/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 209 "../include/osd_util.h"
typedef unsigned char uCHAR;
#line 210 "../include/osd_util.h"
typedef unsigned short uSHORT;
#line 212 "../include/osd_util.h"
typedef unsigned long uLONG;
#line 59 "../include/eng_std.h"
#pragma pack(1)
#line 797
#pragma pack()
#line 38 "../include/dptsig.h"
typedef unsigned char sigBYTE;
#line 39 "../include/dptsig.h"
typedef unsigned short sigWORD;
#line 43 "../include/dptsig.h"
typedef unsigned long sigLONG;
#line 79
#pragma pack(1)
#line 396 "../include/dptsig.h"
struct dpt_sig {
   char dsSignature[6] ;
   sigBYTE dsSigVersion ;
   sigBYTE dsProcessorFamily ;
   sigBYTE dsProcessor ;
   sigBYTE dsFiletype ;
   sigBYTE dsFiletypeFlags ;
   sigBYTE dsOEM ;
   sigLONG dsOS ;
   sigWORD dsCapabilities ;
   sigWORD dsDeviceSupp ;
   sigWORD dsAdapterSupp ;
   sigWORD dsApplication ;
   sigBYTE dsRequirements ;
   sigBYTE dsVersion ;
   sigBYTE dsRevision ;
   sigBYTE dsSubRevision ;
   sigBYTE dsMonth ;
   sigBYTE dsDay ;
   sigBYTE dsYear ;
   char dsDescription[50] ;
};
#line 396 "../include/dptsig.h"
typedef struct dpt_sig dpt_sig_S;
#line 461
#pragma pack()
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 41 "/usr/include/x86_64-linux-gnu/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 103 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
struct __anonstruct_DPT_Semaphore_S_54 {
   char semName[80] ;
   int handle ;
   int semID ;
   int index ;
};
#line 103 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
typedef struct __anonstruct_DPT_Semaphore_S_54 DPT_Semaphore_S;
#line 111 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
union semun {
   int val ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 84 "../include/dpt_scsi.h"
#pragma pack(1)
#line 238 "../include/dpt_scsi.h"
typedef unsigned char scInquiry_S[6];
#line 1282 "../include/dpt_scsi.h"
struct __anonstruct_scFlash_S_24 {
   uCHAR opCode ;
   uCHAR lun ;
   uCHAR action ;
   uLONG address ;
   uLONG length ;
   uCHAR control ;
};
#line 1282 "../include/dpt_scsi.h"
typedef struct __anonstruct_scFlash_S_24 scFlash_S;
#line 2249 "../include/dpt_scsi.h"
typedef unsigned char sdRequestSense_S[8];
#line 3297 "../include/dpt_scsi.h"
struct __anonstruct_modeHeader_S_31 {
   uSHORT dataLength ;
   uCHAR mediumType ;
   uCHAR deviceParam ;
   uCHAR reserved[2] ;
   uSHORT descrLength ;
};
#line 3297 "../include/dpt_scsi.h"
typedef struct __anonstruct_modeHeader_S_31 modeHeader_S;
#line 3390 "../include/dpt_scsi.h"
struct __anonstruct_modeHeader6_S_32 {
   uCHAR dataLength ;
   uCHAR mediumType ;
   uCHAR deviceParam ;
   uCHAR descrLength ;
};
#line 3390 "../include/dpt_scsi.h"
typedef struct __anonstruct_modeHeader6_S_32 modeHeader6_S;
#line 4648 "../include/dpt_scsi.h"
struct __anonstruct_dptFlashStatus_S_42 {
   uCHAR flags1 ;
   uCHAR flags2 ;
   uSHORT fwType ;
   uLONG flashSize ;
   uLONG burnSize ;
   uSHORT programTime ;
   uSHORT eraseTime ;
};
#line 4648 "../include/dpt_scsi.h"
typedef struct __anonstruct_dptFlashStatus_S_42 dptFlashStatus_S;
#line 6850
#pragma pack()
#line 106 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dpt_osd.h"
typedef unsigned char Controller_t;
#line 107 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dpt_osd.h"
typedef void *Status_t;
#line 108 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dpt_osd.h"
typedef sdRequestSense_S *Sense_t;
#line 110 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dpt_osd.h"
typedef void *OutGoing_t;
#line 71 "../include/dpt_eata.h"
#pragma pack(1)
#line 644 "../include/dpt_eata.h"
struct __anonstruct_eataCP_S_55 {
   uCHAR flags ;
   uCHAR reqSenseLen ;
   uCHAR extendedId ;
   uCHAR unUsed[2] ;
   uCHAR nestedFW ;
   uCHAR physical ;
   uCHAR devAddr ;
   uCHAR message[4] ;
   uCHAR scsiCDB[12] ;
   uLONG dataLength ;
   uLONG vCPaddr ;
   uLONG dataAddr ;
   uLONG spAddr ;
   uLONG reqSenseAddr ;
};
#line 644 "../include/dpt_eata.h"
typedef struct __anonstruct_eataCP_S_55 eataCP_S;
#line 1093 "../include/dpt_eata.h"
struct __anonstruct_eataSP_S_56 {
   uCHAR ctlrStatus ;
   uCHAR scsiStatus ;
   uCHAR unUsed1 ;
   uCHAR unUsed2 ;
   uLONG residueLen ;
   uLONG vCPaddr ;
   uCHAR message[12] ;
};
#line 1093 "../include/dpt_eata.h"
typedef struct __anonstruct_eataSP_S_56 eataSP_S;
#line 1158 "../include/dpt_eata.h"
struct __anonstruct_eataSG_S_57 {
   uLONG addr ;
   uLONG length ;
};
#line 1158 "../include/dpt_eata.h"
typedef struct __anonstruct_eataSG_S_57 eataSG_S;
#line 1305
#pragma pack()
#line 50 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odep.h"
typedef unsigned char U8;
#line 51 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odep.h"
typedef unsigned short U16;
#line 53 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odep.h"
typedef unsigned long U32;
#line 110 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odep.h"
typedef U32 BF;
#line 106 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2otypes.h"
struct _U64 {
   U32 LowPart ;
   U32 HighPart ;
};
#line 106 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2otypes.h"
typedef struct _U64 U64;
#line 279 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef U32 I2O_INITIATOR_CONTEXT;
#line 280 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef U32 I2O_TRANSACTION_CONTEXT;
#line 302 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_MESSAGE_FRAME {
   U8 VersionOffset ;
   U8 MsgFlags ;
   U16 MessageSize ;
   BF TargetAddress : 12 ;
   BF InitiatorAddress : 12 ;
   BF Function : 8 ;
   I2O_INITIATOR_CONTEXT InitiatorContext ;
};
#line 302 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_MESSAGE_FRAME I2O_MESSAGE_FRAME;
#line 339 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SINGLE_REPLY_MESSAGE_FRAME {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
   U16 DetailedStatusCode ;
   U8 reserved ;
   U8 ReqStatus ;
};
#line 339 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SINGLE_REPLY_MESSAGE_FRAME I2O_SINGLE_REPLY_MESSAGE_FRAME;
#line 367 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_PRIVATE_MESSAGE_FRAME {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
   U16 XFunctionCode ;
   U16 OrganizationID ;
};
#line 367 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PRIVATE_MESSAGE_FRAME I2O_PRIVATE_MESSAGE_FRAME;
#line 456 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_CLASS_ID {
   BF Class : 12 ;
   BF Version : 4 ;
   BF OrganizationID : 16 ;
};
#line 456 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_CLASS_ID I2O_CLASS_ID;
#line 500 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_PCI_BUS_INFO {
   U8 PciFunctionNumber ;
   U8 PciDeviceNumber ;
   U8 PciBusNumber ;
   U8 reserved ;
   U16 PciVendorID ;
   U16 PciDeviceID ;
};
#line 500 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PCI_BUS_INFO I2O_PCI_BUS_INFO;
#line 510 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_LOCAL_BUS_INFO {
   U16 LbBaseIOPort ;
   U16 reserved ;
   U32 LbBaseMemoryAddress ;
};
#line 510 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_LOCAL_BUS_INFO I2O_LOCAL_BUS_INFO;
#line 517 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_ISA_BUS_INFO {
   U16 IsaBaseIOPort ;
   U8 CSN ;
   U8 reserved ;
   U32 IsaBaseMemoryAddress ;
};
#line 517 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_ISA_BUS_INFO I2O_ISA_BUS_INFO;
#line 525 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_EISA_BUS_INFO {
   U16 EisaBaseIOPort ;
   U8 reserved ;
   U8 EisaSlotNumber ;
   U32 EisaBaseMemoryAddress ;
};
#line 525 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_EISA_BUS_INFO I2O_EISA_BUS_INFO;
#line 533 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_MCA_BUS_INFO {
   U16 McaBaseIOPort ;
   U8 reserved ;
   U8 McaSlotNumber ;
   U32 McaBaseMemoryAddress ;
};
#line 533 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_MCA_BUS_INFO I2O_MCA_BUS_INFO;
#line 541 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_OTHER_BUS_INFO {
   U16 BaseIOPort ;
   U16 reserved ;
   U32 BaseMemoryAddress ;
};
#line 541 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_OTHER_BUS_INFO I2O_OTHER_BUS_INFO;
#line 550 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
union __anonunion_uBus_59 {
   I2O_PCI_BUS_INFO PCIBus ;
   I2O_LOCAL_BUS_INFO LocalBus ;
   I2O_ISA_BUS_INFO ISABus ;
   I2O_EISA_BUS_INFO EISABus ;
   I2O_MCA_BUS_INFO MCABus ;
   I2O_OTHER_BUS_INFO OtherBus ;
};
#line 550 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_HRT_ENTRY {
   U32 AdapterID ;
   BF ControllingTID : 12 ;
   BF AdapterState : 4 ;
   BF BusNumber : 8 ;
   BF BusType : 8 ;
   union __anonunion_uBus_59 uBus ;
};
#line 550 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_HRT_ENTRY I2O_HRT_ENTRY;
#line 550 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_HRT_ENTRY *PI2O_HRT_ENTRY;
#line 584 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_HRT {
   U16 NumberEntries ;
   U8 EntryLength ;
   U8 HRTVersion ;
   U32 CurrentChangeIndicator ;
   I2O_HRT_ENTRY HRTEntry[1] ;
};
#line 584 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_HRT I2O_HRT;
#line 610 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_LCT_ENTRY {
   BF TableEntrySize : 16 ;
   BF LocalTID : 12 ;
   BF reserved : 4 ;
   U32 ChangeIndicator ;
   U32 DeviceFlags ;
   I2O_CLASS_ID ClassID ;
   U32 SubClassInfo ;
   BF UserTID : 12 ;
   BF ParentTID : 12 ;
   BF BiosInfo : 8 ;
   U8 IdentityTag[8] ;
   U32 EventCapabilities ;
};
#line 610 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_LCT_ENTRY I2O_LCT_ENTRY;
#line 636 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_LCT {
   BF TableSize : 16 ;
   BF BootDeviceTID : 12 ;
   BF LctVer : 4 ;
   U32 IopFlags ;
   U32 CurrentChangeIndicator ;
   I2O_LCT_ENTRY LCTEntry[1] ;
};
#line 636 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_LCT I2O_LCT;
#line 775 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_FLAGS_COUNT {
   BF Count : 24 ;
   BF Flags : 8 ;
};
#line 775 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_FLAGS_COUNT I2O_FLAGS_COUNT;
#line 786 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_BIT_BUCKET_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 BufferContext ;
};
#line 786 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_BIT_BUCKET_ELEMENT I2O_SGE_BIT_BUCKET_ELEMENT;
#line 793 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_CHAIN_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 PhysicalAddress ;
};
#line 793 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_CHAIN_ELEMENT I2O_SGE_CHAIN_ELEMENT;
#line 800 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_CHAIN_CONTEXT_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 Context[1] ;
   U32 PhysicalAddress ;
};
#line 800 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_CHAIN_CONTEXT_ELEMENT I2O_SGE_CHAIN_CONTEXT_ELEMENT;
#line 808 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_IGNORE_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
};
#line 808 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_IGNORE_ELEMENT I2O_SGE_IGNORE_ELEMENT;
#line 814 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_IMMEDIATE_DATA_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
};
#line 814 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_IMMEDIATE_DATA_ELEMENT I2O_SGE_IMMEDIATE_DATA_ELEMENT;
#line 820 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_IMMEDIATE_DATA_CONTEXT_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 BufferContext ;
};
#line 820 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_IMMEDIATE_DATA_CONTEXT_ELEMENT I2O_SGE_IMMEDIATE_DATA_CONTEXT_ELEMENT;
#line 827 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_LONG_TRANSACTION_ELEMENT {
   BF LongElementLength : 24 ;
   BF Flags : 8 ;
   U32 BufferContext ;
};
#line 827 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_LONG_TRANSACTION_ELEMENT I2O_SGE_LONG_TRANSACTION_ELEMENT;
#line 839 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_PAGE_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 PhysicalAddress[1] ;
};
#line 839 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_PAGE_ELEMENT I2O_SGE_PAGE_ELEMENT;
#line 846 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_PAGE_CONTEXT_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 BufferContext[1] ;
   U32 PhysicalAddress[1] ;
};
#line 846 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_PAGE_CONTEXT_ELEMENT I2O_SGE_PAGE_CONTEXT_ELEMENT;
#line 854 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_SGL_ATTRIBUTES_ELEMENT {
   U16 SglAttributeFlags ;
   U8 ElementLength ;
   U8 Flags ;
   U32 PageFrameSize ;
};
#line 854 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_SGL_ATTRIBUTES_ELEMENT I2O_SGE_SGL_ATTRIBUTES_ELEMENT;
#line 863 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_SHORT_TRANSACTION_ELEMENT {
   U16 ClassFields ;
   U8 ElementLength ;
   U8 Flags ;
   U32 BufferContext ;
};
#line 863 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_SHORT_TRANSACTION_ELEMENT I2O_SGE_SHORT_TRANSACTION_ELEMENT;
#line 872 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_SIMPLE_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 PhysicalAddress ;
};
#line 872 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_SIMPLE_ELEMENT I2O_SGE_SIMPLE_ELEMENT;
#line 872 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_SIMPLE_ELEMENT *PI2O_SGE_SIMPLE_ELEMENT;
#line 879 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_SIMPLE_CONTEXT_ELEMENT {
   I2O_FLAGS_COUNT FlagsCount ;
   U32 BufferContext[1] ;
   U32 PhysicalAddress ;
};
#line 879 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_SIMPLE_CONTEXT_ELEMENT I2O_SGE_SIMPLE_CONTEXT_ELEMENT;
#line 887 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SGE_TRANSPORT_ELEMENT {
   BF LongElementLength : 24 ;
   BF Flags : 8 ;
};
#line 887 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SGE_TRANSPORT_ELEMENT I2O_SGE_TRANSPORT_ELEMENT;
#line 896 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
union __anonunion_u_60 {
   I2O_SGE_BIT_BUCKET_ELEMENT BitBucket ;
   I2O_SGE_CHAIN_ELEMENT Chain ;
   I2O_SGE_CHAIN_CONTEXT_ELEMENT ChainContext ;
   I2O_SGE_IGNORE_ELEMENT Ignore ;
   I2O_SGE_IMMEDIATE_DATA_ELEMENT ImmediateData ;
   I2O_SGE_IMMEDIATE_DATA_CONTEXT_ELEMENT ImmediateDataContext ;
   I2O_SGE_LONG_TRANSACTION_ELEMENT LongTransaction ;
   I2O_SGE_PAGE_ELEMENT Page ;
   I2O_SGE_PAGE_CONTEXT_ELEMENT PageContext ;
   I2O_SGE_SGL_ATTRIBUTES_ELEMENT SGLAttribute ;
   I2O_SGE_SHORT_TRANSACTION_ELEMENT ShortTransaction ;
   I2O_SGE_SIMPLE_ELEMENT Simple[1] ;
   I2O_SGE_SIMPLE_CONTEXT_ELEMENT SimpleContext[1] ;
   I2O_SGE_TRANSPORT_ELEMENT Transport ;
};
#line 896 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_SG_ELEMENT {
   union __anonunion_u_60 u ;
};
#line 896 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_SG_ELEMENT I2O_SG_ELEMENT;
#line 966 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_PARAM_OPERATIONS_LIST_HEADER {
   U16 OperationCount ;
   U16 Reserved ;
};
#line 966 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PARAM_OPERATIONS_LIST_HEADER I2O_PARAM_OPERATIONS_LIST_HEADER;
#line 973 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_PARAM_RESULTS_LIST_HEADER {
   U16 ResultCount ;
   U16 Reserved ;
};
#line 973 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PARAM_RESULTS_LIST_HEADER I2O_PARAM_RESULTS_LIST_HEADER;
#line 973 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PARAM_RESULTS_LIST_HEADER *PI2O_PARAM_RESULTS_LIST_HEADER;
#line 980 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_PARAM_READ_OPERATION_RESULT {
   U16 BlockSize ;
   U8 BlockStatus ;
   U8 ErrorInfoSize ;
};
#line 980 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PARAM_READ_OPERATION_RESULT I2O_PARAM_READ_OPERATION_RESULT;
#line 1024 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_PARAM_OPERATION_ALL_TEMPLATE {
   U16 Operation ;
   U16 GroupNumber ;
   U16 FieldCount ;
};
#line 1024 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_PARAM_OPERATION_ALL_TEMPLATE I2O_PARAM_OPERATION_ALL_TEMPLATE;
#line 1175 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
struct _I2O_UTIL_DDM_IDENTITY_SCALAR {
   U16 DdmTID ;
   U8 ModuleName[24] ;
   U8 ModuleRevLevel[8] ;
   U8 SNFormat ;
   U8 SerialNumber[256] ;
};
#line 1175 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2omsg.h"
typedef struct _I2O_UTIL_DDM_IDENTITY_SCALAR I2O_UTIL_DDM_IDENTITY_SCALAR;
#line 423 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2obscsi.h"
struct _I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME {
   I2O_SINGLE_REPLY_MESSAGE_FRAME StdReplyFrame ;
   U32 TransferCount ;
   U32 AutoSenseTransferCount ;
   U8 SenseData[40] ;
};
#line 423 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2obscsi.h"
typedef struct _I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME;
#line 458 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2obscsi.h"
typedef U16 I2O_SCB_FLAGS;
#line 39 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
struct _PRIVATE_SCSI_SCB_EXECUTE_MESSAGE {
   I2O_PRIVATE_MESSAGE_FRAME PrivateMessageFrame ;
   BF TID : 16 ;
   BF Interpret : 1 ;
   BF Physical : 1 ;
   BF Reserved1 : 14 ;
   U8 CDBLength ;
   U8 Reserved ;
   I2O_SCB_FLAGS SCBFlags ;
   U8 CDB[16] ;
   U32 ByteCount ;
   I2O_SG_ELEMENT SGL ;
};
#line 39 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
typedef struct _PRIVATE_SCSI_SCB_EXECUTE_MESSAGE PRIVATE_SCSI_SCB_EXECUTE_MESSAGE;
#line 39 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
typedef struct _PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE;
#line 89 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
struct _PRIVATE_FLASH_REGION_MESSAGE {
   I2O_PRIVATE_MESSAGE_FRAME PrivateMessageFrame ;
   U32 FlashRegion ;
   U32 RegionOffset ;
   U32 ByteCount ;
   I2O_SG_ELEMENT SGL ;
};
#line 89 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
typedef struct _PRIVATE_FLASH_REGION_MESSAGE PRIVATE_FLASH_REGION_MESSAGE;
#line 193 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
struct _I2O_DPT_DEVICE_INFO_SCALAR {
   U8 DeviceType ;
   U8 Flags ;
   U16 Bus ;
   U32 Identifier ;
   U8 LunInfo[8] ;
};
#line 193 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2odpt.h"
typedef struct _I2O_DPT_DEVICE_INFO_SCALAR I2O_DPT_DEVICE_INFO_SCALAR;
#line 112 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.h"
struct __anonstruct_TID_t_61 {
   unsigned short TID : 12 ;
   unsigned short Bus : 3 ;
   unsigned short RAID : 1 ;
   unsigned short UserTID : 12 ;
   unsigned short Adapter : 1 ;
   unsigned short SCSI : 1 ;
   unsigned short Lun : 8 ;
   unsigned short Target : 7 ;
};
#line 112 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.h"
typedef struct __anonstruct_TID_t_61 TID_t;
#line 338 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2outil.h"
struct _I2O_UTIL_NOP_MESSAGE {
   I2O_MESSAGE_FRAME StdMessageFrame ;
};
#line 338 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2outil.h"
typedef struct _I2O_UTIL_NOP_MESSAGE I2O_UTIL_NOP_MESSAGE;
#line 347 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2outil.h"
struct _I2O_UTIL_PARAMS_GET_MESSAGE {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
   U32 OperationFlags ;
   I2O_SG_ELEMENT SGL ;
};
#line 347 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2outil.h"
typedef struct _I2O_UTIL_PARAMS_GET_MESSAGE I2O_UTIL_PARAMS_GET_MESSAGE;
#line 347 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2outil.h"
typedef struct _I2O_UTIL_PARAMS_GET_MESSAGE *PI2O_UTIL_PARAMS_GET_MESSAGE;
#line 522 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oexec.h"
struct _I2O_EXEC_HRT_GET_MESSAGE {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
   I2O_SG_ELEMENT SGL ;
};
#line 522 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oexec.h"
typedef struct _I2O_EXEC_HRT_GET_MESSAGE I2O_EXEC_HRT_GET_MESSAGE;
#line 622 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oexec.h"
struct _I2O_EXEC_LCT_NOTIFY_MESSAGE {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
   U32 ClassIdentifier ;
   U32 LastReportedChangeIndicator ;
   I2O_SG_ELEMENT SGL ;
};
#line 622 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oexec.h"
typedef struct _I2O_EXEC_LCT_NOTIFY_MESSAGE I2O_EXEC_LCT_NOTIFY_MESSAGE;
#line 275 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oadptr.h"
struct _I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR {
   U8 SCSIType ;
   U8 ProtectionManagement ;
   U8 Settings ;
   U8 Reserved1 ;
   U32 InitiatorID ;
   U64 ScanLun0Only ;
   U16 DisableDevice ;
   U8 MaxOffset ;
   U8 MaxDataWidth ;
   U64 MaxSyncRate ;
};
#line 275 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oadptr.h"
typedef struct _I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR;
#line 378 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oadptr.h"
struct _I2O_HBA_BUS_RESET_MESSAGE {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
};
#line 378 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oadptr.h"
typedef struct _I2O_HBA_BUS_RESET_MESSAGE I2O_HBA_BUS_RESET_MESSAGE;
#line 390 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oadptr.h"
struct _I2O_HBA_BUS_SCAN_MESSAGE {
   I2O_MESSAGE_FRAME StdMessageFrame ;
   I2O_TRANSACTION_CONTEXT TransactionContext ;
};
#line 390 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/i2oadptr.h"
typedef struct _I2O_HBA_BUS_SCAN_MESSAGE I2O_HBA_BUS_SCAN_MESSAGE;
#line 79 "../include/dptsig.h"
#pragma pack(1)
#line 461
#pragma pack()
#line 465 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct convertCallback {
   void (*callback)(Controller_t controller , Status_t status , Sense_t sense ) ;
   unsigned long VCPaddr ;
   eataSP_S *status ;
   sdRequestSense_S *sense ;
   unsigned short senseLength ;
};
#line 731 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_DPTI_HRT_62 {
   I2O_HRT header ;
   char data[sizeof(I2O_HRT_ENTRY ) * 7UL] ;
};
#line 731 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
typedef struct __anonstruct_DPTI_HRT_62 DPTI_HRT;
#line 736 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_tid_65 {
   TID_t data[1] ;
};
#line 736 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_lct_66 {
   I2O_LCT header ;
   I2O_LCT_ENTRY data[1] ;
};
#line 736 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
union __anonunion_devices_64 {
   struct __anonstruct_tid_65 tid ;
   struct __anonstruct_lct_66 lct ;
};
#line 736 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_DPTI_Devices_S_63 {
   unsigned short size ;
   Controller_t controller ;
   unsigned short numDevices ;
   unsigned char maxBus : 3 ;
   unsigned char valid : 1 ;
   unsigned char changed : 1 ;
   unsigned char flashMode : 1 ;
   unsigned char enableRescan : 1 ;
   unsigned char MIPS : 1 ;
   unsigned char maxLun ;
   unsigned char raidNum ;
   unsigned char adapterID[8] ;
   unsigned long lastScan ;
   union __anonunion_devices_64 devices ;
};
#line 736 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
typedef struct __anonstruct_DPTI_Devices_S_63 DPTI_Devices_S;
#line 971 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct LogPage {
   PRIVATE_SCSI_SCB_EXECUTE_MESSAGE Message ;
   char Buffer[255] ;
};
#line 1302 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct ParamOperations {
   I2O_PARAM_OPERATIONS_LIST_HEADER Header ;
   I2O_PARAM_OPERATION_ALL_TEMPLATE Template[1] ;
};
#line 1308 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct ParamGetMessage {
   I2O_UTIL_PARAMS_GET_MESSAGE M ;
   unsigned char fill[sizeof(I2O_SGE_SIMPLE_ELEMENT ) * 2UL - sizeof(I2O_SG_ELEMENT )] ;
};
#line 1449 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_Buffer_67 {
   I2O_PARAM_RESULTS_LIST_HEADER Header ;
   I2O_PARAM_READ_OPERATION_RESULT Read ;
   I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR Info ;
};
#line 1468 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_Buffer_68 {
   I2O_PARAM_RESULTS_LIST_HEADER Header ;
   I2O_PARAM_READ_OPERATION_RESULT Read ;
   I2O_DPT_DEVICE_INFO_SCALAR Info ;
};
#line 1496 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct Inquiry {
   PRIVATE_SCSI_SCB_EXECUTE_MESSAGE Message ;
   char Buffer[48] ;
};
#line 2408 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct FlashRegionMessage {
   PRIVATE_FLASH_REGION_MESSAGE M ;
   unsigned char fill[4UL * sizeof(I2O_SGE_SIMPLE_ELEMENT ) - sizeof(I2O_SG_ELEMENT )] ;
};
#line 3479 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct PrivateScbMessage {
   PRIVATE_SCSI_SCB_EXECUTE_MESSAGE i2o ;
   unsigned char fill[sizeof(I2O_SGE_SIMPLE_ELEMENT ) * 2UL - sizeof(I2O_SG_ELEMENT )] ;
};
#line 3603 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct __anonstruct_Buffer_69 {
   I2O_PARAM_RESULTS_LIST_HEADER Header ;
   I2O_PARAM_READ_OPERATION_RESULT Read ;
   I2O_UTIL_DDM_IDENTITY_SCALAR Info ;
};
#line 4474 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
struct PrivateScsiScbMessage {
   PRIVATE_SCSI_SCB_EXECUTE_MESSAGE i2o ;
   unsigned char fill[sizeof(I2O_SGE_SIMPLE_ELEMENT ) * 2UL - sizeof(I2O_SG_ELEMENT )] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 59 "../include/eng_std.h"
#pragma pack(1)
#line 89 "../include/eng_std.h"
typedef unsigned long DPT_TAG_T;
#line 91 "../include/eng_std.h"
typedef unsigned long DPT_MSG_T;
#line 93 "../include/eng_std.h"
typedef unsigned long DPT_RTN_T;
#line 797
#pragma pack()
#line 329 "../include/osd_unix.h"
struct __anonstruct_MsgHdr_48 {
   uLONG MsgID ;
   DPT_TAG_T engineTag ;
   DPT_TAG_T targetTag ;
   DPT_MSG_T engEvent ;
   long BufferID ;
   uLONG FromEngBuffOffset ;
   uLONG callerID ;
   DPT_RTN_T result ;
   uLONG timeOut ;
};
#line 329 "../include/osd_unix.h"
typedef struct __anonstruct_MsgHdr_48 MsgHdr;
#line 32 "/usr/include/x86_64-linux-gnu/bits/msq.h"
typedef __syscall_ulong_t msgqnum_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/msq.h"
typedef __syscall_ulong_t msglen_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/msq.h"
struct msqid_ds {
   struct ipc_perm msg_perm ;
   __time_t msg_stime ;
   __time_t msg_rtime ;
   __time_t msg_ctime ;
   __syscall_ulong_t __msg_cbytes ;
   msgqnum_t msg_qnum ;
   msglen_t msg_qbytes ;
   __pid_t msg_lspid ;
   __pid_t msg_lrpid ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 130 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/engmsg.c"
struct msgbuf;
#line 211 "../include/osd_util.h"
typedef unsigned int uINT;
#line 59 "../include/eng_std.h"
#pragma pack(1)
#line 797
#pragma pack()
#line 60 "../include/dpt_buff.h"
#pragma pack(1)
#line 77 "../include/dpt_buff.h"
struct __anonstruct_dptData_S_36 {
   uLONG commID ;
   uLONG allocSize ;
   uLONG writeIndex ;
   uLONG readIndex ;
   uCHAR data[1] ;
};
#line 77 "../include/dpt_buff.h"
typedef struct __anonstruct_dptData_S_36 dptData_S;
#line 231
#pragma pack()
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 222 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
struct __anonstruct_fileStat_28 {
   struct stat s ;
   unsigned short x ;
};
#line 59 "../include/eng_std.h"
#pragma pack(1)
#line 797
#pragma pack()
#line 222 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
struct __anonstruct_fileStat_28___0 {
   struct stat s ;
   unsigned short x ;
};
#line 59 "../include/eng_std.h"
#pragma pack(1)
#line 797
#pragma pack()
#line 36 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufio.h"
struct iobuf {
   unsigned char mask ;
   int rack ;
   int numbufs ;
   int curbuf ;
   long bufptr ;
   char *buf[23] ;
};
#line 36 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufio.h"
typedef struct iobuf IOBUF;
#line 222 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
struct __anonstruct_fileStat_28___1 {
   struct stat s ;
   unsigned short x ;
};
#line 59 "../include/eng_std.h"
#pragma pack(1)
#line 797
#pragma pack()
#line 59
#pragma pack(1)
#line 797
#pragma pack()
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern int getchar(void) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 81 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
char *strupr(char *String ) 
{ 
  int i ;
  int tmp ;

  {
#line 85
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! ((int )*(String + i) != 0)) {
#line 86
      goto while_break;
    }
    {
#line 88
    tmp = toupper((int )*(String + i));
#line 88
    *(String + i) = (char )tmp;
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return (String);
}
}
#line 105 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
char *strlwr(char *String ) 
{ 
  int i ;
  int tmp ;

  {
#line 109
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((int )*(String + i) != 0)) {
#line 110
      goto while_break;
    }
    {
#line 112
    tmp = tolower((int )*(String + i));
#line 112
    *(String + i) = (char )tmp;
#line 113
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (String);
}
}
#line 133 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
int stricmp(char *String1 , char *String2 ) 
{ 
  int Len1 ;
  int Len2 ;
  int Rtnval ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 137
  tmp = strlen((char const   *)String1);
#line 137
  Len1 = (int )tmp;
#line 138
  tmp___0 = strlen((char const   *)String2);
#line 138
  Len2 = (int )tmp___0;
  }
#line 142
  if (Len1 != Len2) {
#line 147
    if (Len1 > Len2) {
#line 148
      Rtnval = 1;
    } else {
#line 152
      Rtnval = -1;
    }
  } else {
#line 158
    i = 0;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
#line 158
      if (! (i < Len1)) {
#line 158
        goto while_break;
      }
      {
#line 160
      tmp___1 = toupper((int )*(String1 + i));
#line 160
      tmp___2 = toupper((int )*(String2 + i));
      }
#line 160
      if (tmp___1 != tmp___2) {
#line 161
        goto while_break;
      }
#line 158
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 166
    if (i < Len1) {
#line 167
      Rtnval = (int )*(String1 + i) - (int )*(String2 + i);
    } else {
#line 168
      Rtnval = 0;
    }
  }
#line 170
  return (Rtnval);
}
}
#line 188 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
int strnicmp(char *s1 , char *s2 , int maxlen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (maxlen > 0) {
#line 191
      if (! ((int )*s1 != 0)) {
#line 191
        goto while_break;
      }
    } else {
#line 191
      goto while_break;
    }
    {
#line 194
    tmp = toupper((int )*s1);
#line 194
    tmp___0 = toupper((int )*s2);
    }
#line 194
    if (tmp != tmp___0) {
#line 195
      return ((int )*s2 - (int )*s1);
    }
#line 198
    maxlen --;
#line 199
    if (maxlen > 0) {
#line 201
      s1 ++;
#line 202
      s2 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  tmp___1 = toupper((int )*s1);
#line 206
  tmp___2 = toupper((int )*s2);
  }
#line 206
  if (tmp___1 != tmp___2) {
#line 207
    return ((int )*s2 - (int )*s1);
  } else {
#line 209
    return (0);
  }
}
}
#line 233 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
char *strnset(char *str_P , char c , int n ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 235
  tmp___0 = strlen((char const   *)str_P);
  }
#line 235
  if (tmp___0 < (size_t )n) {
    {
#line 236
    tmp = strlen((char const   *)str_P);
#line 236
    n = (int )tmp;
    }
  }
#line 238
  n --;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (n > -1)) {
#line 240
      goto while_break;
    }
#line 241
    tmp___1 = n;
#line 241
    n --;
#line 241
    *(str_P + tmp___1) = c;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (str_P);
}
}
#line 269 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
int strcmpi(char *str1_P , char *str2_P ) 
{ 
  int tmp ;

  {
  {
#line 272
  tmp = stricmp(str1_P, str2_P);
  }
#line 272
  return (tmp);
}
}
#line 296 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
uCHAR AsciiDigetsToHexByte(char *String ) 
{ 
  uCHAR i ;
  uCHAR j ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 302
  i = (uCHAR )*(String + 0);
#line 303
  tmp___0 = __ctype_b_loc();
  }
#line 303
  if ((int const   )*(*tmp___0 + (int )i) & 2048) {
#line 304
    i = (uCHAR )((int )i - 48);
  } else {
    {
#line 305
    tmp = toupper((int )i);
#line 305
    i = (uCHAR )((tmp - 65) + 10);
    }
  }
  {
#line 306
  i = (uCHAR )((int )i << 4);
#line 310
  j = (uCHAR )*(String + 1);
#line 311
  tmp___2 = __ctype_b_loc();
  }
#line 311
  if ((int const   )*(*tmp___2 + (int )j) & 2048) {
#line 312
    j = (uCHAR )((int )j - 48);
  } else {
    {
#line 313
    tmp___1 = toupper((int )j);
#line 313
    j = (uCHAR )((tmp___1 - 65) + 10);
    }
  }
#line 314
  i = (uCHAR )((int )i | (int )j);
#line 315
  return (i);
}
}
#line 332 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
void InvertBytes(uCHAR *Source , uCHAR *Dest , uSHORT InvertCount ) 
{ 
  uSHORT i ;
  uSHORT tmp ;

  {
#line 336
  i = (uSHORT )0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    tmp = i;
#line 338
    i = (uSHORT )((int )i + 1);
#line 338
    InvertCount = (uSHORT )((int )InvertCount - 1);
#line 338
    *(Dest + tmp) = *(Source + InvertCount);
#line 337
    if (! InvertCount) {
#line 337
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return;
}
}
#line 356 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
char *LongToAscii(uLONG Value , char *String , uSHORT Base ) 
{ 
  uLONG i ;
  uLONG j ;
  char Str[80] ;

  {
#line 363
  if (Value == 0UL) {
#line 365
    *(String + 0) = (char )'0';
#line 366
    *(String + 1) = (char )'\000';
  } else {
#line 373
    i = (uLONG )0;
    {
#line 374
    while (1) {
      while_continue: /* CIL Label */ ;
#line 374
      if (! Value) {
#line 374
        goto while_break;
      }
#line 376
      j = Value % (unsigned long )Base;
#line 380
      if (j >= 10UL) {
#line 381
        Str[i] = (char )(65 + (int )((char )(j - 10UL)));
      } else {
#line 382
        Str[i] = (char )(48 + (int )((char )j));
      }
#line 383
      i ++;
#line 384
      Value /= (uLONG )Base;
    }
    while_break: /* CIL Label */ ;
    }
#line 386
    Str[i] = (char )'\000';
#line 390
    j = (uLONG )0;
    {
#line 390
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 390
      if (! (j < i)) {
#line 390
        goto while_break___0;
      }
#line 391
      *(String + j) = Str[(i - j) - 1UL];
#line 390
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 392
    *(String + i) = (char )'\000';
  }
#line 394
  return (String);
}
}
#line 409 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/funcs.c"
void dptr_PrintMem(uCHAR *Addr , int Count ) 
{ 
  int Offset ;
  int i ;
  int NumLines ;

  {
#line 413
  Offset = 0;
#line 414
  NumLines = 0;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! (Offset < Count)) {
#line 418
      goto while_break;
    }
    {
#line 423
    printf((char const   */* __restrict  */)"\n%.8X  ", Offset);
#line 427
    i = 0;
    }
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 427
      if (! (i < 16)) {
#line 427
        goto while_break___0;
      }
#line 429
      if (Offset + i >= Count) {
        {
#line 430
        printf((char const   */* __restrict  */)"   ");
        }
      } else {
        {
#line 431
        printf((char const   */* __restrict  */)"%.2X ", (int )*(Addr + (Offset + i)));
        }
      }
#line 432
      if (i == 7) {
        {
#line 433
        printf((char const   */* __restrict  */)"- ");
        }
      }
#line 427
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 438
    printf((char const   */* __restrict  */)"  ");
#line 439
    i = 0;
    }
    {
#line 439
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 439
      if (! (i < 16)) {
#line 439
        goto while_break___1;
      }
#line 441
      if (Offset + i >= Count) {
#line 442
        goto while_break___1;
      }
#line 443
      if ((int )*(Addr + (Offset + i)) > 31) {
#line 443
        if ((int )*(Addr + (Offset + i)) < 127) {
          {
#line 444
          printf((char const   */* __restrict  */)"%c", (int )*(Addr + (Offset + i)));
          }
        } else {
          {
#line 445
          printf((char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 445
        printf((char const   */* __restrict  */)".");
        }
      }
#line 439
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 450
    Offset += 16;
#line 451
    NumLines ++;
#line 452
    if (NumLines >= 20) {
      {
#line 454
      getchar();
#line 455
      NumLines = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eng_sig.c"
dpt_sig_S engineSig  = 
#line 64 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eng_sig.c"
     {{(char )'d', (char )'P', (char )'t', (char )'S', (char )'i', (char )'G'}, (sigBYTE )1,
    (sigBYTE )0, (sigBYTE )28, (sigBYTE )5, (sigBYTE )0, (sigBYTE )0, (sigLONG )16777216,
    (sigWORD )0, (sigWORD )65535, (sigWORD )14, (sigWORD )0, (sigBYTE )0, (sigBYTE )3,
    (sigBYTE )'3', (sigBYTE )'1', (sigBYTE )8, (sigBYTE )12, (sigBYTE )22, {(char )'A',
                                                                            (char )'d',
                                                                            (char )'a',
                                                                            (char )'p',
                                                                            (char )'t',
                                                                            (char )'e',
                                                                            (char )'c',
                                                                            (char )' ',
                                                                            (char )'L',
                                                                            (char )'I',
                                                                            (char )'N',
                                                                            (char )'U',
                                                                            (char )'X',
                                                                            (char )' ',
                                                                            (char )'S',
                                                                            (char )'C',
                                                                            (char )'S',
                                                                            (char )'I',
                                                                            (char )' ',
                                                                            (char )'E',
                                                                            (char )'n',
                                                                            (char )'g',
                                                                            (char )'i',
                                                                            (char )'n',
                                                                            (char )'e',
                                                                            (char )'\000'}};
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/ipc.h"
extern  __attribute__((__nothrow__)) key_t ( __attribute__((__leaf__)) ftok)(char const   *__pathname ,
                                                                             int __proj_id ) ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/sem.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semctl)(int __semid ,
                                                                             int __semnum ,
                                                                             int __cmd 
                                                                             , ...) ;
#line 55
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semget)(key_t __key ,
                                                                             int __nsems ,
                                                                             int __semflg ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semop)(int __semid ,
                                                                            struct sembuf *__sops ,
                                                                            size_t __nsops ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 337 "../include/osd_util.h"
unsigned int *osdCreateNamedSemaphore(char *name ) ;
#line 339
unsigned int *osdCreateSemaphore(void) ;
#line 341
unsigned int *osdCreateEventSemaphore(void) ;
#line 343
unsigned int *osdCreateNamedEventSemaphore(char *name ) ;
#line 346
uSHORT osdDestroySemaphore(unsigned int *semHandle ) ;
#line 348
uLONG osdRequestSemaphore(unsigned int *semHandle , uLONG timeout ) ;
#line 350
uSHORT osdReleaseSemaphore(unsigned int *semHandle ) ;
#line 352
uLONG osdWaitForEventSemaphore(unsigned int *semHandle , uLONG timeout ) ;
#line 354
uLONG osdSignalEventSemaphore(unsigned int *semHandle ) ;
#line 356
uLONG osdResetEventSemaphore(unsigned int *semHandle ) ;
#line 118 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
static char LocalSemaphoreName[80]  = {      (char )'\000'};
#line 119 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
static int LocalSemaphoreInUse[10]  ;
#line 120 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
static int LocalSemID  =    -1;
#line 122
extern int Verbose ;
#line 149 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
static unsigned int *privateCreateNamedSemaphore(char *name , int initialValue ) 
{ 
  DPT_Semaphore_S *rtnVal ;
  int iAmFirst ;
  key_t key ;
  union semun arg ;
  struct flock lock ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 152
  iAmFirst = 0;
#line 157
  tmp = malloc(sizeof(DPT_Semaphore_S ));
#line 157
  rtnVal = (DPT_Semaphore_S *)tmp;
  }
#line 159
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
    {
#line 164
    rtnVal->handle = open((char const   *)name, 66, 448 | (448 >> 3));
    }
#line 165
    if (rtnVal->handle < 0) {
      {
#line 166
      free((void *)rtnVal);
#line 167
      rtnVal = (DPT_Semaphore_S *)((void *)0);
      }
    }
  }
#line 171
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
    {
#line 173
    strcpy((char */* __restrict  */)(rtnVal->semName), (char const   */* __restrict  */)name);
#line 174
    rtnVal->index = 0;
#line 182
    lock.l_type = (short)1;
#line 183
    lock.l_whence = (short)0;
#line 184
    lock.l_start = (__off_t )0;
#line 185
    lock.l_len = (__off_t )0;
#line 187
    tmp___3 = fcntl(rtnVal->handle, 6, & lock);
    }
#line 187
    if (tmp___3 != 0) {
      {
#line 188
      tmp___1 = __errno_location();
      }
#line 188
      if (*tmp___1 != 13) {
        {
#line 188
        tmp___2 = __errno_location();
        }
#line 188
        if (*tmp___2 != 11) {
          {
#line 189
          close(rtnVal->handle);
#line 190
          free((void *)rtnVal);
#line 191
          rtnVal = (DPT_Semaphore_S *)((void *)0);
          }
        } else {
#line 188
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 195
        lock.l_type = (short)0;
#line 197
        tmp___0 = fcntl(rtnVal->handle, 7, & lock);
        }
#line 197
        if (tmp___0 != 0) {
          {
#line 198
          close(rtnVal->handle);
#line 199
          free((void *)rtnVal);
#line 200
          rtnVal = (DPT_Semaphore_S *)((void *)0);
          }
        }
      }
    } else {
#line 204
      iAmFirst = 1;
    }
  }
#line 208
  lock.l_type = (short)2;
#line 210
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
    {
#line 214
    key = ftok((char const   *)(rtnVal->semName), 'D');
    }
#line 216
    if (key == -1) {
      {
#line 217
      fcntl(rtnVal->handle, 7, & lock);
#line 218
      close(rtnVal->handle);
#line 219
      free((void *)rtnVal);
#line 220
      rtnVal = (DPT_Semaphore_S *)((void *)0);
      }
    }
  }
#line 224
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
    {
#line 229
    rtnVal->semID = semget(key, 1, 960 | (448 >> 3));
    }
#line 231
    if (rtnVal->semID == -1) {
#line 232
      if (Verbose) {
        {
#line 233
        perror("\nprivateCreateNamedSemaphore");
        }
      }
      {
#line 235
      fcntl(rtnVal->handle, 7, & lock);
#line 236
      close(rtnVal->handle);
#line 237
      free((void *)rtnVal);
#line 238
      rtnVal = (DPT_Semaphore_S *)((void *)0);
      }
    }
  }
#line 245
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
#line 245
    if (iAmFirst) {
      {
#line 247
      arg.val = initialValue;
#line 249
      tmp___5 = semctl(rtnVal->semID, rtnVal->index, 16, arg);
      }
#line 249
      if (tmp___5 != 0) {
        {
#line 251
        semctl(rtnVal->semID, 0, 0, arg);
#line 252
        fcntl(rtnVal->handle, 7, & lock);
#line 253
        close(rtnVal->handle);
#line 254
        free((void *)rtnVal);
#line 255
        rtnVal = (DPT_Semaphore_S *)((void *)0);
        }
      } else {
        {
#line 259
        lock.l_type = (short)0;
#line 261
        tmp___4 = fcntl(rtnVal->handle, 6, & lock);
        }
#line 261
        if (tmp___4 != 0) {
          {
#line 263
          semctl(rtnVal->semID, 0, 0, arg);
#line 264
          close(rtnVal->handle);
#line 265
          free((void *)rtnVal);
#line 266
          rtnVal = (DPT_Semaphore_S *)((void *)0);
          }
        }
      }
    }
  }
#line 271
  return ((unsigned int *)rtnVal);
}
}
#line 315
extern char **Argv ;
#line 300 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
static unsigned int *privateCreateUnnamedSemaphore(int initialValue ) 
{ 
  DPT_Semaphore_S *rtnVal ;
  union semun arg ;
  int i ;
  key_t key ;
  char *name ;
  int handle ;
  void *tmp ;
  int tmp___0 ;

  {
#line 306
  if (LocalSemID == -1) {
#line 311
    key = 0;
#line 313
    if ((int )LocalSemaphoreName[0] == 0) {
#line 319
      name = *(Argv + 0);
#line 321
      if ((unsigned long )name != (unsigned long )((void *)0)) {
        {
#line 322
        name = strrchr((char const   *)name, '/');
        }
#line 323
        if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 324
          name ++;
        } else {
#line 326
          name = *(Argv + 0);
        }
      }
#line 329
      if ((unsigned long )name != (unsigned long )((void *)0)) {
        {
#line 330
        strcpy((char */* __restrict  */)(LocalSemaphoreName), (char const   */* __restrict  */)"/tmp/");
#line 331
        strcat((char */* __restrict  */)(LocalSemaphoreName), (char const   */* __restrict  */)name);
#line 332
        strcat((char */* __restrict  */)(LocalSemaphoreName), (char const   */* __restrict  */)"_unnamed");
#line 334
        handle = open((char const   *)(LocalSemaphoreName), 66, 0);
        }
#line 336
        if (handle < 0) {
#line 337
          LocalSemaphoreName[0] = (char )'\000';
        } else {
          {
#line 339
          close(handle);
#line 340
          key = ftok((char const   *)(LocalSemaphoreName), 'D');
          }
#line 342
          if (key == -1) {
#line 343
            LocalSemaphoreName[0] = (char )'\000';
#line 344
            key = 0;
          }
        }
      }
    }
    {
#line 353
    LocalSemID = semget(key, 10, 512);
    }
#line 355
    if (LocalSemID == -1) {
#line 357
      if (Verbose) {
        {
#line 358
        perror("\nprivateCreateUnnamedSemaphore");
        }
      }
#line 360
      return ((unsigned int *)((void *)0));
    }
#line 363
    i = 0;
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
#line 363
      if (! (i < 10)) {
#line 363
        goto while_break;
      }
#line 364
      LocalSemaphoreInUse[i] = 0;
#line 363
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 367
  i = 0;
  {
#line 367
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 367
    if (i < 10) {
#line 367
      if (! LocalSemaphoreInUse[i]) {
#line 367
        goto while_break___0;
      }
    } else {
#line 367
      goto while_break___0;
    }
#line 367
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  if (i == 10) {
#line 373
    if (Verbose) {
      {
#line 374
      printf((char const   */* __restrict  */)"\nToo many unnamed semaphores!");
      }
    }
#line 376
    return ((unsigned int *)((void *)0));
  }
  {
#line 379
  tmp = malloc(sizeof(DPT_Semaphore_S ));
#line 379
  rtnVal = (DPT_Semaphore_S *)tmp;
  }
#line 381
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
#line 383
    LocalSemaphoreInUse[i] = 1;
#line 385
    rtnVal->semName[0] = (char )'\000';
#line 386
    rtnVal->semID = LocalSemID;
#line 387
    rtnVal->handle = -1;
#line 388
    rtnVal->index = i;
  }
#line 393
  if ((unsigned long )rtnVal != (unsigned long )((void *)0)) {
    {
#line 395
    arg.val = initialValue;
#line 397
    tmp___0 = semctl(LocalSemID, rtnVal->index, 16, arg);
    }
#line 397
    if (tmp___0 != 0) {
      {
#line 398
      LocalSemaphoreInUse[rtnVal->index] = 0;
#line 399
      free((void *)rtnVal);
#line 400
      rtnVal = (DPT_Semaphore_S *)((void *)0);
      }
    }
  }
#line 404
  return ((unsigned int *)rtnVal);
}
}
#line 430 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
unsigned int *osdCreateSemaphore(void) 
{ 
  unsigned int *rtnVal ;

  {
  {
#line 434
  rtnVal = privateCreateUnnamedSemaphore(0);
  }
#line 436
  if (Verbose) {
    {
#line 437
    printf((char const   */* __restrict  */)"\nosdCreateSemaphore   : Rtn = %lx",
           (unsigned long )rtnVal);
    }
  }
#line 439
  return (rtnVal);
}
}
#line 467 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
unsigned int *osdCreateNamedSemaphore(char *name ) 
{ 
  char temp[80] ;
  unsigned int *rtnVal ;

  {
  {
#line 472
  strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)"/tmp/");
#line 473
  strcat((char */* __restrict  */)(temp), (char const   */* __restrict  */)name);
#line 475
  rtnVal = privateCreateNamedSemaphore(temp, 0);
  }
#line 477
  if (Verbose) {
    {
#line 478
    printf((char const   */* __restrict  */)"\nosdCreateNamedSemaphore   : Rtn = %lx",
           (unsigned long )rtnVal);
    }
  }
#line 480
  return (rtnVal);
}
}
#line 509 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
uSHORT osdDestroySemaphore(unsigned int *semHandle ) 
{ 
  DPT_Semaphore_S *sem ;
  uSHORT rtnVal ;
  int i ;
  union semun arg ;
  int tmp ;
  struct flock lock ;
  union semun arg___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 511
  sem = (DPT_Semaphore_S *)semHandle;
#line 512
  rtnVal = (uSHORT )0;
#line 514
  if ((int )sem->semName[0] == 0) {
#line 520
    if (sem->index < 10) {
#line 521
      LocalSemaphoreInUse[sem->index] = 0;
    }
#line 526
    i = 0;
    {
#line 526
    while (1) {
      while_continue: /* CIL Label */ ;
#line 526
      if (i < 10) {
#line 526
        if (! (! LocalSemaphoreInUse[i])) {
#line 526
          goto while_break;
        }
      } else {
#line 526
        goto while_break;
      }
#line 526
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 530
    if (i == 10) {
      {
#line 535
      arg.val = 0;
#line 536
      tmp = semctl(LocalSemID, 0, 0, arg);
#line 536
      rtnVal = (uSHORT )(tmp != 0);
      }
#line 538
      if ((int )rtnVal == 0) {
        {
#line 539
        LocalSemID = -1;
#line 540
        unlink((char const   *)(LocalSemaphoreName));
        }
      }
    }
  } else {
    {
#line 554
    lock.l_type = (short)1;
#line 555
    lock.l_whence = (short)0;
#line 556
    lock.l_start = (__off_t )0;
#line 557
    lock.l_len = (__off_t )0;
#line 559
    tmp___1 = fcntl(sem->handle, 6, & lock);
    }
#line 559
    if (tmp___1 == 0) {
      {
#line 566
      arg___0.val = 0;
#line 567
      semctl(sem->semID, 0, 0, arg___0);
#line 568
      unlink((char const   *)(sem->semName));
      }
    } else {
      {
#line 576
      lock.l_type = (short)2;
#line 578
      tmp___0 = fcntl(sem->handle, 7, & lock);
#line 578
      rtnVal = (uSHORT )(tmp___0 != 0);
      }
    }
    {
#line 581
    close(sem->handle);
    }
  }
#line 584
  if ((int )rtnVal == 0) {
    {
#line 585
    free((void *)sem);
    }
  }
#line 587
  if (Verbose) {
    {
#line 588
    printf((char const   */* __restrict  */)"\nosdDestroySemaphore   : Rtn = %x",
           (int )rtnVal);
    }
  }
#line 590
  return (rtnVal);
}
}
#line 619 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
static void semaphoreSignalHandler(int sig ) 
{ 


  {
#line 622
  sig = sig;
#line 623
  return;
}
}
#line 625 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
uLONG osdRequestSemaphore(unsigned int *semHandle , uLONG timeout ) 
{ 
  DPT_Semaphore_S *sem ;
  uLONG rtnVal ;
  int resetAction ;
  unsigned int oldAlarm ;
  unsigned int waited ;
  struct sembuf semOps[2] ;
  struct sigaction newSig ;
  struct sigaction oldSig ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 627
  sem = (DPT_Semaphore_S *)semHandle;
#line 628
  rtnVal = (uLONG )0;
#line 629
  resetAction = 0;
#line 639
  semOps[0].sem_num = (unsigned short )sem->index;
#line 640
  semOps[0].sem_op = (short)0;
#line 641
  semOps[0].sem_flg = (short)0;
#line 642
  semOps[1].sem_num = (unsigned short )sem->index;
#line 643
  semOps[1].sem_op = (short)1;
#line 644
  semOps[1].sem_flg = (short)0;
#line 649
  if (timeout == 0UL) {
#line 650
    semOps[0].sem_flg = (short )((int )semOps[0].sem_flg | 2048);
#line 651
    semOps[1].sem_flg = (short )((int )semOps[1].sem_flg | 2048);
#line 653
    timeout = (uLONG )4294967295U;
  }
#line 665
  if (timeout != 4294967295UL) {
    {
#line 669
    timeout = (timeout + 999UL) / 1000UL;
#line 671
    memset((void *)(& newSig), 0, sizeof(newSig));
#line 672
    newSig.__sigaction_handler.sa_handler = & semaphoreSignalHandler;
#line 674
    oldAlarm = alarm(0U);
#line 675
    tmp = sigaction(14, (struct sigaction  const  */* __restrict  */)(& newSig), (struct sigaction */* __restrict  */)(& oldSig));
#line 675
    rtnVal = (uLONG )(tmp != 0);
    }
#line 677
    if (rtnVal == 0UL) {
      {
#line 678
      resetAction = 1;
#line 679
      alarm((unsigned int )timeout);
      }
    } else {
      {
#line 682
      alarm(oldAlarm);
      }
    }
  }
#line 688
  if (rtnVal == 0UL) {
    {
#line 689
    tmp___0 = semop(sem->semID, semOps, (size_t )2);
#line 689
    rtnVal = (uLONG )(tmp___0 != 0);
    }
  }
#line 694
  if (timeout != 4294967295UL) {
    {
#line 701
    tmp___1 = alarm(0U);
#line 701
    waited = (unsigned int )timeout - tmp___1;
    }
#line 703
    if (resetAction) {
      {
#line 704
      sigaction(14, (struct sigaction  const  */* __restrict  */)(& oldSig), (struct sigaction */* __restrict  */)((void *)0));
      }
    }
#line 707
    if (oldAlarm != 0U) {
#line 708
      if (oldAlarm > waited) {
        {
#line 709
        alarm(oldAlarm - waited);
        }
      } else {
        {
#line 711
        raise(14);
        }
      }
    }
  }
#line 716
  if (Verbose) {
    {
#line 717
    printf((char const   */* __restrict  */)"\nosdRequestSemaphore   : Rtn = %lx\n",
           rtnVal);
    }
  }
#line 719
  return (rtnVal);
}
}
#line 747 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
uSHORT osdReleaseSemaphore(unsigned int *semHandle ) 
{ 
  DPT_Semaphore_S *sem ;
  uSHORT rtnVal ;
  struct sembuf semOp ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 749
  sem = (DPT_Semaphore_S *)semHandle;
#line 750
  rtnVal = (uSHORT )1;
#line 755
  semOp.sem_num = (unsigned short )sem->index;
#line 756
  semOp.sem_op = (short)-1;
#line 757
  semOp.sem_flg = (short)2048;
#line 759
  tmp = semop(sem->semID, & semOp, (size_t )1);
#line 759
  rtnVal = (uSHORT )(tmp != 0);
  }
#line 761
  if (rtnVal) {
    {
#line 761
    tmp___0 = __errno_location();
    }
#line 761
    if (*tmp___0 == 11) {
#line 765
      rtnVal = (uSHORT )0;
    }
  }
#line 768
  if (Verbose) {
    {
#line 769
    printf((char const   */* __restrict  */)"\nosdReleaseSemaphore   : Rtn = %x\n",
           (int )rtnVal);
    }
  }
#line 771
  return (rtnVal);
}
}
#line 796 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
uLONG osdResetEventSemaphore(unsigned int *semHandle ) 
{ 


  {
#line 798
  semHandle = semHandle;
#line 799
  return ((uLONG )0);
}
}
#line 824 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
uLONG osdSignalEventSemaphore(unsigned int *semHandle ) 
{ 
  uSHORT tmp ;

  {
  {
#line 826
  tmp = osdReleaseSemaphore(semHandle);
  }
#line 826
  return ((uLONG )tmp);
}
}
#line 852 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
uLONG osdWaitForEventSemaphore(unsigned int *semHandle , uLONG timeout ) 
{ 
  uLONG tmp ;

  {
  {
#line 854
  tmp = osdRequestSemaphore(semHandle, timeout);
  }
#line 854
  return (tmp);
}
}
#line 881 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
unsigned int *osdCreateEventSemaphore(void) 
{ 
  unsigned int *rtnVal ;

  {
  {
#line 885
  rtnVal = privateCreateUnnamedSemaphore(1);
  }
#line 887
  if (Verbose) {
    {
#line 888
    printf((char const   */* __restrict  */)"\nosdCreateEventSemaphore   : Rtn = %lx",
           (unsigned long )rtnVal);
    }
  }
#line 890
  return (rtnVal);
}
}
#line 915 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/semaphor.c"
unsigned int *osdCreateNamedEventSemaphore(char *name ) 
{ 
  char temp[80] ;
  unsigned int *rtnVal ;

  {
  {
#line 920
  strcpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)"/tmp/");
#line 921
  strcat((char */* __restrict  */)(temp), (char const   */* __restrict  */)name);
#line 923
  rtnVal = privateCreateNamedSemaphore(temp, 1);
  }
#line 925
  if (Verbose) {
    {
#line 926
    printf((char const   */* __restrict  */)"\nosdCreateNamedEventSemaphore   : Rtn = %lx",
           (unsigned long )rtnVal);
    }
  }
#line 928
  return (rtnVal);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 2064 "../include/dpt_scsi.h"
uCHAR opCode  ;
#line 2065 "../include/dpt_scsi.h"
uCHAR lun  ;
#line 2066 "../include/dpt_scsi.h"
uCHAR bufferID  ;
#line 2067 "../include/dpt_scsi.h"
uCHAR bufferOffset[3]  ;
#line 2068 "../include/dpt_scsi.h"
uCHAR allocLength[3]  ;
#line 2069 "../include/dpt_scsi.h"
uCHAR control  ;
#line 2192 "../include/dpt_scsi.h"
uCHAR paramListLength[3]  ;
#line 125 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dpt_osd.h"
extern int _osdStartI2OCp(Controller_t controller , OutGoing_t packet , void (*callback)(Controller_t controller ,
                                                                                         Status_t status ,
                                                                                         Sense_t sense ) ) ;
#line 56 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.h"
int DPTI_startEataCp(Controller_t controller , eataCP_S *packet , void (*callback)(Controller_t controller ,
                                                                                   Status_t status ,
                                                                                   Sense_t sense ) ) ;
#line 64
unsigned short DPTI_getTID(Controller_t controller , unsigned char Bus , unsigned char Target ,
                           unsigned char Lun , unsigned char FW , unsigned char Phys ,
                           unsigned char Interpret ) ;
#line 77
unsigned long DPTI_BootBlockSize(void) ;
#line 83
int DPTI_sendMessage(Controller_t controller , PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE Message ) ;
#line 86
unsigned short *DPTI_statusSynchronousAddress(OutGoing_t Message ) ;
#line 88
int DPTI_getParams(Controller_t controller , unsigned short TID , int Group , PI2O_PARAM_RESULTS_LIST_HEADER Header ,
                   unsigned int HeaderSize ) ;
#line 94
void DPTI_refresh(Controller_t controller ) ;
#line 96
void DPTI_rescan(Controller_t controller ) ;
#line 98
void DPTI_resetBus(Controller_t controller ) ;
#line 142
TID_t *DPTI_getDeviceAddr(Controller_t controller , unsigned char Bus , unsigned char Target ,
                          unsigned char Lun , unsigned char FW , unsigned char Phys ) ;
#line 149
TID_t *DPTI_getDeviceTID(Controller_t controller , unsigned short TID ) ;
#line 273 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static void DPTI_synchronousCallback(Controller_t controller , I2O_SINGLE_REPLY_MESSAGE_FRAME *status ) 
{ 


  {
#line 285
  if ((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) == 0) {
#line 285
    if ((int )*(& status->ReqStatus + 0) != 0) {
#line 285
      *((unsigned short *)status->TransactionContext) = (unsigned short)65534;
    } else {
#line 285
      *((unsigned short *)status->TransactionContext) = *((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0));
    }
  } else {
#line 285
    *((unsigned short *)status->TransactionContext) = *((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0));
  }
#line 293
  return;
}
}
#line 295 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static void DPTI_eataSynchronousCallback(Controller_t controller , eataSP_S *status ) 
{ 


  {
#line 305
  *((unsigned short *)*((unsigned long *)((unsigned char *)status + 8))) = (unsigned short )(((int )*((unsigned char *)status + 0) << 8) | (int )*((unsigned char *)status + 1));
#line 307
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 410 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
int DPTI_sendMessage(Controller_t controller , PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE Message ) 
{ 
  unsigned short volatile   DetailedStatus ;
  int retval ;
  unsigned long Counter ;
  time_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 423
  DetailedStatus = (unsigned short volatile   )(unsigned short)65535;
#line 424
  Message->PrivateMessageFrame.TransactionContext = (unsigned long )(& DetailedStatus);
#line 430
  retval = _osdStartI2OCp(controller, (OutGoing_t )Message, (void (*)(Controller_t controller ,
                                                                      Status_t status ,
                                                                      Sense_t sense ))(& DPTI_synchronousCallback));
  }
#line 434
  if (retval >= 0) {
    {
#line 437
    tmp = time((time_t *)((void *)0));
#line 437
    Counter = (unsigned long )tmp + 10UL;
    }
    {
#line 440
    while (1) {
      while_continue: /* CIL Label */ ;
#line 440
      if ((int volatile   )DetailedStatus == (int volatile   )(unsigned short)65535) {
        {
#line 440
        tmp___0 = time((time_t *)((void *)0));
        }
#line 440
        if (! (Counter > (unsigned long )tmp___0)) {
#line 440
          goto while_break;
        }
      } else {
#line 440
        goto while_break;
      }
#line 442
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 455
    return ((int )DetailedStatus);
  }
#line 457
  return (-1);
}
}
#line 465 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static struct convertCallback DPTI_convertCallbackList[1]  ;
#line 487 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static void DPTI_convertCallback(Controller_t controller , I2O_SINGLE_REPLY_MESSAGE_FRAME *status ,
                                 sdRequestSense_S *sense ) 
{ 
  struct convertCallback *placeHolder ;
  eataSP_S Status ;
  sdRequestSense_S *SenseP ;
  unsigned short s ;

  {
  {
#line 498
  placeHolder = (struct convertCallback *)status->TransactionContext;
#line 500
  memset((void *)(& Status), 0, sizeof(Status));
#line 501
  *((unsigned long *)((unsigned char *)(& Status) + 8)) = placeHolder->VCPaddr;
#line 502
  SenseP = (sdRequestSense_S *)((void *)0);
#line 503
  s = (unsigned short)0;
  }
  {
#line 506
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 0) {
#line 506
    goto case_0;
  }
#line 507
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 512) {
#line 507
    goto case_512;
  }
#line 508
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 768) {
#line 508
    goto case_768;
  }
#line 509
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 1024) {
#line 509
    goto case_1024;
  }
#line 510
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 1280) {
#line 510
    goto case_1280;
  }
#line 511
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 1536) {
#line 511
    goto case_1536;
  }
#line 512
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 1792) {
#line 512
    goto case_1792;
  }
#line 513
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 2048) {
#line 513
    goto case_2048;
  }
#line 514
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 2304) {
#line 514
    goto case_2304;
  }
#line 515
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 2560) {
#line 515
    goto case_2560;
  }
#line 516
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 2816) {
#line 516
    goto case_2816;
  }
#line 517
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 3328) {
#line 517
    goto case_3328;
  }
#line 518
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 3584) {
#line 518
    goto case_3584;
  }
#line 519
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 3840) {
#line 519
    goto case_3840;
  }
#line 520
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 4096) {
#line 520
    goto case_4096;
  }
#line 521
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 4352) {
#line 521
    goto case_4352;
  }
#line 522
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 4608) {
#line 522
    goto case_4608;
  }
#line 523
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 4864) {
#line 523
    goto case_4864;
  }
#line 524
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 5120) {
#line 524
    goto case_5120;
  }
#line 525
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 5376) {
#line 525
    goto case_5376;
  }
#line 526
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 5632) {
#line 526
    goto case_5632;
  }
#line 527
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 5888) {
#line 527
    goto case_5888;
  }
#line 528
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 6144) {
#line 528
    goto case_6144;
  }
#line 529
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 13056) {
#line 529
    goto case_13056;
  }
#line 530
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 13312) {
#line 530
    goto case_13312;
  }
#line 531
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 13568) {
#line 531
    goto case_13568;
  }
#line 532
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 13824) {
#line 532
    goto case_13824;
  }
#line 533
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 14080) {
#line 533
    goto case_14080;
  }
#line 534
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 14336) {
#line 534
    goto case_14336;
  }
#line 535
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 14592) {
#line 535
    goto case_14592;
  }
#line 536
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 14848) {
#line 536
    goto case_14848;
  }
#line 537
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 15104) {
#line 537
    goto case_15104;
  }
#line 538
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 15360) {
#line 538
    goto case_15360;
  }
#line 539
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 15616) {
#line 539
    goto case_15616;
  }
#line 540
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 15872) {
#line 540
    goto case_15872;
  }
#line 541
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 16128) {
#line 541
    goto case_16128;
  }
#line 542
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 65280) == 16384) {
#line 542
    goto case_16384;
  }
#line 543
  goto switch_default;
  case_0: /* CIL Label */ 
#line 506
  s = (unsigned short)0;
#line 506
  goto switch_break;
  case_512: /* CIL Label */ 
#line 507
  s = (unsigned short)14;
#line 507
  goto switch_break;
  case_768: /* CIL Label */ 
#line 508
  s = (unsigned short)65535;
#line 508
  goto switch_break;
  case_1024: /* CIL Label */ 
#line 509
  s = (unsigned short)65535;
#line 509
  goto switch_break;
  case_1280: /* CIL Label */ 
#line 510
  s = (unsigned short)65535;
#line 510
  goto switch_break;
  case_1536: /* CIL Label */ 
#line 511
  s = (unsigned short)65535;
#line 511
  goto switch_break;
  case_1792: /* CIL Label */ 
#line 512
  s = (unsigned short)65535;
#line 512
  goto switch_break;
  case_2048: /* CIL Label */ 
#line 513
  s = (unsigned short)1;
#line 513
  goto switch_break;
  case_2304: /* CIL Label */ 
#line 514
  s = (unsigned short)65535;
#line 514
  goto switch_break;
  case_2560: /* CIL Label */ 
#line 515
  s = (unsigned short)1;
#line 515
  goto switch_break;
  case_2816: /* CIL Label */ 
#line 516
  s = (unsigned short)2;
#line 516
  goto switch_break;
  case_3328: /* CIL Label */ 
#line 517
  s = (unsigned short)9;
#line 517
  goto switch_break;
  case_3584: /* CIL Label */ 
#line 518
  s = (unsigned short)3;
#line 518
  goto switch_break;
  case_3840: /* CIL Label */ 
#line 519
  s = (unsigned short)7;
#line 519
  goto switch_break;
  case_4096: /* CIL Label */ 
#line 520
  s = (unsigned short)11;
#line 520
  goto switch_break;
  case_4352: /* CIL Label */ 
#line 521
  s = (unsigned short)4;
#line 521
  goto switch_break;
  case_4608: /* CIL Label */ 
#line 522
  s = (unsigned short)65535;
#line 522
  goto switch_break;
  case_4864: /* CIL Label */ 
#line 523
  s = (unsigned short)6;
#line 523
  goto switch_break;
  case_5120: /* CIL Label */ 
#line 524
  s = (unsigned short)5;
#line 524
  goto switch_break;
  case_5376: /* CIL Label */ 
#line 525
  s = (unsigned short)65535;
#line 525
  goto switch_break;
  case_5632: /* CIL Label */ 
#line 526
  s = (unsigned short)65535;
#line 526
  goto switch_break;
  case_5888: /* CIL Label */ 
#line 527
  s = (unsigned short)65535;
#line 527
  goto switch_break;
  case_6144: /* CIL Label */ 
#line 528
  s = (unsigned short)65535;
#line 528
  goto switch_break;
  case_13056: /* CIL Label */ 
#line 529
  s = (unsigned short)65535;
#line 529
  goto switch_break;
  case_13312: /* CIL Label */ 
#line 530
  s = (unsigned short)65535;
#line 530
  goto switch_break;
  case_13568: /* CIL Label */ 
#line 531
  s = (unsigned short)65535;
#line 531
  goto switch_break;
  case_13824: /* CIL Label */ 
#line 532
  s = (unsigned short)65535;
#line 532
  goto switch_break;
  case_14080: /* CIL Label */ 
#line 533
  s = (unsigned short)65535;
#line 533
  goto switch_break;
  case_14336: /* CIL Label */ 
#line 534
  s = (unsigned short)1;
#line 534
  goto switch_break;
  case_14592: /* CIL Label */ 
#line 535
  s = (unsigned short)1;
#line 535
  goto switch_break;
  case_14848: /* CIL Label */ 
#line 536
  s = (unsigned short)65535;
#line 536
  goto switch_break;
  case_15104: /* CIL Label */ 
#line 537
  s = (unsigned short)65535;
#line 537
  goto switch_break;
  case_15360: /* CIL Label */ 
#line 538
  s = (unsigned short)65535;
#line 538
  goto switch_break;
  case_15616: /* CIL Label */ 
#line 539
  s = (unsigned short)65535;
#line 539
  goto switch_break;
  case_15872: /* CIL Label */ 
#line 540
  s = (unsigned short)65535;
#line 540
  goto switch_break;
  case_16128: /* CIL Label */ 
#line 541
  s = (unsigned short)65535;
#line 541
  goto switch_break;
  case_16384: /* CIL Label */ 
#line 542
  s = (unsigned short)65535;
#line 542
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 543
  s = (unsigned short)65535;
#line 543
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 545
  if ((int )s == 0) {
    {
#line 552
    if ((int )*(& status->ReqStatus + 0) == 1) {
#line 552
      goto case_1;
    }
#line 552
    if ((int )*(& status->ReqStatus + 0) == 10) {
#line 552
      goto case_1;
    }
#line 552
    if ((int )*(& status->ReqStatus + 0) == 9) {
#line 552
      goto case_1;
    }
#line 552
    if ((int )*(& status->ReqStatus + 0) == 8) {
#line 552
      goto case_1;
    }
#line 552
    if ((int )*(& status->ReqStatus + 0) == 3) {
#line 552
      goto case_1;
    }
#line 552
    if ((int )*(& status->ReqStatus + 0) == 2) {
#line 552
      goto case_1;
    }
#line 559
    if ((int )*(& status->ReqStatus + 0) == 0) {
#line 559
      goto case_0___0;
    }
#line 558
    goto switch_default___0;
    case_1: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 552
    s = (unsigned short)14;
#line 552
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 558
    s = (unsigned short)65535;
    case_0___0: /* CIL Label */ 
#line 559
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 561
  *((unsigned char *)(& Status) + 0) = (unsigned char )((int )s | 128);
#line 562
  *((unsigned char *)(& Status) + 1) = (unsigned char )((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 255);
#line 565
  s = (unsigned short)0;
#line 566
  if (((int )*((unsigned short *)((unsigned char *)(& status->DetailedStatusCode) + 0)) & 255) == 2) {
#line 568
    SenseP = (sdRequestSense_S *)(((I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME *)status)->SenseData);
#line 570
    s = (unsigned short )((I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME *)status)->AutoSenseTransferCount;
  } else
#line 572
  if ((unsigned long )sense != (unsigned long )((sdRequestSense_S *)((void *)0))) {
#line 573
    SenseP = sense;
#line 574
    s = placeHolder->senseLength;
  }
#line 582
  if ((unsigned long )placeHolder->status != (unsigned long )((eataSP_S *)((void *)0))) {
    {
#line 583
    memcpy((void */* __restrict  */)((void *)placeHolder->status), (void const   */* __restrict  */)((void *)(& Status)),
           sizeof(eataSP_S ));
    }
  }
#line 591
  if ((unsigned long )SenseP != (unsigned long )((sdRequestSense_S *)((void *)0))) {
#line 591
    if ((unsigned long )placeHolder->sense != (unsigned long )((sdRequestSense_S *)((void *)0))) {
#line 591
      if ((unsigned long )placeHolder->sense != (unsigned long )SenseP) {
#line 591
        if ((int )s != 0) {
#line 595
          if ((int )s > (int )placeHolder->senseLength) {
#line 596
            s = placeHolder->senseLength;
          }
          {
#line 598
          memcpy((void */* __restrict  */)((void *)placeHolder->sense), (void const   */* __restrict  */)((void *)SenseP),
                 (size_t )s);
          }
        }
      }
    }
  }
  {
#line 601
  (*(placeHolder->callback))(controller, (Status_t )(& Status), SenseP);
#line 606
  placeHolder->VCPaddr = 0UL;
  }
#line 614
  return;
}
}
#line 627 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
unsigned short *DPTI_statusSynchronousAddress(OutGoing_t Message ) 
{ 
  unsigned long callback ;
  struct convertCallback *placeHolder ;
  unsigned short *retVal ;

  {
#line 646
  callback = ((I2O_MESSAGE_FRAME *)Message)->InitiatorContext;
#line 652
  if (callback == (unsigned long )(& DPTI_synchronousCallback)) {
#line 653
    return ((unsigned short *)((I2O_PRIVATE_MESSAGE_FRAME *)Message)->TransactionContext);
  }
#line 661
  if (callback == (unsigned long )(& DPTI_convertCallback)) {
#line 664
    placeHolder = (struct convertCallback *)((I2O_PRIVATE_MESSAGE_FRAME *)Message)->TransactionContext;
#line 667
    callback = (unsigned long )placeHolder->callback;
#line 668
    if (callback == (unsigned long )(& DPTI_eataSynchronousCallback)) {
#line 671
      retVal = (unsigned short *)placeHolder->VCPaddr;
#line 676
      placeHolder->VCPaddr = 0UL;
#line 684
      return (retVal);
    }
  }
#line 691
  return ((unsigned short *)((void *)0));
}
}
#line 799 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static DPTI_Devices_S *DPTI_devices[16]  ;
#line 803 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static DPTI_Devices_S **lastCurrentStolen  ;
#line 800 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static DPTI_Devices_S **_DPTI_current(Controller_t controller ) 
{ 
  DPTI_Devices_S **current ;
  DPTI_Devices_S *tmp ;
  void *tmp___0 ;

  {
#line 802
  current = DPTI_devices;
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (*current) {
#line 808
      if ((int )(*current)->controller == (int )controller) {
#line 808
        if ((*current)->valid) {
#line 810
          lastCurrentStolen = current;
#line 811
          return (current);
        }
      }
    }
#line 808
    current ++;
#line 808
    if (! ((unsigned long )current < (unsigned long )(& DPTI_devices[16]))) {
#line 808
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 817
  current = DPTI_devices;
  {
#line 818
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 818
    if (*current) {
#line 818
      if ((int )(*current)->controller == (int )controller) {
#line 819
        lastCurrentStolen = current;
#line 820
        return (current);
      }
    }
#line 818
    current ++;
#line 818
    if (! ((unsigned long )current < (unsigned long )(& DPTI_devices[16]))) {
#line 818
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 826
  current = DPTI_devices;
  {
#line 827
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 827
    if (*current) {
#line 827
      if ((int )(*current)->valid == 0) {
#line 828
        lastCurrentStolen = current;
#line 829
        return (current);
      }
    }
#line 827
    current ++;
#line 827
    if (! ((unsigned long )current < (unsigned long )(& DPTI_devices[16]))) {
#line 827
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 835
  current = DPTI_devices;
  {
#line 836
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 836
    if ((unsigned long )*current == (unsigned long )((DPTI_Devices_S *)((void *)0))) {
      {
#line 837
      tmp___0 = malloc(sizeof(DPTI_Devices_S ));
#line 837
      tmp = (DPTI_Devices_S *)tmp___0;
#line 837
      *current = tmp;
      }
#line 837
      if ((unsigned long )tmp == (unsigned long )((DPTI_Devices_S *)((void *)0))) {
#line 840
        goto while_break___2;
      }
      {
#line 842
      memset((void *)*current, 0, sizeof(DPTI_Devices_S ));
#line 843
      (*current)->size = (unsigned short )sizeof(DPTI_Devices_S );
#line 844
      (*current)->controller = controller;
#line 845
      lastCurrentStolen = current;
      }
#line 846
      return (current);
    }
#line 836
    current ++;
#line 836
    if (! ((unsigned long )current < (unsigned long )(& DPTI_devices[16]))) {
#line 836
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 852
  if ((unsigned long )lastCurrentStolen < (unsigned long )(DPTI_devices)) {
#line 854
    lastCurrentStolen = DPTI_devices;
  } else
#line 852
  if ((unsigned long )(& DPTI_devices[16]) <= (unsigned long )lastCurrentStolen) {
#line 854
    lastCurrentStolen = DPTI_devices;
  }
#line 856
  lastCurrentStolen ++;
#line 857
  if ((unsigned long )lastCurrentStolen < (unsigned long )(DPTI_devices)) {
#line 859
    lastCurrentStolen = DPTI_devices;
  } else
#line 857
  if ((unsigned long )(& DPTI_devices[16]) <= (unsigned long )lastCurrentStolen) {
#line 859
    lastCurrentStolen = DPTI_devices;
  }
#line 864
  return (lastCurrentStolen);
}
}
#line 943 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static I2O_MESSAGE_FRAME *DPTI_fillMessage(unsigned char *Message , unsigned short size ) 
{ 
  I2O_MESSAGE_FRAME *Message_Ptr ;
  unsigned short hold___2 ;

  {
  {
#line 948
  Message_Ptr = (I2O_MESSAGE_FRAME *)((I2O_UTIL_NOP_MESSAGE *)Message);
#line 950
  memset((void *)Message_Ptr, 0, (size_t )size);
#line 951
  *(& Message_Ptr->VersionOffset + 0) = (unsigned char)1;
#line 952
  hold___2 = (unsigned short )((((unsigned long )size + sizeof(U32 )) - 1UL) / sizeof(U32 ));
#line 952
  *((unsigned short *)(& Message_Ptr->VersionOffset + 2)) = hold___2;
#line 953
  Message_Ptr->InitiatorAddress = (BF )1;
  }
#line 954
  return (Message_Ptr);
}
}
#line 967 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned char DPTI_getIrqNum(Controller_t controller ) 
{ 
  unsigned char Message[sizeof(struct LogPage )] ;
  PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *Message_Ptr ;
  I2O_MESSAGE_FRAME *tmp ;
  unsigned short hold___2 ;
  unsigned short hold___3 ;
  unsigned long hold___4 ;
  unsigned short hold___5 ;
  unsigned long hold___6 ;
  unsigned char *cp ;
  unsigned char length ;
  int tmp___0 ;

  {
  {
#line 980
  tmp = DPTI_fillMessage(Message, (unsigned short )((sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) + sizeof(I2O_SGE_SIMPLE_ELEMENT )));
#line 980
  Message_Ptr = (PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *)tmp;
#line 984
  *(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL + ((sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 989
  Message_Ptr->PrivateMessageFrame.StdMessageFrame.Function = (BF )255;
#line 992
  hold___2 = (unsigned short)129;
#line 992
  *((unsigned short *)((unsigned char *)(& Message_Ptr->PrivateMessageFrame.XFunctionCode) + 0)) = hold___2;
#line 995
  hold___3 = (unsigned short)27;
#line 995
  *((unsigned short *)((unsigned char *)(& Message_Ptr->PrivateMessageFrame.OrganizationID) + 0)) = hold___3;
#line 997
  Message_Ptr->Interpret = (BF )1;
#line 1007
  *(& Message_Ptr->CDBLength + 0) = (unsigned char)10;
#line 1011
  Message_Ptr->CDB[0] = (U8 )77;
#line 1012
  Message_Ptr->CDB[2] = (U8 )51;
#line 1013
  Message_Ptr->CDB[8] = (U8 )sizeof(((struct LogPage *)Message_Ptr)->Buffer);
#line 1017
  hold___4 = sizeof(((struct LogPage *)Message_Ptr)->Buffer);
#line 1017
  *((unsigned long *)((unsigned char *)(& Message_Ptr->ByteCount) + 0)) = hold___4;
#line 1022
  hold___5 = (unsigned short)24704;
#line 1022
  *((unsigned short *)((unsigned char *)(& Message_Ptr->SCBFlags) + 0)) = hold___5;
#line 1025
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = sizeof(((struct LogPage *)Message_Ptr)->Buffer);
#line 1025
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )208;
#line 1025
  hold___6 = (unsigned long )((void *)(((struct LogPage *)Message_Ptr)->Buffer));
#line 1025
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___6;
#line 1028
  tmp___0 = DPTI_sendMessage(controller, Message_Ptr);
  }
#line 1028
  if (tmp___0 == 0) {
#line 1029
    cp = (unsigned char *)(((struct LogPage *)Message_Ptr)->Buffer);
#line 1032
    if ((int )*(cp + 0) != 51) {
#line 1033
      return ((unsigned char)0);
    } else
#line 1032
    if ((int )*(cp + 2) != 0) {
#line 1033
      return ((unsigned char)0);
    }
#line 1035
    length = *(cp + 3);
#line 1036
    cp += 4;
    {
#line 1037
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1037
      if (! length) {
#line 1037
        goto while_break;
      }
#line 1038
      if ((int )*(cp + 0) != 0) {
#line 1039
        goto while_break;
      }
#line 1041
      if ((int )*(cp + 1) == 1) {
#line 1041
        if ((int )*(cp + 3) >= 2) {
#line 1042
          return (*(cp + 5));
        }
      }
#line 1044
      if ((int )length < (int )*(cp + 3) + 4) {
#line 1045
        length = (unsigned char)0;
      } else {
#line 1047
        length = (unsigned char )((int )length - ((int )*(cp + 3) + 4));
      }
#line 1050
      cp += (int )*(cp + 3) + 4;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1053
  return ((unsigned char)0);
}
}
#line 1061 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static int DPTI_acquireLct(Controller_t controller ) 
{ 
  unsigned short Counter ;
  unsigned short MaxEntry ;
  unsigned char Message[sizeof(I2O_EXEC_LCT_NOTIFY_MESSAGE )] ;
  I2O_EXEC_LCT_NOTIFY_MESSAGE *Message_Ptr ;
  DPTI_Devices_S *current ;
  I2O_MESSAGE_FRAME *tmp ;
  unsigned long hold___2 ;
  I2O_LCT Table ;
  unsigned long hold___3 ;
  DPTI_Devices_S **tmp___0 ;
  DPTI_Devices_S *newCurrent ;
  void *tmp___1 ;
  DPTI_Devices_S **tmp___2 ;
  unsigned long hold___4 ;
  int tmp___3 ;
  TID_t *Device ;
  I2O_LCT_ENTRY *entry ;
  TID_t *Device___0 ;
  TID_t *SubDevice ;
  unsigned short SubCounter ;

  {
  {
#line 1073
  tmp = DPTI_fillMessage(Message, (unsigned short )((sizeof(I2O_EXEC_LCT_NOTIFY_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) + sizeof(I2O_SGE_SIMPLE_ELEMENT )));
#line 1073
  Message_Ptr = (I2O_EXEC_LCT_NOTIFY_MESSAGE *)tmp;
#line 1076
  *(& Message_Ptr->StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL + ((sizeof(I2O_EXEC_LCT_NOTIFY_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 1080
  Message_Ptr->StdMessageFrame.Function = (BF )162;
#line 1082
  hold___2 = 4294967295UL;
#line 1082
  *((unsigned long *)((unsigned char *)(& Message_Ptr->ClassIdentifier) + 0)) = hold___2;
#line 1094
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = sizeof(I2O_LCT ) - sizeof(I2O_LCT_ENTRY );
#line 1094
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )208;
#line 1094
  hold___3 = (unsigned long )((void *)(& Table));
#line 1094
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___3;
#line 1096
  Table.TableSize = (sizeof(I2O_LCT ) - sizeof(I2O_LCT_ENTRY )) >> 2;
#line 1098
  DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
#line 1103
  MaxEntry = (unsigned short )(((unsigned long )((int )((U16 )Table.TableSize) << 2) - (sizeof(I2O_LCT ) - sizeof(I2O_LCT_ENTRY ))) / sizeof(I2O_LCT_ENTRY ));
#line 1106
  tmp___0 = _DPTI_current(controller);
#line 1106
  current = *tmp___0;
  }
#line 1107
  if ((unsigned long )current->size < sizeof(DPTI_Devices_S ) + (unsigned long )((int )MaxEntry - 1) * sizeof(I2O_LCT_ENTRY )) {
    {
#line 1111
    tmp___1 = malloc(sizeof(DPTI_Devices_S ) + (unsigned long )((int )MaxEntry - 1) * sizeof(I2O_LCT_ENTRY ));
#line 1111
    newCurrent = (DPTI_Devices_S *)tmp___1;
#line 1113
    memcpy((void */* __restrict  */)((void *)newCurrent), (void const   */* __restrict  */)((void *)current),
           (size_t )current->size);
#line 1115
    newCurrent->size = (unsigned short )(sizeof(DPTI_Devices_S ) + (unsigned long )((int )MaxEntry - 1) * sizeof(I2O_LCT_ENTRY ));
#line 1121
    tmp___2 = _DPTI_current(current->controller);
#line 1121
    *tmp___2 = newCurrent;
#line 1122
    free((void *)current);
#line 1123
    current = newCurrent;
    }
  }
  {
#line 1131
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = sizeof(I2O_LCT ) + (unsigned long )((int )MaxEntry - 1) * sizeof(I2O_LCT_ENTRY );
#line 1131
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )208;
#line 1131
  hold___4 = (unsigned long )((void *)(& current->devices.lct.header));
#line 1131
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___4;
#line 1140
  current->numDevices = (unsigned short)0;
#line 1141
  tmp___3 = DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
  }
#line 1141
  if (tmp___3 != 0) {
#line 1147
    return (-1);
  }
#line 1173
  if ((int )MaxEntry != 0) {
#line 1174
    Counter = (unsigned short)0;
    {
#line 1174
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1174
      if (! ((int )Counter < (int )MaxEntry)) {
#line 1174
        goto while_break;
      }
      {
#line 1179
      Device = & current->devices.tid.data[current->numDevices];
#line 1180
      entry = & current->devices.lct.header.LCTEntry[Counter];
#line 1195
      memset((void *)Device, 0, sizeof(TID_t ));
      }
      {
#line 1211
      if ((int )((U16 )entry->ClassID.Class) == 65) {
#line 1211
        goto case_65;
      }
#line 1211
      if ((int )((U16 )entry->ClassID.Class) == 81) {
#line 1211
        goto case_65;
      }
#line 1213
      if ((int )((U16 )entry->ClassID.Class) == 16) {
#line 1213
        goto case_16;
      }
#line 1217
      if ((int )((U16 )entry->ClassID.Class) == 64) {
#line 1217
        goto case_64;
      }
#line 1217
      if ((int )((U16 )entry->ClassID.Class) == 128) {
#line 1217
        goto case_64;
      }
#line 1221
      goto switch_default;
      case_65: /* CIL Label */ 
      case_81: /* CIL Label */ 
#line 1212
      Device->SCSI = (unsigned short)1;
      case_16: /* CIL Label */ 
#line 1214
      goto switch_break;
      case_64: /* CIL Label */ 
      case_128: /* CIL Label */ 
#line 1218
      Device->Adapter = (unsigned short)1;
#line 1219
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1225
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
#line 1231
      Device->UserTID = (U16 )entry->UserTID;
#line 1233
      Device->TID = (U16 )entry->LocalTID;
#line 1234
      current->numDevices = (unsigned short )((int )current->numDevices + 1);
      __Cont: /* CIL Label */ 
#line 1174
      Counter = (unsigned short )((int )Counter + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1241
  Device___0 = current->devices.tid.data;
#line 1243
  Counter = current->numDevices;
  {
#line 1243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1243
    if (! ((int )Counter != 0)) {
#line 1243
      goto while_break___0;
    }
#line 1248
    if (Device___0->Adapter) {
#line 1249
      goto __Cont___0;
    } else
#line 1248
    if (Device___0->SCSI) {
#line 1249
      goto __Cont___0;
    }
#line 1252
    SubDevice = current->devices.tid.data;
#line 1252
    MaxEntry = (unsigned short)0;
#line 1252
    SubCounter = current->numDevices;
    {
#line 1252
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1252
      if (! ((int )SubCounter != 0)) {
#line 1252
        goto while_break___1;
      }
#line 1256
      if (! SubDevice->Adapter) {
#line 1256
        if ((int )SubDevice->UserTID == (int )Device___0->TID) {
#line 1256
          MaxEntry = (unsigned short )((int )MaxEntry + 1);
#line 1256
          if ((int )MaxEntry > 1) {
#line 1259
            Device___0->RAID = (unsigned short)1;
#line 1260
            goto while_break___1;
          } else
#line 1256
          if (! SubDevice->SCSI) {
#line 1259
            Device___0->RAID = (unsigned short)1;
#line 1260
            goto while_break___1;
          }
        }
      }
#line 1252
      SubDevice ++;
#line 1252
      SubCounter = (unsigned short )((int )SubCounter - 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1269
    if ((int )MaxEntry == 0) {
#line 1270
      Device___0->RAID = (unsigned short)1;
    }
    __Cont___0: /* CIL Label */ 
#line 1243
    Device___0 ++;
#line 1243
    Counter = (unsigned short )((int )Counter - 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1278
  return (0);
}
}
#line 1285 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
int DPTI_getParams(Controller_t controller , unsigned short TID , int Group , PI2O_PARAM_RESULTS_LIST_HEADER Header ,
                   unsigned int HeaderSize ) 
{ 
  unsigned char Operations[sizeof(struct ParamOperations )] ;
  struct ParamOperations *Operations_Ptr ;
  unsigned char Message[sizeof(struct ParamGetMessage )] ;
  I2O_UTIL_PARAMS_GET_MESSAGE *Message_Ptr ;
  unsigned short hold___2 ;
  unsigned short hold___3 ;
  unsigned short hold___4 ;
  unsigned short hold___5 ;
  I2O_MESSAGE_FRAME *tmp ;
  unsigned long hold___6 ;
  unsigned long hold___7 ;
  int tmp___0 ;

  {
  {
#line 1325
  memset((void *)(Operations), 0, sizeof(Operations));
#line 1326
  Operations_Ptr = (struct ParamOperations *)(Operations);
#line 1327
  hold___2 = (unsigned short)1;
#line 1327
  *((unsigned short *)((unsigned char *)(& Operations_Ptr->Header.OperationCount) + 0)) = hold___2;
#line 1329
  hold___3 = (unsigned short)1;
#line 1329
  *((unsigned short *)((unsigned char *)(& Operations_Ptr->Template[0].Operation) + 0)) = hold___3;
#line 1331
  hold___4 = (unsigned short)65535;
#line 1331
  *((unsigned short *)((unsigned char *)(& Operations_Ptr->Template[0].FieldCount) + 0)) = hold___4;
#line 1333
  hold___5 = (unsigned short )Group;
#line 1333
  *((unsigned short *)((unsigned char *)(& Operations_Ptr->Template[0].GroupNumber) + 0)) = hold___5;
#line 1336
  memset((void *)Header, 0, (size_t )HeaderSize);
#line 1337
  tmp = DPTI_fillMessage(Message, (unsigned short )sizeof(struct ParamGetMessage ));
#line 1337
  Message_Ptr = (PI2O_UTIL_PARAMS_GET_MESSAGE )tmp;
#line 1339
  *(& Message_Ptr->StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL + ((sizeof(I2O_UTIL_PARAMS_GET_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 1343
  Message_Ptr->StdMessageFrame.TargetAddress = (BF )TID;
#line 1344
  Message_Ptr->StdMessageFrame.Function = (BF )6;
#line 1350
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = sizeof(struct ParamOperations );
#line 1350
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )84;
#line 1350
  hold___6 = (unsigned long )((void *)((unsigned char *)Operations_Ptr));
#line 1350
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___6;
#line 1352
  Message_Ptr->SGL.u.Simple[1].FlagsCount.Count = (BF )HeaderSize;
#line 1352
  Message_Ptr->SGL.u.Simple[1].FlagsCount.Flags = (BF )208;
#line 1352
  hold___7 = (unsigned long )((void *)((unsigned char *)Header));
#line 1352
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[1].PhysicalAddress) + 0)) = hold___7;
#line 1354
  tmp___0 = DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
  }
#line 1354
  if (tmp___0 == 0) {
#line 1354
    if (Header->ResultCount) {
#line 1362
      return (0);
    }
  }
#line 1368
  return (-1);
}
}
#line 1375 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static void DPTI_acquireTargetInfo(Controller_t controller ) 
{ 
  TID_t *Device ;
  unsigned short Index ;
  DPTI_Devices_S *current ;
  DPTI_Devices_S **tmp ;
  unsigned char tmp___0 ;
  unsigned char Message[sizeof(I2O_EXEC_HRT_GET_MESSAGE )] ;
  I2O_EXEC_HRT_GET_MESSAGE *Message_Ptr ;
  I2O_HRT *hrt ;
  I2O_MESSAGE_FRAME *tmp___1 ;
  unsigned long hold___2 ;
  unsigned short NumberOfEntries ;
  PI2O_HRT_ENTRY Entry ;
  int tmp___2 ;
  struct __anonstruct_Buffer_67 Buffer ;
  int tmp___3 ;
  struct __anonstruct_Buffer_68 Buffer___0 ;
  int tmp___4 ;
  unsigned char Message___0[sizeof(struct Inquiry )] ;
  PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *Message_Ptr___0 ;
  I2O_MESSAGE_FRAME *tmp___5 ;
  unsigned short hold___3 ;
  unsigned short hold___4 ;
  unsigned long hold___5 ;
  unsigned short hold___6 ;
  unsigned long hold___7 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1380
  tmp = _DPTI_current(controller);
#line 1380
  current = *tmp;
#line 1388
  tmp___0 = (unsigned char)0;
#line 1388
  current->maxLun = tmp___0;
#line 1388
  current->maxBus = tmp___0;
#line 1394
  hrt = (I2O_HRT *)(((unsigned char *)current + (int )current->size) - sizeof(DPTI_HRT ));
#line 1399
  memset((void *)hrt, 0, sizeof(I2O_HRT ) + 7UL * sizeof(I2O_HRT_ENTRY ));
#line 1401
  tmp___1 = DPTI_fillMessage(Message, (unsigned short )((sizeof(I2O_EXEC_HRT_GET_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) + sizeof(I2O_SGE_SIMPLE_ELEMENT )));
#line 1401
  Message_Ptr = (I2O_EXEC_HRT_GET_MESSAGE *)tmp___1;
#line 1404
  *(& Message_Ptr->StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL + ((sizeof(I2O_EXEC_HRT_GET_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 1408
  Message_Ptr->StdMessageFrame.Function = (BF )168;
#line 1414
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = sizeof(I2O_HRT ) + 7UL * sizeof(I2O_HRT_ENTRY );
#line 1414
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )208;
#line 1414
  hold___2 = (unsigned long )((void *)hrt);
#line 1414
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___2;
#line 1416
  tmp___2 = DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
  }
#line 1416
  if (tmp___2 == 0) {
#line 1420
    NumberOfEntries = *((unsigned short *)((unsigned char *)(& hrt->NumberEntries) + 0));
#line 1421
    Entry = hrt->HRTEntry;
    {
#line 1422
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1422
      if (! ((int )NumberOfEntries != 0)) {
#line 1422
        goto while_break;
      }
#line 1423
      Index = current->numDevices;
#line 1423
      Device = & current->devices.tid.data[0];
      {
#line 1423
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1423
        if (! ((int )Index != 0)) {
#line 1423
          goto while_break___0;
        }
#line 1426
        if ((unsigned long )Device->TID == (*((unsigned long *)((unsigned char *)(& Entry->AdapterID) + 0)) & 4095UL)) {
#line 1428
          Device->Bus = (unsigned short )((unsigned char )(*((unsigned long *)((unsigned char *)(& Entry->AdapterID) + 0)) >> 16));
#line 1430
          if ((int )Device->Bus > (int )current->maxBus) {
#line 1431
            current->maxBus = (unsigned char )Device->Bus;
          }
#line 1434
          if ((int )Device->Lun > (int )current->maxLun) {
#line 1435
            current->maxLun = (unsigned char )Device->Lun;
          }
        }
#line 1423
        Device ++;
#line 1423
        Index = (unsigned short )((int )Index - 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1440
      Entry ++;
#line 1441
      NumberOfEntries = (unsigned short )((int )NumberOfEntries - 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1445
  current->raidNum = (unsigned char)20;
#line 1446
  Index = current->numDevices;
#line 1446
  Device = & current->devices.tid.data[0];
  {
#line 1446
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1446
    if (! ((int )Index != 0)) {
#line 1446
      goto while_break___1;
    }
#line 1448
    if (Device->Adapter) {
      {
#line 1455
      Device->Target = (unsigned short)127;
#line 1456
      Device->Lun = (unsigned short)0;
#line 1457
      tmp___3 = DPTI_getParams(controller, Device->TID, 512, & Buffer.Header, (unsigned int )sizeof(Buffer));
      }
#line 1457
      if (tmp___3 == 0) {
#line 1460
        Device->Target = (unsigned short )((unsigned char )*((unsigned long *)((unsigned char *)(& Buffer.Info.InitiatorID) + 0)));
      }
#line 1465
      current->adapterID[Device->Bus] = (unsigned char )Device->Target;
    } else {
      {
#line 1474
      Device->Bus = (unsigned short)7;
#line 1475
      Device->Target = (unsigned short)127;
#line 1476
      Device->Lun = (unsigned short)255;
#line 1477
      tmp___4 = DPTI_getParams(controller, Device->TID, 32768, & Buffer___0.Header,
                               (unsigned int )sizeof(Buffer___0));
      }
#line 1477
      if (tmp___4 == 0) {
#line 1480
        Device->Bus = (unsigned short )((unsigned char )*((unsigned short *)((unsigned char *)(& Buffer___0.Info.Bus) + 0)));
#line 1482
        Device->Target = (unsigned short )((unsigned char )*((unsigned long *)((unsigned char *)(& Buffer___0.Info.Identifier) + 0)));
#line 1484
        Device->Lun = (unsigned short )*(& Buffer___0.Info.LunInfo[0] + 1);
#line 1486
        if ((int )Device->Bus > (int )current->maxBus) {
#line 1487
          current->maxBus = (unsigned char )Device->Bus;
        }
#line 1489
        if ((int )Device->Lun > (int )current->maxLun) {
#line 1490
          current->maxLun = (unsigned char )Device->Lun;
        }
      }
    }
#line 1446
    Device ++;
#line 1446
    Index = (unsigned short )((int )Index - 1);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1505
  tmp___5 = DPTI_fillMessage(Message___0, (unsigned short )((sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) + sizeof(I2O_SGE_SIMPLE_ELEMENT )));
#line 1505
  Message_Ptr___0 = (PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *)tmp___5;
#line 1509
  *(& Message_Ptr___0->PrivateMessageFrame.StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL + ((sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 1513
  Message_Ptr___0->PrivateMessageFrame.StdMessageFrame.Function = (BF )255;
#line 1516
  hold___3 = (unsigned short)129;
#line 1516
  *((unsigned short *)((unsigned char *)(& Message_Ptr___0->PrivateMessageFrame.XFunctionCode) + 0)) = hold___3;
#line 1519
  hold___4 = (unsigned short)27;
#line 1519
  *((unsigned short *)((unsigned char *)(& Message_Ptr___0->PrivateMessageFrame.OrganizationID) + 0)) = hold___4;
#line 1521
  Message_Ptr___0->Interpret = (BF )1;
#line 1525
  *(& Message_Ptr___0->CDBLength + 0) = (unsigned char)6;
#line 1529
  Message_Ptr___0->CDB[0] = (U8 )18;
#line 1530
  Message_Ptr___0->CDB[4] = (U8 )sizeof(((struct Inquiry *)Message_Ptr___0)->Buffer);
#line 1534
  hold___5 = sizeof(((struct Inquiry *)Message_Ptr___0)->Buffer);
#line 1534
  *((unsigned long *)((unsigned char *)(& Message_Ptr___0->ByteCount) + 0)) = hold___5;
#line 1539
  hold___6 = (unsigned short)24704;
#line 1539
  *((unsigned short *)((unsigned char *)(& Message_Ptr___0->SCBFlags) + 0)) = hold___6;
#line 1542
  Message_Ptr___0->SGL.u.Simple[0].FlagsCount.Count = sizeof(((struct Inquiry *)Message_Ptr___0)->Buffer);
#line 1542
  Message_Ptr___0->SGL.u.Simple[0].FlagsCount.Flags = (BF )208;
#line 1542
  hold___7 = (unsigned long )((void *)(((struct Inquiry *)Message_Ptr___0)->Buffer));
#line 1542
  *((unsigned long *)((unsigned char *)(& Message_Ptr___0->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___7;
#line 1545
  tmp___6 = DPTI_sendMessage(controller, Message_Ptr___0);
  }
#line 1545
  if (tmp___6 == 0) {
#line 1545
    if (*((unsigned long *)(((unsigned char *)(((struct Inquiry *)Message_Ptr___0)->Buffer) + 16) + 2)) == 909523251UL) {
#line 1545
      tmp___7 = 1;
    } else
#line 1545
    if (*((unsigned long *)((unsigned char *)(((struct Inquiry *)Message_Ptr___0)->Buffer) + 16)) == 808464434UL) {
#line 1545
      tmp___7 = 1;
    } else
#line 1545
    if (*((unsigned long *)((unsigned char *)(((struct Inquiry *)Message_Ptr___0)->Buffer) + 16)) == 892350514UL) {
#line 1545
      tmp___7 = 1;
    } else
#line 1545
    if (*((unsigned long *)((unsigned char *)(((struct Inquiry *)Message_Ptr___0)->Buffer) + 16)) == 808529970UL) {
#line 1545
      tmp___7 = 1;
    } else
#line 1545
    if (*((unsigned long *)((unsigned char *)(((struct Inquiry *)Message_Ptr___0)->Buffer) + 16)) == 892416050UL) {
#line 1545
      tmp___7 = 1;
    } else {
#line 1545
      tmp___7 = 0;
    }
  } else {
#line 1545
    tmp___7 = 0;
  }
#line 1545
  current->MIPS = (unsigned char )tmp___7;
#line 1562
  return;
}
}
#line 1569 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static DPTI_Devices_S *DPTI_preloadTable(Controller_t controller ) 
{ 
  DPTI_Devices_S *current ;
  int tmp ;
  DPTI_Devices_S **tmp___0 ;

  {
  {
#line 1577
  tmp = DPTI_acquireLct(controller);
  }
#line 1577
  if (tmp == 0) {
    {
#line 1578
    DPTI_acquireTargetInfo(controller);
    }
  }
  {
#line 1580
  tmp___0 = _DPTI_current(controller);
#line 1580
  current = *tmp___0;
#line 1581
  current->controller = controller;
#line 1582
  current->valid = (unsigned char)1;
  }
#line 1584
  return (current);
}
}
#line 1588 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
void DPTI_refresh(Controller_t controller ) 
{ 
  DPTI_Devices_S **tmp ;

  {
  {
#line 1598
  tmp = _DPTI_current(controller);
#line 1598
  (*tmp)->valid = (unsigned char)0;
  }
#line 1600
  return;
}
}
#line 1606 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
void DPTI_rescan(Controller_t controller ) 
{ 
  unsigned char Message[sizeof(I2O_HBA_BUS_SCAN_MESSAGE )] ;
  I2O_HBA_BUS_SCAN_MESSAGE *Message_Ptr ;
  TID_t *Device ;
  unsigned short NumberOfDevices ;
  DPTI_Devices_S *current ;
  I2O_MESSAGE_FRAME *tmp ;
  DPTI_Devices_S **tmp___0 ;
  time_t tmp___1 ;
  DPTI_Devices_S **devices ;

  {
  {
#line 1622
  tmp = DPTI_fillMessage(Message, (unsigned short )sizeof(I2O_HBA_BUS_SCAN_MESSAGE ));
#line 1622
  Message_Ptr = (I2O_HBA_BUS_SCAN_MESSAGE *)tmp;
#line 1624
  Message_Ptr->StdMessageFrame.Function = (BF )137;
#line 1626
  tmp___0 = _DPTI_current(controller);
#line 1626
  current = *tmp___0;
#line 1631
  Device = current->devices.tid.data;
#line 1631
  NumberOfDevices = current->numDevices;
  }
  {
#line 1631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1631
    if (! ((int )NumberOfDevices != 0)) {
#line 1631
      goto while_break;
    }
#line 1633
    if (Device->Adapter) {
      {
#line 1634
      Message_Ptr->StdMessageFrame.TargetAddress = (BF )Device->TID;
#line 1636
      DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
      }
    }
#line 1631
    Device ++;
#line 1631
    NumberOfDevices = (unsigned short )((int )NumberOfDevices - 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1641
  tmp___1 = time((time_t *)((void *)0));
#line 1641
  current->lastScan = (unsigned long )tmp___1 + 10UL;
#line 1659
  devices = DPTI_devices;
  }
  {
#line 1661
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1661
    if (*devices) {
#line 1661
      if ((*devices)->valid) {
#line 1661
        if (current->lastScan - (*devices)->lastScan < 60UL) {
#line 1664
          (*devices)->lastScan = current->lastScan;
        }
      }
    }
#line 1661
    devices ++;
#line 1661
    if (! ((unsigned long )devices < (unsigned long )(& DPTI_devices[16]))) {
#line 1661
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1687
  current->enableRescan = (unsigned char)0;
#line 1688
  current->valid = (unsigned char)0;
#line 1692
  return;
}
}
#line 1699 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
void DPTI_resetBus(Controller_t controller ) 
{ 
  unsigned char Message[sizeof(I2O_HBA_BUS_RESET_MESSAGE )] ;
  I2O_HBA_BUS_RESET_MESSAGE *Message_Ptr ;
  TID_t *Device ;
  unsigned short NumberOfDevices ;
  DPTI_Devices_S *current ;
  I2O_MESSAGE_FRAME *tmp ;
  DPTI_Devices_S **tmp___0 ;
  time_t tmp___1 ;
  DPTI_Devices_S **devices ;

  {
  {
#line 1715
  tmp = DPTI_fillMessage(Message, (unsigned short )sizeof(I2O_HBA_BUS_RESET_MESSAGE ));
#line 1715
  Message_Ptr = (I2O_HBA_BUS_RESET_MESSAGE *)tmp;
#line 1717
  Message_Ptr->StdMessageFrame.Function = (BF )135;
#line 1719
  tmp___0 = _DPTI_current(controller);
#line 1719
  current = *tmp___0;
#line 1724
  Device = current->devices.tid.data;
#line 1724
  NumberOfDevices = current->numDevices;
  }
  {
#line 1724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1724
    if (! ((int )NumberOfDevices != 0)) {
#line 1724
      goto while_break;
    }
#line 1726
    if (Device->Adapter) {
      {
#line 1727
      Message_Ptr->StdMessageFrame.TargetAddress = (BF )Device->TID;
#line 1729
      DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
      }
    }
#line 1724
    Device ++;
#line 1724
    NumberOfDevices = (unsigned short )((int )NumberOfDevices - 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1734
  tmp___1 = time((time_t *)((void *)0));
#line 1734
  current->lastScan = (unsigned long )tmp___1 + 10UL;
#line 1752
  devices = DPTI_devices;
  }
  {
#line 1754
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1754
    if (*devices) {
#line 1754
      if ((*devices)->valid) {
#line 1754
        if (current->lastScan - (*devices)->lastScan < 60UL) {
#line 1757
          (*devices)->lastScan = current->lastScan;
        }
      }
    }
#line 1754
    devices ++;
#line 1754
    if (! ((unsigned long )devices < (unsigned long )(& DPTI_devices[16]))) {
#line 1754
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1780
  current->enableRescan = (unsigned char)0;
#line 1781
  current->valid = (unsigned char)0;
#line 1785
  return;
}
}
#line 1792 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
TID_t *DPTI_getDeviceAddr(Controller_t controller , unsigned char Bus , unsigned char Target ,
                          unsigned char Lun , unsigned char FW , unsigned char Phys ) 
{ 
  TID_t *Device ;
  DPTI_Devices_S *current ;
  unsigned short NumberOfDevices ;
  unsigned char Pass ;
  DPTI_Devices_S **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1824
  tmp = _DPTI_current(controller);
#line 1824
  current = *tmp;
  }
#line 1825
  if ((int )current->controller != (int )controller) {
#line 1825
    current->valid = (unsigned char)0;
#line 1825
    current->controller = controller;
  }
#line 1826
  if ((int )current->valid == 0) {
    {
#line 1827
    current = DPTI_preloadTable(controller);
    }
  }
#line 1875
  Pass = (unsigned char)0;
  {
#line 1875
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1875
    if (! ((int )Pass < 6)) {
#line 1875
      goto while_break;
    }
#line 1876
    Device = current->devices.tid.data;
#line 1876
    NumberOfDevices = current->numDevices;
    {
#line 1876
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1876
      if (! ((int )NumberOfDevices != 0)) {
#line 1876
        goto while_break___0;
      }
#line 1879
      if ((int )Device->Bus == (int )Bus) {
#line 1879
        if ((int )Device->Target == (int )Target) {
#line 1879
          if ((int )Device->Lun == (int )Lun) {
#line 1879
            if (Phys) {
#line 1879
              if ((int )Pass < 2) {
#line 1879
                tmp___0 = ! Device->RAID;
              } else {
#line 1879
                tmp___0 = (int )Device->SCSI;
              }
#line 1879
              if (tmp___0) {
#line 1879
                goto _L;
              } else {
#line 1879
                goto _L___5;
              }
            } else
            _L___5: /* CIL Label */ 
#line 1879
            if (! Phys) {
#line 1879
              if (Device->RAID) {
#line 1879
                if ((int )Pass == 4) {
#line 1879
                  goto _L;
                } else {
#line 1879
                  if ((int )Device->UserTID != 4095) {
#line 1879
                    if ((int )Device->UserTID != 1) {
#line 1879
                      tmp___1 = 1;
                    } else
#line 1879
                    if ((int )Pass == 0) {
#line 1879
                      tmp___1 = 1;
                    } else
#line 1879
                    if ((int )Pass == 2) {
#line 1879
                      tmp___1 = 1;
                    } else {
#line 1879
                      tmp___1 = 0;
                    }
                  } else {
#line 1879
                    tmp___1 = 0;
                  }
#line 1879
                  if ((int )FW == tmp___1) {
#line 1879
                    goto _L;
                  } else {
#line 1879
                    goto _L___4;
                  }
                }
              } else {
#line 1879
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 1879
            if ((int )Pass == 5) {
#line 1879
              goto _L___2;
            } else
#line 1879
            if ((int )Pass == 6) {
              _L___2: /* CIL Label */ 
#line 1879
              if (! Device->RAID) {
#line 1879
                if ((int )Device->UserTID == 4095) {
#line 1879
                  goto _L;
                } else
#line 1879
                if ((int )Device->UserTID == 1) {
#line 1879
                  if ((int )Pass == 6) {
#line 1879
                    goto _L;
                  } else {
#line 1879
                    goto _L___1;
                  }
                } else {
#line 1879
                  goto _L___1;
                }
              } else {
#line 1879
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 1879
            if ((int )Pass == 7) {
              _L: /* CIL Label */ 
#line 1879
              if (! Device->Adapter) {
#line 1898
                return (Device);
              }
            }
          }
        }
      }
#line 1876
      Device ++;
#line 1876
      NumberOfDevices = (unsigned short )((int )NumberOfDevices - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1875
    Pass = (unsigned char )((int )Pass + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1906
  return ((TID_t *)((void *)0));
}
}
#line 1910 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
TID_t *DPTI_getDeviceTID(Controller_t controller , unsigned short TID ) 
{ 
  TID_t *Device ;
  DPTI_Devices_S *current ;
  unsigned short NumberOfDevices ;
  DPTI_Devices_S **tmp ;

  {
  {
#line 1925
  tmp = _DPTI_current(controller);
#line 1925
  current = *tmp;
  }
#line 1926
  if ((int )current->controller != (int )controller) {
#line 1926
    current->valid = (unsigned char)0;
#line 1926
    current->controller = controller;
  }
#line 1927
  if ((int )current->valid == 0) {
    {
#line 1928
    current = DPTI_preloadTable(controller);
    }
  }
#line 1930
  Device = current->devices.tid.data;
#line 1930
  NumberOfDevices = current->numDevices;
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    if (! ((int )NumberOfDevices != 0)) {
#line 1930
      goto while_break;
    }
#line 1932
    if ((int )Device->TID == (int )TID) {
#line 1935
      return (Device);
    }
#line 1930
    Device ++;
#line 1930
    NumberOfDevices = (unsigned short )((int )NumberOfDevices - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1942
  return ((TID_t *)((void *)0));
}
}
#line 1950 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
unsigned short DPTI_getTID(Controller_t controller , unsigned char Bus , unsigned char Target ,
                           unsigned char Lun , unsigned char FW , unsigned char Phys ,
                           unsigned char Interpret ) 
{ 
  TID_t *Device ;

  {
  {
#line 1983
  Device = DPTI_getDeviceAddr(controller, Bus, Target, Lun, FW, Phys);
  }
#line 1983
  if ((unsigned long )Device != (unsigned long )((TID_t *)((void *)0))) {
#line 1987
    return (Device->TID);
  }
#line 1992
  if (Interpret) {
#line 1996
    return ((unsigned short)0);
  }
#line 2001
  return ((unsigned short)65535);
}
}
#line 2010 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static int DPTI_eataToI2O(Controller_t Controller , eataCP_S *eata_P , PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE i2o_P ) 
{ 
  unsigned short TID ;
  unsigned char FW ;
  unsigned char Phys ;
  unsigned char Interpret ;
  unsigned char Target ;
  unsigned char Lun ;
  unsigned char ScopeUp ;
  char *Header ;
  unsigned long unPacked ;
  unsigned long unPacked___0 ;
  unsigned short hold___2 ;
  U8 cdbLen ;
  unsigned long hold___3 ;
  unsigned long tmp ;
  unsigned short SCBFlags ;
  unsigned short hold___4 ;
  unsigned short hold___5 ;
  unsigned short hold___6 ;
  PI2O_SGE_SIMPLE_ELEMENT SE ;
  unsigned char Flags ;
  unsigned long unPacked___1 ;
  eataSG_S *SG ;
  unsigned long Count ;
  unsigned long hold___7 ;
  unsigned short hold___8 ;
  unsigned long hold___9 ;
  unsigned short hold___10 ;
  unsigned long hold___11 ;
  unsigned short hold___12 ;

  {
#line 2026
  FW = *((unsigned char *)eata_P + 5);
#line 2027
  Phys = *((unsigned char *)eata_P + 6);
#line 2028
  Interpret = (unsigned char )((int )*((unsigned char *)eata_P + 0) & 32);
#line 2030
  Target = (unsigned char )*((char *)eata_P + 2);
#line 2032
  Lun = (unsigned char )*((char *)eata_P + 3);
#line 2037
  if (((int )Target & 31) != ((int )*((unsigned char *)eata_P + 7) & 31)) {
#line 2038
    Target = (unsigned char )((int )*((unsigned char *)eata_P + 7) & 31);
  }
#line 2043
  if (((int )Lun & 7) != ((int )*((unsigned char *)eata_P + 8) & 7)) {
#line 2044
    Lun = (unsigned char )((int )*((unsigned char *)eata_P + 8) & 7);
  }
#line 2056
  if (Interpret) {
#line 2057
    ScopeUp = (unsigned char)0;
    {
#line 2061
    if ((int )*(((unsigned char *)eata_P + 12) + 0) == 21) {
#line 2061
      goto case_21;
    }
#line 2061
    if ((int )*(((unsigned char *)eata_P + 12) + 0) == 85) {
#line 2061
      goto case_21;
    }
#line 2108
    if ((int )*(((unsigned char *)eata_P + 12) + 0) == 26) {
#line 2108
      goto case_26;
    }
#line 2108
    if ((int )*(((unsigned char *)eata_P + 12) + 0) == 90) {
#line 2108
      goto case_26;
    }
#line 2059
    goto switch_break;
    case_21: /* CIL Label */ 
    case_85: /* CIL Label */ 
#line 2064
    if ((int )*((unsigned char *)eata_P + 0) & 8) {
#line 2067
      unPacked = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 2068
      unPacked = unPacked;
#line 2069
      Header = (char *)((void *)unPacked);
#line 2070
      unPacked = *((unsigned long *)((unsigned char *)((eataSG_S *)Header) + 0));
#line 2072
      unPacked = unPacked;
#line 2073
      Header = (char *)((void *)unPacked);
    } else {
#line 2077
      unPacked___0 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 2078
      unPacked___0 = unPacked___0;
#line 2079
      Header = (char *)((void *)unPacked___0);
    }
#line 2085
    if ((int )*(((unsigned char *)eata_P + 12) + 0) == 85) {
#line 2088
      Header += (int )((unsigned short )*((unsigned char *)(Header + 6) + 1)) + ((int )((unsigned short )*((unsigned char *)(Header + 6) + 0)) << 8);
#line 2090
      Header += sizeof(modeHeader_S );
    } else {
#line 2093
      Header += (int )*(Header + 3);
#line 2095
      Header += sizeof(modeHeader6_S );
    }
    {
#line 2103
    if ((63 & (int )*(Header + 0)) == 60) {
#line 2103
      goto case_60;
    }
#line 2103
    if ((63 & (int )*(Header + 0)) == 59) {
#line 2103
      goto case_60;
    }
#line 2103
    if ((63 & (int )*(Header + 0)) == 57) {
#line 2103
      goto case_60;
    }
#line 2103
    if ((63 & (int )*(Header + 0)) == 48) {
#line 2103
      goto case_60;
    }
#line 2102
    goto switch_break___0;
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 2104
    ScopeUp = (unsigned char )((int )ScopeUp + 1);
    switch_break___0: /* CIL Label */ ;
    }
    case_26: /* CIL Label */ 
    case_90: /* CIL Label */ 
    {
#line 2110
    if (((int )*(((unsigned char *)eata_P + 12) + 2) & 63) == 60) {
#line 2110
      goto case_60___0;
    }
#line 2110
    if (((int )*(((unsigned char *)eata_P + 12) + 2) & 63) == 59) {
#line 2110
      goto case_60___0;
    }
#line 2110
    if (((int )*(((unsigned char *)eata_P + 12) + 2) & 63) == 57) {
#line 2110
      goto case_60___0;
    }
#line 2110
    if (((int )*(((unsigned char *)eata_P + 12) + 2) & 63) == 48) {
#line 2110
      goto case_60___0;
    }
#line 2109
    goto switch_break___1;
    case_60___0: /* CIL Label */ 
    case_59___0: /* CIL Label */ 
    case_57___0: /* CIL Label */ 
    case_48___0: /* CIL Label */ 
#line 2111
    ScopeUp = (unsigned char )((int )ScopeUp + 1);
    switch_break___1: /* CIL Label */ ;
    }
#line 2113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2115
    if (ScopeUp) {
#line 2116
      FW = Phys;
#line 2117
      Phys = (unsigned char)0;
    }
  }
  {
#line 2120
  TID = DPTI_getTID(Controller, (unsigned char )((int )*((unsigned char *)eata_P + 7) >> 5),
                    Target, Lun, FW, Phys, Interpret);
  }
#line 2120
  if ((int )TID == 65535) {
#line 2128
    return (-1);
  }
#line 2130
  i2o_P->PrivateMessageFrame.StdMessageFrame.TargetAddress = (BF )TID;
#line 2132
  hold___2 = (unsigned short)27;
#line 2132
  *((unsigned short *)((unsigned char *)(& i2o_P->PrivateMessageFrame.OrganizationID) + 0)) = hold___2;
#line 2134
  i2o_P->TID = (BF )TID;
#line 2135
  i2o_P->Interpret = (BF )(((int )*((unsigned char *)eata_P + 0) & 32) != 0);
#line 2137
  i2o_P->Physical = (BF )((int )*((unsigned char *)eata_P + 6) != 0);
  {
#line 2147
  if (((int )*(((unsigned char *)eata_P + 12) + 0) & 224) == 0) {
#line 2147
    goto case_0;
  }
#line 2149
  if (((int )*(((unsigned char *)eata_P + 12) + 0) & 224) == 64) {
#line 2149
    goto case_64;
  }
#line 2149
  if (((int )*(((unsigned char *)eata_P + 12) + 0) & 224) == 32) {
#line 2149
    goto case_64;
  }
#line 2150
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2147
  cdbLen = (U8 )6;
#line 2147
  goto switch_break___2;
  case_64: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 2149
  cdbLen = (U8 )10;
#line 2149
  goto switch_break___2;
  switch_default: /* CIL Label */ 
#line 2154
  cdbLen = (U8 )12;
#line 2154
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 2160
  memcpy((void */* __restrict  */)(i2o_P->CDB), (void const   */* __restrict  */)((void *)((unsigned char *)eata_P + 12)),
         (size_t )cdbLen);
#line 2161
  *(& i2o_P->CDBLength + 0) = cdbLen;
  }
#line 2166
  if ((int )*((unsigned char *)eata_P + 0) & 192) {
#line 2166
    tmp = *((unsigned long *)((unsigned char *)eata_P + 24));
  } else {
#line 2166
    tmp = 0UL;
  }
#line 2166
  hold___3 = tmp;
#line 2166
  *((unsigned long *)((unsigned char *)(& i2o_P->ByteCount) + 0)) = hold___3;
#line 2171
  if (i2o_P->ByteCount == 0UL) {
#line 2172
    *((unsigned char *)eata_P + 0) = (unsigned char )((int )*((unsigned char *)eata_P + 0) & 63);
  }
#line 2178
  SCBFlags = (unsigned short)0;
#line 2180
  if ((int )*((unsigned char *)eata_P + 0) & 128) {
#line 2184
    SCBFlags = (unsigned short)16384;
  } else
#line 2186
  if ((int )*((unsigned char *)eata_P + 0) & 64) {
#line 2190
    SCBFlags = (unsigned short)32768;
  }
#line 2195
  SCBFlags = (unsigned short )((int )SCBFlags | 8320);
#line 2197
  if ((int )*((unsigned char *)eata_P + 0) & 4) {
#line 2205
    SCBFlags = (unsigned short )((int )SCBFlags | 32);
  } else {
#line 2208
    SCBFlags = (unsigned short )((int )SCBFlags & -97);
  }
#line 2210
  hold___4 = SCBFlags;
#line 2210
  *((unsigned short *)((unsigned char *)(& i2o_P->SCBFlags) + 0)) = hold___4;
#line 2216
  *(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL | ((sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 2227
  hold___5 = (unsigned short )((sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ));
#line 2227
  *((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___5;
#line 2235
  i2o_P->PrivateMessageFrame.StdMessageFrame.Function = (BF )255;
#line 2237
  hold___6 = (unsigned short)129;
#line 2237
  *((unsigned short *)((unsigned char *)(& i2o_P->PrivateMessageFrame.XFunctionCode) + 0)) = hold___6;
#line 2246
  Flags = (unsigned char)16;
#line 2248
  if ((int )*((unsigned char *)eata_P + 0) & 64) {
#line 2249
    Flags = (unsigned char )((int )Flags | 4);
  }
#line 2252
  SE = i2o_P->SGL.u.Simple;
#line 2253
  if ((int )*((unsigned char *)eata_P + 0) & 8) {
#line 2257
    unPacked___1 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 2258
    unPacked___1 = unPacked___1;
#line 2259
    SG = (eataSG_S *)((void *)unPacked___1);
#line 2260
    Count = *((unsigned long *)((unsigned char *)eata_P + 24)) >> 3;
    {
#line 2267
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2267
      if (! Count) {
#line 2267
        goto while_break;
      }
#line 2269
      SE->FlagsCount.Count = *((unsigned long *)((unsigned char *)SG + 4));
#line 2271
      unPacked___1 = *((unsigned long *)((unsigned char *)SG + 0));
#line 2272
      unPacked___1 = unPacked___1;
#line 2273
      hold___7 = unPacked___1;
#line 2273
      *((unsigned long *)((unsigned char *)(& SE->PhysicalAddress) + 0)) = hold___7;
#line 2275
      SG ++;
#line 2276
      Count --;
#line 2276
      if (Count == 0UL) {
#line 2277
        Flags = (unsigned char )((int )Flags | 64);
#line 2278
        if (((int )*((unsigned char *)eata_P + 0) & 4) == 0) {
#line 2279
          Flags = (unsigned char )((int )Flags | 128);
        }
      }
#line 2282
      SE->FlagsCount.Flags = (BF )Flags;
#line 2283
      SE ++;
#line 2284
      hold___8 = (unsigned short )((unsigned long )*((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) + (sizeof(I2O_SGE_SIMPLE_ELEMENT ) >> 2));
#line 2284
      *((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___8;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 2290
  if ((int )*((unsigned char *)eata_P + 0) & 192) {
#line 2294
    if ((int )*((unsigned char *)eata_P + 0) & 192) {
#line 2294
      SE->FlagsCount.Count = *((unsigned long *)((unsigned char *)eata_P + 24));
    } else {
#line 2294
      SE->FlagsCount.Count = (BF )0;
    }
#line 2297
    Flags = (unsigned char )((int )Flags | 64);
#line 2298
    if (((int )*((unsigned char *)eata_P + 0) & 4) == 0) {
#line 2299
      Flags = (unsigned char )((int )Flags | 128);
    }
#line 2301
    SE->FlagsCount.Flags = (BF )Flags;
#line 2303
    unPacked___1 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 2304
    unPacked___1 = unPacked___1;
#line 2305
    hold___9 = unPacked___1;
#line 2305
    *((unsigned long *)((unsigned char *)(& SE->PhysicalAddress) + 0)) = hold___9;
#line 2307
    SE ++;
#line 2308
    hold___10 = (unsigned short )((unsigned long )*((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) + (sizeof(I2O_SGE_SIMPLE_ELEMENT ) >> 2));
#line 2308
    *((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___10;
  }
#line 2314
  if ((int )*((unsigned char *)eata_P + 0) & 4) {
#line 2315
    SE->FlagsCount.Count = (BF )*((unsigned char *)eata_P + 1);
#line 2317
    SE->FlagsCount.Flags = (BF )208;
#line 2321
    unPacked___1 = *((unsigned long *)((unsigned char *)eata_P + 40));
#line 2322
    unPacked___1 = unPacked___1;
#line 2323
    hold___11 = unPacked___1;
#line 2323
    *((unsigned long *)((unsigned char *)(& SE->PhysicalAddress) + 0)) = hold___11;
#line 2325
    hold___12 = (unsigned short )((unsigned long )*((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) + (sizeof(I2O_SGE_SIMPLE_ELEMENT ) >> 2));
#line 2325
    *((unsigned short *)(& i2o_P->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___12;
  }
#line 2336
  return (0);
}
}
#line 2343 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned char DPTI_SpoofedInquiry[36]  = 
#line 2343
  {      (unsigned char)3,      (unsigned char)0,      (unsigned char)2,      (unsigned char)2, 
        (unsigned char)51,      (unsigned char)0,      (unsigned char)0,      (unsigned char)114, 
        (unsigned char )'D',      (unsigned char )'P',      (unsigned char )'T',      (unsigned char )' ', 
        (unsigned char )' ',      (unsigned char )' ',      (unsigned char )' ',      (unsigned char )' ', 
        (unsigned char )'P',      (unsigned char )'M',      (unsigned char )'1',      (unsigned char )'5', 
        (unsigned char )'5',      (unsigned char )'4',      (unsigned char )'U',      (unsigned char )'W', 
        (unsigned char )' ',      (unsigned char )' ',      (unsigned char )' ',      (unsigned char )' ', 
        (unsigned char )' ',      (unsigned char )' ',      (unsigned char )' ',      (unsigned char )' ', 
        (unsigned char )'3',      (unsigned char )'1',      (unsigned char )'0',      (unsigned char )'6'};
#line 2358 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned char DPTI_SpoofedRdConfig[37]  = 
#line 2358
  {      (unsigned char)3,      (unsigned char)0,      (unsigned char)0,      (unsigned char)34, 
        (unsigned char )'E',      (unsigned char )'A',      (unsigned char )'T',      (unsigned char )'A', 
        (unsigned char)16,      (unsigned char)145,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char )sizeof(eataCP_S ), 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char )sizeof(eataSP_S ), 
        (unsigned char)0,      (unsigned char)64,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)64,      (unsigned char)27,      (unsigned char)11, 
        (unsigned char)0,      (unsigned char)15,      (unsigned char)7,      (unsigned char)65, 
        (unsigned char)20};
#line 2393 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static int DPTI_CommandFlash(Controller_t controller , unsigned short flashCommand ,
                             unsigned char region , unsigned long offset , unsigned long SGA1 ,
                             unsigned long SGL1 , unsigned long SGA2 , unsigned short SGL2 ,
                             unsigned long SGA3 , unsigned short SGL3 , unsigned long SGA4 ,
                             unsigned short SGL4 ) 
{ 
  unsigned char Message[sizeof(struct FlashRegionMessage )] ;
  PRIVATE_FLASH_REGION_MESSAGE *Message_Ptr ;
  unsigned char Flags ;
  I2O_MESSAGE_FRAME *tmp ;
  unsigned short hold___2 ;
  unsigned long hold___3 ;
  unsigned long hold___4 ;
  unsigned short hold___5 ;
  unsigned long hold___6 ;
  unsigned long hold___7 ;
  unsigned short hold___8 ;
  unsigned long hold___9 ;
  unsigned short hold___10 ;
  unsigned long hold___11 ;
  unsigned short hold___12 ;
  unsigned long hold___13 ;
  int tmp___0 ;

  {
  {
#line 2415
  Flags = (unsigned char)16;
#line 2423
  tmp = DPTI_fillMessage(Message, (unsigned short )((sizeof(PRIVATE_FLASH_REGION_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) + sizeof(I2O_SGE_SIMPLE_ELEMENT )));
#line 2423
  Message_Ptr = (PRIVATE_FLASH_REGION_MESSAGE *)tmp;
#line 2426
  *(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL | ((sizeof(PRIVATE_FLASH_REGION_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 2430
  hold___2 = (unsigned short)27;
#line 2430
  *((unsigned short *)((unsigned char *)(& Message_Ptr->PrivateMessageFrame.OrganizationID) + 0)) = hold___2;
#line 2432
  Message_Ptr->PrivateMessageFrame.StdMessageFrame.Function = (BF )255;
#line 2434
  hold___3 = (unsigned long )region;
#line 2434
  *((unsigned long *)((unsigned char *)(& Message_Ptr->FlashRegion) + 0)) = hold___3;
#line 2435
  hold___4 = offset;
#line 2435
  *((unsigned long *)((unsigned char *)(& Message_Ptr->RegionOffset) + 0)) = hold___4;
#line 2437
  hold___5 = flashCommand;
#line 2437
  *((unsigned short *)((unsigned char *)(& Message_Ptr->PrivateMessageFrame.XFunctionCode) + 0)) = hold___5;
  }
#line 2439
  if ((int )flashCommand == 258) {
#line 2440
    Flags = (unsigned char)20;
  }
#line 2456
  hold___6 = ((SGL1 + (unsigned long )SGL2) + (unsigned long )SGL3) + (unsigned long )SGL4;
#line 2456
  *((unsigned long *)((unsigned char *)(& Message_Ptr->ByteCount) + 0)) = hold___6;
#line 2458
  if (*((unsigned long *)((unsigned char *)(& Message_Ptr->ByteCount) + 0)) == 0UL) {
#line 2459
    *(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 0) = (unsigned char)1;
  }
#line 2463
  Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = SGL1;
#line 2464
  hold___7 = SGA1;
#line 2464
  *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___7;
#line 2466
  if (SGL2) {
#line 2467
    Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )Flags;
#line 2469
    hold___8 = (unsigned short )((unsigned long )*((unsigned short *)(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) + sizeof(I2O_SGE_SIMPLE_ELEMENT ) / sizeof(U32 ));
#line 2469
    *((unsigned short *)(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___8;
#line 2474
    hold___9 = SGA2;
#line 2474
    *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[1].PhysicalAddress) + 0)) = hold___9;
#line 2476
    Message_Ptr->SGL.u.Simple[1].FlagsCount.Count = (BF )SGL2;
#line 2478
    if (SGL3) {
#line 2479
      Message_Ptr->SGL.u.Simple[1].FlagsCount.Flags = (BF )Flags;
#line 2481
      hold___10 = (unsigned short )((unsigned long )*((unsigned short *)(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) + sizeof(I2O_SGE_SIMPLE_ELEMENT ) / sizeof(U32 ));
#line 2481
      *((unsigned short *)(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___10;
#line 2486
      hold___11 = SGA3;
#line 2486
      *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[2].PhysicalAddress) + 0)) = hold___11;
#line 2488
      Message_Ptr->SGL.u.Simple[2].FlagsCount.Count = (BF )SGL3;
#line 2490
      if (SGL4) {
#line 2491
        Message_Ptr->SGL.u.Simple[2].FlagsCount.Flags = (BF )Flags;
#line 2493
        hold___12 = (unsigned short )((unsigned long )*((unsigned short *)(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) + sizeof(I2O_SGE_SIMPLE_ELEMENT ) / sizeof(U32 ));
#line 2493
        *((unsigned short *)(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 2)) = hold___12;
#line 2498
        hold___13 = SGA4;
#line 2498
        *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[3].PhysicalAddress) + 0)) = hold___13;
#line 2500
        Message_Ptr->SGL.u.Simple[3].FlagsCount.Count = (BF )SGL4;
#line 2502
        Message_Ptr->SGL.u.Simple[3].FlagsCount.Flags = (BF )(((int )Flags | 64) | 128);
      } else {
#line 2506
        Message_Ptr->SGL.u.Simple[2].FlagsCount.Flags = (BF )(((int )Flags | 64) | 128);
      }
    } else {
#line 2511
      Message_Ptr->SGL.u.Simple[1].FlagsCount.Flags = (BF )(((int )Flags | 64) | 128);
    }
  } else {
#line 2516
    Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )(((int )Flags | 64) | 128);
  }
  {
#line 2519
  tmp___0 = DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
  }
#line 2519
  return (tmp___0);
}
}
#line 2526 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static void DPTI_FlashRegionSizes(Controller_t controller , unsigned long *sizeRegion ) 
{ 
  unsigned char Message[sizeof(PRIVATE_FLASH_REGION_MESSAGE )] ;
  PRIVATE_FLASH_REGION_MESSAGE *Message_Ptr ;
  I2O_MESSAGE_FRAME *tmp ;
  unsigned short hold___2 ;
  unsigned short hold___3 ;
  unsigned long hold___4 ;
  unsigned long hold___5 ;

  {
  {
#line 2533
  *(sizeRegion + 0) = 770048UL;
#line 2534
  *(sizeRegion + 1) = 262144UL;
#line 2535
  *(sizeRegion + 2) = 8192UL;
#line 2536
  *(sizeRegion + 3) = 8192UL;
#line 2538
  tmp = DPTI_fillMessage(Message, (unsigned short )((sizeof(PRIVATE_FLASH_REGION_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) + sizeof(I2O_SGE_SIMPLE_ELEMENT )));
#line 2538
  Message_Ptr = (PRIVATE_FLASH_REGION_MESSAGE *)tmp;
#line 2541
  *(& Message_Ptr->PrivateMessageFrame.StdMessageFrame.VersionOffset + 0) = (unsigned char )(1UL | ((sizeof(PRIVATE_FLASH_REGION_MESSAGE ) - sizeof(I2O_SG_ELEMENT )) / sizeof(U32 ) << 4));
#line 2545
  hold___2 = (unsigned short)27;
#line 2545
  *((unsigned short *)((unsigned char *)(& Message_Ptr->PrivateMessageFrame.OrganizationID) + 0)) = hold___2;
#line 2547
  Message_Ptr->PrivateMessageFrame.StdMessageFrame.Function = (BF )255;
#line 2549
  hold___3 = (unsigned short)256;
#line 2549
  *((unsigned short *)((unsigned char *)(& Message_Ptr->PrivateMessageFrame.XFunctionCode) + 0)) = hold___3;
  }
  {
#line 2551
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2552
    Message_Ptr->SGL.u.Simple[0].FlagsCount.Count = sizeof(*(sizeRegion + 0));
#line 2552
    Message_Ptr->SGL.u.Simple[0].FlagsCount.Flags = (BF )208;
#line 2552
    hold___4 = (unsigned long )((void *)(sizeRegion + *((unsigned long *)((unsigned char *)(& Message_Ptr->FlashRegion) + 0))));
#line 2552
    *((unsigned long *)((unsigned char *)(& Message_Ptr->SGL.u.Simple[0].PhysicalAddress) + 0)) = hold___4;
#line 2555
    DPTI_sendMessage(controller, (PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE )Message_Ptr);
#line 2563
    hold___5 = *((unsigned long *)((unsigned char *)(& Message_Ptr->FlashRegion) + 0)) + 1UL;
#line 2563
    *((unsigned long *)((unsigned char *)(& Message_Ptr->FlashRegion) + 0)) = hold___5;
    }
#line 2551
    if (! (*((unsigned long *)((unsigned char *)(& Message_Ptr->FlashRegion) + 0)) < 4UL)) {
#line 2551
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2566
  return;
}
}
#line 2800 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
unsigned short DPTI_BootFlags  ;
#line 2802 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
unsigned long DPTI_BootBlockSize(void) 
{ 
  unsigned long DPTI_BootBlockSize___0 ;

  {
#line 2809
  DPTI_BootBlockSize___0 = 16384UL;
  {
#line 2811
  if (((int )DPTI_BootFlags & 15) == 15) {
#line 2811
    goto case_15;
  }
#line 2814
  if (((int )DPTI_BootFlags & 15) == 4) {
#line 2814
    goto case_4;
  }
#line 2817
  if (((int )DPTI_BootFlags & 15) == 2) {
#line 2817
    goto case_2;
  }
#line 2820
  goto switch_default;
  case_15: /* CIL Label */ 
#line 2812
  DPTI_BootBlockSize___0 = 0UL;
#line 2813
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2815
  DPTI_BootBlockSize___0 <<= 1;
  case_2: /* CIL Label */ 
#line 2818
  DPTI_BootBlockSize___0 <<= 1;
  switch_default: /* CIL Label */ 
#line 2821
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2823
  return (DPTI_BootBlockSize___0);
}
}
#line 2826 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static int DPTI_FlashCommand(Controller_t controller , unsigned short flashCommand ,
                             unsigned long offset , unsigned long SGA1 , unsigned long SGL1 ,
                             unsigned long SGA2 , unsigned short SGL2 , unsigned long SGA3 ,
                             unsigned short SGL3 , unsigned long SGA4 , unsigned short SGL4 ) 
{ 
  unsigned long RegionLimits[5] ;
  unsigned char region ;
  int retVal ;
  unsigned long SGA[4] ;
  unsigned long SGL[4] ;
  unsigned long Offset ;
  unsigned long Length ;
  unsigned short Index ;
  unsigned short retry ;
  unsigned long tmp ;
  unsigned long LocalOffset ;
  char *buffer ;
  char *flash ;
  unsigned short TestLength ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned long SGOffset ;
  char *bp ;
  char *fp ;

  {
  {
#line 2842
  retVal = ~ 0;
#line 2844
  RegionLimits[0] = 0UL;
#line 2844
  region = (unsigned char )RegionLimits[0];
#line 2845
  DPTI_FlashRegionSizes(controller, RegionLimits + 1);
  }
  {
#line 2846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2849
    Offset = offset;
#line 2858
    Length = 0UL;
#line 2858
    Index = (unsigned short )((unsigned char )Length);
#line 2862
    SGA[0] = SGA1;
#line 2863
    SGA[1] = SGA2;
#line 2864
    SGA[2] = SGA3;
#line 2865
    SGA[3] = SGA4;
#line 2866
    SGL[0] = SGL1;
#line 2867
    SGL[1] = (unsigned long )SGL2;
#line 2868
    SGL[2] = (unsigned long )SGL3;
#line 2869
    SGL[3] = (unsigned long )SGL4;
    {
#line 2873
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2874
      if (SGL[Index] == 0UL) {
#line 2875
        goto while_break___0;
      }
#line 2877
      Length += SGL[Index];
#line 2873
      Index = (unsigned short )((int )Index + 1);
#line 2873
      if (! ((int )Index < 4)) {
#line 2873
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2882
    if ((int )DPTI_BootFlags & 4096) {
#line 2883
      if ((int )region == 0) {
        {
#line 2884
        RegionLimits[0] = DPTI_BootBlockSize();
        }
#line 2886
        if (Offset + Length <= RegionLimits[0]) {
#line 2887
          retVal = 0;
        }
      }
    } else
#line 2891
    if ((int )region == 1) {
      {
#line 2893
      RegionLimits[0] = RegionLimits[1];
#line 2894
      tmp = DPTI_BootBlockSize();
#line 2894
      RegionLimits[1] += tmp;
      }
#line 2896
      if (RegionLimits[0] <= Offset) {
#line 2896
        if (Offset + Length <= RegionLimits[1]) {
#line 2898
          retVal = 0;
        }
      }
    }
#line 2904
    Length = 0UL;
#line 2904
    Index = (unsigned short )((unsigned char )Length);
#line 2905
    RegionLimits[(int )region + 1] += RegionLimits[region];
    {
#line 2910
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2910
      if (SGL[0]) {
#line 2910
        if (! (SGL[0] + Offset <= RegionLimits[region])) {
#line 2910
          goto while_break___1;
        }
      } else {
#line 2910
        goto while_break___1;
      }
#line 2911
      Offset += SGL[0];
#line 2912
      SGL[0] = SGL[1];
#line 2912
      if (SGL[0] == 0UL) {
#line 2913
        return (0);
      }
#line 2915
      SGA[0] = SGA[1];
#line 2916
      SGL[1] = SGL[2];
#line 2917
      SGA[1] = SGA[2];
#line 2918
      SGL[2] = SGL[3];
#line 2919
      SGL[3] = 0UL;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2921
    if (SGL[0] == 0UL) {
#line 2925
      goto __Cont;
    }
#line 2928
    if (Offset < RegionLimits[region]) {
#line 2929
      SGL[0] -= RegionLimits[region] - Offset;
#line 2930
      SGA[0] += RegionLimits[region] - Offset;
#line 2931
      Offset = RegionLimits[region];
    }
    {
#line 2933
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2934
      if (SGL[Index] == 0UL) {
#line 2935
        goto while_break___2;
      }
#line 2937
      if (Offset + Length >= RegionLimits[(int )region + 1]) {
#line 2938
        SGL[Index] = 0UL;
      } else
#line 2939
      if ((SGL[Index] + Offset) + Length > RegionLimits[(int )region + 1]) {
#line 2940
        SGL[Index] = (RegionLimits[(int )region + 1] - Offset) - Length;
      }
#line 2942
      Length += SGL[Index];
#line 2933
      Index = (unsigned short )((int )Index + 1);
#line 2933
      if (! ((int )Index < 4)) {
#line 2933
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2944
    if (SGL[0] == 0UL) {
#line 2948
      goto __Cont;
    }
#line 2953
    retVal = -1;
#line 2953
    retry = (unsigned short)2;
    {
#line 2953
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2953
      if (retry) {
#line 2953
        if (! (retVal != 0)) {
#line 2953
          goto while_break___3;
        }
      } else {
#line 2953
        goto while_break___3;
      }
      {
#line 2955
      LocalOffset = Offset - RegionLimits[region];
#line 2956
      retVal = DPTI_CommandFlash(controller, flashCommand, region, LocalOffset, SGA[0],
                                 SGL[0], SGA[1], (unsigned short )SGL[1], SGA[2],
                                 (unsigned short )SGL[2], SGA[3], (unsigned short )SGL[3]);
      }
#line 2956
      if (retVal != 0) {
#line 2960
        goto __Cont___0;
      }
#line 2963
      if ((int )flashCommand == 258) {
        {
#line 2967
        tmp___0 = malloc((size_t )512);
#line 2967
        buffer = (char *)tmp___0;
        }
#line 2967
        if ((unsigned long )buffer == (unsigned long )((char *)((void *)0))) {
#line 2968
          goto while_break___3;
        }
        {
#line 2970
        tmp___1 = malloc((size_t )512);
#line 2970
        flash = (char *)tmp___1;
        }
#line 2970
        if ((unsigned long )flash == (unsigned long )((char *)((void *)0))) {
          {
#line 2971
          free((void *)buffer);
          }
#line 2972
          goto while_break___3;
        }
#line 2974
        Index = (unsigned short)0;
        {
#line 2974
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2974
          if (! ((int )Index == 0)) {
#line 2974
            goto while_break___4;
          }
#line 2975
          SGOffset = (LocalOffset - Offset) + RegionLimits[region];
          {
#line 2979
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2979
            if (! (SGOffset >= SGL[Index])) {
#line 2979
              goto while_break___5;
            }
#line 2980
            SGOffset -= SGL[Index];
#line 2981
            Index = (unsigned short )((int )Index + 1);
#line 2981
            if ((unsigned long )Index > sizeof(SGL) / sizeof(SGL[0])) {
#line 2982
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2985
          if ((unsigned long )Index == sizeof(SGL) / sizeof(SGL[0])) {
#line 2986
            Index = (unsigned short)0;
#line 2987
            goto while_break___4;
          }
#line 2989
          TestLength = (unsigned short)512;
#line 2989
          if ((unsigned long )TestLength > SGL[Index] - SGOffset) {
#line 2990
            TestLength = (unsigned short )(SGL[Index] - SGOffset);
          }
          {
#line 2993
          retVal = DPTI_CommandFlash(controller, (unsigned short)257, region, LocalOffset,
                                     (unsigned long )buffer, 512UL, 0UL, (unsigned short)0,
                                     0UL, (unsigned short)0, 0UL, (unsigned short)0);
          }
#line 2993
          if (retVal != 0) {
#line 2997
            Index = (unsigned short )((int )Index + 1);
#line 2998
            goto while_break___4;
          }
          {
#line 3000
          memcpy((void */* __restrict  */)flash, (void const   */* __restrict  */)((void *)((unsigned char *)(SGA[Index] + SGOffset))),
                 (size_t )TestLength);
#line 3001
          bp = buffer;
#line 3001
          fp = flash;
#line 3001
          Index = TestLength;
          }
          {
#line 3001
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3001
            if (Index) {
#line 3001
              if (! ((int )*bp == (int )*fp)) {
#line 3001
                goto while_break___6;
              }
            } else {
#line 3001
              goto while_break___6;
            }
#line 3001
            bp ++;
#line 3001
            fp ++;
#line 3001
            Index = (unsigned short )((int )Index - 1);
          }
          while_break___6: /* CIL Label */ ;
          }
#line 2974
          LocalOffset += (unsigned long )TestLength;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 3006
        free((void *)buffer);
#line 3007
        free((void *)flash);
        }
#line 3009
        if (Index) {
#line 3010
          if (retVal == 0) {
#line 3011
            retVal = 1024;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2953
      retry = (unsigned short )((int )retry - 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3026
    if ((int )flashCommand == 258) {
#line 3026
      if ((int )region == 0) {
#line 3026
        if (RegionLimits[1] - 65536UL <= Offset) {
#line 3026
          if (retVal == 0) {
            {
#line 3031
            retVal = DPTI_CommandFlash(controller, (unsigned short)259, region, 0UL,
                                       0UL, 0UL, 0UL, (unsigned short)0, 0UL, (unsigned short)0,
                                       0UL, (unsigned short)0);
            }
#line 3031
            if (retVal != 0) {
#line 3031
              if (retVal != 10) {
#line 3035
                goto while_break;
              }
            }
#line 3037
            retVal = 0;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2846
    region = (unsigned char )((int )region + 1);
#line 2846
    if (! ((int )region < 4)) {
#line 2846
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3178
  return (retVal);
}
}
#line 3186 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned long DPTI_getFlashOffset(Controller_t controller , unsigned long Offset ,
                                         unsigned char *Segments ) 
{ 
  unsigned long sizeRegion[5] ;
  unsigned int Index ;
  unsigned short Skew ;
  unsigned long tmp ;
  DPTI_Devices_S **tmp___0 ;
  unsigned long BaseRegion ;
  unsigned long TopRegion ;
  unsigned long tmp___1 ;
  long flashOffset___0 ;

  {
  {
#line 3196
  sizeRegion[0] = 0UL;
#line 3196
  Index = (unsigned int )sizeRegion[0];
#line 3196
  Skew = (unsigned short )Index;
#line 3197
  DPTI_FlashRegionSizes(controller, sizeRegion + 1);
  }
#line 3198
  if ((int )DPTI_BootFlags & 4096) {
    {
#line 3199
    sizeRegion[0] = DPTI_BootBlockSize();
    }
  } else {
    {
#line 3201
    tmp = DPTI_BootBlockSize();
#line 3201
    sizeRegion[1] += tmp;
    }
  }
#line 3208
  if (Offset < sizeRegion[1]) {
    {
#line 3208
    tmp___0 = _DPTI_current(controller);
    }
#line 3208
    if ((*tmp___0)->MIPS) {
#line 3209
      Skew = (unsigned short)16384;
    }
  }
  {
#line 3215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3219
    BaseRegion = sizeRegion[Index];
#line 3219
    tmp___1 = sizeRegion[Index + 1U] + BaseRegion;
#line 3219
    sizeRegion[Index + 1U] = tmp___1;
#line 3219
    TopRegion = tmp___1;
#line 3220
    if (Offset < TopRegion) {
#line 3221
      flashOffset___0 = (long )((BaseRegion + (((Offset - BaseRegion) + (unsigned long )Skew) & 4294901760UL)) - (unsigned long )Skew);
#line 3224
      if (BaseRegion > Offset) {
#line 3225
        if (Segments) {
#line 3226
          *Segments = (unsigned char )((int )((unsigned char )((int )((unsigned short )BaseRegion) >> 14)) - (int )((unsigned char )((int )((unsigned short )Offset) >> 14)));
        }
#line 3229
        if (flashOffset___0 < 0L) {
#line 3230
          flashOffset___0 = 0L;
        }
      } else {
#line 3233
        sizeRegion[0] = 65536UL - (unsigned long )Skew;
#line 3234
        if (flashOffset___0 <= 0L) {
#line 3235
          flashOffset___0 = (long )((unsigned long )flashOffset___0 + (unsigned long )Skew);
        } else
#line 3236
        if ((unsigned long )flashOffset___0 - BaseRegion >= sizeRegion[0]) {
#line 3238
          Skew = (unsigned short)0;
#line 3239
          sizeRegion[0] = 65536UL;
        }
#line 3241
        if (Segments) {
#line 3242
          if ((unsigned long )flashOffset___0 + sizeRegion[0] > TopRegion) {
#line 3243
            sizeRegion[0] = TopRegion - (unsigned long )flashOffset___0;
          }
#line 3245
          *Segments = (unsigned char )(sizeRegion[0] >> 14);
        }
      }
#line 3248
      return ((unsigned long )flashOffset___0);
    }
#line 3251
    Skew = (unsigned short)0;
#line 3215
    Index ++;
#line 3215
    if (! (Index < 4U)) {
#line 3215
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3253
  if (Segments) {
#line 3254
    *Segments = (unsigned char)0;
  }
#line 3256
  return (sizeRegion[4]);
}
}
#line 3866 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned char *flashBuffers[4]  ;
#line 3867 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned long flashOffset  ;
#line 3868 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static unsigned char flashSegments  ;
#line 3264 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
static int DPTI_eataToSpoof(Controller_t controller , eataCP_S *eata_P , void (*callback)(Controller_t controller ,
                                                                                          Status_t status ,
                                                                                          Sense_t sense ) ) 
{ 
  unsigned long Length ;
  unsigned char opCode___0 ;
  DPTI_Devices_S *current ;
  DPTI_Devices_S **tmp ;
  eataSP_S Status ;
  eataSP_S *statusPointer ;
  unsigned long unPacked ;
  unsigned char tmp___0 ;
  unsigned char buffer[255] ;
  unsigned char pageCode ;
  unsigned char PhysicalDeviceBaseInquiry ;
  int tmp___1 ;
  unsigned char OriginalLun ;
  unsigned char Found[8][16] ;
  time_t tmp___2 ;
  TID_t *Device ;
  unsigned short NumberOfDevices ;
  unsigned char Index ;
  unsigned char Bus ;
  unsigned char Id ;
  unsigned char Target ;
  time_t tmp___3 ;
  TID_t *Device___0 ;
  unsigned short NumberOfDevices___0 ;
  unsigned char Target___0 ;
  unsigned char Lun ;
  DPTI_Devices_S **tmp___4 ;
  unsigned char Message[sizeof(struct PrivateScbMessage )] ;
  PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *Message_Ptr ;
  unsigned long physAddr ;
  unsigned long physLength ;
  unsigned long value ;
  unsigned char Flags ;
  I2O_MESSAGE_FRAME *tmp___5 ;
  int tmp___6 ;
  DPTI_Devices_S **tmp___7 ;
  int retVal ;
  unsigned char retry ;
  int tmp___8 ;
  unsigned short length ;
  struct __anonstruct_Buffer_69 Buffer ;
  int tmp___9 ;
  unsigned char modeSense[14] ;
  unsigned char length___0 ;
  unsigned char Message___0[sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE )] ;
  PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *Message_Ptr___0 ;
  eataCP_S eata ;
  unsigned long value___0 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  I2O_MESSAGE_FRAME *tmp___12 ;
  unsigned short size ;
  int tmp___13 ;
  DPTI_Devices_S **tmp___14 ;
  int tmp___15 ;
  unsigned char *cp ;
  unsigned long unPacked___0 ;
  unsigned char tmp___16 ;
  unsigned long unPacked___1 ;
  unsigned long Offset ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned long unPacked___2 ;
  int tmp___21 ;
  unsigned long tmp___22 ;
  unsigned short residual ;
  unsigned char *Address ;
  unsigned long newFlashOffset ;
  unsigned char newFlashSegments ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned long unPacked___3 ;
  unsigned short count ;
  unsigned short miniOffset ;
  unsigned short residual___0 ;
  unsigned char *Address___0 ;
  unsigned long unPacked___4 ;
  unsigned short count___0 ;
  unsigned short miniOffset___0 ;
  unsigned long tmp___31 ;
  unsigned long unPacked___5 ;
  int tmp___32 ;
  dptFlashStatus_S status ;
  unsigned short fwType ;
  unsigned long sizeRegion[4] ;
  unsigned long size___0 ;
  unsigned long tmp___33 ;
  unsigned long unPacked___6 ;
  unsigned long unPacked___7 ;
  eataSP_S Status___0 ;
  eataSP_S *statusPointer___0 ;
  long length___1 ;
  unsigned long unPacked___8 ;

  {
  {
#line 3270
  Length = 0UL;
#line 3272
  tmp = _DPTI_current(controller);
#line 3272
  current = *tmp;
  }
#line 3283
  if ((int )*((unsigned char *)eata_P + 0) & 1) {
    {
#line 3284
    DPTI_resetBus(controller);
#line 3292
    statusPointer = & Status;
    }
#line 3293
    if (*((unsigned long *)((unsigned char *)eata_P + 36)) != 0UL) {
#line 3294
      unPacked = *((unsigned long *)((unsigned char *)eata_P + 36));
#line 3295
      unPacked = unPacked;
#line 3296
      statusPointer = (eataSP_S *)((void *)unPacked);
    }
    {
#line 3298
    memset((void *)statusPointer, 0, sizeof(Status));
#line 3299
    *((unsigned long *)((unsigned char *)statusPointer + 8)) = *((unsigned long *)((unsigned char *)eata_P + 28));
#line 3300
    *((unsigned char *)statusPointer + 0) = (unsigned char)128;
    }
#line 3301
    if ((unsigned long )callback != (unsigned long )((void (*)(Controller_t controller ,
                                                               Status_t status , Sense_t sense ))((void *)0))) {
      {
#line 3302
      (*callback)(controller, (Status_t )statusPointer, (Sense_t )((void *)0));
      }
    }
#line 3307
    return (1);
  }
#line 3309
  if (current->changed) {
#line 3312
    tmp___0 = (unsigned char)0;
#line 3312
    current->valid = tmp___0;
#line 3312
    current->changed = tmp___0;
  }
#line 3315
  opCode___0 = *(((unsigned char *)eata_P + 12) + 0);
#line 3315
  if ((int )opCode___0 == 18) {
#line 3317
    pageCode = *((unsigned char *)((scInquiry_S *)((unsigned char *)eata_P + 12)) + 2);
#line 3319
    if ((int )pageCode == 0) {
#line 3319
      if (((int )*((unsigned char *)eata_P + 0) & 32) == 0) {
#line 3319
        if (((int )*(((unsigned char *)eata_P + 12) + 1) & 1) == 0) {
#line 3319
          tmp___1 = 1;
        } else {
#line 3319
          tmp___1 = 0;
        }
      } else {
#line 3319
        tmp___1 = 0;
      }
    } else {
#line 3319
      tmp___1 = 0;
    }
#line 3319
    PhysicalDeviceBaseInquiry = (unsigned char )tmp___1;
#line 3322
    OriginalLun = (unsigned char)255;
#line 3324
    if (((int )*((unsigned char *)eata_P + 7) & 31) == (int )current->adapterID[(int )*((unsigned char *)eata_P + 7) >> 5]) {
#line 3326
      PhysicalDeviceBaseInquiry = (unsigned char)0;
    }
#line 3341
    if (PhysicalDeviceBaseInquiry) {
#line 3348
      if ((int )current->controller != (int )controller) {
#line 3348
        current->valid = (unsigned char)0;
#line 3348
        current->controller = controller;
      }
#line 3349
      if ((int )current->valid == 0) {
        {
#line 3350
        current = DPTI_preloadTable(controller);
        }
      }
#line 3353
      if (current->lastScan) {
        {
#line 3353
        tmp___2 = time((time_t *)((void *)0));
        }
#line 3353
        if (current->lastScan < (unsigned long )tmp___2) {
#line 3359
          current->enableRescan = (unsigned char)1;
        }
      }
      {
#line 3366
      memset((void *)(Found), 0, sizeof(Found));
#line 3370
      Device = current->devices.tid.data;
#line 3370
      NumberOfDevices = current->numDevices;
      }
      {
#line 3370
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3370
        if (! ((int )NumberOfDevices != 0)) {
#line 3370
          goto while_break;
        }
#line 3373
        if ((int )Device->Adapter == 0) {
#line 3374
          Found[(int )Device->Bus & 7][((int )Device->Target & 120) >> 3] = (unsigned char )((int )Found[(int )Device->Bus & 7][((int )Device->Target & 120) >> 3] | (1 << ((int )Device->Target & 7)));
        }
#line 3370
        Device ++;
#line 3370
        NumberOfDevices = (unsigned short )((int )NumberOfDevices - 1);
      }
      while_break: /* CIL Label */ ;
      }
#line 3383
      Index = (unsigned char)8;
      {
#line 3390
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3391
        Index = (unsigned char )((int )Index - 1);
#line 3392
        Found[Index][((int )current->adapterID[Index] & 120) >> 3] = (unsigned char )((int )Found[Index][((int )current->adapterID[Index] & 120) >> 3] | (1 << ((int )current->adapterID[Index] & 7)));
#line 3390
        if (! Index) {
#line 3390
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3399
      Target = (unsigned char )*((char *)eata_P + 2);
#line 3402
      if (((int )Target & 31) != ((int )*((unsigned char *)eata_P + 7) & 31)) {
#line 3403
        Target = (unsigned char )((int )*((unsigned char *)eata_P + 7) & 31);
      }
#line 3405
      Bus = (unsigned char)0;
      {
#line 3405
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3405
        if (! ((unsigned long )Bus < sizeof(Found) / sizeof(Found[0]))) {
#line 3405
          goto while_break___1;
        }
#line 3406
        Id = (unsigned char)0;
        {
#line 3406
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3406
          if (! ((unsigned long )Id < sizeof(Found[0]) / sizeof(Found[0][0]) << 3)) {
#line 3406
            goto while_break___2;
          }
#line 3410
          if (((int )Found[Bus][(int )Id >> 3] & (1 << ((int )Id & 7))) == 0) {
#line 3411
            goto while_break___2;
          }
#line 3406
          Id = (unsigned char )((int )Id + 1);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3414
        if ((unsigned long )Id < sizeof(Found[0]) / sizeof(Found[0][0]) << 3) {
#line 3415
          goto while_break___1;
        }
#line 3405
        Bus = (unsigned char )((int )Bus + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3418
      if ((int )Bus == (int )((unsigned char )((int )*((unsigned char *)eata_P + 7) >> 5))) {
#line 3418
        if ((int )Id == (int )Target) {
          {
#line 3421
          tmp___3 = time((time_t *)((void *)0));
#line 3421
          current->lastScan = (unsigned long )tmp___3 + 10UL;
          }
#line 3422
          if (current->enableRescan) {
            {
#line 3424
            DPTI_rescan(controller);
            }
          }
        }
      }
    }
#line 3437
    if (PhysicalDeviceBaseInquiry) {
#line 3440
      Target___0 = (unsigned char )*((char *)eata_P + 2);
#line 3441
      Lun = (unsigned char )*((char *)eata_P + 3);
#line 3444
      if (((int )Target___0 & 31) != ((int )*((unsigned char *)eata_P + 7) & 31)) {
#line 3445
        Target___0 = (unsigned char )((int )*((unsigned char *)eata_P + 7) & 31);
      }
#line 3448
      if (((int )Lun & 7) != ((int )*((unsigned char *)eata_P + 8) & 7)) {
#line 3449
        Lun = (unsigned char )((int )*((unsigned char *)eata_P + 8) & 7);
      }
      {
#line 3451
      tmp___4 = _DPTI_current(controller);
#line 3451
      current = *tmp___4;
#line 3452
      Device___0 = current->devices.tid.data;
#line 3452
      NumberOfDevices___0 = current->numDevices;
      }
      {
#line 3452
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3452
        if (! ((int )NumberOfDevices___0 != 0)) {
#line 3452
          goto while_break___3;
        }
#line 3455
        if ((int )Device___0->Adapter == 0) {
#line 3455
          if ((int )Device___0->Bus == (int )*((unsigned char *)eata_P + 7) >> 5) {
#line 3455
            if ((int )Device___0->Target == (int )Target___0) {
#line 3458
              if ((int )Device___0->Lun == (int )Lun) {
#line 3459
                OriginalLun = (unsigned char)255;
#line 3460
                goto while_break___3;
              }
#line 3462
              OriginalLun = (unsigned char )Device___0->Lun;
            }
          }
        }
#line 3452
        Device___0 ++;
#line 3452
        NumberOfDevices___0 = (unsigned short )((int )NumberOfDevices___0 - 1);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3465
      if ((int )OriginalLun != 255) {
#line 3466
        *((unsigned char *)eata_P + 8) = (unsigned char )((int )*((unsigned char *)eata_P + 8) & 248);
#line 3466
        *((unsigned char *)eata_P + 8) = (unsigned char )((int )*((unsigned char *)eata_P + 8) | (int )((unsigned char )((int )OriginalLun & 7)));
#line 3467
        *((char *)eata_P + 3) = (char )OriginalLun;
#line 3468
        *(((unsigned char *)eata_P + 12) + 1) = (unsigned char )((int )*(((unsigned char *)eata_P + 12) + 1) & 31);
#line 3469
        *(((unsigned char *)eata_P + 12) + 1) = (unsigned char )((int )*(((unsigned char *)eata_P + 12) + 1) | (int )((unsigned char )((int )OriginalLun << 5)));
#line 3470
        OriginalLun = Lun;
      }
    }
#line 3477
    if ((int )PhysicalDeviceBaseInquiry != 0) {
#line 3477
      goto _L___0;
    } else
#line 3477
    if (((int )*((unsigned char *)eata_P + 0) & 32) != 0) {
      _L___0: /* CIL Label */ 
      {
#line 3495
      tmp___5 = DPTI_fillMessage(Message, (unsigned short )sizeof(struct PrivateScbMessage ));
#line 3495
      Message_Ptr = (PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *)tmp___5;
#line 3501
      physAddr = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 3502
      physLength = *((unsigned long *)((unsigned char *)eata_P + 24));
#line 3503
      Flags = *((unsigned char *)eata_P + 0);
#line 3507
      *(((unsigned char *)eata_P + 12) + 2) = (unsigned char)0;
#line 3508
      *(((unsigned char *)eata_P + 12) + 1) = (unsigned char )((int )*(((unsigned char *)eata_P + 12) + 1) & 254);
#line 3509
      value = (unsigned long )(buffer);
#line 3510
      value = value;
#line 3511
      *((unsigned long *)((unsigned char *)eata_P + 32)) = value;
#line 3512
      value = sizeof(buffer);
#line 3513
      *((unsigned long *)((unsigned char *)eata_P + 24)) = value;
#line 3514
      *(((unsigned char *)eata_P + 12) + 4) = (unsigned char )sizeof(buffer);
#line 3516
      *((unsigned char *)eata_P + 0) = (unsigned char )((int )*((unsigned char *)eata_P + 0) & 247);
#line 3520
      tmp___6 = DPTI_eataToI2O(controller, eata_P, Message_Ptr);
#line 3520
      Length = (unsigned long )(tmp___6 == 0);
#line 3526
      tmp___7 = _DPTI_current(controller);
#line 3526
      current = *tmp___7;
      }
#line 3527
      if (Length) {
#line 3534
        if (*((unsigned char *)eata_P + 6)) {
#line 3534
          tmp___8 = 5;
        } else {
#line 3534
          tmp___8 = 1;
        }
#line 3534
        retry = (unsigned char )tmp___8;
        {
#line 3538
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 3538
          retVal = DPTI_sendMessage(controller, Message_Ptr);
          }
#line 3538
          if (retVal != 0) {
#line 3538
            if (retVal != 2560) {
#line 3538
              retry = (unsigned char )((int )retry - 1);
#line 3538
              if (! ((int )retry > 0)) {
#line 3538
                goto while_break___4;
              }
            } else {
#line 3538
              goto while_break___4;
            }
          } else {
#line 3538
            goto while_break___4;
          }
#line 3543
          goto while_continue___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3545
        Length = (unsigned long )(retVal == 0);
#line 3546
        if (Length) {
#line 3546
          if (((int )*((unsigned char *)eata_P + 0) & 32) != 0) {
#line 3548
            length = (unsigned short )((int )*(buffer + 4) + 5);
#line 3550
            if ((unsigned long )length > sizeof(buffer)) {
#line 3551
              length = (unsigned short )sizeof(buffer);
            }
#line 3553
            if ((unsigned long )length > sizeof(DPTI_SpoofedInquiry)) {
#line 3554
              length = (unsigned short )sizeof(DPTI_SpoofedInquiry);
            }
            {
#line 3556
            current->raidNum = *(buffer + 6);
#line 3557
            *(buffer + 6) = (unsigned char)0;
#line 3558
            memcpy((void */* __restrict  */)((void *)(DPTI_SpoofedInquiry)), (void const   */* __restrict  */)((void *)(buffer)),
                   (size_t )length);
            }
          }
        }
      }
#line 3566
      *((unsigned long *)((unsigned char *)eata_P + 32)) = physAddr;
#line 3567
      *((unsigned long *)((unsigned char *)eata_P + 24)) = physLength;
#line 3568
      *((unsigned char *)eata_P + 0) = Flags;
#line 3569
      physLength = physLength;
#line 3573
      if (physLength > 255UL) {
#line 3574
        physLength = 255UL;
      }
#line 3576
      *(((unsigned char *)eata_P + 12) + 4) = (unsigned char )physLength;
#line 3578
      *(((unsigned char *)eata_P + 12) + 2) = pageCode;
#line 3579
      if (pageCode) {
#line 3580
        *(((unsigned char *)eata_P + 12) + 1) = (unsigned char )((int )*(((unsigned char *)eata_P + 12) + 1) | 1);
      }
#line 3584
      if ((int )OriginalLun != 255) {
#line 3585
        *((unsigned char *)eata_P + 8) = (unsigned char )((int )*((unsigned char *)eata_P + 8) & 248);
#line 3585
        *((unsigned char *)eata_P + 8) = (unsigned char )((int )*((unsigned char *)eata_P + 8) | (int )((unsigned char )((int )OriginalLun & 7)));
#line 3586
        *((char *)eata_P + 3) = (char )OriginalLun;
#line 3587
        *(((unsigned char *)eata_P + 12) + 1) = (unsigned char )((int )*(((unsigned char *)eata_P + 12) + 1) & 31);
#line 3588
        *(((unsigned char *)eata_P + 12) + 1) = (unsigned char )((int )*(((unsigned char *)eata_P + 12) + 1) | (int )((unsigned char )((int )OriginalLun << 5)));
#line 3589
        *(buffer + 0) = (unsigned char )(31 | ((224 >> 1) & 224));
      }
      {
#line 3597
      if ((int )pageCode == 0) {
#line 3597
        goto case_0;
      }
#line 3812
      if ((int )pageCode == 193) {
#line 3812
        goto case_193;
      }
#line 3596
      goto switch_break;
      case_0: /* CIL Label */ 
#line 3598
      if (((int )*((unsigned char *)eata_P + 0) & 32) != 0) {
        {
#line 3609
        tmp___9 = DPTI_getParams(controller, (unsigned short)0, 61697, & Buffer.Header,
                                 (unsigned int )sizeof(Buffer));
        }
#line 3609
        if (tmp___9) {
#line 3615
          *((unsigned short *)(Buffer.Info.ModuleName + 0)) = (unsigned short )(68 + (80 << 8));
#line 3617
          *((unsigned long *)(Buffer.Info.ModuleName + 2)) = (unsigned long )(84 + (32 << 8)) + ((unsigned long )(80 + (77 << 8)) << 16L);
#line 3619
          *((unsigned long *)(Buffer.Info.ModuleName + 6)) = (unsigned long )(63 + (63 << 8)) + ((unsigned long )(63 + (52 << 8)) << 16L);
#line 3621
          *((unsigned long *)(Buffer.Info.ModuleName + 10)) = (unsigned long )(85 + (87 << 8));
#line 3623
          *((unsigned short *)(Buffer.Info.ModuleRevLevel + 0)) = (unsigned short )(63 + (63 << 8));
#line 3625
          *((unsigned long *)(Buffer.Info.ModuleRevLevel + 2)) = (unsigned long )(63 + (63 << 8));
        }
#line 3628
        if (Length == 0UL) {
          {
#line 3629
          memcpy((void */* __restrict  */)(buffer + 16), (void const   */* __restrict  */)(Buffer.Info.ModuleName + 4),
                 (size_t )8);
#line 3631
          memcpy((void */* __restrict  */)(buffer + 8), (void const   */* __restrict  */)(Buffer.Info.ModuleName),
                 (size_t )4);
#line 3633
          memcpy((void */* __restrict  */)(buffer + 32), (void const   */* __restrict  */)(Buffer.Info.ModuleRevLevel),
                 (size_t )4);
          }
        }
#line 3642
        if ((int )*((buffer + 32) + 0) == 48) {
#line 3642
          if ((int )*((buffer + 32) + 1) < 55) {
#line 3646
            *((buffer + 32) + 0) = (unsigned char )'O';
          } else
#line 3642
          if ((int )*((buffer + 32) + 1) == 55) {
#line 3642
            if ((int )*((buffer + 32) + 2) < 67) {
#line 3646
              *((buffer + 32) + 0) = (unsigned char )'O';
            }
          }
        }
#line 3651
        Length = (unsigned long )((unsigned int )*((unsigned long *)((unsigned char *)eata_P + 24)));
#line 3651
        if (Length > 56UL) {
#line 3653
          Length = 56UL;
        }
      } else
#line 3655
      if (Length != 0UL) {
#line 3660
        Length = 0UL;
#line 3664
        length___0 = *(buffer + 4);
#line 3665
        if ((int )length___0 >= 40) {
#line 3665
          goto _L;
        } else
#line 3665
        if ((int )length___0 < 5) {
          _L: /* CIL Label */ 
#line 3665
          if ((int )length___0 <= 90) {
#line 3667
            length___0 = (unsigned char)91;
          } else
#line 3665
          if ((unsigned long )length___0 >= sizeof(buffer) - 5UL) {
#line 3667
            length___0 = (unsigned char)91;
          }
        }
#line 3669
        if (((unsigned long )length___0 + 5UL) + 12UL <= *((unsigned long *)((unsigned char *)eata_P + 24))) {
#line 3669
          if ((unsigned int )length___0 < (unsigned int )((sizeof(buffer) - 5UL) - 12UL)) {
#line 3669
            if (*((unsigned char *)eata_P + 6)) {
              {
#line 3687
              memcpy((void */* __restrict  */)((void *)(& eata)), (void const   */* __restrict  */)((void *)eata_P),
                     (size_t )44);
#line 3692
              tmp___11 = 0UL;
#line 3692
              *((unsigned long *)((unsigned char *)(& eata) + 12) + 0) = tmp___11;
#line 3692
              tmp___10 = tmp___11;
#line 3692
              *((unsigned long *)((unsigned char *)(& eata) + 12) + 1) = tmp___10;
#line 3692
              *((unsigned long *)((unsigned char *)(& eata) + 12) + 2) = tmp___10;
#line 3699
              tmp___12 = DPTI_fillMessage(Message___0, (unsigned short )sizeof(PRIVATE_SCSI_SCB_EXECUTE_MESSAGE ));
#line 3699
              Message_Ptr___0 = (PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *)tmp___12;
#line 3705
              value___0 = (unsigned long )((void *)(modeSense));
#line 3707
              value___0 = value___0;
#line 3708
              *((unsigned long *)((unsigned char *)(& eata) + 32)) = value___0;
#line 3711
              value___0 = sizeof(modeSense);
#line 3711
              size = (unsigned short )value___0;
#line 3719
              *((uSHORT *)(((unsigned char *)(& eata) + 12) + 7)) = (uSHORT )((int )((unsigned short )*((unsigned char *)(& size) + 1)) + ((int )((unsigned short )*((unsigned char *)(& size) + 0)) << 8));
#line 3723
              *((unsigned long *)((unsigned char *)(& eata) + 24)) = value___0;
#line 3724
              *(((unsigned char *)(& eata) + 12) + 0) = (unsigned char)90;
#line 3726
              *(((unsigned char *)(& eata) + 12) + 1) = (unsigned char )((((int )*((unsigned char *)(& eata) + 8) & 7) << 5) | 8);
#line 3728
              *(((unsigned char *)(& eata) + 12) + 2) = (unsigned char)50;
#line 3729
              *((unsigned char *)(& eata) + 0) = (unsigned char)160;
#line 3733
              tmp___13 = DPTI_eataToI2O(controller, & eata, Message_Ptr___0);
#line 3733
              Length = (unsigned long )(tmp___13 == 0);
#line 3736
              tmp___14 = _DPTI_current(controller);
#line 3736
              current = *tmp___14;
              }
#line 3737
              if (Length) {
                {
#line 3738
                tmp___15 = DPTI_sendMessage(controller, Message_Ptr___0);
#line 3738
                Length = (unsigned long )(tmp___15 == 0);
                }
              }
            }
          }
        }
#line 3746
        if (Length != 0UL) {
#line 3749
          cp = (buffer + 5) + (int )length___0;
#line 3750
          *(buffer + 4) = (unsigned char )((int )length___0 + 12);
#line 3772
          *((unsigned long *)cp) = (unsigned long )(68 + (80 << 8)) + ((unsigned long )(84 + (77 << 8)) << 16L);
#line 3774
          cp += sizeof(unsigned long );
#line 3775
          *((unsigned long *)cp) = (unsigned long )(65 + (71 << 8)) + ((unsigned long )(73 + (67 << 8)) << 16L);
#line 3777
          cp += sizeof(unsigned long );
#line 3778
          *((unsigned long *)cp) = *((unsigned long *)(& modeSense[sizeof(modeSense) - sizeof(long )]));
        }
#line 3782
        Length = (unsigned long )((unsigned int )*((unsigned long *)((unsigned char *)eata_P + 24)));
#line 3782
        if (Length > sizeof(buffer)) {
#line 3784
          Length = sizeof(buffer);
        }
      } else {
#line 3793
        goto switch_break;
      }
#line 3795
      if (Length < (unsigned long )((int )*(buffer + 4) + 5)) {
#line 3796
        *(buffer + 4) = (unsigned char )(Length - 5UL);
      }
      {
#line 3800
      unPacked___0 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 3801
      unPacked___0 = unPacked___0;
#line 3804
      memcpy((void */* __restrict  */)((void *)unPacked___0), (void const   */* __restrict  */)((void *)(buffer)),
             (size_t )((unsigned short )Length));
      }
#line 3811
      goto switch_break;
      case_193: /* CIL Label */ 
      {
#line 3817
      memset((void *)(buffer), 0, (size_t )38);
#line 3818
      memcpy((void */* __restrict  */)((void *)(buffer)), (void const   */* __restrict  */)(DPTI_SpoofedRdConfig),
             sizeof(DPTI_SpoofedRdConfig));
#line 3820
      *(buffer + 33) = (unsigned char )((int )*(buffer + 33) | (int )((unsigned char )((int )current->maxBus << 5)));
#line 3821
      *(buffer + 34) = current->maxLun;
#line 3822
      *((buffer + 12) + 3) = current->adapterID[0];
      }
#line 3823
      if ((int )current->maxBus > 0) {
#line 3824
        *((buffer + 12) + 2) = current->adapterID[1];
      }
#line 3826
      if ((int )current->maxBus > 1) {
#line 3827
        *((buffer + 12) + 1) = current->adapterID[2];
      }
#line 3829
      if ((int )current->maxBus > 2) {
#line 3830
        *((buffer + 12) + 0) = current->adapterID[3];
      }
      {
#line 3832
      *(buffer + 36) = current->raidNum;
#line 3833
      tmp___16 = DPTI_getIrqNum(current->controller);
#line 3833
      *(buffer + 31) = tmp___16;
#line 3834
      *(buffer + 30) = (unsigned char )((int )*(buffer + 30) & 240);
#line 3835
      *(buffer + 30) = (unsigned char )((int )*(buffer + 30) | (int )((unsigned char )((int )*(buffer + 31) & 15)));
#line 3839
      Length = (unsigned long )((unsigned int )*((unsigned long *)((unsigned char *)eata_P + 24)));
      }
#line 3839
      if (Length > 38UL) {
#line 3841
        Length = 38UL;
      }
#line 3843
      if (Length < 38UL) {
#line 3844
        *((unsigned char *)(& buffer) + 4) = (unsigned char )(Length - 5UL);
      }
      {
#line 3848
      unPacked___1 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 3849
      unPacked___1 = unPacked___1;
#line 3851
      memcpy((void */* __restrict  */)((void *)unPacked___1), (void const   */* __restrict  */)((void *)(buffer)),
             (size_t )((unsigned short )Length));
      }
#line 3858
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else
#line 3861
  if ((int )*((unsigned char *)eata_P + 0) & 32) {
    {
#line 3863
    if ((int )opCode___0 == 193) {
#line 3863
      goto case_193___0;
    }
#line 4257
    if ((int )opCode___0 == 0) {
#line 4257
      goto case_0___1;
    }
#line 4261
    if ((int )opCode___0 == 59) {
#line 4261
      goto case_59;
    }
#line 4261
    if ((int )opCode___0 == 60) {
#line 4261
      goto case_59;
    }
#line 4276
    if ((int )opCode___0 == 21) {
#line 4276
      goto case_21;
    }
#line 4276
    if ((int )opCode___0 == 85) {
#line 4276
      goto case_21;
    }
#line 4349
    if ((int )opCode___0 == 14) {
#line 4349
      goto case_14;
    }
#line 4349
    if ((int )opCode___0 == 77) {
#line 4349
      goto case_14;
    }
#line 4349
    if ((int )opCode___0 == 26) {
#line 4349
      goto case_14;
    }
#line 4349
    if ((int )opCode___0 == 90) {
#line 4349
      goto case_14;
    }
#line 4351
    goto switch_default;
    case_193___0: /* CIL Label */ 
#line 3870
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action != 4) {
#line 3876
      current->enableRescan = (unsigned char)1;
    }
#line 3896
    Offset = ((unsigned long )((int )((unsigned short )*(((unsigned char *)(& ((scFlash_S *)((unsigned char *)eata_P + 12))->address) + 2) + 1)) + ((int )((unsigned short )*(((unsigned char *)(& ((scFlash_S *)((unsigned char *)eata_P + 12))->address) + 2) + 0)) << 8)) + ((unsigned long )*((unsigned char *)(& ((scFlash_S *)((unsigned char *)eata_P + 12))->address) + 1) << 16)) + ((unsigned long )*((unsigned char *)(& ((scFlash_S *)((unsigned char *)eata_P + 12))->address) + 0) << 24);
#line 3897
    Length = *((unsigned long *)((unsigned char *)eata_P + 24));
    {
#line 3900
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 3) {
#line 3900
      goto case_3;
    }
#line 3900
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 0) {
#line 3900
      goto case_3;
    }
#line 3905
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 7) {
#line 3905
      goto case_7;
    }
#line 3905
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 6) {
#line 3905
      goto case_7;
    }
#line 3907
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 5) {
#line 3907
      goto case_5;
    }
#line 3948
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 2) {
#line 3948
      goto case_2;
    }
#line 4117
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 1) {
#line 4117
      goto case_1;
    }
#line 4187
    if ((int )((scFlash_S *)((unsigned char *)eata_P + 12))->action == 4) {
#line 4187
      goto case_4;
    }
#line 3898
    goto switch_break___1;
    case_3: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 3901
    current->flashMode = (unsigned char)1;
#line 3902
    Length = 1UL;
#line 3903
    goto switch_break___1;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 3906
    current->flashMode = (unsigned char)0;
    case_5: /* CIL Label */ 
#line 3908
    Length = 1UL;
#line 3910
    if ((unsigned long )flashBuffers[0] == (unsigned long )((unsigned char *)((void *)0))) {
#line 3911
      goto switch_break___1;
    }
#line 3914
    if ((int )flashSegments > 3) {
#line 3914
      tmp___17 = 16384;
    } else {
#line 3914
      tmp___17 = 0;
    }
#line 3914
    if ((int )flashSegments > 2) {
#line 3914
      tmp___18 = 16384;
    } else {
#line 3914
      tmp___18 = 0;
    }
#line 3914
    if ((int )flashSegments > 1) {
#line 3914
      tmp___19 = 16384;
    } else {
#line 3914
      tmp___19 = 0;
    }
    {
#line 3914
    tmp___20 = DPTI_FlashCommand(controller, (unsigned short)258, flashOffset, (unsigned long )flashBuffers[0],
                                 16384UL, (unsigned long )flashBuffers[1], (unsigned short )tmp___19,
                                 (unsigned long )flashBuffers[2], (unsigned short )tmp___18,
                                 (unsigned long )flashBuffers[3], (unsigned short )tmp___17);
    }
#line 3914
    if (tmp___20 != 0) {
#line 3930
      Length = 0xffffffffffffffffUL;
    }
    {
#line 3937
    free((void *)flashBuffers[3]);
#line 3938
    flashBuffers[3] = (unsigned char *)((void *)0);
#line 3939
    free((void *)flashBuffers[2]);
#line 3940
    flashBuffers[2] = (unsigned char *)((void *)0);
#line 3941
    free((void *)flashBuffers[1]);
#line 3942
    flashBuffers[1] = (unsigned char *)((void *)0);
#line 3943
    free((void *)flashBuffers[0]);
#line 3944
    flashBuffers[0] = (unsigned char *)((void *)0);
    }
#line 3947
    goto switch_break___1;
    case_2: /* CIL Label */ 
    {
#line 3956
    tmp___22 = DPTI_getFlashOffset(controller, Offset, (unsigned char *)((void *)0));
    }
#line 3956
    if (((int )((unsigned short )tmp___22) & 65535) == 0) {
#line 3956
      goto _L___1;
    } else
#line 3956
    if (Offset == 0UL) {
      _L___1: /* CIL Label */ 
#line 3956
      if (Length >= 65536UL) {
        {
#line 3962
        unPacked___2 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 3963
        unPacked___2 = unPacked___2;
#line 3965
        tmp___21 = DPTI_FlashCommand(controller, (unsigned short)258, Offset, unPacked___2,
                                     Length, 0UL, (unsigned short)0, 0UL, (unsigned short)0,
                                     0UL, (unsigned short)0);
        }
#line 3965
        if (tmp___21 != 0) {
#line 3969
          Length = 0xffffffffffffffffUL;
        }
#line 3971
        goto switch_break___1;
      }
    }
    {
#line 3987
    newFlashOffset = DPTI_getFlashOffset(controller, Offset, & newFlashSegments);
    }
#line 3989
    if ((unsigned long )flashBuffers[0] == (unsigned long )((unsigned char *)((void *)0))) {
      {
#line 3990
      flashOffset = newFlashOffset;
#line 3991
      flashSegments = newFlashSegments;
#line 4005
      tmp___23 = malloc((size_t )16384);
#line 4005
      flashBuffers[0] = (unsigned char *)tmp___23;
      }
#line 4005
      if ((unsigned long )flashBuffers[0] == (unsigned long )((unsigned char *)((void *)0))) {
#line 4005
        goto _L___2;
      } else {
        {
#line 4005
        tmp___24 = malloc((size_t )16384);
#line 4005
        flashBuffers[1] = (unsigned char *)tmp___24;
        }
#line 4005
        if ((unsigned long )flashBuffers[1] == (unsigned long )((unsigned char *)((void *)0))) {
#line 4005
          goto _L___2;
        } else {
          {
#line 4005
          tmp___25 = malloc((size_t )16384);
#line 4005
          flashBuffers[2] = (unsigned char *)tmp___25;
          }
#line 4005
          if ((unsigned long )flashBuffers[2] == (unsigned long )((unsigned char *)((void *)0))) {
#line 4005
            goto _L___2;
          } else {
            {
#line 4005
            tmp___26 = malloc((size_t )16384);
#line 4005
            flashBuffers[3] = (unsigned char *)tmp___26;
            }
#line 4005
            if ((unsigned long )flashBuffers[3] == (unsigned long )((unsigned char *)((void *)0))) {
              _L___2: /* CIL Label */ 
#line 4017
              if (flashBuffers[2]) {
                {
#line 4018
                free((void *)flashBuffers[2]);
#line 4019
                flashBuffers[2] = (unsigned char *)((void *)0);
                }
              }
#line 4022
              if (flashBuffers[1]) {
                {
#line 4023
                free((void *)flashBuffers[1]);
#line 4024
                flashBuffers[1] = (unsigned char *)((void *)0);
                }
              }
#line 4027
              if (flashBuffers[0]) {
                {
#line 4028
                free((void *)flashBuffers[0]);
#line 4029
                flashBuffers[0] = (unsigned char *)((void *)0);
                }
              }
#line 4032
              Length = 0xffffffffffffffffUL;
#line 4033
              goto switch_break___1;
            }
          }
        }
      }
      {
#line 4037
      DPTI_FlashCommand(controller, (unsigned short)257, flashOffset, (unsigned long )flashBuffers[0],
                        16384UL, (unsigned long )flashBuffers[1], (unsigned short)16384,
                        (unsigned long )flashBuffers[2], (unsigned short)16384, (unsigned long )flashBuffers[3],
                        (unsigned short)16384);
      }
    }
#line 4048
    if (flashOffset != newFlashOffset) {
#line 4050
      if ((int )flashSegments > 3) {
#line 4050
        tmp___27 = 16384;
      } else {
#line 4050
        tmp___27 = 0;
      }
#line 4050
      if ((int )flashSegments > 2) {
#line 4050
        tmp___28 = 16384;
      } else {
#line 4050
        tmp___28 = 0;
      }
#line 4050
      if ((int )flashSegments > 1) {
#line 4050
        tmp___29 = 16384;
      } else {
#line 4050
        tmp___29 = 0;
      }
      {
#line 4050
      tmp___30 = DPTI_FlashCommand(controller, (unsigned short)258, flashOffset, (unsigned long )flashBuffers[0],
                                   16384UL, (unsigned long )flashBuffers[1], (unsigned short )tmp___29,
                                   (unsigned long )flashBuffers[2], (unsigned short )tmp___28,
                                   (unsigned long )flashBuffers[3], (unsigned short )tmp___27);
      }
#line 4050
      if (tmp___30 != 0) {
#line 4066
        Length = 0xffffffffffffffffUL;
#line 4067
        goto switch_break___1;
      }
      {
#line 4070
      flashOffset = newFlashOffset;
#line 4071
      flashSegments = newFlashSegments;
#line 4072
      DPTI_FlashCommand(controller, (unsigned short)257, flashOffset, (unsigned long )flashBuffers[0],
                        16384UL, (unsigned long )flashBuffers[1], (unsigned short)16384,
                        (unsigned long )flashBuffers[2], (unsigned short)16384, (unsigned long )flashBuffers[3],
                        (unsigned short)16384);
      }
    }
#line 4082
    residual = (unsigned short )Length;
#line 4085
    unPacked___3 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 4086
    unPacked___3 = unPacked___3;
#line 4087
    Address = (unsigned char *)((void *)unPacked___3);
    {
#line 4094
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4094
      if (! residual) {
#line 4094
        goto while_break___5;
      }
#line 4095
      count = residual;
#line 4096
      miniOffset = (unsigned short )((int )((unsigned short )Offset) - (int )((unsigned short )flashOffset));
#line 4099
      if (16384 - ((int )miniOffset & 16383) < (int )count) {
#line 4100
        count = (unsigned short )(16384 - ((int )miniOffset & 16383));
      }
      {
#line 4103
      memcpy((void */* __restrict  */)((void *)(flashBuffers[(int )miniOffset >> 14] + ((int )miniOffset & 16383))),
             (void const   */* __restrict  */)Address, (size_t )count);
#line 4111
      residual = (unsigned short )((int )residual - (int )count);
#line 4112
      Offset += (unsigned long )count;
#line 4113
      Address += (int )count;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 4115
    goto switch_break___1;
    case_1: /* CIL Label */ 
#line 4123
    if ((unsigned long )flashBuffers[0] != (unsigned long )((unsigned char *)((void *)0))) {
      {
#line 4123
      tmp___31 = DPTI_getFlashOffset(controller, Offset, (unsigned char *)((void *)0));
      }
#line 4123
      if (flashOffset == tmp___31) {
#line 4123
        if ((Offset - flashOffset) + Length <= 65536UL) {
#line 4130
          residual___0 = (unsigned short )Length;
#line 4138
          unPacked___4 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 4139
          unPacked___4 = unPacked___4;
#line 4140
          Address___0 = (unsigned char *)((void *)unPacked___4);
          {
#line 4147
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 4147
            if (! residual___0) {
#line 4147
              goto while_break___6;
            }
#line 4148
            count___0 = residual___0;
#line 4150
            miniOffset___0 = (unsigned short )((int )((unsigned short )Offset) - (int )((unsigned short )flashOffset));
#line 4156
            if (16384 - ((int )miniOffset___0 & 16383) < (int )count___0) {
#line 4157
              count___0 = (unsigned short )(16384 - ((int )miniOffset___0 & 16383));
            }
            {
#line 4160
            memcpy((void */* __restrict  */)Address___0, (void const   */* __restrict  */)((void *)(flashBuffers[(int )miniOffset___0 >> 14] + ((int )miniOffset___0 & 16383))),
                   (size_t )count___0);
#line 4168
            residual___0 = (unsigned short )((int )residual___0 - (int )count___0);
#line 4169
            Offset += (unsigned long )count___0;
#line 4170
            Address___0 += (int )count___0;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 4172
          goto switch_break___1;
        }
      }
    }
    {
#line 4177
    unPacked___5 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 4178
    unPacked___5 = unPacked___5;
#line 4179
    tmp___32 = DPTI_FlashCommand(controller, (unsigned short)257, Offset, unPacked___5,
                                 Length, 0UL, (unsigned short)0, 0UL, (unsigned short)0,
                                 0UL, (unsigned short)0);
    }
#line 4179
    if (tmp___32 != 0) {
#line 4183
      Length = 0xffffffffffffffffUL;
    }
#line 4186
    goto switch_break___1;
    case_4: /* CIL Label */ 
    {
#line 4189
    fwType = (unsigned short)2554;
#line 4215
    DPTI_FlashRegionSizes(controller, sizeRegion);
#line 4216
    tmp___33 = DPTI_BootBlockSize();
#line 4216
    sizeRegion[0] += tmp___33;
#line 4216
    size___0 = sizeRegion[0];
#line 4218
    memset((void *)(& status), 0, sizeof(status));
#line 4219
    status.flags1 = (uCHAR )192;
#line 4222
    status.flags1 = (uCHAR )((int )status.flags1 | (int )current->flashMode);
#line 4228
    status.fwType = (uSHORT )((int )((unsigned short )*((unsigned char *)(& fwType) + 1)) + ((int )((unsigned short )*((unsigned char *)(& fwType) + 0)) << 8));
#line 4229
    size___0 = ((unsigned long )((int )((unsigned short )*(((unsigned char *)(& size___0) + 2) + 1)) + ((int )((unsigned short )*(((unsigned char *)(& size___0) + 2) + 0)) << 8)) + ((unsigned long )*((unsigned char *)(& size___0) + 1) << 16)) + ((unsigned long )*((unsigned char *)(& size___0) + 0) << 24);
#line 4230
    status.burnSize = size___0;
#line 4231
    size___0 = ((sizeRegion[0] + sizeRegion[1]) + sizeRegion[2]) + sizeRegion[3];
#line 4232
    size___0 = ((unsigned long )((int )((unsigned short )*(((unsigned char *)(& size___0) + 2) + 1)) + ((int )((unsigned short )*(((unsigned char *)(& size___0) + 2) + 0)) << 8)) + ((unsigned long )*((unsigned char *)(& size___0) + 1) << 16)) + ((unsigned long )*((unsigned char *)(& size___0) + 0) << 24);
#line 4233
    status.flashSize = size___0;
#line 4234
    fwType = (unsigned short)8;
#line 4235
    fwType = (unsigned short )((int )((unsigned short )*((unsigned char *)(& fwType) + 1)) + ((int )((unsigned short )*((unsigned char *)(& fwType) + 0)) << 8));
#line 4236
    status.programTime = fwType;
#line 4237
    status.eraseTime = fwType;
#line 4238
    Length = *((unsigned long *)((unsigned char *)eata_P + 24));
    }
#line 4239
    if (Length > sizeof(status)) {
#line 4240
      Length = sizeof(status);
    }
    {
#line 4244
    unPacked___6 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 4245
    unPacked___6 = unPacked___6;
#line 4247
    memcpy((void */* __restrict  */)((void *)unPacked___6), (void const   */* __restrict  */)((void *)(& status)),
           (size_t )((unsigned short )Length));
    }
#line 4254
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 4256
    goto switch_break___0;
    case_0___1: /* CIL Label */ 
#line 4258
    Length ++;
#line 4259
    goto switch_break___0;
    case_59: /* CIL Label */ 
    case_60: /* CIL Label */ 
#line 4267
    current->enableRescan = (unsigned char)1;
#line 4274
    goto switch_break___0;
    case_21: /* CIL Label */ 
    case_85: /* CIL Label */ 
#line 4279
    unPacked___7 = *((unsigned long *)((unsigned char *)eata_P + 32));
#line 4280
    unPacked___7 = unPacked___7;
#line 4281
    if (((int )*((unsigned char *)((void *)unPacked___7) + sizeof(modeHeader_S )) & 63) != 46) {
#line 4286
      current->changed = (unsigned char)1;
#line 4287
      current->enableRescan = (unsigned char)0;
    }
#line 4294
    return (-1);
    case_14: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_90: /* CIL Label */ 
#line 4350
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 4359
    current->enableRescan = (unsigned char)1;
#line 4360
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 4362
  if (*((unsigned char *)eata_P + 6)) {
    {
#line 4389
    if ((int )opCode___0 == 40) {
#line 4389
      goto case_40;
    }
#line 4389
    if ((int )opCode___0 == 26) {
#line 4389
      goto case_40;
    }
#line 4389
    if ((int )opCode___0 == 90) {
#line 4389
      goto case_40;
    }
#line 4389
    if ((int )opCode___0 == 3) {
#line 4389
      goto case_40;
    }
#line 4389
    if ((int )opCode___0 == 37) {
#line 4389
      goto case_40;
    }
#line 4389
    if ((int )opCode___0 == 0) {
#line 4389
      goto case_40;
    }
#line 4373
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 4381
    current->enableRescan = (unsigned char)1;
    case_40: /* CIL Label */ 
    case_26___0: /* CIL Label */ 
    case_90___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_0___2: /* CIL Label */ 
#line 4390
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 4406
    if ((int )opCode___0 == 40) {
#line 4406
      goto case_40___0;
    }
#line 4406
    if ((int )opCode___0 == 3) {
#line 4406
      goto case_40___0;
    }
#line 4406
    if ((int )opCode___0 == 37) {
#line 4406
      goto case_40___0;
    }
#line 4406
    if ((int )opCode___0 == 0) {
#line 4406
      goto case_40___0;
    }
#line 4394
    goto switch_default___1;
    switch_default___1: /* CIL Label */ 
#line 4402
    current->enableRescan = (unsigned char)1;
    case_40___0: /* CIL Label */ 
    case_3___1: /* CIL Label */ 
    case_37___0: /* CIL Label */ 
    case_0___3: /* CIL Label */ 
#line 4408
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 4411
  if (Length == 0UL) {
#line 4411
    if ((int )current->valid == 0) {
#line 4411
      if ((int )controller == (int )current->controller) {
        {
#line 4413
        DPTI_preloadTable(controller);
        }
      }
    }
  }
#line 4415
  if (Length == 0UL) {
#line 4420
    return (-1);
  }
#line 4430
  statusPointer___0 = & Status___0;
#line 4431
  if (*((unsigned long *)((unsigned char *)eata_P + 36)) != 0UL) {
#line 4432
    unPacked___8 = *((unsigned long *)((unsigned char *)eata_P + 36));
#line 4433
    unPacked___8 = unPacked___8;
#line 4434
    statusPointer___0 = (eataSP_S *)((void *)unPacked___8);
  }
  {
#line 4436
  memset((void *)statusPointer___0, 0, sizeof(Status___0));
#line 4437
  *((unsigned long *)((unsigned char *)statusPointer___0 + 8)) = *((unsigned long *)((unsigned char *)eata_P + 28));
#line 4438
  *((unsigned char *)statusPointer___0 + 0) = (unsigned char)128;
  }
#line 4439
  if (Length == 0xffffffffffffffffUL) {
#line 4440
    *((unsigned char *)statusPointer___0 + 1) = (unsigned char)2;
#line 4441
    Length = 1UL;
  }
#line 4443
  length___1 = (long )(*((unsigned long *)((unsigned char *)eata_P + 24)) - Length);
#line 4443
  if (length___1 > 0L) {
#line 4444
    *((unsigned long *)((unsigned char *)statusPointer___0 + 4)) = *((unsigned long *)(& length___1));
  }
#line 4446
  if ((unsigned long )callback != (unsigned long )((void (*)(Controller_t controller ,
                                                             Status_t status , Sense_t sense ))((void *)0))) {
    {
#line 4447
    (*callback)(controller, (Status_t )statusPointer___0, (Sense_t )((void *)0));
    }
  }
#line 4452
  return ((int )Length);
}
}
#line 4461 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/eata2i2o.c"
int DPTI_startEataCp(Controller_t controller , eataCP_S *packet , void (*callback)(Controller_t controller ,
                                                                                   Status_t status ,
                                                                                   Sense_t sense ) ) 
{ 
  unsigned char Message[sizeof(struct PrivateScsiScbMessage )] ;
  PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *Message_Ptr ;
  struct convertCallback *placeHolder ;
  int tmp ;
  I2O_MESSAGE_FRAME *tmp___0 ;
  eataSP_S Status ;
  eataSP_S *statusPointer ;
  unsigned long unPacked ;
  int tmp___1 ;
  unsigned long unPacked___0 ;
  unsigned long unPacked___1 ;
  unsigned short volatile   Status___0 ;
  int retval ;
  unsigned long unPacked___2 ;
  int retval___0 ;

  {
  {
#line 4500
  tmp = DPTI_eataToSpoof(controller, packet, callback);
  }
#line 4500
  if (tmp > 0) {
#line 4505
    return (0);
  }
  {
#line 4510
  tmp___0 = DPTI_fillMessage(Message, (unsigned short )sizeof(struct PrivateScsiScbMessage ));
#line 4510
  Message_Ptr = (PRIVATE_SCSI_SCB_EXECUTE_MESSAGE *)tmp___0;
#line 4515
  tmp___1 = DPTI_eataToI2O(controller, packet, Message_Ptr);
  }
#line 4515
  if (tmp___1 != 0) {
#line 4520
    statusPointer = & Status;
#line 4521
    if (*((unsigned long *)((unsigned char *)packet + 36)) != 0UL) {
#line 4530
      unPacked = *((unsigned long *)((unsigned char *)packet + 36));
#line 4531
      unPacked = unPacked;
#line 4532
      statusPointer = (eataSP_S *)((void *)unPacked);
    }
    {
#line 4545
    memset((void *)statusPointer, 0, sizeof(Status));
#line 4546
    *((unsigned long *)((unsigned char *)statusPointer + 8)) = *((unsigned long *)((unsigned char *)packet + 28));
#line 4547
    *((unsigned char *)statusPointer + 0) = (unsigned char)129;
    }
#line 4548
    if ((unsigned long )callback != (unsigned long )((void (*)(Controller_t controller ,
                                                               Status_t status , Sense_t sense ))((void *)0))) {
      {
#line 4558
      (*callback)(controller, (Status_t )statusPointer, (Sense_t )((void *)0));
      }
    }
#line 4567
    return (2560);
  }
#line 4574
  placeHolder = DPTI_convertCallbackList;
#line 4585
  if (placeHolder->VCPaddr != 0UL) {
#line 4589
    return (-1);
  }
#line 4592
  if (*((unsigned long *)((unsigned char *)packet + 28)) == 0UL) {
#line 4593
    *((unsigned long *)((unsigned char *)packet + 28)) = 0xffffffffffffffffUL;
  }
#line 4608
  placeHolder->VCPaddr = *((unsigned long *)((unsigned char *)packet + 28));
#line 4609
  placeHolder->callback = callback;
#line 4610
  placeHolder->status = (eataSP_S *)((void *)0);
#line 4611
  placeHolder->sense = (sdRequestSense_S *)((void *)0);
#line 4612
  placeHolder->senseLength = (unsigned short)0;
#line 4614
  if (*((unsigned long *)((unsigned char *)packet + 36)) != 0UL) {
#line 4617
    unPacked___0 = *((unsigned long *)((unsigned char *)packet + 36));
#line 4618
    unPacked___0 = unPacked___0;
#line 4619
    placeHolder->status = (eataSP_S *)((void *)unPacked___0);
  }
#line 4621
  if ((int )*((unsigned char *)packet + 0) & 4) {
#line 4621
    if ((int )*((unsigned char *)packet + 1) > 0) {
#line 4625
      unPacked___1 = *((unsigned long *)((unsigned char *)packet + 40));
#line 4626
      unPacked___1 = unPacked___1;
#line 4627
      placeHolder->sense = (sdRequestSense_S *)((void *)unPacked___1);
#line 4628
      placeHolder->senseLength = (unsigned short )*((unsigned char *)packet + 1);
    }
  }
#line 4635
  Message_Ptr->PrivateMessageFrame.TransactionContext = (unsigned long )placeHolder;
#line 4640
  if ((unsigned long )callback == (unsigned long )((void (*)(Controller_t controller ,
                                                             Status_t status , Sense_t sense ))((void *)0))) {
    {
#line 4644
    placeHolder->callback = (void (*)(Controller_t controller , Status_t status ,
                                      Sense_t sense ))(& DPTI_eataSynchronousCallback);
#line 4645
    placeHolder->VCPaddr = (unsigned long )((void *)(& Status___0));
#line 4646
    Status___0 = (unsigned short volatile   )(unsigned short)65535;
#line 4651
    retval = _osdStartI2OCp(controller, (OutGoing_t )Message_Ptr, (void (*)(Controller_t controller ,
                                                                            Status_t status ,
                                                                            Sense_t sense ))(& DPTI_convertCallback));
    }
#line 4655
    if (retval >= 0) {
      {
#line 4656
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4656
        if (! ((int volatile   )Status___0 == (int volatile   )(unsigned short)65535)) {
#line 4656
          goto while_break;
        }
#line 4657
        goto while_continue;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 4664
      placeHolder->VCPaddr = 0UL;
    }
#line 4677
    if (*((unsigned long *)((unsigned char *)packet + 36)) != 0UL) {
#line 4680
      unPacked___2 = *((unsigned long *)((unsigned char *)packet + 36));
#line 4681
      unPacked___2 = unPacked___2;
#line 4682
      unPacked___2 = (unsigned long )((void *)unPacked___2);
#line 4683
      *((unsigned long *)((unsigned char *)((eataSP_S *)unPacked___2) + 8)) = *((unsigned long *)((unsigned char *)packet + 28));
#line 4684
      *((unsigned char *)((eataSP_S *)unPacked___2) + 0) = (unsigned char )(128 | (int )((int volatile   )Status___0 >> 8));
#line 4685
      *((unsigned char *)((eataSP_S *)unPacked___2) + 1) = (unsigned char )Status___0;
    }
#line 4687
    Status___0 = (unsigned short volatile   )((int volatile   )Status___0 & (int volatile   )32767);
#line 4690
    return ((int )Status___0);
  }
  {
#line 4701
  retval___0 = _osdStartI2OCp(controller, (OutGoing_t )Message_Ptr, (void (*)(Controller_t controller ,
                                                                              Status_t status ,
                                                                              Sense_t sense ))(& DPTI_convertCallback));
  }
#line 4703
  if (retval___0 < 0) {
#line 4708
    placeHolder->VCPaddr = 0UL;
  }
#line 4721
  return (retval___0);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 606
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 47 "../include/lockunix.h"
int MkLock(char *name ) ;
#line 52
void RmLock(char *name ) ;
#line 57
void ChLock(char *name , int pid ) ;
#line 65
int IsLock(char *name ) ;
#line 42 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char Lock[13]  = 
#line 42 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'%',      (char )'s',      (char )'.', 
        (char )'L',      (char )'O',      (char )'C',      (char )'K', 
        (char )'\000'};
#line 45 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char *getName(char *name ) 
{ 


  {
#line 50
  if (name) {
#line 51
    return (name);
  }
  {
#line 53
  name = strrchr((char const   *)*(Argv + 0), '/');
  }
#line 53
  if ((unsigned long )name != (unsigned long )((char *)((void *)0))) {
#line 54
    return (name);
  }
#line 56
  return (*(Argv + 0));
}
}
#line 70 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char Template[15]  = 
#line 70
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'%',      (char )'s',      (char )'.', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'\000'};
#line 60 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
int MkLock(char *name ) 
{ 
  char buffer[10] ;
  int fd ;
  char *Name ;
  char *tmp ;
  char *templateBuffer ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *lock ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  __pid_t tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;

  {
  {
#line 73
  tmp = getName(name);
#line 73
  Name = tmp;
#line 74
  tmp___0 = strlen((char const   *)Name);
#line 74
  tmp___1 = malloc((tmp___0 + sizeof(Template)) - 1UL);
#line 74
  templateBuffer = (char *)tmp___1;
  }
#line 77
  if ((unsigned long )templateBuffer == (unsigned long )((char *)((void *)0))) {
#line 78
    return (-1);
  }
  {
#line 80
  tmp___2 = strlen((char const   *)Name);
#line 80
  tmp___3 = malloc((tmp___2 + sizeof(Lock)) - 1UL);
#line 80
  lock = (char *)tmp___3;
  }
#line 80
  if ((unsigned long )lock == (unsigned long )((char *)((void *)0))) {
    {
#line 81
    free((void *)templateBuffer);
    }
#line 82
    return (-1);
  }
  {
#line 84
  sprintf((char */* __restrict  */)templateBuffer, (char const   */* __restrict  */)(Template),
          Name);
#line 85
  tmp___4 = mktemp(templateBuffer);
#line 85
  fd = open((char const   *)tmp___4, 193, 420);
  }
#line 85
  if (fd < 0) {
    {
#line 86
    free((void *)templateBuffer);
#line 87
    free((void *)lock);
    }
#line 88
    return (-1);
  }
  {
#line 90
  tmp___5 = getpid();
#line 90
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d\n",
          tmp___5);
#line 91
  tmp___6 = strlen((char const   *)(buffer));
#line 91
  write(fd, (void const   *)(buffer), tmp___6);
#line 92
  close(fd);
#line 93
  sprintf((char */* __restrict  */)lock, (char const   */* __restrict  */)(Lock),
          Name);
#line 94
  tmp___7 = link((char const   *)templateBuffer, (char const   *)lock);
  }
#line 94
  if (tmp___7 == 0) {
    {
#line 95
    unlink((char const   *)templateBuffer);
#line 96
    free((void *)templateBuffer);
#line 97
    free((void *)lock);
    }
#line 98
    return (0);
  }
  {
#line 101
  fd = open((char const   *)lock, 0);
  }
#line 101
  if (fd >= 0) {
    {
#line 102
    read(fd, (void *)(buffer), sizeof(buffer));
#line 103
    close(fd);
#line 104
    fd = atoi((char const   *)(buffer));
    }
#line 104
    if (fd == 0) {
      {
#line 105
      tmp___8 = __errno_location();
#line 105
      *tmp___8 = 1;
      }
    } else {
      {
#line 106
      tmp___10 = kill(fd, 0);
      }
#line 106
      if (tmp___10 == 0) {
        {
#line 107
        unlink((char const   *)templateBuffer);
#line 108
        free((void *)templateBuffer);
#line 109
        free((void *)lock);
#line 110
        tmp___9 = getpid();
        }
#line 110
        return (fd != tmp___9);
      }
    }
    {
#line 113
    tmp___11 = __errno_location();
    }
#line 113
    if (*tmp___11 != 1) {
      {
#line 114
      unlink((char const   *)lock);
      }
    }
  }
  {
#line 117
  fd = link((char const   *)templateBuffer, (char const   *)lock);
#line 118
  unlink((char const   *)templateBuffer);
#line 119
  free((void *)templateBuffer);
#line 120
  free((void *)lock);
  }
#line 121
  return (fd);
}
}
#line 125 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
void RmLock(char *name ) 
{ 
  char *Name ;
  char *tmp ;
  char *lock ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 131
  tmp = getName(name);
#line 131
  Name = tmp;
#line 132
  tmp___0 = strlen((char const   *)Name);
#line 132
  tmp___1 = malloc((tmp___0 + sizeof(Lock)) - 1UL);
#line 132
  lock = (char *)tmp___1;
  }
#line 134
  if ((unsigned long )lock != (unsigned long )((char *)((void *)0))) {
    {
#line 135
    sprintf((char */* __restrict  */)lock, (char const   */* __restrict  */)(Lock),
            Name);
#line 136
    unlink((char const   *)lock);
#line 137
    free((void *)lock);
    }
  }
#line 139
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
void ChLock(char *name , int pid ) 
{ 
  char *Name ;
  char *tmp ;
  int fd ;
  char buffer[10] ;
  char *lock ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 148
  tmp = getName(name);
#line 148
  Name = tmp;
#line 151
  tmp___0 = strlen((char const   *)Name);
#line 151
  tmp___1 = malloc((tmp___0 + sizeof(Lock)) - 1UL);
#line 151
  lock = (char *)tmp___1;
  }
#line 153
  if ((unsigned long )lock != (unsigned long )((char *)((void *)0))) {
    {
#line 154
    sprintf((char */* __restrict  */)lock, (char const   */* __restrict  */)(Lock),
            Name);
#line 155
    fd = open((char const   *)lock, 577, 420);
    }
#line 155
    if (fd >= 0) {
      {
#line 156
      sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d\n",
              pid);
#line 157
      tmp___2 = strlen((char const   *)(buffer));
#line 157
      write(fd, (void const   *)(buffer), tmp___2);
#line 158
      close(fd);
      }
    }
    {
#line 160
    free((void *)lock);
    }
  }
#line 162
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
int IsLock(char *name ) 
{ 
  char *Name ;
  char *tmp ;
  int fd ;
  char buffer[10] ;
  char *lock ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 171
  tmp = getName(name);
#line 171
  Name = tmp;
#line 174
  tmp___0 = strlen((char const   *)Name);
#line 174
  tmp___1 = malloc((tmp___0 + sizeof(Lock)) - 1UL);
#line 174
  lock = (char *)tmp___1;
  }
#line 176
  if ((unsigned long )lock == (unsigned long )((char *)((void *)0))) {
#line 177
    return (-1);
  }
  {
#line 179
  sprintf((char */* __restrict  */)lock, (char const   */* __restrict  */)(Lock),
          Name);
#line 180
  fd = open((char const   *)lock, 0);
#line 181
  free((void *)lock);
  }
#line 182
  if (fd < 0) {
#line 183
    return (0);
  }
  {
#line 185
  read(fd, (void *)(buffer), sizeof(buffer));
#line 186
  close(fd);
#line 187
  fd = atoi((char const   *)(buffer));
  }
#line 187
  if (fd == 0) {
#line 188
    return (-1);
  } else {
    {
#line 189
    tmp___2 = kill(fd, 0);
    }
#line 189
    if (tmp___2 == 0) {
#line 190
      return (1);
    }
  }
  {
#line 192
  tmp___3 = __errno_location();
  }
#line 192
  return (*tmp___3 == 1);
}
}
#line 324 "../include/dptalign.h"
uLONG dptGetV2(void *in_P , uLONG byteOffset ) ;
#line 327
uLONG dptSetV2(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 330
void dptOrV2(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 333
void dptAndV2(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 336
void dptXorV2(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 339
uLONG dptGetV3(void *in_P , uLONG byteOffset ) ;
#line 342
uLONG dptSetV3(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 345
void dptOrV3(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 348
void dptAndV3(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 351
void dptXorV3(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 354
uLONG dptGetV4(void *in_P , uLONG byteOffset ) ;
#line 357
uLONG dptSetV4(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 360
void dptOrV4(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 363
void dptAndV4(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 366
void dptXorV4(void *in_P , uLONG byteOffset , uLONG newValue ) ;
#line 69 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
uLONG dptGetV2(void *in_P , uLONG byteOffset ) 
{ 
  register uLONG tmpLong ;

  {
#line 76
  tmpLong = (uLONG )*((uCHAR *)in_P + byteOffset);
#line 77
  tmpLong |= (uLONG )*(((uCHAR *)in_P + byteOffset) + 1) << 8;
#line 80
  return (tmpLong);
}
}
#line 96 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
uLONG dptSetV2(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 103
  *((uCHAR *)in_P + byteOffset) = (uCHAR )newValue;
#line 104
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )(newValue >> 8);
#line 107
  return (newValue);
}
}
#line 123 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptOrV2(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 130
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) | (int )((uCHAR )newValue));
#line 131
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) | (int )((uCHAR )(newValue >> 8)));
#line 134
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptAndV2(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 157
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) & (int )((uCHAR )newValue));
#line 158
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) & (int )((uCHAR )(newValue >> 8)));
#line 161
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptXorV2(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 185
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) ^ (int )((uCHAR )newValue));
#line 186
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) ^ (int )((uCHAR )(newValue >> 8)));
#line 189
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
uLONG dptGetV3(void *in_P , uLONG byteOffset ) 
{ 
  register uLONG tmpLong ;

  {
#line 213
  tmpLong = (uLONG )*((uCHAR *)in_P + byteOffset);
#line 214
  tmpLong |= (uLONG )*(((uCHAR *)in_P + byteOffset) + 1) << 8;
#line 215
  tmpLong |= (uLONG )*(((uCHAR *)in_P + byteOffset) + 2) << 16;
#line 218
  return (tmpLong & 16777215UL);
}
}
#line 234 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
uLONG dptSetV3(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 242
  *((uCHAR *)in_P + byteOffset) = (uCHAR )newValue;
#line 243
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )(newValue >> 8);
#line 244
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )(newValue >> 16);
#line 247
  return (newValue & 16777215UL);
}
}
#line 263 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptOrV3(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 271
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) | (int )((uCHAR )newValue));
#line 272
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) | (int )((uCHAR )(newValue >> 8)));
#line 273
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 2) | (int )((uCHAR )(newValue >> 16)));
#line 276
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptAndV3(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 300
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) & (int )((uCHAR )newValue));
#line 301
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) & (int )((uCHAR )(newValue >> 8)));
#line 302
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 2) & (int )((uCHAR )(newValue >> 16)));
#line 305
  return;
}
}
#line 322 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptXorV3(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 330
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) ^ (int )((uCHAR )newValue));
#line 331
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) ^ (int )((uCHAR )(newValue >> 8)));
#line 332
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 2) ^ (int )((uCHAR )(newValue >> 16)));
#line 335
  return;
}
}
#line 351 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
uLONG dptGetV4(void *in_P , uLONG byteOffset ) 
{ 
  register uLONG tmpLong ;

  {
#line 360
  tmpLong = (uLONG )*((uCHAR *)in_P + byteOffset);
#line 361
  tmpLong |= (uLONG )*(((uCHAR *)in_P + byteOffset) + 1) << 8;
#line 362
  tmpLong |= (uLONG )*(((uCHAR *)in_P + byteOffset) + 2) << 16;
#line 363
  tmpLong |= (uLONG )*(((uCHAR *)in_P + byteOffset) + 3) << 24;
#line 366
  return (tmpLong);
}
}
#line 382 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
uLONG dptSetV4(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 391
  *((uCHAR *)in_P + byteOffset) = (uCHAR )newValue;
#line 392
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )(newValue >> 8);
#line 393
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )(newValue >> 16);
#line 394
  *(((uCHAR *)in_P + byteOffset) + 3) = (uCHAR )(newValue >> 24);
#line 397
  return (newValue);
}
}
#line 413 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptOrV4(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 422
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) | (int )((uCHAR )newValue));
#line 423
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) | (int )((uCHAR )(newValue >> 8)));
#line 424
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 2) | (int )((uCHAR )(newValue >> 16)));
#line 425
  *(((uCHAR *)in_P + byteOffset) + 3) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 3) | (int )((uCHAR )(newValue >> 24)));
#line 428
  return;
}
}
#line 444 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptAndV4(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 453
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) & (int )((uCHAR )newValue));
#line 454
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) & (int )((uCHAR )(newValue >> 8)));
#line 455
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 2) & (int )((uCHAR )(newValue >> 16)));
#line 456
  *(((uCHAR *)in_P + byteOffset) + 3) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 3) & (int )((uCHAR )(newValue >> 24)));
#line 459
  return;
}
}
#line 476 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/dptalign.c"
void dptXorV4(void *in_P , uLONG byteOffset , uLONG newValue ) 
{ 


  {
#line 485
  *((uCHAR *)in_P + byteOffset) = (uCHAR )((int )*((uCHAR *)in_P + byteOffset) ^ (int )((uCHAR )newValue));
#line 486
  *(((uCHAR *)in_P + byteOffset) + 1) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 1) ^ (int )((uCHAR )(newValue >> 8)));
#line 487
  *(((uCHAR *)in_P + byteOffset) + 2) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 2) ^ (int )((uCHAR )(newValue >> 16)));
#line 488
  *(((uCHAR *)in_P + byteOffset) + 3) = (uCHAR )((int )*(((uCHAR *)in_P + byteOffset) + 3) ^ (int )((uCHAR )(newValue >> 24)));
#line 491
  return;
}
}
#line 62 "/usr/include/x86_64-linux-gnu/sys/msg.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) msgctl)(int __msqid ,
                                                                             int __cmd ,
                                                                             struct msqid_ds *__buf ) ;
#line 65
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) msgget)(key_t __key ,
                                                                             int __msgflg ) ;
#line 71
extern ssize_t msgrcv(int __msqid , void *__msgp , size_t __msgsz , long __msgtyp ,
                      int __msgflg ) ;
#line 78
extern int msgsnd(int __msqid , void const   *__msgp , size_t __msgsz , int __msgflg ) ;
#line 75 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/engmsg.c"
uLONG DptEnginePid  =    (uLONG )0;
#line 93 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/engmsg.c"
int MessageDPTEngine(int EngineMsgKey , int msqID , int EngineMessage , int SecondsToWait ) 
{ 
  MsgHdr HdrBuff ;
  int p_id ;
  int i ;
  int Rtnval ;
  int OldAlarm ;
  int Done ;
  __pid_t tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 100
  Rtnval = 1;
#line 105
  tmp = getpid();
#line 105
  p_id = tmp;
#line 106
  tmp___0 = alarm(0U);
#line 106
  OldAlarm = (int )tmp___0;
#line 120
  Done = 0;
  }
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (! Done)) {
#line 121
      goto while_break;
    }
    {
#line 123
    Done = 1;
#line 130
    tmp___1 = msgrcv(msqID, (void *)((struct msgbuf *)(& HdrBuff)), sizeof(MsgHdr ) - 4UL,
                     (long )p_id, 2048);
#line 130
    i = (int )tmp___1;
    }
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (! (i != -1)) {
#line 131
        goto while_break___0;
      }
      {
#line 133
      tmp___2 = msgrcv(msqID, (void *)((struct msgbuf *)(& HdrBuff)), sizeof(MsgHdr ) - 4UL,
                       (long )p_id, 2048);
#line 133
      i = (int )tmp___2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 140
    HdrBuff.engineTag = (DPT_TAG_T )p_id;
#line 141
    HdrBuff.engEvent = (DPT_MSG_T )EngineMessage;
#line 142
    HdrBuff.targetTag = (DPT_TAG_T )p_id;
#line 143
    HdrBuff.callerID = (uLONG )p_id;
#line 144
    HdrBuff.BufferID = 0L;
#line 145
    HdrBuff.FromEngBuffOffset = (uLONG )0;
#line 146
    HdrBuff.result = (DPT_RTN_T )0;
#line 150
    HdrBuff.MsgID = (uLONG )EngineMsgKey;
#line 155
    tmp___5 = msgsnd(msqID, (void const   *)((struct msgbuf *)(& HdrBuff)), sizeof(MsgHdr ) - 4UL,
                     0);
#line 155
    i = tmp___5 != -1;
    }
#line 155
    if (i) {
      {
#line 162
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 162
        if (! (i != -1)) {
#line 162
          goto while_break___1;
        }
        {
#line 167
        alarm((unsigned int )SecondsToWait);
#line 172
        tmp___3 = msgrcv(msqID, (void *)((struct msgbuf *)(& HdrBuff)), sizeof(MsgHdr ) - 4UL,
                         (long )p_id, 0);
#line 172
        i = (int )tmp___3;
#line 177
        alarm(0U);
        }
#line 182
        if (i != -1) {
#line 182
          if (HdrBuff.engEvent == (DPT_MSG_T )EngineMessage) {
#line 184
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 191
      if (i == -1) {
        {
#line 193
        tmp___4 = __errno_location();
#line 193
        Rtnval = *tmp___4;
        }
      } else
#line 204
      if (HdrBuff.engEvent == (DPT_MSG_T )EngineMessage) {
#line 206
        Rtnval = 0;
#line 212
        if (! DptEnginePid) {
#line 212
          if (EngineMessage == 1) {
#line 214
            DptEnginePid = HdrBuff.callerID;
          }
        }
      } else {
#line 224
        Done = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (OldAlarm) {
    {
#line 247
    alarm((unsigned int )OldAlarm);
    }
  }
#line 250
  return (Rtnval);
}
}
#line 266 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/engmsg.c"
int CheckForEngine(int EngineMsgKey , int Clear , int SecondsToWait ) 
{ 
  int msqID ;
  struct msqid_ds CtlBuf ;
  int i ;
  int LoopCount ;
  MsgHdr HdrBuff ;
  int p_id ;
  int OldAlarm ;
  __pid_t tmp ;
  unsigned int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 268
  msqID = -1;
#line 277
  if (! SecondsToWait) {
#line 278
    SecondsToWait = 2;
  }
  {
#line 283
  msqID = msgget(2, 438);
  }
#line 287
  if (msqID != -1) {
    {
#line 289
    i = MessageDPTEngine(EngineMsgKey, msqID, 0, SecondsToWait);
    }
#line 293
    if (i) {
      {
#line 299
      tmp = getpid();
#line 299
      p_id = tmp;
#line 300
      HdrBuff.engineTag = (DPT_TAG_T )p_id;
#line 301
      HdrBuff.engEvent = (DPT_MSG_T )0;
#line 302
      HdrBuff.targetTag = (DPT_TAG_T )p_id;
#line 303
      HdrBuff.callerID = (uLONG )p_id;
#line 304
      HdrBuff.BufferID = 0L;
#line 305
      HdrBuff.FromEngBuffOffset = (uLONG )0;
#line 306
      HdrBuff.result = (DPT_RTN_T )0;
#line 310
      HdrBuff.MsgID = (uLONG )EngineMsgKey;
#line 316
      LoopCount = 60 / SecondsToWait;
      }
      {
#line 317
      while (1) {
        while_continue: /* CIL Label */ ;
#line 317
        tmp___3 = LoopCount;
#line 317
        LoopCount --;
#line 317
        if (! tmp___3) {
#line 317
          goto while_break;
        }
        {
#line 322
        tmp___2 = IsLock((char *)"dpteng");
        }
#line 322
        if (tmp___2) {
          {
#line 327
          tmp___0 = alarm((unsigned int )SecondsToWait);
#line 327
          OldAlarm = (int )tmp___0;
#line 331
          tmp___1 = msgrcv(msqID, (void *)((struct msgbuf *)(& HdrBuff)), sizeof(MsgHdr ) - 4UL,
                           (long )p_id, 0);
#line 331
          i = (int )tmp___1;
#line 336
          alarm((unsigned int )OldAlarm);
          }
#line 341
          if (i == -1) {
#line 343
            goto while_continue;
          } else {
#line 350
            return (msqID);
          }
        } else {
#line 357
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 365
      if (Clear) {
        {
#line 366
        msgctl(msqID, 0, & CtlBuf);
        }
      }
#line 367
      msqID = -1;
    }
  }
#line 370
  return (msqID);
}
}
#line 386 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/engmsg.c"
int CheckForCommEng(int EngineMsgKey , int Clear , int SecondsToWait ) 
{ 
  int msqID ;
  int i ;

  {
#line 388
  msqID = -1;
#line 393
  if (! SecondsToWait) {
#line 394
    SecondsToWait = 1;
  }
  {
#line 398
  msqID = msgget(2, 438);
  }
#line 402
  if (msqID != -1) {
    {
#line 404
    i = MessageDPTEngine(EngineMsgKey, msqID, 0, SecondsToWait);
    }
#line 409
    if (i) {
#line 411
      msqID = -1;
    }
  }
#line 415
  return (msqID);
}
}
#line 47 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
void BufferSetAllocSize(void *buf , uLONG size ) 
{ 
  dptData_S *bp ;

  {
#line 50
  bp = (dptData_S *)buf;
#line 51
  bp->allocSize = (size - sizeof(dptData_S )) + 1UL;
#line 52
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
void BufferReset(void *buf ) 
{ 
  dptData_S *bp ;

  {
#line 58
  bp = (dptData_S *)buf;
#line 59
  bp->writeIndex = (uLONG )0;
#line 60
  bp->readIndex = (uLONG )0;
#line 61
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
void BufferClear(void *buf ) 
{ 
  dptData_S *bp ;

  {
  {
#line 67
  bp = (dptData_S *)buf;
#line 68
  memset((void *)(bp->data), 0, (size_t )((uINT )bp->allocSize));
  }
#line 69
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
void BufferReplay(void *buf ) 
{ 
  dptData_S *bp ;

  {
#line 75
  bp = (dptData_S *)buf;
#line 76
  bp->readIndex = (uLONG )0;
#line 77
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
uSHORT BufferExtract(void *buf , void *dest_P , uSHORT destSize ) 
{ 
  dptData_S *bp ;
  uLONG numToCopy ;
  uLONG numLeft ;

  {
#line 85
  bp = (dptData_S *)buf;
#line 87
  numToCopy = (uLONG )0;
#line 88
  if (bp->writeIndex > bp->readIndex) {
#line 90
    numLeft = bp->writeIndex - bp->readIndex;
#line 91
    if (numLeft > (uLONG )destSize) {
#line 91
      numToCopy = (uLONG )destSize;
    } else {
#line 91
      numToCopy = numLeft;
    }
    {
#line 92
    memcpy((void */* __restrict  */)dest_P, (void const   */* __restrict  */)(& bp->data[bp->readIndex]),
           (size_t )((uINT )numToCopy));
#line 93
    bp->readIndex += numToCopy;
    }
  }
#line 96
  if (numToCopy == (uLONG )destSize) {
#line 96
    return ((uSHORT )1);
  } else {
#line 97
    return ((uSHORT )0);
  }
}
}
#line 101 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
uSHORT BufferSkip(void *buf , uSHORT destSize ) 
{ 
  dptData_S *bp ;
  uLONG numToCopy ;
  uLONG numLeft ;

  {
#line 106
  bp = (dptData_S *)buf;
#line 108
  numToCopy = (uLONG )0;
#line 109
  if (bp->writeIndex > bp->readIndex) {
#line 111
    numLeft = bp->writeIndex - bp->readIndex;
#line 112
    if (numLeft > (uLONG )destSize) {
#line 112
      numToCopy = (uLONG )destSize;
    } else {
#line 112
      numToCopy = numLeft;
    }
#line 113
    bp->readIndex += numToCopy;
  }
#line 116
  if (numToCopy == (uLONG )destSize) {
#line 116
    return ((uSHORT )1);
  } else {
#line 117
    return ((uSHORT )0);
  }
}
}
#line 121 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
uSHORT BufferInsert(void *buf , void *src_P , uSHORT srcSize ) 
{ 
  dptData_S *bp ;
  uLONG numToCopy ;
  uLONG numLeft ;

  {
#line 126
  bp = (dptData_S *)buf;
#line 128
  numToCopy = (uLONG )0;
#line 129
  if (bp->allocSize > bp->writeIndex) {
#line 131
    numLeft = bp->allocSize - bp->writeIndex;
#line 132
    if (numLeft > (uLONG )srcSize) {
#line 132
      numToCopy = (uLONG )srcSize;
    } else {
#line 132
      numToCopy = numLeft;
    }
    {
#line 133
    memcpy((void */* __restrict  */)(& bp->data[bp->writeIndex]), (void const   */* __restrict  */)src_P,
           (size_t )((uINT )numToCopy));
#line 134
    bp->writeIndex += numToCopy;
    }
  }
#line 137
  if (numToCopy == (uLONG )srcSize) {
#line 137
    return ((uSHORT )1);
  } else {
#line 138
    return ((uSHORT )0);
  }
}
}
#line 142 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
uSHORT BufferInsertULONG(void *buf , uLONG src ) 
{ 
  dptData_S *bp ;
  uLONG numToCopy ;
  uLONG numLeft ;

  {
#line 147
  bp = (dptData_S *)buf;
#line 149
  numToCopy = (uLONG )0;
#line 150
  if (bp->allocSize > bp->writeIndex) {
#line 152
    numLeft = bp->allocSize - bp->writeIndex;
#line 153
    if (numLeft > sizeof(uLONG )) {
#line 153
      numToCopy = sizeof(uLONG );
    } else {
#line 153
      numToCopy = numLeft;
    }
    {
#line 154
    memcpy((void */* __restrict  */)(& bp->data[bp->writeIndex]), (void const   */* __restrict  */)(& src),
           (size_t )((uINT )numToCopy));
#line 155
    bp->writeIndex += numToCopy;
    }
  }
#line 158
  if (numToCopy == sizeof(uLONG )) {
#line 158
    return ((uSHORT )1);
  } else {
#line 159
    return ((uSHORT )0);
  }
}
}
#line 163 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
uSHORT BufferInsertUSHORT(void *buf , uSHORT src ) 
{ 
  dptData_S *bp ;
  uLONG numToCopy ;
  uLONG numLeft ;

  {
#line 168
  bp = (dptData_S *)buf;
#line 170
  numToCopy = (uLONG )0;
#line 171
  if (bp->allocSize > bp->writeIndex) {
#line 173
    numLeft = bp->allocSize - bp->writeIndex;
#line 174
    if (numLeft > sizeof(uSHORT )) {
#line 174
      numToCopy = sizeof(uSHORT );
    } else {
#line 174
      numToCopy = numLeft;
    }
    {
#line 175
    memcpy((void */* __restrict  */)(& bp->data[bp->writeIndex]), (void const   */* __restrict  */)(& src),
           (size_t )((uINT )numToCopy));
#line 176
    bp->writeIndex += numToCopy;
    }
  }
#line 179
  if (numToCopy == sizeof(uSHORT )) {
#line 179
    return ((uSHORT )1);
  } else {
#line 180
    return ((uSHORT )0);
  }
}
}
#line 184 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
uSHORT BufferInsertuCHAR(void *buf , uCHAR src ) 
{ 
  dptData_S *bp ;
  uLONG numToCopy ;
  uLONG numLeft ;

  {
#line 189
  bp = (dptData_S *)buf;
#line 191
  numToCopy = (uLONG )0;
#line 192
  if (bp->allocSize > bp->writeIndex) {
#line 194
    numLeft = bp->allocSize - bp->writeIndex;
#line 195
    if (numLeft > sizeof(uCHAR )) {
#line 195
      numToCopy = sizeof(uCHAR );
    } else {
#line 195
      numToCopy = numLeft;
    }
    {
#line 196
    memcpy((void */* __restrict  */)(& bp->data[bp->writeIndex]), (void const   */* __restrict  */)(& src),
           (size_t )((uINT )numToCopy));
#line 197
    bp->writeIndex += numToCopy;
    }
  }
#line 200
  if (numToCopy == sizeof(uCHAR )) {
#line 200
    return ((uSHORT )1);
  } else {
#line 201
    return ((uSHORT )0);
  }
}
}
#line 206 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/dptcbuff.c"
void BufferSetExtractSize(void *buf , uSHORT inSize ) 
{ 
  dptData_S *bp ;

  {
#line 209
  bp = (dptData_S *)buf;
#line 211
  if (bp->allocSize > (uLONG )inSize) {
#line 211
    bp->writeIndex = (uLONG )inSize;
  } else {
#line 211
    bp->writeIndex = bp->allocSize;
  }
#line 213
  return;
}
}
#line 238 "../include/osd_util.h"
uSHORT osdSwap2(uSHORT *inShort ) ;
#line 243
uLONG osdSwap3(uLONG *inLong ) ;
#line 260
uLONG osdSwap4(uLONG *inLong ) ;
#line 266
uSHORT trueSwap2(uSHORT *inShort ) ;
#line 267
uLONG trueSwap4(uLONG *inLong ) ;
#line 285
uLONG netSwap4(uLONG val ) ;
#line 73 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/swap_em.c"
uSHORT osdSwap2(uSHORT *inShort ) 
{ 
  uSHORT i ;

  {
#line 92
  i = (uSHORT )((int )*inShort & 255);
#line 93
  *inShort = (uSHORT )((int )*inShort >> 8);
#line 94
  *inShort = (uSHORT )((int )*inShort | ((int )i << 8));
#line 95
  return (*inShort);
}
}
#line 120 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/swap_em.c"
uLONG osdSwap4(uLONG *inLong ) 
{ 
  char src[4] ;
  char *dst ;
  int i ;

  {
#line 141
  *((uLONG *)(src)) = *inLong;
#line 142
  dst = (char *)inLong;
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < 4)) {
#line 143
      goto while_break;
    }
#line 145
    *(dst + i) = src[3 - i];
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (*inLong);
}
}
#line 155 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/swap_em.c"
uLONG osdSwap3(uLONG *inLong ) 
{ 
  uLONG tmp ;

  {
  {
#line 173
  tmp = osdSwap4(inLong);
  }
#line 173
  return (tmp >> 8);
}
}
#line 197 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/swap_em.c"
uSHORT trueSwap2(uSHORT *inShort ) 
{ 
  uSHORT outShort ;
  char *src ;
  char *dst ;

  {
#line 204
  src = (char *)inShort;
#line 205
  dst = (char *)(& outShort);
#line 207
  *(dst + 0) = *(src + 1);
#line 208
  *(dst + 1) = *(src + 0);
#line 210
  *(src + 0) = *(dst + 0);
#line 211
  *(src + 1) = *(dst + 1);
#line 213
  return (outShort);
}
}
#line 237 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/swap_em.c"
uLONG trueSwap4(uLONG *inLong ) 
{ 
  uLONG outLong ;
  char *src ;
  char *dst ;
  int i ;

  {
#line 244
  src = (char *)inLong;
#line 245
  dst = (char *)(& outLong);
#line 246
  i = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < 4)) {
#line 246
      goto while_break;
    }
#line 248
    *(dst + i) = *(src + (3 - i));
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  i = 0;
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! (i < 4)) {
#line 251
      goto while_break___0;
    }
#line 253
    *(src + i) = *(dst + i);
#line 251
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 256
  return (outLong);
}
}
#line 284 "/home/wheatley/newnew/temp/raidutils-0.0.6/raideng/swap_em.c"
uLONG netSwap4(uLONG val ) 
{ 


  {
#line 301
  return (val);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 71 "../include/findpath.h"
char *FindPath(char const   *file , int mode ) ;
#line 72
char *AddSearchArgv(char *search ) ;
#line 73
char *AddSearch(char *searchLeft , char const   *searchRight ) ;
#line 74
char *FindPathWithSearch(char const   *file , int mode , char const   *search ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 104 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strcat(char *left , char const   *right ) ;
#line 105
static char *DirName(char const   *left ) ;
#line 106
static char *BaseName(char const   *left ) ;
#line 107
static int fileAccess(char const   *file , int mode ) ;
#line 108
static char *Strtok(char const   *string , char const   *sepset ) ;
#line 112 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char const   DefaultPath[76]  = 
#line 112
  {      (char const   )'.',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'d', 
        (char const   )'p',      (char const   )'t',      (char const   )':',      (char const   )'/', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'/', 
        (char const   )'S',      (char const   )'U',      (char const   )'N',      (char const   )'W', 
        (char const   )'h',      (char const   )'w',      (char const   )'r',      (char const   )'d', 
        (char const   )'g',      (char const   )':',      (char const   )'/',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'/',      (char const   )'S', 
        (char const   )'U',      (char const   )'N',      (char const   )'W',      (char const   )'h', 
        (char const   )'w',      (char const   )'r',      (char const   )'d',      (char const   )'c', 
        (char const   )':',      (char const   )'/',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'/',      (char const   )'d',      (char const   )'p', 
        (char const   )'t',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'p',      (char const   )'p',      (char const   )'/',      (char const   )'d', 
        (char const   )'p',      (char const   )'t',      (char const   )':',      (char const   )'/', 
        (char const   )'v',      (char const   )'a',      (char const   )'r',      (char const   )'/', 
        (char const   )'d',      (char const   )'p',      (char const   )'t',      (char const   )'\000'};
#line 113 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char const   Separator[2]  = {      (char const   )':',      (char const   )'\000'};
#line 114 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char DirectorySeparator[2]  = {      (char )'/',      (char )'\000'};
#line 133 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strcat(char *left , char const   *right ) 
{ 
  int zero ;
  unsigned int size ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 136
  zero = 0;
#line 139
  if ((unsigned long )right == (unsigned long )((char *)((void *)0))) {
#line 144
    return (left);
  } else
#line 139
  if ((int const   )*right == 0) {
#line 144
    return (left);
  } else {
#line 139
    zero = (unsigned long )left == (unsigned long )((char *)((void *)0));
#line 139
    if (zero) {
      {
#line 139
      tmp = strlen(right);
#line 139
      size = (unsigned int )(tmp + 1UL);
#line 139
      tmp___0 = malloc((size_t )size);
#line 139
      tmp___4 = tmp___0;
      }
    } else {
      {
#line 139
      tmp___1 = strlen((char const   *)left);
#line 139
      tmp___2 = strlen(right);
#line 139
      size = (unsigned int )((tmp___1 + tmp___2) + 1UL);
#line 139
      tmp___3 = realloc((void *)left, (size_t )size);
#line 139
      tmp___4 = tmp___3;
      }
    }
#line 139
    left = (char *)tmp___4;
#line 139
    if ((unsigned long )left == (unsigned long )((char *)((void *)0))) {
#line 144
      return (left);
    }
  }
#line 146
  if (zero) {
    {
#line 147
    memset((void *)left, 0, (size_t )size);
    }
  }
  {
#line 149
  tmp___5 = strcat((char */* __restrict  */)left, (char const   */* __restrict  */)right);
  }
#line 149
  return (tmp___5);
}
}
#line 153 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *DirName(char const   *left ) 
{ 
  char *retVal ;
  char *cp ;
  size_t tmp ;
  unsigned int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 158
  retVal = (char *)left;
#line 158
  if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
    {
#line 159
    tmp = strlen((char const   *)retVal);
#line 159
    cp = retVal + tmp;
    }
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      cp --;
#line 162
      if ((unsigned long )cp >= (unsigned long )left) {
#line 162
        if ((int )*cp != 47) {
#line 162
          if ((int )*cp != 92) {
#line 162
            if (! ((int )*cp != 58)) {
#line 162
              goto while_break;
            }
          } else {
#line 162
            goto while_break;
          }
        } else {
#line 162
          goto while_break;
        }
      } else {
#line 162
        goto while_break;
      }
#line 163
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 165
    if ((unsigned long )cp >= (unsigned long )left) {
#line 166
      DirectorySeparator[0] = *cp;
    }
#line 168
    size = (unsigned int )(cp - (char *)left) + 2U;
#line 168
    if (size <= 1U) {
#line 169
      return ((char *)((void *)0));
    }
    {
#line 171
    tmp___1 = malloc((size_t )size);
#line 171
    retVal = (char *)tmp___1;
    }
#line 171
    if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
      {
#line 172
      tmp___0 = memcpy((void */* __restrict  */)retVal, (void const   */* __restrict  */)left,
                       (size_t )(size - 1U));
#line 172
      *((char *)tmp___0 + (size - 1U)) = (char )'\000';
      }
    }
  }
#line 175
  return (retVal);
}
}
#line 179 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *BaseName(char const   *left ) 
{ 
  char *retVal ;
  unsigned int size ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 187
  retVal = (char *)left;
#line 187
  if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
    {
#line 189
    tmp = strlen((char const   *)retVal);
#line 189
    size = (unsigned int )tmp;
#line 189
    cp = retVal + size;
    }
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      cp --;
#line 191
      if ((unsigned long )cp >= (unsigned long )left) {
#line 191
        if ((int )*cp != 47) {
#line 191
          if ((int )*cp != 92) {
#line 191
            if (! ((int )*cp != 58)) {
#line 191
              goto while_break;
            }
          } else {
#line 191
            goto while_break;
          }
        } else {
#line 191
          goto while_break;
        }
      } else {
#line 191
        goto while_break;
      }
#line 192
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 194
    if ((unsigned long )cp >= (unsigned long )left) {
#line 195
      DirectorySeparator[0] = *cp;
    }
#line 197
    cp ++;
#line 197
    if (size <= (unsigned int )(cp - (char *)left)) {
#line 201
      return ((char *)((void *)0));
    }
    {
#line 203
    size -= (unsigned int )(cp - (char *)left) - 1U;
#line 204
    tmp___1 = malloc((size_t )size);
#line 204
    retVal = (char *)tmp___1;
    }
#line 204
    if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
      {
#line 205
      tmp___0 = memcpy((void */* __restrict  */)retVal, (void const   */* __restrict  */)cp,
                       (size_t )(size - 1U));
#line 205
      *((char *)tmp___0 + (size - 1U)) = (char )'\000';
      }
    }
  }
#line 211
  return (retVal);
}
}
#line 219 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static int fileAccess(char const   *file , int mode ) 
{ 
  struct __anonstruct_fileStat_28 fileStat ;
  int retVal ;
  int tmp ;

  {
  {
#line 229
  retVal = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& fileStat.s));
  }
#line 229
  if (retVal < 0) {
#line 230
    return (retVal);
  }
#line 236
  if (((fileStat.s.st_mode & 61440U) == 32768U) == 0) {
#line 237
    return (1);
  }
  {
#line 239
  tmp = access(file, mode);
  }
#line 239
  return (tmp);
}
}
#line 254 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *savept  ;
#line 255 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *hold  ;
#line 250 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strtok(char const   *string , char const   *sepset ) 
{ 
  register char *p ;
  register char *q ;
  register char *r ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 257
  if ((unsigned long )hold != (unsigned long )((void *)0)) {
    {
#line 258
    free((void *)hold);
#line 259
    hold = (char *)((void *)0);
    }
  }
#line 261
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 262
    p = savept;
  } else {
#line 264
    p = (char *)string;
  }
#line 265
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 266
    return ((char *)((void *)0));
  }
  {
#line 267
  tmp = strspn((char const   *)p, sepset);
#line 267
  q = p + tmp;
  }
#line 268
  if ((int )*q == 0) {
#line 269
    return ((char *)((void *)0));
  }
  {
#line 270
  r = strpbrk((char const   *)q, sepset);
  }
#line 270
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 271
    savept = (char *)0;
  } else {
    {
#line 273
    tmp___0 = malloc((size_t )((unsigned int )(r - q) + 1U));
#line 273
    hold = (char *)tmp___0;
    }
#line 274
    if (hold) {
      {
#line 275
      tmp___1 = strspn((char const   *)r, sepset);
#line 275
      p = r + tmp___1;
      }
#line 276
      if ((unsigned long )p > (unsigned long )r) {
#line 276
        savept = p;
      } else {
#line 276
        savept = r + 1;
      }
      {
#line 277
      memcpy((void */* __restrict  */)hold, (void const   */* __restrict  */)q, (size_t )((unsigned int )(r - q)));
#line 278
      *(hold + (r - q)) = (char )'\000';
#line 279
      q = hold;
      }
    } else {
      {
#line 282
      *r = (char )'\000';
#line 283
      tmp___2 = strspn((char const   *)r, sepset);
#line 283
      p = r + tmp___2;
      }
#line 284
      if ((unsigned long )p > (unsigned long )r) {
#line 284
        p ++;
#line 284
        savept = p;
      } else {
#line 284
        r ++;
#line 284
        savept = r;
      }
    }
  }
#line 287
  return (q);
}
}
#line 293 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
char *FindPathWithSearch(char const   *file , int mode , char const   *search ) 
{ 
  char *Name ;
  char *token ;
  char *path ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 303
  Name = BaseName(file);
  }
#line 303
  if ((unsigned long )Name == (unsigned long )((char *)((void *)0))) {
#line 307
    return ((char *)((void *)0));
  }
#line 309
  if ((unsigned long )search != (unsigned long )((char const   *)((void *)0))) {
#line 311
    path = (char *)search;
#line 313
    if ((int const   )*(file + 0) != (int const   )DirectorySeparator[0]) {
      {
#line 315
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 315
        token = Strtok((char const   *)path, Separator);
        }
#line 315
        if (! ((unsigned long )token != (unsigned long )((char *)((void *)0)))) {
#line 315
          goto while_break;
        }
        {
#line 322
        path = Strcat((char *)((void *)0), (char const   *)token);
        }
#line 322
        if ((unsigned long )path != (unsigned long )((char *)((void *)0))) {
          {
#line 322
          tmp___0 = strlen((char const   *)path);
          }
#line 322
          if ((int )*(path + (tmp___0 - 1UL)) == (int )DirectorySeparator[0]) {
#line 322
            goto _L;
          } else {
            {
#line 322
            path = Strcat(path, (char const   *)(DirectorySeparator));
            }
#line 322
            if ((unsigned long )path != (unsigned long )((char *)((void *)0))) {
              _L: /* CIL Label */ 
              {
#line 322
              path = Strcat(path, file);
              }
#line 322
              if ((unsigned long )path != (unsigned long )((char *)((void *)0))) {
                {
#line 331
                tmp = fileAccess((char const   *)path, mode);
                }
#line 331
                if (tmp == 0) {
                  {
#line 332
                  free((void *)Name);
                  }
#line 338
                  return (path);
                }
                {
#line 340
                free((void *)path);
                }
              }
            }
          }
        }
#line 343
        path = (char *)((void *)0);
      }
      while_break: /* CIL Label */ ;
      }
#line 345
      path = (char *)search;
    }
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 348
      token = Strtok((char const   *)path, Separator);
      }
#line 348
      if (! ((unsigned long )token != (unsigned long )((char *)((void *)0)))) {
#line 348
        goto while_break___0;
      }
      {
#line 350
      path = Strcat((char *)((void *)0), (char const   *)token);
      }
#line 350
      if ((unsigned long )path != (unsigned long )((char *)((void *)0))) {
        {
#line 350
        tmp___2 = strlen((char const   *)path);
        }
#line 350
        if ((int )*(path + (tmp___2 - 1UL)) == (int )DirectorySeparator[0]) {
#line 350
          goto _L___0;
        } else {
          {
#line 350
          path = Strcat(path, (char const   *)(DirectorySeparator));
          }
#line 350
          if ((unsigned long )path != (unsigned long )((char *)((void *)0))) {
            _L___0: /* CIL Label */ 
            {
#line 350
            path = Strcat(path, (char const   *)Name);
            }
#line 350
            if ((unsigned long )path != (unsigned long )((char *)((void *)0))) {
              {
#line 358
              tmp___1 = fileAccess((char const   *)path, mode);
              }
#line 358
              if (tmp___1 == 0) {
                {
#line 359
                free((void *)Name);
                }
#line 363
                return (path);
              }
              {
#line 365
              free((void *)path);
              }
            }
          }
        }
      }
#line 367
      path = (char *)((void *)0);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 370
  free((void *)Name);
  }
#line 374
  return ((char *)((void *)0));
}
}
#line 377 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
char *AddSearch(char *searchLeft , char const   *searchRight ) 
{ 


  {
#line 380
  if ((unsigned long )searchRight != (unsigned long )((char *)((void *)0))) {
#line 380
    if ((int const   )*(searchRight + 0) != 0) {
#line 381
      if ((unsigned long )searchLeft != (unsigned long )((char *)((void *)0))) {
        {
#line 382
        searchLeft = Strcat(searchLeft, Separator);
        }
      }
      {
#line 384
      searchLeft = Strcat(searchLeft, searchRight);
      }
    }
  }
#line 389
  return (searchLeft);
}
}
#line 426 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char _grep[14]  = 
#line 426
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'g',      (char )'r',      (char )'e', 
        (char )'p',      (char )'\000'};
#line 428 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char _ps[12]  = 
#line 428
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'p',      (char )'s',      (char )'\000'};
#line 433 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char command[16]  = 
#line 433
  {      (char )'%',      (char )'s',      (char )' ',      (char )'-', 
        (char )'l',      (char )'|',      (char )'%',      (char )'s', 
        (char )' ',      (char )'\'',      (char )' ',      (char )'%', 
        (char )'d',      (char )' ',      (char )'\'',      (char )'\000'};
#line 392 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
char *AddSearchArgv(char *search ) 
{ 
  char *_localArgv[2] ;
  char **localArgv ;
  char *grep ;
  char *ps ;
  char *buffer ;
  int tmp ;
  int tmp___0 ;
  FILE *fp ;
  __pid_t tmp___1 ;
  void *tmp___2 ;
  char *cp ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int length ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *execute ;
  char *tmp___9 ;

  {
#line 423
  localArgv = Argv;
#line 423
  if ((unsigned long )localArgv == (unsigned long )((char **)((void *)0))) {
#line 423
    goto _L;
  } else
#line 423
  if ((unsigned long )*(localArgv + 0) == (unsigned long )((char *)((void *)0))) {
#line 423
    goto _L;
  } else
#line 423
  if ((int )*(*(localArgv + 0) + 0) == 0) {
    _L: /* CIL Label */ 
    {
#line 427
    grep = _grep;
#line 429
    ps = _ps;
#line 437
    localArgv = (char **)((void *)0);
#line 438
    tmp = fileAccess((char const   *)grep, 1);
    }
#line 438
    if (tmp) {
#line 439
      grep += 4;
    }
    {
#line 441
    tmp___0 = fileAccess((char const   *)ps, 1);
    }
#line 441
    if (tmp___0) {
#line 442
      ps += 4;
    }
    {
#line 444
    tmp___4 = strlen((char const   *)ps);
#line 444
    tmp___5 = strlen((char const   *)grep);
#line 444
    tmp___6 = malloc((((sizeof(command) - 6UL) + 10UL) + tmp___4) + tmp___5);
#line 444
    buffer = (char *)tmp___6;
    }
#line 444
    if ((unsigned long )buffer != (unsigned long )((char *)((void *)0))) {
      {
#line 448
      tmp___1 = getpid();
#line 448
      sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)(command),
              ps, grep, tmp___1);
#line 449
      fp = popen((char const   *)buffer, "r");
      }
#line 449
      if ((unsigned long )fp != (unsigned long )((FILE *)((void *)0))) {
        {
#line 450
        free((void *)buffer);
#line 451
        tmp___2 = malloc((size_t )512);
#line 451
        buffer = (char *)tmp___2;
        }
        {
#line 452
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 452
          tmp___3 = fgets((char */* __restrict  */)buffer, 512, (FILE */* __restrict  */)fp);
          }
#line 452
          if (! tmp___3) {
#line 452
            goto while_break;
          }
#line 453
          cp = buffer;
          {
#line 454
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 454
            if (*cp) {
#line 454
              if ((int )*cp != 13) {
#line 454
                if (! ((int )*cp != 10)) {
#line 454
                  goto while_break___0;
                }
              } else {
#line 454
                goto while_break___0;
              }
            } else {
#line 454
              goto while_break___0;
            }
#line 454
            cp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 455
          *cp = (char )'\000';
          {
#line 456
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 456
            cp --;
#line 456
            if (! ((unsigned long )cp > (unsigned long )buffer)) {
#line 456
              goto while_break___1;
            }
#line 457
            if ((int )*(cp + 0) == 58) {
#line 457
              if (48 <= (int )*(cp + 1)) {
#line 457
                if ((int )*(cp + 1) <= 53) {
#line 457
                  if (48 <= (int )*(cp + 2)) {
#line 457
                    if ((int )*(cp + 2) <= 57) {
#line 460
                      goto while_break___1;
                    }
                  }
                }
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 463
          if ((int )*cp == 58) {
#line 464
            cp += 3;
            {
#line 466
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 466
              if (! ((int )*cp == 32)) {
#line 466
                if (! ((int )*cp == 9)) {
#line 466
                  goto while_break___2;
                }
              }
#line 467
              cp ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 469
            cp = strcpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)cp);
            }
            {
#line 470
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 470
              if (*cp) {
#line 470
                if ((int )*cp != 32) {
#line 470
                  if (! ((int )*cp != 9)) {
#line 470
                    goto while_break___3;
                  }
                } else {
#line 470
                  goto while_break___3;
                }
              } else {
#line 470
                goto while_break___3;
              }
#line 471
              cp ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 473
            *cp = (char )'\000';
#line 474
            _localArgv[0] = buffer;
#line 475
            _localArgv[1] = (char *)((void *)0);
#line 476
            localArgv = _localArgv;
#line 477
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 480
        pclose(fp);
        }
#line 481
        if ((unsigned long )localArgv == (unsigned long )((char **)((void *)0))) {
          {
#line 482
          free((void *)buffer);
          }
        }
      } else {
        {
#line 485
        free((void *)buffer);
        }
      }
    }
  }
#line 491
  if ((unsigned long )localArgv == (unsigned long )((char **)((void *)0))) {
#line 491
    goto _L___0;
  } else
#line 491
  if ((unsigned long )*(localArgv + 0) == (unsigned long )((char *)((void *)0))) {
#line 491
    goto _L___0;
  } else
#line 491
  if ((int )*(*(localArgv + 0) + 0) == 0) {
    _L___0: /* CIL Label */ 
    {
#line 497
    _localArgv[0] = getenv("_");
    }
#line 497
    if ((unsigned long )_localArgv[0] != (unsigned long )((char *)((void *)0))) {
      {
#line 497
      tmp___7 = strlen((char const   *)_localArgv[0]);
#line 497
      length = (int )tmp___7;
      }
#line 497
      if (length > 1) {
        {
#line 497
        tmp___8 = strcmp((char const   *)((_localArgv[0] + length) - 2), "sh");
        }
#line 497
        if (tmp___8 != 0) {
#line 500
          _localArgv[1] = (char *)((void *)0);
#line 501
          localArgv = _localArgv;
        }
      }
    }
  }
#line 512
  if ((unsigned long )localArgv != (unsigned long )((char **)((void *)0))) {
    {
#line 514
    tmp___9 = DirName((char const   *)*(localArgv + 0));
#line 514
    execute = tmp___9;
    }
#line 519
    if ((unsigned long )execute != (unsigned long )((char *)((void *)0))) {
      {
#line 520
      search = AddSearch(search, (char const   *)execute);
#line 521
      free((void *)execute);
      }
    }
  }
#line 530
  return (search);
}
}
#line 533 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
char *FindPath(char const   *file , int mode ) 
{ 
  char *SearchPath ;
  char *Name ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 544
  SearchPath = DirName(file);
#line 548
  SearchPath = AddSearchArgv(SearchPath);
#line 552
  SearchPath = AddSearch(SearchPath, DefaultPath);
#line 556
  tmp = getenv("DPTPATH");
#line 556
  SearchPath = AddSearch(SearchPath, (char const   *)tmp);
#line 560
  tmp___0 = getenv("PATH");
#line 560
  SearchPath = AddSearch(SearchPath, (char const   *)tmp___0);
#line 565
  Name = FindPathWithSearch(file, mode, (char const   *)SearchPath);
#line 566
  free((void *)SearchPath);
  }
#line 567
  if ((unsigned long )Name != (unsigned long )((char *)((void *)0))) {
#line 568
    return (Name);
  }
  {
#line 570
  Name = BaseName(file);
  }
#line 570
  if ((unsigned long )Name == (unsigned long )((char *)((void *)0))) {
#line 571
    return ((char *)((void *)0));
  }
  {
#line 574
  tmp___1 = fileAccess((char const   *)Name, mode);
  }
#line 574
  if (tmp___1 == 0) {
#line 578
    return (Name);
  }
  {
#line 580
  free((void *)Name);
  }
#line 584
  return ((char *)((void *)0));
}
}
#line 104
static char *Strcat___0(char *left , char const   *right ) ;
#line 105
static char *DirName___0(char const   *left ) ;
#line 106
static char *BaseName___0(char const   *left ) ;
#line 107
static int fileAccess___0(char const   *file , int mode ) ;
#line 108
static char *Strtok___0(char const   *string , char const   *sepset ) ;
#line 112 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char const   DefaultPath___0[76]  = 
#line 112
  {      (char const   )'.',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'d', 
        (char const   )'p',      (char const   )'t',      (char const   )':',      (char const   )'/', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'/', 
        (char const   )'S',      (char const   )'U',      (char const   )'N',      (char const   )'W', 
        (char const   )'h',      (char const   )'w',      (char const   )'r',      (char const   )'d', 
        (char const   )'g',      (char const   )':',      (char const   )'/',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'/',      (char const   )'S', 
        (char const   )'U',      (char const   )'N',      (char const   )'W',      (char const   )'h', 
        (char const   )'w',      (char const   )'r',      (char const   )'d',      (char const   )'c', 
        (char const   )':',      (char const   )'/',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'/',      (char const   )'d',      (char const   )'p', 
        (char const   )'t',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'p',      (char const   )'p',      (char const   )'/',      (char const   )'d', 
        (char const   )'p',      (char const   )'t',      (char const   )':',      (char const   )'/', 
        (char const   )'v',      (char const   )'a',      (char const   )'r',      (char const   )'/', 
        (char const   )'d',      (char const   )'p',      (char const   )'t',      (char const   )'\000'};
#line 113 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char const   Separator___0[2]  = {      (char const   )':',      (char const   )'\000'};
#line 114 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char DirectorySeparator___0[2]  = {      (char )'/',      (char )'\000'};
#line 133 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strcat___0(char *left , char const   *right ) 
{ 
  int zero ;
  unsigned int size ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 136
  zero = 0;
#line 139
  if ((unsigned long )right == (unsigned long )((char *)((void *)0))) {
#line 144
    return (left);
  } else
#line 139
  if ((int const   )*right == 0) {
#line 144
    return (left);
  } else {
#line 139
    zero = (unsigned long )left == (unsigned long )((char *)((void *)0));
#line 139
    if (zero) {
      {
#line 139
      tmp = strlen(right);
#line 139
      size = (unsigned int )(tmp + 1UL);
#line 139
      tmp___0 = malloc((size_t )size);
#line 139
      tmp___4 = tmp___0;
      }
    } else {
      {
#line 139
      tmp___1 = strlen((char const   *)left);
#line 139
      tmp___2 = strlen(right);
#line 139
      size = (unsigned int )((tmp___1 + tmp___2) + 1UL);
#line 139
      tmp___3 = realloc((void *)left, (size_t )size);
#line 139
      tmp___4 = tmp___3;
      }
    }
#line 139
    left = (char *)tmp___4;
#line 139
    if ((unsigned long )left == (unsigned long )((char *)((void *)0))) {
#line 144
      return (left);
    }
  }
#line 146
  if (zero) {
    {
#line 147
    memset((void *)left, 0, (size_t )size);
    }
  }
  {
#line 149
  tmp___5 = strcat((char */* __restrict  */)left, (char const   */* __restrict  */)right);
  }
#line 149
  return (tmp___5);
}
}
#line 153 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *DirName___0(char const   *left ) 
{ 
  char *retVal ;
  char *cp ;
  size_t tmp ;
  unsigned int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 158
  retVal = (char *)left;
#line 158
  if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
    {
#line 159
    tmp = strlen((char const   *)retVal);
#line 159
    cp = retVal + tmp;
    }
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      cp --;
#line 162
      if ((unsigned long )cp >= (unsigned long )left) {
#line 162
        if ((int )*cp != 47) {
#line 162
          if ((int )*cp != 92) {
#line 162
            if (! ((int )*cp != 58)) {
#line 162
              goto while_break;
            }
          } else {
#line 162
            goto while_break;
          }
        } else {
#line 162
          goto while_break;
        }
      } else {
#line 162
        goto while_break;
      }
#line 163
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 165
    if ((unsigned long )cp >= (unsigned long )left) {
#line 166
      DirectorySeparator___0[0] = *cp;
    }
#line 168
    size = (unsigned int )(cp - (char *)left) + 2U;
#line 168
    if (size <= 1U) {
#line 169
      return ((char *)((void *)0));
    }
    {
#line 171
    tmp___1 = malloc((size_t )size);
#line 171
    retVal = (char *)tmp___1;
    }
#line 171
    if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
      {
#line 172
      tmp___0 = memcpy((void */* __restrict  */)retVal, (void const   */* __restrict  */)left,
                       (size_t )(size - 1U));
#line 172
      *((char *)tmp___0 + (size - 1U)) = (char )'\000';
      }
    }
  }
#line 175
  return (retVal);
}
}
#line 179 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *BaseName___0(char const   *left ) 
{ 
  char *retVal ;
  unsigned int size ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 187
  retVal = (char *)left;
#line 187
  if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
    {
#line 189
    tmp = strlen((char const   *)retVal);
#line 189
    size = (unsigned int )tmp;
#line 189
    cp = retVal + size;
    }
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      cp --;
#line 191
      if ((unsigned long )cp >= (unsigned long )left) {
#line 191
        if ((int )*cp != 47) {
#line 191
          if ((int )*cp != 92) {
#line 191
            if (! ((int )*cp != 58)) {
#line 191
              goto while_break;
            }
          } else {
#line 191
            goto while_break;
          }
        } else {
#line 191
          goto while_break;
        }
      } else {
#line 191
        goto while_break;
      }
#line 192
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 194
    if ((unsigned long )cp >= (unsigned long )left) {
#line 195
      DirectorySeparator___0[0] = *cp;
    }
#line 197
    cp ++;
#line 197
    if (size <= (unsigned int )(cp - (char *)left)) {
#line 201
      return ((char *)((void *)0));
    }
    {
#line 203
    size -= (unsigned int )(cp - (char *)left) - 1U;
#line 204
    tmp___1 = malloc((size_t )size);
#line 204
    retVal = (char *)tmp___1;
    }
#line 204
    if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
      {
#line 205
      tmp___0 = memcpy((void */* __restrict  */)retVal, (void const   */* __restrict  */)cp,
                       (size_t )(size - 1U));
#line 205
      *((char *)tmp___0 + (size - 1U)) = (char )'\000';
      }
    }
  }
#line 211
  return (retVal);
}
}
#line 219 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static int fileAccess___0(char const   *file , int mode ) 
{ 
  struct __anonstruct_fileStat_28___0 fileStat ;
  int retVal ;
  int tmp ;

  {
  {
#line 229
  retVal = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& fileStat.s));
  }
#line 229
  if (retVal < 0) {
#line 230
    return (retVal);
  }
#line 236
  if (((fileStat.s.st_mode & 61440U) == 32768U) == 0) {
#line 237
    return (1);
  }
  {
#line 239
  tmp = access(file, mode);
  }
#line 239
  return (tmp);
}
}
#line 254 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *savept___0  ;
#line 255 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *hold___0  ;
#line 250 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strtok___0(char const   *string , char const   *sepset ) 
{ 
  register char *p ;
  register char *q ;
  register char *r ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 257
  if ((unsigned long )hold___0 != (unsigned long )((void *)0)) {
    {
#line 258
    free((void *)hold___0);
#line 259
    hold___0 = (char *)((void *)0);
    }
  }
#line 261
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 262
    p = savept___0;
  } else {
#line 264
    p = (char *)string;
  }
#line 265
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 266
    return ((char *)((void *)0));
  }
  {
#line 267
  tmp = strspn((char const   *)p, sepset);
#line 267
  q = p + tmp;
  }
#line 268
  if ((int )*q == 0) {
#line 269
    return ((char *)((void *)0));
  }
  {
#line 270
  r = strpbrk((char const   *)q, sepset);
  }
#line 270
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 271
    savept___0 = (char *)0;
  } else {
    {
#line 273
    tmp___0 = malloc((size_t )((unsigned int )(r - q) + 1U));
#line 273
    hold___0 = (char *)tmp___0;
    }
#line 274
    if (hold___0) {
      {
#line 275
      tmp___1 = strspn((char const   *)r, sepset);
#line 275
      p = r + tmp___1;
      }
#line 276
      if ((unsigned long )p > (unsigned long )r) {
#line 276
        savept___0 = p;
      } else {
#line 276
        savept___0 = r + 1;
      }
      {
#line 277
      memcpy((void */* __restrict  */)hold___0, (void const   */* __restrict  */)q,
             (size_t )((unsigned int )(r - q)));
#line 278
      *(hold___0 + (r - q)) = (char )'\000';
#line 279
      q = hold___0;
      }
    } else {
      {
#line 282
      *r = (char )'\000';
#line 283
      tmp___2 = strspn((char const   *)r, sepset);
#line 283
      p = r + tmp___2;
      }
#line 284
      if ((unsigned long )p > (unsigned long )r) {
#line 284
        p ++;
#line 284
        savept___0 = p;
      } else {
#line 284
        r ++;
#line 284
        savept___0 = r;
      }
    }
  }
#line 287
  return (q);
}
}
#line 426 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char _grep___0[14]  = 
#line 426
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'g',      (char )'r',      (char )'e', 
        (char )'p',      (char )'\000'};
#line 428 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char _ps___0[12]  = 
#line 428
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'p',      (char )'s',      (char )'\000'};
#line 433 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char command___0[16]  = 
#line 433
  {      (char )'%',      (char )'s',      (char )' ',      (char )'-', 
        (char )'l',      (char )'|',      (char )'%',      (char )'s', 
        (char )' ',      (char )'\'',      (char )' ',      (char )'%', 
        (char )'d',      (char )' ',      (char )'\'',      (char )'\000'};
#line 42 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char Lock___0[13]  = 
#line 42 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'%',      (char )'s',      (char )'.', 
        (char )'L',      (char )'O',      (char )'C',      (char )'K', 
        (char )'\000'};
#line 45 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char *getName___0(char *name ) 
{ 


  {
#line 50
  if (name) {
#line 51
    return (name);
  }
  {
#line 53
  name = strrchr((char const   *)*(Argv + 0), '/');
  }
#line 53
  if ((unsigned long )name != (unsigned long )((char *)((void *)0))) {
#line 54
    return (name);
  }
#line 56
  return (*(Argv + 0));
}
}
#line 70 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char Template___0[15]  = 
#line 70
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'%',      (char )'s',      (char )'.', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'\000'};
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufio.h"
IOBUF *OpenInputBuf(char **buf , int numbufs ) ;
#line 51
IOBUF *OpenOutputBuf(char **buf , int numbufs ) ;
#line 54
void putbufc(int c , IOBUF *iobuf ) ;
#line 55
int InputBufBit(IOBUF *iobuf ) ;
#line 56
unsigned long InputBufBits(IOBUF *iobuf , int bit_count ) ;
#line 57
void CloseInputBuf(IOBUF *iobuf ) ;
#line 58
void CloseOutputBuf(IOBUF *iobuf ) ;
#line 45 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
IOBUF *OpenOutputBuf(char **buf , int numbufs ) 
{ 
  IOBUF *iobuf ;
  int i ;
  void *tmp ;

  {
  {
#line 50
  tmp = calloc((size_t )1, sizeof(IOBUF ));
#line 50
  iobuf = (IOBUF *)tmp;
  }
#line 51
  if ((unsigned long )iobuf == (unsigned long )((void *)0)) {
#line 52
    return (iobuf);
  }
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < numbufs)) {
#line 53
      goto while_break;
    }
#line 53
    iobuf->buf[i] = *(buf + i);
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  iobuf->numbufs = numbufs;
#line 55
  iobuf->curbuf = 0;
#line 56
  iobuf->rack = 0;
#line 57
  iobuf->mask = (unsigned char)1;
#line 58
  iobuf->bufptr = 0L;
#line 59
  return (iobuf);
}
}
#line 62 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
IOBUF *OpenInputBuf(char **buf , int numbufs ) 
{ 
  IOBUF *iobuf ;
  int i ;
  void *tmp ;

  {
  {
#line 67
  tmp = calloc((size_t )1, sizeof(IOBUF ));
#line 67
  iobuf = (IOBUF *)tmp;
  }
#line 68
  if ((unsigned long )iobuf == (unsigned long )((void *)0)) {
#line 69
    return (iobuf);
  }
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < numbufs)) {
#line 70
      goto while_break;
    }
#line 70
    iobuf->buf[i] = *(buf + i);
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  iobuf->numbufs = numbufs;
#line 72
  iobuf->curbuf = 0;
#line 73
  iobuf->rack = 0;
#line 74
  iobuf->mask = (unsigned char)1;
#line 75
  iobuf->bufptr = 0L;
#line 76
  return (iobuf);
}
}
#line 79 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
void CloseOutputBuf(IOBUF *iobuf ) 
{ 


  {
#line 81
  if ((int )iobuf->mask != 1) {
    {
#line 82
    putbufc(iobuf->rack, iobuf);
    }
  }
  {
#line 83
  free((void *)((char *)iobuf));
  }
#line 84
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
void CloseInputBuf(IOBUF *iobuf ) 
{ 


  {
  {
#line 88
  free((void *)((char *)iobuf));
  }
#line 89
  return;
}
}
#line 91 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
void putbufc(int c , IOBUF *iobuf ) 
{ 
  long tmp ;

  {
#line 93
  tmp = iobuf->bufptr;
#line 93
  (iobuf->bufptr) ++;
#line 93
  *(iobuf->buf[iobuf->curbuf] + tmp) = (char )c;
#line 94
  if (iobuf->bufptr == 64512L) {
#line 96
    (iobuf->curbuf) ++;
#line 97
    iobuf->bufptr = 0L;
  }
#line 99
  return;
}
}
#line 122 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
int InputBufBit(IOBUF *iobuf ) 
{ 
  int value ;
  long tmp ;
  int tmp___0 ;

  {
#line 126
  if ((int )iobuf->mask == 1) {
#line 128
    tmp = iobuf->bufptr;
#line 128
    (iobuf->bufptr) ++;
#line 128
    iobuf->rack = (int )*(iobuf->buf[iobuf->curbuf] + tmp);
#line 129
    if (iobuf->bufptr == 64512L) {
#line 131
      (iobuf->curbuf) ++;
#line 132
      iobuf->bufptr = 0L;
    }
  }
#line 135
  value = iobuf->rack & (int )iobuf->mask;
#line 136
  iobuf->mask = (unsigned char )((int )iobuf->mask << 1);
#line 137
  if ((int )iobuf->mask == 0) {
#line 138
    iobuf->mask = (unsigned char)1;
  }
#line 139
  if (value) {
#line 139
    tmp___0 = 1;
  } else {
#line 139
    tmp___0 = 0;
  }
#line 139
  return (tmp___0);
}
}
#line 168 "/home/wheatley/newnew/temp/raidutils-0.0.6/raidutil/bufiolsb.c"
unsigned long InputBufBits(IOBUF *iobuf , int bit_count ) 
{ 
  unsigned long mask ;
  unsigned long return_value ;
  long tmp ;
  int tmp___0 ;

  {
#line 173
  mask = 1UL;
#line 174
  return_value = 0UL;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    tmp___0 = bit_count;
#line 175
    bit_count --;
#line 175
    if (! (tmp___0 > 0)) {
#line 175
      goto while_break;
    }
#line 177
    if ((int )iobuf->mask == 1) {
#line 179
      tmp = iobuf->bufptr;
#line 179
      (iobuf->bufptr) ++;
#line 179
      iobuf->rack = (int )*(iobuf->buf[iobuf->curbuf] + tmp);
#line 180
      if (iobuf->bufptr == 64512L) {
#line 182
        (iobuf->curbuf) ++;
#line 183
        iobuf->bufptr = 0L;
      }
    }
#line 189
    if (iobuf->rack & (int )iobuf->mask) {
#line 190
      return_value |= mask;
    }
#line 191
    mask <<= 1;
#line 192
    iobuf->mask = (unsigned char )((int )iobuf->mask << 1);
#line 193
    if ((int )iobuf->mask == 0) {
#line 194
      iobuf->mask = (unsigned char)1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (return_value);
}
}
#line 104 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strcat___1(char *left , char const   *right ) ;
#line 105
static char *DirName___1(char const   *left ) ;
#line 106
static char *BaseName___1(char const   *left ) ;
#line 107
static int fileAccess___1(char const   *file , int mode ) ;
#line 108
static char *Strtok___1(char const   *string , char const   *sepset ) ;
#line 112 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char const   DefaultPath___1[76]  = 
#line 112
  {      (char const   )'.',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'d', 
        (char const   )'p',      (char const   )'t',      (char const   )':',      (char const   )'/', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'/', 
        (char const   )'S',      (char const   )'U',      (char const   )'N',      (char const   )'W', 
        (char const   )'h',      (char const   )'w',      (char const   )'r',      (char const   )'d', 
        (char const   )'g',      (char const   )':',      (char const   )'/',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'/',      (char const   )'S', 
        (char const   )'U',      (char const   )'N',      (char const   )'W',      (char const   )'h', 
        (char const   )'w',      (char const   )'r',      (char const   )'d',      (char const   )'c', 
        (char const   )':',      (char const   )'/',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'/',      (char const   )'d',      (char const   )'p', 
        (char const   )'t',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'p',      (char const   )'p',      (char const   )'/',      (char const   )'d', 
        (char const   )'p',      (char const   )'t',      (char const   )':',      (char const   )'/', 
        (char const   )'v',      (char const   )'a',      (char const   )'r',      (char const   )'/', 
        (char const   )'d',      (char const   )'p',      (char const   )'t',      (char const   )'\000'};
#line 113 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char const   Separator___1[2]  = {      (char const   )':',      (char const   )'\000'};
#line 114 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char DirectorySeparator___1[2]  = {      (char )'/',      (char )'\000'};
#line 133 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strcat___1(char *left , char const   *right ) 
{ 
  int zero ;
  unsigned int size ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 136
  zero = 0;
#line 139
  if ((unsigned long )right == (unsigned long )((char *)((void *)0))) {
#line 144
    return (left);
  } else
#line 139
  if ((int const   )*right == 0) {
#line 144
    return (left);
  } else {
#line 139
    zero = (unsigned long )left == (unsigned long )((char *)((void *)0));
#line 139
    if (zero) {
      {
#line 139
      tmp = strlen(right);
#line 139
      size = (unsigned int )(tmp + 1UL);
#line 139
      tmp___0 = malloc((size_t )size);
#line 139
      tmp___4 = tmp___0;
      }
    } else {
      {
#line 139
      tmp___1 = strlen((char const   *)left);
#line 139
      tmp___2 = strlen(right);
#line 139
      size = (unsigned int )((tmp___1 + tmp___2) + 1UL);
#line 139
      tmp___3 = realloc((void *)left, (size_t )size);
#line 139
      tmp___4 = tmp___3;
      }
    }
#line 139
    left = (char *)tmp___4;
#line 139
    if ((unsigned long )left == (unsigned long )((char *)((void *)0))) {
#line 144
      return (left);
    }
  }
#line 146
  if (zero) {
    {
#line 147
    memset((void *)left, 0, (size_t )size);
    }
  }
  {
#line 149
  tmp___5 = strcat((char */* __restrict  */)left, (char const   */* __restrict  */)right);
  }
#line 149
  return (tmp___5);
}
}
#line 153 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *DirName___1(char const   *left ) 
{ 
  char *retVal ;
  char *cp ;
  size_t tmp ;
  unsigned int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 158
  retVal = (char *)left;
#line 158
  if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
    {
#line 159
    tmp = strlen((char const   *)retVal);
#line 159
    cp = retVal + tmp;
    }
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      cp --;
#line 162
      if ((unsigned long )cp >= (unsigned long )left) {
#line 162
        if ((int )*cp != 47) {
#line 162
          if ((int )*cp != 92) {
#line 162
            if (! ((int )*cp != 58)) {
#line 162
              goto while_break;
            }
          } else {
#line 162
            goto while_break;
          }
        } else {
#line 162
          goto while_break;
        }
      } else {
#line 162
        goto while_break;
      }
#line 163
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 165
    if ((unsigned long )cp >= (unsigned long )left) {
#line 166
      DirectorySeparator___1[0] = *cp;
    }
#line 168
    size = (unsigned int )(cp - (char *)left) + 2U;
#line 168
    if (size <= 1U) {
#line 169
      return ((char *)((void *)0));
    }
    {
#line 171
    tmp___1 = malloc((size_t )size);
#line 171
    retVal = (char *)tmp___1;
    }
#line 171
    if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
      {
#line 172
      tmp___0 = memcpy((void */* __restrict  */)retVal, (void const   */* __restrict  */)left,
                       (size_t )(size - 1U));
#line 172
      *((char *)tmp___0 + (size - 1U)) = (char )'\000';
      }
    }
  }
#line 175
  return (retVal);
}
}
#line 179 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *BaseName___1(char const   *left ) 
{ 
  char *retVal ;
  unsigned int size ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 187
  retVal = (char *)left;
#line 187
  if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
    {
#line 189
    tmp = strlen((char const   *)retVal);
#line 189
    size = (unsigned int )tmp;
#line 189
    cp = retVal + size;
    }
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      cp --;
#line 191
      if ((unsigned long )cp >= (unsigned long )left) {
#line 191
        if ((int )*cp != 47) {
#line 191
          if ((int )*cp != 92) {
#line 191
            if (! ((int )*cp != 58)) {
#line 191
              goto while_break;
            }
          } else {
#line 191
            goto while_break;
          }
        } else {
#line 191
          goto while_break;
        }
      } else {
#line 191
        goto while_break;
      }
#line 192
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
#line 194
    if ((unsigned long )cp >= (unsigned long )left) {
#line 195
      DirectorySeparator___1[0] = *cp;
    }
#line 197
    cp ++;
#line 197
    if (size <= (unsigned int )(cp - (char *)left)) {
#line 201
      return ((char *)((void *)0));
    }
    {
#line 203
    size -= (unsigned int )(cp - (char *)left) - 1U;
#line 204
    tmp___1 = malloc((size_t )size);
#line 204
    retVal = (char *)tmp___1;
    }
#line 204
    if ((unsigned long )retVal != (unsigned long )((char *)((void *)0))) {
      {
#line 205
      tmp___0 = memcpy((void */* __restrict  */)retVal, (void const   */* __restrict  */)cp,
                       (size_t )(size - 1U));
#line 205
      *((char *)tmp___0 + (size - 1U)) = (char )'\000';
      }
    }
  }
#line 211
  return (retVal);
}
}
#line 219 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static int fileAccess___1(char const   *file , int mode ) 
{ 
  struct __anonstruct_fileStat_28___1 fileStat ;
  int retVal ;
  int tmp ;

  {
  {
#line 229
  retVal = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& fileStat.s));
  }
#line 229
  if (retVal < 0) {
#line 230
    return (retVal);
  }
#line 236
  if (((fileStat.s.st_mode & 61440U) == 32768U) == 0) {
#line 237
    return (1);
  }
  {
#line 239
  tmp = access(file, mode);
  }
#line 239
  return (tmp);
}
}
#line 254 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *savept___1  ;
#line 255 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *hold___1  ;
#line 250 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char *Strtok___1(char const   *string , char const   *sepset ) 
{ 
  register char *p ;
  register char *q ;
  register char *r ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 257
  if ((unsigned long )hold___1 != (unsigned long )((void *)0)) {
    {
#line 258
    free((void *)hold___1);
#line 259
    hold___1 = (char *)((void *)0);
    }
  }
#line 261
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 262
    p = savept___1;
  } else {
#line 264
    p = (char *)string;
  }
#line 265
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 266
    return ((char *)((void *)0));
  }
  {
#line 267
  tmp = strspn((char const   *)p, sepset);
#line 267
  q = p + tmp;
  }
#line 268
  if ((int )*q == 0) {
#line 269
    return ((char *)((void *)0));
  }
  {
#line 270
  r = strpbrk((char const   *)q, sepset);
  }
#line 270
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 271
    savept___1 = (char *)0;
  } else {
    {
#line 273
    tmp___0 = malloc((size_t )((unsigned int )(r - q) + 1U));
#line 273
    hold___1 = (char *)tmp___0;
    }
#line 274
    if (hold___1) {
      {
#line 275
      tmp___1 = strspn((char const   *)r, sepset);
#line 275
      p = r + tmp___1;
      }
#line 276
      if ((unsigned long )p > (unsigned long )r) {
#line 276
        savept___1 = p;
      } else {
#line 276
        savept___1 = r + 1;
      }
      {
#line 277
      memcpy((void */* __restrict  */)hold___1, (void const   */* __restrict  */)q,
             (size_t )((unsigned int )(r - q)));
#line 278
      *(hold___1 + (r - q)) = (char )'\000';
#line 279
      q = hold___1;
      }
    } else {
      {
#line 282
      *r = (char )'\000';
#line 283
      tmp___2 = strspn((char const   *)r, sepset);
#line 283
      p = r + tmp___2;
      }
#line 284
      if ((unsigned long )p > (unsigned long )r) {
#line 284
        p ++;
#line 284
        savept___1 = p;
      } else {
#line 284
        r ++;
#line 284
        savept___1 = r;
      }
    }
  }
#line 287
  return (q);
}
}
#line 426 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char _grep___1[14]  = 
#line 426
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'g',      (char )'r',      (char )'e', 
        (char )'p',      (char )'\000'};
#line 428 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char _ps___1[12]  = 
#line 428
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'/',      (char )'p',      (char )'s',      (char )'\000'};
#line 433 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/findpath.c"
static char command___1[16]  = 
#line 433
  {      (char )'%',      (char )'s',      (char )' ',      (char )'-', 
        (char )'l',      (char )'|',      (char )'%',      (char )'s', 
        (char )' ',      (char )'\'',      (char )' ',      (char )'%', 
        (char )'d',      (char )' ',      (char )'\'',      (char )'\000'};
#line 42 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char Lock___1[13]  = 
#line 42 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'%',      (char )'s',      (char )'.', 
        (char )'L',      (char )'O',      (char )'C',      (char )'K', 
        (char )'\000'};
#line 45 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char *getName___1(char *name ) 
{ 


  {
#line 50
  if (name) {
#line 51
    return (name);
  }
  {
#line 53
  name = strrchr((char const   *)*(Argv + 0), '/');
  }
#line 53
  if ((unsigned long )name != (unsigned long )((char *)((void *)0))) {
#line 54
    return (name);
  }
#line 56
  return (*(Argv + 0));
}
}
#line 70 "/home/wheatley/newnew/temp/raidutils-0.0.6/lib/lockunix.c"
static char Template___1[15]  = 
#line 70
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'%',      (char )'s',      (char )'.', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'\000'};
