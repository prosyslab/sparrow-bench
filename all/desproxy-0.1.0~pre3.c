/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
struct request {
   unsigned char buffer[512] ;
   unsigned short size ;
   unsigned short bib ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.h"
int debug_printf(char const   *fmt  , ...) ;
#line 60
void mark_all_client_sockets_as_free(void) ;
#line 86
void print_program_version(char *PROGRAM_NAME , char *PROGRAM_VERSION ) ;
#line 123
int connect_host_to_proxy(int connection , char *remote_host___0 , char *remote_port___0 ) ;
#line 131
void initialize_gettext(void) ;
#line 138
int listen_in_TCP_port(unsigned int request_port ) ;
#line 145
int bind_UDP_port(unsigned int request_port ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int status  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int fd  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int maxfd  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int client_socket[10]  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int proxy_socket[10]  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int connection_status[10]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char *proxy_host  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char *proxy_port  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char *dns_server  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char *local_port  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char username[256]  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char password[256]  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char console_line[256]  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char HTTP_return_code[4]  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
char string[256]  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
unsigned char buffer[1500]  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
unsigned char client_socket_is_free[10]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
fd_set mask  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
fd_set rmask  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
struct sockaddr_in proxy  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
struct hostent *proxy_hostent  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
struct sockaddr_in server  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
struct sockaddr_in client  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
struct sockaddr_in remote  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
struct termios old_tty  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
unsigned int client_length  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int server_length  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int proxy_length  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.h"
int remote_length  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
char UDP_buffer[512]  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
int request_socket  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
struct request requests[10]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
void EOC_dns(int connection ) 
{ 


  {
  {
#line 40
  debug_printf(">EOC_dns(%d)\n", connection);
  }
#line 41
  if (connection != 9) {
    {
#line 43
    mask.__fds_bits[client_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << client_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 44
    rmask.__fds_bits[client_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << client_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 45
    close(client_socket[connection]);
    }
  }
  {
#line 47
  mask.__fds_bits[proxy_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << proxy_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 48
  rmask.__fds_bits[proxy_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << proxy_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 49
  close(proxy_socket[connection]);
#line 50
  client_socket_is_free[connection] = (unsigned char)1;
#line 51
  debug_printf("EOC_dns>\n");
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
int answer_request(int connection , int size ) 
{ 
  int count ;
  int htons_size ;
  char buffer___0[514] ;
  unsigned short *ptr ;
  uint16_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  uint16_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;

  {
  {
#line 62
  debug_printf(">answer_request(%d,%d)\n", connection, size);
  }
#line 63
  if (connection == 9) {
    {
#line 65
    memcpy((void */* __restrict  */)(& buffer___0[2]), (void const   */* __restrict  */)(UDP_buffer),
           (size_t )size);
#line 66
    tmp = htons((uint16_t )size);
#line 66
    htons_size = (int )tmp;
#line 67
    memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)(& htons_size),
           (size_t )2);
#line 68
    debug_printf("UDP\n");
    }
  } else {
    {
#line 72
    memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)(requests[connection].buffer),
           (size_t )(size + 2));
#line 73
    debug_printf("TCP\n");
    }
  }
  {
#line 76
  debug_printf("proxy_host %s\n", proxy_host);
#line 77
  debug_printf("proxy_port %s\n", proxy_port);
#line 78
  tmp___0 = connect_host_to_proxy(connection, dns_server, (char *)"53");
  }
#line 78
  if (tmp___0 != 0) {
    {
#line 80
    printf((char const   */* __restrict  */)"connect_host_to_proxy: ERROR\n");
    }
#line 81
    return (-1);
  }
  {
#line 84
  tmp___1 = write(proxy_socket[connection], (void const   *)(buffer___0), (size_t )(size + 2));
#line 84
  count = (int )tmp___1;
  }
#line 84
  if (count == -1) {
    {
#line 86
    perror("write");
    }
#line 87
    return (-2);
  }
  {
#line 89
  debug_printf("#BEGIN OF REQUEST#");
#line 95
  debug_printf("#END OF REQUEST#");
#line 96
  debug_printf("LOCAL->PROXY(%d)\n", count);
#line 97
  tmp___2 = read(proxy_socket[connection], (void *)(buffer___0), (size_t )2);
#line 97
  count = (int )tmp___2;
  }
#line 97
  if (count == -1) {
    {
#line 99
    perror("read");
    }
#line 100
    return (-3);
  }
  {
#line 102
  ptr = (unsigned short *)(buffer___0);
#line 103
  tmp___3 = ntohs(*ptr);
#line 103
  size = (int )tmp___3;
#line 104
  debug_printf("size=%d\n", size);
#line 105
  tmp___4 = read(proxy_socket[connection], (void *)(& buffer___0[2]), (size_t )size);
#line 105
  count = (int )tmp___4;
  }
#line 105
  if (count == -1) {
    {
#line 107
    perror("write");
    }
#line 108
    return (-4);
  }
  {
#line 110
  debug_printf("PROXY->LOCAL(%d)\n", count);
  }
#line 111
  if (connection == 9) {
    {
#line 115
    tmp___5 = sendto(client_socket[connection], (void const   *)(& buffer___0[2]),
                     (size_t )size, 0, (struct sockaddr  const  *)((struct sockaddr *)(& client)),
                     client_length);
#line 115
    count = (int )tmp___5;
    }
#line 115
    if (count != size) {
      {
#line 119
      perror("sendto");
      }
#line 120
      return (-5);
    }
  } else {
    {
#line 125
    tmp___6 = write(client_socket[connection], (void const   *)(buffer___0), (size_t )(size + 2));
#line 125
    count = (int )tmp___6;
    }
#line 125
    if (count == -1) {
      {
#line 127
      perror("write");
      }
#line 128
      return (-6);
    }
  }
  {
#line 131
  debug_printf("LOCAL->CLIENT(%d)\n", count);
#line 132
  debug_printf("answer_request>\n");
  }
#line 133
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
void parse_command_line(int argc , char **argv ) 
{ 
  char *tmp ;

  {
  {
#line 139
  debug_printf(">parse_command_line(COMMAND_LINE)\n");
  }
#line 140
  if (argc != 4) {
    {
#line 142
    tmp = gettext("Usage: desproxy-dns dns_server proxy_host proxy_port\n\n");
#line 142
    printf((char const   */* __restrict  */)tmp);
#line 144
    exit(1);
    }
  }
  {
#line 146
  dns_server = *(argv + 1);
#line 147
  proxy_host = *(argv + 2);
#line 148
  proxy_port = *(argv + 3);
#line 149
  debug_printf("parse_command_line>\n");
  }
#line 150
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
void process_connection_request(void) 
{ 
  int connection ;
  char *tmp ;
  uint16_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 157
  debug_printf(">process_connection_request()\n");
#line 158
  connection = 0;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (connection < 9)) {
#line 158
      goto while_break;
    }
#line 159
    if (client_socket_is_free[connection]) {
#line 160
      goto while_break;
    }
#line 158
    connection ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (connection == 9) {
    {
#line 163
    tmp = gettext("There are no connections available at this time\n");
#line 163
    printf((char const   */* __restrict  */)tmp);
    }
  } else {
    {
#line 167
    client_length = (unsigned int )sizeof(client);
#line 168
    client_socket[connection] = accept(request_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& client)),
                                       (socklen_t */* __restrict  */)(& client_length));
    }
#line 170
    if (client_socket[connection] < 0) {
      {
#line 172
      perror("accept");
#line 173
      EOC_dns(connection);
      }
#line 174
      return;
    }
    {
#line 176
    client_socket_is_free[connection] = (unsigned char)0;
#line 177
    tmp___0 = ntohs(client.sin_port);
#line 177
    tmp___1 = inet_ntoa(client.sin_addr);
#line 177
    tmp___2 = gettext("TCP request from %s, port %d\n");
#line 177
    printf((char const   */* __restrict  */)tmp___2, tmp___1, (int )tmp___0);
    }
#line 179
    if (client_socket[connection] > maxfd) {
#line 180
      maxfd = client_socket[connection];
    }
#line 181
    mask.__fds_bits[client_socket[connection] / (8 * (int )sizeof(__fd_mask ))] |= 1L << client_socket[connection] % (8 * (int )sizeof(__fd_mask ));
#line 182
    requests[connection].bib = (unsigned short)0;
  }
  {
#line 184
  debug_printf("process_connection_request>\n");
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-dns.c"
int main(int argc , char **argv ) 
{ 
  int connection ;
  int nfound ;
  int count ;
  struct timeval timeout ;
  int tmp ;
  char *tmp___0 ;
  int __d0 ;
  int __d1 ;
  char *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  unsigned short *ptr ;
  int tmp___4 ;
  int *tmp___5 ;
  uint16_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;

  {
  {
#line 195
  signal(13, (void (*)(int  ))1);
#line 196
  initialize_gettext();
#line 197
  print_program_version((char *)"desproxy-dns", (char *)"0.1.0-pre3");
#line 198
  parse_command_line(argc, argv);
#line 200
  request_socket = listen_in_TCP_port(53U);
#line 201
  client_socket[9] = bind_UDP_port(53U);
#line 203
  tmp = fcntl(client_socket[9], 4, 2048);
  }
#line 203
  if (tmp < 0) {
    {
#line 205
    perror("fnctl");
#line 206
    exit(1);
    }
  }
  {
#line 209
  tmp___0 = gettext("Press <Control+C> to Quit\n\n");
#line 209
  printf((char const   */* __restrict  */)tmp___0);
#line 210
  mark_all_client_sockets_as_free();
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& mask.__fds_bits[0]): "memory");
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  mask.__fds_bits[request_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << request_socket % (8 * (int )sizeof(__fd_mask ));
#line 214
  maxfd = request_socket;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 217
    rmask = mask;
#line 218
    timeout.tv_sec = (__time_t )0;
#line 219
    timeout.tv_usec = (__suseconds_t )500000;
#line 220
    nfound = select(maxfd + 1, (fd_set */* __restrict  */)(& rmask), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
#line 221
    debug_printf("nfound> (%d)\n", nfound);
    }
#line 222
    if (nfound < 0) {
      {
#line 224
      tmp___2 = __errno_location();
      }
#line 224
      if (*tmp___2 == 4) {
        {
#line 226
        tmp___1 = gettext("Interrupted by system call\n");
#line 226
        printf((char const   */* __restrict  */)tmp___1);
        }
#line 227
        goto while_continue___0;
      }
      {
#line 229
      perror("select");
#line 230
      exit(1);
      }
    }
#line 233
    if ((rmask.__fds_bits[request_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << request_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 235
      process_connection_request();
      }
    }
#line 238
    connection = 0;
    {
#line 238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 238
      if (! (connection < 9)) {
#line 238
        goto while_break___1;
      }
#line 240
      if (! client_socket_is_free[connection]) {
        {
#line 242
        debug_printf("client_socket_is_free[%d]=1\n", connection);
        }
#line 243
        if ((rmask.__fds_bits[client_socket[connection] / (8 * (int )sizeof(__fd_mask ))] & (1L << client_socket[connection] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 245
          tmp___3 = read(client_socket[connection], (void *)(buffer), (size_t )1500);
#line 245
          count = (int )tmp___3;
          }
#line 245
          if (count == -1) {
            {
#line 249
            perror("read");
#line 250
            exit(1);
            }
          }
#line 252
          if (count == 0) {
            {
#line 253
            EOC_dns(connection);
            }
          } else {
            {
#line 256
            memcpy((void */* __restrict  */)(& requests[connection].buffer[requests[connection].bib]),
                   (void const   */* __restrict  */)(buffer), (size_t )count);
#line 259
            requests[connection].bib = (unsigned short )((int )requests[connection].bib + count);
            }
#line 261
            if ((int )requests[connection].bib > 2) {
              {
#line 263
              ptr = (unsigned short *)(& requests[connection].buffer[0]);
#line 264
              requests[connection].size = htons(*ptr);
              }
#line 265
              if ((int )requests[connection].size == (int )requests[connection].bib - 2) {
                {
#line 268
                tmp___4 = answer_request(connection, (int )requests[connection].size);
                }
#line 268
                if (tmp___4 < 0) {
                  {
#line 271
                  EOC_dns(connection);
                  }
                }
              }
            }
          }
        }
      }
#line 238
      connection ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 280
    client_length = (unsigned int )sizeof(client);
#line 281
    memset((void *)(& client), 0, sizeof(client));
#line 282
    tmp___9 = recvfrom(client_socket[9], (void */* __restrict  */)(UDP_buffer), (size_t )512,
                       0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& client)),
                       (socklen_t */* __restrict  */)(& client_length));
#line 282
    count = (int )tmp___9;
    }
#line 282
    if (count < 1) {
      {
#line 284
      tmp___5 = __errno_location();
      }
#line 284
      if (*tmp___5 != 11) {
        {
#line 286
        perror("recvfrom");
#line 287
        exit(1);
        }
      }
    } else {
      {
#line 292
      tmp___6 = ntohs(client.sin_port);
#line 292
      tmp___7 = inet_ntoa(client.sin_addr);
#line 292
      tmp___8 = gettext("UDP request from %s, port %d\n");
#line 292
      printf((char const   */* __restrict  */)tmp___8, tmp___7, (int )tmp___6);
#line 294
      answer_request(9, count);
#line 296
      EOC_dns(9);
      }
    }
    {
#line 299
    fflush(stdout);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 301
  exit(0);
  }
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.h"
char *get_console_line(void) ;
#line 45
void strtolower(char *string___0 ) ;
#line 52
void EOC(int connection ) ;
#line 69
void strnsend(int fd___0 , char *string___0 , int len ) ;
#line 77
void strsend(int fd___0 , char *string___0 ) ;
#line 94
char *parse_HTTP_return_code(void) ;
#line 103
int wait_for_crlf(int fd___0 ) ;
#line 112
int wait_for_2crlf(int fd___0 ) ;
#line 153
void print_connection(int connection , char *string___0 ) ;
#line 159
int look_for_desproxy_conf(void) ;
#line 167
void get_username_and_password(void) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
static void base64_encode(char const   *s , char *p ) 
{ 
  char base64[65] ;
  int i ;
  int length ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
  {
#line 26
  base64[0] = (char )'A';
#line 26
  base64[1] = (char )'B';
#line 26
  base64[2] = (char )'C';
#line 26
  base64[3] = (char )'D';
#line 26
  base64[4] = (char )'E';
#line 26
  base64[5] = (char )'F';
#line 26
  base64[6] = (char )'G';
#line 26
  base64[7] = (char )'H';
#line 26
  base64[8] = (char )'I';
#line 26
  base64[9] = (char )'J';
#line 26
  base64[10] = (char )'K';
#line 26
  base64[11] = (char )'L';
#line 26
  base64[12] = (char )'M';
#line 26
  base64[13] = (char )'N';
#line 26
  base64[14] = (char )'O';
#line 26
  base64[15] = (char )'P';
#line 26
  base64[16] = (char )'Q';
#line 26
  base64[17] = (char )'R';
#line 26
  base64[18] = (char )'S';
#line 26
  base64[19] = (char )'T';
#line 26
  base64[20] = (char )'U';
#line 26
  base64[21] = (char )'V';
#line 26
  base64[22] = (char )'W';
#line 26
  base64[23] = (char )'X';
#line 26
  base64[24] = (char )'Y';
#line 26
  base64[25] = (char )'Z';
#line 26
  base64[26] = (char )'a';
#line 26
  base64[27] = (char )'b';
#line 26
  base64[28] = (char )'c';
#line 26
  base64[29] = (char )'d';
#line 26
  base64[30] = (char )'e';
#line 26
  base64[31] = (char )'f';
#line 26
  base64[32] = (char )'g';
#line 26
  base64[33] = (char )'h';
#line 26
  base64[34] = (char )'i';
#line 26
  base64[35] = (char )'j';
#line 26
  base64[36] = (char )'k';
#line 26
  base64[37] = (char )'l';
#line 26
  base64[38] = (char )'m';
#line 26
  base64[39] = (char )'n';
#line 26
  base64[40] = (char )'o';
#line 26
  base64[41] = (char )'p';
#line 26
  base64[42] = (char )'q';
#line 26
  base64[43] = (char )'r';
#line 26
  base64[44] = (char )'s';
#line 26
  base64[45] = (char )'t';
#line 26
  base64[46] = (char )'u';
#line 26
  base64[47] = (char )'v';
#line 26
  base64[48] = (char )'w';
#line 26
  base64[49] = (char )'x';
#line 26
  base64[50] = (char )'y';
#line 26
  base64[51] = (char )'z';
#line 26
  base64[52] = (char )'0';
#line 26
  base64[53] = (char )'1';
#line 26
  base64[54] = (char )'2';
#line 26
  base64[55] = (char )'3';
#line 26
  base64[56] = (char )'4';
#line 26
  base64[57] = (char )'5';
#line 26
  base64[58] = (char )'6';
#line 26
  base64[59] = (char )'7';
#line 26
  base64[60] = (char )'8';
#line 26
  base64[61] = (char )'9';
#line 26
  base64[62] = (char )'+';
#line 26
  base64[63] = (char )'/';
#line 26
  base64[64] = (char )'\000';
#line 30
  tmp = strlen(s);
#line 30
  length = (int )tmp;
#line 31
  i = 0;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < length)) {
#line 31
      goto while_break;
    }
#line 33
    tmp___0 = p;
#line 33
    p ++;
#line 33
    *tmp___0 = base64[(int const   )*(s + 0) >> 2];
#line 34
    tmp___1 = p;
#line 34
    p ++;
#line 34
    *tmp___1 = base64[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 35
    tmp___2 = p;
#line 35
    p ++;
#line 35
    *tmp___2 = base64[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 36
    tmp___3 = p;
#line 36
    p ++;
#line 36
    *tmp___3 = base64[(int const   )*(s + 2) & 63];
#line 37
    s += 3;
#line 31
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (i == length + 1) {
#line 40
    *(p - 1) = (char )'=';
  } else
#line 41
  if (i == length + 2) {
#line 42
    tmp___4 = (char )'=';
#line 42
    *(p - 2) = tmp___4;
#line 42
    *(p - 1) = tmp___4;
  }
#line 43
  *p = (char )'\000';
#line 44
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int debug_printf(char const   *fmt  , ...) 
{ 


  {
#line 69
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
char *get_console_line(void) 
{ 
  int count ;
  size_t tmp ;

  {
  {
#line 82
  fgets((char */* __restrict  */)(console_line), 256, (FILE */* __restrict  */)stdin);
#line 83
  count = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 83
    tmp = strlen((char const   *)(console_line));
    }
#line 83
    if (! ((size_t )count < tmp)) {
#line 83
      goto while_break;
    }
#line 84
    if ((int )console_line[count] < 32) {
#line 85
      console_line[count] = (char)0;
    }
#line 83
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (console_line);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void strtolower(char *string___0 ) 
{ 
  int count ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 99
  count = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp___0 = strlen((char const   *)string___0);
    }
#line 99
    if (! ((size_t )count < tmp___0)) {
#line 99
      goto while_break;
    }
    {
#line 101
    tmp = tolower((int )*(string___0 + count));
#line 101
    *(string___0 + count) = (char )tmp;
#line 99
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void print_connection(int connection , char *string___0 ) 
{ 
  char *tmp ;

  {
  {
#line 114
  tmp = gettext("Connection");
#line 114
  printf((char const   */* __restrict  */)tmp);
#line 115
  printf((char const   */* __restrict  */)" #%d: %s", connection, string___0);
  }
#line 116
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void EOC(int connection ) 
{ 
  char *tmp ;

  {
  {
#line 126
  debug_printf(">EOC(%d)\n", connection);
#line 127
  debug_printf("connection_status[%d]=%d\n", connection, connection_status[connection]);
#line 130
  client_socket_is_free[connection] = (unsigned char)1;
#line 131
  mask.__fds_bits[client_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << client_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 132
  rmask.__fds_bits[client_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << client_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 133
  close(client_socket[connection]);
  }
#line 135
  if (connection_status[connection] == 1) {
    {
#line 137
    debug_printf("connection_status[connection] == BICONNECTED\n");
#line 139
    mask.__fds_bits[proxy_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << proxy_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 140
    rmask.__fds_bits[proxy_socket[connection] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << proxy_socket[connection] % (8 * (int )sizeof(__fd_mask )));
#line 141
    close(proxy_socket[connection]);
    }
  }
  {
#line 143
  connection_status[connection] = 11;
#line 144
  tmp = gettext("end of connection\n");
#line 144
  print_connection(connection, tmp);
#line 146
  debug_printf("EOC>\n");
  }
#line 147
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void mark_all_client_sockets_as_free(void) 
{ 
  int connection ;

  {
  {
#line 159
  debug_printf(">mark_all_client_sockets_as_free ()\n");
#line 160
  connection = 0;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (connection < 10)) {
#line 160
      goto while_break;
    }
#line 161
    client_socket_is_free[connection] = (unsigned char)1;
#line 160
    connection ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  debug_printf("mark_all_client_sockets_as_free>\n");
  }
#line 163
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void print_program_version(char *PROGRAM_NAME , char *PROGRAM_VERSION ) 
{ 
  int count ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 176
  printf((char const   */* __restrict  */)"\n-----------------------------------\n");
#line 177
  printf((char const   */* __restrict  */)"%s", PROGRAM_NAME);
#line 178
  count = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    tmp = strlen((char const   *)PROGRAM_NAME);
    }
#line 178
    if (! ((size_t )count < 25UL - tmp)) {
#line 178
      goto while_break;
    }
    {
#line 179
    printf((char const   */* __restrict  */)" ");
#line 178
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  count = 0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 180
    tmp___0 = strlen((char const   *)PROGRAM_VERSION);
    }
#line 180
    if (! ((size_t )count < 10UL - tmp___0)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    printf((char const   */* __restrict  */)" ");
#line 180
    count ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  printf((char const   */* __restrict  */)"%s\n\n", PROGRAM_VERSION);
#line 183
  printf((char const   */* __restrict  */)"(C) 2003 Miguelanxo Otero Salgueiro\n");
#line 184
  printf((char const   */* __restrict  */)"-----------------------------------\n\n");
  }
#line 185
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void strnsend(int fd___0 , char *string___0 , int len ) 
{ 


  {
  {
#line 198
  debug_printf(">strnsend(%d,%s,%d)\n", fd___0, string___0, len);
#line 216
  write(fd___0, (void const   *)string___0, (size_t )len);
#line 217
  debug_printf("strnsend>\n");
  }
#line 218
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void strsend(int fd___0 , char *string___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 229
  tmp = strlen((char const   *)string___0);
#line 229
  strnsend(fd___0, string___0, (int )tmp);
  }
#line 230
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
char *parse_HTTP_return_code(void) 
{ 
  int count ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 243
  debug_printf(">parse_HTTP_return_code\n");
#line 247
  strcpy((char */* __restrict  */)(HTTP_return_code), (char const   */* __restrict  */)"XXX");
#line 249
  tmp = memcmp((void const   *)(buffer), (void const   *)"HTTP", (size_t )4);
  }
#line 249
  if (! tmp) {
#line 251
    count = 0;
    {
#line 251
    while (1) {
      while_continue: /* CIL Label */ ;
#line 251
      if (! ((int )buffer[count] != 32)) {
#line 251
        goto while_break;
      }
#line 252
      if (count == 1500) {
#line 253
        goto while_break;
      }
#line 251
      count ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 254
    if (count < 1500) {
      {
#line 256
      memcpy((void */* __restrict  */)(HTTP_return_code), (void const   */* __restrict  */)(& buffer[count + 1]),
             (size_t )3);
#line 257
      HTTP_return_code[3] = (char)0;
#line 258
      debug_printf("parse_HTTP_return_code>\n");
      }
#line 259
      return (HTTP_return_code);
    }
  }
  {
#line 262
  printf((char const   */* __restrict  */)"parse_HTTP_return_code:");
#line 263
  tmp___0 = gettext("bad proxy response.\n");
#line 263
  printf((char const   */* __restrict  */)tmp___0);
#line 264
  exit(1);
  }
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int wait_for_crlf(int fd___0 ) 
{ 
  unsigned char previous_byte ;
  int count ;

  {
  {
#line 277
  previous_byte = (unsigned char)0;
#line 280
  debug_printf(">wait_for_crfl(%d)\n", fd___0);
#line 281
  count = 0;
  }
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    read(fd___0, (void *)(& buffer[count]), (size_t )1);
#line 285
    debug_printf("%c", (int )buffer[count]);
    }
#line 286
    if ((int )buffer[count] == 10) {
#line 286
      if ((int )previous_byte == 13) {
#line 287
        goto while_break;
      }
    }
#line 288
    if (count == 1500) {
      {
#line 290
      printf((char const   */* __restrict  */)" (CASCA)\n\n");
#line 291
      printf((char const   */* __restrict  */)"wait_for_crlf: BUFFER OVERFLOW!\n");
      }
#line 292
      return (-1);
    }
#line 294
    previous_byte = buffer[count];
#line 295
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  buffer[count + 1] = (unsigned char)0;
#line 298
  debug_printf("wait_for_crfl>\n");
  }
#line 299
  return (0);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int wait_for_2crlf(int fd___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 312
  debug_printf(">wait_for_2crlf\n");
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 313
    tmp___0 = memcmp((void const   *)(buffer), (void const   *)"\r\n", (size_t )2);
    }
#line 313
    if (! tmp___0) {
#line 313
      goto while_break;
    }
    {
#line 315
    tmp = wait_for_crlf(fd___0);
    }
#line 315
    if (tmp < 0) {
#line 317
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  debug_printf("wait_for_2crlf>\n");
  }
#line 321
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int connect_host_to_proxy(int connection , char *remote_host___0 , char *remote_port___0 ) 
{ 
  int count ;
  char proxy_user[256] ;
  char User_Agent[256] ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char proxy_authorization_base64[257] ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 340
  debug_printf(">connect_host_to_proxy(%d,%s,%s)\n", connection, remote_host___0,
               remote_port___0);
#line 342
  debug_printf(">socket(AF_INET,SOCK_STREAM,0)\n");
#line 343
  tmp = socket(2, 1, 0);
#line 343
  proxy_socket[connection] = tmp;
  }
#line 343
  if (tmp < 0) {
    {
#line 345
    perror("socket");
    }
#line 346
    return (-1);
  }
  {
#line 348
  debug_printf("socket> (%d)\n", proxy_socket[connection]);
#line 349
  proxy_hostent = gethostbyname((char const   *)proxy_host);
  }
#line 349
  if ((unsigned long )proxy_hostent == (unsigned long )((void *)0)) {
    {
#line 351
    tmp___0 = __h_errno_location();
    }
    {
#line 353
    if (*tmp___0 == 2) {
#line 353
      goto case_2;
    }
#line 360
    if (*tmp___0 == 1) {
#line 360
      goto case_1;
    }
#line 366
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 355
    printf((char const   */* __restrict  */)"gethostbyname:");
#line 356
    tmp___1 = gettext(" temporary error");
#line 356
    printf((char const   */* __restrict  */)tmp___1);
#line 357
    tmp___2 = gettext(" in name resolution\n");
#line 357
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 358
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 362
    printf((char const   */* __restrict  */)"gethostbyname:");
#line 363
    tmp___3 = gettext(" unknown host\n");
#line 363
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 364
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 368
    printf((char const   */* __restrict  */)"gethostbyname:");
#line 369
    tmp___4 = gettext(" non-recoverable");
#line 369
    printf((char const   */* __restrict  */)tmp___4);
#line 370
    tmp___5 = gettext(" name server error\n");
#line 370
    printf((char const   */* __restrict  */)tmp___5);
    }
    switch_break: /* CIL Label */ ;
    }
#line 373
    return (-2);
  }
  {
#line 375
  memset((void *)(& proxy), 0, sizeof(proxy));
#line 376
  proxy.sin_family = (sa_family_t )2;
#line 377
  memcpy((void */* __restrict  */)(& proxy.sin_addr), (void const   */* __restrict  */)*(proxy_hostent->h_addr_list + 0),
         (size_t )proxy_hostent->h_length);
#line 378
  tmp___6 = atoi((char const   *)proxy_port);
#line 378
  proxy.sin_port = htons((uint16_t )tmp___6);
#line 379
  debug_printf(">connect\n");
#line 380
  tmp___7 = connect(proxy_socket[connection], (struct sockaddr  const  *)((struct sockaddr *)(& proxy)),
                    (socklen_t )sizeof(proxy));
  }
#line 380
  if (tmp___7 < 0) {
    {
#line 383
    perror("connect");
    }
#line 384
    return (-3);
  }
  {
#line 386
  debug_printf("connect>\n");
#line 387
  status = 0;
#line 388
  strcpy((char */* __restrict  */)(string), (char const   */* __restrict  */)"CONNECT ");
#line 389
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)remote_host___0);
#line 390
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)":");
#line 391
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)remote_port___0);
#line 392
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)" HTTP/1.1\r\nHost: ");
#line 393
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)remote_host___0);
#line 394
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)":");
#line 395
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)remote_port___0);
#line 396
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)"\r\nUser-Agent: ");
#line 397
  tmp___9 = getenv("USER_AGENT");
  }
#line 397
  if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
    {
#line 399
    tmp___8 = getenv("USER_AGENT");
#line 399
    strncpy((char */* __restrict  */)(User_Agent), (char const   */* __restrict  */)tmp___8,
            (size_t )255);
    }
  } else {
    {
#line 403
    strcpy((char */* __restrict  */)(User_Agent), (char const   */* __restrict  */)"Mozilla/4.0 (compatible; MSIE 5.5; Windows 98)");
    }
  }
  {
#line 405
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)(User_Agent));
#line 406
  tmp___11 = getenv("PROXY_USER");
  }
#line 406
  if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
    {
#line 410
    tmp___10 = getenv("PROXY_USER");
#line 410
    strncpy((char */* __restrict  */)(proxy_user), (char const   */* __restrict  */)tmp___10,
            (size_t )255);
#line 411
    base64_encode((char const   *)(proxy_user), proxy_authorization_base64);
#line 412
    strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)"\r\nProxy-authorization: Basic ");
#line 413
    strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)(proxy_authorization_base64));
#line 414
    debug_printf("Proxy-authorization: Basic %s\n", proxy_authorization_base64);
    }
  }
  {
#line 417
  strcat((char */* __restrict  */)(string), (char const   */* __restrict  */)"\r\n\r\n");
#line 418
  strsend(proxy_socket[connection], string);
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (status == 0)) {
#line 419
      goto while_break;
    }
    {
#line 421
    tmp___12 = wait_for_crlf(proxy_socket[connection]);
    }
#line 421
    if (tmp___12 < 0) {
      {
#line 423
      EOC(connection);
      }
#line 424
      return (-4);
    }
    {
#line 426
    parse_HTTP_return_code();
#line 427
    tmp___13 = strcmp((char const   *)(HTTP_return_code), "200");
    }
#line 427
    if (tmp___13) {
#line 430
      status = 2;
    } else {
#line 428
      status = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  if (status == 2) {
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 437
      tmp___14 = read(proxy_socket[connection], (void *)(buffer), sizeof(buffer));
#line 437
      count = (int )tmp___14;
      }
#line 437
      if (! (count != 0)) {
#line 437
        goto while_break___0;
      }
      {
#line 439
      write(1, (void const   *)(buffer), (size_t )count);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 440
    return (-5);
  }
  {
#line 446
  tmp___15 = wait_for_2crlf(proxy_socket[connection]);
  }
#line 446
  if (tmp___15 < 0) {
#line 448
    return (-6);
  }
  {
#line 450
  tmp___16 = gettext("bidirectional connection stablished\n\n");
#line 450
  print_connection(connection, tmp___16);
  }
#line 452
  if (proxy_socket[connection] > maxfd) {
#line 453
    maxfd = proxy_socket[connection];
  }
  {
#line 454
  mask.__fds_bits[proxy_socket[connection] / (8 * (int )sizeof(__fd_mask ))] |= 1L << proxy_socket[connection] % (8 * (int )sizeof(__fd_mask ));
#line 455
  debug_printf("connect_host_to_proxy> (0)\n");
  }
#line 456
  return (0);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void initialize_gettext(void) 
{ 


  {
  {
#line 467
  debug_printf(">initialize_gettext()\n");
#line 468
  setlocale(6, "");
#line 469
  bindtextdomain("desproxy", "/usr/local/share/locale");
#line 470
  textdomain("desproxy");
#line 471
  debug_printf("initilize_gettext>\n");
  }
#line 472
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int bind_UDP_port(unsigned int request_port ) 
{ 
  int UDP_socket ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 484
  debug_printf("bind_UDP_port(%d)\n", request_port);
#line 485
  UDP_socket = socket(2, 2, 0);
  }
#line 485
  if (UDP_socket < 0) {
    {
#line 487
    perror("socket");
#line 488
    exit(1);
    }
  }
  {
#line 490
  memset((void *)(& server), 0, sizeof(server));
#line 491
  server.sin_family = (sa_family_t )2;
#line 492
  server.sin_addr.s_addr = htonl((in_addr_t )0);
#line 493
  server.sin_port = htons((uint16_t )request_port);
#line 494
  tmp = bind(UDP_socket, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
             (socklen_t )sizeof(server));
  }
#line 494
  if (tmp < 0) {
    {
#line 496
    perror("bind");
#line 497
    exit(1);
    }
  }
  {
#line 499
  tmp___0 = gettext("UDP port ");
#line 499
  printf((char const   */* __restrict  */)tmp___0);
#line 500
  printf((char const   */* __restrict  */)"%d", request_port);
#line 501
  tmp___1 = gettext(" Bound\n");
#line 501
  printf((char const   */* __restrict  */)tmp___1);
#line 502
  debug_printf("bind_UDP_port> (%d)\n", UDP_socket);
  }
#line 503
  return (UDP_socket);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int listen_in_TCP_port(unsigned int request_port ) 
{ 
  int request_socket___0 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 516
  debug_printf("listen_in_TCP_port(%d)\n", request_port);
#line 517
  request_socket___0 = socket(2, 1, 0);
  }
#line 517
  if (request_socket___0 < 0) {
    {
#line 519
    perror("socket");
#line 520
    exit(1);
    }
  }
  {
#line 522
  memset((void *)(& server), 0, sizeof(server));
#line 523
  server.sin_family = (sa_family_t )2;
#line 524
  server.sin_addr.s_addr = htonl((in_addr_t )0);
#line 525
  server.sin_port = htons((uint16_t )request_port);
#line 526
  tmp = bind(request_socket___0, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
             (socklen_t )sizeof(server));
  }
#line 526
  if (tmp < 0) {
    {
#line 528
    perror("bind");
#line 529
    exit(1);
    }
  }
  {
#line 531
  tmp___0 = listen(request_socket___0, 128);
  }
#line 531
  if (tmp___0 < 0) {
    {
#line 533
    perror("listen");
#line 534
    exit(1);
    }
  }
  {
#line 536
  tmp___1 = gettext("TCP port ");
#line 536
  printf((char const   */* __restrict  */)tmp___1);
#line 537
  printf((char const   */* __restrict  */)"%d", request_port);
#line 538
  tmp___2 = gettext(" Bound & Listening\n");
#line 538
  printf((char const   */* __restrict  */)tmp___2);
#line 539
  debug_printf("listen_in_TCP_port> (%d)\n", request_socket___0);
  }
#line 540
  return (request_socket___0);
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
int look_for_desproxy_conf(void) 
{ 
  FILE *desproxy_conf ;

  {
  {
#line 552
  desproxy_conf = fopen((char const   */* __restrict  */)"desproxy.conf", (char const   */* __restrict  */)"r");
  }
#line 552
  if ((unsigned long )desproxy_conf == (unsigned long )((void *)0)) {
#line 554
    return (0);
  }
  {
#line 556
  fclose(desproxy_conf);
  }
#line 557
  return (1);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void turn_console_echo_off(void) 
{ 
  struct termios tty ;

  {
  {
#line 574
  tcgetattr(0, & old_tty);
#line 597
  tty = old_tty;
#line 598
  tty.c_lflag &= 4294967173U;
#line 612
  tcsetattr(0, 2, (struct termios  const  *)(& tty));
  }
#line 613
  return;
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void turn_console_echo_on(void) 
{ 


  {
  {
#line 627
  tcsetattr(0, 2, (struct termios  const  *)(& old_tty));
  }
#line 628
  return;
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
void get_username_and_password(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 639
  strcpy((char */* __restrict  */)(console_line), (char const   */* __restrict  */)"");
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 641
    tmp___1 = strcmp((char const   *)(console_line), "");
    }
#line 641
    if (tmp___1) {
#line 641
      goto while_break;
    }
    {
#line 643
    tmp = gettext("Username: ");
#line 643
    printf((char const   */* __restrict  */)tmp);
#line 644
    tmp___0 = get_console_line();
#line 644
    strcpy((char */* __restrict  */)(username), (char const   */* __restrict  */)tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 647
  tmp___2 = gettext("Password: ");
#line 647
  printf((char const   */* __restrict  */)tmp___2);
#line 652
  turn_console_echo_off();
#line 653
  tmp___3 = get_console_line();
#line 653
  strcpy((char */* __restrict  */)(password), (char const   */* __restrict  */)tmp___3);
#line 658
  turn_console_echo_on();
#line 663
  printf((char const   */* __restrict  */)"\n");
  }
#line 664
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.c"
char *remote_host  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.c"
char *remote_port  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.c"
void client_to_proxy(int connection ) 
{ 
  int count ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 25
  print_connection(connection, (char *)"client -> proxy");
#line 26
  tmp = read(client_socket[connection], (void *)(buffer), sizeof(buffer));
#line 26
  count = (int )tmp;
  }
#line 26
  if (count == -1) {
    {
#line 28
    perror("read");
#line 29
    EOC(connection);
    }
#line 30
    return;
  }
  {
#line 32
  printf((char const   */* __restrict  */)" %4d bytes read\n", count);
  }
#line 33
  if (count == 0) {
    {
#line 35
    EOC(connection);
    }
#line 36
    return;
  } else {
    {
#line 40
    tmp___0 = write(proxy_socket[connection], (void const   *)(buffer), (size_t )count);
#line 40
    count = (int )tmp___0;
    }
#line 40
    if (count == -1) {
      {
#line 42
      perror("write");
#line 43
      EOC(connection);
      }
    }
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy.c"
void proxy_to_client(int connection ) 
{ 
  int count ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 53
  print_connection(connection, (char *)"proxy -> client");
#line 54
  tmp = read(proxy_socket[connection], (void *)(buffer), sizeof(buffer));
#line 54
  count = (int )tmp;
  }
#line 54
  if (count == -1) {
    {
#line 56
    perror("read");
#line 57
    EOC(connection);
    }
#line 58
    return;
  }
  {
#line 60
  printf((char const   */* __restrict  */)" %4d bytes read\n", count);
  }
#line 61
  if (count == 0) {
    {
#line 63
    EOC(connection);
    }
#line 64
    return;
  } else {
    {
#line 68
    tmp___0 = write(client_socket[connection], (void const   *)(buffer), (size_t )count);
#line 68
    count = (int )tmp___0;
    }
#line 68
    if (count == -1) {
      {
#line 70
      perror("write");
#line 71
      EOC(connection);
      }
    }
  }
#line 74
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
static void base64_encode___0(char const   *s , char *p ) 
{ 
  char base64[65] ;
  int i ;
  int length ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
  {
#line 26
  base64[0] = (char )'A';
#line 26
  base64[1] = (char )'B';
#line 26
  base64[2] = (char )'C';
#line 26
  base64[3] = (char )'D';
#line 26
  base64[4] = (char )'E';
#line 26
  base64[5] = (char )'F';
#line 26
  base64[6] = (char )'G';
#line 26
  base64[7] = (char )'H';
#line 26
  base64[8] = (char )'I';
#line 26
  base64[9] = (char )'J';
#line 26
  base64[10] = (char )'K';
#line 26
  base64[11] = (char )'L';
#line 26
  base64[12] = (char )'M';
#line 26
  base64[13] = (char )'N';
#line 26
  base64[14] = (char )'O';
#line 26
  base64[15] = (char )'P';
#line 26
  base64[16] = (char )'Q';
#line 26
  base64[17] = (char )'R';
#line 26
  base64[18] = (char )'S';
#line 26
  base64[19] = (char )'T';
#line 26
  base64[20] = (char )'U';
#line 26
  base64[21] = (char )'V';
#line 26
  base64[22] = (char )'W';
#line 26
  base64[23] = (char )'X';
#line 26
  base64[24] = (char )'Y';
#line 26
  base64[25] = (char )'Z';
#line 26
  base64[26] = (char )'a';
#line 26
  base64[27] = (char )'b';
#line 26
  base64[28] = (char )'c';
#line 26
  base64[29] = (char )'d';
#line 26
  base64[30] = (char )'e';
#line 26
  base64[31] = (char )'f';
#line 26
  base64[32] = (char )'g';
#line 26
  base64[33] = (char )'h';
#line 26
  base64[34] = (char )'i';
#line 26
  base64[35] = (char )'j';
#line 26
  base64[36] = (char )'k';
#line 26
  base64[37] = (char )'l';
#line 26
  base64[38] = (char )'m';
#line 26
  base64[39] = (char )'n';
#line 26
  base64[40] = (char )'o';
#line 26
  base64[41] = (char )'p';
#line 26
  base64[42] = (char )'q';
#line 26
  base64[43] = (char )'r';
#line 26
  base64[44] = (char )'s';
#line 26
  base64[45] = (char )'t';
#line 26
  base64[46] = (char )'u';
#line 26
  base64[47] = (char )'v';
#line 26
  base64[48] = (char )'w';
#line 26
  base64[49] = (char )'x';
#line 26
  base64[50] = (char )'y';
#line 26
  base64[51] = (char )'z';
#line 26
  base64[52] = (char )'0';
#line 26
  base64[53] = (char )'1';
#line 26
  base64[54] = (char )'2';
#line 26
  base64[55] = (char )'3';
#line 26
  base64[56] = (char )'4';
#line 26
  base64[57] = (char )'5';
#line 26
  base64[58] = (char )'6';
#line 26
  base64[59] = (char )'7';
#line 26
  base64[60] = (char )'8';
#line 26
  base64[61] = (char )'9';
#line 26
  base64[62] = (char )'+';
#line 26
  base64[63] = (char )'/';
#line 26
  base64[64] = (char )'\000';
#line 30
  tmp = strlen(s);
#line 30
  length = (int )tmp;
#line 31
  i = 0;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < length)) {
#line 31
      goto while_break;
    }
#line 33
    tmp___0 = p;
#line 33
    p ++;
#line 33
    *tmp___0 = base64[(int const   )*(s + 0) >> 2];
#line 34
    tmp___1 = p;
#line 34
    p ++;
#line 34
    *tmp___1 = base64[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 35
    tmp___2 = p;
#line 35
    p ++;
#line 35
    *tmp___2 = base64[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 36
    tmp___3 = p;
#line 36
    p ++;
#line 36
    *tmp___3 = base64[(int const   )*(s + 2) & 63];
#line 37
    s += 3;
#line 31
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (i == length + 1) {
#line 40
    *(p - 1) = (char )'=';
  } else
#line 41
  if (i == length + 2) {
#line 42
    tmp___4 = (char )'=';
#line 42
    *(p - 2) = tmp___4;
#line 42
    *(p - 1) = tmp___4;
  }
#line 43
  *p = (char )'\000';
#line 44
  return;
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/socket2socket.c"
int remote_socket[10]  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/socket2socket.c"
void EOC_s2s(int index___0 ) 
{ 
  char *tmp ;

  {
  {
#line 26
  close(client_socket[index___0]);
#line 27
  close(remote_socket[index___0]);
#line 28
  mask.__fds_bits[client_socket[index___0] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << client_socket[index___0] % (8 * (int )sizeof(__fd_mask )));
#line 29
  mask.__fds_bits[remote_socket[index___0] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << remote_socket[index___0] % (8 * (int )sizeof(__fd_mask )));
#line 30
  client_socket_is_free[index___0] = (unsigned char)1;
#line 31
  tmp = gettext("End of connection\n");
#line 31
  printf((char const   */* __restrict  */)tmp);
#line 32
  fflush(stdout);
#line 33
  fflush(stderr);
  }
#line 34
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
static void base64_encode___1(char const   *s , char *p ) 
{ 
  char base64[65] ;
  int i ;
  int length ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
  {
#line 26
  base64[0] = (char )'A';
#line 26
  base64[1] = (char )'B';
#line 26
  base64[2] = (char )'C';
#line 26
  base64[3] = (char )'D';
#line 26
  base64[4] = (char )'E';
#line 26
  base64[5] = (char )'F';
#line 26
  base64[6] = (char )'G';
#line 26
  base64[7] = (char )'H';
#line 26
  base64[8] = (char )'I';
#line 26
  base64[9] = (char )'J';
#line 26
  base64[10] = (char )'K';
#line 26
  base64[11] = (char )'L';
#line 26
  base64[12] = (char )'M';
#line 26
  base64[13] = (char )'N';
#line 26
  base64[14] = (char )'O';
#line 26
  base64[15] = (char )'P';
#line 26
  base64[16] = (char )'Q';
#line 26
  base64[17] = (char )'R';
#line 26
  base64[18] = (char )'S';
#line 26
  base64[19] = (char )'T';
#line 26
  base64[20] = (char )'U';
#line 26
  base64[21] = (char )'V';
#line 26
  base64[22] = (char )'W';
#line 26
  base64[23] = (char )'X';
#line 26
  base64[24] = (char )'Y';
#line 26
  base64[25] = (char )'Z';
#line 26
  base64[26] = (char )'a';
#line 26
  base64[27] = (char )'b';
#line 26
  base64[28] = (char )'c';
#line 26
  base64[29] = (char )'d';
#line 26
  base64[30] = (char )'e';
#line 26
  base64[31] = (char )'f';
#line 26
  base64[32] = (char )'g';
#line 26
  base64[33] = (char )'h';
#line 26
  base64[34] = (char )'i';
#line 26
  base64[35] = (char )'j';
#line 26
  base64[36] = (char )'k';
#line 26
  base64[37] = (char )'l';
#line 26
  base64[38] = (char )'m';
#line 26
  base64[39] = (char )'n';
#line 26
  base64[40] = (char )'o';
#line 26
  base64[41] = (char )'p';
#line 26
  base64[42] = (char )'q';
#line 26
  base64[43] = (char )'r';
#line 26
  base64[44] = (char )'s';
#line 26
  base64[45] = (char )'t';
#line 26
  base64[46] = (char )'u';
#line 26
  base64[47] = (char )'v';
#line 26
  base64[48] = (char )'w';
#line 26
  base64[49] = (char )'x';
#line 26
  base64[50] = (char )'y';
#line 26
  base64[51] = (char )'z';
#line 26
  base64[52] = (char )'0';
#line 26
  base64[53] = (char )'1';
#line 26
  base64[54] = (char )'2';
#line 26
  base64[55] = (char )'3';
#line 26
  base64[56] = (char )'4';
#line 26
  base64[57] = (char )'5';
#line 26
  base64[58] = (char )'6';
#line 26
  base64[59] = (char )'7';
#line 26
  base64[60] = (char )'8';
#line 26
  base64[61] = (char )'9';
#line 26
  base64[62] = (char )'+';
#line 26
  base64[63] = (char )'/';
#line 26
  base64[64] = (char )'\000';
#line 30
  tmp = strlen(s);
#line 30
  length = (int )tmp;
#line 31
  i = 0;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < length)) {
#line 31
      goto while_break;
    }
#line 33
    tmp___0 = p;
#line 33
    p ++;
#line 33
    *tmp___0 = base64[(int const   )*(s + 0) >> 2];
#line 34
    tmp___1 = p;
#line 34
    p ++;
#line 34
    *tmp___1 = base64[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 35
    tmp___2 = p;
#line 35
    p ++;
#line 35
    *tmp___2 = base64[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 36
    tmp___3 = p;
#line 36
    p ++;
#line 36
    *tmp___3 = base64[(int const   )*(s + 2) & 63];
#line 37
    s += 3;
#line 31
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (i == length + 1) {
#line 40
    *(p - 1) = (char )'=';
  } else
#line 41
  if (i == length + 2) {
#line 42
    tmp___4 = (char )'=';
#line 42
    *(p - 2) = tmp___4;
#line 42
    *(p - 1) = tmp___4;
  }
#line 43
  *p = (char )'\000';
#line 44
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
int request_length  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
unsigned char nmethods[10]  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
unsigned char methods[10][256]  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void nothing_read(int connection ) 
{ 
  ssize_t tmp ;
  char *tmp___0 ;

  {
  {
#line 47
  debug_printf(">nothing_read()\n");
#line 48
  tmp = read(client_socket[connection], (void *)(buffer), (size_t )1);
  }
#line 48
  if (tmp == -1L) {
    {
#line 50
    perror("read");
#line 51
    EOC(connection);
    }
#line 52
    return;
  }
#line 55
  if ((int )buffer[0] == 4) {
    {
#line 57
    connection_status[connection] = 6;
#line 58
    debug_printf("nothing_read>\n");
    }
#line 59
    return;
  }
#line 62
  if ((int )buffer[0] == 5) {
    {
#line 64
    connection_status[connection] = 5;
#line 65
    debug_printf("nothing_read>\n");
    }
#line 66
    return;
  }
  {
#line 69
  tmp___0 = gettext("invalid client protocol version (");
#line 69
  printf((char const   */* __restrict  */)tmp___0);
#line 70
  printf((char const   */* __restrict  */)"%d)\n", (int )buffer[0]);
#line 75
  strnsend(client_socket[connection], (char *)"\005\001\000\000", 4);
#line 76
  EOC(connection);
  }
#line 77
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void protocol_v4_ok(int connection ) 
{ 
  ssize_t tmp ;

  {
  {
#line 86
  debug_printf(">protocol_v4_ok()\n");
#line 87
  tmp = read(client_socket[connection], (void *)(buffer), (size_t )1);
  }
#line 87
  if (tmp == -1L) {
    {
#line 89
    perror("read");
#line 90
    EOC(connection);
    }
#line 91
    return;
  }
#line 93
  if ((int )buffer[0] != 1) {
    {
#line 95
    debug_printf("Method != 1 (CONNECT) => method refused\n");
#line 96
    strnsend(client_socket[connection], (char *)"\000[\000\000\000\000\000\000", 8);
#line 98
    EOC(connection);
    }
  } else {
    {
#line 102
    debug_printf("Method 1 (CONNECT) accepted\n");
#line 103
    connection_status[connection] = 9;
    }
  }
  {
#line 105
  debug_printf("protocol_v4_ok>\n");
  }
#line 106
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void protocol_v5_ok(int connection ) 
{ 
  ssize_t tmp ;

  {
  {
#line 115
  debug_printf(">protocol_v5_ok()\n");
#line 116
  tmp = read(client_socket[connection], (void *)(buffer), (size_t )1);
  }
#line 116
  if (tmp == -1L) {
    {
#line 118
    perror("read");
#line 119
    EOC(connection);
    }
#line 120
    return;
  }
  {
#line 122
  nmethods[connection] = buffer[0];
#line 123
  connection_status[connection] = 7;
#line 124
  debug_printf("Number of methods: %d\n", (int )nmethods[connection]);
#line 125
  debug_printf("protocol_v5_ok>\n");
  }
#line 126
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void method_accepted_v4(int connection ) 
{ 
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 135
  debug_printf(">method_accepted()\n");
#line 136
  tmp = read(client_socket[connection], (void *)(buffer), (size_t )6);
  }
#line 136
  if (tmp == -1L) {
    {
#line 138
    perror("read");
#line 139
    EOC(connection);
    }
#line 140
    return;
  }
  {
#line 142
  debug_printf("IP ");
#line 143
  debug_printf("(%d.%d.%d.%d:%d)\n", (int )buffer[2], (int )buffer[3], (int )buffer[4],
               (int )buffer[5], (int )buffer[0] * 256 + (int )buffer[1]);
#line 145
  sprintf((char */* __restrict  */)(remote_host), (char const   */* __restrict  */)"%d.%d.%d.%d",
          (int )buffer[2], (int )buffer[3], (int )buffer[4], (int )buffer[5]);
#line 147
  sprintf((char */* __restrict  */)(remote_port), (char const   */* __restrict  */)"%d",
          (int )buffer[0] * 256 + (int )buffer[1]);
#line 148
  buffer[0] = (unsigned char)255;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! ((int )buffer[0] != 0)) {
#line 149
      goto while_break;
    }
    {
#line 151
    tmp___0 = read(client_socket[connection], (void *)(buffer), (size_t )1);
    }
#line 151
    if (tmp___0 == -1L) {
      {
#line 153
      perror("read");
#line 154
      EOC(connection);
      }
#line 155
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  tmp___1 = connect_host_to_proxy(connection, remote_host, remote_port);
  }
#line 158
  if (tmp___1 != 0) {
    {
#line 160
    strnsend(client_socket[connection], (char *)"\000[\000\000\000\000\000\000", 8);
#line 162
    printf((char const   */* __restrict  */)"connect_host_to_proxy: ERROR\n");
#line 163
    EOC(connection);
    }
#line 164
    return;
  } else {
    {
#line 171
    strnsend(client_socket[connection], (char *)"\000Z\000\000\000\000\000\000", 8);
#line 173
    connection_status[connection] = 1;
    }
  }
#line 175
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void method_accepted_v5(int connection ) 
{ 
  unsigned char index___0 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 185
  debug_printf(">method_accepted()\n");
#line 186
  tmp = read(client_socket[connection], (void *)(buffer), (size_t )4);
  }
#line 186
  if (tmp == -1L) {
    {
#line 188
    perror("read");
#line 189
    EOC(connection);
    }
#line 190
    return;
  }
  {
#line 192
  debug_printf("VER %d\n", (int )buffer[0]);
#line 193
  debug_printf("CMD %d\n", (int )buffer[1]);
#line 194
  debug_printf("RSV %d\n", (int )buffer[2]);
#line 195
  debug_printf("ATYP %d\n", (int )buffer[3]);
  }
#line 196
  if ((int )buffer[1] != 1) {
    {
#line 198
    debug_printf("Command %d not supported\n", (int )buffer[1]);
#line 202
    strnsend(client_socket[connection], (char *)"\005\a\000\001", 4);
#line 203
    strnsend(client_socket[connection], (char *)(& server.sin_port), 2);
#line 204
    strnsend(client_socket[connection], (char *)(& server.sin_addr.s_addr), 4);
#line 205
    EOC(connection);
    }
#line 206
    return;
  }
#line 208
  if ((int )buffer[3] == 1) {
    {
#line 210
    tmp___0 = read(client_socket[connection], (void *)(buffer), (size_t )6);
    }
#line 210
    if (tmp___0 == -1L) {
      {
#line 212
      perror("read");
#line 213
      EOC(connection);
      }
#line 214
      return;
    }
    {
#line 216
    debug_printf("ATYP = IP ");
#line 217
    debug_printf("(%d.%d.%d.%d:%d)\n", (int )buffer[0], (int )buffer[1], (int )buffer[2],
                 (int )buffer[3], (int )buffer[4] * 256 + (int )buffer[5]);
#line 219
    sprintf((char */* __restrict  */)(remote_host), (char const   */* __restrict  */)"%d.%d.%d.%d",
            (int )buffer[0], (int )buffer[1], (int )buffer[2], (int )buffer[3]);
#line 221
    sprintf((char */* __restrict  */)(remote_port), (char const   */* __restrict  */)"%d",
            (int )buffer[4] * 256 + (int )buffer[5]);
    }
  }
#line 223
  if ((int )buffer[3] == 3) {
    {
#line 225
    tmp___1 = read(client_socket[connection], (void *)(buffer), (size_t )1);
    }
#line 225
    if (tmp___1 == -1L) {
      {
#line 227
      perror("read");
#line 228
      EOC(connection);
      }
#line 229
      return;
    }
    {
#line 231
    debug_printf("ATYP = DOMAINNAME\n");
#line 232
    strcpy((char */* __restrict  */)(remote_host), (char const   */* __restrict  */)"");
#line 233
    index___0 = buffer[0];
    }
    {
#line 233
    while (1) {
      while_continue: /* CIL Label */ ;
#line 233
      if (! ((int )index___0 > 0)) {
#line 233
        goto while_break;
      }
      {
#line 235
      tmp___2 = read(client_socket[connection], (void *)(buffer), (size_t )1);
      }
#line 235
      if (tmp___2 == -1L) {
        {
#line 237
        perror("read");
#line 238
        EOC(connection);
        }
#line 239
        return;
      }
      {
#line 241
      strncat((char */* __restrict  */)(remote_host), (char const   */* __restrict  */)((char *)(buffer)),
              (size_t )1);
#line 233
      index___0 = (unsigned char )((int )index___0 - 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 243
    strncat((char */* __restrict  */)(remote_host), (char const   */* __restrict  */)"\000",
            (size_t )1);
#line 244
    debug_printf("remote_host %s\n", remote_host);
#line 245
    tmp___3 = read(client_socket[connection], (void *)(buffer), (size_t )2);
    }
#line 245
    if (tmp___3 == -1L) {
      {
#line 247
      perror("read");
#line 248
      EOC(connection);
      }
#line 249
      return;
    }
    {
#line 251
    sprintf((char */* __restrict  */)(remote_port), (char const   */* __restrict  */)"%d",
            (int )buffer[0] * 256 + (int )buffer[1]);
#line 252
    debug_printf("remote_port %s\n", remote_port);
    }
  }
  {
#line 254
  tmp___4 = connect_host_to_proxy(connection, remote_host, remote_port);
  }
#line 254
  if (tmp___4 != 0) {
    {
#line 259
    strnsend(client_socket[connection], (char *)"\005\004\000\001", 4);
#line 260
    printf((char const   */* __restrict  */)"connect_host_to_proxy: ERROR\n");
#line 261
    EOC(connection);
    }
#line 262
    return;
  } else {
    {
#line 269
    strnsend(client_socket[connection], (char *)"\005\000\000\001", 4);
#line 270
    strnsend(client_socket[connection], (char *)(& server.sin_port), 2);
#line 271
    strnsend(client_socket[connection], (char *)(& server.sin_addr.s_addr), 4);
#line 272
    connection_status[connection] = 1;
    }
  }
#line 274
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void nmethods_read(int connection ) 
{ 
  unsigned char index___0 ;
  ssize_t tmp ;
  char *tmp___0 ;

  {
  {
#line 280
  debug_printf(">nmethods_read()\n");
#line 281
  tmp = read(client_socket[connection], (void *)(& methods[connection][0]), (size_t )nmethods[connection]);
  }
#line 281
  if (tmp == -1L) {
    {
#line 285
    perror("read");
#line 286
    EOC(connection);
    }
#line 287
    return;
  }
#line 289
  connection_status[connection] = 8;
#line 290
  index___0 = (unsigned char)0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! ((int )index___0 < (int )nmethods[connection])) {
#line 290
      goto while_break;
    }
#line 295
    if ((int )methods[connection][index___0] == 0) {
      {
#line 297
      connection_status[connection] = 10;
#line 298
      strnsend(client_socket[connection], (char *)"\005\000", 2);
#line 299
      debug_printf("Selected method 0\n");
      }
    }
#line 290
    index___0 = (unsigned char )((int )index___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  if (connection_status[connection] != 10) {
    {
#line 304
    tmp___0 = gettext("All methods rejected\n");
#line 304
    debug_printf((char const   *)tmp___0);
#line 305
    strnsend(client_socket[connection], (char *)"\005\377", 2);
#line 306
    EOC(connection);
    }
#line 307
    return;
  }
  {
#line 309
  debug_printf("nmethods_read>\n");
  }
#line 310
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/desproxy-socksserver.c"
void biconnected(int connection ) 
{ 
  int count ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 319
  debug_printf(">biconnected()\n");
#line 320
  debug_printf("client -> proxy (%d) ", connection);
#line 321
  tmp = read(client_socket[connection], (void *)(buffer), sizeof(buffer));
#line 321
  count = (int )tmp;
  }
#line 321
  if (count == -1) {
    {
#line 323
    debug_printf("-1 bytes\n");
#line 324
    perror("read");
#line 325
    EOC(connection);
    }
#line 326
    return;
  }
#line 328
  if (count == 0) {
    {
#line 330
    debug_printf("0 bytes\n");
#line 331
    EOC(connection);
    }
  } else {
    {
#line 335
    tmp___0 = write(proxy_socket[connection], (void const   *)(buffer), (size_t )count);
#line 335
    count = (int )tmp___0;
    }
#line 335
    if (count == -1) {
      {
#line 337
      perror("write");
#line 338
      EOC(connection);
      }
#line 339
      return;
    }
    {
#line 341
    debug_printf("%d bytes\n", count);
    }
  }
  {
#line 343
  debug_printf("biconnected>\n");
  }
#line 344
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
static void base64_encode___2(char const   *s , char *p ) 
{ 
  char base64[65] ;
  int i ;
  int length ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
  {
#line 26
  base64[0] = (char )'A';
#line 26
  base64[1] = (char )'B';
#line 26
  base64[2] = (char )'C';
#line 26
  base64[3] = (char )'D';
#line 26
  base64[4] = (char )'E';
#line 26
  base64[5] = (char )'F';
#line 26
  base64[6] = (char )'G';
#line 26
  base64[7] = (char )'H';
#line 26
  base64[8] = (char )'I';
#line 26
  base64[9] = (char )'J';
#line 26
  base64[10] = (char )'K';
#line 26
  base64[11] = (char )'L';
#line 26
  base64[12] = (char )'M';
#line 26
  base64[13] = (char )'N';
#line 26
  base64[14] = (char )'O';
#line 26
  base64[15] = (char )'P';
#line 26
  base64[16] = (char )'Q';
#line 26
  base64[17] = (char )'R';
#line 26
  base64[18] = (char )'S';
#line 26
  base64[19] = (char )'T';
#line 26
  base64[20] = (char )'U';
#line 26
  base64[21] = (char )'V';
#line 26
  base64[22] = (char )'W';
#line 26
  base64[23] = (char )'X';
#line 26
  base64[24] = (char )'Y';
#line 26
  base64[25] = (char )'Z';
#line 26
  base64[26] = (char )'a';
#line 26
  base64[27] = (char )'b';
#line 26
  base64[28] = (char )'c';
#line 26
  base64[29] = (char )'d';
#line 26
  base64[30] = (char )'e';
#line 26
  base64[31] = (char )'f';
#line 26
  base64[32] = (char )'g';
#line 26
  base64[33] = (char )'h';
#line 26
  base64[34] = (char )'i';
#line 26
  base64[35] = (char )'j';
#line 26
  base64[36] = (char )'k';
#line 26
  base64[37] = (char )'l';
#line 26
  base64[38] = (char )'m';
#line 26
  base64[39] = (char )'n';
#line 26
  base64[40] = (char )'o';
#line 26
  base64[41] = (char )'p';
#line 26
  base64[42] = (char )'q';
#line 26
  base64[43] = (char )'r';
#line 26
  base64[44] = (char )'s';
#line 26
  base64[45] = (char )'t';
#line 26
  base64[46] = (char )'u';
#line 26
  base64[47] = (char )'v';
#line 26
  base64[48] = (char )'w';
#line 26
  base64[49] = (char )'x';
#line 26
  base64[50] = (char )'y';
#line 26
  base64[51] = (char )'z';
#line 26
  base64[52] = (char )'0';
#line 26
  base64[53] = (char )'1';
#line 26
  base64[54] = (char )'2';
#line 26
  base64[55] = (char )'3';
#line 26
  base64[56] = (char )'4';
#line 26
  base64[57] = (char )'5';
#line 26
  base64[58] = (char )'6';
#line 26
  base64[59] = (char )'7';
#line 26
  base64[60] = (char )'8';
#line 26
  base64[61] = (char )'9';
#line 26
  base64[62] = (char )'+';
#line 26
  base64[63] = (char )'/';
#line 26
  base64[64] = (char )'\000';
#line 30
  tmp = strlen(s);
#line 30
  length = (int )tmp;
#line 31
  i = 0;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < length)) {
#line 31
      goto while_break;
    }
#line 33
    tmp___0 = p;
#line 33
    p ++;
#line 33
    *tmp___0 = base64[(int const   )*(s + 0) >> 2];
#line 34
    tmp___1 = p;
#line 34
    p ++;
#line 34
    *tmp___1 = base64[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 35
    tmp___2 = p;
#line 35
    p ++;
#line 35
    *tmp___2 = base64[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 36
    tmp___3 = p;
#line 36
    p ++;
#line 36
    *tmp___3 = base64[(int const   )*(s + 2) & 63];
#line 37
    s += 3;
#line 31
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (i == length + 1) {
#line 40
    *(p - 1) = (char )'=';
  } else
#line 41
  if (i == length + 2) {
#line 42
    tmp___4 = (char )'=';
#line 42
    *(p - 2) = tmp___4;
#line 42
    *(p - 1) = tmp___4;
  }
#line 43
  *p = (char )'\000';
#line 44
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/desproxy-0.1.0~pre3/src/util.c"
static void base64_encode___3(char const   *s , char *p ) 
{ 
  char base64[65] ;
  int i ;
  int length ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
  {
#line 26
  base64[0] = (char )'A';
#line 26
  base64[1] = (char )'B';
#line 26
  base64[2] = (char )'C';
#line 26
  base64[3] = (char )'D';
#line 26
  base64[4] = (char )'E';
#line 26
  base64[5] = (char )'F';
#line 26
  base64[6] = (char )'G';
#line 26
  base64[7] = (char )'H';
#line 26
  base64[8] = (char )'I';
#line 26
  base64[9] = (char )'J';
#line 26
  base64[10] = (char )'K';
#line 26
  base64[11] = (char )'L';
#line 26
  base64[12] = (char )'M';
#line 26
  base64[13] = (char )'N';
#line 26
  base64[14] = (char )'O';
#line 26
  base64[15] = (char )'P';
#line 26
  base64[16] = (char )'Q';
#line 26
  base64[17] = (char )'R';
#line 26
  base64[18] = (char )'S';
#line 26
  base64[19] = (char )'T';
#line 26
  base64[20] = (char )'U';
#line 26
  base64[21] = (char )'V';
#line 26
  base64[22] = (char )'W';
#line 26
  base64[23] = (char )'X';
#line 26
  base64[24] = (char )'Y';
#line 26
  base64[25] = (char )'Z';
#line 26
  base64[26] = (char )'a';
#line 26
  base64[27] = (char )'b';
#line 26
  base64[28] = (char )'c';
#line 26
  base64[29] = (char )'d';
#line 26
  base64[30] = (char )'e';
#line 26
  base64[31] = (char )'f';
#line 26
  base64[32] = (char )'g';
#line 26
  base64[33] = (char )'h';
#line 26
  base64[34] = (char )'i';
#line 26
  base64[35] = (char )'j';
#line 26
  base64[36] = (char )'k';
#line 26
  base64[37] = (char )'l';
#line 26
  base64[38] = (char )'m';
#line 26
  base64[39] = (char )'n';
#line 26
  base64[40] = (char )'o';
#line 26
  base64[41] = (char )'p';
#line 26
  base64[42] = (char )'q';
#line 26
  base64[43] = (char )'r';
#line 26
  base64[44] = (char )'s';
#line 26
  base64[45] = (char )'t';
#line 26
  base64[46] = (char )'u';
#line 26
  base64[47] = (char )'v';
#line 26
  base64[48] = (char )'w';
#line 26
  base64[49] = (char )'x';
#line 26
  base64[50] = (char )'y';
#line 26
  base64[51] = (char )'z';
#line 26
  base64[52] = (char )'0';
#line 26
  base64[53] = (char )'1';
#line 26
  base64[54] = (char )'2';
#line 26
  base64[55] = (char )'3';
#line 26
  base64[56] = (char )'4';
#line 26
  base64[57] = (char )'5';
#line 26
  base64[58] = (char )'6';
#line 26
  base64[59] = (char )'7';
#line 26
  base64[60] = (char )'8';
#line 26
  base64[61] = (char )'9';
#line 26
  base64[62] = (char )'+';
#line 26
  base64[63] = (char )'/';
#line 26
  base64[64] = (char )'\000';
#line 30
  tmp = strlen(s);
#line 30
  length = (int )tmp;
#line 31
  i = 0;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < length)) {
#line 31
      goto while_break;
    }
#line 33
    tmp___0 = p;
#line 33
    p ++;
#line 33
    *tmp___0 = base64[(int const   )*(s + 0) >> 2];
#line 34
    tmp___1 = p;
#line 34
    p ++;
#line 34
    *tmp___1 = base64[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 35
    tmp___2 = p;
#line 35
    p ++;
#line 35
    *tmp___2 = base64[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 36
    tmp___3 = p;
#line 36
    p ++;
#line 36
    *tmp___3 = base64[(int const   )*(s + 2) & 63];
#line 37
    s += 3;
#line 31
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (i == length + 1) {
#line 40
    *(p - 1) = (char )'=';
  } else
#line 41
  if (i == length + 2) {
#line 42
    tmp___4 = (char )'=';
#line 42
    *(p - 2) = tmp___4;
#line 42
    *(p - 1) = tmp___4;
  }
#line 43
  *p = (char )'\000';
#line 44
  return;
}
}
