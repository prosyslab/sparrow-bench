/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 37 "/usr/include/rpc/types.h"
typedef int bool_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 81 "/usr/include/rpc/xdr.h"
enum xdr_op {
    XDR_ENCODE = 0,
    XDR_DECODE = 1,
    XDR_FREE = 2
} ;
#line 109
struct XDR;
#line 109 "/usr/include/rpc/xdr.h"
typedef struct XDR XDR;
#line 110 "/usr/include/rpc/xdr.h"
struct xdr_ops {
   bool_t (*x_getlong)(XDR *__xdrs , long *__lp ) ;
   bool_t (*x_putlong)(XDR *__xdrs , long const   *__lp ) ;
   bool_t (*x_getbytes)(XDR *__xdrs , caddr_t __addr , u_int __len ) ;
   bool_t (*x_putbytes)(XDR *__xdrs , char const   *__addr , u_int __len ) ;
   u_int (*x_getpostn)(XDR const   *__xdrs ) ;
   bool_t (*x_setpostn)(XDR *__xdrs , u_int __pos ) ;
   int32_t *(*x_inline)(XDR *__xdrs , u_int __len ) ;
   void (*x_destroy)(XDR *__xdrs ) ;
   bool_t (*x_getint32)(XDR *__xdrs , int32_t *__ip ) ;
   bool_t (*x_putint32)(XDR *__xdrs , int32_t const   *__ip ) ;
};
#line 110 "/usr/include/rpc/xdr.h"
struct XDR {
   enum xdr_op x_op ;
   struct xdr_ops *x_ops ;
   caddr_t x_public ;
   caddr_t x_private ;
   caddr_t x_base ;
   u_int x_handy ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
struct rusers_utmp {
   char *ut_user ;
   char *ut_line ;
   char *ut_host ;
   int ut_type ;
   int ut_time ;
   u_int ut_idle ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
typedef struct rusers_utmp rusers_utmp;
#line 33 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
struct __anonstruct_utmp_array_72 {
   u_int utmp_array_len ;
   rusers_utmp *utmp_array_val ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
typedef struct __anonstruct_utmp_array_72 utmp_array;
#line 72 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
struct ru_utmp {
   char ut_line[8] ;
   char ut_name[8] ;
   char ut_host[16] ;
   long ut_time ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
struct utmparr {
   struct ru_utmp **uta_arr ;
   int uta_cnt ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
struct utmpidle {
   struct ru_utmp ui_utmp ;
   unsigned int ui_idle ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
struct utmpidlearr {
   struct utmpidle **uia_arr ;
   int uia_cnt ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 38 "/usr/include/rpc/types.h"
typedef int enum_t;
#line 40 "/usr/include/rpc/types.h"
typedef unsigned long rpcprog_t;
#line 41 "/usr/include/rpc/types.h"
typedef unsigned long rpcvers_t;
#line 42 "/usr/include/rpc/types.h"
typedef unsigned long rpcproc_t;
#line 43 "/usr/include/rpc/types.h"
typedef unsigned long rpcprot_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 52 "/usr/include/rpc/auth.h"
enum auth_stat {
    AUTH_OK = 0,
    AUTH_BADCRED = 1,
    AUTH_REJECTEDCRED = 2,
    AUTH_BADVERF = 3,
    AUTH_REJECTEDVERF = 4,
    AUTH_TOOWEAK = 5,
    AUTH_INVALIDRESP = 6,
    AUTH_FAILED = 7
} ;
#line 82 "/usr/include/rpc/auth.h"
struct opaque_auth {
   enum_t oa_flavor ;
   caddr_t oa_base ;
   u_int oa_length ;
};
#line 54 "/usr/include/rpc/rpc_msg.h"
enum msg_type {
    CALL = 0,
    REPLY = 1
} ;
#line 59
enum reply_stat {
    MSG_ACCEPTED = 0,
    MSG_DENIED = 1
} ;
#line 64
enum accept_stat {
    SUCCESS = 0,
    PROG_UNAVAIL = 1,
    PROG_MISMATCH = 2,
    PROC_UNAVAIL = 3,
    GARBAGE_ARGS = 4,
    SYSTEM_ERR = 5
} ;
#line 73
enum reject_stat {
    RPC_MISMATCH = 0,
    AUTH_ERROR = 1
} ;
#line 87 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_AR_versions_65 {
   u_long low ;
   u_long high ;
};
#line 87 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_AR_results_66 {
   caddr_t where ;
   bool_t (*proc)(XDR * , void *  , ...) ;
};
#line 87 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_64 {
   struct __anonstruct_AR_versions_65 AR_versions ;
   struct __anonstruct_AR_results_66 AR_results ;
};
#line 87 "/usr/include/rpc/rpc_msg.h"
struct accepted_reply {
   struct opaque_auth ar_verf ;
   enum accept_stat ar_stat ;
   union __anonunion_ru_64 ru ;
};
#line 108 "/usr/include/rpc/rpc_msg.h"
struct __anonstruct_RJ_versions_68 {
   u_long low ;
   u_long high ;
};
#line 108 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_67 {
   struct __anonstruct_RJ_versions_68 RJ_versions ;
   enum auth_stat RJ_why ;
};
#line 108 "/usr/include/rpc/rpc_msg.h"
struct rejected_reply {
   enum reject_stat rj_stat ;
   union __anonunion_ru_67 ru ;
};
#line 124 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_69 {
   struct accepted_reply RP_ar ;
   struct rejected_reply RP_dr ;
};
#line 124 "/usr/include/rpc/rpc_msg.h"
struct reply_body {
   enum reply_stat rp_stat ;
   union __anonunion_ru_69 ru ;
};
#line 137 "/usr/include/rpc/rpc_msg.h"
struct call_body {
   u_long cb_rpcvers ;
   u_long cb_prog ;
   u_long cb_vers ;
   u_long cb_proc ;
   struct opaque_auth cb_cred ;
   struct opaque_auth cb_verf ;
};
#line 149 "/usr/include/rpc/rpc_msg.h"
union __anonunion_ru_70 {
   struct call_body RM_cmb ;
   struct reply_body RM_rmb ;
};
#line 149 "/usr/include/rpc/rpc_msg.h"
struct rpc_msg {
   u_long rm_xid ;
   enum msg_type rm_direction ;
   union __anonunion_ru_70 ru ;
};
#line 81 "/usr/include/rpc/svc.h"
enum xprt_stat {
    XPRT_DIED = 0,
    XPRT_MOREREQS = 1,
    XPRT_IDLE = 2
} ;
#line 90
struct SVCXPRT;
#line 90 "/usr/include/rpc/svc.h"
typedef struct SVCXPRT SVCXPRT;
#line 91 "/usr/include/rpc/svc.h"
struct xp_ops {
   bool_t (*xp_recv)(SVCXPRT *__xprt , struct rpc_msg *__msg ) ;
   enum xprt_stat (*xp_stat)(SVCXPRT *__xprt ) ;
   bool_t (*xp_getargs)(SVCXPRT *__xprt , bool_t (*__xdr_args)(XDR * , void *  , ...) ,
                        caddr_t __args_ptr ) ;
   bool_t (*xp_reply)(SVCXPRT *__xprt , struct rpc_msg *__msg ) ;
   bool_t (*xp_freeargs)(SVCXPRT *__xprt , bool_t (*__xdr_args)(XDR * , void *  , ...) ,
                         caddr_t __args_ptr ) ;
   void (*xp_destroy)(SVCXPRT *__xprt ) ;
};
#line 91 "/usr/include/rpc/svc.h"
struct SVCXPRT {
   int xp_sock ;
   u_short xp_port ;
   struct xp_ops  const  *xp_ops ;
   int xp_addrlen ;
   struct sockaddr_in xp_raddr ;
   struct opaque_auth xp_verf ;
   caddr_t xp_p1 ;
   caddr_t xp_p2 ;
   char xp_pad[256] ;
};
#line 164 "/usr/include/rpc/svc.h"
struct svc_req {
   rpcprog_t rq_prog ;
   rpcvers_t rq_vers ;
   rpcproc_t rq_proc ;
   struct opaque_auth rq_cred ;
   caddr_t rq_clntcred ;
   SVCXPRT *rq_xprt ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 61 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_39 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_39 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 69 "/usr/include/rpc/auth.h"
struct __anonstruct_key_61 {
   u_int32_t high ;
   u_int32_t low ;
};
#line 69 "/usr/include/rpc/auth.h"
union des_block {
   struct __anonstruct_key_61 key ;
   char c[8] ;
};
#line 91
struct AUTH;
#line 91 "/usr/include/rpc/auth.h"
typedef struct AUTH AUTH;
#line 92 "/usr/include/rpc/auth.h"
struct auth_ops {
   void (*ah_nextverf)(AUTH * ) ;
   int (*ah_marshal)(AUTH * , XDR * ) ;
   int (*ah_validate)(AUTH * , struct opaque_auth * ) ;
   int (*ah_refresh)(AUTH * ) ;
   void (*ah_destroy)(AUTH * ) ;
};
#line 92 "/usr/include/rpc/auth.h"
struct AUTH {
   struct opaque_auth ah_cred ;
   struct opaque_auth ah_verf ;
   union des_block ah_key ;
   struct auth_ops *ah_ops ;
   caddr_t ah_private ;
};
#line 50 "/usr/include/rpc/clnt.h"
enum clnt_stat {
    RPC_SUCCESS = 0,
    RPC_CANTENCODEARGS = 1,
    RPC_CANTDECODERES = 2,
    RPC_CANTSEND = 3,
    RPC_CANTRECV = 4,
    RPC_TIMEDOUT = 5,
    RPC_VERSMISMATCH = 6,
    RPC_AUTHERROR = 7,
    RPC_PROGUNAVAIL = 8,
    RPC_PROGVERSMISMATCH = 9,
    RPC_PROCUNAVAIL = 10,
    RPC_CANTDECODEARGS = 11,
    RPC_SYSTEMERROR = 12,
    RPC_NOBROADCAST = 21,
    RPC_UNKNOWNHOST = 13,
    RPC_UNKNOWNPROTO = 17,
    RPC_UNKNOWNADDR = 19,
    RPC_RPCBFAILURE = 14,
    RPC_PROGNOTREGISTERED = 15,
    RPC_N2AXLATEFAILURE = 22,
    RPC_FAILED = 16,
    RPC_INTR = 18,
    RPC_TLIERROR = 20,
    RPC_UDERROR = 23,
    RPC_INPROGRESS = 24,
    RPC_STALERACHANDLE = 25
} ;
#line 103 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_vers_63 {
   u_long low ;
   u_long high ;
};
#line 103 "/usr/include/rpc/clnt.h"
struct __anonstruct_RE_lb_64 {
   long s1 ;
   long s2 ;
};
#line 103 "/usr/include/rpc/clnt.h"
union __anonunion_ru_62 {
   int RE_errno ;
   enum auth_stat RE_why ;
   struct __anonstruct_RE_vers_63 RE_vers ;
   struct __anonstruct_RE_lb_64 RE_lb ;
};
#line 103 "/usr/include/rpc/clnt.h"
struct rpc_err {
   enum clnt_stat re_status ;
   union __anonunion_ru_62 ru ;
};
#line 129
struct CLIENT;
#line 129 "/usr/include/rpc/clnt.h"
typedef struct CLIENT CLIENT;
#line 130 "/usr/include/rpc/clnt.h"
struct clnt_ops {
   enum clnt_stat (*cl_call)(CLIENT * , u_long  , bool_t (*)(XDR * , void *  , ...) ,
                             caddr_t  , bool_t (*)(XDR * , void *  , ...) , caddr_t  ,
                             struct timeval  ) ;
   void (*cl_abort)(void) ;
   void (*cl_geterr)(CLIENT * , struct rpc_err * ) ;
   bool_t (*cl_freeres)(CLIENT * , bool_t (*)(XDR * , void *  , ...) , caddr_t  ) ;
   void (*cl_destroy)(CLIENT * ) ;
   bool_t (*cl_control)(CLIENT * , int  , char * ) ;
};
#line 130 "/usr/include/rpc/clnt.h"
struct CLIENT {
   AUTH *cl_auth ;
   struct clnt_ops *cl_ops ;
   caddr_t cl_private ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
typedef char ut_line_t[33];
#line 86 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
typedef char ut_name_t[33];
#line 87 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
typedef char ut_host_t[257];
#line 380 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
union __anonunion_argument_74 {
   int fill ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
struct host_list {
   struct host_list *next ;
   struct in_addr addr ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
struct rstat_timeval {
   u_int tv_sec ;
   u_int tv_usec ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
typedef struct rstat_timeval rstat_timeval;
#line 33 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
struct statstime {
   int cp_time[4] ;
   int dk_xfer[4] ;
   u_int v_pgpgin ;
   u_int v_pgpgout ;
   u_int v_pswpin ;
   u_int v_pswpout ;
   u_int v_intr ;
   int if_ipackets ;
   int if_ierrors ;
   int if_oerrors ;
   int if_collisions ;
   u_int v_swtch ;
   int avenrun[3] ;
   rstat_timeval boottime ;
   rstat_timeval curtime ;
   int if_opackets ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
typedef struct statstime statstime;
#line 53 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
struct statsswtch {
   int cp_time[4] ;
   int dk_xfer[4] ;
   u_int v_pgpgin ;
   u_int v_pgpgout ;
   u_int v_pswpin ;
   u_int v_pswpout ;
   u_int v_intr ;
   int if_ipackets ;
   int if_ierrors ;
   int if_oerrors ;
   int if_collisions ;
   u_int v_swtch ;
   u_int avenrun[3] ;
   rstat_timeval boottime ;
   int if_opackets ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
typedef struct statsswtch statsswtch;
#line 72 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
struct stats {
   int cp_time[4] ;
   int dk_xfer[4] ;
   u_int v_pgpgin ;
   u_int v_pgpgout ;
   u_int v_pswpin ;
   u_int v_pswpout ;
   u_int v_intr ;
   int if_ipackets ;
   int if_ierrors ;
   int if_oerrors ;
   int if_collisions ;
   int if_opackets ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
typedef struct stats stats;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 99 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
struct rup_data {
   char *host ;
   struct statstime statstime ;
};
#line 107
enum sort_type {
    SORT_NONE = 0,
    SORT_HOST = 1,
    SORT_LDAV = 2,
    SORT_UPTIME = 3
} ;
#line 288 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_int)(XDR *__xdrs ,
                                                                                 int *__ip ) ;
#line 289
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_u_int)(XDR *__xdrs ,
                                                                                   u_int *__up ) ;
#line 290
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_long)(XDR *__xdrs ,
                                                                                  long *__lp ) ;
#line 308
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_array)(XDR *_xdrs ,
                                                                                   caddr_t *__addrp ,
                                                                                   u_int *__sizep ,
                                                                                   u_int __maxsize ,
                                                                                   u_int __elsize ,
                                                                                   bool_t (*__elproc)(XDR * ,
                                                                                                      void * 
                                                                                                      , ...) ) ;
#line 311
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_bytes)(XDR *__xdrs ,
                                                                                   char **__cpp ,
                                                                                   u_int *__sizep ,
                                                                                   u_int __maxsize ) ;
#line 314
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_string)(XDR *__xdrs ,
                                                                                    char **__cpp ,
                                                                                    u_int __maxsize ) ;
#line 324
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_reference)(XDR *__xdrs ,
                                                                                       caddr_t *__xpp ,
                                                                                       u_int __size ,
                                                                                       bool_t (*__proc)(XDR * ,
                                                                                                        void * 
                                                                                                        , ...) ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers.h"
 __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_utmparr)(XDR *xdrs ,
                                                                              struct utmparr *objp ) ;
#line 97
 __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_utmpidlearr)(XDR *xdrs ,
                                                                                  struct utmpidlearr *objp ) ;
#line 134
bool_t xdr_rusers_utmp(XDR *xdrs , rusers_utmp *objp ) ;
#line 135
bool_t xdr_utmp_array(XDR *xdrs , utmp_array *objp ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t xdr_rusers_utmp(XDR *xdrs , rusers_utmp *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;

  {
  {
#line 16
  tmp = xdr_string(xdrs, & objp->ut_user, (u_int )32);
  }
#line 16
  if (! tmp) {
#line 17
    return (0);
  }
  {
#line 18
  tmp___0 = xdr_string(xdrs, & objp->ut_line, (u_int )32);
  }
#line 18
  if (! tmp___0) {
#line 19
    return (0);
  }
  {
#line 20
  tmp___1 = xdr_string(xdrs, & objp->ut_host, (u_int )257);
  }
#line 20
  if (! tmp___1) {
#line 21
    return (0);
  }
  {
#line 22
  tmp___2 = xdr_int(xdrs, & objp->ut_type);
  }
#line 22
  if (! tmp___2) {
#line 23
    return (0);
  }
  {
#line 24
  tmp___3 = xdr_int(xdrs, & objp->ut_time);
  }
#line 24
  if (! tmp___3) {
#line 25
    return (0);
  }
  {
#line 26
  tmp___4 = xdr_u_int(xdrs, & objp->ut_idle);
  }
#line 26
  if (! tmp___4) {
#line 27
    return (0);
  }
#line 28
  return (1);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t xdr_utmp_array(XDR *xdrs , utmp_array *objp ) 
{ 
  bool_t tmp ;

  {
  {
#line 36
  tmp = xdr_array(xdrs, (char **)(& objp->utmp_array_val), & objp->utmp_array_len,
                  (u_int )(~ 0), (u_int )sizeof(rusers_utmp ), (bool_t (*)(XDR * ,
                                                                           void * 
                                                                           , ...))(& xdr_rusers_utmp));
  }
#line 36
  if (! tmp) {
#line 38
    return (0);
  }
#line 39
  return (1);
}
}
#line 41
bool_t xdr_utmp(XDR *xdrs , struct ru_utmp *objp ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t xdr_utmp(XDR *xdrs , struct ru_utmp *objp ) 
{ 
  char *ptr ;
  unsigned int size ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;

  {
#line 49
  if ((unsigned int )xdrs->x_op != 2U) {
    {
#line 53
    ptr = objp->ut_line;
#line 54
    size = (unsigned int )sizeof(objp->ut_line);
#line 55
    tmp = xdr_bytes(xdrs, & ptr, & size, size);
    }
#line 55
    if (! tmp) {
#line 56
      return (0);
    }
    {
#line 58
    ptr = objp->ut_name;
#line 59
    size = (unsigned int )sizeof(objp->ut_name);
#line 60
    tmp___0 = xdr_bytes(xdrs, & ptr, & size, size);
    }
#line 60
    if (! tmp___0) {
#line 61
      return (0);
    }
    {
#line 63
    ptr = objp->ut_host;
#line 64
    size = (unsigned int )sizeof(objp->ut_host);
#line 65
    tmp___1 = xdr_bytes(xdrs, & ptr, & size, size);
    }
#line 65
    if (! tmp___1) {
#line 66
      return (0);
    }
  }
  {
#line 69
  tmp___2 = xdr_long(xdrs, & objp->ut_time);
  }
#line 69
  if (! tmp___2) {
#line 70
    return (0);
  }
#line 72
  return (1);
}
}
#line 75
bool_t xdr_utmpptr(XDR *xdrs , struct ru_utmp **objpp ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t xdr_utmpptr(XDR *xdrs , struct ru_utmp **objpp ) 
{ 
  bool_t tmp ;

  {
  {
#line 82
  tmp = xdr_reference(xdrs, (char **)objpp, (u_int )sizeof(struct ru_utmp ), (bool_t (*)(XDR * ,
                                                                                         void * 
                                                                                         , ...))(& xdr_utmp));
  }
#line 82
  if (! tmp) {
#line 84
    return (0);
  }
#line 86
  return (1);
}
}
#line 89
 __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_utmparr)(XDR *xdrs ,
                                                                              struct utmparr *objp ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t ( __attribute__((__leaf__)) xdr_utmparr)(XDR *xdrs , struct utmparr *objp ) 
{ 
  bool_t tmp ;

  {
  {
#line 94
  tmp = xdr_array(xdrs, (char **)(& objp->uta_arr), (u_int *)(& objp->uta_cnt), (u_int )100,
                  (u_int )sizeof(struct ru_utmp *), (bool_t (*)(XDR * , void *  , ...))(& xdr_utmpptr));
  }
#line 94
  if (! tmp) {
#line 97
    return (0);
  }
#line 99
  return (1);
}
}
#line 102
bool_t xdr_utmpidle(XDR *xdrs , struct utmpidle *objp ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t xdr_utmpidle(XDR *xdrs , struct utmpidle *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 109
  tmp = xdr_utmp(xdrs, & objp->ui_utmp);
  }
#line 109
  if (! tmp) {
#line 110
    return (0);
  }
  {
#line 112
  tmp___0 = xdr_u_int(xdrs, & objp->ui_idle);
  }
#line 112
  if (! tmp___0) {
#line 113
    return (0);
  }
#line 115
  return (1);
}
}
#line 118
bool_t xdr_utmpidleptr(XDR *xdrs , struct utmpidle **objpp ) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t xdr_utmpidleptr(XDR *xdrs , struct utmpidle **objpp ) 
{ 
  bool_t tmp ;

  {
  {
#line 125
  tmp = xdr_reference(xdrs, (char **)objpp, (u_int )sizeof(struct utmpidle ), (bool_t (*)(XDR * ,
                                                                                          void * 
                                                                                          , ...))(& xdr_utmpidle));
  }
#line 125
  if (! tmp) {
#line 127
    return (0);
  }
#line 129
  return (1);
}
}
#line 132
 __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_utmpidlearr)(XDR *xdrs ,
                                                                                  struct utmpidlearr *objp ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_xdr.c"
bool_t ( __attribute__((__leaf__)) xdr_utmpidlearr)(XDR *xdrs , struct utmpidlearr *objp ) 
{ 
  bool_t tmp ;

  {
  {
#line 137
  tmp = xdr_array(xdrs, (char **)(& objp->uia_arr), (u_int *)(& objp->uia_cnt), (u_int )100,
                  (u_int )sizeof(struct utmpidle *), (bool_t (*)(XDR * , void *  , ...))(& xdr_utmpidleptr));
  }
#line 137
  if (! tmp) {
#line 140
    return (0);
  }
#line 142
  return (1);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusersd.c"
char rusersd_rcsid[57]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusersd.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'s', 
        (char )'e',      (char )'r',      (char )'s',      (char )'d', 
        (char )'.',      (char )'c',      (char )',',      (char )'v', 
        (char )' ',      (char )'1',      (char )'.',      (char )'1', 
        (char )'0',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'0',      (char )'/',      (char )'0', 
        (char )'7',      (char )'/',      (char )'2',      (char )'3', 
        (char )' ',      (char )'0',      (char )'4',      (char )':', 
        (char )'0',      (char )'9',      (char )':',      (char )'2', 
        (char )'8',      (char )' ',      (char )'d',      (char )'h', 
        (char )'o',      (char )'l',      (char )'l',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'E', 
        (char )'x',      (char )'p',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 188 "/usr/include/rpc/svc.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) svc_register)(SVCXPRT *__xprt ,
                                                                                      rpcprog_t __prog ,
                                                                                      rpcvers_t __vers ,
                                                                                      void (*__dispatch)(struct svc_req * ,
                                                                                                         SVCXPRT * ) ,
                                                                                      rpcprot_t __protocol ) ;
#line 292
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svc_run)(void) ;
#line 311
extern  __attribute__((__nothrow__)) SVCXPRT *( __attribute__((__leaf__)) svcudp_create)(int __sock ) ;
#line 71 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) pmap_unset)(u_long const   __program ,
                                                                                    u_long const   __vers ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/../version.h"
char pkg[30]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/../version.h"
  {      (char )'$',      (char )'N',      (char )'e',      (char )'t', 
        (char )'K',      (char )'i',      (char )'t',      (char )':', 
        (char )' ',      (char )'n',      (char )'e',      (char )'t', 
        (char )'k',      (char )'i',      (char )'t',      (char )'-', 
        (char )'r',      (char )'u',      (char )'s',      (char )'e', 
        (char )'r',      (char )'s',      (char )'-',      (char )'0', 
        (char )'.',      (char )'1',      (char )'7',      (char )' ', 
        (char )'$',      (char )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusersd.c"
void rusers_service(struct svc_req *rqstp , SVCXPRT *transp ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusersd.c"
int from_inetd  =    1;
#line 54 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusersd.c"
static void cleanup(int ignore ) 
{ 


  {
  {
#line 60
  pmap_unset((u_long const   )100002, (u_long const   )3);
#line 61
  pmap_unset((u_long const   )100002, (u_long const   )2);
#line 62
  exit(0);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusersd.c"
int main(void) 
{ 
  SVCXPRT *transp ;
  int sock ;
  int proto ;
  struct sockaddr_in from ;
  int fromlen ;
  struct passwd *pw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  bool_t tmp___5 ;
  char const   *tmp___6 ;
  bool_t tmp___7 ;

  {
  {
#line 69
  sock = 0;
#line 70
  proto = 0;
#line 72
  fromlen = (int )sizeof(from);
#line 76
  openlog("rpc.rusersd", 1, 3 << 3);
#line 79
  tmp___2 = getuid();
  }
#line 79
  if (tmp___2 == 0U) {
    {
#line 82
    pw = getpwnam("nobody");
    }
#line 82
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 83
      syslog(4, "Unable to find user nobody: %m");
#line 84
      exit(1);
      }
    }
    {
#line 86
    tmp = setgroups((size_t )1, (__gid_t const   *)(& pw->pw_gid));
    }
#line 86
    if (tmp < 0) {
      {
#line 89
      syslog(4, "Failed to drop privilege: %m");
#line 90
      exit(1);
      }
    } else {
      {
#line 86
      tmp___0 = setgid(pw->pw_gid);
      }
#line 86
      if (tmp___0 < 0) {
        {
#line 89
        syslog(4, "Failed to drop privilege: %m");
#line 90
        exit(1);
        }
      } else {
        {
#line 86
        tmp___1 = setuid(pw->pw_uid);
        }
#line 86
        if (tmp___1 < 0) {
          {
#line 89
          syslog(4, "Failed to drop privilege: %m");
#line 90
          exit(1);
          }
        }
      }
    }
  }
  {
#line 98
  tmp___3 = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                        (socklen_t */* __restrict  */)(& fromlen));
  }
#line 98
  if (tmp___3 < 0) {
#line 99
    from_inetd = 0;
#line 100
    sock = -1;
#line 101
    proto = 17;
  }
#line 104
  if (! from_inetd) {
    {
#line 105
    daemon(0, 0);
#line 107
    pmap_unset((u_long const   )100002, (u_long const   )3);
#line 108
    pmap_unset((u_long const   )100002, (u_long const   )2);
#line 110
    signal(2, & cleanup);
#line 111
    signal(15, & cleanup);
#line 112
    signal(1, & cleanup);
    }
  }
  {
#line 115
  openlog("rpc.rusersd", 1, 3 << 3);
#line 117
  transp = svcudp_create(sock);
  }
#line 118
  if ((unsigned long )transp == (unsigned long )((void *)0)) {
    {
#line 119
    syslog(3, "cannot create udp service.");
#line 120
    exit(1);
    }
  }
  {
#line 122
  tmp___5 = svc_register(transp, (rpcprog_t )100002, (rpcvers_t )3, & rusers_service,
                         (rpcprot_t )proto);
  }
#line 122
  if (! tmp___5) {
#line 123
    if (proto) {
#line 123
      tmp___4 = "udp";
    } else {
#line 123
      tmp___4 = "(inetd)";
    }
    {
#line 123
    syslog(3, "unable to register (RUSERSPROG, RUSERSVERS_3, %s).", tmp___4);
#line 124
    exit(1);
    }
  }
  {
#line 127
  tmp___7 = svc_register(transp, (rpcprog_t )100002, (rpcvers_t )2, & rusers_service,
                         (rpcprot_t )proto);
  }
#line 127
  if (! tmp___7) {
#line 128
    if (proto) {
#line 128
      tmp___6 = "udp";
    } else {
#line 128
      tmp___6 = "(inetd)";
    }
    {
#line 128
    syslog(3, "unable to register (RUSERSPROG, RUSERSVERS_IDLE, %s).", tmp___6);
#line 129
    exit(1);
    }
  }
  {
#line 132
  svc_run();
#line 133
  syslog(3, "svc_run returned");
#line 134
  exit(1);
  }
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
char rp_rcsid[61]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'s', 
        (char )'e',      (char )'r',      (char )'s',      (char )'_', 
        (char )'p',      (char )'r',      (char )'o',      (char )'c', 
        (char )'.',      (char )'c',      (char )',',      (char )'v', 
        (char )' ',      (char )'1',      (char )'.',      (char )'1', 
        (char )'6',      (char )' ',      (char )'2',      (char )'0', 
        (char )'0',      (char )'0',      (char )'/',      (char )'0', 
        (char )'7',      (char )'/',      (char )'2',      (char )'3', 
        (char )' ',      (char )'0',      (char )'3',      (char )':', 
        (char )'1',      (char )'1',      (char )':',      (char )'5', 
        (char )'6',      (char )' ',      (char )'d',      (char )'h', 
        (char )'o',      (char )'l',      (char )'l',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'E', 
        (char )'x',      (char )'p',      (char )' ',      (char )'$', 
        (char )'\000'};
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 62 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) getutent)(void) ;
#line 65
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setutent)(void) ;
#line 68
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endutent)(void) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 285 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_void)(void) ;
#line 244 "/usr/include/rpc/svc.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) svc_sendreply)(SVCXPRT *__xprt ,
                                                                                       bool_t (*__xdr_results)(XDR * ,
                                                                                                               void * 
                                                                                                               , ...) ,
                                                                                       caddr_t __xdr_location ) ;
#line 247
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_decode)(SVCXPRT *__xprt ) ;
#line 251
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_noproc)(SVCXPRT *__xprt ) ;
#line 253
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_progvers)(SVCXPRT *__xprt ,
                                                                                       rpcvers_t __low_vers ,
                                                                                       rpcvers_t __high_vers ) ;
#line 260
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) svcerr_systemerr)(SVCXPRT *__xprt ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 111 "/usr/include/rpcsvc/rusers.h"
utmp_array *rusersproc_names_3(void *tmp1 , CLIENT *tmp2 ) ;
#line 114
utmp_array *rusersproc_allnames_3(void *tmp1 , CLIENT *tmp2 ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
struct rusers_utmp utmps[100]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
struct utmpidle *utmp_idlep[100]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
struct utmpidle utmp_idle[100]  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
ut_line_t line[100]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
ut_name_t name[100]  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
ut_host_t host[100]  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static u_int getidle(char *tty , char *display ) 
{ 
  struct stat st ;
  char devname[4096] ;
  time_t now ;
  long idletime ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 161
  tmp = strstr((char const   *)tty, "../");
  }
#line 161
  if (tmp) {
#line 162
    return ((u_int )0);
  }
  {
#line 172
  idletime = 0L;
#line 190
  snprintf((char */* __restrict  */)(devname), sizeof(devname), (char const   */* __restrict  */)"%s/%s",
           "/dev/", tty);
#line 191
  tmp___0 = stat((char const   */* __restrict  */)(devname), (struct stat */* __restrict  */)(& st));
  }
#line 191
  if (tmp___0 < 0) {
#line 195
    return ((u_int )-1);
  }
  {
#line 197
  time(& now);
  }
#line 202
  if (now < st.st_atim.tv_sec) {
#line 202
    idletime = 0L;
  } else {
#line 203
    idletime = now - st.st_atim.tv_sec;
  }
#line 204
  idletime = (idletime + 30L) / 60L;
#line 209
  return ((u_int )idletime);
}
}
#line 216
static char *rusers_num(void *ign1 , struct svc_req *ign2 ) ;
#line 216 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static int num_users  =    0;
#line 212 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static char *rusers_num(void *ign1 , struct svc_req *ign2 ) 
{ 
  struct utmp *uptr ;
  int tmp ;

  {
  {
#line 220
  num_users = 0;
#line 223
  setutent();
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 224
    uptr = getutent();
    }
#line 224
    if (! ((unsigned long )uptr != (unsigned long )((void *)0))) {
#line 224
      goto while_break;
    }
#line 225
    if (uptr->ut_user[0]) {
#line 225
      if (uptr->ut_line[0]) {
        {
#line 225
        tmp = strncmp((char const   *)(uptr->ut_user), "sleeper", sizeof(uptr->ut_user));
        }
#line 225
        if (tmp) {
#line 225
          if ((int )uptr->ut_type == 7) {
#line 232
            num_users ++;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  endutent();
  }
#line 236
  return ((char *)(& num_users));
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static utmp_array ut  ;
#line 239 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static utmp_array *do_names_3(int all ) 
{ 
  struct utmp *uptr ;
  int nusers ;
  int tmp ;

  {
  {
#line 244
  nusers = 0;
#line 248
  memset((void *)(& ut), 0, sizeof(ut));
#line 249
  ut.utmp_array_val = & utmps[0];
#line 253
  setutent();
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 254
    uptr = getutent();
    }
#line 254
    if ((unsigned long )uptr != (unsigned long )((void *)0)) {
#line 254
      if (! (nusers < 100)) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
#line 255
    if (uptr->ut_user[0]) {
#line 255
      if (uptr->ut_line[0]) {
        {
#line 255
        tmp = strncmp((char const   *)(uptr->ut_user), "sleeper", sizeof(uptr->ut_user));
        }
#line 255
        if (tmp) {
#line 255
          if ((int )uptr->ut_type == 7) {
            {
#line 262
            utmps[nusers].ut_type = 7;
#line 263
            utmps[nusers].ut_time = uptr->ut_tv.tv_sec;
#line 265
            utmps[nusers].ut_idle = getidle(uptr->ut_line, uptr->ut_host);
#line 267
            utmps[nusers].ut_line = line[nusers];
#line 268
            strncpy((char */* __restrict  */)(line[nusers]), (char const   */* __restrict  */)(uptr->ut_line),
                    sizeof(line[nusers]));
#line 270
            line[nusers][sizeof(line[nusers]) - 1UL] = (char)0;
#line 271
            utmps[nusers].ut_user = name[nusers];
#line 272
            strncpy((char */* __restrict  */)(name[nusers]), (char const   */* __restrict  */)(uptr->ut_user),
                    sizeof(name[nusers]));
#line 274
            name[nusers][sizeof(name[nusers]) - 1UL] = (char)0;
#line 275
            utmps[nusers].ut_host = host[nusers];
#line 276
            strncpy((char */* __restrict  */)(host[nusers]), (char const   */* __restrict  */)(uptr->ut_host),
                    sizeof(host[nusers]));
#line 278
            host[nusers][sizeof(host[nusers]) - 1UL] = (char)0;
#line 280
            line[nusers][32] = (char )'\000';
#line 281
            name[nusers][32] = (char )'\000';
#line 282
            host[nusers][256] = (char )'\000';
#line 284
            nusers ++;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  ut.utmp_array_len = (u_int )nusers;
#line 289
  endutent();
  }
#line 290
  return (& ut);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
utmp_array *rusersproc_names_3(void *tmp1 , CLIENT *tmp2 ) 
{ 
  utmp_array *tmp ;

  {
  {
#line 298
  tmp = do_names_3(0);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
utmp_array *rusersproc_allnames_3(void *tmp1 , CLIENT *tmp2 ) 
{ 
  utmp_array *tmp ;

  {
  {
#line 306
  tmp = do_names_3(1);
  }
#line 306
  return (tmp);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static void do_strncpy(char *tgt , char const   *src , size_t len ) 
{ 


  {
  {
#line 310
  strncpy((char */* __restrict  */)tgt, (char const   */* __restrict  */)src, len);
#line 311
  *(tgt + (len - 1UL)) = (char)0;
  }
#line 312
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static struct utmpidlearr ut___0  ;
#line 314 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static struct utmpidlearr *do_names_2(int all ) 
{ 
  struct utmp *uptr ;
  int nusers ;
  int tmp ;

  {
  {
#line 320
  nusers = 0;
#line 324
  memset((void *)(& ut___0), 0, sizeof(ut___0));
#line 325
  ut___0.uia_arr = utmp_idlep;
#line 326
  ut___0.uia_cnt = 0;
#line 330
  setutent();
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 331
    uptr = getutent();
    }
#line 331
    if ((unsigned long )uptr != (unsigned long )((void *)0)) {
#line 331
      if (! (nusers < 100)) {
#line 331
        goto while_break;
      }
    } else {
#line 331
      goto while_break;
    }
#line 332
    if (uptr->ut_user[0]) {
#line 332
      if (uptr->ut_line[0]) {
        {
#line 332
        tmp = strncmp((char const   *)(uptr->ut_user), "sleeper", sizeof(uptr->ut_user));
        }
#line 332
        if (tmp) {
#line 332
          if ((int )uptr->ut_type == 7) {
            {
#line 339
            utmp_idlep[nusers] = & utmp_idle[nusers];
#line 340
            utmp_idle[nusers].ui_utmp.ut_time = (long )uptr->ut_tv.tv_sec;
#line 342
            utmp_idle[nusers].ui_idle = getidle(uptr->ut_line, uptr->ut_host);
#line 344
            do_strncpy(utmp_idle[nusers].ui_utmp.ut_line, (char const   *)(uptr->ut_line),
                       sizeof(utmp_idle[nusers].ui_utmp.ut_line));
#line 348
            strncpy((char */* __restrict  */)(utmp_idle[nusers].ui_utmp.ut_name),
                    (char const   */* __restrict  */)(uptr->ut_user), sizeof(utmp_idle[nusers].ui_utmp.ut_name));
#line 351
            do_strncpy(utmp_idle[nusers].ui_utmp.ut_host, (char const   *)(uptr->ut_host),
                       sizeof(utmp_idle[nusers].ui_utmp.ut_host));
#line 354
            nusers ++;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 358
  ut___0.uia_cnt = nusers;
#line 359
  endutent();
  }
#line 360
  return (& ut___0);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static char *rusersproc_names_2(void) 
{ 
  struct utmpidlearr *tmp ;

  {
  {
#line 367
  tmp = do_names_2(0);
  }
#line 367
  return ((char *)tmp);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
static char *rusersproc_allnames_2(void) 
{ 
  struct utmpidlearr *tmp ;

  {
  {
#line 374
  tmp = do_names_2(1);
  }
#line 374
  return ((char *)tmp);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rpc.rusersd/rusers_proc.c"
void rusers_service(struct svc_req *rqstp , SVCXPRT *transp ) 
{ 
  union __anonunion_argument_74 argument ;
  char *result ;
  bool_t (*xdr_argument)(void) ;
  bool_t (*xdr_result)(XDR * , void *  , ...) ;
  char *(*local)(void * , struct svc_req * ) ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;

  {
  {
#line 390
  if (rqstp->rq_proc == 0UL) {
#line 390
    goto case_0;
  }
#line 394
  if (rqstp->rq_proc == 1UL) {
#line 394
    goto case_1;
  }
#line 408
  if (rqstp->rq_proc == 2UL) {
#line 408
    goto case_2___0;
  }
#line 428
  if (rqstp->rq_proc == 3UL) {
#line 428
    goto case_3___1;
  }
#line 448
  goto switch_default___2;
  case_0: /* CIL Label */ 
  {
#line 391
  svc_sendreply(transp, (bool_t (*)(XDR * , void *  , ...))(& xdr_void), (caddr_t )((void *)0));
  }
#line 392
  goto leave;
  case_1: /* CIL Label */ 
#line 395
  xdr_argument = (bool_t (*)(void))(& xdr_void);
#line 396
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_int);
  {
#line 399
  if (rqstp->rq_vers == 2UL) {
#line 399
    goto case_2;
  }
#line 399
  if (rqstp->rq_vers == 3UL) {
#line 399
    goto case_2;
  }
#line 402
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 400
  local = & rusers_num;
#line 401
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 403
  svcerr_progvers(transp, (rpcvers_t )2, (rpcvers_t )3);
  }
#line 404
  goto leave;
  switch_break___0: /* CIL Label */ ;
  }
#line 406
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 409
  xdr_argument = (bool_t (*)(void))(& xdr_void);
#line 410
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_utmp_array);
  {
#line 412
  if (rqstp->rq_vers == 3UL) {
#line 412
    goto case_3___0;
  }
#line 416
  if (rqstp->rq_vers == 2UL) {
#line 416
    goto case_2___1;
  }
#line 421
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
#line 413
  local = (char *(*)(void * , struct svc_req * ))(& rusersproc_names_3);
#line 414
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 417
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_utmpidlearr);
#line 418
  local = (char *(*)(void * , struct svc_req * ))(& rusersproc_names_2);
#line 419
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 422
  svcerr_progvers(transp, (rpcvers_t )2, (rpcvers_t )3);
  }
#line 423
  goto leave;
  switch_break___1: /* CIL Label */ ;
  }
#line 426
  goto switch_break;
  case_3___1: /* CIL Label */ 
#line 429
  xdr_argument = (bool_t (*)(void))(& xdr_void);
#line 430
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_utmp_array);
  {
#line 432
  if (rqstp->rq_vers == 3UL) {
#line 432
    goto case_3___2;
  }
#line 436
  if (rqstp->rq_vers == 2UL) {
#line 436
    goto case_2___2;
  }
#line 441
  goto switch_default___1;
  case_3___2: /* CIL Label */ 
#line 433
  local = (char *(*)(void * , struct svc_req * ))(& rusersproc_allnames_3);
#line 434
  goto switch_break___2;
  case_2___2: /* CIL Label */ 
#line 437
  xdr_result = (bool_t (*)(XDR * , void *  , ...))(& xdr_utmpidlearr);
#line 438
  local = (char *(*)(void * , struct svc_req * ))(& rusersproc_allnames_2);
#line 439
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 442
  svcerr_progvers(transp, (rpcvers_t )2, (rpcvers_t )3);
  }
#line 443
  goto leave;
  switch_break___2: /* CIL Label */ ;
  }
#line 446
  goto switch_break;
  switch_default___2: /* CIL Label */ 
  {
#line 449
  svcerr_noproc(transp);
  }
#line 450
  goto leave;
  switch_break: /* CIL Label */ ;
  }
  {
#line 452
  memset((void *)(& argument), 0, sizeof(argument));
#line 453
  tmp = (*((transp->xp_ops)->xp_getargs))(transp, (bool_t (*)(XDR * , void *  , ...))xdr_argument,
                                          (char *)(& argument));
  }
#line 453
  if (! tmp) {
    {
#line 454
    svcerr_decode(transp);
    }
#line 455
    goto leave;
  }
  {
#line 457
  result = (*local)((void *)(& argument), rqstp);
  }
#line 458
  if ((unsigned long )result != (unsigned long )((void *)0)) {
    {
#line 458
    tmp___0 = svc_sendreply(transp, xdr_result, result);
    }
#line 458
    if (! tmp___0) {
      {
#line 460
      svcerr_systemerr(transp);
      }
    }
  }
  {
#line 462
  tmp___1 = (*((transp->xp_ops)->xp_freeargs))(transp, (bool_t (*)(XDR * , void * 
                                                                   , ...))xdr_argument,
                                               (char *)(& argument));
  }
#line 462
  if (! tmp___1) {
    {
#line 463
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to free arguments\n");
#line 464
    exit(1);
    }
  }
  leave: 
#line 467
  if (from_inetd) {
    {
#line 468
    exit(0);
    }
  }
#line 469
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
char rusers_rcsid[56]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'s', 
        (char )'e',      (char )'r',      (char )'s',      (char )'.', 
        (char )'c',      (char )',',      (char )'v',      (char )' ', 
        (char )'1',      (char )'.',      (char )'1',      (char )'7', 
        (char )' ',      (char )'1',      (char )'9',      (char )'9', 
        (char )'9',      (char )'/',      (char )'1',      (char )'2', 
        (char )'/',      (char )'1',      (char )'2',      (char )' ', 
        (char )'1',      (char )'9',      (char )':',      (char )'3', 
        (char )'2',      (char )':',      (char )'0',      (char )'5', 
        (char )' ',      (char )'d',      (char )'h',      (char )'o', 
        (char )'l',      (char )'l',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'E',      (char )'x', 
        (char )'p',      (char )' ',      (char )'$',      (char )'\000'};
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 291 "/usr/include/rpc/clnt.h"
extern  __attribute__((__nothrow__)) CLIENT *( __attribute__((__leaf__)) clnt_create)(char const   *__host ,
                                                                                      u_long const   __prog ,
                                                                                      u_long const   __vers ,
                                                                                      char const   *__prot ) ;
#line 368
extern void clnt_pcreateerror(char const   *__msg ) ;
#line 379
extern void clnt_perror(CLIENT *__clnt , char const   *__msg ) ;
#line 399
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) clnt_sperrno)(enum clnt_stat __num ) ;
#line 82 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) enum clnt_stat ( __attribute__((__leaf__)) clnt_broadcast)(u_long const   __prog ,
                                                                                                u_long const   __vers ,
                                                                                                u_long const   __proc ,
                                                                                                bool_t (*__xargs)(XDR * ,
                                                                                                                  void * 
                                                                                                                  , ...) ,
                                                                                                caddr_t __argsp ,
                                                                                                bool_t (*__xresults)(XDR * ,
                                                                                                                     void * 
                                                                                                                     , ...) ,
                                                                                                caddr_t __resultsp ,
                                                                                                bool_t (*__eachresult)(caddr_t __resp ,
                                                                                                                       struct sockaddr_in *__raddr ) ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
char *argv0  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
struct timeval timeout  =    {(__time_t )25, (__suseconds_t )0};
#line 75 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
int longopt  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
int allopt  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
struct host_list *hosts  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
static int search_host(struct in_addr addr ) 
{ 
  struct host_list *hp ;

  {
#line 89
  if (! hosts) {
#line 90
    return (0);
  }
#line 92
  hp = hosts;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 92
      goto while_break;
    }
#line 93
    if (hp->addr.s_addr == addr.s_addr) {
#line 94
      return (1);
    }
#line 92
    hp = hp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (0);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
static void remember_host(struct in_addr addr ) 
{ 
  struct host_list *hp ;
  void *tmp ;

  {
  {
#line 105
  tmp = malloc(sizeof(struct host_list ));
#line 105
  hp = (struct host_list *)tmp;
  }
#line 105
  if (! hp) {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no memory.\n",
            argv0);
#line 107
    exit(1);
    }
  }
#line 109
  hp->addr.s_addr = addr.s_addr;
#line 110
  hp->next = hosts;
#line 111
  hosts = hp;
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
static int rusers_reply(char *replyp , struct sockaddr_in *raddrp ) 
{ 
  int x ;
  int idlee ;
  char date[32] ;
  char idle_time[64] ;
  char remote[64] ;
  char local[64] ;
  struct hostent *hp ;
  struct utmpidlearr *up ;
  char const   *host___0 ;
  int days ;
  int hours ;
  int minutes ;
  int seconds ;
  int tmp ;
  char *tmp___0 ;
  time_t tmptime ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int len1 ;
  size_t tmp___3 ;
  int len2 ;
  size_t tmp___4 ;
  int excess ;

  {
  {
#line 121
  up = (struct utmpidlearr *)replyp;
#line 125
  tmp = search_host(raddrp->sin_addr);
  }
#line 125
  if (tmp) {
#line 126
    return (0);
  }
#line 128
  if (! allopt) {
#line 128
    if (! up->uia_cnt) {
#line 129
      return (0);
    }
  }
  {
#line 131
  hp = gethostbyaddr((void const   *)((char *)(& raddrp->sin_addr.s_addr)), (__socklen_t )sizeof(struct in_addr ),
                     2);
  }
#line 133
  if (hp) {
#line 134
    host___0 = (char const   *)hp->h_name;
  } else {
    {
#line 136
    tmp___0 = inet_ntoa(raddrp->sin_addr);
#line 136
    host___0 = (char const   *)tmp___0;
    }
  }
#line 138
  if (! longopt) {
    {
#line 139
    printf((char const   */* __restrict  */)"%-*.*s ", 20, 20, host___0);
    }
  }
#line 141
  x = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (x < up->uia_cnt)) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmptime = (*(up->uia_arr + x))->ui_utmp.ut_time;
#line 143
    tmp___1 = ctime((time_t const   *)(& tmptime));
#line 143
    strncpy((char */* __restrict  */)(date), (char const   */* __restrict  */)(tmp___1 + 4),
            sizeof(date) - 1UL);
#line 144
    date[sizeof(date) - 1UL] = (char)0;
#line 146
    idlee = (int )(*(up->uia_arr + x))->ui_idle;
#line 147
    snprintf((char */* __restrict  */)(idle_time), sizeof(idle_time), (char const   */* __restrict  */)"   :%02d",
             idlee);
    }
#line 148
    if (idlee == 2147483647) {
      {
#line 149
      strcpy((char */* __restrict  */)(idle_time), (char const   */* __restrict  */)"??");
      }
    } else
#line 150
    if (idlee == 0) {
      {
#line 151
      strcpy((char */* __restrict  */)(idle_time), (char const   */* __restrict  */)"");
      }
    } else {
#line 153
      seconds = idlee;
#line 154
      days = seconds / 86400;
#line 155
      seconds %= 86400;
#line 156
      hours = seconds / 3600;
#line 157
      seconds %= 3600;
#line 158
      minutes = seconds / 60;
#line 159
      seconds %= 60;
#line 160
      if (idlee > 60) {
        {
#line 161
        snprintf((char */* __restrict  */)(idle_time), sizeof(idle_time), (char const   */* __restrict  */)"%2d:%02d",
                 minutes, seconds);
        }
      }
#line 163
      if (idlee >= 3600) {
        {
#line 164
        snprintf((char */* __restrict  */)(idle_time), sizeof(idle_time), (char const   */* __restrict  */)"%2d:%02d:%02d",
                 hours, minutes, seconds);
        }
      }
#line 167
      if (idlee >= 86400) {
        {
#line 168
        snprintf((char */* __restrict  */)(idle_time), sizeof(idle_time), (char const   */* __restrict  */)"%d days, %d:%02d:%02d",
                 days, hours, minutes, seconds);
        }
      }
    }
    {
#line 173
    strncpy((char */* __restrict  */)(remote), (char const   */* __restrict  */)((*(up->uia_arr + x))->ui_utmp.ut_host),
            sizeof(remote) - 1UL);
#line 175
    remote[sizeof(remote) - 1UL] = (char)0;
#line 177
    tmp___2 = strlen((char const   *)(remote));
    }
#line 177
    if (tmp___2 != 0UL) {
      {
#line 178
      snprintf((char */* __restrict  */)(remote), sizeof(remote), (char const   */* __restrict  */)"(%.16s)",
               (*(up->uia_arr + x))->ui_utmp.ut_host);
      }
    }
#line 181
    if (longopt) {
      {
#line 183
      tmp___3 = strlen(host___0);
#line 183
      len1 = (int )tmp___3;
#line 184
      tmp___4 = strlen((char const   *)((*(up->uia_arr + x))->ui_utmp.ut_line));
#line 184
      len2 = (int )tmp___4;
      }
#line 185
      if (len1 + len2 > 29) {
#line 186
        excess = (((len1 + len2) - 20) - 8) - 1;
#line 187
        if (excess < len1) {
#line 187
          len1 -= excess;
        } else
#line 188
        if (excess < len2) {
#line 188
          len2 -= excess;
        } else {
#line 191
          len1 = 20;
#line 192
          len2 = 8;
        }
      }
      {
#line 195
      snprintf((char */* __restrict  */)(local), sizeof(local), (char const   */* __restrict  */)"%-.*s:%-.*s",
               len1, host___0, len2, (*(up->uia_arr + x))->ui_utmp.ut_line);
#line 199
      printf((char const   */* __restrict  */)"%-8.8s %-*.*s %-12.12s %8s %.18s\n",
             (*(up->uia_arr + x))->ui_utmp.ut_name, 29, 29, local, date, idle_time,
             remote);
      }
    } else {
      {
#line 206
      printf((char const   */* __restrict  */)"%.8s ", (*(up->uia_arr + x))->ui_utmp.ut_name);
      }
    }
#line 141
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (! longopt) {
    {
#line 210
    putchar('\n');
    }
  }
  {
#line 212
  remember_host(raddrp->sin_addr);
  }
#line 213
  return (0);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
static void onehost(char *host___0 ) 
{ 
  struct utmpidlearr up ;
  CLIENT *rusers_clnt ;
  struct sockaddr_in addr ;
  struct hostent *hp ;
  enum clnt_stat tmp ;

  {
  {
#line 225
  hp = gethostbyname((char const   *)host___0);
  }
#line 226
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown host \"%s\"\n",
            argv0, host___0);
#line 229
    exit(1);
    }
  }
  {
#line 232
  rusers_clnt = clnt_create((char const   *)host___0, (u_long const   )100002, (u_long const   )2,
                            "udp");
  }
#line 233
  if ((unsigned long )rusers_clnt == (unsigned long )((void *)0)) {
    {
#line 234
    clnt_pcreateerror((char const   *)argv0);
#line 235
    exit(1);
    }
  }
  {
#line 238
  memset((void *)(& up), 0, sizeof(up));
#line 239
  memset((void *)(& addr), 0, sizeof(addr));
#line 240
  tmp = (*((rusers_clnt->cl_ops)->cl_call))(rusers_clnt, (u_long )2, (bool_t (*)(XDR * ,
                                                                                 void * 
                                                                                 , ...))(& xdr_void),
                                            (caddr_t )((void *)0), (bool_t (*)(XDR * ,
                                                                               void * 
                                                                               , ...))(& xdr_utmpidlearr),
                                            (char *)(& up), timeout);
  }
#line 240
  if ((unsigned int )tmp != 0U) {
    {
#line 242
    clnt_perror(rusers_clnt, (char const   *)argv0);
#line 243
    exit(1);
    }
  }
#line 245
  if (hp->h_length > (int )sizeof(addr.sin_addr)) {
#line 246
    hp->h_length = (int )sizeof(addr.sin_addr);
  }
  {
#line 248
  memcpy((void */* __restrict  */)(& addr.sin_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
         (size_t )hp->h_length);
#line 249
  rusers_reply((char *)(& up), & addr);
  }
#line 250
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
static void allhosts(void) 
{ 
  struct utmpidlearr up ;
  enum clnt_stat clnt_stat ;
  char *tmp ;

  {
  {
#line 259
  bzero((void *)((char *)(& up)), sizeof(up));
#line 260
  clnt_stat = clnt_broadcast((u_long const   )100002, (u_long const   )2, (u_long const   )2,
                             (bool_t (*)(XDR * , void *  , ...))(& xdr_void), (caddr_t )((void *)0),
                             (bool_t (*)(XDR * , void *  , ...))(& xdr_utmpidlearr),
                             (char *)(& up), & rusers_reply);
  }
#line 266
  if ((unsigned int )clnt_stat != 0U) {
#line 266
    if ((unsigned int )clnt_stat != 5U) {
      {
#line 267
      tmp = clnt_sperrno(clnt_stat);
#line 267
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              argv0, tmp);
#line 268
      exit(1);
      }
    }
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rusers/rusers.c"
static void usage(void) 
{ 


  {
  {
#line 275
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-la] [hosts ...]\n",
          argv0);
#line 276
  exit(1);
  }
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 320 "/usr/include/rpc/xdr.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) xdr_vector)(XDR *__xdrs ,
                                                                                    char *__basep ,
                                                                                    u_int __nelem ,
                                                                                    u_int __elemsize ,
                                                                                    bool_t (*__xdr_elem)(XDR * ,
                                                                                                         void * 
                                                                                                         , ...) ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat.h"
bool_t xdr_rstat_timeval(XDR *xdrs , rstat_timeval *objp ) ;
#line 146
bool_t xdr_statstime(XDR *xdrs , statstime *objp ) ;
#line 147
bool_t xdr_statsswtch(XDR *xdrs , statsswtch *objp ) ;
#line 148
bool_t xdr_stats(XDR *xdrs , stats *objp ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat_xdr.c"
bool_t xdr_rstat_timeval(XDR *xdrs , rstat_timeval *objp ) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 13
  tmp = xdr_u_int(xdrs, & objp->tv_sec);
  }
#line 13
  if (! tmp) {
#line 14
    return (0);
  }
  {
#line 15
  tmp___0 = xdr_u_int(xdrs, & objp->tv_usec);
  }
#line 15
  if (! tmp___0) {
#line 16
    return (0);
  }
#line 17
  return (1);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat_xdr.c"
bool_t xdr_statstime(XDR *xdrs , statstime *objp ) 
{ 
  register int32_t *buf ;
  int i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  bool_t tmp___5 ;
  bool_t tmp___6 ;
  bool_t tmp___7 ;
  bool_t tmp___8 ;
  bool_t tmp___9 ;
  bool_t tmp___10 ;
  bool_t tmp___11 ;
  register int *genp ;
  int32_t *tmp___12 ;
  int *tmp___13 ;
  uint32_t tmp___14 ;
  register int *genp___0 ;
  int32_t *tmp___15 ;
  int *tmp___16 ;
  uint32_t tmp___17 ;
  int32_t *tmp___18 ;
  uint32_t tmp___19 ;
  int32_t *tmp___20 ;
  uint32_t tmp___21 ;
  int32_t *tmp___22 ;
  uint32_t tmp___23 ;
  int32_t *tmp___24 ;
  uint32_t tmp___25 ;
  int32_t *tmp___26 ;
  uint32_t tmp___27 ;
  int32_t *tmp___28 ;
  uint32_t tmp___29 ;
  int32_t *tmp___30 ;
  uint32_t tmp___31 ;
  int32_t *tmp___32 ;
  uint32_t tmp___33 ;
  int32_t *tmp___34 ;
  uint32_t tmp___35 ;
  int32_t *tmp___36 ;
  uint32_t tmp___37 ;
  register int *genp___1 ;
  int32_t *tmp___38 ;
  int *tmp___39 ;
  uint32_t tmp___40 ;
  bool_t tmp___41 ;
  bool_t tmp___42 ;
  bool_t tmp___43 ;
  bool_t tmp___44 ;
  bool_t tmp___45 ;
  bool_t tmp___46 ;
  bool_t tmp___47 ;
  bool_t tmp___48 ;
  bool_t tmp___49 ;
  bool_t tmp___50 ;
  bool_t tmp___51 ;
  bool_t tmp___52 ;
  bool_t tmp___53 ;
  bool_t tmp___54 ;
  bool_t tmp___55 ;
  bool_t tmp___56 ;
  register int *genp___2 ;
  int *tmp___57 ;
  int32_t *tmp___58 ;
  uint32_t tmp___59 ;
  register int *genp___3 ;
  int *tmp___60 ;
  int32_t *tmp___61 ;
  uint32_t tmp___62 ;
  int32_t *tmp___63 ;
  uint32_t tmp___64 ;
  int32_t *tmp___65 ;
  uint32_t tmp___66 ;
  int32_t *tmp___67 ;
  uint32_t tmp___68 ;
  int32_t *tmp___69 ;
  uint32_t tmp___70 ;
  int32_t *tmp___71 ;
  uint32_t tmp___72 ;
  int32_t *tmp___73 ;
  uint32_t tmp___74 ;
  int32_t *tmp___75 ;
  uint32_t tmp___76 ;
  int32_t *tmp___77 ;
  uint32_t tmp___78 ;
  int32_t *tmp___79 ;
  uint32_t tmp___80 ;
  int32_t *tmp___81 ;
  uint32_t tmp___82 ;
  register int *genp___4 ;
  int *tmp___83 ;
  int32_t *tmp___84 ;
  uint32_t tmp___85 ;
  bool_t tmp___86 ;
  bool_t tmp___87 ;
  bool_t tmp___88 ;
  bool_t tmp___89 ;
  bool_t tmp___90 ;
  bool_t tmp___91 ;
  bool_t tmp___92 ;
  bool_t tmp___93 ;
  bool_t tmp___94 ;
  bool_t tmp___95 ;
  bool_t tmp___96 ;
  bool_t tmp___97 ;
  bool_t tmp___98 ;
  bool_t tmp___99 ;
  bool_t tmp___100 ;
  bool_t tmp___101 ;
  bool_t tmp___102 ;
  bool_t tmp___103 ;
  bool_t tmp___104 ;

  {
#line 27
  if ((unsigned int )xdrs->x_op == 0U) {
    {
#line 28
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )84);
    }
#line 29
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 30
      tmp = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                       (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 30
      if (! tmp) {
#line 32
        return (0);
      }
      {
#line 33
      tmp___0 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                           (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 33
      if (! tmp___0) {
#line 35
        return (0);
      }
      {
#line 36
      tmp___1 = xdr_u_int(xdrs, & objp->v_pgpgin);
      }
#line 36
      if (! tmp___1) {
#line 37
        return (0);
      }
      {
#line 38
      tmp___2 = xdr_u_int(xdrs, & objp->v_pgpgout);
      }
#line 38
      if (! tmp___2) {
#line 39
        return (0);
      }
      {
#line 40
      tmp___3 = xdr_u_int(xdrs, & objp->v_pswpin);
      }
#line 40
      if (! tmp___3) {
#line 41
        return (0);
      }
      {
#line 42
      tmp___4 = xdr_u_int(xdrs, & objp->v_pswpout);
      }
#line 42
      if (! tmp___4) {
#line 43
        return (0);
      }
      {
#line 44
      tmp___5 = xdr_u_int(xdrs, & objp->v_intr);
      }
#line 44
      if (! tmp___5) {
#line 45
        return (0);
      }
      {
#line 46
      tmp___6 = xdr_int(xdrs, & objp->if_ipackets);
      }
#line 46
      if (! tmp___6) {
#line 47
        return (0);
      }
      {
#line 48
      tmp___7 = xdr_int(xdrs, & objp->if_ierrors);
      }
#line 48
      if (! tmp___7) {
#line 49
        return (0);
      }
      {
#line 50
      tmp___8 = xdr_int(xdrs, & objp->if_oerrors);
      }
#line 50
      if (! tmp___8) {
#line 51
        return (0);
      }
      {
#line 52
      tmp___9 = xdr_int(xdrs, & objp->if_collisions);
      }
#line 52
      if (! tmp___9) {
#line 53
        return (0);
      }
      {
#line 54
      tmp___10 = xdr_u_int(xdrs, & objp->v_swtch);
      }
#line 54
      if (! tmp___10) {
#line 55
        return (0);
      }
      {
#line 56
      tmp___11 = xdr_vector(xdrs, (char *)(objp->avenrun), (u_int )3, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 56
      if (! tmp___11) {
#line 58
        return (0);
      }
    } else {
#line 64
      i = 0;
#line 64
      genp = objp->cp_time;
      {
#line 64
      while (1) {
        while_continue: /* CIL Label */ ;
#line 64
        if (! (i < 4)) {
#line 64
          goto while_break;
        }
        {
#line 66
        tmp___12 = buf;
#line 66
        buf ++;
#line 66
        tmp___13 = genp;
#line 66
        genp ++;
#line 66
        tmp___14 = htonl((uint32_t )((long )*tmp___13));
#line 66
        *tmp___12 = (int32_t )tmp___14;
#line 64
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 72
      i = 0;
#line 72
      genp___0 = objp->dk_xfer;
      {
#line 72
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 72
        if (! (i < 4)) {
#line 72
          goto while_break___0;
        }
        {
#line 74
        tmp___15 = buf;
#line 74
        buf ++;
#line 74
        tmp___16 = genp___0;
#line 74
        genp___0 ++;
#line 74
        tmp___17 = htonl((uint32_t )((long )*tmp___16));
#line 74
        *tmp___15 = (int32_t )tmp___17;
#line 72
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 77
      tmp___18 = buf;
#line 77
      buf ++;
#line 77
      tmp___19 = htonl((uint32_t )((long )objp->v_pgpgin));
#line 77
      *tmp___18 = (int32_t )tmp___19;
#line 78
      tmp___20 = buf;
#line 78
      buf ++;
#line 78
      tmp___21 = htonl((uint32_t )((long )objp->v_pgpgout));
#line 78
      *tmp___20 = (int32_t )tmp___21;
#line 79
      tmp___22 = buf;
#line 79
      buf ++;
#line 79
      tmp___23 = htonl((uint32_t )((long )objp->v_pswpin));
#line 79
      *tmp___22 = (int32_t )tmp___23;
#line 80
      tmp___24 = buf;
#line 80
      buf ++;
#line 80
      tmp___25 = htonl((uint32_t )((long )objp->v_pswpout));
#line 80
      *tmp___24 = (int32_t )tmp___25;
#line 81
      tmp___26 = buf;
#line 81
      buf ++;
#line 81
      tmp___27 = htonl((uint32_t )((long )objp->v_intr));
#line 81
      *tmp___26 = (int32_t )tmp___27;
#line 82
      tmp___28 = buf;
#line 82
      buf ++;
#line 82
      tmp___29 = htonl((uint32_t )((long )objp->if_ipackets));
#line 82
      *tmp___28 = (int32_t )tmp___29;
#line 83
      tmp___30 = buf;
#line 83
      buf ++;
#line 83
      tmp___31 = htonl((uint32_t )((long )objp->if_ierrors));
#line 83
      *tmp___30 = (int32_t )tmp___31;
#line 84
      tmp___32 = buf;
#line 84
      buf ++;
#line 84
      tmp___33 = htonl((uint32_t )((long )objp->if_oerrors));
#line 84
      *tmp___32 = (int32_t )tmp___33;
#line 85
      tmp___34 = buf;
#line 85
      buf ++;
#line 85
      tmp___35 = htonl((uint32_t )((long )objp->if_collisions));
#line 85
      *tmp___34 = (int32_t )tmp___35;
#line 86
      tmp___36 = buf;
#line 86
      buf ++;
#line 86
      tmp___37 = htonl((uint32_t )((long )objp->v_swtch));
#line 86
      *tmp___36 = (int32_t )tmp___37;
#line 90
      i = 0;
#line 90
      genp___1 = objp->avenrun;
      }
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (! (i < 3)) {
#line 90
          goto while_break___1;
        }
        {
#line 92
        tmp___38 = buf;
#line 92
        buf ++;
#line 92
        tmp___39 = genp___1;
#line 92
        genp___1 ++;
#line 92
        tmp___40 = htonl((uint32_t )((long )*tmp___39));
#line 92
        *tmp___38 = (int32_t )tmp___40;
#line 90
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 96
    tmp___41 = xdr_rstat_timeval(xdrs, & objp->boottime);
    }
#line 96
    if (! tmp___41) {
#line 97
      return (0);
    }
    {
#line 98
    tmp___42 = xdr_rstat_timeval(xdrs, & objp->curtime);
    }
#line 98
    if (! tmp___42) {
#line 99
      return (0);
    }
    {
#line 100
    tmp___43 = xdr_int(xdrs, & objp->if_opackets);
    }
#line 100
    if (! tmp___43) {
#line 101
      return (0);
    }
#line 102
    return (1);
  } else
#line 103
  if ((unsigned int )xdrs->x_op == 1U) {
    {
#line 104
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )84);
    }
#line 105
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 106
      tmp___44 = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 106
      if (! tmp___44) {
#line 108
        return (0);
      }
      {
#line 109
      tmp___45 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 109
      if (! tmp___45) {
#line 111
        return (0);
      }
      {
#line 112
      tmp___46 = xdr_u_int(xdrs, & objp->v_pgpgin);
      }
#line 112
      if (! tmp___46) {
#line 113
        return (0);
      }
      {
#line 114
      tmp___47 = xdr_u_int(xdrs, & objp->v_pgpgout);
      }
#line 114
      if (! tmp___47) {
#line 115
        return (0);
      }
      {
#line 116
      tmp___48 = xdr_u_int(xdrs, & objp->v_pswpin);
      }
#line 116
      if (! tmp___48) {
#line 117
        return (0);
      }
      {
#line 118
      tmp___49 = xdr_u_int(xdrs, & objp->v_pswpout);
      }
#line 118
      if (! tmp___49) {
#line 119
        return (0);
      }
      {
#line 120
      tmp___50 = xdr_u_int(xdrs, & objp->v_intr);
      }
#line 120
      if (! tmp___50) {
#line 121
        return (0);
      }
      {
#line 122
      tmp___51 = xdr_int(xdrs, & objp->if_ipackets);
      }
#line 122
      if (! tmp___51) {
#line 123
        return (0);
      }
      {
#line 124
      tmp___52 = xdr_int(xdrs, & objp->if_ierrors);
      }
#line 124
      if (! tmp___52) {
#line 125
        return (0);
      }
      {
#line 126
      tmp___53 = xdr_int(xdrs, & objp->if_oerrors);
      }
#line 126
      if (! tmp___53) {
#line 127
        return (0);
      }
      {
#line 128
      tmp___54 = xdr_int(xdrs, & objp->if_collisions);
      }
#line 128
      if (! tmp___54) {
#line 129
        return (0);
      }
      {
#line 130
      tmp___55 = xdr_u_int(xdrs, & objp->v_swtch);
      }
#line 130
      if (! tmp___55) {
#line 131
        return (0);
      }
      {
#line 132
      tmp___56 = xdr_vector(xdrs, (char *)(objp->avenrun), (u_int )3, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 132
      if (! tmp___56) {
#line 134
        return (0);
      }
    } else {
#line 140
      i = 0;
#line 140
      genp___2 = objp->cp_time;
      {
#line 140
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 140
        if (! (i < 4)) {
#line 140
          goto while_break___2;
        }
        {
#line 142
        tmp___57 = genp___2;
#line 142
        genp___2 ++;
#line 142
        tmp___58 = buf;
#line 142
        buf ++;
#line 142
        tmp___59 = ntohl((uint32_t )*tmp___58);
#line 142
        *tmp___57 = (int )((long )((uint32_t )((int32_t )tmp___59)));
#line 140
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 148
      i = 0;
#line 148
      genp___3 = objp->dk_xfer;
      {
#line 148
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 148
        if (! (i < 4)) {
#line 148
          goto while_break___3;
        }
        {
#line 150
        tmp___60 = genp___3;
#line 150
        genp___3 ++;
#line 150
        tmp___61 = buf;
#line 150
        buf ++;
#line 150
        tmp___62 = ntohl((uint32_t )*tmp___61);
#line 150
        *tmp___60 = (int )((long )((uint32_t )((int32_t )tmp___62)));
#line 148
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 153
      tmp___63 = buf;
#line 153
      buf ++;
#line 153
      tmp___64 = ntohl((uint32_t )*tmp___63);
#line 153
      objp->v_pgpgin = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___64))));
#line 154
      tmp___65 = buf;
#line 154
      buf ++;
#line 154
      tmp___66 = ntohl((uint32_t )*tmp___65);
#line 154
      objp->v_pgpgout = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___66))));
#line 155
      tmp___67 = buf;
#line 155
      buf ++;
#line 155
      tmp___68 = ntohl((uint32_t )*tmp___67);
#line 155
      objp->v_pswpin = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___68))));
#line 156
      tmp___69 = buf;
#line 156
      buf ++;
#line 156
      tmp___70 = ntohl((uint32_t )*tmp___69);
#line 156
      objp->v_pswpout = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___70))));
#line 157
      tmp___71 = buf;
#line 157
      buf ++;
#line 157
      tmp___72 = ntohl((uint32_t )*tmp___71);
#line 157
      objp->v_intr = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___72))));
#line 158
      tmp___73 = buf;
#line 158
      buf ++;
#line 158
      tmp___74 = ntohl((uint32_t )*tmp___73);
#line 158
      objp->if_ipackets = (int )((long )((uint32_t )((int32_t )tmp___74)));
#line 159
      tmp___75 = buf;
#line 159
      buf ++;
#line 159
      tmp___76 = ntohl((uint32_t )*tmp___75);
#line 159
      objp->if_ierrors = (int )((long )((uint32_t )((int32_t )tmp___76)));
#line 160
      tmp___77 = buf;
#line 160
      buf ++;
#line 160
      tmp___78 = ntohl((uint32_t )*tmp___77);
#line 160
      objp->if_oerrors = (int )((long )((uint32_t )((int32_t )tmp___78)));
#line 161
      tmp___79 = buf;
#line 161
      buf ++;
#line 161
      tmp___80 = ntohl((uint32_t )*tmp___79);
#line 161
      objp->if_collisions = (int )((long )((uint32_t )((int32_t )tmp___80)));
#line 162
      tmp___81 = buf;
#line 162
      buf ++;
#line 162
      tmp___82 = ntohl((uint32_t )*tmp___81);
#line 162
      objp->v_swtch = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___82))));
#line 166
      i = 0;
#line 166
      genp___4 = objp->avenrun;
      }
      {
#line 166
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 166
        if (! (i < 3)) {
#line 166
          goto while_break___4;
        }
        {
#line 168
        tmp___83 = genp___4;
#line 168
        genp___4 ++;
#line 168
        tmp___84 = buf;
#line 168
        buf ++;
#line 168
        tmp___85 = ntohl((uint32_t )*tmp___84);
#line 168
        *tmp___83 = (int )((long )((uint32_t )((int32_t )tmp___85)));
#line 166
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 172
    tmp___86 = xdr_rstat_timeval(xdrs, & objp->boottime);
    }
#line 172
    if (! tmp___86) {
#line 173
      return (0);
    }
    {
#line 174
    tmp___87 = xdr_rstat_timeval(xdrs, & objp->curtime);
    }
#line 174
    if (! tmp___87) {
#line 175
      return (0);
    }
    {
#line 176
    tmp___88 = xdr_int(xdrs, & objp->if_opackets);
    }
#line 176
    if (! tmp___88) {
#line 177
      return (0);
    }
#line 178
    return (1);
  }
  {
#line 181
  tmp___89 = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 181
  if (! tmp___89) {
#line 183
    return (0);
  }
  {
#line 184
  tmp___90 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 184
  if (! tmp___90) {
#line 186
    return (0);
  }
  {
#line 187
  tmp___91 = xdr_u_int(xdrs, & objp->v_pgpgin);
  }
#line 187
  if (! tmp___91) {
#line 188
    return (0);
  }
  {
#line 189
  tmp___92 = xdr_u_int(xdrs, & objp->v_pgpgout);
  }
#line 189
  if (! tmp___92) {
#line 190
    return (0);
  }
  {
#line 191
  tmp___93 = xdr_u_int(xdrs, & objp->v_pswpin);
  }
#line 191
  if (! tmp___93) {
#line 192
    return (0);
  }
  {
#line 193
  tmp___94 = xdr_u_int(xdrs, & objp->v_pswpout);
  }
#line 193
  if (! tmp___94) {
#line 194
    return (0);
  }
  {
#line 195
  tmp___95 = xdr_u_int(xdrs, & objp->v_intr);
  }
#line 195
  if (! tmp___95) {
#line 196
    return (0);
  }
  {
#line 197
  tmp___96 = xdr_int(xdrs, & objp->if_ipackets);
  }
#line 197
  if (! tmp___96) {
#line 198
    return (0);
  }
  {
#line 199
  tmp___97 = xdr_int(xdrs, & objp->if_ierrors);
  }
#line 199
  if (! tmp___97) {
#line 200
    return (0);
  }
  {
#line 201
  tmp___98 = xdr_int(xdrs, & objp->if_oerrors);
  }
#line 201
  if (! tmp___98) {
#line 202
    return (0);
  }
  {
#line 203
  tmp___99 = xdr_int(xdrs, & objp->if_collisions);
  }
#line 203
  if (! tmp___99) {
#line 204
    return (0);
  }
  {
#line 205
  tmp___100 = xdr_u_int(xdrs, & objp->v_swtch);
  }
#line 205
  if (! tmp___100) {
#line 206
    return (0);
  }
  {
#line 207
  tmp___101 = xdr_vector(xdrs, (char *)(objp->avenrun), (u_int )3, (u_int )sizeof(int ),
                         (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 207
  if (! tmp___101) {
#line 209
    return (0);
  }
  {
#line 210
  tmp___102 = xdr_rstat_timeval(xdrs, & objp->boottime);
  }
#line 210
  if (! tmp___102) {
#line 211
    return (0);
  }
  {
#line 212
  tmp___103 = xdr_rstat_timeval(xdrs, & objp->curtime);
  }
#line 212
  if (! tmp___103) {
#line 213
    return (0);
  }
  {
#line 214
  tmp___104 = xdr_int(xdrs, & objp->if_opackets);
  }
#line 214
  if (! tmp___104) {
#line 215
    return (0);
  }
#line 216
  return (1);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat_xdr.c"
bool_t xdr_statsswtch(XDR *xdrs , statsswtch *objp ) 
{ 
  register int32_t *buf ;
  int i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  bool_t tmp___5 ;
  bool_t tmp___6 ;
  bool_t tmp___7 ;
  bool_t tmp___8 ;
  bool_t tmp___9 ;
  bool_t tmp___10 ;
  bool_t tmp___11 ;
  register int *genp ;
  int32_t *tmp___12 ;
  int *tmp___13 ;
  uint32_t tmp___14 ;
  register int *genp___0 ;
  int32_t *tmp___15 ;
  int *tmp___16 ;
  uint32_t tmp___17 ;
  int32_t *tmp___18 ;
  uint32_t tmp___19 ;
  int32_t *tmp___20 ;
  uint32_t tmp___21 ;
  int32_t *tmp___22 ;
  uint32_t tmp___23 ;
  int32_t *tmp___24 ;
  uint32_t tmp___25 ;
  int32_t *tmp___26 ;
  uint32_t tmp___27 ;
  int32_t *tmp___28 ;
  uint32_t tmp___29 ;
  int32_t *tmp___30 ;
  uint32_t tmp___31 ;
  int32_t *tmp___32 ;
  uint32_t tmp___33 ;
  int32_t *tmp___34 ;
  uint32_t tmp___35 ;
  int32_t *tmp___36 ;
  uint32_t tmp___37 ;
  register u_int *genp___1 ;
  int32_t *tmp___38 ;
  u_int *tmp___39 ;
  uint32_t tmp___40 ;
  bool_t tmp___41 ;
  bool_t tmp___42 ;
  bool_t tmp___43 ;
  bool_t tmp___44 ;
  bool_t tmp___45 ;
  bool_t tmp___46 ;
  bool_t tmp___47 ;
  bool_t tmp___48 ;
  bool_t tmp___49 ;
  bool_t tmp___50 ;
  bool_t tmp___51 ;
  bool_t tmp___52 ;
  bool_t tmp___53 ;
  bool_t tmp___54 ;
  bool_t tmp___55 ;
  register int *genp___2 ;
  int *tmp___56 ;
  int32_t *tmp___57 ;
  uint32_t tmp___58 ;
  register int *genp___3 ;
  int *tmp___59 ;
  int32_t *tmp___60 ;
  uint32_t tmp___61 ;
  int32_t *tmp___62 ;
  uint32_t tmp___63 ;
  int32_t *tmp___64 ;
  uint32_t tmp___65 ;
  int32_t *tmp___66 ;
  uint32_t tmp___67 ;
  int32_t *tmp___68 ;
  uint32_t tmp___69 ;
  int32_t *tmp___70 ;
  uint32_t tmp___71 ;
  int32_t *tmp___72 ;
  uint32_t tmp___73 ;
  int32_t *tmp___74 ;
  uint32_t tmp___75 ;
  int32_t *tmp___76 ;
  uint32_t tmp___77 ;
  int32_t *tmp___78 ;
  uint32_t tmp___79 ;
  int32_t *tmp___80 ;
  uint32_t tmp___81 ;
  register u_int *genp___4 ;
  u_int *tmp___82 ;
  int32_t *tmp___83 ;
  uint32_t tmp___84 ;
  bool_t tmp___85 ;
  bool_t tmp___86 ;
  bool_t tmp___87 ;
  bool_t tmp___88 ;
  bool_t tmp___89 ;
  bool_t tmp___90 ;
  bool_t tmp___91 ;
  bool_t tmp___92 ;
  bool_t tmp___93 ;
  bool_t tmp___94 ;
  bool_t tmp___95 ;
  bool_t tmp___96 ;
  bool_t tmp___97 ;
  bool_t tmp___98 ;
  bool_t tmp___99 ;
  bool_t tmp___100 ;
  bool_t tmp___101 ;

  {
#line 226
  if ((unsigned int )xdrs->x_op == 0U) {
    {
#line 227
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )84);
    }
#line 228
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 229
      tmp = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                       (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 229
      if (! tmp) {
#line 231
        return (0);
      }
      {
#line 232
      tmp___0 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                           (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 232
      if (! tmp___0) {
#line 234
        return (0);
      }
      {
#line 235
      tmp___1 = xdr_u_int(xdrs, & objp->v_pgpgin);
      }
#line 235
      if (! tmp___1) {
#line 236
        return (0);
      }
      {
#line 237
      tmp___2 = xdr_u_int(xdrs, & objp->v_pgpgout);
      }
#line 237
      if (! tmp___2) {
#line 238
        return (0);
      }
      {
#line 239
      tmp___3 = xdr_u_int(xdrs, & objp->v_pswpin);
      }
#line 239
      if (! tmp___3) {
#line 240
        return (0);
      }
      {
#line 241
      tmp___4 = xdr_u_int(xdrs, & objp->v_pswpout);
      }
#line 241
      if (! tmp___4) {
#line 242
        return (0);
      }
      {
#line 243
      tmp___5 = xdr_u_int(xdrs, & objp->v_intr);
      }
#line 243
      if (! tmp___5) {
#line 244
        return (0);
      }
      {
#line 245
      tmp___6 = xdr_int(xdrs, & objp->if_ipackets);
      }
#line 245
      if (! tmp___6) {
#line 246
        return (0);
      }
      {
#line 247
      tmp___7 = xdr_int(xdrs, & objp->if_ierrors);
      }
#line 247
      if (! tmp___7) {
#line 248
        return (0);
      }
      {
#line 249
      tmp___8 = xdr_int(xdrs, & objp->if_oerrors);
      }
#line 249
      if (! tmp___8) {
#line 250
        return (0);
      }
      {
#line 251
      tmp___9 = xdr_int(xdrs, & objp->if_collisions);
      }
#line 251
      if (! tmp___9) {
#line 252
        return (0);
      }
      {
#line 253
      tmp___10 = xdr_u_int(xdrs, & objp->v_swtch);
      }
#line 253
      if (! tmp___10) {
#line 254
        return (0);
      }
      {
#line 255
      tmp___11 = xdr_vector(xdrs, (char *)(objp->avenrun), (u_int )3, (u_int )sizeof(u_int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_u_int));
      }
#line 255
      if (! tmp___11) {
#line 257
        return (0);
      }
    } else {
#line 263
      i = 0;
#line 263
      genp = objp->cp_time;
      {
#line 263
      while (1) {
        while_continue: /* CIL Label */ ;
#line 263
        if (! (i < 4)) {
#line 263
          goto while_break;
        }
        {
#line 265
        tmp___12 = buf;
#line 265
        buf ++;
#line 265
        tmp___13 = genp;
#line 265
        genp ++;
#line 265
        tmp___14 = htonl((uint32_t )((long )*tmp___13));
#line 265
        *tmp___12 = (int32_t )tmp___14;
#line 263
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 271
      i = 0;
#line 271
      genp___0 = objp->dk_xfer;
      {
#line 271
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 271
        if (! (i < 4)) {
#line 271
          goto while_break___0;
        }
        {
#line 273
        tmp___15 = buf;
#line 273
        buf ++;
#line 273
        tmp___16 = genp___0;
#line 273
        genp___0 ++;
#line 273
        tmp___17 = htonl((uint32_t )((long )*tmp___16));
#line 273
        *tmp___15 = (int32_t )tmp___17;
#line 271
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 276
      tmp___18 = buf;
#line 276
      buf ++;
#line 276
      tmp___19 = htonl((uint32_t )((long )objp->v_pgpgin));
#line 276
      *tmp___18 = (int32_t )tmp___19;
#line 277
      tmp___20 = buf;
#line 277
      buf ++;
#line 277
      tmp___21 = htonl((uint32_t )((long )objp->v_pgpgout));
#line 277
      *tmp___20 = (int32_t )tmp___21;
#line 278
      tmp___22 = buf;
#line 278
      buf ++;
#line 278
      tmp___23 = htonl((uint32_t )((long )objp->v_pswpin));
#line 278
      *tmp___22 = (int32_t )tmp___23;
#line 279
      tmp___24 = buf;
#line 279
      buf ++;
#line 279
      tmp___25 = htonl((uint32_t )((long )objp->v_pswpout));
#line 279
      *tmp___24 = (int32_t )tmp___25;
#line 280
      tmp___26 = buf;
#line 280
      buf ++;
#line 280
      tmp___27 = htonl((uint32_t )((long )objp->v_intr));
#line 280
      *tmp___26 = (int32_t )tmp___27;
#line 281
      tmp___28 = buf;
#line 281
      buf ++;
#line 281
      tmp___29 = htonl((uint32_t )((long )objp->if_ipackets));
#line 281
      *tmp___28 = (int32_t )tmp___29;
#line 282
      tmp___30 = buf;
#line 282
      buf ++;
#line 282
      tmp___31 = htonl((uint32_t )((long )objp->if_ierrors));
#line 282
      *tmp___30 = (int32_t )tmp___31;
#line 283
      tmp___32 = buf;
#line 283
      buf ++;
#line 283
      tmp___33 = htonl((uint32_t )((long )objp->if_oerrors));
#line 283
      *tmp___32 = (int32_t )tmp___33;
#line 284
      tmp___34 = buf;
#line 284
      buf ++;
#line 284
      tmp___35 = htonl((uint32_t )((long )objp->if_collisions));
#line 284
      *tmp___34 = (int32_t )tmp___35;
#line 285
      tmp___36 = buf;
#line 285
      buf ++;
#line 285
      tmp___37 = htonl((uint32_t )((long )objp->v_swtch));
#line 285
      *tmp___36 = (int32_t )tmp___37;
#line 289
      i = 0;
#line 289
      genp___1 = objp->avenrun;
      }
      {
#line 289
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 289
        if (! (i < 3)) {
#line 289
          goto while_break___1;
        }
        {
#line 291
        tmp___38 = buf;
#line 291
        buf ++;
#line 291
        tmp___39 = genp___1;
#line 291
        genp___1 ++;
#line 291
        tmp___40 = htonl((uint32_t )((long )*tmp___39));
#line 291
        *tmp___38 = (int32_t )tmp___40;
#line 289
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 295
    tmp___41 = xdr_rstat_timeval(xdrs, & objp->boottime);
    }
#line 295
    if (! tmp___41) {
#line 296
      return (0);
    }
    {
#line 297
    tmp___42 = xdr_int(xdrs, & objp->if_opackets);
    }
#line 297
    if (! tmp___42) {
#line 298
      return (0);
    }
#line 299
    return (1);
  } else
#line 300
  if ((unsigned int )xdrs->x_op == 1U) {
    {
#line 301
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )84);
    }
#line 302
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 303
      tmp___43 = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 303
      if (! tmp___43) {
#line 305
        return (0);
      }
      {
#line 306
      tmp___44 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 306
      if (! tmp___44) {
#line 308
        return (0);
      }
      {
#line 309
      tmp___45 = xdr_u_int(xdrs, & objp->v_pgpgin);
      }
#line 309
      if (! tmp___45) {
#line 310
        return (0);
      }
      {
#line 311
      tmp___46 = xdr_u_int(xdrs, & objp->v_pgpgout);
      }
#line 311
      if (! tmp___46) {
#line 312
        return (0);
      }
      {
#line 313
      tmp___47 = xdr_u_int(xdrs, & objp->v_pswpin);
      }
#line 313
      if (! tmp___47) {
#line 314
        return (0);
      }
      {
#line 315
      tmp___48 = xdr_u_int(xdrs, & objp->v_pswpout);
      }
#line 315
      if (! tmp___48) {
#line 316
        return (0);
      }
      {
#line 317
      tmp___49 = xdr_u_int(xdrs, & objp->v_intr);
      }
#line 317
      if (! tmp___49) {
#line 318
        return (0);
      }
      {
#line 319
      tmp___50 = xdr_int(xdrs, & objp->if_ipackets);
      }
#line 319
      if (! tmp___50) {
#line 320
        return (0);
      }
      {
#line 321
      tmp___51 = xdr_int(xdrs, & objp->if_ierrors);
      }
#line 321
      if (! tmp___51) {
#line 322
        return (0);
      }
      {
#line 323
      tmp___52 = xdr_int(xdrs, & objp->if_oerrors);
      }
#line 323
      if (! tmp___52) {
#line 324
        return (0);
      }
      {
#line 325
      tmp___53 = xdr_int(xdrs, & objp->if_collisions);
      }
#line 325
      if (! tmp___53) {
#line 326
        return (0);
      }
      {
#line 327
      tmp___54 = xdr_u_int(xdrs, & objp->v_swtch);
      }
#line 327
      if (! tmp___54) {
#line 328
        return (0);
      }
      {
#line 329
      tmp___55 = xdr_vector(xdrs, (char *)(objp->avenrun), (u_int )3, (u_int )sizeof(u_int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_u_int));
      }
#line 329
      if (! tmp___55) {
#line 331
        return (0);
      }
    } else {
#line 337
      i = 0;
#line 337
      genp___2 = objp->cp_time;
      {
#line 337
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 337
        if (! (i < 4)) {
#line 337
          goto while_break___2;
        }
        {
#line 339
        tmp___56 = genp___2;
#line 339
        genp___2 ++;
#line 339
        tmp___57 = buf;
#line 339
        buf ++;
#line 339
        tmp___58 = ntohl((uint32_t )*tmp___57);
#line 339
        *tmp___56 = (int )((long )((uint32_t )((int32_t )tmp___58)));
#line 337
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 345
      i = 0;
#line 345
      genp___3 = objp->dk_xfer;
      {
#line 345
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 345
        if (! (i < 4)) {
#line 345
          goto while_break___3;
        }
        {
#line 347
        tmp___59 = genp___3;
#line 347
        genp___3 ++;
#line 347
        tmp___60 = buf;
#line 347
        buf ++;
#line 347
        tmp___61 = ntohl((uint32_t )*tmp___60);
#line 347
        *tmp___59 = (int )((long )((uint32_t )((int32_t )tmp___61)));
#line 345
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 350
      tmp___62 = buf;
#line 350
      buf ++;
#line 350
      tmp___63 = ntohl((uint32_t )*tmp___62);
#line 350
      objp->v_pgpgin = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___63))));
#line 351
      tmp___64 = buf;
#line 351
      buf ++;
#line 351
      tmp___65 = ntohl((uint32_t )*tmp___64);
#line 351
      objp->v_pgpgout = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___65))));
#line 352
      tmp___66 = buf;
#line 352
      buf ++;
#line 352
      tmp___67 = ntohl((uint32_t )*tmp___66);
#line 352
      objp->v_pswpin = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___67))));
#line 353
      tmp___68 = buf;
#line 353
      buf ++;
#line 353
      tmp___69 = ntohl((uint32_t )*tmp___68);
#line 353
      objp->v_pswpout = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___69))));
#line 354
      tmp___70 = buf;
#line 354
      buf ++;
#line 354
      tmp___71 = ntohl((uint32_t )*tmp___70);
#line 354
      objp->v_intr = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___71))));
#line 355
      tmp___72 = buf;
#line 355
      buf ++;
#line 355
      tmp___73 = ntohl((uint32_t )*tmp___72);
#line 355
      objp->if_ipackets = (int )((long )((uint32_t )((int32_t )tmp___73)));
#line 356
      tmp___74 = buf;
#line 356
      buf ++;
#line 356
      tmp___75 = ntohl((uint32_t )*tmp___74);
#line 356
      objp->if_ierrors = (int )((long )((uint32_t )((int32_t )tmp___75)));
#line 357
      tmp___76 = buf;
#line 357
      buf ++;
#line 357
      tmp___77 = ntohl((uint32_t )*tmp___76);
#line 357
      objp->if_oerrors = (int )((long )((uint32_t )((int32_t )tmp___77)));
#line 358
      tmp___78 = buf;
#line 358
      buf ++;
#line 358
      tmp___79 = ntohl((uint32_t )*tmp___78);
#line 358
      objp->if_collisions = (int )((long )((uint32_t )((int32_t )tmp___79)));
#line 359
      tmp___80 = buf;
#line 359
      buf ++;
#line 359
      tmp___81 = ntohl((uint32_t )*tmp___80);
#line 359
      objp->v_swtch = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___81))));
#line 363
      i = 0;
#line 363
      genp___4 = objp->avenrun;
      }
      {
#line 363
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 363
        if (! (i < 3)) {
#line 363
          goto while_break___4;
        }
        {
#line 365
        tmp___82 = genp___4;
#line 365
        genp___4 ++;
#line 365
        tmp___83 = buf;
#line 365
        buf ++;
#line 365
        tmp___84 = ntohl((uint32_t )*tmp___83);
#line 365
        *tmp___82 = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___84))));
#line 363
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 369
    tmp___85 = xdr_rstat_timeval(xdrs, & objp->boottime);
    }
#line 369
    if (! tmp___85) {
#line 370
      return (0);
    }
    {
#line 371
    tmp___86 = xdr_int(xdrs, & objp->if_opackets);
    }
#line 371
    if (! tmp___86) {
#line 372
      return (0);
    }
#line 373
    return (1);
  }
  {
#line 376
  tmp___87 = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 376
  if (! tmp___87) {
#line 378
    return (0);
  }
  {
#line 379
  tmp___88 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 379
  if (! tmp___88) {
#line 381
    return (0);
  }
  {
#line 382
  tmp___89 = xdr_u_int(xdrs, & objp->v_pgpgin);
  }
#line 382
  if (! tmp___89) {
#line 383
    return (0);
  }
  {
#line 384
  tmp___90 = xdr_u_int(xdrs, & objp->v_pgpgout);
  }
#line 384
  if (! tmp___90) {
#line 385
    return (0);
  }
  {
#line 386
  tmp___91 = xdr_u_int(xdrs, & objp->v_pswpin);
  }
#line 386
  if (! tmp___91) {
#line 387
    return (0);
  }
  {
#line 388
  tmp___92 = xdr_u_int(xdrs, & objp->v_pswpout);
  }
#line 388
  if (! tmp___92) {
#line 389
    return (0);
  }
  {
#line 390
  tmp___93 = xdr_u_int(xdrs, & objp->v_intr);
  }
#line 390
  if (! tmp___93) {
#line 391
    return (0);
  }
  {
#line 392
  tmp___94 = xdr_int(xdrs, & objp->if_ipackets);
  }
#line 392
  if (! tmp___94) {
#line 393
    return (0);
  }
  {
#line 394
  tmp___95 = xdr_int(xdrs, & objp->if_ierrors);
  }
#line 394
  if (! tmp___95) {
#line 395
    return (0);
  }
  {
#line 396
  tmp___96 = xdr_int(xdrs, & objp->if_oerrors);
  }
#line 396
  if (! tmp___96) {
#line 397
    return (0);
  }
  {
#line 398
  tmp___97 = xdr_int(xdrs, & objp->if_collisions);
  }
#line 398
  if (! tmp___97) {
#line 399
    return (0);
  }
  {
#line 400
  tmp___98 = xdr_u_int(xdrs, & objp->v_swtch);
  }
#line 400
  if (! tmp___98) {
#line 401
    return (0);
  }
  {
#line 402
  tmp___99 = xdr_vector(xdrs, (char *)(objp->avenrun), (u_int )3, (u_int )sizeof(u_int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_u_int));
  }
#line 402
  if (! tmp___99) {
#line 404
    return (0);
  }
  {
#line 405
  tmp___100 = xdr_rstat_timeval(xdrs, & objp->boottime);
  }
#line 405
  if (! tmp___100) {
#line 406
    return (0);
  }
  {
#line 407
  tmp___101 = xdr_int(xdrs, & objp->if_opackets);
  }
#line 407
  if (! tmp___101) {
#line 408
    return (0);
  }
#line 409
  return (1);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rstat_xdr.c"
bool_t xdr_stats(XDR *xdrs , stats *objp ) 
{ 
  register int32_t *buf ;
  int i ;
  bool_t tmp ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  bool_t tmp___3 ;
  bool_t tmp___4 ;
  bool_t tmp___5 ;
  bool_t tmp___6 ;
  bool_t tmp___7 ;
  bool_t tmp___8 ;
  bool_t tmp___9 ;
  bool_t tmp___10 ;
  register int *genp ;
  int32_t *tmp___11 ;
  int *tmp___12 ;
  uint32_t tmp___13 ;
  register int *genp___0 ;
  int32_t *tmp___14 ;
  int *tmp___15 ;
  uint32_t tmp___16 ;
  int32_t *tmp___17 ;
  uint32_t tmp___18 ;
  int32_t *tmp___19 ;
  uint32_t tmp___20 ;
  int32_t *tmp___21 ;
  uint32_t tmp___22 ;
  int32_t *tmp___23 ;
  uint32_t tmp___24 ;
  int32_t *tmp___25 ;
  uint32_t tmp___26 ;
  int32_t *tmp___27 ;
  uint32_t tmp___28 ;
  int32_t *tmp___29 ;
  uint32_t tmp___30 ;
  int32_t *tmp___31 ;
  uint32_t tmp___32 ;
  int32_t *tmp___33 ;
  uint32_t tmp___34 ;
  int32_t *tmp___35 ;
  uint32_t tmp___36 ;
  bool_t tmp___37 ;
  bool_t tmp___38 ;
  bool_t tmp___39 ;
  bool_t tmp___40 ;
  bool_t tmp___41 ;
  bool_t tmp___42 ;
  bool_t tmp___43 ;
  bool_t tmp___44 ;
  bool_t tmp___45 ;
  bool_t tmp___46 ;
  bool_t tmp___47 ;
  bool_t tmp___48 ;
  register int *genp___1 ;
  int *tmp___49 ;
  int32_t *tmp___50 ;
  uint32_t tmp___51 ;
  register int *genp___2 ;
  int *tmp___52 ;
  int32_t *tmp___53 ;
  uint32_t tmp___54 ;
  int32_t *tmp___55 ;
  uint32_t tmp___56 ;
  int32_t *tmp___57 ;
  uint32_t tmp___58 ;
  int32_t *tmp___59 ;
  uint32_t tmp___60 ;
  int32_t *tmp___61 ;
  uint32_t tmp___62 ;
  int32_t *tmp___63 ;
  uint32_t tmp___64 ;
  int32_t *tmp___65 ;
  uint32_t tmp___66 ;
  int32_t *tmp___67 ;
  uint32_t tmp___68 ;
  int32_t *tmp___69 ;
  uint32_t tmp___70 ;
  int32_t *tmp___71 ;
  uint32_t tmp___72 ;
  int32_t *tmp___73 ;
  uint32_t tmp___74 ;
  bool_t tmp___75 ;
  bool_t tmp___76 ;
  bool_t tmp___77 ;
  bool_t tmp___78 ;
  bool_t tmp___79 ;
  bool_t tmp___80 ;
  bool_t tmp___81 ;
  bool_t tmp___82 ;
  bool_t tmp___83 ;
  bool_t tmp___84 ;
  bool_t tmp___85 ;
  bool_t tmp___86 ;

  {
#line 419
  if ((unsigned int )xdrs->x_op == 0U) {
    {
#line 420
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )72);
    }
#line 421
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 422
      tmp = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                       (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 422
      if (! tmp) {
#line 424
        return (0);
      }
      {
#line 425
      tmp___0 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                           (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 425
      if (! tmp___0) {
#line 427
        return (0);
      }
      {
#line 428
      tmp___1 = xdr_u_int(xdrs, & objp->v_pgpgin);
      }
#line 428
      if (! tmp___1) {
#line 429
        return (0);
      }
      {
#line 430
      tmp___2 = xdr_u_int(xdrs, & objp->v_pgpgout);
      }
#line 430
      if (! tmp___2) {
#line 431
        return (0);
      }
      {
#line 432
      tmp___3 = xdr_u_int(xdrs, & objp->v_pswpin);
      }
#line 432
      if (! tmp___3) {
#line 433
        return (0);
      }
      {
#line 434
      tmp___4 = xdr_u_int(xdrs, & objp->v_pswpout);
      }
#line 434
      if (! tmp___4) {
#line 435
        return (0);
      }
      {
#line 436
      tmp___5 = xdr_u_int(xdrs, & objp->v_intr);
      }
#line 436
      if (! tmp___5) {
#line 437
        return (0);
      }
      {
#line 438
      tmp___6 = xdr_int(xdrs, & objp->if_ipackets);
      }
#line 438
      if (! tmp___6) {
#line 439
        return (0);
      }
      {
#line 440
      tmp___7 = xdr_int(xdrs, & objp->if_ierrors);
      }
#line 440
      if (! tmp___7) {
#line 441
        return (0);
      }
      {
#line 442
      tmp___8 = xdr_int(xdrs, & objp->if_oerrors);
      }
#line 442
      if (! tmp___8) {
#line 443
        return (0);
      }
      {
#line 444
      tmp___9 = xdr_int(xdrs, & objp->if_collisions);
      }
#line 444
      if (! tmp___9) {
#line 445
        return (0);
      }
      {
#line 446
      tmp___10 = xdr_int(xdrs, & objp->if_opackets);
      }
#line 446
      if (! tmp___10) {
#line 447
        return (0);
      }
    } else {
#line 452
      i = 0;
#line 452
      genp = objp->cp_time;
      {
#line 452
      while (1) {
        while_continue: /* CIL Label */ ;
#line 452
        if (! (i < 4)) {
#line 452
          goto while_break;
        }
        {
#line 454
        tmp___11 = buf;
#line 454
        buf ++;
#line 454
        tmp___12 = genp;
#line 454
        genp ++;
#line 454
        tmp___13 = htonl((uint32_t )((long )*tmp___12));
#line 454
        *tmp___11 = (int32_t )tmp___13;
#line 452
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 460
      i = 0;
#line 460
      genp___0 = objp->dk_xfer;
      {
#line 460
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 460
        if (! (i < 4)) {
#line 460
          goto while_break___0;
        }
        {
#line 462
        tmp___14 = buf;
#line 462
        buf ++;
#line 462
        tmp___15 = genp___0;
#line 462
        genp___0 ++;
#line 462
        tmp___16 = htonl((uint32_t )((long )*tmp___15));
#line 462
        *tmp___14 = (int32_t )tmp___16;
#line 460
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 465
      tmp___17 = buf;
#line 465
      buf ++;
#line 465
      tmp___18 = htonl((uint32_t )((long )objp->v_pgpgin));
#line 465
      *tmp___17 = (int32_t )tmp___18;
#line 466
      tmp___19 = buf;
#line 466
      buf ++;
#line 466
      tmp___20 = htonl((uint32_t )((long )objp->v_pgpgout));
#line 466
      *tmp___19 = (int32_t )tmp___20;
#line 467
      tmp___21 = buf;
#line 467
      buf ++;
#line 467
      tmp___22 = htonl((uint32_t )((long )objp->v_pswpin));
#line 467
      *tmp___21 = (int32_t )tmp___22;
#line 468
      tmp___23 = buf;
#line 468
      buf ++;
#line 468
      tmp___24 = htonl((uint32_t )((long )objp->v_pswpout));
#line 468
      *tmp___23 = (int32_t )tmp___24;
#line 469
      tmp___25 = buf;
#line 469
      buf ++;
#line 469
      tmp___26 = htonl((uint32_t )((long )objp->v_intr));
#line 469
      *tmp___25 = (int32_t )tmp___26;
#line 470
      tmp___27 = buf;
#line 470
      buf ++;
#line 470
      tmp___28 = htonl((uint32_t )((long )objp->if_ipackets));
#line 470
      *tmp___27 = (int32_t )tmp___28;
#line 471
      tmp___29 = buf;
#line 471
      buf ++;
#line 471
      tmp___30 = htonl((uint32_t )((long )objp->if_ierrors));
#line 471
      *tmp___29 = (int32_t )tmp___30;
#line 472
      tmp___31 = buf;
#line 472
      buf ++;
#line 472
      tmp___32 = htonl((uint32_t )((long )objp->if_oerrors));
#line 472
      *tmp___31 = (int32_t )tmp___32;
#line 473
      tmp___33 = buf;
#line 473
      buf ++;
#line 473
      tmp___34 = htonl((uint32_t )((long )objp->if_collisions));
#line 473
      *tmp___33 = (int32_t )tmp___34;
#line 474
      tmp___35 = buf;
#line 474
      buf ++;
#line 474
      tmp___36 = htonl((uint32_t )((long )objp->if_opackets));
#line 474
      *tmp___35 = (int32_t )tmp___36;
      }
    }
#line 476
    return (1);
  } else
#line 477
  if ((unsigned int )xdrs->x_op == 1U) {
    {
#line 478
    buf = (*((xdrs->x_ops)->x_inline))(xdrs, (u_int )72);
    }
#line 479
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 480
      tmp___37 = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 480
      if (! tmp___37) {
#line 482
        return (0);
      }
      {
#line 483
      tmp___38 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                            (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
      }
#line 483
      if (! tmp___38) {
#line 485
        return (0);
      }
      {
#line 486
      tmp___39 = xdr_u_int(xdrs, & objp->v_pgpgin);
      }
#line 486
      if (! tmp___39) {
#line 487
        return (0);
      }
      {
#line 488
      tmp___40 = xdr_u_int(xdrs, & objp->v_pgpgout);
      }
#line 488
      if (! tmp___40) {
#line 489
        return (0);
      }
      {
#line 490
      tmp___41 = xdr_u_int(xdrs, & objp->v_pswpin);
      }
#line 490
      if (! tmp___41) {
#line 491
        return (0);
      }
      {
#line 492
      tmp___42 = xdr_u_int(xdrs, & objp->v_pswpout);
      }
#line 492
      if (! tmp___42) {
#line 493
        return (0);
      }
      {
#line 494
      tmp___43 = xdr_u_int(xdrs, & objp->v_intr);
      }
#line 494
      if (! tmp___43) {
#line 495
        return (0);
      }
      {
#line 496
      tmp___44 = xdr_int(xdrs, & objp->if_ipackets);
      }
#line 496
      if (! tmp___44) {
#line 497
        return (0);
      }
      {
#line 498
      tmp___45 = xdr_int(xdrs, & objp->if_ierrors);
      }
#line 498
      if (! tmp___45) {
#line 499
        return (0);
      }
      {
#line 500
      tmp___46 = xdr_int(xdrs, & objp->if_oerrors);
      }
#line 500
      if (! tmp___46) {
#line 501
        return (0);
      }
      {
#line 502
      tmp___47 = xdr_int(xdrs, & objp->if_collisions);
      }
#line 502
      if (! tmp___47) {
#line 503
        return (0);
      }
      {
#line 504
      tmp___48 = xdr_int(xdrs, & objp->if_opackets);
      }
#line 504
      if (! tmp___48) {
#line 505
        return (0);
      }
    } else {
#line 510
      i = 0;
#line 510
      genp___1 = objp->cp_time;
      {
#line 510
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 510
        if (! (i < 4)) {
#line 510
          goto while_break___1;
        }
        {
#line 512
        tmp___49 = genp___1;
#line 512
        genp___1 ++;
#line 512
        tmp___50 = buf;
#line 512
        buf ++;
#line 512
        tmp___51 = ntohl((uint32_t )*tmp___50);
#line 512
        *tmp___49 = (int )((long )((uint32_t )((int32_t )tmp___51)));
#line 510
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 518
      i = 0;
#line 518
      genp___2 = objp->dk_xfer;
      {
#line 518
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 518
        if (! (i < 4)) {
#line 518
          goto while_break___2;
        }
        {
#line 520
        tmp___52 = genp___2;
#line 520
        genp___2 ++;
#line 520
        tmp___53 = buf;
#line 520
        buf ++;
#line 520
        tmp___54 = ntohl((uint32_t )*tmp___53);
#line 520
        *tmp___52 = (int )((long )((uint32_t )((int32_t )tmp___54)));
#line 518
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 523
      tmp___55 = buf;
#line 523
      buf ++;
#line 523
      tmp___56 = ntohl((uint32_t )*tmp___55);
#line 523
      objp->v_pgpgin = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___56))));
#line 524
      tmp___57 = buf;
#line 524
      buf ++;
#line 524
      tmp___58 = ntohl((uint32_t )*tmp___57);
#line 524
      objp->v_pgpgout = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___58))));
#line 525
      tmp___59 = buf;
#line 525
      buf ++;
#line 525
      tmp___60 = ntohl((uint32_t )*tmp___59);
#line 525
      objp->v_pswpin = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___60))));
#line 526
      tmp___61 = buf;
#line 526
      buf ++;
#line 526
      tmp___62 = ntohl((uint32_t )*tmp___61);
#line 526
      objp->v_pswpout = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___62))));
#line 527
      tmp___63 = buf;
#line 527
      buf ++;
#line 527
      tmp___64 = ntohl((uint32_t )*tmp___63);
#line 527
      objp->v_intr = (u_int )((u_long )((long )((uint32_t )((int32_t )tmp___64))));
#line 528
      tmp___65 = buf;
#line 528
      buf ++;
#line 528
      tmp___66 = ntohl((uint32_t )*tmp___65);
#line 528
      objp->if_ipackets = (int )((long )((uint32_t )((int32_t )tmp___66)));
#line 529
      tmp___67 = buf;
#line 529
      buf ++;
#line 529
      tmp___68 = ntohl((uint32_t )*tmp___67);
#line 529
      objp->if_ierrors = (int )((long )((uint32_t )((int32_t )tmp___68)));
#line 530
      tmp___69 = buf;
#line 530
      buf ++;
#line 530
      tmp___70 = ntohl((uint32_t )*tmp___69);
#line 530
      objp->if_oerrors = (int )((long )((uint32_t )((int32_t )tmp___70)));
#line 531
      tmp___71 = buf;
#line 531
      buf ++;
#line 531
      tmp___72 = ntohl((uint32_t )*tmp___71);
#line 531
      objp->if_collisions = (int )((long )((uint32_t )((int32_t )tmp___72)));
#line 532
      tmp___73 = buf;
#line 532
      buf ++;
#line 532
      tmp___74 = ntohl((uint32_t )*tmp___73);
#line 532
      objp->if_opackets = (int )((long )((uint32_t )((int32_t )tmp___74)));
      }
    }
#line 534
    return (1);
  }
  {
#line 537
  tmp___75 = xdr_vector(xdrs, (char *)(objp->cp_time), (u_int )4, (u_int )sizeof(int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 537
  if (! tmp___75) {
#line 539
    return (0);
  }
  {
#line 540
  tmp___76 = xdr_vector(xdrs, (char *)(objp->dk_xfer), (u_int )4, (u_int )sizeof(int ),
                        (bool_t (*)(XDR * , void *  , ...))(& xdr_int));
  }
#line 540
  if (! tmp___76) {
#line 542
    return (0);
  }
  {
#line 543
  tmp___77 = xdr_u_int(xdrs, & objp->v_pgpgin);
  }
#line 543
  if (! tmp___77) {
#line 544
    return (0);
  }
  {
#line 545
  tmp___78 = xdr_u_int(xdrs, & objp->v_pgpgout);
  }
#line 545
  if (! tmp___78) {
#line 546
    return (0);
  }
  {
#line 547
  tmp___79 = xdr_u_int(xdrs, & objp->v_pswpin);
  }
#line 547
  if (! tmp___79) {
#line 548
    return (0);
  }
  {
#line 549
  tmp___80 = xdr_u_int(xdrs, & objp->v_pswpout);
  }
#line 549
  if (! tmp___80) {
#line 550
    return (0);
  }
  {
#line 551
  tmp___81 = xdr_u_int(xdrs, & objp->v_intr);
  }
#line 551
  if (! tmp___81) {
#line 552
    return (0);
  }
  {
#line 553
  tmp___82 = xdr_int(xdrs, & objp->if_ipackets);
  }
#line 553
  if (! tmp___82) {
#line 554
    return (0);
  }
  {
#line 555
  tmp___83 = xdr_int(xdrs, & objp->if_ierrors);
  }
#line 555
  if (! tmp___83) {
#line 556
    return (0);
  }
  {
#line 557
  tmp___84 = xdr_int(xdrs, & objp->if_oerrors);
  }
#line 557
  if (! tmp___84) {
#line 558
    return (0);
  }
  {
#line 559
  tmp___85 = xdr_int(xdrs, & objp->if_collisions);
  }
#line 559
  if (! tmp___85) {
#line 560
    return (0);
  }
  {
#line 561
  tmp___86 = xdr_int(xdrs, & objp->if_opackets);
  }
#line 561
  if (! tmp___86) {
#line 562
    return (0);
  }
#line 563
  return (1);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
char rcsid[52]  = 
#line 34 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'r',      (char )'u',      (char )'p', 
        (char )'.',      (char )'c',      (char )',',      (char )'v', 
        (char )' ',      (char )'1',      (char )'.',      (char )'8', 
        (char )' ',      (char )'2',      (char )'0',      (char )'0', 
        (char )'0',      (char )'/',      (char )'0',      (char )'7', 
        (char )'/',      (char )'2',      (char )'2',      (char )' ', 
        (char )'1',      (char )'9',      (char )':',      (char )'5', 
        (char )'1',      (char )':',      (char )'4',      (char )'0', 
        (char )' ',      (char )'d',      (char )'h',      (char )'o', 
        (char )'l',      (char )'l',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'E',      (char )'x', 
        (char )'p',      (char )' ',      (char )'$',      (char )'\000'};
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 369 "/usr/include/rpc/clnt.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) clnt_spcreateerror)(char const   *__msg ) ;
#line 381
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) clnt_sperror)(CLIENT *__clnt ,
                                                                                     char const   *__msg ) ;
#line 40 "/usr/include/err.h"
extern void ( /* format attribute */  warnx)(char const   *__format  , ...) ;
#line 46
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int print_rup_data(char const   *host___0 , statstime *host_stat ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int printtime  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int printseconds  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int search_host___0(struct in_addr addr ) 
{ 
  struct host_list *hp ;

  {
#line 73
  if (! hosts) {
#line 74
    return (0);
  }
#line 76
  hp = hosts;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 76
      goto while_break;
    }
#line 77
    if (hp->addr.s_addr == addr.s_addr) {
#line 78
      return (1);
    }
#line 76
    hp = hp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (0);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static void remember_host___0(struct in_addr addr ) 
{ 
  struct host_list *hp ;
  void *tmp ;

  {
  {
#line 89
  tmp = malloc(sizeof(struct host_list ));
#line 89
  hp = (struct host_list *)tmp;
  }
#line 89
  if (! hp) {
    {
#line 90
    err(1, "malloc");
    }
  }
#line 93
  hp->addr.s_addr = addr.s_addr;
#line 94
  hp->next = hosts;
#line 95
  hosts = hp;
#line 96
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
struct rup_data *rup_data  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
int rup_data_idx  =    0;
#line 105 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
int rup_data_max  =    0;
#line 113 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
enum sort_type sort_type  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int compare(void const   *a1 , void const   *a2 ) 
{ 
  struct rup_data  const  *d1 ;
  struct rup_data  const  *d2 ;
  int tmp ;

  {
#line 118
  d1 = (struct rup_data  const  *)a1;
#line 119
  d2 = (struct rup_data  const  *)a2;
  {
#line 122
  if ((unsigned int )sort_type == 1U) {
#line 122
    goto case_1;
  }
#line 124
  if ((unsigned int )sort_type == 2U) {
#line 124
    goto case_2;
  }
#line 127
  if ((unsigned int )sort_type == 3U) {
#line 127
    goto case_3;
  }
#line 130
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 123
  tmp = strcmp((char const   *)d1->host, (char const   *)d2->host);
  }
#line 123
  return (tmp);
  case_2: /* CIL Label */ 
#line 125
  return (d1->statstime.avenrun[0] - d2->statstime.avenrun[0]);
  case_3: /* CIL Label */ 
#line 128
  return ((int )(d1->statstime.boottime.tv_sec - d2->statstime.boottime.tv_sec));
  switch_default: /* CIL Label */ 
  {
#line 132
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static void remember_rup_data(char const   *host___0 , struct statstime  const  *st ) 
{ 
  void *tmp ;

  {
#line 140
  if (rup_data_idx >= rup_data_max) {
    {
#line 141
    rup_data_max += 16;
#line 142
    tmp = realloc((void *)rup_data, (unsigned long )rup_data_max * sizeof(struct rup_data ));
#line 142
    rup_data = (struct rup_data *)tmp;
    }
#line 144
    if ((unsigned long )rup_data == (unsigned long )((void *)0)) {
      {
#line 145
      err(1, "realloc");
      }
    }
  }
  {
#line 150
  (rup_data + rup_data_idx)->host = strdup(host___0);
#line 151
  (rup_data + rup_data_idx)->statstime = (struct statstime )*st;
#line 152
  rup_data_idx ++;
  }
#line 153
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int rstat_reply(char *replyp , struct sockaddr_in *raddrp ) 
{ 
  struct hostent *hp ;
  char const   *host___0 ;
  statstime *host_stat ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 162
  host_stat = (statstime *)replyp;
#line 164
  tmp___0 = search_host___0(raddrp->sin_addr);
  }
#line 164
  if (! tmp___0) {
    {
#line 165
    hp = gethostbyaddr((void const   *)((char *)(& raddrp->sin_addr.s_addr)), (__socklen_t )sizeof(struct in_addr ),
                       2);
    }
#line 168
    if (hp) {
#line 169
      host___0 = (char const   *)hp->h_name;
    } else {
      {
#line 171
      tmp = inet_ntoa(raddrp->sin_addr);
#line 171
      host___0 = (char const   *)tmp;
      }
    }
    {
#line 173
    remember_host___0(raddrp->sin_addr);
    }
#line 175
    if ((unsigned int )sort_type != 0U) {
      {
#line 176
      remember_rup_data(host___0, (struct statstime  const  *)host_stat);
      }
    } else {
      {
#line 178
      print_rup_data(host___0, host_stat);
      }
    }
  }
#line 182
  return (0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static int print_rup_data(char const   *host___0 , statstime *host_stat ) 
{ 
  time_t hosttime ;
  long uptime ;
  struct tm *time___0 ;
  struct tm *tmp ;
  int tmp___0 ;
  int days ;
  char const   *tmp___1 ;
  int hours ;
  int mins ;

  {
  {
#line 192
  printf((char const   */* __restrict  */)"%-*.*s", 24, 24, host___0);
#line 194
  hosttime = (time_t )host_stat->curtime.tv_sec;
#line 195
  host_stat->curtime.tv_sec -= host_stat->boottime.tv_sec;
#line 196
  uptime = (long )host_stat->curtime.tv_sec;
  }
#line 198
  if (printtime) {
#line 199
    if (printseconds) {
      {
#line 200
      printf((char const   */* __restrict  */)" %-12lld", (unsigned long long )hosttime);
      }
    } else {
      {
#line 203
      tmp = localtime((time_t const   *)(& hosttime));
#line 203
      time___0 = tmp;
      }
#line 204
      if (time___0->tm_hour >= 12) {
#line 204
        tmp___0 = 'p';
      } else {
#line 204
        tmp___0 = 'a';
      }
      {
#line 204
      printf((char const   */* __restrict  */)" %2d:%02d%cm", time___0->tm_hour % 12,
             time___0->tm_min, tmp___0);
      }
    }
  }
#line 210
  if (printseconds) {
    {
#line 211
    printf((char const   */* __restrict  */)" up %12ld", uptime);
    }
  } else {
    {
#line 214
    uptime /= 60L;
#line 215
    printf((char const   */* __restrict  */)" up ");
    }
#line 216
    if (uptime > 1440L) {
#line 217
      days = (int )(uptime / 1440L);
#line 218
      if (days > 1) {
#line 218
        tmp___1 = "days,";
      } else {
#line 218
        tmp___1 = "day, ";
      }
      {
#line 218
      printf((char const   */* __restrict  */)"%3d %s ", days, tmp___1);
#line 219
      uptime %= 1440L;
      }
    } else {
      {
#line 222
      printf((char const   */* __restrict  */)"          ");
      }
    }
#line 225
    if (uptime > 60L) {
      {
#line 226
      hours = (int )(uptime / 60L);
#line 227
      mins = (int )(uptime % 60L);
#line 228
      printf((char const   */* __restrict  */)"%2d:%02d,   ", hours, mins);
      }
    } else {
      {
#line 231
      printf((char const   */* __restrict  */)"%2ld mins, ", uptime);
      }
    }
  }
  {
#line 234
  printf((char const   */* __restrict  */)" load average: %.2f %.2f %.2f\n", (double )host_stat->avenrun[0] / (double )(1 << 8),
         (double )host_stat->avenrun[1] / (double )(1 << 8), (double )host_stat->avenrun[2] / (double )(1 << 8));
  }
#line 239
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static void onehost___0(char const   *host___0 ) 
{ 
  CLIENT *rstat_clnt ;
  statstime host_stat ;
  struct timeval foo ;
  char *tmp ;
  char *tmp___0 ;
  enum clnt_stat tmp___1 ;

  {
  {
#line 250
  rstat_clnt = clnt_create(host___0, (u_long const   )100001, (u_long const   )3,
                           "udp");
  }
#line 251
  if ((unsigned long )rstat_clnt == (unsigned long )((void *)0)) {
    {
#line 252
    tmp = clnt_spcreateerror(host___0);
#line 252
    warnx("%s", tmp);
    }
#line 253
    return;
  }
  {
#line 256
  memset((void *)(& host_stat), 0, sizeof(host_stat));
#line 257
  tmp___1 = (*((rstat_clnt->cl_ops)->cl_call))(rstat_clnt, (u_long )1, (bool_t (*)(XDR * ,
                                                                                   void * 
                                                                                   , ...))(& xdr_void),
                                               (caddr_t )((void *)0), (bool_t (*)(XDR * ,
                                                                                  void * 
                                                                                  , ...))(& xdr_statstime),
                                               (char *)(& host_stat), foo);
  }
#line 257
  if ((unsigned int )tmp___1 != 0U) {
    {
#line 262
    tmp___0 = clnt_sperror(rstat_clnt, host___0);
#line 262
    warnx("%s", tmp___0);
    }
#line 263
    return;
  }
  {
#line 266
  print_rup_data(host___0, & host_stat);
#line 267
  (*((rstat_clnt->cl_ops)->cl_destroy))(rstat_clnt);
  }
#line 268
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static void allhosts___0(void) 
{ 
  statstime host_stat ;
  enum clnt_stat clnt_stat ;
  int i ;
  char *tmp ;

  {
#line 278
  if ((unsigned int )sort_type != 0U) {
    {
#line 279
    printf((char const   */* __restrict  */)"collecting responses...");
#line 280
    fflush(stdout);
    }
  }
  {
#line 283
  clnt_stat = clnt_broadcast((u_long const   )100001, (u_long const   )3, (u_long const   )1,
                             (bool_t (*)(XDR * , void *  , ...))(& xdr_void), (caddr_t )((void *)0),
                             (bool_t (*)(XDR * , void *  , ...))(& xdr_statstime),
                             (char *)(& host_stat), & rstat_reply);
  }
#line 288
  if ((unsigned int )clnt_stat != 0U) {
#line 288
    if ((unsigned int )clnt_stat != 5U) {
      {
#line 289
      tmp = clnt_sperrno(clnt_stat);
#line 289
      warnx("%s", tmp);
#line 290
      exit(1);
      }
    }
  }
#line 293
  if ((unsigned int )sort_type != 0U) {
    {
#line 294
    putchar('\n');
#line 295
    qsort((void *)rup_data, (size_t )rup_data_idx, sizeof(struct rup_data ), & compare);
#line 297
    i = 0;
    }
    {
#line 297
    while (1) {
      while_continue: /* CIL Label */ ;
#line 297
      if (! (i < rup_data_idx)) {
#line 297
        goto while_break;
      }
      {
#line 298
      print_rup_data((char const   *)(rup_data + i)->host, & (rup_data + i)->statstime);
#line 297
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 301
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/netkit-rusers-0.17/rup/rup.c"
static void usage___0(void) 
{ 


  {
  {
#line 305
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: rup [-dhlt] [hosts ...]\n");
#line 306
  exit(1);
  }
}
}
