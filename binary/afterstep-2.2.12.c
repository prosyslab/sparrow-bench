/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_32 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_32 Visual;
#line 267
struct _XDisplay;
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 442 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_44 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 442 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_44 XRectangle;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 98 "/usr/include/X11/Xmd.h"
typedef int INT32;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_269 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_268 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_269 min_aspect ;
   struct __anonstruct_min_aspect_269 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_268 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_270 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_270 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_271 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_271 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_274 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_274 XClassHint;
#line 287 "/usr/include/X11/Xutil.h"
struct __anonstruct_XVisualInfo_275 {
   Visual *visual ;
   VisualID visualid ;
   int screen ;
   int depth ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int colormap_size ;
   int bits_per_rgb ;
};
#line 287 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XVisualInfo_275 XVisualInfo;
#line 53 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/astypes.h"
typedef unsigned long ASFlagType;
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
struct wild_reg_exp;
#line 23 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
typedef unsigned long ASHashableValueBase;
#line 24 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
typedef ASHashableValueBase const   ASHashableValue;
#line 47 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
struct ASHashItem {
   struct ASHashItem *next ;
   ASHashableValueBase value ;
   void *data ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
typedef struct ASHashItem ASHashItem;
#line 56 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
typedef unsigned short ASHashKey;
#line 57 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
typedef ASHashItem *ASHashBucket;
#line 59 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
struct ASHashTable {
   ASHashKey size ;
   ASHashBucket *buckets ;
   ASHashKey buckets_used ;
   unsigned long items_num ;
   ASHashItem *most_recent ;
   ASHashKey (*hash_func)(ASHashableValue value , ASHashKey hash_size ) ;
   long (*compare_func)(ASHashableValue value1 , ASHashableValue value2 ) ;
   void (*item_destroy_func)(ASHashableValue value , void *data ) ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/ashash.h"
typedef struct ASHashTable ASHashTable;
#line 8 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/asvector.h"
struct ASVector {
   void *memory ;
   size_t allocated ;
   size_t used ;
   size_t unit ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/fs.h"
struct direntry {
   mode_t d_mode ;
   time_t d_mtime ;
   off_t d_size ;
   char d_name[1] ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 16 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/regexp.h"
struct reg_exp;
#line 18 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/regexp.h"
struct wild_reg_exp {
   unsigned char *raw ;
   struct reg_exp *head ;
   struct reg_exp *tail ;
   struct reg_exp *longest ;
   unsigned char max_size ;
   unsigned char hard_total ;
   unsigned char soft_total ;
   unsigned char wildcards_num ;
   regex_t *p_reg ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/aslist.h"
struct ASBiDirElem {
   struct ASBiDirElem *next ;
   struct ASBiDirElem *prev ;
   void *data ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/aslist.h"
typedef struct ASBiDirElem ASBiDirElem;
#line 22 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/aslist.h"
struct ASBiDirList {
   size_t count ;
   void (*destroy_func)(void *data ) ;
   ASBiDirElem *head ;
   ASBiDirElem *tail ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/aslist.h"
typedef struct ASBiDirList ASBiDirList;
#line 17 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/functions.h"
struct ASImage;
#line 193 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/functions.h"
struct FunctionData {
   CARD32 func ;
   INT32 func_val[2] ;
   INT32 unit_val[2] ;
   char unit[2] ;
   char *name ;
   char *text ;
   char hotkey ;
   void *popup ;
   int name_encoding ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
struct ASImageManager;
#line 10
struct ASVisual;
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
struct icon_t {
   struct ASImage *image ;
   Pixmap pix ;
   Pixmap mask ;
   Pixmap alpha ;
   int width ;
   int height ;
   Atom im_name ;
};
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
typedef struct icon_t icon_t;
#line 24 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
typedef icon_t MyIcon;
#line 38 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
struct button_t {
   MyIcon unpressed ;
   MyIcon pressed ;
   unsigned int width ;
   unsigned int height ;
   int context ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
typedef struct button_t button_t;
#line 47 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/myicon.h"
typedef button_t MyButton;
#line 279 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/afterstep.h"
struct __anonstruct_ASGeometry_292 {
   int flags ;
   int x ;
   int y ;
   unsigned int width ;
   unsigned int height ;
};
#line 279 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/afterstep.h"
typedef struct __anonstruct_ASGeometry_292 ASGeometry;
#line 291 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/afterstep.h"
struct ASRectangle {
   long x ;
   long y ;
   unsigned long width ;
   unsigned long height ;
};
#line 291 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/afterstep.h"
typedef struct ASRectangle ASRectangle;
#line 330
struct ASHints;
#line 331
struct ASStatusHints;
#line 332
struct ASCanvas;
#line 57 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asapp.h"
struct ASSession;
#line 58
struct ASDesktopCategory;
#line 59
struct ASDesktopEntry;
#line 60
struct ASCategoryTree;
#line 148 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asapp.h"
struct ASProgArgs {
   int saved_argc ;
   char **saved_argv ;
   ASFlagType mask ;
   char *override_config ;
   char *override_home ;
   char *override_share ;
   char *override_look ;
   char *override_feel ;
   char *display_name ;
   ASFlagType flags ;
   int verbosity_level ;
   Window src_window ;
   int src_context ;
   char *log_file ;
   char *locale ;
   ASGeometry geometry ;
   int gravity ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asapp.h"
typedef struct ASProgArgs ASProgArgs;
#line 199
enum __anonenum_module_name_collision_319 {
    ASE_AllowModuleNameCollision = 0,
    ASE_KillOldModuleOnNameCollision = 1,
    ASE_KillNewModuleOnNameCollision = 2
} ;
#line 199 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asapp.h"
struct ASEnvironment {
   ASFlagType flags ;
   char *module_path ;
   char *sound_path ;
   char *icon_path ;
   char *pixmap_path ;
   char *font_path ;
   char *cursor_path ;
   unsigned short desk_pages_h ;
   unsigned short desk_pages_v ;
   unsigned short desk_scale ;
   enum __anonenum_module_name_collision_319 module_name_collision ;
   char *tool_command[3] ;
   char *gtkrc_path ;
   char *gtkrc20_path ;
   char *IconTheme ;
   char *IconThemePath ;
   char *IconThemeFallback ;
};
#line 328
struct ScreenInfo;
#line 367
struct ASFeel;
#line 368
struct MyLook;
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/session.h"
struct ASDeskSession {
   int desk ;
   char *background_file ;
   char *feel_file ;
   struct ASFeel *feel ;
   char *look_file ;
   struct MyLook *look ;
   char *theme_file ;
   char *colorscheme_file ;
};
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/session.h"
typedef struct ASDeskSession ASDeskSession;
#line 24 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/session.h"
struct ASSession {
   struct ScreenInfo *scr ;
   int colordepth ;
   char *ashome ;
   char *asshare ;
   char *overriding_file ;
   char *overriding_look ;
   char *overriding_feel ;
   char *overriding_theme ;
   char *overriding_colorscheme ;
   char *workspace_state ;
   char *webcache ;
   ASDeskSession *defaults ;
   ASDeskSession **desks ;
   unsigned int desks_used ;
   unsigned int desks_allocated ;
   void (*on_feel_changed_func)(struct ScreenInfo *scr , int desk , struct ASFeel *old_feel ) ;
   void (*on_look_changed_func)(struct ScreenInfo *scr , int desk , struct MyLook *old_look ) ;
   int changed ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/session.h"
typedef struct ASSession ASSession;
#line 7 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
enum __anonenum_ASDesktopEntryTypes_320 {
    ASDE_TypeApplication = 0,
    ASDE_TypeLink = 1,
    ASDE_TypeFSDevice = 2,
    ASDE_TypeDirectory = 3,
    ASDE_Types = 4
} ;
#line 7 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
typedef enum __anonenum_ASDesktopEntryTypes_320 ASDesktopEntryTypes;
#line 21 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
struct ASDesktopEntry {
   int ref_count ;
   ASFlagType flags ;
   ASDesktopEntryTypes type ;
   char *Name_localized ;
   char *Comment_localized ;
   char *Name ;
   char *GenericName ;
   char *Comment ;
   char *Icon ;
   char *TryExec ;
   char *Exec ;
   char *Path ;
   char *SwallowTitle ;
   char *SwallowExec ;
   char *SortOrder ;
   char *Categories ;
   char *OnlyShowIn ;
   char *NotShowIn ;
   char *StartupWMClass ;
   char *IndexName ;
   char *Aliases ;
   int categories_len ;
   char **categories_shortcuts ;
   int categories_num ;
   int show_in_len ;
   char **show_in_shortcuts ;
   int show_in_num ;
   int not_show_in_len ;
   char **not_show_in_shortcuts ;
   int not_show_in_num ;
   char *clean_exec ;
   char *origin ;
   int aliases_len ;
   char **aliases_shortcuts ;
   int aliases_num ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
typedef struct ASDesktopEntry ASDesktopEntry;
#line 112 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
struct ASDesktopCategory {
   int ref_count ;
   char *index_name ;
   char *name ;
   struct ASVector *entries ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
typedef struct ASDesktopCategory ASDesktopCategory;
#line 123 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
struct ASCategoryTree {
   ASFlagType flags ;
   char *name ;
   char *icon_path ;
   int max_depth ;
   char **dir_list ;
   int dir_num ;
   ASDesktopCategory *default_category ;
   struct ASHashTable *categories ;
   struct ASHashTable *entries ;
};
#line 123 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
typedef struct ASCategoryTree ASCategoryTree;
#line 63 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterImage/asvisual.h"
typedef CARD32 ARGB32;
#line 107
struct ASScanline;
#line 207
enum __anonenum_as_colormap_type_322 {
    ACM_None = 0,
    ACM_3BPP = 1,
    ACM_6BPP = 2,
    ACM_12BPP = 3
} ;
#line 207 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterImage/asvisual.h"
union __anonunion_as_colormap_reverse_323 {
   ARGB32 *xref ;
   struct ASHashTable *hash ;
};
#line 207 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterImage/asvisual.h"
struct ASVisual {
   Display *dpy ;
   XVisualInfo visual_info ;
   unsigned long rshift ;
   unsigned long gshift ;
   unsigned long bshift ;
   unsigned long rbits ;
   unsigned long gbits ;
   unsigned long bbits ;
   unsigned long true_depth ;
   int BGR_mode ;
   int msb_first ;
   Colormap colormap ;
   int own_colormap ;
   unsigned long black_pixel ;
   unsigned long white_pixel ;
   enum __anonenum_as_colormap_type_322 as_colormap_type ;
   unsigned long *as_colormap ;
   union __anonunion_as_colormap_reverse_323 as_colormap_reverse ;
   CARD32 (*color2pixel_func)(struct ASVisual *asv , CARD32 encoded_color , unsigned long *pixel ) ;
   void (*pixel2color_func)(struct ASVisual *asv , unsigned long pixel , CARD32 *red ,
                            CARD32 *green , CARD32 *blue ) ;
   void (*ximage2scanline_func)(struct ASVisual *asv , XImage *xim , struct ASScanline *sl ,
                                int y , unsigned char *xim_data ) ;
   void (*scanline2ximage_func)(struct ASVisual *asv , XImage *xim , struct ASScanline *sl ,
                                int y , unsigned char *xim_data ) ;
   ASFlagType glx_support ;
   void *glx_scratch_gc_indirect ;
   void *glx_scratch_gc_direct ;
   Window scratch_window ;
};
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct ASDatabaseRecord;
#line 18
enum __anonenum_HintsTypes_324 {
    HINTS_ICCCM = 0,
    HINTS_GroupLead = 1,
    HINTS_Transient = 2,
    HINTS_Motif = 3,
    HINTS_Gnome = 4,
    HINTS_KDE = 5,
    HINTS_ExtendedWM = 6,
    HINTS_XResources = 7,
    HINTS_ASDatabase = 8,
    HINTS_Supported = 9
} ;
#line 18 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
typedef enum __anonenum_HintsTypes_324 HintsTypes;
#line 334 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct MwmHints {
   CARD32 flags ;
   CARD32 functions ;
   CARD32 decorations ;
   INT32 inputMode ;
   CARD32 status ;
};
#line 334 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
typedef struct MwmHints MwmHints;
#line 421 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct GnomeHints {
   ASFlagType flags ;
   CARD32 layer ;
   CARD32 state ;
   CARD32 workspace ;
   CARD32 hints ;
   CARD32 expanded_size[4] ;
};
#line 421 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
typedef struct GnomeHints GnomeHints;
#line 478 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct ExtendedWMHints {
   ASFlagType flags ;
   ASFlagType type_flags ;
   ASFlagType state_flags ;
   XTextProperty *name ;
   XTextProperty *icon_name ;
   XTextProperty *visible_name ;
   XTextProperty *visible_icon_name ;
   CARD32 desktop ;
   CARD32 pid ;
   CARD32 *icon ;
   long icon_length ;
   CARD32 window_opacity ;
};
#line 478 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
typedef struct ExtendedWMHints ExtendedWMHints;
#line 550 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct KDEHints {
   ASFlagType flags ;
   Window systray_window_for ;
};
#line 550 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
typedef struct KDEHints KDEHints;
#line 563 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct ASParentHints {
   Window parent ;
   ASFlagType flags ;
   int desktop ;
   int viewport_x ;
   int viewport_y ;
};
#line 563 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
typedef struct ASParentHints ASParentHints;
#line 586 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/clientprops.h"
struct ASRawHints {
   struct ScreenInfo *scr ;
   XTextProperty *wm_name ;
   XTextProperty *wm_icon_name ;
   XClassHint *wm_class ;
   ASRectangle placement ;
   unsigned int border_width ;
   XWMHints *wm_hints ;
   ASParentHints *group_leader ;
   XSizeHints *wm_normal_hints ;
   ASParentHints *transient_for ;
   ASFlagType wm_protocols ;
   CARD32 *wm_cmap_windows ;
   long wm_cmap_win_count ;
   XTextProperty *wm_client_machine ;
   int wm_cmd_argc ;
   char **wm_cmd_argv ;
   INT32 wm_state ;
   CARD32 wm_state_icon_win ;
   MwmHints *motif_hints ;
   GnomeHints gnome_hints ;
   ExtendedWMHints extwm_hints ;
   KDEHints kde_hints ;
   ASFlagType hints_types ;
};
#line 169 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asstorage.h"
typedef CARD32 ASStorageID;
#line 120 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asimage.h"
struct ASImageAlternative;
#line 126 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asimage.h"
struct ASImageAlternative {
   XImage *ximage ;
   XImage *mask_ximage ;
   ARGB32 *argb32 ;
   double *vector ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asimage.h"
struct ASImage {
   unsigned long magic ;
   unsigned int width ;
   unsigned int height ;
   ASStorageID *alpha ;
   ASStorageID *red ;
   ASStorageID *green ;
   ASStorageID *blue ;
   ASStorageID *channels[4] ;
   ARGB32 back_color ;
   struct ASImageAlternative alt ;
   struct ASImageManager *imageman ;
   int ref_count ;
   char *name ;
   ASFlagType flags ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asimage.h"
typedef struct ASImage ASImage;
#line 216 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asimage.h"
struct ASImageManager {
   ASHashTable *image_hash ;
   char *search_path[9] ;
   double gamma ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/scanline.h"
struct ASScanline {
   CARD32 flags ;
   CARD32 *buffer ;
   CARD32 *blue ;
   CARD32 *green ;
   CARD32 *red ;
   CARD32 *alpha ;
   CARD32 *channels[4] ;
   CARD32 *xc3 ;
   CARD32 *xc2 ;
   CARD32 *xc1 ;
   ARGB32 back_color ;
   unsigned int width ;
   unsigned int shift ;
   unsigned int offset_x ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asfont.h"
struct ASFontManager;
#line 224 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../libAfterImage/asfont.h"
struct ASFontManager {
   Display *dpy ;
   char *font_path ;
   ASHashTable *fonts_hash ;
   size_t unicode_used ;
   CARD32 *local_unicode ;
   int ft_ok ;
   void *pad ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/mylook.h"
struct MyStyle;
#line 18
struct ASSupportedHints;
#line 280
struct ASBalloonLook;
#line 280 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/mylook.h"
struct MyLook {
   unsigned long magic ;
   char *name ;
   int ref_count ;
   unsigned long flags ;
   unsigned short look_id ;
   unsigned short deskback_id_base ;
   struct ASHashTable *styles_list ;
   struct ASHashTable *backs_list ;
   struct ASHashTable *desk_configs ;
   unsigned int KillBackgroundThreshold ;
   struct MyStyle *MSMenu[6] ;
   struct MyStyle *MSWindow[5] ;
   ASGeometry resize_move_geometry ;
   char *DefaultIcon ;
   struct icon_t *MenuArrow ;
   char *CursorFore ;
   char *CursorBack ;
   MyButton buttons[10] ;
   unsigned int button_xref[10] ;
   MyButton *ordered_buttons[10] ;
   unsigned int button_first_right ;
   int DrawMenuBorders ;
   int StartMenuSortMode ;
   int menu_hcm ;
   int menu_icm ;
   int menu_scm ;
   ASGeometry *configured_icon_areas ;
   unsigned int configured_icon_areas_num ;
   unsigned int ButtonWidth ;
   unsigned int ButtonHeight ;
   unsigned int ButtonIconSpacing ;
   ASFlagType ButtonAlign ;
   ASFlagType ButtonBevel ;
   unsigned int minipixmap_width ;
   unsigned int minipixmap_height ;
   int RubberBand ;
   int TitleButtonStyle ;
   int TitleButtonSpacing[2] ;
   int TitleButtonXOffset[2] ;
   int TitleButtonYOffset[2] ;
   int TitleTextAlign ;
   struct ASSupportedHints *supported_hints ;
   struct ASHashTable *FramesList ;
   char *DefaultFrameName ;
   struct ASBalloonLook *balloon_look ;
   ARGB32 desktop_animation_tint ;
   struct ScreenInfo *scr ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/mylook.h"
typedef struct MyLook MyLook;
#line 143 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
union __anonunion_icon_347 {
   Window window ;
   Pixmap pixmap ;
};
#line 143 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
struct __anonstruct_min_aspect_348 {
   int x ;
   int y ;
};
#line 143 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
struct ASHints {
   char *names[9] ;
   char *res_name ;
   char *res_class ;
   char *icon_name ;
   int res_name_idx ;
   int res_class_idx ;
   int icon_name_idx ;
   unsigned char names_encoding[9] ;
   char *matched_name0 ;
   unsigned char matched_name0_encoding ;
   ASFlagType flags ;
   ASFlagType protocols ;
   ASFlagType function_mask ;
   ASFlagType client_icon_flags ;
   union __anonunion_icon_347 icon ;
   Pixmap icon_mask ;
   CARD32 *icon_argb ;
   int icon_x ;
   int icon_y ;
   char *icon_file ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_348 min_aspect ;
   struct __anonstruct_min_aspect_348 max_aspect ;
   int base_width ;
   int base_height ;
   int gravity ;
   unsigned int border_width ;
   unsigned int handle_width ;
   Window group_lead ;
   Window transient_for ;
   CARD32 *cmap_windows ;
   int pid ;
   char *frame_name ;
   char *windowbox_name ;
   char *mystyle_names[5] ;
   ASFlagType disabled_buttons ;
   ASFlagType hints_types_raw ;
   ASFlagType hints_types_clean ;
   char *client_host ;
   char *client_cmd ;
   CARD32 window_opacity ;
   ASFlagType extwm_window_type ;
};
#line 143 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
typedef struct ASHints ASHints;
#line 220 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
struct ASStatusHints {
   ASFlagType flags ;
   int x ;
   int y ;
   unsigned int width ;
   unsigned int height ;
   unsigned int border_width ;
   int viewport_x ;
   int viewport_y ;
   int desktop ;
   int layer ;
   Window icon_window ;
   unsigned int frame_size[4] ;
   unsigned int frame_border_width ;
};
#line 220 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
typedef struct ASStatusHints ASStatusHints;
#line 243 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
typedef void (*hints_merge_func)(ASHints *clean , struct ASRawHints *raw , struct ASDatabaseRecord *db_rec ,
                                 ASStatusHints *status , ASFlagType what );
#line 248 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/hints.h"
struct ASSupportedHints {
   ASFlagType hints_flags ;
   HintsTypes hints_types[9] ;
   hints_merge_func merge_funcs[9] ;
   int hints_num ;
};
#line 120 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asdatabase.h"
struct ASDatabaseRecord {
   unsigned long magic ;
   struct wild_reg_exp *regexp ;
   unsigned long set_flags ;
   unsigned long flags ;
   unsigned long set_buttons ;
   unsigned long buttons ;
   unsigned long set_data_flags ;
   ASGeometry default_geometry ;
   int desk ;
   int layer ;
   int viewport_x ;
   int viewport_y ;
   int border_width ;
   int resize_width ;
   int gravity ;
   char *icon_file ;
   char *frame_name ;
   char *windowbox_name ;
   int window_opacity ;
   char *window_styles[5] ;
   int own_strings ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
enum ASWinListSortOrderVals {
    ASO_Circulation = 0,
    ASO_Alpha = 1,
    ASO_Stacking = 2,
    ASO_Creation = 3,
    ASO_Default = 0
} ;
#line 38 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
typedef enum ASWinListSortOrderVals ASWinListSortOrderVals;
#line 116
enum __anonenum_ASPlacementStrategy_351 {
    ASP_SmartPlacement = 0,
    ASP_RandomPlacement = 1,
    ASP_Tile = 2,
    ASP_Cascade = 3,
    ASP_UnderPointer = 4,
    ASP_Manual = 5
} ;
#line 116 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
typedef enum __anonenum_ASPlacementStrategy_351 ASPlacementStrategy;
#line 131 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
struct ASWindowBox {
   ASFlagType set_flags ;
   ASFlagType flags ;
   char *name ;
   ASGeometry area ;
   ASPlacementStrategy main_strategy ;
   ASPlacementStrategy backup_strategy ;
   unsigned int min_width ;
   unsigned int min_height ;
   unsigned int max_width ;
   unsigned int max_height ;
   int min_layer ;
   int max_layer ;
   int desk ;
   int x_spacing ;
   int y_spacing ;
   unsigned int cascade_pos ;
};
#line 131 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
typedef struct ASWindowBox ASWindowBox;
#line 179 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
struct MouseButton {
   int Button ;
   int Context ;
   int Modifier ;
   struct MouseButton *NextButton ;
   struct FunctionData *fdata ;
};
#line 188 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
struct FuncKey {
   struct FuncKey *next ;
   char *name ;
   KeyCode keycode ;
   int cont ;
   int mods ;
   struct FunctionData *fdata ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
struct ASFeel {
   unsigned long magic ;
   unsigned long set_flags ;
   unsigned long flags ;
   ASFlagType deprecated_flags ;
   ASFlagType set_val_flags ;
   unsigned int ClickTime ;
   unsigned int OpaqueMove ;
   unsigned int OpaqueResize ;
   int AutoRaiseDelay ;
   unsigned int AutoReverse ;
   int XorValue ;
   int Xzap ;
   int Yzap ;
   long RaiseButtons ;
   int EdgeScrollX ;
   int EdgeScrollY ;
   int EdgeResistanceScroll ;
   int EdgeAttractionScreen ;
   int EdgeAttractionWindow ;
   int EdgeResistanceMove ;
   int EdgeResistanceDragScroll ;
   int ShadeAnimationSteps ;
   struct ASHashTable *Popups ;
   struct ASHashTable *ComplexFunctions ;
   struct MouseButton *MouseButtonRoot ;
   struct FuncKey *FuncKeyRoot ;
   Cursor cursors[32] ;
   ASFlagType buttons2grab ;
   unsigned int no_snaping_mod ;
   ASWindowBox *window_boxes ;
   ASWindowBox *default_window_box ;
   char *default_window_box_name ;
   unsigned int window_boxes_num ;
   unsigned int recent_submenu_items ;
   unsigned int desk_cover_animation_steps ;
   unsigned int desk_cover_animation_type ;
   int conserve_memory ;
   ASWinListSortOrderVals winlist_sort_order ;
};
#line 199 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asfeel.h"
typedef struct ASFeel ASFeel;
#line 35 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/screen.h"
struct __anonstruct_ASPanFrame_354 {
   Window win ;
   int isMapped ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/screen.h"
typedef struct __anonstruct_ASPanFrame_354 ASPanFrame;
#line 55
struct ASMoveResizeData;
#line 63 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/screen.h"
struct ASIconBox {
   int desktop ;
   ASGeometry *areas ;
   unsigned short areas_num ;
   ASBiDirList *icons ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/screen.h"
struct ASBackgroundHandler {
   Pixmap pmap ;
   unsigned int pmap_width ;
   unsigned int pmap_height ;
   int cmd_pid ;
   ASImage *im ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/screen.h"
typedef struct ASBackgroundHandler ASBackgroundHandler;
#line 79
struct ASWMProps;
#line 79
struct ASWindowList;
#line 79 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/screen.h"
struct ScreenInfo {
   unsigned long screen ;
   int d_depth ;
   int NumberOfScreens ;
   int MyDisplayWidth ;
   int MyDisplayHeight ;
   int localhost ;
   char *rdisplay_string ;
   char *display_string ;
   struct ASWMProps *wmprops ;
   struct ASVisual *asv ;
   Window Root ;
   struct ASImage *RootImage ;
   struct ASCanvas *RootCanvas ;
   XRectangle RootClipArea ;
   ASBackgroundHandler *RootBackground ;
   Window SizeWindow ;
   Window ServiceWin ;
   struct ASWindowList *Windows ;
   struct ASIconBox *default_icon_box ;
   struct ASHashTable *icon_boxes ;
   ASPanFrame PanFrame[4] ;
   int usePanFrames ;
   struct ASMoveResizeData *moveresize_in_progress ;
   int randomx ;
   int randomy ;
   unsigned int VScale ;
   int VxMax ;
   int VyMax ;
   int Vx ;
   int Vy ;
   int CurrentDesk ;
   int LastValidDesk ;
   Time last_Timestamp ;
   Time menu_grab_Timestamp ;
   ASFeel Feel ;
   MyLook Look ;
   Cursor standard_cursors[32] ;
   GC DrawGC ;
   GC RootGC ;
   int xinerama_screens_num ;
   XRectangle *xinerama_screens ;
   struct ASFontManager *font_manager ;
   struct ASImageManager *image_manager ;
   int (*on_dead_window)(Window w ) ;
   int XineEventBase ;
   int XineErrorBase ;
   int ShmCompletionEventType ;
   int ShapeEventBase ;
   int ShapeErrorBase ;
};
#line 114 "/usr/include/X11/Xmd.h"
typedef unsigned char CARD8;
#line 81 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
enum __anonenum_ASFontType_289 {
    ASF_X11 = 0,
    ASF_Freetype = 1,
    ASF_GuessWho = 2,
    ASF_Monospaced = 4,
    ASF_RightToLeft = 8,
    ASF_HasKerning = 16
} ;
#line 81 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef enum __anonenum_ASFontType_289 ASFontType;
#line 96
struct ASFont;
#line 106 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
struct ASGlyph {
   CARD8 *pixmap ;
   short width ;
   short height ;
   short lead ;
   short step ;
   short ascend ;
   short descend ;
   unsigned int font_gid ;
   long xrender_gid ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef struct ASGlyph ASGlyph;
#line 135 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
struct ASGlyphRange {
   unsigned long min_char ;
   unsigned long max_char ;
   ASGlyph *glyphs ;
   struct ASGlyphRange *below ;
   struct ASGlyphRange *above ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef struct ASGlyphRange ASGlyphRange;
#line 163 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
struct ASFont {
   unsigned long magic ;
   int ref_count ;
   struct ASFontManager *fontman ;
   char *name ;
   ASFontType type ;
   ASFlagType flags ;
   ASGlyphRange *codemap ;
   ASHashTable *locale_glyphs ;
   ASGlyph default_glyph ;
   int max_height ;
   int max_ascend ;
   int max_descend ;
   int space_size ;
   int spacing_x ;
   int spacing_y ;
   int cell_width ;
   int cell_height ;
   CARD32 *pad ;
   unsigned long xrender_glyphset ;
};
#line 163 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef struct ASFont ASFont;
#line 263
enum __anonenum_ASCharType_290 {
    ASCT_UTF8 = 0,
    ASCT_Char = 1,
    ASCT_Unicode = 4
} ;
#line 263 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef enum __anonenum_ASCharType_290 ASCharType;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_25 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_25 Depth;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_26 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_26 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_27 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_27 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_28 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_28 XSetWindowAttributes;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_42 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_42 *_XPrivDisplay;
#line 207 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asvisual.h"
typedef struct ASVisual ASVisual;
#line 45 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../blender.h"
typedef void (*merge_scanlines_func)(struct ASScanline *bottom , struct ASScanline *top ,
                                     int offset );
#line 12 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
struct ASImageBevel;
#line 87
enum __anonenum_ASAltImFormats_287 {
    ASA_ASImage = 0,
    ASA_XImage = 1,
    ASA_MaskXImage = 2,
    ASA_ScratchXImage = 3,
    ASA_ScratchMaskXImage = 4,
    ASA_ScratchXImageAndAlpha = 5,
    ASA_ARGB32 = 6,
    ASA_Vector = 7,
    ASA_Formats = 8
} ;
#line 87 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
typedef enum __anonenum_ASAltImFormats_287 ASAltImFormats;
#line 289 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
struct ASImageLayer {
   ASImage *im ;
   ARGB32 solid_color ;
   int dst_x ;
   int dst_y ;
   int clip_x ;
   int clip_y ;
   unsigned int clip_width ;
   unsigned int clip_height ;
   ARGB32 tint ;
   struct ASImageBevel *bevel ;
   int bevel_x ;
   int bevel_y ;
   unsigned int bevel_width ;
   unsigned int bevel_height ;
   int merge_mode ;
   void (*merge_scanlines)(struct ASScanline *bottom , struct ASScanline *top , int offset ) ;
   struct ASImageLayer *next ;
   void *data ;
};
#line 289 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
typedef struct ASImageLayer ASImageLayer;
#line 75 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../imencdec.h"
struct ASImageBevel {
   ASFlagType type ;
   ARGB32 hi_color ;
   ARGB32 lo_color ;
   ARGB32 hihi_color ;
   ARGB32 hilo_color ;
   ARGB32 lolo_color ;
   unsigned short left_outline ;
   unsigned short top_outline ;
   unsigned short right_outline ;
   unsigned short bottom_outline ;
   unsigned short left_inline ;
   unsigned short top_inline ;
   unsigned short right_inline ;
   unsigned short bottom_inline ;
};
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_36 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_36 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_37 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_37 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_38 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_38 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_39 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_40 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_41 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_42 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_43 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_44 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_45 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_46 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_47 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_48 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_49 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_50 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_51 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_52 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_53 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_54 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_55 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_56 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_57 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_58 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_59 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_60 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_61 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_62 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_64 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_64 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_63 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_65 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_66 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_66 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_67 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_68 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_69 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_51 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_51 fd_set;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_57 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_57 XGCValues;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 21 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/xml.h"
struct xml_elem_t {
   struct xml_elem_t *next ;
   struct xml_elem_t *child ;
   char *tag ;
   int tag_id ;
   char *parm ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/xml.h"
typedef struct xml_elem_t xml_elem_t;
#line 77
enum __anonenum_tag_type_313 {
    ASXML_OpeningTag = 0,
    ASXML_SimpleTag = 1,
    ASXML_ClosingTag = 2
} ;
#line 77 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/xml.h"
struct ASXmlBuffer {
   char *buffer ;
   int allocated ;
   int used ;
   int current ;
   int state ;
   int level ;
   int verbatim ;
   int quoted ;
   enum __anonenum_tag_type_313 tag_type ;
   int tags_count ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/xml.h"
typedef struct ASXmlBuffer ASXmlBuffer;
#line 216 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
typedef struct ASImageManager ASImageManager;
#line 9 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../char2uni.h"
enum __anonenum_ASSupportedCharsets_318 {
    CHARSET_ISO8859_1 = 0,
    CHARSET_ISO8859_2 = 1,
    CHARSET_ISO8859_3 = 2,
    CHARSET_ISO8859_4 = 3,
    CHARSET_ISO8859_5 = 4,
    CHARSET_ISO8859_6 = 5,
    CHARSET_ISO8859_7 = 6,
    CHARSET_ISO8859_8 = 7,
    CHARSET_ISO8859_9 = 8,
    CHARSET_ISO8859_10 = 9,
    CHARSET_ISO8859_13 = 10,
    CHARSET_ISO8859_14 = 11,
    CHARSET_ISO8859_15 = 12,
    CHARSET_ISO8859_16 = 13,
    CHARSET_KOI8_R = 14,
    CHARSET_KOI8_RU = 15,
    CHARSET_KOI8_U = 16,
    CHARSET_CP1250 = 17,
    CHARSET_CP1251 = 18,
    CHARSET_CP1252 = 19,
    CHARSET_UTF8 = 20,
    SUPPORTED_CHARSETS_NUM = 21
} ;
#line 9 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../char2uni.h"
typedef enum __anonenum_ASSupportedCharsets_318 ASSupportedCharsets;
#line 224 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef struct ASFontManager ASFontManager;
#line 256 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
struct ASComposeWinProps {
   int center ;
   int geom_x ;
   int geom_y ;
   unsigned int geom_width ;
   unsigned int geom_height ;
   unsigned long geom_flags ;
   int override_redirect ;
   int timeout ;
   int click_timeout ;
   int on_top ;
   char const   *title ;
   int no_shape ;
   int mapped ;
   int dont_clear ;
   int last_x ;
   int last_y ;
   unsigned int last_width ;
   unsigned int last_height ;
   Pixmap last_root_pmap ;
   ASImage *last_root_im ;
   Pixmap canvas ;
   int canvas_width ;
   int canvas_height ;
};
#line 256 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
typedef struct ASComposeWinProps ASComposeWinProps;
#line 300
enum __anonenum_compose_type_333 {
    COMPOSE_Once = 0,
    COMPOSE_Interactive = 1,
    COMPOSE_XClipboard = 2
} ;
#line 825 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
union __anonunion_data_334 {
   unsigned char *uc_ptr ;
   long *long_ptr ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../imencdec.h"
typedef struct ASImageBevel ASImageBevel;
#line 249 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
enum ASText3DType {
    AST_Plain = 0,
    AST_Embossed = 1,
    AST_Sunken = 2,
    AST_ShadeAbove = 3,
    AST_ShadeBelow = 4,
    AST_EmbossedThick = 5,
    AST_SunkenThick = 6,
    AST_OutlineAbove = 7,
    AST_OutlineBelow = 8,
    AST_OutlineFull = 9,
    AST_3DTypes = 10
} ;
#line 249 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef enum ASText3DType ASText3DType;
#line 275 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
struct ASTextAttributes {
   unsigned int version ;
   ASFlagType rendition_flags ;
   ASText3DType type ;
   ASCharType char_type ;
   unsigned int tab_size ;
   unsigned int origin ;
   unsigned int *tab_stops ;
   unsigned int tab_stops_num ;
   ARGB32 fore_color ;
   unsigned int width ;
};
#line 275 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
typedef struct ASTextAttributes ASTextAttributes;
#line 113 "/usr/include/X11/Xmd.h"
typedef unsigned short CARD16;
#line 233 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
struct ASVectorPalette {
   unsigned int npoints ;
   double *points ;
   CARD16 *channels[4] ;
   ARGB32 default_color ;
};
#line 233 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
typedef struct ASVectorPalette ASVectorPalette;
#line 41 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../import.h"
enum __anonenum_ASImageFileTypes_297 {
    ASIT_Xpm = 0,
    ASIT_ZCompressedXpm = 1,
    ASIT_GZCompressedXpm = 2,
    ASIT_Png = 3,
    ASIT_Jpeg = 4,
    ASIT_Xcf = 5,
    ASIT_Ppm = 6,
    ASIT_Pnm = 7,
    ASIT_Bmp = 8,
    ASIT_Ico = 9,
    ASIT_Cur = 10,
    ASIT_Gif = 11,
    ASIT_Tiff = 12,
    ASIT_XMLScript = 13,
    ASIT_SVG = 14,
    ASIT_Xbm = 15,
    ASIT_Targa = 16,
    ASIT_Supported = 16,
    ASIT_Pcx = 17,
    ASIT_HTML = 18,
    ASIT_XML = 19,
    ASIT_Unknown = 20
} ;
#line 41 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../import.h"
typedef enum __anonenum_ASImageFileTypes_297 ASImageFileTypes;
#line 53 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
struct __anonstruct_ASXpmExportParams_298 {
   ASImageFileTypes type ;
   ASFlagType flags ;
   int dither ;
   int opaque_threshold ;
   int max_colors ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
typedef struct __anonstruct_ASXpmExportParams_298 ASXpmExportParams;
#line 67 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
struct __anonstruct_ASPngExportParams_299 {
   ASImageFileTypes type ;
   ASFlagType flags ;
   int compression ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
typedef struct __anonstruct_ASPngExportParams_299 ASPngExportParams;
#line 79 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
struct __anonstruct_ASJpegExportParams_300 {
   ASImageFileTypes type ;
   ASFlagType flags ;
   int quality ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
typedef struct __anonstruct_ASJpegExportParams_300 ASJpegExportParams;
#line 91 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
struct __anonstruct_ASGifExportParams_301 {
   ASImageFileTypes type ;
   ASFlagType flags ;
   int dither ;
   int opaque_threshold ;
   unsigned short animate_delay ;
   unsigned short animate_repeats ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
typedef struct __anonstruct_ASGifExportParams_301 ASGifExportParams;
#line 106 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
struct __anonstruct_ASTiffExportParams_302 {
   ASImageFileTypes type ;
   ASFlagType flags ;
   CARD32 rows_per_strip ;
   CARD32 compression_type ;
   int jpeg_quality ;
   int opaque_threshold ;
};
#line 106 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
typedef struct __anonstruct_ASTiffExportParams_302 ASTiffExportParams;
#line 135 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
union ASImageExportParams {
   ASImageFileTypes type ;
   ASXpmExportParams xpm ;
   ASPngExportParams png ;
   ASJpegExportParams jpeg ;
   ASGifExportParams gif ;
   ASTiffExportParams tiff ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
typedef union ASImageExportParams ASImageExportParams;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 381 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
struct ASGradient {
   int type ;
   int npoints ;
   ARGB32 *color ;
   double *offset ;
};
#line 381 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
typedef struct ASGradient ASGradient;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/fs.h"
extern int my_scandir(char * , struct direntry *** , int (*select)(char const   * ) ,
                      int (*dcomp)(struct direntry  const  **d1 , struct direntry  const  **d2 ) ) ;
#line 43
extern int no_dots_except_directory(char const   *d_name ) ;
#line 47
extern int check_file_mode(char const   *file , int mode ) ;
#line 61
extern char *make_file_name(char const   *path , char const   *file ) ;
#line 66
extern int is_executable_in_path(char const   *name ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/mystring.h"
extern int mystrcasecmp(char const   *s1 , char const   *s2 ) ;
#line 9
extern int mystrncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 13
extern char *mystrdup(char const   *str ) ;
#line 26
extern void set_string(char **target , char *string ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/parse.h"
extern char *find_doublequotes(char const   *ptr ) ;
#line 35
extern char *stripcpy(char const   *source ) ;
#line 91
extern char **compound_string2string_list(char *string , char separator , int duplicate ,
                                          int *nitems_return ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/safemalloc.h"
extern void *safemalloc(size_t length ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/../include/../libAfterBase/aslist.h"
extern ASBiDirList *create_asbidirlist(void (*destroy_func)(void *data ) ) ;
#line 40
extern void destroy_asbidirlist(ASBiDirList **pl ) ;
#line 42
extern void iterate_asbidirlist(ASBiDirList *l , int (*iter_func)(void *data , void *aux_data ) ,
                                void *aux_data , void *start_from , int reverse ) ;
#line 47
extern void *append_bidirelem(ASBiDirList *l , void *data ) ;
#line 277 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/asapp.h"
extern void InitMyApp(char const   *app_class , int agrc , char **argv , void (*version_func)(void) ,
                      void (*custom_usage_func)(void) , ASFlagType opt_mask ) ;
#line 283
extern struct ASDesktopCategory *name2desktop_category(char const   *name , struct ASCategoryTree **tree_return ) ;
#line 288
extern void FreeMyAppResources() ;
#line 290
extern void InitSession() ;
#line 295
extern ASProgArgs *MyArgsPtr ;
#line 355
extern struct ASSession *Session ;
#line 356
extern struct ASEnvironment *Environment ;
#line 359
extern struct ASCategoryTree *StandardCategories ;
#line 360
extern struct ASCategoryTree *AfterStepCategories ;
#line 361
extern struct ASCategoryTree *KDECategories ;
#line 362
extern struct ASCategoryTree *GNOMECategories ;
#line 363
extern struct ASCategoryTree *OtherCategories ;
#line 364
extern struct ASCategoryTree *CombinedCategories ;
#line 65 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/session.h"
extern char *make_session_apps_path(ASSession *session ) ;
#line 67
extern char *make_session_file(ASSession *session , char const   *source , int use_depth ) ;
#line 69
extern char *make_session_data_file(ASSession *session , int shared , int if_mode_only 
                                    , ...) ;
#line 183 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/../libAfterStep/desktop_category.h"
extern ASDesktopEntry *create_desktop_entry(ASDesktopEntryTypes default_type ) ;
#line 185
extern int unref_desktop_entry(ASDesktopEntry *de ) ;
#line 192
extern ASCategoryTree *create_category_tree(char const   *name , char const   *path ,
                                            char const   *icon_path , ASFlagType flags ,
                                            int max_depth ) ;
#line 193
extern void destroy_category_tree(ASCategoryTree **pct ) ;
#line 194
extern int register_desktop_entry(ASCategoryTree *ct , ASDesktopEntry *de ) ;
#line 195
extern void add_category_tree_subtree(ASCategoryTree *ct , ASCategoryTree *subtree ) ;
#line 197
extern void print_category_tree2(ASCategoryTree *ct , ASDesktopCategory *dc ) ;
#line 198
extern void save_category_tree(ASCategoryTree *ct , FILE *fp ) ;
#line 2680 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/afterconf.h"
int load_category_tree(struct ASCategoryTree *ct ) ;
#line 2682
void DestroyCategories(void) ;
#line 2683
void ReloadCategories(int cached ) ;
#line 2684
void UpdateCategoriesCache(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
char const   *default_aliases[5][2]  = { {        "ArcadeGame",        "Arcade"}, 
   {        "Application",        "Applications"}, 
   {        "Game",        "Games"}, 
   {        "Utility",        "Utilities"}, 
   {        (char const   *)((void *)0),        (char const   *)((void *)0)}};
#line 83 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static char *filter_desktop_entry_exec(char const   *exec ) 
{ 
  char *clean_exec ;
  char *tmp ;
  int start ;
  int ts ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *end ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  {
#line 85
  tmp = mystrdup(exec);
#line 85
  clean_exec = tmp;
#line 86
  start = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if ((int )*(clean_exec + start) != 0) {
      {
#line 88
      tmp___0 = __ctype_b_loc();
      }
#line 88
      if ((int const   )*(*tmp___0 + (int )*(clean_exec + start)) & 8192) {
#line 88
        goto while_break;
      }
    } else {
#line 88
      goto while_break;
    }
#line 89
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! ((int )*(clean_exec + start) != 0)) {
#line 90
      goto while_break___0;
    }
#line 91
    ts = start;
    {
#line 92
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 92
      tmp___1 = __ctype_b_loc();
      }
#line 92
      if (! ((int const   )*(*tmp___1 + (int )*(clean_exec + ts)) & 8192)) {
#line 92
        goto while_break___1;
      }
#line 93
      ts ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 94
    if ((int )*(clean_exec + ts) == 37) {
      {
#line 94
      tmp___9 = __ctype_b_loc();
      }
#line 94
      if ((int const   )*(*tmp___9 + (int )*(clean_exec + (ts + 1))) & 1024) {
        {
#line 95
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 95
          tmp___2 = __ctype_b_loc();
          }
#line 95
          if ((int const   )*(*tmp___2 + (int )*(clean_exec + ts)) & 8192) {
#line 95
            goto while_break___2;
          } else
#line 95
          if (! ((int )*(clean_exec + ts) != 0)) {
#line 95
            goto while_break___2;
          }
#line 96
          *(clean_exec + ts) = (char )' ';
#line 97
          ts ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 99
        start = ts;
      } else {
#line 94
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 100
      tmp___8 = mystrncasecmp((char const   *)(clean_exec + ts), "-caption ", (size_t )9);
      }
#line 100
      if (tmp___8 == 0) {
#line 101
        ts += 9;
        {
#line 102
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 102
          tmp___3 = __ctype_b_loc();
          }
#line 102
          if (! ((int const   )*(*tmp___3 + (int )*(clean_exec + ts)) & 8192)) {
#line 102
            goto while_break___3;
          }
#line 103
          ts ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 104
        tmp___5 = mystrncasecmp((char const   *)(clean_exec + ts), "\"%c\"", (size_t )4);
        }
#line 104
        if (tmp___5 == 0) {
#line 105
          ts += 3;
          {
#line 106
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 106
            if (! (start < ts)) {
#line 106
              goto while_break___4;
            }
#line 107
            start ++;
#line 107
            *(clean_exec + start) = (char )' ';
          }
          while_break___4: /* CIL Label */ ;
          }
        } else
#line 108
        if ((int )*(clean_exec + ts) == 37) {
          {
#line 108
          tmp___4 = __ctype_b_loc();
          }
#line 108
          if ((int const   )*(*tmp___4 + (int )*(clean_exec + (ts + 1))) & 1024) {
#line 109
            ts ++;
            {
#line 110
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 110
              if (! (start < ts)) {
#line 110
                goto while_break___5;
              }
#line 111
              start ++;
#line 111
              *(clean_exec + start) = (char )' ';
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      } else
#line 113
      if ((int )*(clean_exec + ts) == 34) {
        {
#line 114
        tmp___6 = find_doublequotes((char const   *)(clean_exec + ts));
#line 114
        end = tmp___6;
        }
#line 116
        if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 117
          start = (int )(end - (clean_exec + 0));
        } else {
#line 119
          start = ts;
        }
#line 120
        start ++;
      } else {
#line 122
        start = ts;
        {
#line 122
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 122
          tmp___7 = __ctype_b_loc();
          }
#line 122
          if ((int const   )*(*tmp___7 + (int )*(clean_exec + start)) & 8192) {
#line 122
            goto while_break___6;
          } else
#line 122
          if (! ((int )*(clean_exec + start) != 0)) {
#line 122
            goto while_break___6;
          }
#line 122
          start ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 126
    tmp___10 = __ctype_b_loc();
    }
#line 126
    if (! ((int const   )*(*tmp___10 + (int )*(clean_exec + (start - 1))) & 8192)) {
#line 126
      goto while_break___7;
    }
#line 127
    start --;
#line 128
    *(clean_exec + start) = (char )'\000';
  }
  while_break___7: /* CIL Label */ ;
  }
#line 130
  return (clean_exec);
}
}
#line 136
char *stripcpy_localized(char *ptr ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static char default_locale[3]  = {      (char )'u',      (char )'s',      (char )'\000'};
#line 133 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
char *stripcpy_localized(char *ptr ) 
{ 
  int i ;
  char *locale ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 135
  i = 0;
#line 137
  if (*(MyArgsPtr->locale + 0)) {
#line 137
    tmp = MyArgsPtr->locale;
  } else {
#line 137
    tmp = & default_locale[0];
  }
#line 137
  locale = tmp;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if ((int )*(locale + i) != 46) {
#line 139
      if ((int )*(locale + i) != 0) {
#line 139
        if (! ((int )*(ptr + i) != 93)) {
#line 139
          goto while_break;
        }
      } else {
#line 139
        goto while_break;
      }
    } else {
#line 139
      goto while_break;
    }
#line 140
    if ((int )*(ptr + i) != (int )*(locale + i)) {
#line 141
      goto while_break;
    }
#line 142
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if ((int )*(locale + i) == 46) {
#line 144
    goto _L;
  } else
#line 144
  if ((int )*(locale + i) == 95) {
#line 144
    goto _L;
  } else
#line 144
  if ((int )*(locale + i) == 0) {
    _L: /* CIL Label */ 
#line 144
    if ((int )*(ptr + i) == 93) {
      {
#line 146
      tmp___0 = stripcpy((char const   *)((ptr + i) + 2));
      }
#line 146
      return (tmp___0);
    }
  }
#line 147
  return ((char *)((void *)0));
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static void parse_desktop_entry_line(ASDesktopEntry *de , char *ptr ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *val ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *val___0 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;

  {
#line 156
  if ((int )*(ptr + 0) == 88) {
#line 156
    if ((int )*(ptr + 1) == 45) {
      {
#line 157
      ptr += 2;
#line 158
      tmp___11 = mystrncasecmp((char const   *)ptr, "AfterStep-", (size_t )10);
      }
#line 158
      if (tmp___11 == 0) {
        {
#line 159
        ptr += 10;
#line 160
        tmp = mystrncasecmp((char const   *)ptr, "IndexName=", (size_t )10);
        }
#line 160
        if (tmp == 0) {
#line 160
          if (de->IndexName) {
            {
#line 160
            free((void *)de->IndexName);
            }
          }
          {
#line 160
          de->IndexName = stripcpy((char const   *)((ptr + 9) + 1));
          }
#line 160
          return;
        }
        {
#line 161
        tmp___0 = mystrncasecmp((char const   *)ptr, "Aliases=", (size_t )8);
        }
#line 161
        if (tmp___0 == 0) {
#line 161
          if (de->Aliases) {
            {
#line 161
            free((void *)de->Aliases);
            }
          }
          {
#line 161
          de->Aliases = stripcpy((char const   *)((ptr + 7) + 1));
          }
#line 161
          return;
        }
        {
#line 162
        tmp___4 = mystrncasecmp((char const   *)ptr, "ASModule=", (size_t )9);
        }
#line 162
        if (tmp___4 == 0) {
          {
#line 162
          tmp___2 = stripcpy((char const   *)((ptr + 8) + 1));
#line 162
          tmp___1 = tmp___2;
          }
#line 162
          if ((int )*(tmp___1 + 0) == 49) {
#line 162
            de->flags |= (unsigned long )(1 << 7);
          } else {
            {
#line 162
            tmp___3 = mystrcasecmp((char const   *)tmp___1, "true");
            }
#line 162
            if (tmp___3 == 0) {
#line 162
              de->flags |= (unsigned long )(1 << 7);
            }
          }
          {
#line 162
          free((void *)tmp___1);
          }
#line 162
          return;
        }
        {
#line 163
        tmp___8 = mystrncasecmp((char const   *)ptr, "CheckAvailability=", (size_t )18);
        }
#line 163
        if (tmp___8 == 0) {
          {
#line 163
          tmp___6 = stripcpy((char const   *)((ptr + 17) + 1));
#line 163
          tmp___5 = tmp___6;
          }
#line 163
          if ((int )*(tmp___5 + 0) == 49) {
#line 163
            de->flags |= (unsigned long )(1 << 8);
          } else {
            {
#line 163
            tmp___7 = mystrcasecmp((char const   *)tmp___5, "true");
            }
#line 163
            if (tmp___7 == 0) {
#line 163
              de->flags |= (unsigned long )(1 << 8);
            }
          }
          {
#line 163
          free((void *)tmp___5);
          }
#line 163
          return;
        }
      } else {
        {
#line 164
        tmp___10 = mystrncasecmp((char const   *)ptr, "KDE-", (size_t )4);
        }
#line 164
        if (tmp___10 == 0) {
#line 165
          de->flags |= (unsigned long )(1 << 5);
        } else {
          {
#line 166
          tmp___9 = mystrncasecmp((char const   *)ptr, "GNOME-", (size_t )6);
          }
#line 166
          if (tmp___9 == 0) {
#line 167
            de->flags |= (unsigned long )(1 << 6);
          }
        }
      }
    } else {
#line 156
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 168
    tmp___52 = mystrncasecmp((char const   *)ptr, "Name[", (size_t )5);
    }
#line 168
    if (tmp___52 == 0) {
#line 168
      if ((int )*(MyArgsPtr->locale + 0) == (int )*(ptr + 5)) {
        {
#line 170
        tmp___12 = stripcpy_localized(ptr + 5);
#line 170
        val = tmp___12;
        }
#line 172
        if (val) {
          {
#line 173
          set_string(& de->Name_localized, val);
          }
        }
      } else {
#line 168
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 174
      tmp___51 = mystrncasecmp((char const   *)ptr, "Type=", (size_t )5);
      }
#line 174
      if (tmp___51 == 0) {
        {
#line 175
        ptr += 5;
#line 177
        tmp___13 = mystrncasecmp((char const   *)ptr, "Application", (size_t )11);
        }
#line 177
        if (tmp___13 == 0) {
#line 177
          de->type = (ASDesktopEntryTypes )0;
#line 177
          return;
        }
        {
#line 178
        tmp___14 = mystrncasecmp((char const   *)ptr, "Link", (size_t )4);
        }
#line 178
        if (tmp___14 == 0) {
#line 178
          de->type = (ASDesktopEntryTypes )1;
#line 178
          return;
        }
        {
#line 179
        tmp___15 = mystrncasecmp((char const   *)ptr, "FSDevice", (size_t )8);
        }
#line 179
        if (tmp___15 == 0) {
#line 179
          de->type = (ASDesktopEntryTypes )2;
#line 179
          return;
        }
        {
#line 180
        tmp___16 = mystrncasecmp((char const   *)ptr, "Directory", (size_t )9);
        }
#line 180
        if (tmp___16 == 0) {
#line 180
          de->type = (ASDesktopEntryTypes )3;
#line 180
          return;
        }
      } else {
        {
#line 181
        tmp___50 = mystrncasecmp((char const   *)ptr, "Comment[", (size_t )8);
        }
#line 181
        if (tmp___50 == 0) {
#line 181
          if ((int )*(MyArgsPtr->locale + 0) == (int )*(ptr + 8)) {
            {
#line 183
            tmp___17 = stripcpy_localized(ptr + 8);
#line 183
            val___0 = tmp___17;
            }
#line 185
            if (val___0) {
              {
#line 186
              set_string(& de->Comment_localized, val___0);
              }
            }
          } else {
#line 181
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 187
          tmp___48 = mystrncasecmp((char const   *)ptr, "Encoding=", (size_t )9);
          }
#line 187
          if (tmp___48 == 0) {
            {
#line 187
            tmp___49 = mystrncasecmp((char const   *)(ptr + 9), "UTF-8", (size_t )5);
            }
#line 187
            if (tmp___49 != 0) {
#line 189
              de->flags |= (unsigned long )(1 << 4);
            } else {
#line 187
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 191
            tmp___18 = mystrncasecmp((char const   *)ptr, "Name=", (size_t )5);
            }
#line 191
            if (tmp___18 == 0) {
#line 191
              if (de->Name) {
                {
#line 191
                free((void *)de->Name);
                }
              }
              {
#line 191
              de->Name = stripcpy((char const   *)((ptr + 4) + 1));
              }
#line 191
              return;
            }
            {
#line 192
            tmp___19 = mystrncasecmp((char const   *)ptr, "GenericName=", (size_t )12);
            }
#line 192
            if (tmp___19 == 0) {
#line 192
              if (de->GenericName) {
                {
#line 192
                free((void *)de->GenericName);
                }
              }
              {
#line 192
              de->GenericName = stripcpy((char const   *)((ptr + 11) + 1));
              }
#line 192
              return;
            }
            {
#line 193
            tmp___20 = mystrncasecmp((char const   *)ptr, "Comment=", (size_t )8);
            }
#line 193
            if (tmp___20 == 0) {
#line 193
              if (de->Comment) {
                {
#line 193
                free((void *)de->Comment);
                }
              }
              {
#line 193
              de->Comment = stripcpy((char const   *)((ptr + 7) + 1));
              }
#line 193
              return;
            }
            {
#line 194
            tmp___21 = mystrncasecmp((char const   *)ptr, "Icon=", (size_t )5);
            }
#line 194
            if (tmp___21 == 0) {
#line 194
              if (de->Icon) {
                {
#line 194
                free((void *)de->Icon);
                }
              }
              {
#line 194
              de->Icon = stripcpy((char const   *)((ptr + 4) + 1));
              }
#line 194
              return;
            }
            {
#line 195
            tmp___22 = mystrncasecmp((char const   *)ptr, "TryExec=", (size_t )8);
            }
#line 195
            if (tmp___22 == 0) {
#line 195
              if (de->TryExec) {
                {
#line 195
                free((void *)de->TryExec);
                }
              }
              {
#line 195
              de->TryExec = stripcpy((char const   *)((ptr + 7) + 1));
              }
#line 195
              return;
            }
            {
#line 196
            tmp___23 = mystrncasecmp((char const   *)ptr, "Exec=", (size_t )5);
            }
#line 196
            if (tmp___23 == 0) {
#line 196
              if (de->Exec) {
                {
#line 196
                free((void *)de->Exec);
                }
              }
              {
#line 196
              de->Exec = stripcpy((char const   *)((ptr + 4) + 1));
              }
#line 196
              return;
            }
            {
#line 197
            tmp___24 = mystrncasecmp((char const   *)ptr, "Path=", (size_t )5);
            }
#line 197
            if (tmp___24 == 0) {
#line 197
              if (de->Path) {
                {
#line 197
                free((void *)de->Path);
                }
              }
              {
#line 197
              de->Path = stripcpy((char const   *)((ptr + 4) + 1));
              }
#line 197
              return;
            }
            {
#line 198
            tmp___25 = mystrncasecmp((char const   *)ptr, "SwallowTitle=", (size_t )13);
            }
#line 198
            if (tmp___25 == 0) {
#line 198
              if (de->SwallowTitle) {
                {
#line 198
                free((void *)de->SwallowTitle);
                }
              }
              {
#line 198
              de->SwallowTitle = stripcpy((char const   *)((ptr + 12) + 1));
              }
#line 198
              return;
            }
            {
#line 199
            tmp___26 = mystrncasecmp((char const   *)ptr, "SwallowExec=", (size_t )12);
            }
#line 199
            if (tmp___26 == 0) {
#line 199
              if (de->SwallowExec) {
                {
#line 199
                free((void *)de->SwallowExec);
                }
              }
              {
#line 199
              de->SwallowExec = stripcpy((char const   *)((ptr + 11) + 1));
              }
#line 199
              return;
            }
            {
#line 200
            tmp___27 = mystrncasecmp((char const   *)ptr, "SortOrder=", (size_t )10);
            }
#line 200
            if (tmp___27 == 0) {
#line 200
              if (de->SortOrder) {
                {
#line 200
                free((void *)de->SortOrder);
                }
              }
              {
#line 200
              de->SortOrder = stripcpy((char const   *)((ptr + 9) + 1));
              }
#line 200
              return;
            }
            {
#line 201
            tmp___28 = mystrncasecmp((char const   *)ptr, "Categories=", (size_t )11);
            }
#line 201
            if (tmp___28 == 0) {
#line 201
              if (de->Categories) {
                {
#line 201
                free((void *)de->Categories);
                }
              }
              {
#line 201
              de->Categories = stripcpy((char const   *)((ptr + 10) + 1));
              }
#line 201
              return;
            }
            {
#line 202
            tmp___29 = mystrncasecmp((char const   *)ptr, "OnlyShowIn=", (size_t )11);
            }
#line 202
            if (tmp___29 == 0) {
#line 202
              if (de->OnlyShowIn) {
                {
#line 202
                free((void *)de->OnlyShowIn);
                }
              }
              {
#line 202
              de->OnlyShowIn = stripcpy((char const   *)((ptr + 10) + 1));
              }
#line 202
              return;
            }
            {
#line 203
            tmp___30 = mystrncasecmp((char const   *)ptr, "NotShowIn=", (size_t )10);
            }
#line 203
            if (tmp___30 == 0) {
#line 203
              if (de->NotShowIn) {
                {
#line 203
                free((void *)de->NotShowIn);
                }
              }
              {
#line 203
              de->NotShowIn = stripcpy((char const   *)((ptr + 9) + 1));
              }
#line 203
              return;
            }
            {
#line 204
            tmp___31 = mystrncasecmp((char const   *)ptr, "StartupWMClass=", (size_t )15);
            }
#line 204
            if (tmp___31 == 0) {
#line 204
              if (de->StartupWMClass) {
                {
#line 204
                free((void *)de->StartupWMClass);
                }
              }
              {
#line 204
              de->StartupWMClass = stripcpy((char const   *)((ptr + 14) + 1));
              }
#line 204
              return;
            }
            {
#line 205
            tmp___35 = mystrncasecmp((char const   *)ptr, "NoDisplay=", (size_t )10);
            }
#line 205
            if (tmp___35 == 0) {
              {
#line 205
              tmp___33 = stripcpy((char const   *)((ptr + 9) + 1));
#line 205
              tmp___32 = tmp___33;
              }
#line 205
              if ((int )*(tmp___32 + 0) == 49) {
#line 205
                de->flags |= 1UL;
              } else {
                {
#line 205
                tmp___34 = mystrcasecmp((char const   *)tmp___32, "true");
                }
#line 205
                if (tmp___34 == 0) {
#line 205
                  de->flags |= 1UL;
                }
              }
              {
#line 205
              free((void *)tmp___32);
              }
#line 205
              return;
            }
            {
#line 206
            tmp___39 = mystrncasecmp((char const   *)ptr, "Hidden=", (size_t )7);
            }
#line 206
            if (tmp___39 == 0) {
              {
#line 206
              tmp___37 = stripcpy((char const   *)((ptr + 6) + 1));
#line 206
              tmp___36 = tmp___37;
              }
#line 206
              if ((int )*(tmp___36 + 0) == 49) {
#line 206
                de->flags |= (unsigned long )(1 << 1);
              } else {
                {
#line 206
                tmp___38 = mystrcasecmp((char const   *)tmp___36, "true");
                }
#line 206
                if (tmp___38 == 0) {
#line 206
                  de->flags |= (unsigned long )(1 << 1);
                }
              }
              {
#line 206
              free((void *)tmp___36);
              }
#line 206
              return;
            }
            {
#line 206
            tmp___43 = mystrncasecmp((char const   *)ptr, "Terminal=", (size_t )9);
            }
#line 206
            if (tmp___43 == 0) {
              {
#line 206
              tmp___41 = stripcpy((char const   *)((ptr + 8) + 1));
#line 206
              tmp___40 = tmp___41;
              }
#line 206
              if ((int )*(tmp___40 + 0) == 49) {
#line 206
                de->flags |= (unsigned long )(1 << 2);
              } else {
                {
#line 206
                tmp___42 = mystrcasecmp((char const   *)tmp___40, "true");
                }
#line 206
                if (tmp___42 == 0) {
#line 206
                  de->flags |= (unsigned long )(1 << 2);
                }
              }
              {
#line 206
              free((void *)tmp___40);
              }
#line 206
              return;
            }
            {
#line 207
            tmp___47 = mystrncasecmp((char const   *)ptr, "StartupNotify=", (size_t )14);
            }
#line 207
            if (tmp___47 == 0) {
              {
#line 207
              tmp___45 = stripcpy((char const   *)((ptr + 13) + 1));
#line 207
              tmp___44 = tmp___45;
              }
#line 207
              if ((int )*(tmp___44 + 0) == 49) {
#line 207
                de->flags |= (unsigned long )(1 << 3);
              } else {
                {
#line 207
                tmp___46 = mystrcasecmp((char const   *)tmp___44, "true");
                }
#line 207
                if (tmp___46 == 0) {
#line 207
                  de->flags |= (unsigned long )(1 << 3);
                }
              }
              {
#line 207
              free((void *)tmp___44);
              }
#line 207
              return;
            }
          }
        }
      }
    }
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static void fix_desktop_entry(ASDesktopEntry *de , char const   *default_category ,
                              char const   *icon_path , char const   *origin , int applnk ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int i ;
  ASFlagType kind ;
  char *ptr ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 214
  if ((unsigned long )de->Categories == (unsigned long )((void *)0)) {
#line 214
    if (default_category) {
#line 215
      if ((de->flags & (unsigned long )((1 << 5) | (1 << 6))) == 0UL) {
        {
#line 216
        tmp___0 = mystrncasecmp(default_category, "KDE", (size_t )3);
        }
#line 216
        if (tmp___0 == 0) {
#line 217
          de->flags |= (unsigned long )(1 << 5);
        } else {
          {
#line 218
          tmp = mystrncasecmp(default_category, "GNOME", (size_t )5);
          }
#line 218
          if (tmp == 0) {
#line 219
            de->flags |= (unsigned long )(1 << 6);
          }
        }
      }
#line 221
      if ((unsigned int )de->type != 3U) {
        {
#line 222
        de->Categories = mystrdup(default_category);
        }
      }
    }
  }
#line 224
  if (applnk) {
#line 225
    de->flags |= (unsigned long )(1 << 5);
  }
#line 227
  if ((unsigned long )de->Categories != (unsigned long )((void *)0)) {
    {
#line 228
    tmp___1 = strlen((char const   *)de->Categories);
#line 228
    de->categories_len = (int )tmp___1;
#line 229
    de->categories_shortcuts = compound_string2string_list(de->Categories, (char )';',
                                                           0, & de->categories_num);
    }
#line 232
    if ((de->flags & (unsigned long )((1 << 5) | (1 << 6))) == 0UL) {
#line 233
      i = de->categories_num;
#line 234
      kind = (ASFlagType )0;
      {
#line 236
      while (1) {
        while_continue: /* CIL Label */ ;
#line 236
        i --;
#line 236
        if (i >= 0) {
#line 236
          if (! (kind == 0UL)) {
#line 236
            goto while_break;
          }
        } else {
#line 236
          goto while_break;
        }
#line 237
        ptr = *(de->categories_shortcuts + i);
#line 239
        if ((int )*(ptr + 0) == 88) {
#line 240
          if ((int )*(ptr + 1) != 45) {
#line 241
            goto while_continue;
          }
#line 242
          ptr += 2;
        }
        {
#line 244
        tmp___3 = mystrncasecmp((char const   *)ptr, "KDE", (size_t )3);
        }
#line 244
        if (tmp___3 == 0) {
#line 245
          kind |= (unsigned long )(1 << 5);
        } else {
          {
#line 246
          tmp___2 = mystrncasecmp((char const   *)ptr, "GNOME", (size_t )5);
          }
#line 246
          if (tmp___2 == 0) {
#line 247
            kind |= (unsigned long )(1 << 6);
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 249
      de->flags |= kind;
    }
  }
#line 252
  if ((de->flags & (unsigned long )((1 << 5) | (1 << 6))) == 0UL) {
#line 252
    if (de->Name) {
#line 253
      if ((int )*(de->Name + 0) == 71) {
#line 254
        de->flags |= (unsigned long )(1 << 6);
      } else
#line 255
      if ((int )*(de->Name + 0) == 75) {
#line 256
        de->flags |= (unsigned long )(1 << 5);
      }
    }
  }
#line 258
  if ((unsigned long )de->Aliases != (unsigned long )((void *)0)) {
    {
#line 259
    tmp___4 = strlen((char const   *)de->Aliases);
#line 259
    de->aliases_len = (int )tmp___4;
#line 260
    de->aliases_shortcuts = compound_string2string_list(de->Aliases, (char )';', 0,
                                                        & de->aliases_num);
    }
  }
#line 265
  if ((unsigned long )de->OnlyShowIn != (unsigned long )((void *)0)) {
    {
#line 266
    tmp___5 = strlen((char const   *)de->OnlyShowIn);
#line 266
    de->show_in_len = (int )tmp___5;
#line 267
    de->show_in_shortcuts = compound_string2string_list(de->OnlyShowIn, (char )';',
                                                        0, & de->show_in_num);
    }
  }
#line 271
  if ((unsigned long )de->NotShowIn != (unsigned long )((void *)0)) {
    {
#line 272
    tmp___6 = strlen((char const   *)de->NotShowIn);
#line 272
    de->not_show_in_len = (int )tmp___6;
#line 273
    de->not_show_in_shortcuts = compound_string2string_list(de->NotShowIn, (char )';',
                                                            0, & de->not_show_in_num);
    }
  }
#line 277
  if (de->Exec) {
    {
#line 278
    de->clean_exec = filter_desktop_entry_exec((char const   *)de->Exec);
    }
  }
  {
#line 280
  de->origin = mystrdup(origin);
  }
#line 282
  if (de->flags & (unsigned long )(1 << 8)) {
    {
#line 283
    tmp___7 = is_executable_in_path((char const   *)de->clean_exec);
    }
#line 283
    if (! tmp___7) {
#line 284
      de->flags |= (unsigned long )(1 << 9);
    }
  } else
#line 289
  if ((unsigned long )de->TryExec != (unsigned long )((void *)0)) {
    {
#line 290
    tmp___8 = is_executable_in_path((char const   *)de->TryExec);
    }
#line 290
    if (! tmp___8) {
#line 291
      de->flags |= (unsigned long )(1 << 9);
    }
  }
#line 298
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static char rb[1025]  ;
#line 300 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static ASDesktopEntry *parse_desktop_entry(char const   *fullfilename , char const   *default_category ,
                                           ASDesktopEntryTypes default_type , char const   *icon_path ,
                                           int applnk ) 
{ 
  ASDesktopEntry *de ;
  FILE *fp ;
  char *tmp ;

  {
#line 307
  de = (ASDesktopEntry *)((void *)0);
#line 308
  fp = (FILE *)((void *)0);
#line 310
  if (fullfilename) {
    {
#line 311
    fp = fopen((char const   */* __restrict  */)fullfilename, (char const   */* __restrict  */)"r");
    }
  }
#line 313
  if (fp) {
    {
#line 316
    de = create_desktop_entry(default_type);
    }
    {
#line 317
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 317
      tmp = fgets((char */* __restrict  */)(& rb[0]), 1024, (FILE */* __restrict  */)fp);
      }
#line 317
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 317
        goto while_break;
      }
      {
#line 318
      parse_desktop_entry_line(de, & rb[0]);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 319
    fix_desktop_entry(de, default_category, icon_path, fullfilename, applnk);
#line 321
    fclose(fp);
    }
  }
#line 323
  return (de);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static char rb___0[1025]  ;
#line 326 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
int parse_desktop_entry_list(char const   *fullfilename , ASBiDirList *entry_list ,
                             char const   *default_category , ASDesktopEntryTypes default_type ,
                             char const   *icon_path , int applnk ) 
{ 
  ASDesktopEntry *de ;
  int count ;
  FILE *fp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 333
  de = (ASDesktopEntry *)((void *)0);
#line 334
  count = 0;
#line 335
  fp = (FILE *)((void *)0);
#line 338
  if (fullfilename) {
    {
#line 339
    fp = fopen((char const   */* __restrict  */)fullfilename, (char const   */* __restrict  */)"r");
    }
  }
#line 341
  if (fp) {
    {
#line 344
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 344
      tmp___2 = fgets((char */* __restrict  */)(& rb___0[0]), 1024, (FILE */* __restrict  */)fp);
      }
#line 344
      if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 344
        goto while_break;
      }
#line 346
      if ((int )rb___0[0] == 91) {
#line 347
        if ((int )rb___0[1] == 68) {
          {
#line 347
          tmp = mystrncasecmp((char const   *)(& rb___0[2]), "esktop Entry]", (size_t )13);
          }
#line 347
          if (tmp == 0) {
#line 347
            goto _L;
          } else {
            {
#line 347
            tmp___0 = mystrncasecmp((char const   *)(& rb___0[2]), "esktopEntry]",
                                    (size_t )12);
            }
#line 347
            if (tmp___0 == 0) {
#line 347
              goto _L;
            } else {
#line 347
              goto _L___1;
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 347
        if ((int )rb___0[1] == 75) {
          {
#line 347
          tmp___1 = mystrncasecmp((char const   *)(& rb___0[2]), "DE Desktop Entry]",
                                  (size_t )17);
          }
#line 347
          if (tmp___1 == 0) {
            _L: /* CIL Label */ 
#line 353
            if (de) {
              {
#line 354
              fix_desktop_entry(de, default_category, icon_path, fullfilename, applnk);
#line 356
              append_bidirelem(entry_list, (void *)de);
              }
            }
            {
#line 358
            de = create_desktop_entry(default_type);
#line 359
            count ++;
            }
          } else {
#line 347
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 360
        if (de) {
          {
#line 361
          fix_desktop_entry(de, default_category, icon_path, fullfilename, applnk);
#line 363
          append_bidirelem(entry_list, (void *)de);
#line 364
          de = (ASDesktopEntry *)((void *)0);
          }
        }
      } else
#line 366
      if (de) {
        {
#line 367
        parse_desktop_entry_line(de, & rb___0[0]);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 369
    if (de) {
      {
#line 370
      fix_desktop_entry(de, default_category, icon_path, fullfilename, applnk);
#line 372
      append_bidirelem(entry_list, (void *)de);
      }
    }
    {
#line 374
    fclose(fp);
    }
  }
#line 376
  return (count);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static void parse_desktop_entry_tree(char *fullpath , char const   *dirname , ASBiDirList *entry_list ,
                                     ASDesktopEntry *parent , char const   *icon_path ,
                                     char const   *default_app_category , int applnk ) 
{ 
  struct direntry **list ;
  int list_len ;
  int i ;
  int curr_dir_index ;
  char *dir_category ;
  ASDesktopEntry *tmp ;
  ASDesktopEntry *curr_dir ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *entry_fullpath ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 387
  list = (struct direntry **)((void *)0);
#line 388
  curr_dir_index = -1;
#line 389
  dir_category = (char *)((void *)0);
#line 390
  curr_dir = (ASDesktopEntry *)((void *)0);
#line 393
  list_len = my_scandir(fullpath, & list, & no_dots_except_directory, (int (*)(struct direntry  const  **d1 ,
                                                                               struct direntry  const  **d2 ))((void *)0));
#line 395
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"number of items in %s = %d\n",
          fullpath, list_len);
#line 396
  i = 0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (i < list_len)) {
#line 396
      goto while_break;
    }
#line 397
    if (! (((*(list + i))->d_mode & 61440U) == 16384U)) {
#line 397
      if ((int )(*(list + i))->d_name[0] == 46) {
        {
#line 398
        tmp___2 = strcasecmp((char const   *)((*(list + i))->d_name), ".directory");
        }
#line 398
        if (tmp___2 == 0) {
#line 399
          curr_dir_index = i;
#line 400
          if (parent) {
#line 400
            tmp___0 = parent->Name;
          } else {
#line 400
            tmp___0 = (char *)((void *)0);
          }
          {
#line 400
          tmp = parse_desktop_entry((char const   *)fullpath, (char const   *)tmp___0,
                                    (ASDesktopEntryTypes )3, icon_path, applnk);
          }
#line 403
          if (tmp) {
#line 404
            if ((unsigned long )tmp->Name == (unsigned long )((void *)0)) {
              {
#line 405
              tmp->Name = mystrdup(dirname);
              }
            }
            {
#line 406
            tmp___1 = mystrcasecmp((char const   *)tmp->Name, "Default");
            }
#line 406
            if (tmp___1 != 0) {
              {
#line 407
              dir_category = mystrdup((char const   *)tmp->Name);
              }
            }
            {
#line 408
            curr_dir = tmp;
#line 409
            append_bidirelem(entry_list, (void *)tmp);
            }
          }
#line 411
          goto while_break;
        }
      }
    }
#line 396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if ((unsigned long )curr_dir == (unsigned long )((void *)0)) {
#line 416
    if (parent) {
#line 416
      tmp___3 = parent->Name;
    } else {
#line 416
      tmp___3 = (char *)((void *)0);
    }
    {
#line 416
    curr_dir = parse_desktop_entry((char const   *)fullpath, (char const   *)tmp___3,
                                   (ASDesktopEntryTypes )3, icon_path, applnk);
    }
#line 419
    if (curr_dir) {
#line 420
      if ((unsigned long )curr_dir->Name == (unsigned long )((void *)0)) {
        {
#line 421
        curr_dir->Name = mystrdup(dirname);
#line 422
        append_bidirelem(entry_list, (void *)curr_dir);
        }
      }
    }
  }
#line 426
  i = 0;
  {
#line 426
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 426
    if (! (i < list_len)) {
#line 426
      goto while_break___0;
    }
#line 427
    if ((int )(*(list + i))->d_name[0] != 46) {
      {
#line 428
      tmp___4 = make_file_name((char const   *)fullpath, (char const   *)((*(list + i))->d_name));
#line 428
      entry_fullpath = tmp___4;
      }
#line 430
      if (((*(list + i))->d_mode & 61440U) == 16384U) {
        {
#line 432
        parse_desktop_entry_tree(entry_fullpath, (char const   *)((*(list + i))->d_name),
                                 entry_list, curr_dir, icon_path, default_app_category,
                                 applnk);
        }
      } else
#line 435
      if (i != curr_dir_index) {
#line 437
        if (dir_category) {
#line 437
          tmp___5 = (char const   *)dir_category;
        } else {
#line 437
          tmp___5 = default_app_category;
        }
        {
#line 437
        parse_desktop_entry_list((char const   *)entry_fullpath, entry_list, tmp___5,
                                 (ASDesktopEntryTypes )0, icon_path, applnk);
        }
      }
      {
#line 442
      free((void *)entry_fullpath);
      }
    }
    {
#line 444
    free((void *)*(list + i));
#line 426
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 447
  if (list) {
    {
#line 448
    free((void *)list);
    }
  }
#line 450
  if (dir_category) {
    {
#line 451
    free((void *)dir_category);
    }
  }
#line 452
  return;
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static void desktop_entry_destroy_list_item(void *data ) 
{ 


  {
  {
#line 456
  unref_desktop_entry((ASDesktopEntry *)data);
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
static int register_desktop_entry_list_item(void *data , void *aux_data ) 
{ 


  {
  {
#line 461
  register_desktop_entry((ASCategoryTree *)aux_data, (ASDesktopEntry *)data);
  }
#line 463
  return (1);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
int load_category_tree(struct ASCategoryTree *ct ) 
{ 
  int i ;
  ASBiDirList *entry_list ;
  ASBiDirList *tmp ;
  int applnk ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 472
  if (ct) {
#line 472
    if (ct->dir_list) {
      {
#line 474
      tmp = create_asbidirlist(& desktop_entry_destroy_list_item);
#line 474
      entry_list = tmp;
#line 477
      i = 0;
      }
      {
#line 477
      while (1) {
        while_continue: /* CIL Label */ ;
#line 477
        if (! (i < ct->dir_num)) {
#line 477
          goto while_break;
        }
        {
#line 478
        tmp___0 = strstr((char const   *)*(ct->dir_list + i), "/applnk");
#line 478
        applnk = (unsigned long )tmp___0 != (unsigned long )((void *)0);
#line 480
        tmp___2 = check_file_mode((char const   *)*(ct->dir_list + i), 16384);
        }
#line 480
        if (tmp___2 == 0) {
          {
#line 483
          parse_desktop_entry_tree(*(ct->dir_list + i), (char const   *)((void *)0),
                                   entry_list, (ASDesktopEntry *)((void *)0), (char const   *)ct->icon_path,
                                   (char const   *)ct->name, applnk);
          }
        } else {
          {
#line 485
          tmp___1 = check_file_mode((char const   *)*(ct->dir_list + i), 32768);
          }
#line 485
          if (tmp___1 == 0) {
            {
#line 486
            parse_desktop_entry_list((char const   *)*(ct->dir_list + i), entry_list,
                                     (char const   *)ct->name, (ASDesktopEntryTypes )3,
                                     (char const   *)ct->icon_path, applnk);
            }
          }
        }
#line 477
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 491
      iterate_asbidirlist(entry_list, & register_desktop_entry_list_item, (void *)ct,
                          (void *)0, 0);
#line 493
      destroy_asbidirlist(& entry_list);
      }
#line 496
      return (1);
    }
  }
#line 498
  return (0);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
void DestroyCategories(void) 
{ 


  {
#line 503
  if (StandardCategories) {
    {
#line 504
    destroy_category_tree(& StandardCategories);
    }
  }
#line 505
  if (AfterStepCategories) {
    {
#line 506
    destroy_category_tree(& AfterStepCategories);
    }
  }
#line 507
  if (KDECategories) {
    {
#line 508
    destroy_category_tree(& KDECategories);
    }
  }
#line 509
  if (GNOMECategories) {
    {
#line 510
    destroy_category_tree(& GNOMECategories);
    }
  }
#line 511
  if (OtherCategories) {
    {
#line 512
    destroy_category_tree(& OtherCategories);
    }
  }
#line 513
  if (CombinedCategories) {
    {
#line 514
    destroy_category_tree(& CombinedCategories);
    }
  }
#line 518
  return;
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
void save_category_tree_cache(ASCategoryTree *ct , char const   *fname ) 
{ 
  char *configfile ;
  FILE *fp ;

  {
  {
#line 525
  configfile = make_session_data_file(Session, 0, 0, fname, (void *)0);
  }
#line 526
  if (configfile) {
    {
#line 527
    fp = fopen((char const   */* __restrict  */)configfile, (char const   */* __restrict  */)"wb");
    }
#line 528
    if (fp) {
      {
#line 529
      save_category_tree(ct, fp);
#line 530
      fclose(fp);
      }
    }
    {
#line 532
    free((void *)configfile);
    }
  }
#line 534
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
void UpdateCategoriesCache(void) 
{ 


  {
  {
#line 538
  save_category_tree_cache(AfterStepCategories, "non-configurable/AfterStepCategories");
#line 539
  save_category_tree_cache(KDECategories, "non-configurable/KDECategories");
#line 540
  save_category_tree_cache(GNOMECategories, "non-configurable/GNOMECategories");
#line 541
  save_category_tree_cache(OtherCategories, "non-configurable/OtherCategories");
  }
#line 542
  return;
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
void ReloadCategories(int cached ) 
{ 
  char *configfile ;
  char *tmp ;
  char *configfile___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *path ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  DestroyCategories();
#line 552
  configfile = make_session_file(Session, "standard_categories", 0);
  }
#line 552
  if ((unsigned long )configfile != (unsigned long )((void *)0)) {
#line 555
    if (Environment) {
#line 555
      tmp = Environment->pixmap_path;
    } else {
#line 555
      tmp = (char *)((void *)0);
    }
    {
#line 555
    StandardCategories = create_category_tree("Default", (char const   *)configfile,
                                              (char const   *)tmp, (ASFlagType )0,
                                              -1);
#line 559
    free((void *)configfile);
    }
  }
#line 562
  if (cached) {
    {
#line 563
    tmp___0 = make_session_data_file(Session, 0, 0, "non-configurable/AfterStepCategories",
                                     (void *)0);
#line 563
    configfile___0 = tmp___0;
    }
#line 567
    if (Environment) {
#line 567
      tmp___1 = Environment->pixmap_path;
    } else {
#line 567
      tmp___1 = (char *)((void *)0);
    }
    {
#line 567
    AfterStepCategories = create_category_tree("AfterStep", (char const   *)configfile___0,
                                               (char const   *)tmp___1, (ASFlagType )0,
                                               -1);
#line 571
    free((void *)configfile___0);
#line 572
    configfile___0 = make_session_data_file(Session, 0, 0, "non-configurable/KDECategories",
                                            (void *)0);
#line 574
    KDECategories = create_category_tree("KDE", (char const   *)configfile___0, "~/.icons/kde/48x48/apps/:$XDG_DATA_DIRS/icons/kde/48x48/apps/:$KDEDIR/share/icons/default.kde/48x48/apps:$KDEDIR/share/icons/hicolor/48x48/apps:$KDEDIR/share/icons/locolor/48x48/apps:/usr/share/pixmaps",
                                         (ASFlagType )0, -1);
#line 576
    free((void *)configfile___0);
#line 577
    configfile___0 = make_session_data_file(Session, 0, 0, "non-configurable/GNOMECategories",
                                            (void *)0);
#line 579
    GNOMECategories = create_category_tree("GNOME", (char const   *)configfile___0,
                                           "~/.icons/gnome/48x48/apps/:$XDG_DATA_DIRS/icons/gnome/48x48/apps/:$GNOMEDIR/share/pixmaps:/usr/share/pixmaps:/usr/share/icons:/usr/share/icons/hicolor/48x48/apps:/usr/share/icons/hicolor/32x32/apps:/usr/share/icons/gnome/48x48/apps",
                                           (ASFlagType )0, -1);
#line 582
    free((void *)configfile___0);
#line 583
    configfile___0 = make_session_data_file(Session, 0, 0, "non-configurable/OtherCategories",
                                            (void *)0);
#line 585
    OtherCategories = create_category_tree("OTHER", (char const   *)configfile___0,
                                           "/usr/share/pixmaps:/usr/local/share/pixmaps:/usr/share/icons:/usr/share/icons/hicolor/48x48/apps:/usr/share/icons/hicolor/32x32/apps",
                                           (ASFlagType )0, -1);
#line 588
    free((void *)configfile___0);
    }
  } else {
    {
#line 590
    tmp___2 = make_session_apps_path(Session);
#line 590
    path = tmp___2;
    }
#line 592
    if (path) {
#line 593
      if (Environment) {
#line 593
        tmp___3 = Environment->pixmap_path;
      } else {
#line 593
        tmp___3 = (char *)((void *)0);
      }
      {
#line 593
      AfterStepCategories = create_category_tree("AfterStep", (char const   *)path,
                                                 (char const   *)tmp___3, (ASFlagType )0,
                                                 -1);
#line 597
      free((void *)path);
      }
    }
    {
#line 600
    KDECategories = create_category_tree("KDE", "$KDEDIR/share/applnk:$KDEDIR/share/applications:/usr/share/applnk:/usr/share/applications",
                                         "~/.icons/kde/48x48/apps/:$XDG_DATA_DIRS/icons/kde/48x48/apps/:$KDEDIR/share/icons/default.kde/48x48/apps:$KDEDIR/share/icons/hicolor/48x48/apps:$KDEDIR/share/icons/locolor/48x48/apps:/usr/share/pixmaps",
                                         (ASFlagType )(1 << 4), -1);
#line 603
    GNOMECategories = create_category_tree("GNOME", "~/.gnome2/vfolders/applications/:$GNOMEDIR/share/applications:/usr/share/applications:/usr/local/share/applications",
                                           "~/.icons/gnome/48x48/apps/:$XDG_DATA_DIRS/icons/gnome/48x48/apps/:$GNOMEDIR/share/pixmaps:/usr/share/pixmaps:/usr/share/icons:/usr/share/icons/hicolor/48x48/apps:/usr/share/icons/hicolor/32x32/apps:/usr/share/icons/gnome/48x48/apps",
                                           (ASFlagType )(1 << 3), -1);
#line 606
    OtherCategories = create_category_tree("OTHER", "/etc/X11/applnk:/usr/share/applications:/usr/local/share/applications:/var/lib/menu-xdg",
                                           "/usr/share/pixmaps:/usr/local/share/pixmaps:/usr/share/icons:/usr/share/icons/hicolor/48x48/apps:/usr/share/icons/hicolor/32x32/apps",
                                           (ASFlagType )((1 << 1) | (1 << 2)), -1);
    }
  }
  {
#line 612
  CombinedCategories = create_category_tree("", (char const   *)((void *)0), (char const   *)((void *)0),
                                            (ASFlagType )0, -1);
#line 614
  load_category_tree(StandardCategories);
  }
  {
#line 615
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 615
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 616
  if (! cached) {
    {
#line 617
    add_category_tree_subtree(AfterStepCategories, StandardCategories);
#line 618
    add_category_tree_subtree(KDECategories, StandardCategories);
#line 619
    add_category_tree_subtree(GNOMECategories, StandardCategories);
#line 620
    add_category_tree_subtree(OtherCategories, StandardCategories);
    }
  }
  {
#line 622
  load_category_tree(AfterStepCategories);
  }
  {
#line 623
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 623
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 624
  load_category_tree(KDECategories);
  }
  {
#line 625
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 625
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 626
  load_category_tree(GNOMECategories);
  }
  {
#line 627
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 627
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 628
  load_category_tree(OtherCategories);
  }
  {
#line 629
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 629
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 634
  add_category_tree_subtree(CombinedCategories, StandardCategories);
#line 635
  add_category_tree_subtree(CombinedCategories, AfterStepCategories);
#line 636
  add_category_tree_subtree(CombinedCategories, KDECategories);
#line 637
  add_category_tree_subtree(CombinedCategories, GNOMECategories);
#line 638
  add_category_tree_subtree(CombinedCategories, OtherCategories);
  }
  {
#line 640
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 640
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 641
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterConf/DesktopEntry.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  ASDesktopCategory *dc ;
  ASCategoryTree *ct ;
  int cached ;
  int tmp ;
  char *name ;
  char *colon ;
  char *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 648
  dc = (ASDesktopCategory *)((void *)0);
#line 649
  ct = (ASCategoryTree *)((void *)0);
#line 650
  cached = 0;
#line 652
  InitMyApp("PrintDesktopEntries", argc, argv, (void (*)(void))((void *)0), (void (*)(void))((void *)0),
            (ASFlagType )0);
#line 653
  InitSession();
#line 654
  i = 1;
  }
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if (! (i < argc)) {
#line 654
      goto while_break;
    }
#line 655
    if (*(argv + i)) {
      {
#line 655
      tmp = strcmp((char const   *)*(argv + i), "--cached");
      }
#line 655
      if (tmp == 0) {
#line 656
        cached = 1;
      }
    }
#line 654
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 658
  ReloadCategories(cached);
#line 660
  i = 1;
  }
  {
#line 660
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 660
    if (! (i < argc)) {
#line 660
      goto while_break___0;
    }
#line 661
    if (*(argv + i)) {
      {
#line 661
      tmp___4 = strcmp((char const   *)*(argv + i), "--cached");
      }
#line 661
      if (tmp___4 != 0) {
        {
#line 662
        name = (char *)((void *)0);
#line 663
        tmp___0 = strchr((char const   *)*(argv + i), ':');
#line 663
        colon = tmp___0;
#line 664
        tmp___1 = strlen((char const   *)*(argv + i));
#line 664
        len = (int )tmp___1;
        }
#line 666
        if ((unsigned long )colon == (unsigned long )((void *)0)) {
          {
#line 667
          tmp___2 = safemalloc((size_t )(((len + 1) + 7) + 1));
#line 667
          name = (char *)tmp___2;
#line 668
          sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s:Default",
                  *(argv + i));
          }
        } else
#line 669
        if ((int )*(colon + 1) == 0) {
          {
#line 670
          tmp___3 = safemalloc((size_t )((len + 7) + 1));
#line 670
          name = (char *)tmp___3;
#line 671
          sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%sDefault",
                  *(argv + i));
          }
        } else {
          {
#line 673
          name = mystrdup((char const   *)*(argv + i));
          }
        }
        {
#line 675
        dc = name2desktop_category((char const   *)name, & ct);
        }
#line 676
        if ((unsigned long )dc == (unsigned long )((void *)0)) {
          {
#line 677
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid category name \"%s\"",
                  *(argv + i));
          }
#line 678
          return (0);
        }
        {
#line 680
        free((void *)name);
        }
#line 681
        goto while_break___0;
      }
    }
#line 660
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 683
  if (dc) {
#line 683
    if (ct) {
      {
#line 684
      print_category_tree2(ct, dc);
      }
    } else {
#line 683
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 687
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#Standard: ####################################################\n");
#line 689
    print_category_tree2(StandardCategories, (ASDesktopCategory *)((void *)0));
#line 690
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#AfterStep:####################################################\n");
#line 692
    print_category_tree2(AfterStepCategories, (ASDesktopCategory *)((void *)0));
#line 693
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#KDE:      ####################################################\n");
#line 695
    print_category_tree2(KDECategories, (ASDesktopCategory *)((void *)0));
#line 696
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#GNOME:    ####################################################\n");
#line 698
    print_category_tree2(GNOMECategories, (ASDesktopCategory *)((void *)0));
#line 699
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#OTHER:   ####################################################\n");
#line 701
    print_category_tree2(OtherCategories, (ASDesktopCategory *)((void *)0));
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#Combined: ####################################################\n");
#line 704
    print_category_tree2(CombinedCategories, (ASDesktopCategory *)((void *)0));
#line 705
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"#####################################################\n");
    }
  }
  {
#line 708
  DestroyCategories();
#line 709
  FreeMyAppResources();
  }
#line 710
  return (1);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/output.h"
extern void set_application_name(char *argv0 ) ;
#line 22
extern unsigned int set_output_threshold(unsigned int threshold ) ;
#line 49
extern int show_error(char const   *error_format  , ...) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/safemalloc.h"
extern void *safecalloc(size_t num , size_t blength ) ;
#line 340 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
extern struct ASFontManager *create_font_manager(Display *dpy , char const   *font_path ,
                                                 struct ASFontManager *reusable_memory ) ;
#line 341
extern void destroy_font_manager(struct ASFontManager *fontman , int reusable ) ;
#line 447
extern struct ASFont *get_asfont(struct ASFontManager *fontman , char const   *font_string ,
                                 int face_no , int size , ASFontType type_and_flags ) ;
#line 449
extern int release_font(struct ASFont *font ) ;
#line 479
extern ASGlyph **get_text_glyph_list(char const   *text , ASFont *font , ASCharType char_type ,
                                     int length ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascheckttf.c"
void usage(void) 
{ 


  {
  {
#line 19
  printf((char const   */* __restrict  */)"  Usage:   ascheckttf [-h] [-f font] [-s size] [-t text]|[--unicode <listof unicodes>][-S 3D_style] \n");
#line 21
  printf((char const   */* __restrict  */)"  Where: font - TrueType font\'s filename\n");
#line 22
  printf((char const   */* __restrict  */)"         size - size in points for TrueType fonts;\n");
#line 23
  printf((char const   */* __restrict  */)"         text - text;\n");
#line 24
  printf((char const   */* __restrict  */)"         unicode - comma separated list of unicode codes;\n");
#line 25
  printf((char const   */* __restrict  */)"         3D_style - 3D style of text. One of the following:\n");
#line 27
  printf((char const   */* __restrict  */)"             0 - plain 2D tetx, 1 - embossed, 2 - sunken, 3 - shade above,\n");
#line 29
  printf((char const   */* __restrict  */)"             4 - shade below, 5 - embossed thick, 6 - sunken thick.\n");
#line 31
  printf((char const   */* __restrict  */)"             7 - ouline above, 8 - ouline below, 9 - full ouline.\n");
  }
#line 35
  return;
}
}
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 2808
extern int XMapRaised(Display * , Window  ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 16 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/mystring.h"
extern char *mystrndup(char const   *str , size_t n ) ;
#line 489 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asvisual.h"
extern ASVisual *create_asvisual(Display *dpy , int screen , int default_depth , ASVisual *reusable_memory ) ;
#line 246 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../blender.h"
extern void alphablend_scanlines(struct ASScanline *bottom , struct ASScanline *top ,
                                 int offset ) ;
#line 291
extern merge_scanlines_func blend_scanlines_name2func(char const   *name ) ;
#line 292
extern void list_scanline_merging(FILE *stream , char const   *format ) ;
#line 561 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
extern void destroy_asimage(ASImage **im ) ;
#line 357 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../ximage.h"
extern Pixmap asimage2pixmap(struct ASVisual *asv , Window root , ASImage *im , GC gc ,
                             int use_cached ) ;
#line 368 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../transform.h"
extern ASImage *scale_asimage(struct ASVisual *asv , ASImage *src , int to_width ,
                              int to_height , ASAltImFormats out_format , unsigned int compression_out ,
                              int quality ) ;
#line 383
extern ASImage *merge_layers(struct ASVisual *asv , ASImageLayer *layers , int count ,
                             int dst_width , int dst_height , ASAltImFormats out_format ,
                             unsigned int compression_out , int quality ) ;
#line 221 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../import.h"
extern ASImage *file2ASImage(char const   *file , ASFlagType what , double gamma ,
                             unsigned int compression  , ...) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/common.h"
Atom _XA_WM_DELETE_WINDOW ;
#line 5
Window create_top_level_window(ASVisual *asv___0 , Window root , int x , int y , unsigned int width ,
                               unsigned int height , unsigned int border_width , unsigned long attr_mask ,
                               XSetWindowAttributes *attr , char const   *app_class ,
                               char const   *app_name ) ;
#line 11
Pixmap set_window_background_and_free(Window w , Pixmap p ) ;
#line 13
void wait_closedown(Window w ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asmerge.c"
char *burning_rose[6]  = {      (char *)"asmerge",      (char *)"rose512.jpg",      (char *)"add",      (char *)"back.xpm:512x386", 
        (char *)"hue",      (char *)"fore.xpm:512x386"};
#line 1900 "/usr/include/X11/Xlib.h"
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2528
extern int XFree(void * ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3351
extern int XSetWindowBackgroundPixmap(Display * , Window  , Pixmap  ) ;
#line 665 "/usr/include/X11/Xutil.h"
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 733
extern int XStringListToTextProperty(char ** , int  , XTextProperty * ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/output.h"
extern char const   *get_application_name() ;
#line 491 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asvisual.h"
extern ASVisual *get_default_asvisual() ;
#line 630
extern Window create_visual_window(ASVisual *asv , Window parent , int x , int y ,
                                   unsigned int width , unsigned int height , unsigned int border_width ,
                                   unsigned int wclass , unsigned long mask , XSetWindowAttributes *attributes ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/common.c"
Atom _XA_WM_DELETE_WINDOW  =    (Atom )0L;
#line 77 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/common.c"
Window create_top_level_window(ASVisual *asv___0 , Window root , int x , int y , unsigned int width ,
                               unsigned int height , unsigned int border_width , unsigned long attr_mask ,
                               XSetWindowAttributes *attr , char const   *app_class ,
                               char const   *app_name ) 
{ 
  Window w ;
  char *tmp ;
  XTextProperty name ;
  XClassHint class1 ;
  char const   *tmp___0 ;

  {
  {
#line 85
  w = (Window )0L;
#line 91
  w = create_visual_window(asv___0, root, x, y, width, height, border_width, 1U, attr_mask,
                           attr);
  }
#line 94
  if ((unsigned long )app_name == (unsigned long )((void *)0)) {
    {
#line 94
    tmp___0 = get_application_name();
#line 94
    tmp = (char *)tmp___0;
    }
  } else {
#line 94
    tmp = (char *)app_name;
  }
  {
#line 95
  XStringListToTextProperty(& tmp, 1, & name);
#line 97
  class1.res_name = tmp;
#line 98
  class1.res_class = (char *)app_class;
#line 99
  XSetWMProtocols(asv___0->dpy, w, & _XA_WM_DELETE_WINDOW, 1);
#line 100
  XSetWMProperties(asv___0->dpy, w, & name, & name, (char **)((void *)0), 0, (XSizeHints *)((void *)0),
                   (XWMHints *)((void *)0), & class1);
#line 102
  XFree((void *)((char *)name.value));
  }
#line 105
  return (w);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/common.c"
Pixmap set_window_background_and_free(Window w , Pixmap p ) 
{ 
  Display *dpy___0 ;
  ASVisual *tmp ;

  {
#line 134
  if (p != 0UL) {
#line 134
    if (w != 0UL) {
      {
#line 136
      tmp = get_default_asvisual();
#line 136
      dpy___0 = tmp->dpy;
      }
#line 138
      if (dpy___0) {
        {
#line 140
        XSetWindowBackgroundPixmap(dpy___0, w, p);
#line 141
        XClearWindow(dpy___0, w);
#line 142
        XFlush(dpy___0);
#line 143
        XFreePixmap(dpy___0, p);
#line 144
        p = (Pixmap )0L;
        }
      }
    }
  }
#line 148
  return (p);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/common.c"
void wait_closedown(Window w ) 
{ 
  Display *dpy___0 ;
  ASVisual *tmp ;
  XEvent event ;

  {
  {
#line 179
  tmp = get_default_asvisual();
#line 179
  dpy___0 = tmp->dpy;
  }
#line 181
  if (dpy___0) {
#line 183
    if (w) {
      {
#line 185
      XSelectInput(dpy___0, w, ((1L << 17) | (1L << 2)) | (1L << 3));
      }
      {
#line 189
      while (1) {
        while_continue: /* CIL Label */ ;
#line 189
        if (! (w != 0UL)) {
#line 189
          goto while_break;
        }
        {
#line 193
        XNextEvent(dpy___0, & event);
        }
        {
#line 196
        if (event.type == 33) {
#line 196
          goto case_33;
        }
#line 200
        if (event.type == 4) {
#line 200
          goto case_4;
        }
#line 194
        goto switch_break;
        case_33: /* CIL Label */ 
#line 197
        if (event.xclient.format != 32) {
#line 199
          goto switch_break;
        } else
#line 197
        if ((Atom )event.xclient.data.l[0] != _XA_WM_DELETE_WINDOW) {
#line 199
          goto switch_break;
        }
        case_4: /* CIL Label */ 
        {
#line 201
        XDestroyWindow(dpy___0, w);
#line 202
        XFlush(dpy___0);
#line 203
        w = (Window )0L;
        }
#line 204
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 208
    XCloseDisplay(dpy___0);
    }
  }
#line 211
  return;
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/output.h"
extern int show_warning(char const   *warning_format  , ...) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/parse.h"
extern char const   *parse_argb_color(char const   *color , CARD32 *pargb ) ;
#line 378 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../transform.h"
extern ASImage *tile_asimage(struct ASVisual *asv , ASImage *src , int offset_x ,
                             int offset_y , int to_width , int to_height , ARGB32 tint ,
                             ASAltImFormats out_format , unsigned int compression_out ,
                             int quality ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 1503 "/usr/include/X11/Xlib.h"
extern char *XFetchBytes(Display * , int * ) ;
#line 1553
extern int XInternAtoms(Display * , char ** , int  , int  , Atom * ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2183
extern int XConnectionNumber(Display * ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2790
extern int XKillClient(Display * , XID  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2846
extern int XMoveWindow(Display * , Window  , int  , int  ) ;
#line 2877
extern int XPeekEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 3038
extern int XRaiseWindow(Display * , Window  ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3195
extern int XSetCloseDownMode(Display * , int  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3458
extern int XTranslateCoordinates(Display * , Window  , Window  , int  , int  , int * ,
                                 int * , Window * ) ;
#line 3517
extern int XUnmapWindow(Display * , Window  ) ;
#line 659 "/usr/include/X11/Xutil.h"
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/output.h"
extern int show_progress(char const   *msg_format  , ...) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/fs.h"
extern char *load_file(char const   *realfilename ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/parse.h"
extern double parse_math(char const   *str , char **endptr , double size ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../../libAfterBase/xml.h"
extern xml_elem_t *xml_parse_parm(char const   *parm , struct ASHashTable *vocabulary ) ;
#line 111
extern void xml_print(xml_elem_t *root ) ;
#line 113
extern void xml_elem_delete(xml_elem_t **list , xml_elem_t *elem ) ;
#line 114
extern xml_elem_t *xml_parse_doc(char const   *str , struct ASHashTable *vocabulary ) ;
#line 119
extern void reset_xml_buffer(ASXmlBuffer *xb ) ;
#line 121
extern void add_xml_buffer_chars(ASXmlBuffer *xb , char *tmp , int len ) ;
#line 122
extern int spool_xml_tag(ASXmlBuffer *xb , char *tmp , int len ) ;
#line 130
extern xml_elem_t *format_xml_buffer_state(ASXmlBuffer *xb ) ;
#line 492 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asvisual.h"
extern void destroy_asvisual(ASVisual *asv , int reusable ) ;
#line 639
extern Pixmap create_visual_pixmap(ASVisual *asv , Window root , unsigned int width ,
                                   unsigned int height , unsigned int depth ) ;
#line 644
extern int get_dpy_drawable_size(Display *drawable_dpy , Drawable d , unsigned int *ret_w ,
                                 unsigned int *ret_h ) ;
#line 651
extern XImage *create_visual_scratch_ximage(ASVisual *asv , unsigned int width , unsigned int height ,
                                            unsigned int depth ) ;
#line 650 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
extern void destroy_image_manager(struct ASImageManager *imman , int reusable ) ;
#line 759
extern int safe_asimage_destroy(ASImage *im ) ;
#line 820
extern ASImageLayer *create_image_layers(int count ) ;
#line 950
extern ASFlagType get_asimage_chanmask(ASImage *im ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../char2uni.h"
extern ASSupportedCharsets as_set_charset(ASSupportedCharsets new_charset ) ;
#line 57
extern ASSupportedCharsets parse_charset_name(char const   *name ) ;
#line 166 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../ximage.h"
extern ASImage *pixmap2asimage(struct ASVisual *asv , Pixmap p , int x , int y , unsigned int width ,
                               unsigned int height , unsigned long plane_mask , int keep_cache ,
                               unsigned int compression ) ;
#line 335
extern int subimage2ximage(struct ASVisual *asv , ASImage *im , int x , int y , XImage *xim ) ;
#line 336
extern int put_ximage(ASVisual *asv , XImage *xim , Drawable d , GC gc , int src_x ,
                      int src_y , int dest_x , int dest_y , unsigned int width , unsigned int height ) ;
#line 343
extern int asimage2drawable(struct ASVisual *asv , Drawable d , ASImage *im , GC gc ,
                            int src_x , int src_y , int dest_x , int dest_y , unsigned int width ,
                            unsigned int height , int use_cached ) ;
#line 348
extern int asimage2drawable_gl(ASVisual *asv , Drawable d , ASImage *im , int src_x ,
                               int src_y , int dest_x , int dest_y , int width , int height ,
                               int d_width , int d_height , int force_direct ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimagexml.h"
extern struct ASImageManager *create_generic_imageman(char const   *path ) ;
#line 26
extern struct ASFontManager *create_generic_fontman(Display *dpy , char const   *path ) ;
#line 29
extern ASImage *compose_asimage_xml(ASVisual *asv , struct ASImageManager *imman ,
                                    struct ASFontManager *fontman , char *doc_str ,
                                    ASFlagType flags , int verbose , Window display_win ,
                                    char const   *path ) ;
#line 54
extern ASImage *compose_asimage_xml_from_doc(ASVisual *asv , struct ASImageManager *imman ,
                                             struct ASFontManager *fontman , struct xml_elem_t *doc ,
                                             ASFlagType flags , int verbose , Window display_win ,
                                             char const   *path , int target_width ,
                                             int target_height ) ;
#line 71
extern int save_asimage_to_file(char const   *file2bsaved , ASImage *im , char const   *strtype ,
                                char const   *compress , char const   *opacity , int delay ,
                                int replace ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../pixmap.h"
extern Pixmap GetRootPixmap(Atom id ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
extern int asvisual_empty_XErrorHandler(Display *dpy , XErrorEvent *event ) ;
#line 163 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
ASVisual *asv  ;
#line 164 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
int verbose  =    0;
#line 166 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
void version(void) 
{ 


  {
  {
#line 167
  printf((char const   */* __restrict  */)"ascompose version 1.2\n");
  }
#line 168
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
static char *default_doc_str  =    (char *)"<composite op=hue>  <composite op=add>    <scale width=512 height=proportional>\t\t<img id=rose src=rose512.jpg/></scale>    <tile width=512 height=384><img src=back.xpm/></tile>  </composite>  <tile width=512 height=384><img src=fore.xpm/></tile></composite><printf format=\"original image width=%d\n\" var=\"rose.width\"/><printf format=\"original image height=%d\n\" var=\"rose.height\"/><printf format=\"original image size in pixels=%d\n\" val=$rose.width*$rose.height/>";
#line 254
char *load_stdin(void) ;
#line 283
Window showimage(ASImage *im , int looping , Window main_window , ASComposeWinProps *props ,
                 int dst_x , int dst_y ) ;
#line 284
Window make_main_window(int onroot , ASComposeWinProps *props ) ;
#line 286 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
int screen  =    0;
#line 286 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
int depth  =    0;
#line 287 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
Display *dpy  =    (Display *)((void *)0);
#line 773 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
Window make_main_window(int onroot , ASComposeWinProps *props ) 
{ 
  Window w ;
  XSetWindowAttributes attributes ;

  {
#line 776
  w = (Window )0L;
#line 780
  if (onroot) {
#line 782
    w = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
#line 783
    props->last_x = 0;
#line 784
    props->last_y = 0;
#line 785
    props->last_width = 0U;
#line 786
    props->last_height = 0U;
  } else {
    {
#line 789
    attributes.override_redirect = props->override_redirect;
#line 790
    w = create_top_level_window(asv, (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root,
                                32, 32, 100U, 30U, 0U, (unsigned long )(1L << 9),
                                & attributes, "ASCompose", props->title);
#line 794
    props->last_x = 32;
#line 795
    props->last_y = 32;
#line 796
    props->last_width = 100U;
#line 797
    props->last_height = 30U;
#line 798
    XSelectInput(dpy, w, ((1L << 17) | (1L << 2)) | (1L << 3));
    }
  }
#line 800
  props->last_root_pmap = (Pixmap )0L;
#line 801
  if (props->last_root_im) {
    {
#line 802
    safe_asimage_destroy(props->last_root_im);
    }
  }
#line 803
  props->last_root_im = (ASImage *)((void *)0);
#line 807
  return (w);
}
}
#line 810 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
int set_root_pixmap_property(long pmap ) 
{ 
  Window root ;
  char *names[2] ;
  Atom atoms[2] ;
  int i ;
  Pixmap pmaps[2] ;
  Atom type ;
  int format ;
  unsigned long nitems ;
  unsigned long after ;
  union __anonunion_data_334 data ;
  int (*oldXErrorHandler)(Display * , XErrorEvent * ) ;
  XErrorHandler tmp ;
  int tmp___0 ;
  Atom tmp___1 ;

  {
  {
#line 814
  root = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
#line 815
  names[0] = (char *)"_XROOTPMAP_ID";
#line 815
  names[1] = (char *)"ESETROOT_PMAP_ID";
#line 819
  tmp___0 = XInternAtoms(dpy, & names[0], 2, 1, & atoms[0]);
  }
#line 819
  if (tmp___0 != 0) {
#line 821
    pmaps[0] = (Pixmap )0;
#line 821
    pmaps[1] = (Pixmap )0;
#line 831
    i = 0;
    {
#line 831
    while (1) {
      while_continue: /* CIL Label */ ;
#line 831
      if (! (i < 2)) {
#line 831
        goto while_break;
      }
#line 832
      if (atoms[i]) {
        {
#line 835
        data.long_ptr = (long *)((void *)0);
#line 836
        XGetWindowProperty(dpy, root, atoms[i], 0L, 1L, 0, (Atom )0L, & type, & format,
                           & nitems, & after, & data.uc_ptr);
        }
#line 837
        if ((unsigned long )data.long_ptr == (unsigned long )((void *)0)) {
#line 838
          goto while_break;
        }
#line 839
        pmaps[i] = (Pixmap )*(data.long_ptr + 0);
#line 841
        if (format != 32) {
#line 842
          goto while_break;
        } else
#line 841
        if (nitems == 0UL) {
#line 842
          goto while_break;
        } else
#line 841
        if (pmaps[i] != pmaps[0]) {
#line 842
          goto while_break;
        } else
#line 841
        if (type != 20UL) {
#line 842
          goto while_break;
        }
      }
#line 831
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 844
    if (i >= 2) {
#line 844
      if (pmaps[0]) {
#line 844
        if (pmaps[0] != (Pixmap )pmap) {
          {
#line 847
          tmp = XSetErrorHandler(& asvisual_empty_XErrorHandler);
#line 847
          oldXErrorHandler = tmp;
#line 849
          XKillClient(dpy, pmaps[0]);
#line 850
          XSync(dpy, 0);
#line 851
          XSetErrorHandler(oldXErrorHandler);
          }
        }
      }
    }
  }
#line 854
  i = 0;
  {
#line 854
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 854
    if (! (i < 2)) {
#line 854
      goto while_break___0;
    }
#line 856
    if (! atoms[i]) {
      {
#line 857
      tmp___1 = XInternAtom(dpy, (char const   *)names[i], 0);
#line 857
      atoms[i] = tmp___1;
      }
#line 857
      if (tmp___1 == 0UL) {
#line 858
        goto while_break___0;
      }
    }
    {
#line 860
    XChangeProperty(dpy, root, atoms[i], (Atom )20, 32, 0, (unsigned char const   *)((unsigned char *)(& pmap)),
                    1);
#line 854
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 862
  if (i >= 2) {
    {
#line 864
    XSetCloseDownMode(dpy, 1);
    }
#line 865
    return (1);
  }
#line 868
  return (0);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
int wait_x_timeout(int timeout ) 
{ 
  XEvent evt ;
  fd_set in_fdset ;
  int x_fd ;
  int tmp ;
  struct timeval tv ;
  struct timeval *t ;
  int retval ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;

  {
#line 875
  if (timeout < 0) {
    {
#line 878
    XPeekEvent(dpy, & evt);
    }
#line 879
    return (1);
  } else
#line 880
  if (timeout > 0) {
    {
#line 883
    tmp = XConnectionNumber(dpy);
#line 883
    x_fd = tmp;
#line 885
    t = (struct timeval *)((void *)0);
#line 886
    retval = 0;
    }
    {
#line 888
    while (1) {
      while_continue: /* CIL Label */ ;
#line 888
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& in_fdset.__fds_bits[0]): "memory");
#line 888
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 889
    in_fdset.__fds_bits[x_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << x_fd % (8 * (int )sizeof(__fd_mask ));
#line 890
    tv.tv_sec = (__time_t )(timeout / 1000);
#line 891
    tv.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 892
    t = & tv;
#line 893
    retval = select(x_fd + 1, (fd_set */* __restrict  */)(& in_fdset), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)t);
    }
#line 894
    return (retval > 0);
  }
  {
#line 897
  tmp___0 = XPending(dpy);
  }
#line 897
  return (tmp___0);
#line 899
  return (0);
}
}
#line 902 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
Window showimage(ASImage *im , int looping , Window main_window , ASComposeWinProps *props ,
                 int dst_x , int dst_y ) 
{ 
  int x ;
  int y ;
  ASImage *orig_im ;
  unsigned int width ;
  unsigned int height ;
  unsigned int shape_rects_count ;
  XRectangle *shape_rects ;
  int done ;
  Window root ;
  int screen___0 ;
  int root_w ;
  int root_h ;
  Pixmap saved_canvas ;
  int move ;
  XSizeHints hints ;
  unsigned int root_pmap_width ;
  unsigned int root_pmap_height ;
  Pixmap rp ;
  Pixmap tmp ;
  ASImage *transp_im ;
  ASImage *tmp___0 ;
  int root_x ;
  int root_y ;
  Window wdumm ;
  ASImageLayer *layers ;
  ASImageLayer *tmp___1 ;
  int tmp___2 ;
  ASFlagType tmp___3 ;
  int pmap_width ;
  int pmap_height ;
  GC gc ;
  int tmp___4 ;
  int tmp___5 ;
  XImage *xim ;
  XImage *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  XEvent event ;
  int do_close ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 905
  x = 32;
#line 905
  y = 32;
#line 906
  orig_im = im;
#line 908
  shape_rects_count = 0U;
#line 909
  shape_rects = (XRectangle *)((void *)0);
#line 910
  done = 0;
#line 911
  root = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
#line 912
  screen___0 = ((_XPrivDisplay )dpy)->default_screen;
#line 913
  root_w = (((_XPrivDisplay )dpy)->screens + screen___0)->width;
#line 914
  root_h = (((_XPrivDisplay )dpy)->screens + screen___0)->height;
#line 915
  saved_canvas = (Pixmap )0L;
#line 917
  if ((unsigned long )im == (unsigned long )((void *)0)) {
#line 918
    return ((Window )0L);
  } else
#line 917
  if (main_window == 0UL) {
#line 918
    return ((Window )0L);
  }
#line 920
  width = im->width + (unsigned int )dst_x;
#line 921
  height = im->height + (unsigned int )dst_y;
#line 923
  if (main_window != root) {
#line 925
    move = 1;
#line 927
    if (props->geom_flags & 4UL) {
#line 927
      if (props->geom_width > 0U) {
#line 928
        width = props->geom_width;
      }
    }
#line 929
    if (props->geom_flags & 8UL) {
#line 929
      if (props->geom_height > 0U) {
#line 930
        height = props->geom_height;
      }
    }
#line 932
    if (props->center) {
#line 934
      x = (int )(((unsigned int )root_w - width) / 2U);
#line 935
      y = (int )(((unsigned int )root_h - height) / 2U);
    } else
#line 936
    if (props->geom_flags & 3UL) {
#line 938
      x = props->geom_x;
#line 939
      y = props->geom_y;
#line 940
      if (props->geom_flags & 16UL) {
#line 941
        x = (int )(((unsigned int )root_w - width) + (unsigned int )x);
      }
#line 942
      if (props->geom_flags & 32UL) {
#line 943
        y = (int )(((unsigned int )root_h - height) + (unsigned int )y);
      }
    } else {
#line 945
      move = 0;
    }
#line 947
    if (move) {
#line 947
      if (props->last_x != x) {
        {
#line 949
        XMoveWindow(dpy, main_window, x, y);
#line 950
        props->last_x = x;
#line 951
        props->last_y = y;
        }
      } else
#line 947
      if (props->last_y != y) {
        {
#line 949
        XMoveWindow(dpy, main_window, x, y);
#line 950
        props->last_x = x;
#line 951
        props->last_y = y;
        }
      }
    }
#line 953
    if (props->last_width != width) {
      {
#line 955
      XResizeWindow(dpy, main_window, width, height);
#line 956
      props->last_width = width;
#line 957
      props->last_height = height;
#line 958
      saved_canvas = props->canvas;
#line 959
      props->canvas = (Pixmap )0L;
      }
    } else
#line 953
    if (props->last_height != height) {
      {
#line 955
      XResizeWindow(dpy, main_window, width, height);
#line 956
      props->last_width = width;
#line 957
      props->last_height = height;
#line 958
      saved_canvas = props->canvas;
#line 959
      props->canvas = (Pixmap )0L;
      }
    }
#line 962
    if (! props->mapped) {
#line 964
      if (props->geom_flags != 0UL) {
#line 967
        hints.flags = 1L << 9;
#line 968
        if (props->geom_flags & 12UL) {
#line 969
          hints.flags |= 1L << 1;
        }
#line 970
        if (props->geom_flags & 3UL) {
#line 971
          hints.flags |= 1L;
        }
#line 972
        hints.win_gravity = 1;
#line 973
        if (props->geom_flags & 16UL) {
#line 973
          if (! (props->geom_flags & 32UL)) {
#line 974
            hints.win_gravity = 3;
          } else {
#line 973
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 975
        if (! (props->geom_flags & 16UL)) {
#line 975
          if (props->geom_flags & 32UL) {
#line 976
            hints.win_gravity = 7;
          } else {
#line 975
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 977
        if (props->geom_flags & 16UL) {
#line 977
          if (props->geom_flags & 32UL) {
#line 978
            hints.win_gravity = 9;
          }
        }
        {
#line 979
        XSetWMNormalHints(dpy, main_window, & hints);
        }
      }
      {
#line 981
      XMapWindow(dpy, main_window);
#line 982
      props->mapped = 1;
      }
    }
#line 984
    if (props->on_top) {
      {
#line 985
      XRaiseWindow(dpy, main_window);
      }
    }
    {
#line 986
    tmp___3 = get_asimage_chanmask(im);
    }
#line 986
    if (tmp___3 & (unsigned long )(1 << 3)) {
      {
#line 995
      tmp = GetRootPixmap((Atom )0L);
#line 995
      rp = tmp;
#line 996
      transp_im = (ASImage *)((void *)0);
#line 998
      XTranslateCoordinates(dpy, main_window, root, 0, 0, & root_x, & root_y, & wdumm);
      }
#line 1000
      if (rp) {
#line 1002
        if (props->last_root_pmap != rp) {
#line 1002
          goto _L___1;
        } else
#line 1002
        if ((unsigned long )props->last_root_im == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 1005
          if (props->last_root_im) {
            {
#line 1006
            safe_asimage_destroy(props->last_root_im);
            }
          }
          {
#line 1007
          get_dpy_drawable_size(asv->dpy, rp, & root_pmap_width, & root_pmap_height);
#line 1008
          transp_im = pixmap2asimage(asv, rp, 0, 0, root_pmap_width, root_pmap_height,
                                     4294967295UL, 0, 0U);
#line 1009
          props->last_root_pmap = rp;
#line 1010
          props->last_root_im = transp_im;
          }
        } else {
#line 1013
          width = (props->last_root_im)->width;
#line 1014
          height = (props->last_root_im)->height;
#line 1015
          transp_im = props->last_root_im;
        }
      }
#line 1019
      if (transp_im) {
        {
#line 1021
        tmp___1 = create_image_layers(2);
#line 1021
        layers = tmp___1;
#line 1023
        (layers + 0)->im = transp_im;
#line 1024
        (layers + 0)->clip_x = root_x + dst_x;
#line 1025
        (layers + 0)->clip_y = root_y + dst_y;
#line 1026
        (layers + 0)->clip_width = im->width;
#line 1027
        (layers + 0)->clip_height = im->height;
#line 1028
        (layers + 1)->im = im;
#line 1029
        (layers + 1)->clip_width = im->width;
#line 1030
        (layers + 1)->clip_height = im->height;
        }
#line 1031
        if (asv->glx_support & (unsigned long )(1 << 3)) {
#line 1031
          tmp___2 = 0;
        } else {
#line 1031
          tmp___2 = 1;
        }
        {
#line 1031
        tmp___0 = merge_layers(asv, layers, 2, (int )im->width, (int )im->height,
                               (ASAltImFormats )tmp___2, 0U, -1);
        }
#line 1033
        if (tmp___0) {
#line 1034
          im = tmp___0;
        }
        {
#line 1035
        free((void *)layers);
        }
      }
    }
  }
#line 1044
  if (props->canvas == 0UL) {
#line 1046
    pmap_width = (int )width;
#line 1047
    pmap_height = (int )height;
#line 1048
    gc = (GC )((void *)0);
#line 1049
    if (main_window == root) {
#line 1051
      pmap_width = (int )((unsigned int )dst_x + im->width);
#line 1052
      pmap_height = (int )((unsigned int )dst_x + im->height);
#line 1053
      depth = (((_XPrivDisplay )dpy)->screens + screen___0)->root_depth;
#line 1054
      gc = (((_XPrivDisplay )dpy)->screens + screen___0)->default_gc;
    }
    {
#line 1056
    props->canvas = create_visual_pixmap(asv, main_window, (unsigned int )pmap_width,
                                         (unsigned int )pmap_height, (unsigned int )(((_XPrivDisplay )dpy)->screens + screen___0)->root_depth);
    }
#line 1059
    if ((unsigned long )gc == (unsigned long )((void *)0)) {
      {
#line 1060
      gc = XCreateGC(dpy, main_window, 0UL, (XGCValues *)((void *)0));
      }
    }
#line 1062
    if ((unsigned int )pmap_width != im->width) {
      {
#line 1063
      XFillRectangle(dpy, props->canvas, gc, 0, 0, (unsigned int )pmap_width, (unsigned int )pmap_height);
      }
    } else
#line 1062
    if ((unsigned int )pmap_height != im->height) {
      {
#line 1063
      XFillRectangle(dpy, props->canvas, gc, 0, 0, (unsigned int )pmap_width, (unsigned int )pmap_height);
      }
    }
#line 1065
    if (saved_canvas) {
#line 1066
      if (props->canvas_height < pmap_height) {
#line 1066
        tmp___4 = props->canvas_height;
      } else {
#line 1066
        tmp___4 = pmap_height;
      }
#line 1066
      if (props->canvas_width < pmap_width) {
#line 1066
        tmp___5 = props->canvas_width;
      } else {
#line 1066
        tmp___5 = pmap_width;
      }
      {
#line 1066
      XCopyArea(dpy, saved_canvas, props->canvas, gc, 0, 0, (unsigned int )tmp___5,
                (unsigned int )tmp___4, 0, 0);
      }
    }
#line 1070
    if ((unsigned long )gc != (unsigned long )(((_XPrivDisplay )dpy)->screens + screen___0)->default_gc) {
      {
#line 1071
      XFreeGC(dpy, gc);
      }
    }
#line 1073
    props->canvas_width = pmap_width;
#line 1074
    props->canvas_height = pmap_height;
  }
#line 1076
  if (main_window == root) {
    {
#line 1078
    tmp___6 = create_visual_scratch_ximage(asv, im->width, im->height, (unsigned int )(((_XPrivDisplay )dpy)->screens + screen___0)->root_depth);
#line 1078
    xim = tmp___6;
#line 1079
    tmp___7 = subimage2ximage(asv, im, 0, 0, xim);
    }
#line 1079
    if (tmp___7) {
      {
#line 1081
      put_ximage(asv, xim, props->canvas, (((_XPrivDisplay )dpy)->screens + screen___0)->default_gc,
                 0, 0, dst_x, dst_y, im->width, im->height);
      }
    }
    {
#line 1083
    (*(xim->f.destroy_image))(xim);
    }
  } else {
#line 1086
    if (asv->glx_support & (unsigned long )(1 << 3)) {
      {
#line 1087
      done = asimage2drawable_gl(asv, props->canvas, im, 0, 0, 0, 0, (int )im->width,
                                 (int )im->height, (int )im->width, (int )im->height,
                                 0);
      }
    }
#line 1091
    if (! done) {
      {
#line 1092
      asimage2drawable(asv, props->canvas, im, (GC )((void *)0), 0, 0, dst_x, dst_y,
                       im->width, im->height, 1);
      }
    }
  }
#line 1095
  if ((unsigned long )im != (unsigned long )orig_im) {
    {
#line 1097
    safe_asimage_destroy(im);
#line 1098
    im = orig_im;
    }
  }
  {
#line 1101
  XSetWindowBackgroundPixmap(dpy, main_window, props->canvas);
#line 1102
  XClearWindow(dpy, main_window);
#line 1103
  XFlush(dpy);
  }
#line 1104
  if (main_window == root) {
#line 1104
    if (! looping) {
      {
#line 1106
      tmp___8 = set_root_pixmap_property((long )props->canvas);
      }
#line 1106
      if (tmp___8) {
        {
#line 1108
        props->canvas = (Pixmap )0L;
#line 1109
        XSync(dpy, 0);
        }
      }
    }
  }
#line 1113
  if (saved_canvas) {
    {
#line 1116
    XFreePixmap(dpy, saved_canvas);
    }
  }
#line 1119
  if (main_window == root) {
#line 1119
    if (! looping) {
#line 1120
      return (root);
    }
  }
  {
#line 1134
  XSync(dpy, 0);
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (main_window != 0UL)) {
#line 1136
      goto while_break;
    }
#line 1139
    do_close = 0;
#line 1141
    if (props->timeout) {
      {
#line 1141
      tmp___9 = wait_x_timeout(props->timeout);
      }
#line 1141
      if (! tmp___9) {
#line 1143
        if (looping) {
#line 1144
          return (main_window);
        }
#line 1145
        do_close = 1;
      }
    }
#line 1147
    if (! do_close) {
      {
#line 1149
      tmp___11 = XPending(dpy);
      }
#line 1149
      if (! tmp___11) {
        {
#line 1150
        tmp___10 = wait_x_timeout(props->click_timeout);
        }
#line 1150
        if (! tmp___10) {
#line 1151
          if (looping) {
#line 1152
            return (main_window);
          }
        }
      }
      {
#line 1154
      XNextEvent(dpy, & event);
      }
      {
#line 1157
      if (event.type == 33) {
#line 1157
        goto case_33;
      }
#line 1164
      if (event.type == 4) {
#line 1164
        goto case_4;
      }
#line 1155
      goto switch_break;
      case_33: /* CIL Label */ 
#line 1158
      if (event.xclient.format == 32) {
#line 1158
        if ((Atom )event.xclient.data.l[0] == _XA_WM_DELETE_WINDOW) {
#line 1161
          do_close = 1;
        }
      }
#line 1163
      goto switch_break;
      case_4: /* CIL Label */ ;
#line 1166
      if (looping) {
#line 1167
        return (main_window);
      }
#line 1168
      do_close = 1;
#line 1169
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1172
    if (do_close) {
#line 1174
      if (main_window != root) {
        {
#line 1175
        XDestroyWindow(dpy, main_window);
        }
      }
      {
#line 1176
      XFlush(dpy);
#line 1177
      main_window = (Window )0L;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1182
  return (main_window);
}
}
#line 1186 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/ascompose.c"
char *load_stdin(void) 
{ 
  char buffer[512] ;
  char *complete ;
  void *tmp ;
  int complete_allocated ;
  int complete_curr ;
  int len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1190
  tmp = safemalloc((size_t )8192);
#line 1190
  complete = (char *)tmp;
#line 1191
  complete_allocated = 8192;
#line 1192
  complete_curr = 0;
  }
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1195
    tmp___2 = fgets((char */* __restrict  */)(& buffer[0]), 512, (FILE */* __restrict  */)stdin);
    }
#line 1195
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 1195
      goto while_break;
    }
    {
#line 1197
    tmp___0 = strlen((char const   *)(& buffer[0]));
#line 1197
    len = (int )tmp___0;
    }
#line 1198
    if (complete_curr + len > complete_allocated) {
      {
#line 1200
      complete_allocated += len;
#line 1201
      tmp___1 = realloc((void *)complete, (size_t )complete_allocated);
#line 1201
      complete = (char *)tmp___1;
      }
    }
    {
#line 1203
    memcpy((void */* __restrict  */)(complete + complete_curr), (void const   */* __restrict  */)(& buffer[0]),
           (size_t )len);
#line 1204
    complete_curr += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1206
  return (complete);
}
}
#line 803 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asimage.h"
extern void init_image_layers(ASImageLayer *l , int count ) ;
#line 955
extern void move_asimage_channel(ASImage *dst , int channel_dst , ASImage *src , int channel_src ) ;
#line 537 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../asfont.h"
extern struct ASImage *draw_fancy_text(void const   *text , struct ASFont *font ,
                                       ASTextAttributes *attr , int compression ,
                                       int length ) ;
#line 552
extern int get_fancy_text_size(void const   *text , struct ASFont *font , ASTextAttributes *attr ,
                               unsigned int *width , unsigned int *height , int length ,
                               int *x_positions ) ;
#line 527
extern struct ASImage *draw_utf8_text(char const   *text , struct ASFont *font , ASText3DType type ,
                                      int compression ) ;
#line 545
extern int get_utf8_text_size(char const   *text , struct ASFont *font , ASText3DType type ,
                              unsigned int *width , unsigned int *height ) ;
#line 391 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../transform.h"
extern ASImage *flip_asimage(struct ASVisual *asv , ASImage *src , int offset_x ,
                             int offset_y , int to_width , int to_height , int flip ,
                             ASAltImFormats out_format , unsigned int compression_out ,
                             int quality ) ;
#line 396
extern ASImage *mirror_asimage(ASVisual *asv , ASImage *src , int offset_x , int offset_y ,
                               int to_width , int to_height , int vertical , ASAltImFormats out_format ,
                               unsigned int compression_out , int quality ) ;
#line 372
extern ASImage *scale_asimage2(ASVisual *asv , ASImage *src , int clip_x , int clip_y ,
                               int clip_width , int clip_height , int to_width , int to_height ,
                               ASAltImFormats out_format , unsigned int compression_out ,
                               int quality ) ;
#line 528
extern ASImage *slice_asimage2(ASVisual *asv , ASImage *src , int slice_x_start ,
                               int slice_x_end , int slice_y_start , int slice_y_end ,
                               int to_width , int to_height , int scaled , ASAltImFormats out_format ,
                               unsigned int compression_out , int quality ) ;
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 522 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../transform.h"
extern ASImage *create_asimage_from_vector(ASVisual *asv , double *vector , int width ,
                                           int height , ASVectorPalette *palette ,
                                           ASAltImFormats out_format , unsigned int compression ,
                                           int quality ) ;
#line 182 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../export.h"
extern int ASImage2file(ASImage *im , char const   *dir , char const   *file , ASImageFileTypes type ,
                        ASImageExportParams *params ) ;
#line 187
extern int ASImage2PNGBuff(ASImage *im , CARD8 **buffer , int *size , ASImageExportParams *params ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asvector.c"
CARD16 chan_alpha[9]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asvector.c"
  {      (CARD16 )65535,      (CARD16 )65535,      (CARD16 )65535,      (CARD16 )65535, 
        (CARD16 )65535,      (CARD16 )65535,      (CARD16 )65535,      (CARD16 )65535, 
        (CARD16 )65535};
#line 31 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asvector.c"
CARD16 chan_red[9]  = 
#line 31
  {      (CARD16 )0,      (CARD16 )28672,      (CARD16 )0,      (CARD16 )0, 
        (CARD16 )0,      (CARD16 )65535,      (CARD16 )65535,      (CARD16 )28672, 
        (CARD16 )65535};
#line 33 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asvector.c"
CARD16 chan_green[9]  = 
#line 33
  {      (CARD16 )0,      (CARD16 )0,      (CARD16 )0,      (CARD16 )65535, 
        (CARD16 )65535,      (CARD16 )65535,      (CARD16 )0,      (CARD16 )0, 
        (CARD16 )65535};
#line 35 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asvector.c"
CARD16 chan_blue[9]  = 
#line 35
  {      (CARD16 )0,      (CARD16 )28672,      (CARD16 )65535,      (CARD16 )65535, 
        (CARD16 )0,      (CARD16 )0,      (CARD16 )0,      (CARD16 )0, 
        (CARD16 )65535};
#line 48 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asvector.c"
double points[9]  = 
#line 48
  {      (double )0,      (double )1,      (double )2,      (double )3, 
        (double )4,      (double )5,      (double )6,      (double )7, 
        (double )8};
#line 1534 "/usr/include/X11/Xlib.h"
extern int (*XSynchronize(Display * , int  ))(Display * ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 387 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/../transform.h"
extern ASImage *make_gradient(struct ASVisual *asv , struct ASGradient *grad , int width ,
                              int height , ASFlagType filter , ASAltImFormats out_format ,
                              unsigned int compression_out , int quality ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asgrad.c"
ARGB32 default_colors[11]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asgrad.c"
  {      4278190080U,      4285530224U,      4278190335U,      4278255615U, 
        4278255360U,      4294967040U,      4285530112U,      4294901760U, 
        4286611616U,      4292927743U,      4288717055U};
#line 43 "/home/june/repo/benchmarks/collector/temp/afterstep-2.2.12/libAfterImage/apps/asgrad.c"
double default_offsets[11]  = 
#line 43
  {      (double )0,      0.1,      0.15,      0.20, 
        0.35,      0.45,      0.55,      0.50, 
        0.65,      0.8,      1.0};
