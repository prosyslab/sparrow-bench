/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
struct _ArtDRect;
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
typedef struct _ArtDRect ArtDRect;
#line 30 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
struct _ArtDRect {
   double x0 ;
   double y0 ;
   double x1 ;
   double y1 ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_point.h"
struct _ArtPoint;
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_point.h"
typedef struct _ArtPoint ArtPoint;
#line 29 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_point.h"
struct _ArtPoint {
   double x ;
   double y ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
struct _ArtSVP;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
typedef struct _ArtSVP ArtSVP;
#line 38
struct _ArtSVPSeg;
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
typedef struct _ArtSVPSeg ArtSVPSeg;
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
struct _ArtSVPSeg {
   int n_points ;
   int dir ;
   ArtDRect bbox ;
   ArtPoint *points ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
struct _ArtSVP {
   int n_segs ;
   ArtSVPSeg segs[1] ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pathcode.h"
enum __anonenum_ArtPathcode_1 {
    ART_MOVETO = 0,
    ART_MOVETO_OPEN = 1,
    ART_CURVETO = 2,
    ART_LINETO = 3,
    ART_END = 4
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pathcode.h"
typedef enum __anonenum_ArtPathcode_1 ArtPathcode;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.h"
struct _ArtVpath;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.h"
typedef struct _ArtVpath ArtVpath;
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.h"
struct _ArtVpath {
   ArtPathcode code ;
   double x ;
   double y ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.h"
enum __anonenum_ArtPathStrokeJoinType_2 {
    ART_PATH_STROKE_JOIN_MITER = 0,
    ART_PATH_STROKE_JOIN_ROUND = 1,
    ART_PATH_STROKE_JOIN_BEVEL = 2
} ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.h"
typedef enum __anonenum_ArtPathStrokeJoinType_2 ArtPathStrokeJoinType;
#line 43
enum __anonenum_ArtPathStrokeCapType_3 {
    ART_PATH_STROKE_CAP_BUTT = 0,
    ART_PATH_STROKE_CAP_ROUND = 1,
    ART_PATH_STROKE_CAP_SQUARE = 2
} ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.h"
typedef enum __anonenum_ArtPathStrokeCapType_3 ArtPathStrokeCapType;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.h"
enum __anonenum_ArtWindRule_26 {
    ART_WIND_RULE_NONZERO = 0,
    ART_WIND_RULE_INTERSECT = 1,
    ART_WIND_RULE_ODDEVEN = 2,
    ART_WIND_RULE_POSITIVE = 3
} ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.h"
typedef enum __anonenum_ArtWindRule_26 ArtWindRule;
#line 45
struct _ArtSvpWriter;
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.h"
typedef struct _ArtSvpWriter ArtSvpWriter;
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.h"
struct _ArtSvpWriter {
   int (*add_segment)(ArtSvpWriter *self , int wind_left , int delta_wind , double x ,
                      double y ) ;
   void (*add_point)(ArtSvpWriter *self , int seg_id , double x , double y ) ;
   void (*close_segment)(ArtSvpWriter *self , int seg_id ) ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_config.h"
typedef unsigned int art_u32;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.h"
typedef art_u32 ArtUtaBbox;
#line 36
struct _ArtUta;
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.h"
typedef struct _ArtUta ArtUta;
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.h"
struct _ArtUta {
   int x0 ;
   int y0 ;
   int width ;
   int height ;
   ArtUtaBbox *utiles ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
struct _ArtIRect;
#line 28 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
typedef struct _ArtIRect ArtIRect;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
struct _ArtIRect {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_bpath.h"
struct _ArtBpath;
#line 39 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_bpath.h"
typedef struct _ArtBpath ArtBpath;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_bpath.h"
struct _ArtBpath {
   ArtPathcode code ;
   double x1 ;
   double y1 ;
   double x2 ;
   double y2 ;
   double x3 ;
   double y3 ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.h"
struct _ArtSVPRenderAAStep;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.h"
typedef struct _ArtSVPRenderAAStep ArtSVPRenderAAStep;
#line 36
struct _ArtSVPRenderAAIter;
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.h"
typedef struct _ArtSVPRenderAAIter ArtSVPRenderAAIter;
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.h"
struct _ArtSVPRenderAAStep {
   int x ;
   int delta ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
typedef double artfloat;
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
struct _ArtSVPRenderAAIter {
   ArtSVP const   *svp ;
   int x0 ;
   int x1 ;
   int y ;
   int seg_ix ;
   int *active_segs ;
   int n_active_segs ;
   int *cursor ;
   artfloat *seg_x ;
   artfloat *seg_dx ;
   ArtSVPRenderAAStep *steps ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_filterlevel.h"
enum __anonenum_ArtFilterLevel_1 {
    ART_FILTER_NEAREST = 0,
    ART_FILTER_TILES = 1,
    ART_FILTER_BILINEAR = 2,
    ART_FILTER_HYPER = 3
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_filterlevel.h"
typedef enum __anonenum_ArtFilterLevel_1 ArtFilterLevel;
#line 8 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_config.h"
typedef unsigned char art_u8;
#line 9 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_config.h"
typedef unsigned short art_u16;
#line 58 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.h"
typedef int art_boolean;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_alphagamma.h"
struct _ArtAlphaGamma;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_alphagamma.h"
typedef struct _ArtAlphaGamma ArtAlphaGamma;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_alphagamma.h"
struct _ArtAlphaGamma {
   double gamma ;
   int invtable_size ;
   int table[256] ;
   art_u8 invtable[1] ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef art_u16 ArtPixMaxDepth;
#line 58
struct _ArtRender;
#line 58 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef struct _ArtRender ArtRender;
#line 59
struct _ArtRenderCallback;
#line 59 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef struct _ArtRenderCallback ArtRenderCallback;
#line 60
struct _ArtRenderMaskRun;
#line 60 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef struct _ArtRenderMaskRun ArtRenderMaskRun;
#line 61
struct _ArtImageSource;
#line 61 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef struct _ArtImageSource ArtImageSource;
#line 64
enum __anonenum_ArtAlphaType_22 {
    ART_ALPHA_NONE = 0,
    ART_ALPHA_SEPARATE = 1,
    ART_ALPHA_PREMUL = 2
} ;
#line 64 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef enum __anonenum_ArtAlphaType_22 ArtAlphaType;
#line 70
enum __anonenum_ArtCompositingMode_23 {
    ART_COMPOSITE_NORMAL = 0,
    ART_COMPOSITE_MULTIPLY = 1,
    ART_COMPOSITE_CUSTOM = 2
} ;
#line 70 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef enum __anonenum_ArtCompositingMode_23 ArtCompositingMode;
#line 77
enum __anonenum_ArtImageSourceFlags_24 {
    ART_IMAGE_SOURCE_CAN_CLEAR = 1,
    ART_IMAGE_SOURCE_CAN_COMPOSITE = 2
} ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef enum __anonenum_ArtImageSourceFlags_24 ArtImageSourceFlags;
#line 82 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
struct _ArtRenderMaskRun {
   int x ;
   int alpha ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
struct _ArtRenderCallback {
   void (*render)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest , int y ) ;
   void (*done)(ArtRenderCallback *self , ArtRender *render ) ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
struct _ArtImageSource {
   ArtRenderCallback super ;
   void (*negotiate)(ArtImageSource *self , ArtRender *render , ArtImageSourceFlags *p_flags ,
                     int *p_buf_depth , ArtAlphaType *p_alpha_type ) ;
};
#line 109 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
struct _ArtRender {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   art_u8 *pixels ;
   int rowstride ;
   int n_chan ;
   int depth ;
   ArtAlphaType alpha_type ;
   art_boolean clear ;
   ArtPixMaxDepth clear_color[17] ;
   art_u32 opacity ;
   ArtCompositingMode compositing_mode ;
   ArtAlphaGamma *alphagamma ;
   art_u8 *alpha_buf ;
   int buf_depth ;
   ArtAlphaType buf_alpha ;
   art_u8 *image_buf ;
   int n_run ;
   ArtRenderMaskRun *run ;
   int n_span ;
   int *span_x ;
   art_boolean need_span ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
struct _ArtGradientLinear;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
typedef struct _ArtGradientLinear ArtGradientLinear;
#line 42
struct _ArtGradientRadial;
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
typedef struct _ArtGradientRadial ArtGradientRadial;
#line 43
struct _ArtGradientStop;
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
typedef struct _ArtGradientStop ArtGradientStop;
#line 45
enum __anonenum_ArtGradientSpread_25 {
    ART_GRADIENT_PAD = 0,
    ART_GRADIENT_REFLECT = 1,
    ART_GRADIENT_REPEAT = 2
} ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
typedef enum __anonenum_ArtGradientSpread_25 ArtGradientSpread;
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
struct _ArtGradientLinear {
   double a ;
   double b ;
   double c ;
   ArtGradientSpread spread ;
   int n_stops ;
   ArtGradientStop *stops ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
struct _ArtGradientRadial {
   double affine[6] ;
   double fx ;
   double fy ;
   int n_stops ;
   ArtGradientStop *stops ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
struct _ArtGradientStop {
   double offset ;
   ArtPixMaxDepth color[17] ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
struct _ArtImageSourceGradLin;
#line 63 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
typedef struct _ArtImageSourceGradLin ArtImageSourceGradLin;
#line 64
struct _ArtImageSourceGradRad;
#line 64 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
typedef struct _ArtImageSourceGradRad ArtImageSourceGradRad;
#line 67 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
struct _ArtImageSourceGradLin {
   ArtImageSource super ;
   ArtGradientLinear gradient ;
   ArtGradientStop stops[1] ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
struct _ArtImageSourceGradRad {
   ArtImageSource super ;
   ArtGradientRadial gradient ;
   double a ;
   ArtGradientStop stops[1] ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
struct _ArtRgbSVPData;
#line 29 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
typedef struct _ArtRgbSVPData ArtRgbSVPData;
#line 30
struct _ArtRgbSVPAlphaData;
#line 30 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
typedef struct _ArtRgbSVPAlphaData ArtRgbSVPAlphaData;
#line 32 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
struct _ArtRgbSVPData {
   art_u32 rgbtab[256] ;
   art_u8 *buf ;
   int rowstride ;
   int x0 ;
   int x1 ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
struct _ArtRgbSVPAlphaData {
   int alphatab[256] ;
   art_u8 r ;
   art_u8 g ;
   art_u8 b ;
   art_u8 alpha ;
   art_u8 *buf ;
   int rowstride ;
   int x0 ;
   int x1 ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
struct _ArtVpathSVPEnd;
#line 31 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
typedef struct _ArtVpathSVPEnd ArtVpathSVPEnd;
#line 33 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
struct _ArtVpathSVPEnd {
   int seg_num ;
   int which ;
   double x ;
   double y ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.h"
struct _ArtVpathDash;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.h"
typedef struct _ArtVpathDash ArtVpathDash;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.h"
struct _ArtVpathDash {
   double offset ;
   int n_dash ;
   double *dash ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.h"
struct _ArtPixBuf;
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.h"
typedef struct _ArtPixBuf ArtPixBuf;
#line 42
enum __anonenum_ArtPixFormat_21 {
    ART_PIX_RGB = 0
} ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.h"
typedef enum __anonenum_ArtPixFormat_21 ArtPixFormat;
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.h"
struct _ArtPixBuf {
   ArtPixFormat format ;
   int n_channels ;
   int has_alpha ;
   int bits_per_sample ;
   art_u8 *pixels ;
   int width ;
   int height ;
   int rowstride ;
   void *destroy_data ;
   void (*destroy)(void *func_data , void *data ) ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
struct _ArtMaskSource;
#line 62 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
typedef struct _ArtMaskSource ArtMaskSource;
#line 100 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
struct _ArtMaskSource {
   ArtRenderCallback super ;
   int (*can_drive)(ArtMaskSource *self , ArtRender *render ) ;
   void (*invoke_driver)(ArtMaskSource *self , ArtRender *render ) ;
   void (*prepare)(ArtMaskSource *self , ArtRender *render , art_boolean first ) ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderPriv;
#line 28 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
typedef struct _ArtRenderPriv ArtRenderPriv;
#line 30 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderPriv {
   ArtRender super ;
   ArtImageSource *image_source ;
   int n_mask_source ;
   ArtMaskSource **mask_source ;
   int n_callbacks ;
   ArtRenderCallback **callbacks ;
};
#line 1164
struct _ArtImageSourceSolid;
#line 1164 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
typedef struct _ArtImageSourceSolid ArtImageSourceSolid;
#line 1166 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtImageSourceSolid {
   ArtImageSource super ;
   ArtPixMaxDepth color[16] ;
   art_u32 *rgbtab ;
   art_boolean init ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
struct _ArtPriQ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
typedef struct _ArtPriQ ArtPriQ;
#line 48
struct _ArtPriPoint;
#line 48 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
typedef struct _ArtPriPoint ArtPriPoint;
#line 50 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
struct _ArtPriQ {
   int n_items ;
   int n_items_max ;
   ArtPriPoint **items ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
struct _ArtPriPoint {
   double x ;
   double y ;
   void *user_data ;
};
#line 301
struct _ArtSvpWriterRewind;
#line 301 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
typedef struct _ArtSvpWriterRewind ArtSvpWriterRewind;
#line 306 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
struct _ArtSvpWriterRewind {
   ArtSvpWriter super ;
   ArtWindRule rule ;
   ArtSVP *svp ;
   int n_segs_max ;
   int *n_points_max ;
};
#line 471
struct _ArtActiveSeg;
#line 471 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
typedef struct _ArtActiveSeg ArtActiveSeg;
#line 491 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
struct _ArtActiveSeg {
   int flags ;
   int wind_left ;
   int delta_wind ;
   ArtActiveSeg *left ;
   ArtActiveSeg *right ;
   ArtSVPSeg const   *in_seg ;
   int in_curs ;
   double x[2] ;
   double y0 ;
   double y1 ;
   double a ;
   double b ;
   double c ;
   int n_stack ;
   int n_stack_max ;
   ArtPoint *stack ;
   ArtActiveSeg *horiz_left ;
   ArtActiveSeg *horiz_right ;
   double horiz_x ;
   int horiz_delta_wind ;
   int seg_id ;
};
#line 516
struct _ArtIntersectCtx;
#line 516 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
typedef struct _ArtIntersectCtx ArtIntersectCtx;
#line 518 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
struct _ArtIntersectCtx {
   ArtSVP const   *in ;
   ArtSvpWriter *out ;
   ArtPriQ *pq ;
   ArtActiveSeg *active_head ;
   double y ;
   ArtActiveSeg *horiz_first ;
   ArtActiveSeg *horiz_last ;
   int in_curs ;
};
#line 653
enum __anonenum_ArtBreakFlags_24 {
    ART_BREAK_LEFT = 1,
    ART_BREAK_RIGHT = 2
} ;
#line 653 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
typedef enum __anonenum_ArtBreakFlags_24 ArtBreakFlags;
#line 28 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
struct _ArtMaskSourceSVP;
#line 28 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
typedef struct _ArtMaskSourceSVP ArtMaskSourceSVP;
#line 30 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
struct _ArtMaskSourceSVP {
   ArtMaskSource super ;
   ArtRender *render ;
   ArtSVP const   *svp ;
   art_u8 *dest_ptr ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
struct _ArtMaskSourceMask;
#line 31 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
typedef struct _ArtMaskSourceMask ArtMaskSourceMask;
#line 33 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
struct _ArtMaskSourceMask {
   ArtMaskSource super ;
   ArtRender *render ;
   art_boolean first ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   art_u8 const   *mask_buf ;
   int rowstride ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
struct _ArtGraySVPData;
#line 31 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
typedef struct _ArtGraySVPData ArtGraySVPData;
#line 33 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
struct _ArtGraySVPData {
   art_u8 *buf ;
   int rowstride ;
   int x0 ;
   int x1 ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
void art_svp_free(ArtSVP *svp ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.h"
void art_vpath_add_point(ArtVpath **p_vpath , int *pn_points , int *pn_points_max ,
                         ArtPathcode code , double x , double y ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.h"
ArtSVP *art_svp_vpath_stroke(ArtVpath *vpath , ArtPathStrokeJoinType join , ArtPathStrokeCapType cap ,
                             double line_width , double miter_limit , double flatness ) ;
#line 58
ArtVpath *art_svp_vpath_stroke_raw(ArtVpath *vpath , ArtPathStrokeJoinType join ,
                                   ArtPathStrokeCapType cap , double line_width ,
                                   double miter_limit , double flatness ) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 178
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.h"
void *art_alloc(size_t size ) ;
#line 41
void art_free(void *ptr ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.h"
ArtSvpWriter *art_svp_writer_rewind_new(ArtWindRule rule ) ;
#line 57
ArtSVP *art_svp_writer_rewind_reap(ArtSvpWriter *self ) ;
#line 63
void art_svp_intersector(ArtSVP const   *in , ArtSvpWriter *out ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath.h"
ArtSVP *art_svp_from_vpath(ArtVpath *vpath ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void art_svp_vpath_stroke_arc(ArtVpath **p_vpath , int *pn , int *pn_max ,
                                     double xc , double yc , double x0 , double y0___0 ,
                                     double x1 , double y1___0 , double radius , double flatness ) 
{ 
  double theta ;
  double th_0 ;
  double th_1 ;
  int n_pts ;
  int i ;
  double aradius ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 64
  aradius = fabs(radius);
#line 65
  tmp = sqrt(flatness / aradius);
#line 65
  theta = ((double )2 * 1.41421356237309504880) * tmp;
#line 66
  th_0 = atan2(y0___0, x0);
#line 67
  th_1 = atan2(y1___0, x1);
  }
#line 68
  if (radius > (double )0) {
#line 71
    if (th_0 < th_1) {
#line 71
      th_0 += 3.14159265358979323846 * (double )2;
    }
    {
#line 72
    tmp___0 = ceil((th_0 - th_1) / theta);
#line 72
    n_pts = (int )tmp___0;
    }
  } else {
#line 77
    if (th_1 < th_0) {
#line 77
      th_1 += 3.14159265358979323846 * (double )2;
    }
    {
#line 78
    tmp___1 = ceil((th_1 - th_0) / theta);
#line 78
    n_pts = (int )tmp___1;
    }
  }
  {
#line 83
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + x0, yc + y0___0);
#line 85
  i = 1;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < n_pts)) {
#line 85
      goto while_break;
    }
    {
#line 87
    theta = th_0 + ((th_1 - th_0) * (double )i) / (double )n_pts;
#line 88
    tmp___2 = sin(theta);
#line 88
    tmp___3 = cos(theta);
#line 88
    art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + tmp___3 * aradius,
                        yc + tmp___2 * aradius);
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + x1, yc + y1___0);
  }
#line 100
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void render_seg(ArtVpath **p_forw , int *pn_forw , int *pn_forw_max , ArtVpath **p_rev ,
                       int *pn_rev , int *pn_rev_max , ArtVpath *vpath , int i0 ,
                       int i1 , int i2 , ArtPathStrokeJoinType join , double line_width ,
                       double miter_limit , double flatness ) 
{ 
  double dx0 ;
  double dy0 ;
  double dx1 ;
  double dy1 ;
  double dlx0 ;
  double dly0 ;
  double dlx1 ;
  double dly1 ;
  double dmx ;
  double dmy ;
  double dmr2 ;
  double scale ;
  double cross ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 136
  dx0 = (vpath + i1)->x - (vpath + i0)->x;
#line 137
  dy0 = (vpath + i1)->y - (vpath + i0)->y;
#line 139
  dx1 = (vpath + i2)->x - (vpath + i1)->x;
#line 140
  dy1 = (vpath + i2)->y - (vpath + i1)->y;
#line 144
  tmp = sqrt(dx0 * dx0 + dy0 * dy0);
#line 144
  scale = line_width / tmp;
#line 145
  dlx0 = dy0 * scale;
#line 146
  dly0 = - dx0 * scale;
#line 150
  tmp___0 = sqrt(dx1 * dx1 + dy1 * dy1);
#line 150
  scale = line_width / tmp___0;
#line 151
  dlx1 = dy1 * scale;
#line 152
  dly1 = - dx1 * scale;
#line 171
  cross = dx1 * dy0 - dx0 * dy1;
#line 173
  dmx = (dlx0 + dlx1) * 0.5;
#line 174
  dmy = (dly0 + dly1) * 0.5;
#line 175
  dmr2 = dmx * dmx + dmy * dmy;
  }
#line 177
  if ((unsigned int )join == 0U) {
#line 177
    if ((dmr2 * miter_limit) * miter_limit < line_width * line_width) {
#line 179
      join = (ArtPathStrokeJoinType )2;
    }
  }
#line 186
  if (dmr2 > 1e-12) {
#line 188
    scale = (line_width * line_width) / dmr2;
#line 189
    dmx *= scale;
#line 190
    dmy *= scale;
  }
#line 193
  if (cross * cross < 1e-12) {
#line 193
    if (dx0 * dx1 + dy0 * dy1 >= (double )0) {
      {
#line 199
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 201
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
      }
    } else {
#line 193
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 204
  if (cross > (double )0) {
#line 211
    if (dmr2 > 1e-12) {
#line 211
      if ((dx0 + dmx) * dx0 + (dy0 + dmy) * dy0 > (double )0) {
#line 211
        if ((dx1 - dmx) * dx1 + (dy1 - dmy) * dy1 > (double )0) {
          {
#line 230
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dmx,
                              (vpath + i1)->y + dmy);
          }
        } else {
          {
#line 236
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                              (vpath + i1)->y + dly0);
#line 238
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                              (vpath + i1)->y);
#line 240
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                              (vpath + i1)->y + dly1);
          }
        }
      } else {
        {
#line 236
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                            (vpath + i1)->y + dly0);
#line 238
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                            (vpath + i1)->y);
#line 240
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                            (vpath + i1)->y + dly1);
        }
      }
    } else {
      {
#line 236
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
#line 238
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                          (vpath + i1)->y);
#line 240
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                          (vpath + i1)->y + dly1);
      }
    }
#line 244
    if ((unsigned int )join == 2U) {
      {
#line 247
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 249
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                          (vpath + i1)->y - dly1);
      }
    } else
#line 252
    if ((unsigned int )join == 0U) {
      {
#line 254
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dmx,
                          (vpath + i1)->y - dmy);
      }
    } else
#line 257
    if ((unsigned int )join == 1U) {
      {
#line 258
      art_svp_vpath_stroke_arc(p_forw, pn_forw, pn_forw_max, (vpath + i1)->x, (vpath + i1)->y,
                               - dlx0, - dly0, - dlx1, - dly1, line_width, flatness);
      }
    }
  } else {
#line 272
    if (dmr2 > 1e-12) {
#line 272
      if ((dx0 - dmx) * dx0 + (dy0 - dmy) * dy0 > (double )0) {
#line 272
        if ((dx1 + dmx) * dx1 + (dy1 + dmy) * dy1 > (double )0) {
          {
#line 291
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dmx,
                              (vpath + i1)->y - dmy);
          }
        } else {
          {
#line 297
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                              (vpath + i1)->y - dly0);
#line 299
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                              (vpath + i1)->y);
#line 301
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                              (vpath + i1)->y - dly1);
          }
        }
      } else {
        {
#line 297
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                            (vpath + i1)->y - dly0);
#line 299
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                            (vpath + i1)->y);
#line 301
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                            (vpath + i1)->y - dly1);
        }
      }
    } else {
      {
#line 297
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 299
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                          (vpath + i1)->y);
#line 301
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                          (vpath + i1)->y - dly1);
      }
    }
#line 305
    if ((unsigned int )join == 2U) {
      {
#line 308
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
#line 310
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                          (vpath + i1)->y + dly1);
      }
    } else
#line 313
    if ((unsigned int )join == 0U) {
      {
#line 315
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dmx,
                          (vpath + i1)->y + dmy);
      }
    } else
#line 318
    if ((unsigned int )join == 1U) {
      {
#line 319
      art_svp_vpath_stroke_arc(p_rev, pn_rev, pn_rev_max, (vpath + i1)->x, (vpath + i1)->y,
                               dlx0, dly0, dlx1, dly1, - line_width, flatness);
      }
    }
  }
#line 327
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void render_cap(ArtVpath **p_result , int *pn_result , int *pn_result_max ,
                       ArtVpath *vpath , int i0 , int i1 , ArtPathStrokeCapType cap ,
                       double line_width , double flatness ) 
{ 
  double dx0 ;
  double dy0 ;
  double dlx0 ;
  double dly0 ;
  double scale ;
  int n_pts ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double theta ;
  double c_th ;
  double s_th ;

  {
  {
#line 341
  dx0 = (vpath + i1)->x - (vpath + i0)->x;
#line 342
  dy0 = (vpath + i1)->y - (vpath + i0)->y;
#line 346
  tmp = sqrt(dx0 * dx0 + dy0 * dy0);
#line 346
  scale = line_width / tmp;
#line 347
  dlx0 = dy0 * scale;
#line 348
  dly0 = - dx0 * scale;
  }
  {
#line 356
  if ((unsigned int )cap == 0U) {
#line 356
    goto case_0;
  }
#line 362
  if ((unsigned int )cap == 1U) {
#line 362
    goto case_1;
  }
#line 381
  if ((unsigned int )cap == 2U) {
#line 381
    goto case_2;
  }
#line 354
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 357
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                      (vpath + i1)->y - dly0);
#line 359
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                      (vpath + i1)->y + dly0);
  }
#line 361
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 363
  tmp___0 = sqrt(flatness / line_width);
#line 363
  tmp___1 = ceil(3.14159265358979323846 / ((2.0 * 1.41421356237309504880) * tmp___0));
#line 363
  n_pts = (int )tmp___1;
#line 364
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                      (vpath + i1)->y - dly0);
#line 366
  i = 1;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (i < n_pts)) {
#line 366
      goto while_break;
    }
    {
#line 370
    theta = (3.14159265358979323846 * (double )i) / (double )n_pts;
#line 371
    c_th = cos(theta);
#line 372
    s_th = sin(theta);
#line 373
    art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x - dlx0 * c_th) - dly0 * s_th,
                        ((vpath + i1)->y - dly0 * c_th) + dlx0 * s_th);
#line 366
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                      (vpath + i1)->y + dly0);
  }
#line 380
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 382
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x - dlx0) - dly0,
                      ((vpath + i1)->y - dly0) + dlx0);
#line 386
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x + dlx0) - dly0,
                      ((vpath + i1)->y + dly0) + dlx0);
  }
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
ArtVpath *art_svp_vpath_stroke_raw(ArtVpath *vpath , ArtPathStrokeJoinType join ,
                                   ArtPathStrokeCapType cap , double line_width ,
                                   double miter_limit , double flatness ) 
{ 
  int begin_idx ;
  int end_idx ;
  int i ;
  ArtVpath *forw ;
  ArtVpath *rev ;
  int n_forw ;
  int n_rev ;
  int n_forw_max ;
  int n_rev_max ;
  ArtVpath *result ;
  int n_result ;
  int n_result_max ;
  double half_lw ;
  int closed ;
  int last ;
  int this ;
  int next ;
  int second ;
  double dx ;
  double dy ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int j ;
  int j___0 ;

  {
  {
#line 424
  half_lw = 0.5 * line_width;
#line 429
  n_forw_max = 16;
#line 430
  tmp = art_alloc((unsigned long )n_forw_max * sizeof(ArtVpath ));
#line 430
  forw = (ArtVpath *)tmp;
#line 432
  n_rev_max = 16;
#line 433
  tmp___0 = art_alloc((unsigned long )n_rev_max * sizeof(ArtVpath ));
#line 433
  rev = (ArtVpath *)tmp___0;
#line 435
  n_result = 0;
#line 436
  n_result_max = 16;
#line 437
  tmp___1 = art_alloc((unsigned long )n_result_max * sizeof(ArtVpath ));
#line 437
  result = (ArtVpath *)tmp___1;
#line 439
  begin_idx = 0;
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! ((unsigned int )(vpath + begin_idx)->code != 4U)) {
#line 439
      goto while_break;
    }
#line 441
    n_forw = 0;
#line 442
    n_rev = 0;
#line 444
    closed = (unsigned int )(vpath + begin_idx)->code == 0U;
#line 454
    this = begin_idx;
#line 456
    i = this + 1;
    {
#line 456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 456
      if (! ((unsigned int )(vpath + i)->code == 3U)) {
#line 456
        goto while_break___0;
      }
#line 458
      dx = (vpath + i)->x - (vpath + this)->x;
#line 459
      dy = (vpath + i)->y - (vpath + this)->y;
#line 460
      if (dx * dx + dy * dy > 1e-12) {
#line 461
        goto while_break___0;
      }
#line 456
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 463
    next = i;
#line 464
    second = next;
    {
#line 467
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 467
      if (! ((unsigned int )(vpath + next)->code == 3U)) {
#line 467
        goto while_break___1;
      }
#line 469
      last = this;
#line 470
      this = next;
#line 472
      i = this + 1;
      {
#line 472
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 472
        if (! ((unsigned int )(vpath + i)->code == 3U)) {
#line 472
          goto while_break___2;
        }
#line 474
        dx = (vpath + i)->x - (vpath + this)->x;
#line 475
        dy = (vpath + i)->y - (vpath + this)->y;
#line 476
        if (dx * dx + dy * dy > 1e-12) {
#line 477
          goto while_break___2;
        }
#line 472
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 479
      next = i;
#line 480
      if ((unsigned int )(vpath + next)->code != 3U) {
#line 486
        if (closed) {
#line 486
          if ((vpath + this)->x == (vpath + begin_idx)->x) {
#line 486
            if ((vpath + this)->y == (vpath + begin_idx)->y) {
              {
#line 493
              render_seg(& forw, & n_forw, & n_forw_max, & rev, & n_rev, & n_rev_max,
                         vpath, last, this, second, join, half_lw, miter_limit, flatness);
#line 502
              art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )0,
                                  (forw + (n_forw - 1))->x, (forw + (n_forw - 1))->y);
#line 505
              j = 0;
              }
              {
#line 505
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 505
                if (! (j < n_forw)) {
#line 505
                  goto while_break___3;
                }
                {
#line 506
                art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )3,
                                    (forw + j)->x, (forw + j)->y);
#line 505
                j ++;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 511
              art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )0,
                                  (rev + 0)->x, (rev + 0)->y);
#line 514
              j = n_rev - 1;
              }
              {
#line 514
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 514
                if (! (j >= 0)) {
#line 514
                  goto while_break___4;
                }
                {
#line 515
                art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )3,
                                    (rev + j)->x, (rev + j)->y);
#line 514
                j --;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 486
              goto _L___0;
            }
          } else {
#line 486
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 526
          render_cap(& forw, & n_forw, & n_forw_max, vpath, last, this, cap, half_lw,
                     flatness);
#line 529
          art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )0,
                              (forw + 0)->x, (forw + 0)->y);
#line 532
          j___0 = 1;
          }
          {
#line 532
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 532
            if (! (j___0 < n_forw)) {
#line 532
              goto while_break___5;
            }
            {
#line 533
            art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )3,
                                (forw + j___0)->x, (forw + j___0)->y);
#line 532
            j___0 ++;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 536
          j___0 = n_rev - 1;
          {
#line 536
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 536
            if (! (j___0 >= 0)) {
#line 536
              goto while_break___6;
            }
            {
#line 537
            art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )3,
                                (rev + j___0)->x, (rev + j___0)->y);
#line 536
            j___0 --;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 540
          render_cap(& result, & n_result, & n_result_max, vpath, second, begin_idx,
                     cap, half_lw, flatness);
#line 543
          art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )3,
                              (forw + 0)->x, (forw + 0)->y);
          }
        }
      } else {
        {
#line 549
        render_seg(& forw, & n_forw, & n_forw_max, & rev, & n_rev, & n_rev_max, vpath,
                   last, this, next, join, half_lw, miter_limit, flatness);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 554
    end_idx = next;
#line 439
    begin_idx = end_idx;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 557
  art_free((void *)forw);
#line 558
  art_free((void *)rev);
#line 562
  art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )4, (double )0,
                      (double )0);
  }
#line 563
  return (result);
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
ArtSVP *art_svp_vpath_stroke(ArtVpath *vpath , ArtPathStrokeJoinType join , ArtPathStrokeCapType cap ,
                             double line_width , double miter_limit , double flatness ) 
{ 
  ArtVpath *vpath_stroke ;
  ArtSVP *svp ;
  ArtSVP *svp2 ;
  ArtSvpWriter *swr ;

  {
  {
#line 687
  vpath_stroke = art_svp_vpath_stroke_raw(vpath, join, cap, line_width, miter_limit,
                                          flatness);
#line 692
  svp = art_svp_from_vpath(vpath_stroke);
#line 696
  art_free((void *)vpath_stroke);
#line 698
  swr = art_svp_writer_rewind_new((ArtWindRule )0);
#line 699
  art_svp_intersector((ArtSVP const   *)svp, swr);
#line 701
  svp2 = art_svp_writer_rewind_reap(swr);
#line 705
  art_svp_free(svp);
  }
#line 706
  return (svp2);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_vpath.h"
ArtUta *art_uta_from_vpath(ArtVpath const   *vec ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect_uta.h"
ArtIRect *art_rect_list_from_uta(ArtUta *uta , int max_width , int max_height , int *p_nrects ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.h"
unsigned int const   libart_major_version ;
#line 19
unsigned int const   libart_minor_version ;
#line 19
unsigned int const   libart_micro_version ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testuta.c"
static void print_uta_ps(ArtUta *uta ) 
{ 
  int x ;
  int y ;
  int x0 ;
  int y0___0 ;
  int x1 ;
  int y1___0 ;
  int width ;
  ArtUtaBbox ub ;

  {
#line 45
  width = uta->width;
#line 48
  y = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (y < uta->height)) {
#line 48
      goto while_break;
    }
#line 49
    x = 0;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! (x < width)) {
#line 49
        goto while_break___0;
      }
#line 51
      ub = *(uta->utiles + (y * width + x));
#line 52
      if (ub != 0U) {
        {
#line 54
        x0 = (int )((ArtUtaBbox )((uta->x0 + x) * (1 << 5)) + (ub >> 24));
#line 55
        x1 = (int )((unsigned int )((uta->x0 + x) * (1 << 5)) + ((ub >> 8) & 255U));
#line 56
        y0___0 = (int )((unsigned int )((uta->y0 + y) * (1 << 5)) + ((ub >> 16) & 255U));
#line 57
        y1___0 = (int )((unsigned int )((uta->y0 + y) * (1 << 5)) + (ub & 255U));
#line 58
        printf((char const   */* __restrict  */)"%% tile %d, %d: %d %d %d %d\n", x,
               y, ub >> 24, (ub >> 16) & 255U, (ub >> 8) & 255U, ub & 255U);
#line 64
        printf((char const   */* __restrict  */)"%d %d moveto %d %d lineto %d %d lineto %d %d lineto closepath fill\n",
               50 + x0, 700 - y0___0, 50 + x1, 700 - y0___0, 50 + x1, 700 - y1___0,
               50 + x0, 700 - y1___0);
        }
      }
#line 49
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 48
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testuta.c"
static void print_rbuf_ps(int *rbuf , int width , int height ) 
{ 
  int x ;
  int y ;

  {
#line 76
  y = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (y < height)) {
#line 76
      goto while_break;
    }
#line 77
    x = 0;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! (x < width)) {
#line 77
        goto while_break___0;
      }
#line 78
      if (*(rbuf + (y * width + x)) != 0) {
        {
#line 79
        printf((char const   */* __restrict  */)"%d %d moveto (%d) show\n", x * (1 << 5),
               y * (1 << 5), *(rbuf + (y * width + x)));
        }
      }
#line 77
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 76
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testuta.c"
static void print_ps_vpath(ArtVpath *vpath ) 
{ 
  int i ;

  {
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((unsigned int )(vpath + i)->code != 4U)) {
#line 104
      goto while_break;
    }
    {
#line 108
    if ((unsigned int )(vpath + i)->code == 0U) {
#line 108
      goto case_0;
    }
#line 111
    if ((unsigned int )(vpath + i)->code == 3U) {
#line 111
      goto case_3;
    }
#line 114
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 109
    printf((char const   */* __restrict  */)"%g %g moveto\n", (double )50 + (vpath + i)->x,
           (double )700 - (vpath + i)->y);
    }
#line 110
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 112
    printf((char const   */* __restrict  */)"%g %g lineto\n", (double )50 + (vpath + i)->x,
           (double )700 - (vpath + i)->y);
    }
#line 113
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 115
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  printf((char const   */* __restrict  */)"stroke\n");
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testuta.c"
static ArtVpath *randstar(int n ) 
{ 
  ArtVpath *vec ;
  int i ;
  double r ;
  double th ;
  void *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 128
  tmp = art_alloc((unsigned long )(n + 2) * sizeof(ArtVpath ));
#line 128
  vec = (ArtVpath *)tmp;
#line 129
  i = 0;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < n)) {
#line 129
      goto while_break;
    }
#line 131
    if (i) {
#line 131
      (vec + i)->code = (ArtPathcode )3;
    } else {
#line 131
      (vec + i)->code = (ArtPathcode )0;
    }
    {
#line 132
    tmp___0 = rand();
#line 132
    r = (double )tmp___0 * (250.0 / (double )2147483647);
#line 133
    th = ((double )(i * 2) * 3.14159265358979323846) / (double )n;
#line 134
    tmp___1 = cos(th);
#line 134
    (vec + i)->x = (double )250 + r * tmp___1;
#line 135
    tmp___2 = sin(th);
#line 135
    (vec + i)->y = (double )250 - r * tmp___2;
#line 129
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  (vec + i)->code = (ArtPathcode )3;
#line 138
  (vec + i)->x = (vec + 0)->x;
#line 139
  (vec + i)->y = (vec + 0)->y;
#line 140
  i ++;
#line 141
  (vec + i)->code = (ArtPathcode )4;
#line 142
  (vec + i)->x = (double )0;
#line 143
  (vec + i)->y = (double )0;
#line 144
  return (vec);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testuta.c"
int main(int argc , char **argv ) 
{ 
  ArtUta *uta ;
  int i ;
  int *rbuf ;
  ArtVpath *vec ;
  ArtIRect *rects ;
  int n_rects ;
  int tmp ;

  {
#line 157
  if (argc == 2) {
    {
#line 158
    tmp = atoi((char const   *)*(argv + 1));
#line 158
    srand((unsigned int )tmp);
    }
  }
  {
#line 161
  printf((char const   */* __restrict  */)"%%!PS-Adobe\n");
#line 162
  printf((char const   */* __restrict  */)"%% libart version: %d.%d.%d\n", libart_major_version,
         libart_minor_version, libart_micro_version);
#line 164
  printf((char const   */* __restrict  */)"/Helvetica findfont 12 scalefont setfont\n");
#line 165
  printf((char const   */* __restrict  */)"0.5 setlinewidth\n");
#line 167
  printf((char const   */* __restrict  */)"0.5 setgray\n");
#line 168
  i = 0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < 500)) {
#line 168
      goto while_break;
    }
    {
#line 170
    printf((char const   */* __restrict  */)"%d %d moveto %d %d lineto stroke\n",
           50, 700 - i, 550, 700 - i);
#line 172
    printf((char const   */* __restrict  */)"%d %d moveto %d %d lineto stroke\n",
           50 + i, 700, 50 + i, 200);
#line 168
    i += 1 << 5;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  printf((char const   */* __restrict  */)"/a {\n");
#line 179
  vec = randstar(50);
#line 180
  print_ps_vpath(vec);
#line 181
  uta = art_uta_from_vpath((ArtVpath const   *)vec);
#line 188
  rbuf = (int *)((void *)0);
#line 197
  printf((char const   */* __restrict  */)"} def 1 0.5 0.5 setrgbcolor\n");
#line 199
  print_uta_ps(uta);
#line 201
  printf((char const   */* __restrict  */)"0 0 0.5 setrgbcolor\n");
  }
#line 203
  if (rbuf) {
    {
#line 204
    print_rbuf_ps(rbuf, 500 >> 5, 500 >> 5);
    }
  }
  {
#line 206
  printf((char const   */* __restrict  */)"0 setgray a\n");
#line 208
  rects = art_rect_list_from_uta(uta, 256, 64, & n_rects);
#line 210
  printf((char const   */* __restrict  */)"%% %d rectangles:\n0 0 1 setrgbcolor\n",
         n_rects);
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i < n_rects)) {
#line 212
      goto while_break___0;
    }
    {
#line 213
    printf((char const   */* __restrict  */)"%d %d moveto %d %d lineto %d %d lineto %d %d lineto closepath stroke\n",
           50 + (rects + i)->x0, 700 - (rects + i)->y0, 50 + (rects + i)->x1, 700 - (rects + i)->y0,
           50 + (rects + i)->x1, 700 - (rects + i)->y1, 50 + (rects + i)->x0, 700 - (rects + i)->y1);
#line 212
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 219
  printf((char const   */* __restrict  */)"showpage\n");
  }
#line 232
  return (0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.h"
void *art_realloc(void *ptr , size_t size ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_bpath.h"
ArtPoint *art_bezier_to_vec(double x0 , double y0___0 , double x1 , double y1___0 ,
                            double x2 , double y2 , double x3 , double y3 , ArtPoint *p ,
                            int level ) ;
#line 42
ArtVpath *art_bez_path_to_vec(ArtBpath const   *bez , double flatness ) ;
#line 162 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) hypot)(double __x ,
                                                                               double __y ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_bpath.c"
ArtPoint *art_bezier_to_vec(double x0 , double y0___0 , double x1 , double y1___0 ,
                            double x2 , double y2 , double x3 , double y3 , ArtPoint *p ,
                            int level ) 
{ 
  double x_m ;
  double y_m ;
  double xa1 ;
  double ya1 ;
  double xa2 ;
  double ya2 ;
  double xb1 ;
  double yb1 ;
  double xb2 ;
  double yb2 ;

  {
#line 49
  if (level == 1) {
#line 50
    x_m = ((x0 + (double )3 * (x1 + x2)) + x3) * 0.125;
#line 51
    y_m = ((y0___0 + (double )3 * (y1___0 + y2)) + y3) * 0.125;
#line 52
    p->x = x_m;
#line 53
    p->y = y_m;
#line 54
    p ++;
#line 55
    p->x = x3;
#line 56
    p->y = y3;
#line 57
    p ++;
  } else {
    {
#line 67
    xa1 = (x0 + x1) * 0.5;
#line 68
    ya1 = (y0___0 + y1___0) * 0.5;
#line 69
    xa2 = ((x0 + (double )2 * x1) + x2) * 0.25;
#line 70
    ya2 = ((y0___0 + (double )2 * y1___0) + y2) * 0.25;
#line 71
    xb1 = ((x1 + (double )2 * x2) + x3) * 0.25;
#line 72
    yb1 = ((y1___0 + (double )2 * y2) + y3) * 0.25;
#line 73
    xb2 = (x2 + x3) * 0.5;
#line 74
    yb2 = (y2 + y3) * 0.5;
#line 75
    x_m = (xa2 + xb1) * 0.5;
#line 76
    y_m = (ya2 + yb1) * 0.5;
#line 81
    p = art_bezier_to_vec(x0, y0___0, xa1, ya1, xa2, ya2, x_m, y_m, p, level - 1);
#line 82
    p = art_bezier_to_vec(x_m, y_m, xb1, yb1, xb2, yb2, x3, y3, p, level - 1);
    }
  }
#line 84
  return (p);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_bpath.c"
static void art_vpath_render_bez(ArtVpath **p_vpath , int *pn , int *pn_max , double x0 ,
                                 double y0___0 , double x1 , double y1___0 , double x2 ,
                                 double y2 , double x3 , double y3 , double flatness ) 
{ 
  double x3_0 ;
  double y3_0 ;
  double z3_0_dot ;
  double z1_dot ;
  double z2_dot ;
  double z1_perp ;
  double z2_perp ;
  double max_perp_sq ;
  double x_m ;
  double y_m ;
  double xa1 ;
  double ya1 ;
  double xa2 ;
  double ya2 ;
  double xb1 ;
  double yb1 ;
  double xb2 ;
  double yb2 ;
  double tmp ;
  double tmp___0 ;

  {
#line 161
  x3_0 = x3 - x0;
#line 162
  y3_0 = y3 - y0___0;
#line 165
  z3_0_dot = x3_0 * x3_0 + y3_0 * y3_0;
#line 167
  if (z3_0_dot < 0.001) {
    {
#line 174
    tmp = hypot(x1 - x0, y1___0 - y0___0);
    }
#line 174
    if (tmp < 0.001) {
      {
#line 174
      tmp___0 = hypot(x2 - x0, y2 - y0___0);
      }
#line 174
      if (tmp___0 < 0.001) {
#line 176
        goto nosubdivide;
      } else {
#line 178
        goto subdivide;
      }
    } else {
#line 178
      goto subdivide;
    }
  }
#line 192
  max_perp_sq = (flatness * flatness) * z3_0_dot;
#line 194
  z1_perp = (y1___0 - y0___0) * x3_0 - (x1 - x0) * y3_0;
#line 195
  if (z1_perp * z1_perp > max_perp_sq) {
#line 196
    goto subdivide;
  }
#line 198
  z2_perp = (y3 - y2) * x3_0 - (x3 - x2) * y3_0;
#line 199
  if (z2_perp * z2_perp > max_perp_sq) {
#line 200
    goto subdivide;
  }
#line 202
  z1_dot = (x1 - x0) * x3_0 + (y1___0 - y0___0) * y3_0;
#line 203
  if (z1_dot < (double )0) {
#line 203
    if (z1_dot * z1_dot > max_perp_sq) {
#line 204
      goto subdivide;
    }
  }
#line 206
  z2_dot = (x3 - x2) * x3_0 + (y3 - y2) * y3_0;
#line 207
  if (z2_dot < (double )0) {
#line 207
    if (z2_dot * z2_dot > max_perp_sq) {
#line 208
      goto subdivide;
    }
  }
#line 210
  if (z1_dot + z1_dot > z3_0_dot) {
#line 211
    goto subdivide;
  }
#line 213
  if (z2_dot + z2_dot > z3_0_dot) {
#line 214
    goto subdivide;
  }
  nosubdivide: 
  {
#line 219
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, x3, y3);
  }
#line 221
  return;
  subdivide: 
  {
#line 225
  xa1 = (x0 + x1) * 0.5;
#line 226
  ya1 = (y0___0 + y1___0) * 0.5;
#line 227
  xa2 = ((x0 + (double )2 * x1) + x2) * 0.25;
#line 228
  ya2 = ((y0___0 + (double )2 * y1___0) + y2) * 0.25;
#line 229
  xb1 = ((x1 + (double )2 * x2) + x3) * 0.25;
#line 230
  yb1 = ((y1___0 + (double )2 * y2) + y3) * 0.25;
#line 231
  xb2 = (x2 + x3) * 0.5;
#line 232
  yb2 = (y2 + y3) * 0.5;
#line 233
  x_m = (xa2 + xb1) * 0.5;
#line 234
  y_m = (ya2 + yb1) * 0.5;
#line 239
  art_vpath_render_bez(p_vpath, pn, pn_max, x0, y0___0, xa1, ya1, xa2, ya2, x_m, y_m,
                       flatness);
#line 241
  art_vpath_render_bez(p_vpath, pn, pn_max, x_m, y_m, xb1, yb1, xb2, yb2, x3, y3,
                       flatness);
  }
#line 243
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_bpath.c"
ArtVpath *art_bez_path_to_vec(ArtBpath const   *bez , double flatness ) 
{ 
  ArtVpath *vec ;
  int vec_n ;
  int vec_n_max ;
  int bez_index ;
  double x ;
  double y ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 265
  vec_n = 0;
#line 266
  vec_n_max = 1 << 4;
#line 267
  tmp = art_alloc((unsigned long )vec_n_max * sizeof(ArtVpath ));
#line 267
  vec = (ArtVpath *)tmp;
#line 272
  x = (double )0;
#line 273
  y = (double )0;
#line 275
  bez_index = 0;
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (vec_n >= vec_n_max) {
      {
#line 288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 288
        if (vec_n_max) {
          {
#line 288
          vec_n_max <<= 1;
#line 288
          tmp___0 = art_realloc((void *)vec, (unsigned long )vec_n_max * sizeof(ArtVpath ));
#line 288
          vec = (ArtVpath *)tmp___0;
          }
        } else {
          {
#line 288
          vec_n_max = 1;
#line 288
          tmp___1 = art_alloc(sizeof(ArtVpath ));
#line 288
          vec = (ArtVpath *)tmp___1;
          }
        }
#line 288
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 293
    if ((unsigned int const   )(bez + bez_index)->code == 3U) {
#line 293
      goto case_3;
    }
#line 293
    if ((unsigned int const   )(bez + bez_index)->code == 0U) {
#line 293
      goto case_3;
    }
#line 293
    if ((unsigned int const   )(bez + bez_index)->code == 1U) {
#line 293
      goto case_3;
    }
#line 301
    if ((unsigned int const   )(bez + bez_index)->code == 4U) {
#line 301
      goto case_4;
    }
#line 307
    if ((unsigned int const   )(bez + bez_index)->code == 2U) {
#line 307
      goto case_2;
    }
#line 289
    goto switch_break;
    case_3: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 294
    x = (double )(bez + bez_index)->x3;
#line 295
    y = (double )(bez + bez_index)->y3;
#line 296
    (vec + vec_n)->code = (ArtPathcode )(bez + bez_index)->code;
#line 297
    (vec + vec_n)->x = x;
#line 298
    (vec + vec_n)->y = y;
#line 299
    vec_n ++;
#line 300
    goto switch_break;
    case_4: /* CIL Label */ 
#line 302
    (vec + vec_n)->code = (ArtPathcode )(bez + bez_index)->code;
#line 303
    (vec + vec_n)->x = (double )0;
#line 304
    (vec + vec_n)->y = (double )0;
#line 305
    vec_n ++;
#line 306
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 314
    art_vpath_render_bez(& vec, & vec_n, & vec_n_max, x, y, (double )(bez + bez_index)->x1,
                         (double )(bez + bez_index)->y1, (double )(bez + bez_index)->x2,
                         (double )(bez + bez_index)->y2, (double )(bez + bez_index)->x3,
                         (double )(bez + bez_index)->y3, flatness);
#line 320
    x = (double )(bez + bez_index)->x3;
#line 321
    y = (double )(bez + bez_index)->y3;
    }
#line 322
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 276
    tmp___2 = bez_index;
#line 276
    bez_index ++;
#line 276
    if (! ((unsigned int const   )(bez + tmp___2)->code != 4U)) {
#line 276
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return (vec);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.h"
ArtSVPRenderAAIter *art_svp_render_aa_iter(ArtSVP const   *svp , int x0 , int y0___0 ,
                                           int x1 , int y1___0 ) ;
#line 47
void art_svp_render_aa_iter_step(ArtSVPRenderAAIter *iter , int *p_start , ArtSVPRenderAAStep **p_steps ,
                                 int *p_n_steps ) ;
#line 51
void art_svp_render_aa_iter_done(ArtSVPRenderAAIter *iter ) ;
#line 54
void art_svp_render_aa(ArtSVP const   *svp , int x0 , int y0___0 , int x1 , int y1___0 ,
                       void (*callback)(void *callback_data , int y , int start ,
                                        ArtSVPRenderAAStep *steps , int n_steps ) ,
                       void *callback_data ) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
static void art_svp_render_insert_active(int i , int *active_segs , int n_active_segs ,
                                         artfloat *seg_x , artfloat *seg_dx ) 
{ 
  int j ;
  artfloat x ;
  int tmp1 ;
  int tmp2 ;

  {
#line 60
  x = *(seg_x + i) + 0.001 * *(seg_dx + i);
#line 61
  j = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (j < n_active_segs) {
#line 61
      if (! (*(seg_x + *(active_segs + j)) < x)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
#line 61
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  tmp1 = i;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (! (j < n_active_segs)) {
#line 64
      goto while_break___0;
    }
#line 66
    tmp2 = *(active_segs + j);
#line 67
    *(active_segs + j) = tmp1;
#line 68
    tmp1 = tmp2;
#line 69
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  *(active_segs + j) = tmp1;
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
static void art_svp_render_delete_active(int *active_segs , int j , int n_active_segs ) 
{ 
  int k ;

  {
#line 79
  k = j;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (k < n_active_segs)) {
#line 79
      goto while_break;
    }
#line 80
    *(active_segs + k) = *(active_segs + (k + 1));
#line 79
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
ArtSVPRenderAAIter *art_svp_render_aa_iter(ArtSVP const   *svp , int x0 , int y0___0 ,
                                           int x1 , int y1___0 ) 
{ 
  ArtSVPRenderAAIter *iter ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 134
  tmp = art_alloc(sizeof(ArtSVPRenderAAIter ));
#line 134
  iter = (ArtSVPRenderAAIter *)tmp;
#line 136
  iter->svp = svp;
#line 137
  iter->y = y0___0;
#line 138
  iter->x0 = x0;
#line 139
  iter->x1 = x1;
#line 140
  iter->seg_ix = 0;
#line 142
  tmp___0 = art_alloc((unsigned long )svp->n_segs * sizeof(int ));
#line 142
  iter->active_segs = (int *)tmp___0;
#line 143
  tmp___1 = art_alloc((unsigned long )svp->n_segs * sizeof(int ));
#line 143
  iter->cursor = (int *)tmp___1;
#line 144
  tmp___2 = art_alloc((unsigned long )svp->n_segs * sizeof(artfloat ));
#line 144
  iter->seg_x = (artfloat *)tmp___2;
#line 145
  tmp___3 = art_alloc((unsigned long )svp->n_segs * sizeof(artfloat ));
#line 145
  iter->seg_dx = (artfloat *)tmp___3;
#line 146
  tmp___4 = art_alloc((unsigned long )(x1 - x0) * sizeof(ArtSVPRenderAAStep ));
#line 146
  iter->steps = (ArtSVPRenderAAStep *)tmp___4;
#line 147
  iter->n_active_segs = 0;
  }
#line 149
  return (iter);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
void art_svp_render_aa_iter_step(ArtSVPRenderAAIter *iter , int *p_start , ArtSVPRenderAAStep **p_steps ,
                                 int *p_n_steps ) 
{ 
  ArtSVP const   *svp ;
  int *active_segs ;
  int n_active_segs ;
  int *cursor ;
  artfloat *seg_x ;
  artfloat *seg_dx ;
  int i ;
  int j ;
  int x0 ;
  int x1 ;
  int y ;
  int seg_index ;
  int x ;
  ArtSVPRenderAAStep *steps ;
  int n_steps ;
  artfloat y_top ;
  artfloat y_bot ;
  artfloat x_top ;
  artfloat x_bot ;
  artfloat x_min ;
  artfloat x_max ;
  int ix_min ;
  int ix_max ;
  artfloat delta ;
  int last ;
  int this ;
  int xdelta ;
  artfloat rslope ;
  artfloat drslope ;
  int start ;
  ArtSVPSeg const   *seg ;
  int curs ;
  artfloat dy ;
  int sx ;
  double tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;

  {
#line 190
  svp = iter->svp;
#line 191
  active_segs = iter->active_segs;
#line 192
  n_active_segs = iter->n_active_segs;
#line 193
  cursor = iter->cursor;
#line 194
  seg_x = iter->seg_x;
#line 195
  seg_dx = iter->seg_dx;
#line 196
  i = iter->seg_ix;
#line 198
  x0 = iter->x0;
#line 199
  x1 = iter->x1;
#line 200
  y = iter->y;
#line 204
  steps = iter->steps;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (i < (int )svp->n_segs) {
#line 222
      if (! (svp->segs[i].bbox.y0 < (double const   )(y + 1))) {
#line 222
        goto while_break;
      }
    } else {
#line 222
      goto while_break;
    }
#line 224
    if (svp->segs[i].bbox.y1 > (double const   )y) {
#line 224
      if (svp->segs[i].bbox.x0 < (double const   )x1) {
#line 227
        seg = (ArtSVPSeg const   *)(& svp->segs[i]);
#line 229
        curs = 0;
        {
#line 229
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 229
          if (! ((seg->points + (curs + 1))->y < (double )y)) {
#line 229
            goto while_break___0;
          }
#line 229
          curs ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 230
        *(cursor + i) = curs;
#line 231
        dy = (seg->points + (curs + 1))->y - (seg->points + curs)->y;
#line 232
        tmp = fabs(dy);
        }
#line 232
        if (tmp >= 1e-6) {
#line 233
          *(seg_dx + i) = ((seg->points + (curs + 1))->x - (seg->points + curs)->x) / dy;
        } else {
#line 236
          *(seg_dx + i) = 1e12;
        }
        {
#line 237
        *(seg_x + i) = (seg->points + curs)->x + ((double )y - (seg->points + curs)->y) * *(seg_dx + i);
#line 239
        tmp___0 = n_active_segs;
#line 239
        n_active_segs ++;
#line 239
        art_svp_render_insert_active(i, active_segs, tmp___0, seg_x, seg_dx);
        }
      }
    }
#line 222
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  n_steps = 0;
#line 247
  start = 32768;
#line 249
  j = 0;
  {
#line 249
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 249
    if (! (j < n_active_segs)) {
#line 249
      goto while_break___1;
    }
#line 251
    seg_index = *(active_segs + j);
#line 252
    seg = (ArtSVPSeg const   *)(& svp->segs[seg_index]);
#line 253
    curs = *(cursor + seg_index);
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 254
      if (curs != (int )(seg->n_points - 1)) {
#line 254
        if (! ((seg->points + curs)->y < (double )(y + 1))) {
#line 254
          goto while_break___2;
        }
      } else {
#line 254
        goto while_break___2;
      }
#line 257
      y_top = (artfloat )y;
#line 258
      if (y_top < (seg->points + curs)->y) {
#line 259
        y_top = (seg->points + curs)->y;
      }
#line 260
      y_bot = (artfloat )(y + 1);
#line 261
      if (y_bot > (seg->points + (curs + 1))->y) {
#line 262
        y_bot = (seg->points + (curs + 1))->y;
      }
#line 263
      if (y_top != y_bot) {
#line 264
        if (seg->dir) {
#line 264
          tmp___1 = 16711680.0;
        } else {
#line 264
          tmp___1 = - 16711680.0;
        }
#line 264
        delta = tmp___1 * (y_bot - y_top);
#line 266
        x_top = *(seg_x + seg_index) + (y_top - (artfloat )y) * *(seg_dx + seg_index);
#line 267
        x_bot = *(seg_x + seg_index) + (y_bot - (artfloat )y) * *(seg_dx + seg_index);
#line 268
        if (x_top < x_bot) {
#line 270
          x_min = x_top;
#line 271
          x_max = x_bot;
        } else {
#line 275
          x_min = x_bot;
#line 276
          x_max = x_top;
        }
        {
#line 278
        tmp___2 = floor(x_min);
#line 278
        ix_min = (int )tmp___2;
#line 279
        tmp___3 = floor(x_max);
#line 279
        ix_max = (int )tmp___3;
        }
#line 280
        if (! (ix_min >= x1)) {
#line 284
          if (ix_max < x0) {
#line 286
            start = (int )((artfloat )start + delta);
          } else
#line 287
          if (ix_min == ix_max) {
#line 290
            xdelta = (int )(((artfloat )(ix_min + 1) - (x_min + x_max) * 0.5) * delta);
#line 292
            if (n_steps == 0) {
#line 292
              sx = n_steps;
#line 292
              (steps + sx)->x = ix_min;
#line 292
              (steps + sx)->delta = xdelta;
#line 292
              n_steps ++;
            } else
#line 292
            if ((steps + (n_steps - 1))->x < ix_min) {
#line 292
              sx = n_steps;
#line 292
              (steps + sx)->x = ix_min;
#line 292
              (steps + sx)->delta = xdelta;
#line 292
              n_steps ++;
            } else {
#line 292
              sx = n_steps;
              {
#line 292
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 292
                if (! (sx > 0)) {
#line 292
                  goto while_break___3;
                }
#line 292
                if ((steps + (sx - 1))->x == ix_min) {
#line 292
                  (steps + (sx - 1))->delta += xdelta;
#line 292
                  sx = n_steps;
#line 292
                  goto while_break___3;
                } else
#line 292
                if ((steps + (sx - 1))->x < ix_min) {
#line 292
                  goto while_break___3;
                }
#line 292
                sx --;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 292
              if (sx < n_steps) {
                {
#line 292
                memmove((void *)(steps + (sx + 1)), (void const   *)(steps + sx),
                        (unsigned long )(n_steps - sx) * sizeof(*(steps + 0)));
#line 292
                (steps + sx)->x = ix_min;
#line 292
                (steps + sx)->delta = xdelta;
#line 292
                n_steps ++;
                }
              }
            }
#line 294
            if (ix_min + 1 < x1) {
#line 296
              xdelta = (int )(delta - (artfloat )xdelta);
#line 298
              if (n_steps == 0) {
#line 298
                sx = n_steps;
#line 298
                (steps + sx)->x = ix_min + 1;
#line 298
                (steps + sx)->delta = xdelta;
#line 298
                n_steps ++;
              } else
#line 298
              if ((steps + (n_steps - 1))->x < ix_min + 1) {
#line 298
                sx = n_steps;
#line 298
                (steps + sx)->x = ix_min + 1;
#line 298
                (steps + sx)->delta = xdelta;
#line 298
                n_steps ++;
              } else {
#line 298
                sx = n_steps;
                {
#line 298
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 298
                  if (! (sx > 0)) {
#line 298
                    goto while_break___4;
                  }
#line 298
                  if ((steps + (sx - 1))->x == ix_min + 1) {
#line 298
                    (steps + (sx - 1))->delta += xdelta;
#line 298
                    sx = n_steps;
#line 298
                    goto while_break___4;
                  } else
#line 298
                  if ((steps + (sx - 1))->x < ix_min + 1) {
#line 298
                    goto while_break___4;
                  }
#line 298
                  sx --;
                }
                while_break___4: /* CIL Label */ ;
                }
#line 298
                if (sx < n_steps) {
                  {
#line 298
                  memmove((void *)(steps + (sx + 1)), (void const   *)(steps + sx),
                          (unsigned long )(n_steps - sx) * sizeof(*(steps + 0)));
#line 298
                  (steps + sx)->x = ix_min + 1;
#line 298
                  (steps + sx)->delta = xdelta;
#line 298
                  n_steps ++;
                  }
                }
              }
            }
          } else {
            {
#line 304
            tmp___4 = fabs(*(seg_dx + seg_index));
#line 304
            rslope = 1.0 / tmp___4;
#line 305
            drslope = delta * rslope;
#line 306
            last = (int )(((drslope * 0.5) * ((artfloat )(ix_min + 1) - x_min)) * ((artfloat )(ix_min + 1) - x_min));
#line 309
            xdelta = last;
            }
#line 310
            if (ix_min >= x0) {
#line 312
              if (n_steps == 0) {
#line 312
                sx = n_steps;
#line 312
                (steps + sx)->x = ix_min;
#line 312
                (steps + sx)->delta = xdelta;
#line 312
                n_steps ++;
              } else
#line 312
              if ((steps + (n_steps - 1))->x < ix_min) {
#line 312
                sx = n_steps;
#line 312
                (steps + sx)->x = ix_min;
#line 312
                (steps + sx)->delta = xdelta;
#line 312
                n_steps ++;
              } else {
#line 312
                sx = n_steps;
                {
#line 312
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 312
                  if (! (sx > 0)) {
#line 312
                    goto while_break___5;
                  }
#line 312
                  if ((steps + (sx - 1))->x == ix_min) {
#line 312
                    (steps + (sx - 1))->delta += xdelta;
#line 312
                    sx = n_steps;
#line 312
                    goto while_break___5;
                  } else
#line 312
                  if ((steps + (sx - 1))->x < ix_min) {
#line 312
                    goto while_break___5;
                  }
#line 312
                  sx --;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 312
                if (sx < n_steps) {
                  {
#line 312
                  memmove((void *)(steps + (sx + 1)), (void const   *)(steps + sx),
                          (unsigned long )(n_steps - sx) * sizeof(*(steps + 0)));
#line 312
                  (steps + sx)->x = ix_min;
#line 312
                  (steps + sx)->delta = xdelta;
#line 312
                  n_steps ++;
                  }
                }
              }
#line 314
              x = ix_min + 1;
            } else {
#line 318
              start += last;
#line 319
              x = x0;
            }
#line 321
            if (ix_max > x1) {
#line 322
              ix_max = x1;
            }
            {
#line 323
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 323
              if (! (x < ix_max)) {
#line 323
                goto while_break___6;
              }
#line 325
              if (seg->dir) {
#line 325
                tmp___5 = 16711680.0;
              } else {
#line 325
                tmp___5 = - 16711680.0;
              }
#line 325
              this = (int )((tmp___5 * rslope) * (((double )x + 0.5) - x_min));
#line 327
              xdelta = this - last;
#line 328
              last = this;
#line 330
              if (n_steps == 0) {
#line 330
                sx = n_steps;
#line 330
                (steps + sx)->x = x;
#line 330
                (steps + sx)->delta = xdelta;
#line 330
                n_steps ++;
              } else
#line 330
              if ((steps + (n_steps - 1))->x < x) {
#line 330
                sx = n_steps;
#line 330
                (steps + sx)->x = x;
#line 330
                (steps + sx)->delta = xdelta;
#line 330
                n_steps ++;
              } else {
#line 330
                sx = n_steps;
                {
#line 330
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 330
                  if (! (sx > 0)) {
#line 330
                    goto while_break___7;
                  }
#line 330
                  if ((steps + (sx - 1))->x == x) {
#line 330
                    (steps + (sx - 1))->delta += xdelta;
#line 330
                    sx = n_steps;
#line 330
                    goto while_break___7;
                  } else
#line 330
                  if ((steps + (sx - 1))->x < x) {
#line 330
                    goto while_break___7;
                  }
#line 330
                  sx --;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 330
                if (sx < n_steps) {
                  {
#line 330
                  memmove((void *)(steps + (sx + 1)), (void const   *)(steps + sx),
                          (unsigned long )(n_steps - sx) * sizeof(*(steps + 0)));
#line 330
                  (steps + sx)->x = x;
#line 330
                  (steps + sx)->delta = xdelta;
#line 330
                  n_steps ++;
                  }
                }
              }
#line 323
              x ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 332
            if (x < x1) {
#line 334
              this = (int )(delta * ((double )1 - ((0.5 * (x_max - (artfloat )ix_max)) * (x_max - (artfloat )ix_max)) * rslope));
#line 338
              xdelta = this - last;
#line 339
              last = this;
#line 341
              if (n_steps == 0) {
#line 341
                sx = n_steps;
#line 341
                (steps + sx)->x = x;
#line 341
                (steps + sx)->delta = xdelta;
#line 341
                n_steps ++;
              } else
#line 341
              if ((steps + (n_steps - 1))->x < x) {
#line 341
                sx = n_steps;
#line 341
                (steps + sx)->x = x;
#line 341
                (steps + sx)->delta = xdelta;
#line 341
                n_steps ++;
              } else {
#line 341
                sx = n_steps;
                {
#line 341
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 341
                  if (! (sx > 0)) {
#line 341
                    goto while_break___8;
                  }
#line 341
                  if ((steps + (sx - 1))->x == x) {
#line 341
                    (steps + (sx - 1))->delta += xdelta;
#line 341
                    sx = n_steps;
#line 341
                    goto while_break___8;
                  } else
#line 341
                  if ((steps + (sx - 1))->x < x) {
#line 341
                    goto while_break___8;
                  }
#line 341
                  sx --;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 341
                if (sx < n_steps) {
                  {
#line 341
                  memmove((void *)(steps + (sx + 1)), (void const   *)(steps + sx),
                          (unsigned long )(n_steps - sx) * sizeof(*(steps + 0)));
#line 341
                  (steps + sx)->x = x;
#line 341
                  (steps + sx)->delta = xdelta;
#line 341
                  n_steps ++;
                  }
                }
              }
#line 343
              if (x + 1 < x1) {
#line 345
                xdelta = (int )(delta - (artfloat )last);
#line 347
                if (n_steps == 0) {
#line 347
                  sx = n_steps;
#line 347
                  (steps + sx)->x = x + 1;
#line 347
                  (steps + sx)->delta = xdelta;
#line 347
                  n_steps ++;
                } else
#line 347
                if ((steps + (n_steps - 1))->x < x + 1) {
#line 347
                  sx = n_steps;
#line 347
                  (steps + sx)->x = x + 1;
#line 347
                  (steps + sx)->delta = xdelta;
#line 347
                  n_steps ++;
                } else {
#line 347
                  sx = n_steps;
                  {
#line 347
                  while (1) {
                    while_continue___9: /* CIL Label */ ;
#line 347
                    if (! (sx > 0)) {
#line 347
                      goto while_break___9;
                    }
#line 347
                    if ((steps + (sx - 1))->x == x + 1) {
#line 347
                      (steps + (sx - 1))->delta += xdelta;
#line 347
                      sx = n_steps;
#line 347
                      goto while_break___9;
                    } else
#line 347
                    if ((steps + (sx - 1))->x < x + 1) {
#line 347
                      goto while_break___9;
                    }
#line 347
                    sx --;
                  }
                  while_break___9: /* CIL Label */ ;
                  }
#line 347
                  if (sx < n_steps) {
                    {
#line 347
                    memmove((void *)(steps + (sx + 1)), (void const   *)(steps + sx),
                            (unsigned long )(n_steps - sx) * sizeof(*(steps + 0)));
#line 347
                    (steps + sx)->x = x + 1;
#line 347
                    (steps + sx)->delta = xdelta;
#line 347
                    n_steps ++;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 352
      curs ++;
#line 353
      if (curs != (int )(seg->n_points - 1)) {
#line 353
        if ((seg->points + curs)->y < (double )(y + 1)) {
          {
#line 356
          dy = (seg->points + (curs + 1))->y - (seg->points + curs)->y;
#line 357
          tmp___6 = fabs(dy);
          }
#line 357
          if (tmp___6 >= 1e-6) {
#line 358
            *(seg_dx + seg_index) = ((seg->points + (curs + 1))->x - (seg->points + curs)->x) / dy;
          } else {
#line 361
            *(seg_dx + seg_index) = 1e12;
          }
#line 362
          *(seg_x + seg_index) = (seg->points + curs)->x + ((double )y - (seg->points + curs)->y) * *(seg_dx + seg_index);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 367
    if ((seg->points + curs)->y >= (double )(y + 1)) {
#line 369
      curs --;
#line 370
      *(cursor + seg_index) = curs;
#line 371
      *(seg_x + seg_index) += *(seg_dx + seg_index);
    } else {
      {
#line 375
      n_active_segs --;
#line 375
      tmp___7 = j;
#line 375
      j --;
#line 375
      art_svp_render_delete_active(active_segs, tmp___7, n_active_segs);
      }
    }
#line 249
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 380
  *p_start = start;
#line 381
  *p_steps = steps;
#line 382
  *p_n_steps = n_steps;
#line 384
  iter->seg_ix = i;
#line 385
  iter->n_active_segs = n_active_segs;
#line 386
  (iter->y) ++;
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
void art_svp_render_aa_iter_done(ArtSVPRenderAAIter *iter ) 
{ 


  {
  {
#line 392
  art_free((void *)iter->steps);
#line 394
  art_free((void *)iter->seg_dx);
#line 395
  art_free((void *)iter->seg_x);
#line 396
  art_free((void *)iter->cursor);
#line 397
  art_free((void *)iter->active_segs);
#line 398
  art_free((void *)iter);
  }
#line 399
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
void art_svp_render_aa(ArtSVP const   *svp , int x0 , int y0___0 , int x1 , int y1___0 ,
                       void (*callback)(void *callback_data , int y , int start ,
                                        ArtSVPRenderAAStep *steps , int n_steps ) ,
                       void *callback_data ) 
{ 
  ArtSVPRenderAAIter *iter ;
  int y ;
  int start ;
  ArtSVPRenderAAStep *steps ;
  int n_steps ;

  {
  {
#line 453
  iter = art_svp_render_aa_iter(svp, x0, y0___0, x1, y1___0);
#line 456
  y = y0___0;
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! (y < y1___0)) {
#line 456
      goto while_break;
    }
    {
#line 458
    art_svp_render_aa_iter_step(iter, & start, & steps, & n_steps);
#line 459
    (*callback)(callback_data, y, start, steps, n_steps);
#line 456
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 462
  art_svp_render_aa_iter_done(iter);
  }
#line 463
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_rect.h"
ArtUta *art_uta_from_irect(ArtIRect *bbox ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_rect.c"
ArtUta *art_uta_from_irect(ArtIRect *bbox ) 
{ 
  ArtUta *uta ;
  ArtUtaBbox *utiles ;
  ArtUtaBbox bb ;
  int width ;
  int height ;
  int x ;
  int y ;
  int xf0 ;
  int yf0 ;
  int xf1 ;
  int yf1 ;
  int ix ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 47
  tmp = art_alloc(sizeof(ArtUta ));
#line 47
  uta = (ArtUta *)tmp;
#line 48
  uta->x0 = bbox->x0 >> 5;
#line 49
  uta->y0 = bbox->y0 >> 5;
#line 50
  width = (((bbox->x1 + (1 << 5)) - 1) >> 5) - uta->x0;
#line 51
  height = (((bbox->y1 + (1 << 5)) - 1) >> 5) - uta->y0;
#line 52
  tmp___0 = art_alloc((unsigned long )(width * height) * sizeof(ArtUtaBbox ));
#line 52
  utiles = (ArtUtaBbox *)tmp___0;
#line 54
  uta->width = width;
#line 55
  uta->height = height;
#line 56
  uta->utiles = utiles;
#line 58
  xf0 = bbox->x0 & ((1 << 5) - 1);
#line 59
  yf0 = bbox->y0 & ((1 << 5) - 1);
#line 60
  xf1 = ((bbox->x1 - 1) & ((1 << 5) - 1)) + 1;
#line 61
  yf1 = ((bbox->y1 - 1) & ((1 << 5) - 1)) + 1;
  }
#line 62
  if (height == 1) {
#line 64
    if (width == 1) {
#line 65
      *(utiles + 0) = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | (xf1 << 8)) | yf1);
    } else {
#line 68
      *(utiles + 0) = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | ((1 << 5) << 8)) | yf1);
#line 69
      bb = (ArtUtaBbox )(((yf0 << 16) | ((1 << 5) << 8)) | yf1);
#line 70
      x = 1;
      {
#line 70
      while (1) {
        while_continue: /* CIL Label */ ;
#line 70
        if (! (x < width - 1)) {
#line 70
          goto while_break;
        }
#line 71
        *(utiles + x) = bb;
#line 70
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 72
      *(utiles + x) = (ArtUtaBbox )(((yf0 << 16) | (xf1 << 8)) | yf1);
    }
  } else
#line 77
  if (width == 1) {
#line 79
    *(utiles + 0) = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | (xf1 << 8)) | (1 << 5));
#line 80
    bb = (ArtUtaBbox )(((xf0 << 24) | (xf1 << 8)) | (1 << 5));
#line 81
    y = 1;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! (y < height - 1)) {
#line 81
        goto while_break___0;
      }
#line 82
      *(utiles + y) = bb;
#line 81
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    *(utiles + y) = (ArtUtaBbox )(((xf0 << 24) | (xf1 << 8)) | yf1);
  } else {
#line 87
    *(utiles + 0) = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | ((1 << 5) << 8)) | (1 << 5));
#line 89
    bb = (ArtUtaBbox )(((yf0 << 16) | ((1 << 5) << 8)) | (1 << 5));
#line 90
    x = 1;
    {
#line 90
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 90
      if (! (x < width - 1)) {
#line 90
        goto while_break___1;
      }
#line 91
      *(utiles + x) = bb;
#line 90
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 92
    *(utiles + x) = (ArtUtaBbox )(((yf0 << 16) | (xf1 << 8)) | (1 << 5));
#line 93
    ix = width;
#line 94
    y = 1;
    {
#line 94
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (y < height - 1)) {
#line 94
        goto while_break___2;
      }
#line 96
      tmp___1 = ix;
#line 96
      ix ++;
#line 96
      *(utiles + tmp___1) = (ArtUtaBbox )(((xf0 << 24) | ((1 << 5) << 8)) | (1 << 5));
#line 98
      bb = (ArtUtaBbox )(((1 << 5) << 8) | (1 << 5));
#line 99
      x = 1;
      {
#line 99
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 99
        if (! (x < width - 1)) {
#line 99
          goto while_break___3;
        }
#line 100
        tmp___2 = ix;
#line 100
        ix ++;
#line 100
        *(utiles + tmp___2) = bb;
#line 99
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 101
      tmp___3 = ix;
#line 101
      ix ++;
#line 101
      *(utiles + tmp___3) = (ArtUtaBbox )((xf1 << 8) | (1 << 5));
#line 94
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 103
    tmp___4 = ix;
#line 103
    ix ++;
#line 103
    *(utiles + tmp___4) = (ArtUtaBbox )(((xf0 << 24) | ((1 << 5) << 8)) | yf1);
#line 104
    bb = (ArtUtaBbox )(((1 << 5) << 8) | yf1);
#line 105
    x = 1;
    {
#line 105
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 105
      if (! (x < width - 1)) {
#line 105
        goto while_break___4;
      }
#line 106
      tmp___5 = ix;
#line 106
      ix ++;
#line 106
      *(utiles + tmp___5) = bb;
#line 105
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 107
    tmp___6 = ix;
#line 107
    ix ++;
#line 107
    *(utiles + tmp___6) = (ArtUtaBbox )((xf1 << 8) | yf1);
  }
#line 110
  return (uta);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 175 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
void art_render_add_image_source(ArtRender *render , ArtImageSource *image_source ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.h"
void art_render_gradient_linear(ArtRender *render , ArtGradientLinear const   *gradient ,
                                ArtFilterLevel level ) ;
#line 77
void art_render_gradient_radial(ArtRender *render , ArtGradientRadial const   *gradient ,
                                ArtFilterLevel level ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_rgba_gradient_run(art_u8 *buf , art_u8 *color1 , art_u8 *color2 ,
                                  int len ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int a ;
  int dr ;
  int dg ;
  int db ;
  int da ;
  art_u8 *tmp ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;

  {
#line 108
  r = ((int )*(color1 + 0) << 16) + 32768;
#line 109
  g = ((int )*(color1 + 1) << 16) + 32768;
#line 110
  b = ((int )*(color1 + 2) << 16) + 32768;
#line 111
  a = ((int )*(color1 + 3) << 16) + 32768;
#line 112
  dr = (((int )*(color2 + 0) - (int )*(color1 + 0)) << 16) / len;
#line 113
  dg = (((int )*(color2 + 1) - (int )*(color1 + 1)) << 16) / len;
#line 114
  db = (((int )*(color2 + 2) - (int )*(color1 + 2)) << 16) / len;
#line 115
  da = (((int )*(color2 + 3) - (int )*(color1 + 3)) << 16) / len;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < len)) {
#line 117
      goto while_break;
    }
#line 119
    tmp = buf;
#line 119
    buf ++;
#line 119
    *tmp = (art_u8 )(r >> 16);
#line 120
    tmp___0 = buf;
#line 120
    buf ++;
#line 120
    *tmp___0 = (art_u8 )(g >> 16);
#line 121
    tmp___1 = buf;
#line 121
    buf ++;
#line 121
    *tmp___1 = (art_u8 )(b >> 16);
#line 122
    tmp___2 = buf;
#line 122
    buf ++;
#line 122
    *tmp___2 = (art_u8 )(a >> 16);
#line 124
    r += dr;
#line 125
    g += dg;
#line 126
    b += db;
#line 127
    a += da;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void calc_color_at(ArtGradientStop *stops , int n_stops , ArtGradientSpread spread ,
                          double offset , double offset_fraction , int favor_start ,
                          int ix , art_u8 *color ) 
{ 
  double off0 ;
  double off1 ;
  int j ;
  double interp ;
  double o ;
  double tmp ;
  double tmp___0 ;
  int z0 ;
  int z1 ;
  int z ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 144
  if ((unsigned int )spread == 0U) {
#line 146
    if (offset < 0.0) {
#line 148
      *(color + 0) = (art_u8 )((((int )(stops + 0)->color[0] + 128) - (((int )(stops + 0)->color[0] + 128) >> 8)) >> 8);
#line 149
      *(color + 1) = (art_u8 )((((int )(stops + 0)->color[1] + 128) - (((int )(stops + 0)->color[1] + 128) >> 8)) >> 8);
#line 150
      *(color + 2) = (art_u8 )((((int )(stops + 0)->color[2] + 128) - (((int )(stops + 0)->color[2] + 128) >> 8)) >> 8);
#line 151
      *(color + 3) = (art_u8 )((((int )(stops + 0)->color[3] + 128) - (((int )(stops + 0)->color[3] + 128) >> 8)) >> 8);
#line 152
      return;
    }
#line 154
    if (offset >= 1.0) {
#line 156
      *(color + 0) = (art_u8 )((((int )(stops + (n_stops - 1))->color[0] + 128) - (((int )(stops + (n_stops - 1))->color[0] + 128) >> 8)) >> 8);
#line 157
      *(color + 1) = (art_u8 )((((int )(stops + (n_stops - 1))->color[1] + 128) - (((int )(stops + (n_stops - 1))->color[1] + 128) >> 8)) >> 8);
#line 158
      *(color + 2) = (art_u8 )((((int )(stops + (n_stops - 1))->color[2] + 128) - (((int )(stops + (n_stops - 1))->color[2] + 128) >> 8)) >> 8);
#line 159
      *(color + 3) = (art_u8 )((((int )(stops + (n_stops - 1))->color[3] + 128) - (((int )(stops + (n_stops - 1))->color[3] + 128) >> 8)) >> 8);
#line 160
      return;
    }
  }
#line 164
  if (ix > 0) {
#line 164
    if (ix < n_stops) {
      {
#line 166
      off0 = (stops + (ix - 1))->offset;
#line 167
      off1 = (stops + ix)->offset;
#line 168
      tmp___2 = fabs(off1 - off0);
      }
#line 168
      if (tmp___2 > 1e-6) {
        {
#line 172
        o = offset_fraction;
#line 174
        tmp___0 = fabs(o);
        }
#line 174
        if (tmp___0 < 1e-6) {
#line 174
          if (! favor_start) {
#line 175
            o = 1.0;
          } else {
#line 174
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 176
          tmp = fabs(o - 1.0);
          }
#line 176
          if (tmp < 1e-6) {
#line 176
            if (favor_start) {
#line 177
              o = 0.0;
            }
          }
        }
#line 184
        interp = (o - off0) / (off1 - off0);
#line 185
        j = 0;
        {
#line 185
        while (1) {
          while_continue: /* CIL Label */ ;
#line 185
          if (! (j < 4)) {
#line 185
            goto while_break;
          }
          {
#line 189
          z0 = (int )(stops + (ix - 1))->color[j];
#line 190
          z1 = (int )(stops + ix)->color[j];
#line 191
          tmp___1 = floor(((double )z0 + (double )(z1 - z0) * interp) + 0.5);
#line 191
          z = (int )tmp___1;
#line 192
          *(color + j) = (art_u8 )(((z + 128) - ((z + 128) >> 8)) >> 8);
#line 185
          j ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 194
        return;
      }
#line 198
      *(color + 0) = (art_u8 )((((int )(stops + ix)->color[0] + 128) - (((int )(stops + ix)->color[0] + 128) >> 8)) >> 8);
#line 199
      *(color + 1) = (art_u8 )((((int )(stops + ix)->color[1] + 128) - (((int )(stops + ix)->color[1] + 128) >> 8)) >> 8);
#line 200
      *(color + 2) = (art_u8 )((((int )(stops + ix)->color[2] + 128) - (((int )(stops + ix)->color[2] + 128) >> 8)) >> 8);
#line 201
      *(color + 3) = (art_u8 )((((int )(stops + ix)->color[3] + 128) - (((int )(stops + ix)->color[3] + 128) >> 8)) >> 8);
#line 202
      return;
    }
  }
  {
#line 205
  printf((char const   */* __restrict  */)"WARNING! bad ix %d in calc_color_at() [internal error]\n",
         ix);
#line 206
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                206U, "calc_color_at");
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_render_8(ArtRenderCallback *self , ArtRender *render ,
                                                art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradLin *z ;
  ArtGradientLinear const   *gradient ;
  int i ;
  int width ;
  int len ;
  double offset ;
  double d_offset ;
  double offset_fraction ;
  int next_stop ;
  int ix ;
  art_u8 color1[4] ;
  art_u8 color2[4] ;
  int n_stops ;
  int extra_stops ;
  ArtGradientStop *stops ;
  ArtGradientStop *tmp_stops ;
  art_u8 *bufp ;
  ArtGradientSpread spread ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double o ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
#line 214
  z = (ArtImageSourceGradLin *)self;
#line 215
  gradient = (ArtGradientLinear const   *)(& z->gradient);
#line 217
  width = render->x1 - render->x0;
#line 224
  n_stops = (int )gradient->n_stops;
#line 226
  stops = (ArtGradientStop *)gradient->stops;
#line 228
  bufp = render->image_buf;
#line 229
  spread = (ArtGradientSpread )gradient->spread;
#line 242
  offset = (double )(((double const   )render->x0 * gradient->a + (double const   )y * gradient->b) + gradient->c);
#line 243
  d_offset = (double )gradient->a;
#line 248
  if ((gradient->stops + 0)->offset > 1e-6) {
#line 248
    goto _L;
  } else
#line 248
  if ((gradient->stops + (n_stops - 1))->offset < 1.0 - 1e-6) {
    _L: /* CIL Label */ 
    {
#line 251
    extra_stops = 0;
#line 252
    tmp = __builtin_alloca(sizeof(ArtGradientStop ) * (unsigned long )(n_stops + 2));
#line 252
    stops = (ArtGradientStop *)tmp;
#line 252
    tmp_stops = stops;
    }
#line 253
    if ((gradient->stops + 0)->offset > 1e-6) {
      {
#line 255
      memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)gradient->stops,
             sizeof(ArtGradientStop ));
#line 256
      (tmp_stops + 0)->offset = 0.0;
#line 257
      tmp_stops ++;
#line 258
      extra_stops ++;
      }
    }
    {
#line 260
    memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)gradient->stops,
           sizeof(ArtGradientStop ) * (unsigned long )n_stops);
    }
#line 261
    if ((gradient->stops + (n_stops - 1))->offset < 1.0 - 1e-6) {
      {
#line 263
      tmp_stops += n_stops;
#line 264
      memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)(gradient->stops + (n_stops - 1)),
             sizeof(ArtGradientStop ));
#line 265
      (tmp_stops + 0)->offset = 1.0;
#line 266
      extra_stops ++;
      }
    }
#line 268
    n_stops += extra_stops;
  }
#line 282
  if ((unsigned int )spread == 1U) {
    {
#line 284
    tmp_stops = stops;
#line 285
    tmp___0 = __builtin_alloca((sizeof(ArtGradientStop ) * (unsigned long )n_stops) * 2UL);
#line 285
    stops = (ArtGradientStop *)tmp___0;
#line 286
    memcpy((void */* __restrict  */)stops, (void const   */* __restrict  */)tmp_stops,
           sizeof(ArtGradientStop ) * (unsigned long )n_stops);
#line 288
    i = 0;
    }
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < n_stops)) {
#line 288
        goto while_break;
      }
      {
#line 290
      (stops + ((n_stops * 2 - 1) - i))->offset = 1.0 - (stops + i)->offset / 2.0;
#line 291
      memcpy((void */* __restrict  */)((stops + ((n_stops * 2 - 1) - i))->color),
             (void const   */* __restrict  */)((stops + i)->color), sizeof((stops + i)->color));
#line 292
      (stops + i)->offset /= 2.0;
#line 288
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 295
    spread = (ArtGradientSpread )2;
#line 296
    offset /= 2.0;
#line 297
    d_offset /= 2.0;
#line 299
    n_stops = 2 * n_stops;
  }
  {
#line 311
  tmp___1 = floor(offset);
#line 311
  offset_fraction = offset - tmp___1;
#line 321
  ix = 0;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! (ix < n_stops)) {
#line 321
      goto while_break___0;
    }
#line 322
    if ((stops + ix)->offset > offset_fraction) {
#line 324
      goto while_break___0;
    } else
#line 322
    if (d_offset < 0.0) {
      {
#line 322
      tmp___2 = fabs((stops + ix)->offset - offset_fraction);
      }
#line 322
      if (tmp___2 < 1e-6) {
#line 324
        goto while_break___0;
      }
    }
#line 321
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  if (ix == 0) {
#line 326
    ix = n_stops - 1;
  } else
#line 327
  if (ix == n_stops) {
#line 328
    ix = n_stops - 1;
  }
#line 334
  if (! (ix > 0)) {
    {
#line 334
    __assert_fail("ix > 0", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  334U, "art_render_gradient_linear_render_8");
    }
  }
#line 335
  if (! (ix < n_stops)) {
    {
#line 335
    __assert_fail("ix < n_stops", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  335U, "art_render_gradient_linear_render_8");
    }
  }
#line 336
  if (! ((stops + (ix - 1))->offset <= offset_fraction + 1e-6)) {
#line 336
    if ((stops + ix)->offset > 1.0 - 1e-6) {
#line 336
      if (! (offset_fraction < 1e-6)) {
        {
#line 336
        __assert_fail("(stops[ix-1].offset <= offset_fraction + 1e-6) || ((stops[ix].offset > (1.0 - 1e-6)) && (offset_fraction < 1e-6 ))",
                      "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                      337U, "art_render_gradient_linear_render_8");
        }
      }
    } else {
      {
#line 336
      __assert_fail("(stops[ix-1].offset <= offset_fraction + 1e-6) || ((stops[ix].offset > (1.0 - 1e-6)) && (offset_fraction < 1e-6 ))",
                    "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                    337U, "art_render_gradient_linear_render_8");
      }
    }
  }
#line 338
  if (! (offset_fraction <= (stops + ix)->offset)) {
    {
#line 338
    __assert_fail("offset_fraction <= stops[ix].offset", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  338U, "art_render_gradient_linear_render_8");
    }
  }
  {
#line 348
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 348
    if (! (width > 0)) {
#line 348
      goto while_break___1;
    }
    {
#line 354
    calc_color_at(stops, n_stops, spread, offset, offset_fraction, d_offset > - 1e-6,
                  ix, color1);
    }
#line 362
    if (d_offset > (double )0) {
#line 363
      next_stop = ix;
    } else {
#line 365
      next_stop = ix - 1;
    }
    {
#line 370
    tmp___7 = fabs(d_offset);
    }
#line 370
    if (tmp___7 > 1e-6) {
      {
#line 373
      o = offset_fraction;
#line 375
      tmp___4 = fabs(o);
      }
#line 375
      if (tmp___4 <= 1e-6) {
#line 375
        if (ix == n_stops - 1) {
#line 376
          o = 1.0;
        } else {
#line 375
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 377
        tmp___3 = fabs(o - 1.0);
        }
#line 377
        if (tmp___3 <= 1e-6) {
#line 377
          if (ix == 1) {
#line 378
            o = 0.0;
          }
        }
      }
      {
#line 383
      tmp___5 = fabs(((stops + next_stop)->offset - o) / d_offset);
#line 383
      tmp___6 = floor(tmp___5);
#line 383
      len = (int )tmp___6 + 1;
      }
#line 384
      if (len > 0) {
#line 384
        len = len;
      } else {
#line 384
        len = 0;
      }
#line 385
      if (len < width) {
#line 385
        len = len;
      } else {
#line 385
        len = width;
      }
    } else {
#line 389
      len = width;
    }
#line 394
    if (len > 0) {
      {
#line 396
      offset += (double )(len - 1) * d_offset;
#line 397
      tmp___8 = floor(offset);
#line 397
      offset_fraction = offset - tmp___8;
#line 401
      calc_color_at(stops, n_stops, spread, offset, offset_fraction, d_offset < 1e-6,
                    ix, color2);
#line 409
      art_rgba_gradient_run(bufp, color1, color2, len);
#line 413
      offset += d_offset;
#line 414
      tmp___9 = floor(offset);
#line 414
      offset_fraction = offset - tmp___9;
      }
    }
#line 417
    if (d_offset > (double )0) {
      {
#line 419
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 421
        ix ++;
#line 422
        if (ix == n_stops) {
#line 423
          ix = 1;
        }
#line 419
        if ((stops + (ix - 1))->offset <= offset_fraction) {
#line 419
          if (offset_fraction < (stops + ix)->offset) {
#line 419
            goto while_break___2;
          } else {
#line 419
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 419
        if (ix == 1) {
#line 419
          if (offset_fraction > 1.0 - 1e-6) {
#line 419
            goto while_break___2;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 436
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 438
        ix --;
#line 439
        if (ix == 0) {
#line 440
          ix = n_stops - 1;
        }
#line 436
        if ((stops + (ix - 1))->offset < offset_fraction) {
#line 436
          if (offset_fraction <= (stops + ix)->offset) {
#line 436
            goto while_break___3;
          } else {
#line 436
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 436
        if (ix == n_stops - 1) {
#line 436
          if (offset_fraction < 1e-6) {
#line 436
            goto while_break___3;
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 447
    bufp += 4 * len;
#line 448
    width -= len;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 450
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_setpix(ArtRender *render , art_u8 *dst , int n_stops ,
                                       ArtGradientStop *stops , double offset ) 
{ 
  int ix ;
  int j ;
  double off0 ;
  double off1 ;
  int n_ch ;
  double interp ;
  int z0 ;
  int z1 ;
  int z ;
  double tmp ;
  double tmp___0 ;
  int z___0 ;

  {
#line 474
  n_ch = render->n_chan + 1;
#line 476
  ix = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (ix < n_stops)) {
#line 476
      goto while_break;
    }
#line 477
    if ((stops + ix)->offset > offset) {
#line 478
      goto while_break;
    }
#line 476
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  if (ix > 0) {
#line 480
    if (ix < n_stops) {
      {
#line 482
      off0 = (stops + (ix - 1))->offset;
#line 483
      off1 = (stops + ix)->offset;
#line 484
      tmp___0 = fabs(off1 - off0);
      }
#line 484
      if (tmp___0 > 1e-6) {
#line 488
        interp = (offset - off0) / (off1 - off0);
#line 489
        j = 0;
        {
#line 489
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 489
          if (! (j < n_ch)) {
#line 489
            goto while_break___0;
          }
          {
#line 493
          z0 = (int )(stops + (ix - 1))->color[j];
#line 494
          z1 = (int )(stops + ix)->color[j];
#line 495
          tmp = floor(((double )z0 + (double )(z1 - z0) * interp) + 0.5);
#line 495
          z = (int )tmp;
          }
#line 496
          if (render->buf_depth == 8) {
#line 497
            *(dst + j) = (art_u8 )(((z + 128) - ((z + 128) >> 8)) >> 8);
          } else {
#line 499
            *((art_u16 *)dst + j) = (art_u16 )z;
          }
#line 489
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 501
        return;
      }
    } else {
#line 480
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 504
  if (ix == n_stops) {
#line 505
    ix --;
  }
#line 507
  j = 0;
  {
#line 507
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 507
    if (! (j < n_ch)) {
#line 507
      goto while_break___1;
    }
#line 510
    z___0 = (int )(stops + ix)->color[j];
#line 511
    if (render->buf_depth == 8) {
#line 512
      *(dst + j) = (art_u8 )(((z___0 + 128) - ((z___0 + 128) >> 8)) >> 8);
    } else {
#line 514
      *((art_u16 *)dst + j) = (art_u16 )z___0;
    }
#line 507
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_done(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 521
  art_free((void *)self);
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_render(ArtRenderCallback *self , ArtRender *render ,
                                              art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradLin *z ;
  ArtGradientLinear const   *gradient ;
  int pixstride ;
  int x ;
  int width ;
  double offset ;
  double d_offset ;
  double actual_offset ;
  int n_stops ;
  ArtGradientStop *stops ;
  art_u8 *bufp ;
  ArtGradientSpread spread ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 528
  z = (ArtImageSourceGradLin *)self;
#line 529
  gradient = (ArtGradientLinear const   *)(& z->gradient);
#line 530
  pixstride = (render->n_chan + 1) * (render->depth >> 3);
#line 532
  width = render->x1 - render->x0;
#line 535
  n_stops = (int )gradient->n_stops;
#line 536
  stops = (ArtGradientStop *)gradient->stops;
#line 537
  bufp = render->image_buf;
#line 538
  spread = (ArtGradientSpread )gradient->spread;
#line 540
  offset = (double )(((double const   )render->x0 * gradient->a + (double const   )y * gradient->b) + gradient->c);
#line 541
  d_offset = (double )gradient->a;
#line 543
  x = 0;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (x < width)) {
#line 543
      goto while_break;
    }
#line 545
    if ((unsigned int )spread == 0U) {
#line 546
      actual_offset = offset;
    } else
#line 547
    if ((unsigned int )spread == 2U) {
      {
#line 548
      tmp = floor(offset);
#line 548
      actual_offset = offset - tmp;
      }
    } else {
      {
#line 553
      tmp___1 = floor(0.5 * offset);
#line 553
      tmp___0 = offset - (double )2 * tmp___1;
      }
#line 554
      if (tmp___0 > (double )1) {
#line 554
        actual_offset = (double )2 - tmp___0;
      } else {
#line 554
        actual_offset = tmp___0;
      }
    }
    {
#line 556
    art_render_gradient_setpix(render, bufp, n_stops, stops, actual_offset);
#line 557
    offset += d_offset;
#line 558
    bufp += pixstride;
#line 543
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_negotiate(ArtImageSource *self , ArtRender *render ,
                                                 ArtImageSourceFlags *p_flags , int *p_buf_depth ,
                                                 ArtAlphaType *p_alpha ) 
{ 


  {
#line 567
  if (render->depth == 8) {
#line 567
    if (render->n_chan == 3) {
#line 570
      self->super.render = & art_render_gradient_linear_render_8;
#line 571
      *p_flags = (ArtImageSourceFlags )0;
#line 572
      *p_buf_depth = 8;
#line 573
      *p_alpha = (ArtAlphaType )2;
#line 574
      return;
    }
  }
#line 577
  self->super.render = & art_render_gradient_linear_render;
#line 578
  *p_flags = (ArtImageSourceFlags )0;
#line 579
  *p_buf_depth = render->depth;
#line 580
  *p_alpha = (ArtAlphaType )2;
#line 581
  return;
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
void art_render_gradient_linear(ArtRender *render , ArtGradientLinear const   *gradient ,
                                ArtFilterLevel level ) 
{ 
  ArtImageSourceGradLin *image_source ;
  void *tmp ;

  {
  {
#line 596
  tmp = art_alloc(sizeof(ArtImageSourceGradLin ) + sizeof(ArtGradientStop ) * (unsigned long )(gradient->n_stops - 1));
#line 596
  image_source = (ArtImageSourceGradLin *)tmp;
#line 599
  image_source->super.super.render = (void (*)(ArtRenderCallback *self , ArtRender *render ,
                                               art_u8 *dest , int y ))((void *)0);
#line 600
  image_source->super.super.done = & art_render_gradient_linear_done;
#line 601
  image_source->super.negotiate = & art_render_gradient_linear_negotiate;
#line 604
  image_source->gradient = (ArtGradientLinear )*gradient;
#line 605
  image_source->gradient.stops = image_source->stops;
#line 606
  memcpy((void */* __restrict  */)image_source->gradient.stops, (void const   */* __restrict  */)gradient->stops,
         sizeof(ArtGradientStop ) * (unsigned long )gradient->n_stops);
#line 608
  art_render_add_image_source(render, & image_source->super);
  }
#line 609
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_done(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 614
  art_free((void *)self);
  }
#line 615
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_render(ArtRenderCallback *self , ArtRender *render ,
                                              art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradRad *z ;
  ArtGradientRadial const   *gradient ;
  int pixstride ;
  int x ;
  int x0 ;
  int width ;
  int n_stops ;
  ArtGradientStop *stops ;
  art_u8 *bufp ;
  double fx ;
  double fy ;
  double dx ;
  double dy ;
  double const   *affine ;
  double aff0 ;
  double aff1 ;
  double a ;
  double arecip ;
  double b ;
  double db ;
  double c ;
  double dc ;
  double ddc ;
  double b_a ;
  double db_a ;
  double rad ;
  double drad ;
  double ddrad ;
  double z___0 ;
  double tmp ;

  {
#line 621
  z = (ArtImageSourceGradRad *)self;
#line 622
  gradient = (ArtGradientRadial const   *)(& z->gradient);
#line 623
  pixstride = (render->n_chan + 1) * (render->depth >> 3);
#line 625
  x0 = render->x0;
#line 626
  width = render->x1 - x0;
#line 627
  n_stops = (int )gradient->n_stops;
#line 628
  stops = (ArtGradientStop *)gradient->stops;
#line 629
  bufp = render->image_buf;
#line 630
  fx = (double )gradient->fx;
#line 631
  fy = (double )gradient->fy;
#line 633
  affine = (double const   *)(gradient->affine);
#line 634
  aff0 = (double )*(affine + 0);
#line 635
  aff1 = (double )*(affine + 1);
#line 636
  a = z->a;
#line 637
  arecip = 1.0 / a;
#line 643
  dx = (((double )x0 * aff0 + (double )((double const   )y * *(affine + 2))) + (double )*(affine + 4)) - fx;
#line 644
  dy = (((double )x0 * aff1 + (double )((double const   )y * *(affine + 3))) + (double )*(affine + 5)) - fy;
#line 645
  b = dx * fx + dy * fy;
#line 646
  db = aff0 * fx + aff1 * fy;
#line 647
  c = dx * dx + dy * dy;
#line 648
  dc = ((((double )2 * aff0) * dx + aff0 * aff0) + ((double )2 * aff1) * dy) + aff1 * aff1;
#line 649
  ddc = ((double )2 * aff0) * aff0 + ((double )2 * aff1) * aff1;
#line 651
  b_a = b * arecip;
#line 652
  db_a = db * arecip;
#line 654
  rad = b_a * b_a + c * arecip;
#line 655
  drad = (((double )2 * b_a) * db_a + db_a * db_a) + dc * arecip;
#line 656
  ddrad = ((double )2 * db_a) * db_a + ddc * arecip;
#line 658
  x = 0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (x < width)) {
#line 658
      goto while_break;
    }
#line 662
    if (rad > (double )0) {
      {
#line 663
      tmp = sqrt(rad);
#line 663
      z___0 = b_a + tmp;
      }
    } else {
#line 665
      z___0 = b_a;
    }
    {
#line 666
    art_render_gradient_setpix(render, bufp, n_stops, stops, z___0);
#line 667
    bufp += pixstride;
#line 668
    b_a += db_a;
#line 669
    rad += drad;
#line 670
    drad += ddrad;
#line 658
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_negotiate(ArtImageSource *self , ArtRender *render ,
                                                 ArtImageSourceFlags *p_flags , int *p_buf_depth ,
                                                 ArtAlphaType *p_alpha ) 
{ 


  {
#line 679
  self->super.render = & art_render_gradient_radial_render;
#line 680
  *p_flags = (ArtImageSourceFlags )0;
#line 681
  *p_buf_depth = render->depth;
#line 682
  *p_alpha = (ArtAlphaType )2;
#line 683
  return;
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
void art_render_gradient_radial(ArtRender *render , ArtGradientRadial const   *gradient ,
                                ArtFilterLevel level ) 
{ 
  ArtImageSourceGradRad *image_source ;
  void *tmp ;
  double fx ;
  double fy ;

  {
  {
#line 698
  tmp = art_alloc(sizeof(ArtImageSourceGradRad ) + sizeof(ArtGradientStop ) * (unsigned long )(gradient->n_stops - 1));
#line 698
  image_source = (ArtImageSourceGradRad *)tmp;
#line 700
  fx = (double )gradient->fx;
#line 701
  fy = (double )gradient->fy;
#line 703
  image_source->super.super.render = (void (*)(ArtRenderCallback *self , ArtRender *render ,
                                               art_u8 *dest , int y ))((void *)0);
#line 704
  image_source->super.super.done = & art_render_gradient_radial_done;
#line 705
  image_source->super.negotiate = & art_render_gradient_radial_negotiate;
#line 708
  image_source->gradient = (ArtGradientRadial )*gradient;
#line 709
  image_source->gradient.stops = image_source->stops;
#line 710
  memcpy((void */* __restrict  */)image_source->gradient.stops, (void const   */* __restrict  */)gradient->stops,
         sizeof(ArtGradientStop ) * (unsigned long )gradient->n_stops);
#line 713
  image_source->a = ((double )1 - fx * fx) - fy * fy;
#line 715
  art_render_add_image_source(render, & image_source->super);
  }
#line 716
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.h"
void art_rgb_svp_aa(ArtSVP const   *svp , int x0 , int y0 , int x1 , int y1 , art_u32 fg_color ,
                    art_u32 bg_color , art_u8 *buf , int rowstride , ArtAlphaGamma *alphagamma ) ;
#line 44
void art_rgb_svp_alpha(ArtSVP const   *svp , int x0 , int y0 , int x1 , int y1 , art_u32 rgba ,
                       art_u8 *buf , int rowstride , ArtAlphaGamma *alphagamma ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb.h"
void art_rgb_fill_run(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int n ) ;
#line 36
void art_rgb_run_alpha(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int alpha ,
                       int n ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_callback(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                 int n_steps ) 
{ 
  ArtRgbSVPData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  art_u32 rgb ;
  int x0 ;
  int x1 ;
  int k ;

  {
#line 51
  data = (ArtRgbSVPData *)callback_data;
#line 54
  running_sum = (art_u32 )start;
#line 59
  linebuf = data->buf;
#line 60
  x0 = data->x0;
#line 61
  x1 = data->x1;
#line 63
  if (n_steps > 0) {
#line 65
    run_x1 = (steps + 0)->x;
#line 66
    if (run_x1 > x0) {
      {
#line 68
      rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 69
      art_rgb_fill_run(linebuf, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                       (art_u8 )(rgb & 255U), run_x1 - x0);
      }
    }
#line 74
    k = 0;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! (k < n_steps - 1)) {
#line 74
        goto while_break;
      }
#line 76
      running_sum += (art_u32 )(steps + k)->delta;
#line 77
      run_x0 = run_x1;
#line 78
      run_x1 = (steps + (k + 1))->x;
#line 79
      if (run_x1 > run_x0) {
        {
#line 81
        rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 82
        art_rgb_fill_run(linebuf + (run_x0 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                         (art_u8 )(rgb & 255U), run_x1 - run_x0);
        }
      }
#line 74
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 87
    running_sum += (art_u32 )(steps + k)->delta;
#line 88
    if (x1 > run_x1) {
      {
#line 90
      rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 91
      art_rgb_fill_run(linebuf + (run_x1 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                       (art_u8 )(rgb & 255U), x1 - run_x1);
      }
    }
  } else {
    {
#line 98
    rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 99
    art_rgb_fill_run(linebuf, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                     (art_u8 )(rgb & 255U), x1 - x0);
    }
  }
#line 104
  data->buf += data->rowstride;
#line 105
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
void art_rgb_svp_aa(ArtSVP const   *svp , int x0 , int y0 , int x1 , int y1 , art_u32 fg_color ,
                    art_u32 bg_color , art_u8 *buf , int rowstride , ArtAlphaGamma *alphagamma ) 
{ 
  ArtRgbSVPData data ;
  int r_fg ;
  int g_fg ;
  int b_fg ;
  int r_bg ;
  int g_bg ;
  int b_bg ;
  int r ;
  int g ;
  int b ;
  int dr ;
  int dg ;
  int db ;
  int i ;
  int *table ;
  art_u8 *invtab ;

  {
#line 153
  if ((unsigned long )alphagamma == (unsigned long )((void *)0)) {
#line 155
    r_fg = (int )(fg_color >> 16);
#line 156
    g_fg = (int )((fg_color >> 8) & 255U);
#line 157
    b_fg = (int )(fg_color & 255U);
#line 159
    r_bg = (int )(bg_color >> 16);
#line 160
    g_bg = (int )((bg_color >> 8) & 255U);
#line 161
    b_bg = (int )(bg_color & 255U);
#line 163
    r = (r_bg << 16) + 32768;
#line 164
    g = (g_bg << 16) + 32768;
#line 165
    b = (b_bg << 16) + 32768;
#line 166
    dr = ((r_fg - r_bg) << 16) / 255;
#line 167
    dg = ((g_fg - g_bg) << 16) / 255;
#line 168
    db = ((b_fg - b_bg) << 16) / 255;
#line 170
    i = 0;
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 170
      if (! (i < 256)) {
#line 170
        goto while_break;
      }
#line 172
      data.rgbtab[i] = (art_u32 )(((r & 16711680) | ((g & 16711680) >> 8)) | (b >> 16));
#line 173
      r += dr;
#line 174
      g += dg;
#line 175
      b += db;
#line 170
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 183
    table = alphagamma->table;
#line 185
    r_fg = *(table + (fg_color >> 16));
#line 186
    g_fg = *(table + ((fg_color >> 8) & 255U));
#line 187
    b_fg = *(table + (fg_color & 255U));
#line 189
    r_bg = *(table + (bg_color >> 16));
#line 190
    g_bg = *(table + ((bg_color >> 8) & 255U));
#line 191
    b_bg = *(table + (bg_color & 255U));
#line 193
    r = (r_bg << 16) + 32768;
#line 194
    g = (g_bg << 16) + 32768;
#line 195
    b = (b_bg << 16) + 32768;
#line 196
    dr = ((r_fg - r_bg) << 16) / 255;
#line 197
    dg = ((g_fg - g_bg) << 16) / 255;
#line 198
    db = ((b_fg - b_bg) << 16) / 255;
#line 200
    invtab = alphagamma->invtable;
#line 201
    i = 0;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! (i < 256)) {
#line 201
        goto while_break___0;
      }
#line 203
      data.rgbtab[i] = (art_u32 )((((int )*(invtab + (r >> 16)) << 16) | ((int )*(invtab + (g >> 16)) << 8)) | (int )*(invtab + (b >> 16)));
#line 206
      r += dr;
#line 207
      g += dg;
#line 208
      b += db;
#line 201
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 211
  data.buf = buf;
#line 212
  data.rowstride = rowstride;
#line 213
  data.x0 = x0;
#line 214
  data.x1 = x1;
#line 215
  art_svp_render_aa(svp, x0, y0, x1, y1, & art_rgb_svp_callback, (void *)(& data));
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_alpha_callback(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                       int n_steps ) 
{ 
  ArtRgbSVPAlphaData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int k ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int *alphatab ;
  int alpha ;

  {
#line 222
  data = (ArtRgbSVPAlphaData *)callback_data;
#line 225
  running_sum = (art_u32 )start;
#line 232
  linebuf = data->buf;
#line 233
  x0 = data->x0;
#line 234
  x1 = data->x1;
#line 236
  r = data->r;
#line 237
  g = data->g;
#line 238
  b = data->b;
#line 239
  alphatab = data->alphatab;
#line 241
  if (n_steps > 0) {
#line 243
    run_x1 = (steps + 0)->x;
#line 244
    if (run_x1 > x0) {
#line 246
      alpha = (int )((running_sum >> 16) & 255U);
#line 247
      if (alpha) {
        {
#line 248
        art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), run_x1 - x0);
        }
      }
    }
#line 253
    k = 0;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (! (k < n_steps - 1)) {
#line 253
        goto while_break;
      }
#line 255
      running_sum += (art_u32 )(steps + k)->delta;
#line 256
      run_x0 = run_x1;
#line 257
      run_x1 = (steps + (k + 1))->x;
#line 258
      if (run_x1 > run_x0) {
#line 260
        alpha = (int )((running_sum >> 16) & 255U);
#line 261
        if (alpha) {
          {
#line 262
          art_rgb_run_alpha(linebuf + (run_x0 - x0) * 3, r, g, b, *(alphatab + alpha),
                            run_x1 - run_x0);
          }
        }
      }
#line 253
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 267
    running_sum += (art_u32 )(steps + k)->delta;
#line 268
    if (x1 > run_x1) {
#line 270
      alpha = (int )((running_sum >> 16) & 255U);
#line 271
      if (alpha) {
        {
#line 272
        art_rgb_run_alpha(linebuf + (run_x1 - x0) * 3, r, g, b, *(alphatab + alpha),
                          x1 - run_x1);
        }
      }
    }
  } else {
#line 279
    alpha = (int )((running_sum >> 16) & 255U);
#line 280
    if (alpha) {
      {
#line 281
      art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), x1 - x0);
      }
    }
  }
#line 286
  data->buf += data->rowstride;
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_alpha_opaque_callback(void *callback_data , int y , int start ,
                                              ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtRgbSVPAlphaData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int k ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int *alphatab ;
  int alpha ;

  {
#line 294
  data = (ArtRgbSVPAlphaData *)callback_data;
#line 297
  running_sum = (art_u32 )start;
#line 304
  linebuf = data->buf;
#line 305
  x0 = data->x0;
#line 306
  x1 = data->x1;
#line 308
  r = data->r;
#line 309
  g = data->g;
#line 310
  b = data->b;
#line 311
  alphatab = data->alphatab;
#line 313
  if (n_steps > 0) {
#line 315
    run_x1 = (steps + 0)->x;
#line 316
    if (run_x1 > x0) {
#line 318
      alpha = (int )(running_sum >> 16);
#line 319
      if (alpha) {
#line 321
        if (alpha >= 255) {
          {
#line 322
          art_rgb_fill_run(linebuf, r, g, b, run_x1 - x0);
          }
        } else {
          {
#line 326
          art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), run_x1 - x0);
          }
        }
      }
    }
#line 332
    k = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (! (k < n_steps - 1)) {
#line 332
        goto while_break;
      }
#line 334
      running_sum += (art_u32 )(steps + k)->delta;
#line 335
      run_x0 = run_x1;
#line 336
      run_x1 = (steps + (k + 1))->x;
#line 337
      if (run_x1 > run_x0) {
#line 339
        alpha = (int )(running_sum >> 16);
#line 340
        if (alpha) {
#line 342
          if (alpha >= 255) {
            {
#line 343
            art_rgb_fill_run(linebuf + (run_x0 - x0) * 3, r, g, b, run_x1 - run_x0);
            }
          } else {
            {
#line 347
            art_rgb_run_alpha(linebuf + (run_x0 - x0) * 3, r, g, b, *(alphatab + alpha),
                              run_x1 - run_x0);
            }
          }
        }
      }
#line 332
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 353
    running_sum += (art_u32 )(steps + k)->delta;
#line 354
    if (x1 > run_x1) {
#line 356
      alpha = (int )(running_sum >> 16);
#line 357
      if (alpha) {
#line 359
        if (alpha >= 255) {
          {
#line 360
          art_rgb_fill_run(linebuf + (run_x1 - x0) * 3, r, g, b, x1 - run_x1);
          }
        } else {
          {
#line 364
          art_rgb_run_alpha(linebuf + (run_x1 - x0) * 3, r, g, b, *(alphatab + alpha),
                            x1 - run_x1);
          }
        }
      }
    }
  } else {
#line 372
    alpha = (int )(running_sum >> 16);
#line 373
    if (alpha) {
#line 375
      if (alpha >= 255) {
        {
#line 376
        art_rgb_fill_run(linebuf, r, g, b, x1 - x0);
        }
      } else {
        {
#line 380
        art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), x1 - x0);
        }
      }
    }
  }
#line 386
  data->buf += data->rowstride;
#line 387
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
void art_rgb_svp_alpha(ArtSVP const   *svp , int x0 , int y0 , int x1 , int y1 , art_u32 rgba ,
                       art_u8 *buf , int rowstride , ArtAlphaGamma *alphagamma ) 
{ 
  ArtRgbSVPAlphaData data ;
  int r ;
  int g ;
  int b ;
  int alpha ;
  int i ;
  int a ;
  int da ;

  {
#line 428
  r = (int )(rgba >> 24);
#line 429
  g = (int )((rgba >> 16) & 255U);
#line 430
  b = (int )((rgba >> 8) & 255U);
#line 431
  alpha = (int )(rgba & 255U);
#line 433
  data.r = (art_u8 )r;
#line 434
  data.g = (art_u8 )g;
#line 435
  data.b = (art_u8 )b;
#line 436
  data.alpha = (art_u8 )alpha;
#line 438
  a = 32768;
#line 439
  da = (alpha * 66051 + 128) >> 8;
#line 441
  i = 0;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (i < 256)) {
#line 441
      goto while_break;
    }
#line 443
    data.alphatab[i] = a >> 16;
#line 444
    a += da;
#line 441
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  data.buf = buf;
#line 448
  data.rowstride = rowstride;
#line 449
  data.x0 = x0;
#line 450
  data.x1 = x1;
#line 451
  if (alpha == 255) {
    {
#line 452
    art_svp_render_aa(svp, x0, y0, x1, y1, & art_rgb_svp_alpha_opaque_callback, (void *)(& data));
    }
  } else {
    {
#line 455
    art_svp_render_aa(svp, x0, y0, x1, y1, & art_rgb_svp_alpha_callback, (void *)(& data));
    }
  }
#line 456
  return;
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb.c"
void art_rgb_fill_run(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int n ) 
{ 
  int i ;
  unsigned int v1 ;
  unsigned int v2 ;
  unsigned int v3 ;
  art_u8 *tmp ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;
  art_u8 *tmp___3 ;
  art_u8 *tmp___4 ;
  art_u8 *tmp___5 ;
  art_u8 *tmp___6 ;
  art_u8 *tmp___7 ;

  {
#line 95
  if ((int )r == (int )g) {
#line 95
    if ((int )g == (int )b) {
      {
#line 97
      memset((void *)buf, (int )g, (size_t )((n + n) + n));
      }
    } else {
#line 95
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 101
  if (n < 8) {
#line 103
    i = 0;
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! (i < n)) {
#line 103
        goto while_break;
      }
#line 105
      tmp = buf;
#line 105
      buf ++;
#line 105
      *tmp = r;
#line 106
      tmp___0 = buf;
#line 106
      buf ++;
#line 106
      *tmp___0 = g;
#line 107
      tmp___1 = buf;
#line 107
      buf ++;
#line 107
      *tmp___1 = b;
#line 103
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 113
    i = 0;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! ((unsigned long )buf & 3UL)) {
#line 113
        goto while_break___0;
      }
#line 115
      tmp___2 = buf;
#line 115
      buf ++;
#line 115
      *tmp___2 = r;
#line 116
      tmp___3 = buf;
#line 116
      buf ++;
#line 116
      *tmp___3 = g;
#line 117
      tmp___4 = buf;
#line 117
      buf ++;
#line 117
      *tmp___4 = b;
#line 113
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 120
    v1 = (unsigned int )((((int )r | ((int )g << 8)) | ((int )b << 16)) | ((int )r << 24));
#line 121
    v3 = (v1 << 8) | (unsigned int )b;
#line 122
    v2 = (v3 << 8) | (unsigned int )g;
    {
#line 128
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 128
      if (! (i < n - 3)) {
#line 128
        goto while_break___1;
      }
#line 130
      *((art_u32 *)buf + 0) = v1;
#line 131
      *((art_u32 *)buf + 1) = v2;
#line 132
      *((art_u32 *)buf + 2) = v3;
#line 133
      buf += 12;
#line 128
      i += 4;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 136
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 136
      if (! (i < n)) {
#line 136
        goto while_break___2;
      }
#line 138
      tmp___5 = buf;
#line 138
      buf ++;
#line 138
      *tmp___5 = r;
#line 139
      tmp___6 = buf;
#line 139
      buf ++;
#line 139
      *tmp___6 = g;
#line 140
      tmp___7 = buf;
#line 140
      buf ++;
#line 140
      *tmp___7 = b;
#line 136
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 144
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb.c"
void art_rgb_run_alpha(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int alpha ,
                       int n ) 
{ 
  int i ;
  int v ;
  art_u8 *tmp ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;

  {
#line 165
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < n)) {
#line 165
      goto while_break;
    }
#line 167
    v = (int )*buf;
#line 168
    tmp = buf;
#line 168
    buf ++;
#line 168
    *tmp = (art_u8 )(v + ((((int )r - v) * alpha + 128) >> 8));
#line 169
    v = (int )*buf;
#line 170
    tmp___0 = buf;
#line 170
    buf ++;
#line 170
    *tmp___0 = (art_u8 )(v + ((((int )g - v) * alpha + 128) >> 8));
#line 171
    v = (int )*buf;
#line 172
    tmp___1 = buf;
#line 172
    buf ++;
#line 172
    *tmp___1 = (art_u8 )(v + ((((int )b - v) * alpha + 128) >> 8));
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.h"
ArtVpath *art_vpath_from_svp(ArtSVP const   *svp ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
static int art_vpath_svp_point_compare(double x1 , double y1 , double x2 , double y2 ) 
{ 


  {
#line 44
  if (y1 - 1e-6 > y2) {
#line 44
    return (1);
  }
#line 45
  if (y1 + 1e-6 < y2) {
#line 45
    return (-1);
  }
#line 46
  if (x1 - 1e-6 > x2) {
#line 46
    return (1);
  }
#line 47
  if (x1 + 1e-6 < x2) {
#line 47
    return (-1);
  }
#line 48
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
static int art_vpath_svp_compare(void const   *s1 , void const   *s2 ) 
{ 
  ArtVpathSVPEnd const   *e1 ;
  ArtVpathSVPEnd const   *e2 ;
  int tmp ;

  {
  {
#line 54
  e1 = (ArtVpathSVPEnd const   *)s1;
#line 55
  e2 = (ArtVpathSVPEnd const   *)s2;
#line 57
  tmp = art_vpath_svp_point_compare((double )e1->x, (double )e1->y, (double )e2->x,
                                    (double )e2->y);
  }
#line 57
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
ArtVpath *art_vpath_from_svp(ArtSVP const   *svp ) 
{ 
  int n_segs ;
  ArtVpathSVPEnd *ends ;
  ArtVpath *new ;
  int *visited ;
  int n_new ;
  int n_new_max ;
  int i ;
  int k ;
  int j ;
  int seg_num ;
  int first ;
  double last_x ;
  double last_y ;
  int n_points ;
  int pt_num ;
  void *tmp ;
  int lastpt ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 86
  n_segs = (int )svp->n_segs;
#line 92
  j = 0;
#line 99
  last_x = (double )0;
#line 100
  last_y = (double )0;
#line 102
  tmp = art_alloc((unsigned long )(n_segs * 2) * sizeof(ArtVpathSVPEnd ));
#line 102
  ends = (ArtVpathSVPEnd *)tmp;
#line 103
  i = 0;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < (int )svp->n_segs)) {
#line 103
      goto while_break;
    }
#line 107
    (ends + i * 2)->seg_num = i;
#line 108
    (ends + i * 2)->which = 0;
#line 109
    (ends + i * 2)->x = (svp->segs[i].points + 0)->x;
#line 110
    (ends + i * 2)->y = (svp->segs[i].points + 0)->y;
#line 112
    lastpt = (int )(svp->segs[i].n_points - 1);
#line 113
    (ends + (i * 2 + 1))->seg_num = i;
#line 114
    (ends + (i * 2 + 1))->which = 1;
#line 115
    (ends + (i * 2 + 1))->x = (svp->segs[i].points + lastpt)->x;
#line 116
    (ends + (i * 2 + 1))->y = (svp->segs[i].points + lastpt)->y;
#line 103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  qsort((void *)ends, (size_t )(n_segs * 2), sizeof(ArtVpathSVPEnd ), & art_vpath_svp_compare);
#line 120
  n_new = 0;
#line 121
  n_new_max = 16;
#line 123
  tmp___0 = art_alloc((unsigned long )n_new_max * sizeof(ArtVpath ));
#line 123
  new = (ArtVpath *)tmp___0;
#line 125
  tmp___1 = art_alloc((unsigned long )n_segs * sizeof(int ));
#line 125
  visited = (int *)tmp___1;
#line 126
  i = 0;
  }
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! (i < n_segs)) {
#line 126
      goto while_break___0;
    }
#line 127
    *(visited + i) = 0;
#line 126
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 129
  first = 1;
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (i < n_segs)) {
#line 130
      goto while_break___1;
    }
#line 132
    if (! first) {
#line 136
      j = 0;
      {
#line 136
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 136
        if (! (j < n_segs * 2)) {
#line 136
          goto while_break___2;
        }
#line 138
        if (! *(visited + (ends + j)->seg_num)) {
          {
#line 138
          tmp___2 = art_vpath_svp_point_compare(last_x, last_y, (ends + j)->x, (ends + j)->y);
          }
#line 138
          if (tmp___2 == 0) {
#line 141
            goto while_break___2;
          }
        }
#line 136
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 143
      if (j == n_segs * 2) {
#line 144
        first = 1;
      }
    }
#line 146
    if (first) {
#line 149
      j = 0;
      {
#line 149
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 149
        if (! (j < n_segs * 2)) {
#line 149
          goto while_break___3;
        }
#line 150
        if (! *(visited + (ends + j)->seg_num)) {
#line 151
          goto while_break___3;
        }
#line 149
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 153
    if (j == n_segs * 2) {
      {
#line 155
      printf((char const   */* __restrict  */)"failure\n");
      }
    }
#line 157
    seg_num = (ends + j)->seg_num;
#line 158
    n_points = (int )svp->segs[seg_num].n_points;
#line 159
    k = 0;
    {
#line 159
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 159
      if (! (k < n_points)) {
#line 159
        goto while_break___4;
      }
#line 161
      if (svp->segs[seg_num].dir) {
#line 161
        pt_num = k;
      } else {
#line 161
        pt_num = n_points - (1 + k);
      }
#line 162
      if (k == 0) {
#line 164
        if (first) {
          {
#line 166
          art_vpath_add_point(& new, & n_new, & n_new_max, (ArtPathcode )0, (svp->segs[seg_num].points + pt_num)->x,
                              (svp->segs[seg_num].points + pt_num)->y);
          }
        }
      } else {
        {
#line 174
        art_vpath_add_point(& new, & n_new, & n_new_max, (ArtPathcode )3, (svp->segs[seg_num].points + pt_num)->x,
                            (svp->segs[seg_num].points + pt_num)->y);
        }
#line 178
        if (k == n_points - 1) {
#line 180
          last_x = (svp->segs[seg_num].points + pt_num)->x;
#line 181
          last_y = (svp->segs[seg_num].points + pt_num)->y;
        }
      }
#line 186
      first = 0;
#line 159
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 188
    *(visited + seg_num) = 1;
#line 130
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 191
  art_vpath_add_point(& new, & n_new, & n_new_max, (ArtPathcode )4, (double )0, (double )0);
#line 193
  art_free((void *)visited);
#line 194
  art_free((void *)ends);
  }
#line 195
  return (new);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_affine_private.h"
void art_rgb_affine_run(int *p_x0 , int *p_x1 , int y , int src_width , int src_height ,
                        double const   *affine ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_affine_private.c"
void art_rgb_affine_run(int *p_x0 , int *p_x1 , int y , int src_width , int src_height ,
                        double const   *affine ) 
{ 
  int x0 ;
  int x1 ;
  double z ;
  double x_intercept ;
  int xi ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 52
  x0 = *p_x0;
#line 53
  x1 = *p_x1;
#line 56
  if (*(affine + 0) > (double const   )1e-6) {
    {
#line 58
    z = (double )(*(affine + 2) * (double const   )((double )y + 0.5) + *(affine + 4));
#line 59
    x_intercept = - z / (double )*(affine + 0);
#line 60
    tmp = ceil((x_intercept + 1e-6) - 0.5);
#line 60
    xi = (int )tmp;
    }
#line 61
    if (xi > x0) {
#line 62
      x0 = xi;
    }
    {
#line 63
    x_intercept = (- z + (double )src_width) / (double )*(affine + 0);
#line 64
    tmp___0 = ceil((x_intercept - 1e-6) - 0.5);
#line 64
    xi = (int )tmp___0;
    }
#line 65
    if (xi < x1) {
#line 66
      x1 = xi;
    }
  } else
#line 68
  if (*(affine + 0) < (double const   )(- 1e-6)) {
    {
#line 70
    z = (double )(*(affine + 2) * (double const   )((double )y + 0.5) + *(affine + 4));
#line 71
    x_intercept = (- z + (double )src_width) / (double )*(affine + 0);
#line 72
    tmp___1 = ceil((x_intercept + 1e-6) - 0.5);
#line 72
    xi = (int )tmp___1;
    }
#line 73
    if (xi > x0) {
#line 74
      x0 = xi;
    }
    {
#line 75
    x_intercept = - z / (double )*(affine + 0);
#line 76
    tmp___2 = ceil((x_intercept - 1e-6) - 0.5);
#line 76
    xi = (int )tmp___2;
    }
#line 77
    if (xi < x1) {
#line 78
      x1 = xi;
    }
  } else {
#line 82
    z = (double )(*(affine + 2) * (double const   )((double )y + 0.5) + *(affine + 4));
#line 83
    if (z < (double )0) {
#line 85
      *p_x1 = *p_x0;
#line 86
      return;
    } else
#line 83
    if (z >= (double )src_width) {
#line 85
      *p_x1 = *p_x0;
#line 86
      return;
    }
  }
#line 91
  if (*(affine + 1) > (double const   )1e-6) {
    {
#line 93
    z = (double )(*(affine + 3) * (double const   )((double )y + 0.5) + *(affine + 5));
#line 94
    x_intercept = - z / (double )*(affine + 1);
#line 95
    tmp___3 = ceil((x_intercept + 1e-6) - 0.5);
#line 95
    xi = (int )tmp___3;
    }
#line 96
    if (xi > x0) {
#line 97
      x0 = xi;
    }
    {
#line 98
    x_intercept = (- z + (double )src_height) / (double )*(affine + 1);
#line 99
    tmp___4 = ceil((x_intercept - 1e-6) - 0.5);
#line 99
    xi = (int )tmp___4;
    }
#line 100
    if (xi < x1) {
#line 101
      x1 = xi;
    }
  } else
#line 103
  if (*(affine + 1) < (double const   )(- 1e-6)) {
    {
#line 105
    z = (double )(*(affine + 3) * (double const   )((double )y + 0.5) + *(affine + 5));
#line 106
    x_intercept = (- z + (double )src_height) / (double )*(affine + 1);
#line 107
    tmp___5 = ceil((x_intercept + 1e-6) - 0.5);
#line 107
    xi = (int )tmp___5;
    }
#line 108
    if (xi > x0) {
#line 109
      x0 = xi;
    }
    {
#line 110
    x_intercept = - z / (double )*(affine + 1);
#line 111
    tmp___6 = ceil((x_intercept - 1e-6) - 0.5);
#line 111
    xi = (int )tmp___6;
    }
#line 112
    if (xi < x1) {
#line 113
      x1 = xi;
    }
  } else {
#line 117
    z = (double )(*(affine + 3) * (double const   )((double )y + 0.5) + *(affine + 5));
#line 118
    if (z < (double )0) {
#line 120
      *p_x1 = *p_x0;
#line 121
      return;
    } else
#line 118
    if (z >= (double )src_height) {
#line 120
      *p_x1 = *p_x0;
#line 121
      return;
    }
  }
#line 125
  *p_x0 = x0;
#line 126
  *p_x1 = x1;
#line 127
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
void art_drect_copy(ArtDRect *dest , ArtDRect const   *src ) ;
#line 58
void art_drect_union(ArtDRect *dest , ArtDRect const   *src1 , ArtDRect const   *src2 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect_svp.h"
void art_drect_svp(ArtDRect *bbox , ArtSVP const   *svp ) ;
#line 40
void art_drect_svp_union(ArtDRect *bbox , ArtSVP const   *svp ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect_svp.c"
void art_drect_svp(ArtDRect *bbox , ArtSVP const   *svp ) 
{ 
  int i ;

  {
#line 47
  if (svp->n_segs == 0) {
#line 49
    bbox->x0 = (double )0;
#line 50
    bbox->y0 = (double )0;
#line 51
    bbox->x1 = (double )0;
#line 52
    bbox->y1 = (double )0;
#line 53
    return;
  }
  {
#line 56
  art_drect_copy(bbox, & svp->segs[0].bbox);
#line 58
  i = 1;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < (int )svp->n_segs)) {
#line 58
      goto while_break;
    }
#line 60
    if (bbox->x0 < (double )svp->segs[i].bbox.x0) {
#line 60
      bbox->x0 = bbox->x0;
    } else {
#line 60
      bbox->x0 = (double )svp->segs[i].bbox.x0;
    }
#line 61
    if (bbox->y0 < (double )svp->segs[i].bbox.y0) {
#line 61
      bbox->y0 = bbox->y0;
    } else {
#line 61
      bbox->y0 = (double )svp->segs[i].bbox.y0;
    }
#line 62
    if (bbox->x1 > (double )svp->segs[i].bbox.x1) {
#line 62
      bbox->x1 = bbox->x1;
    } else {
#line 62
      bbox->x1 = (double )svp->segs[i].bbox.x1;
    }
#line 63
    if (bbox->y1 > (double )svp->segs[i].bbox.y1) {
#line 63
      bbox->y1 = bbox->y1;
    } else {
#line 63
      bbox->y1 = (double )svp->segs[i].bbox.y1;
    }
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect_svp.c"
void art_drect_svp_union(ArtDRect *bbox , ArtSVP const   *svp ) 
{ 
  ArtDRect svp_bbox ;

  {
  {
#line 80
  art_drect_svp(& svp_bbox, svp);
#line 81
  art_drect_union(bbox, (ArtDRect const   *)bbox, (ArtDRect const   *)(& svp_bbox));
  }
#line 82
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  art_die)(char const   *fmt 
                                                                       , ...) ;
#line 90
void ( /* format attribute */  art_warn)(char const   *fmt  , ...) ;
#line 93
void ( /* format attribute */  art_dprint)(char const   *fmt  , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
 __attribute__((__noreturn__)) void ( /* format attribute */  art_die)(char const   *fmt 
                                                                       , ...) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
void ( /* format attribute */  art_die)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 42
  __builtin_va_start(ap, fmt);
#line 43
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 44
  __builtin_va_end(ap);
#line 45
  exit(1);
  }
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
void ( /* format attribute */  art_warn)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 59
  __builtin_va_start(ap, fmt);
#line 60
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 61
  __builtin_va_end(ap);
  }
#line 62
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
void ( /* format attribute */  art_dprint)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 75
  __builtin_va_start(ap, fmt);
#line 76
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 77
  __builtin_va_end(ap);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
void *art_alloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 82
  tmp = malloc(size);
  }
#line 82
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
void art_free(void *ptr ) 
{ 


  {
  {
#line 87
  free(ptr);
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_misc.c"
void *art_realloc(void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 92
  tmp = realloc(ptr, size);
  }
#line 92
  return (tmp);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
int art_svp_seg_compare(void const   *s1 , void const   *s2 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath.c"
static void reverse_points(ArtPoint *points , int n_points ) 
{ 
  int i ;
  ArtPoint tmp_p ;

  {
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < n_points >> 1)) {
#line 41
      goto while_break;
    }
#line 43
    tmp_p = *(points + i);
#line 44
    *(points + i) = *(points + (n_points - (i + 1)));
#line 45
    *(points + (n_points - (i + 1))) = tmp_p;
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath.c"
ArtSVP *art_svp_from_vpath(ArtVpath *vpath ) 
{ 
  int n_segs ;
  int n_segs_max ;
  ArtSVP *svp ;
  int dir ;
  int new_dir ;
  int i ;
  ArtPoint *points ;
  int n_points ;
  int n_points_max ;
  double x ;
  double y ;
  double x_min ;
  double x_max ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 79
  n_segs = 0;
#line 80
  n_segs_max = 16;
#line 81
  tmp = art_alloc(sizeof(ArtSVP ) + (unsigned long )(n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 81
  svp = (ArtSVP *)tmp;
#line 84
  dir = 0;
#line 85
  n_points = 0;
#line 86
  n_points_max = 0;
#line 87
  points = (ArtPoint *)((void *)0);
#line 88
  i = 0;
#line 90
  y = (double )0;
#line 90
  x = y;
#line 92
  x_max = (double )0;
#line 92
  x_min = x_max;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((unsigned int )(vpath + i)->code != 4U)) {
#line 94
      goto while_break;
    }
#line 95
    if ((unsigned int )(vpath + i)->code == 0U) {
#line 95
      goto _L;
    } else
#line 95
    if ((unsigned int )(vpath + i)->code == 1U) {
      _L: /* CIL Label */ 
#line 97
      if ((unsigned long )points != (unsigned long )((void *)0)) {
#line 97
        if (n_points >= 2) {
#line 99
          if (n_segs == n_segs_max) {
            {
#line 101
            n_segs_max <<= 1;
#line 102
            tmp___0 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 102
            svp = (ArtSVP *)tmp___0;
            }
          }
#line 106
          svp->segs[n_segs].n_points = n_points;
#line 107
          svp->segs[n_segs].dir = dir > 0;
#line 108
          if (dir < 0) {
            {
#line 109
            reverse_points(points, n_points);
            }
          }
#line 110
          svp->segs[n_segs].points = points;
#line 111
          svp->segs[n_segs].bbox.x0 = x_min;
#line 112
          svp->segs[n_segs].bbox.x1 = x_max;
#line 113
          svp->segs[n_segs].bbox.y0 = (points + 0)->y;
#line 114
          svp->segs[n_segs].bbox.y1 = (points + (n_points - 1))->y;
#line 115
          n_segs ++;
#line 116
          points = (ArtPoint *)((void *)0);
        }
      }
#line 119
      if ((unsigned long )points == (unsigned long )((void *)0)) {
        {
#line 121
        n_points_max = 4;
#line 122
        tmp___1 = art_alloc((unsigned long )n_points_max * sizeof(ArtPoint ));
#line 122
        points = (ArtPoint *)tmp___1;
        }
      }
#line 125
      n_points = 1;
#line 126
      x = (vpath + i)->x;
#line 126
      (points + 0)->x = x;
#line 127
      y = (vpath + i)->y;
#line 127
      (points + 0)->y = y;
#line 128
      x_min = x;
#line 129
      x_max = x;
#line 130
      dir = 0;
    } else {
#line 134
      if ((vpath + i)->y > y) {
#line 134
        new_dir = 1;
      } else
#line 134
      if ((vpath + i)->y == y) {
#line 134
        if ((vpath + i)->x > x) {
#line 134
          new_dir = 1;
        } else {
#line 134
          new_dir = -1;
        }
      } else {
#line 134
        new_dir = -1;
      }
#line 136
      if (dir) {
#line 136
        if (dir != new_dir) {
#line 139
          x = (points + (n_points - 1))->x;
#line 140
          y = (points + (n_points - 1))->y;
#line 141
          if (n_segs == n_segs_max) {
            {
#line 143
            n_segs_max <<= 1;
#line 144
            tmp___2 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 144
            svp = (ArtSVP *)tmp___2;
            }
          }
#line 148
          svp->segs[n_segs].n_points = n_points;
#line 149
          svp->segs[n_segs].dir = dir > 0;
#line 150
          if (dir < 0) {
            {
#line 151
            reverse_points(points, n_points);
            }
          }
          {
#line 152
          svp->segs[n_segs].points = points;
#line 153
          svp->segs[n_segs].bbox.x0 = x_min;
#line 154
          svp->segs[n_segs].bbox.x1 = x_max;
#line 155
          svp->segs[n_segs].bbox.y0 = (points + 0)->y;
#line 156
          svp->segs[n_segs].bbox.y1 = (points + (n_points - 1))->y;
#line 157
          n_segs ++;
#line 159
          n_points = 1;
#line 160
          n_points_max = 4;
#line 161
          tmp___3 = art_alloc((unsigned long )n_points_max * sizeof(ArtPoint ));
#line 161
          points = (ArtPoint *)tmp___3;
#line 162
          (points + 0)->x = x;
#line 163
          (points + 0)->y = y;
#line 164
          x_min = x;
#line 165
          x_max = x;
          }
        }
      }
#line 168
      if ((unsigned long )points != (unsigned long )((void *)0)) {
#line 170
        if (n_points == n_points_max) {
          {
#line 171
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 171
            if (n_points_max) {
              {
#line 171
              n_points_max <<= 1;
#line 171
              tmp___4 = art_realloc((void *)points, (unsigned long )n_points_max * sizeof(ArtPoint ));
#line 171
              points = (ArtPoint *)tmp___4;
              }
            } else {
              {
#line 171
              n_points_max = 1;
#line 171
              tmp___5 = art_alloc(sizeof(ArtPoint ));
#line 171
              points = (ArtPoint *)tmp___5;
              }
            }
#line 171
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 172
        x = (vpath + i)->x;
#line 172
        (points + n_points)->x = x;
#line 173
        y = (vpath + i)->y;
#line 173
        (points + n_points)->y = y;
#line 174
        if (x < x_min) {
#line 174
          x_min = x;
        } else
#line 175
        if (x > x_max) {
#line 175
          x_max = x;
        }
#line 176
        n_points ++;
      }
#line 178
      dir = new_dir;
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if ((unsigned long )points != (unsigned long )((void *)0)) {
#line 185
    if (n_points >= 2) {
#line 187
      if (n_segs == n_segs_max) {
        {
#line 189
        n_segs_max <<= 1;
#line 190
        tmp___6 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 190
        svp = (ArtSVP *)tmp___6;
        }
      }
#line 194
      svp->segs[n_segs].n_points = n_points;
#line 195
      svp->segs[n_segs].dir = dir > 0;
#line 196
      if (dir < 0) {
        {
#line 197
        reverse_points(points, n_points);
        }
      }
#line 198
      svp->segs[n_segs].points = points;
#line 199
      svp->segs[n_segs].bbox.x0 = x_min;
#line 200
      svp->segs[n_segs].bbox.x1 = x_max;
#line 201
      svp->segs[n_segs].bbox.y0 = (points + 0)->y;
#line 202
      svp->segs[n_segs].bbox.y1 = (points + (n_points - 1))->y;
#line 203
      n_segs ++;
    } else {
      {
#line 206
      art_free((void *)points);
      }
    }
  }
  {
#line 209
  svp->n_segs = n_segs;
#line 211
  qsort((void *)(& svp->segs), (size_t )n_segs, sizeof(ArtSVPSeg ), & art_svp_seg_compare);
  }
#line 213
  return (svp);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.h"
void art_affine_point(ArtPoint *dst , ArtPoint const   *src , double const   *affine ) ;
#line 37
void art_affine_invert(double *dst , double const   *src ) ;
#line 42
void art_affine_flip(double *dst_affine , double const   *src_affine , int horz ,
                     int vert ) ;
#line 46
void art_affine_to_string(char *str , double const   *src ) ;
#line 49
void art_affine_multiply(double *dst , double const   *src1 , double const   *src2 ) ;
#line 54
void art_affine_identity(double *dst ) ;
#line 58
void art_affine_scale(double *dst , double sx , double sy ) ;
#line 62
void art_affine_rotate(double *dst , double theta ) ;
#line 66
void art_affine_shear(double *dst , double theta ) ;
#line 70
void art_affine_translate(double *dst , double tx , double ty ) ;
#line 75
double art_affine_expansion(double const   *src ) ;
#line 81
int art_affine_rectilinear(double const   *src ) ;
#line 85
int art_affine_equal(double *matrix1 , double *matrix2 ) ;
#line 67 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_point(ArtPoint *dst , ArtPoint const   *src , double const   *affine ) 
{ 
  double x ;
  double y ;

  {
#line 49
  x = (double )src->x;
#line 50
  y = (double )src->y;
#line 51
  dst->x = (x * (double )*(affine + 0) + y * (double )*(affine + 2)) + (double )*(affine + 4);
#line 52
  dst->y = (x * (double )*(affine + 1) + y * (double )*(affine + 3)) + (double )*(affine + 5);
#line 53
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_invert(double *dst , double const   *src ) 
{ 
  double r_det ;

  {
#line 71
  r_det = 1.0 / (double )(*(src + 0) * *(src + 3) - *(src + 1) * *(src + 2));
#line 72
  *(dst + 0) = (double )(*(src + 3) * (double const   )r_det);
#line 73
  *(dst + 1) = (double )(- *(src + 1) * (double const   )r_det);
#line 74
  *(dst + 2) = (double )(- *(src + 2) * (double const   )r_det);
#line 75
  *(dst + 3) = (double )(*(src + 0) * (double const   )r_det);
#line 76
  *(dst + 4) = (double )(- *(src + 4) * (double const   )*(dst + 0) - *(src + 5) * (double const   )*(dst + 2));
#line 77
  *(dst + 5) = (double )(- *(src + 4) * (double const   )*(dst + 1) - *(src + 5) * (double const   )*(dst + 3));
#line 78
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_flip(double *dst_affine , double const   *src_affine , int horz ,
                     int vert ) 
{ 


  {
#line 95
  if (horz) {
#line 95
    *(dst_affine + 0) = (double )(- *(src_affine + 0));
  } else {
#line 95
    *(dst_affine + 0) = (double )*(src_affine + 0);
  }
#line 96
  if (horz) {
#line 96
    *(dst_affine + 1) = (double )(- *(src_affine + 1));
  } else {
#line 96
    *(dst_affine + 1) = (double )*(src_affine + 1);
  }
#line 97
  if (vert) {
#line 97
    *(dst_affine + 2) = (double )(- *(src_affine + 2));
  } else {
#line 97
    *(dst_affine + 2) = (double )*(src_affine + 2);
  }
#line 98
  if (vert) {
#line 98
    *(dst_affine + 3) = (double )(- *(src_affine + 3));
  } else {
#line 98
    *(dst_affine + 3) = (double )*(src_affine + 3);
  }
#line 99
  if (horz) {
#line 99
    *(dst_affine + 4) = (double )(- *(src_affine + 4));
  } else {
#line 99
    *(dst_affine + 4) = (double )*(src_affine + 4);
  }
#line 100
  if (vert) {
#line 100
    *(dst_affine + 5) = (double )(- *(src_affine + 5));
  } else {
#line 100
    *(dst_affine + 5) = (double )*(src_affine + 5);
  }
#line 101
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
static int art_ftoa(char *str , double x ) 
{ 
  char *p ;
  int i ;
  int j ;
  double tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int ix ;
  char *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;

  {
  {
#line 113
  p = (char *)str;
#line 116
  p = (char *)str;
#line 117
  tmp = fabs(x);
  }
#line 117
  if (tmp < 1e-6 / (double )2) {
    {
#line 119
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"0");
    }
#line 120
    return (1);
  }
#line 122
  if (x < (double )0) {
#line 124
    tmp___0 = p;
#line 124
    p ++;
#line 124
    *tmp___0 = (char )'-';
#line 125
    x = - x;
  }
  {
#line 127
  tmp___9 = floor((double )(x + 1e-6 / (double )2 < (double )1));
  }
#line 127
  if ((int )tmp___9) {
    {
#line 129
    tmp___1 = p;
#line 129
    p ++;
#line 129
    *tmp___1 = (char )'0';
#line 130
    tmp___2 = p;
#line 130
    p ++;
#line 130
    *tmp___2 = (char )'.';
#line 131
    tmp___3 = floor((x + 1e-6 / (double )2) * 1e6);
#line 131
    i = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%06d",
                (int )tmp___3);
    }
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (i) {
#line 132
        if (! ((int )*(p + (i - 1)) == 48)) {
#line 132
          goto while_break;
        }
      } else {
#line 132
        goto while_break;
      }
#line 133
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 134
    if (i == 0) {
#line 135
      i --;
    }
#line 136
    p += i;
  } else
#line 138
  if (x < 1e6) {
    {
#line 140
    tmp___4 = floor(x + 1e-6 / (double )2);
#line 140
    i = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d",
                (int )tmp___4);
#line 141
    p += i;
    }
#line 142
    if (i < 6) {
      {
#line 146
      tmp___5 = p;
#line 146
      p ++;
#line 146
      *tmp___5 = (char )'.';
#line 147
      tmp___6 = floor(x + 1e-6 / (double )2);
#line 147
      x -= tmp___6;
#line 148
      j = i;
      }
      {
#line 148
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 148
        if (! (j < 6)) {
#line 148
          goto while_break___0;
        }
#line 149
        x *= (double )10;
#line 148
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 150
      tmp___7 = floor(x + 0.5);
#line 150
      ix = (int )tmp___7;
#line 152
      j = 0;
      }
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 152
        if (! (j < i)) {
#line 152
          goto while_break___1;
        }
#line 153
        ix *= 10;
#line 152
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 157
      if (ix == 1000000) {
#line 158
        ix = 999999;
      }
      {
#line 160
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%06d",
              ix);
#line 161
      i = 6 - i;
      }
      {
#line 162
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 162
        if (i) {
#line 162
          if (! ((int )*(p + (i - 1)) == 48)) {
#line 162
            goto while_break___2;
          }
        } else {
#line 162
          goto while_break___2;
        }
#line 163
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 164
      if (i == 0) {
#line 165
        i --;
      }
#line 166
      p += i;
    }
  } else {
    {
#line 170
    tmp___8 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%g",
                      x);
#line 170
    p += tmp___8;
    }
  }
#line 172
  *p = (char )'\000';
#line 173
  return ((int )(p - (char *)str));
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_to_string(char *str , double const   *src ) 
{ 
  char tmp[80] ;
  int i ;
  int ix ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double theta ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 204
  tmp___18 = fabs((double )*(src + 4));
  }
#line 204
  if (tmp___18 < 1e-6) {
    {
#line 204
    tmp___19 = fabs((double )*(src + 5));
    }
#line 204
    if (tmp___19 < 1e-6) {
      {
#line 207
      tmp___9 = fabs((double )*(src + 1));
      }
#line 207
      if (tmp___9 < 1e-6) {
        {
#line 207
        tmp___10 = fabs((double )*(src + 2));
        }
#line 207
        if (tmp___10 < 1e-6) {
          {
#line 210
          tmp___3 = fabs((double )(*(src + 0) - (double const   )1));
          }
#line 210
          if (tmp___3 < 1e-6) {
            {
#line 210
            tmp___4 = fabs((double )(*(src + 3) - (double const   )1));
            }
#line 210
            if (tmp___4 < 1e-6) {
#line 213
              *(str + 0) = (char )'\000';
#line 214
              return;
            } else {
#line 210
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 218
            ix = 0;
#line 219
            tmp___0 = art_ftoa((char *)(str + ix), (double )*(src + 0));
#line 219
            ix += tmp___0;
#line 220
            tmp___1 = ix;
#line 220
            ix ++;
#line 220
            *(str + tmp___1) = (char )' ';
#line 221
            tmp___2 = art_ftoa((char *)(str + ix), (double )*(src + 3));
#line 221
            ix += tmp___2;
#line 222
            strcpy((char */* __restrict  */)(str + ix), (char const   */* __restrict  */)" scale");
            }
#line 223
            return;
          }
        } else {
#line 207
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 229
        tmp___6 = fabs((double )(*(src + 0) - *(src + 3)));
        }
#line 229
        if (tmp___6 < 1e-6) {
          {
#line 229
          tmp___7 = fabs((double )(*(src + 1) + *(src + 2)));
          }
#line 229
          if (tmp___7 < 1e-6) {
            {
#line 229
            tmp___8 = fabs((double )((*(src + 0) * *(src + 0) + *(src + 1) * *(src + 1)) - (double const   )1));
            }
#line 229
            if (tmp___8 < (double )2 * 1e-6) {
              {
#line 235
              tmp___5 = atan2((double )*(src + 1), (double )*(src + 0));
#line 235
              theta = ((double )180 / 3.14159265358979323846) * tmp___5;
#line 236
              art_ftoa((char *)(tmp), theta);
#line 237
              sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s rotate",
                      tmp);
              }
#line 238
              return;
            }
          }
        }
      }
    } else {
#line 204
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 245
    tmp___14 = fabs((double )(*(src + 0) - (double const   )1));
    }
#line 245
    if (tmp___14 < 1e-6) {
      {
#line 245
      tmp___15 = fabs((double )*(src + 1));
      }
#line 245
      if (tmp___15 < 1e-6) {
        {
#line 245
        tmp___16 = fabs((double )*(src + 2));
        }
#line 245
        if (tmp___16 < 1e-6) {
          {
#line 245
          tmp___17 = fabs((double )(*(src + 3) - (double const   )1));
          }
#line 245
          if (tmp___17 < 1e-6) {
            {
#line 248
            ix = 0;
#line 249
            tmp___11 = art_ftoa((char *)(str + ix), (double )*(src + 4));
#line 249
            ix += tmp___11;
#line 250
            tmp___12 = ix;
#line 250
            ix ++;
#line 250
            *(str + tmp___12) = (char )' ';
#line 251
            tmp___13 = art_ftoa((char *)(str + ix), (double )*(src + 5));
#line 251
            ix += tmp___13;
#line 252
            strcpy((char */* __restrict  */)(str + ix), (char const   */* __restrict  */)" translate");
            }
#line 253
            return;
          }
        }
      }
    }
  }
#line 257
  ix = 0;
#line 258
  tmp___20 = ix;
#line 258
  ix ++;
#line 258
  *(str + tmp___20) = (char )'[';
#line 259
  tmp___21 = ix;
#line 259
  ix ++;
#line 259
  *(str + tmp___21) = (char )' ';
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 6)) {
#line 260
      goto while_break;
    }
    {
#line 262
    tmp___22 = art_ftoa((char *)(str + ix), (double )*(src + i));
#line 262
    ix += tmp___22;
#line 263
    tmp___23 = ix;
#line 263
    ix ++;
#line 263
    *(str + tmp___23) = (char )' ';
#line 260
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  strcpy((char */* __restrict  */)(str + ix), (char const   */* __restrict  */)"] concat");
  }
#line 266
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_multiply(double *dst , double const   *src1 , double const   *src2 ) 
{ 
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double d4 ;
  double d5 ;

  {
#line 286
  d0 = (double )(*(src1 + 0) * *(src2 + 0) + *(src1 + 1) * *(src2 + 2));
#line 287
  d1 = (double )(*(src1 + 0) * *(src2 + 1) + *(src1 + 1) * *(src2 + 3));
#line 288
  d2 = (double )(*(src1 + 2) * *(src2 + 0) + *(src1 + 3) * *(src2 + 2));
#line 289
  d3 = (double )(*(src1 + 2) * *(src2 + 1) + *(src1 + 3) * *(src2 + 3));
#line 290
  d4 = (double )((*(src1 + 4) * *(src2 + 0) + *(src1 + 5) * *(src2 + 2)) + *(src2 + 4));
#line 291
  d5 = (double )((*(src1 + 4) * *(src2 + 1) + *(src1 + 5) * *(src2 + 3)) + *(src2 + 5));
#line 292
  *(dst + 0) = d0;
#line 293
  *(dst + 1) = d1;
#line 294
  *(dst + 2) = d2;
#line 295
  *(dst + 3) = d3;
#line 296
  *(dst + 4) = d4;
#line 297
  *(dst + 5) = d5;
#line 298
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_identity(double *dst ) 
{ 


  {
#line 309
  *(dst + 0) = (double )1;
#line 310
  *(dst + 1) = (double )0;
#line 311
  *(dst + 2) = (double )0;
#line 312
  *(dst + 3) = (double )1;
#line 313
  *(dst + 4) = (double )0;
#line 314
  *(dst + 5) = (double )0;
#line 315
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_scale(double *dst , double sx , double sy ) 
{ 


  {
#line 329
  *(dst + 0) = sx;
#line 330
  *(dst + 1) = (double )0;
#line 331
  *(dst + 2) = (double )0;
#line 332
  *(dst + 3) = sy;
#line 333
  *(dst + 4) = (double )0;
#line 334
  *(dst + 5) = (double )0;
#line 335
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_rotate(double *dst , double theta ) 
{ 
  double s ;
  double c ;

  {
  {
#line 353
  s = sin((theta * 3.14159265358979323846) / 180.0);
#line 354
  c = cos((theta * 3.14159265358979323846) / 180.0);
#line 355
  *(dst + 0) = c;
#line 356
  *(dst + 1) = s;
#line 357
  *(dst + 2) = - s;
#line 358
  *(dst + 3) = c;
#line 359
  *(dst + 4) = (double )0;
#line 360
  *(dst + 5) = (double )0;
  }
#line 361
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_shear(double *dst , double theta ) 
{ 
  double t ;

  {
  {
#line 377
  t = tan((theta * 3.14159265358979323846) / 180.0);
#line 378
  *(dst + 0) = (double )1;
#line 379
  *(dst + 1) = (double )0;
#line 380
  *(dst + 2) = t;
#line 381
  *(dst + 3) = (double )1;
#line 382
  *(dst + 4) = (double )0;
#line 383
  *(dst + 5) = (double )0;
  }
#line 384
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
void art_affine_translate(double *dst , double tx , double ty ) 
{ 


  {
#line 397
  *(dst + 0) = (double )1;
#line 398
  *(dst + 1) = (double )0;
#line 399
  *(dst + 2) = (double )0;
#line 400
  *(dst + 3) = (double )1;
#line 401
  *(dst + 4) = tx;
#line 402
  *(dst + 5) = ty;
#line 403
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
double art_affine_expansion(double const   *src ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
#line 419
  tmp = fabs((double )(*(src + 0) * *(src + 3) - *(src + 1) * *(src + 2)));
#line 419
  tmp___0 = sqrt(tmp);
  }
#line 419
  return (tmp___0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
int art_affine_rectilinear(double const   *src ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;

  {
  {
#line 435
  tmp = fabs((double )*(src + 1));
  }
#line 435
  if (tmp < 1e-6) {
    {
#line 435
    tmp___0 = fabs((double )*(src + 2));
    }
#line 435
    if (tmp___0 < 1e-6) {
#line 435
      tmp___3 = 1;
    } else {
#line 435
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 435
    tmp___1 = fabs((double )*(src + 0));
    }
#line 435
    if (tmp___1 < 1e-6) {
      {
#line 435
      tmp___2 = fabs((double )*(src + 3));
      }
#line 435
      if (tmp___2 < 1e-6) {
#line 435
        tmp___3 = 1;
      } else {
#line 435
        tmp___3 = 0;
      }
    } else {
#line 435
      tmp___3 = 0;
    }
  }
#line 435
  return (tmp___3);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
int art_affine_equal(double *matrix1 , double *matrix2 ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;

  {
  {
#line 452
  tmp = fabs(*(matrix1 + 0) - *(matrix2 + 0));
  }
#line 452
  if (tmp < 1e-6) {
    {
#line 452
    tmp___0 = fabs(*(matrix1 + 1) - *(matrix2 + 1));
    }
#line 452
    if (tmp___0 < 1e-6) {
      {
#line 452
      tmp___1 = fabs(*(matrix1 + 2) - *(matrix2 + 2));
      }
#line 452
      if (tmp___1 < 1e-6) {
        {
#line 452
        tmp___2 = fabs(*(matrix1 + 3) - *(matrix2 + 3));
        }
#line 452
        if (tmp___2 < 1e-6) {
          {
#line 452
          tmp___3 = fabs(*(matrix1 + 4) - *(matrix2 + 4));
          }
#line 452
          if (tmp___3 < 1e-6) {
            {
#line 452
            tmp___4 = fabs(*(matrix1 + 5) - *(matrix2 + 5));
            }
#line 452
            if (tmp___4 < 1e-6) {
#line 452
              tmp___5 = 1;
            } else {
#line 452
              tmp___5 = 0;
            }
          } else {
#line 452
            tmp___5 = 0;
          }
        } else {
#line 452
          tmp___5 = 0;
        }
      } else {
#line 452
        tmp___5 = 0;
      }
    } else {
#line 452
      tmp___5 = 0;
    }
  } else {
#line 452
    tmp___5 = 0;
  }
#line 452
  return (tmp___5);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.h"
ArtUta *art_uta_new(int x0 , int y0 , int x1 , int y1 ) ;
#line 62
ArtUta *art_uta_new_coords(int x0 , int y0 , int x1 , int y1 ) ;
#line 65
void art_uta_free(ArtUta *uta ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.c"
ArtUta *art_uta_new(int x0 , int y0 , int x1 , int y1 ) 
{ 
  ArtUta *uta ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 43
  tmp = art_alloc(sizeof(ArtUta ));
#line 43
  uta = (ArtUta *)tmp;
#line 44
  uta->x0 = x0;
#line 45
  uta->y0 = y0;
#line 46
  uta->width = x1 - x0;
#line 47
  uta->height = y1 - y0;
#line 49
  tmp___0 = art_alloc((unsigned long )(uta->width * uta->height) * sizeof(ArtUtaBbox ));
#line 49
  uta->utiles = (ArtUtaBbox *)tmp___0;
#line 51
  memset((void *)uta->utiles, 0, (unsigned long )(uta->width * uta->height) * sizeof(ArtUtaBbox ));
  }
#line 52
  return (uta);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.c"
ArtUta *art_uta_new_coords(int x0 , int y0 , int x1 , int y1 ) 
{ 
  ArtUta *tmp ;

  {
  {
#line 69
  tmp = art_uta_new(x0 >> 5, y0 >> 5, 1 + (x1 >> 5), 1 + (y1 >> 5));
  }
#line 69
  return (tmp);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta.c"
void art_uta_free(ArtUta *uta ) 
{ 


  {
  {
#line 84
  art_free((void *)uta->utiles);
#line 85
  art_free((void *)uta);
  }
#line 86
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_a_affine.h"
void art_rgb_a_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 , int dst_rowstride ,
                      art_u8 const   *src , int src_width , int src_height , int src_rowstride ,
                      art_u32 rgb , double const   *affine , ArtFilterLevel level ,
                      ArtAlphaGamma *alphagamma ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_a_affine.c"
void art_rgb_a_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 , int dst_rowstride ,
                      art_u8 const   *src , int src_width , int src_height , int src_rowstride ,
                      art_u32 rgb , double const   *affine , ArtFilterLevel level ,
                      ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  int alpha ;
  art_u8 bg_r ;
  art_u8 bg_g ;
  art_u8 bg_b ;
  art_u8 fg_r ;
  art_u8 fg_g ;
  art_u8 fg_b ;
  int tmp ;
  int run_x0 ;
  int run_x1 ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 92
  r = (art_u8 )((rgb >> 16) & 255U);
#line 93
  g = (art_u8 )((rgb >> 8) & 255U);
#line 94
  b = (art_u8 )(rgb & 255U);
#line 96
  dst_linestart = dst;
#line 97
  art_affine_invert((double *)(inv), affine);
#line 98
  y = y0___0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (y < y1___0)) {
#line 98
      goto while_break;
    }
    {
#line 100
    pt.y = (double )y + 0.5;
#line 101
    run_x0 = x0;
#line 102
    run_x1 = x1;
#line 103
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 105
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 106
    x = run_x0;
    }
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! (x < run_x1)) {
#line 106
        goto while_break___0;
      }
      {
#line 108
      pt.x = (double )x + 0.5;
#line 109
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 110
      tmp___0 = floor(src_pt.x);
#line 110
      src_x = (int )tmp___0;
#line 111
      tmp___1 = floor(src_pt.y);
#line 111
      src_y = (int )tmp___1;
#line 112
      src_p = (src + src_y * src_rowstride) + src_x;
      }
#line 113
      if (src_x >= 0) {
#line 113
        if (src_x < src_width) {
#line 113
          if (src_y >= 0) {
#line 113
            if (src_y < src_height) {
#line 117
              alpha = (int )*src_p;
#line 118
              if (alpha) {
#line 120
                if (alpha == 255) {
#line 122
                  *(dst_p + 0) = r;
#line 123
                  *(dst_p + 1) = g;
#line 124
                  *(dst_p + 2) = b;
                } else {
#line 128
                  bg_r = *(dst_p + 0);
#line 129
                  bg_g = *(dst_p + 1);
#line 130
                  bg_b = *(dst_p + 2);
#line 132
                  tmp = ((int )r - (int )bg_r) * alpha;
#line 133
                  fg_r = (art_u8 )((int )bg_r + (((tmp + (tmp >> 8)) + 128) >> 8));
#line 134
                  tmp = ((int )g - (int )bg_g) * alpha;
#line 135
                  fg_g = (art_u8 )((int )bg_g + (((tmp + (tmp >> 8)) + 128) >> 8));
#line 136
                  tmp = ((int )b - (int )bg_b) * alpha;
#line 137
                  fg_b = (art_u8 )((int )bg_b + (((tmp + (tmp >> 8)) + 128) >> 8));
#line 139
                  *(dst_p + 0) = fg_r;
#line 140
                  *(dst_p + 1) = fg_g;
#line 141
                  *(dst_p + 2) = fg_b;
                }
              }
            } else {
#line 144
              *(dst_p + 0) = (art_u8 )255;
#line 144
              *(dst_p + 1) = (art_u8 )0;
#line 144
              *(dst_p + 2) = (art_u8 )0;
            }
          } else {
#line 144
            *(dst_p + 0) = (art_u8 )255;
#line 144
            *(dst_p + 1) = (art_u8 )0;
#line 144
            *(dst_p + 2) = (art_u8 )0;
          }
        } else {
#line 144
          *(dst_p + 0) = (art_u8 )255;
#line 144
          *(dst_p + 1) = (art_u8 )0;
#line 144
          *(dst_p + 2) = (art_u8 )0;
        }
      } else {
#line 144
        *(dst_p + 0) = (art_u8 )255;
#line 144
        *(dst_p + 1) = (art_u8 )0;
#line 144
        *(dst_p + 2) = (art_u8 )0;
      }
#line 145
      dst_p += 3;
#line 106
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    dst_linestart += dst_rowstride;
#line 98
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.h"
int art_svp_add_segment(ArtSVP **p_vp , int *pn_segs_max , int **pn_points_max , int n_points ,
                        int dir , ArtPoint *points , ArtDRect *bbox ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.c"
int art_svp_add_segment(ArtSVP **p_vp , int *pn_segs_max , int **pn_points_max , int n_points ,
                        int dir , ArtPoint *points , ArtDRect *bbox ) 
{ 
  int seg_num ;
  ArtSVP *svp ;
  ArtSVPSeg *seg ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  double x_min ;
  double x_max ;
  int i ;

  {
#line 65
  svp = *p_vp;
#line 66
  tmp = svp->n_segs;
#line 66
  (svp->n_segs) ++;
#line 66
  seg_num = tmp;
#line 67
  if (*pn_segs_max == seg_num) {
    {
#line 69
    *pn_segs_max <<= 1;
#line 70
    tmp___0 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(*pn_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 70
    svp = (ArtSVP *)tmp___0;
#line 72
    *p_vp = svp;
    }
#line 73
    if ((unsigned long )pn_points_max != (unsigned long )((void *)0)) {
      {
#line 74
      tmp___1 = art_realloc((void *)*pn_points_max, (unsigned long )*pn_segs_max * sizeof(int ));
#line 74
      *pn_points_max = (int *)tmp___1;
      }
    }
  }
#line 76
  seg = & svp->segs[seg_num];
#line 77
  seg->n_points = n_points;
#line 78
  seg->dir = dir;
#line 79
  seg->points = points;
#line 80
  if (bbox) {
#line 81
    seg->bbox = *bbox;
  } else
#line 82
  if (points) {
#line 87
    x_max = (points + 0)->x;
#line 87
    x_min = x_max;
#line 88
    i = 1;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (i < n_points)) {
#line 88
        goto while_break;
      }
#line 90
      if (x_min > (points + i)->x) {
#line 91
        x_min = (points + i)->x;
      }
#line 92
      if (x_max < (points + i)->x) {
#line 93
        x_max = (points + i)->x;
      }
#line 88
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 95
    seg->bbox.x0 = x_min;
#line 96
    seg->bbox.y0 = (points + 0)->y;
#line 98
    seg->bbox.x1 = x_max;
#line 99
    seg->bbox.y1 = (points + (n_points - 1))->y;
  }
#line 101
  return (seg_num);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.c"
void art_svp_free(ArtSVP *svp ) 
{ 
  int n_segs ;
  int i ;

  {
#line 114
  n_segs = svp->n_segs;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < n_segs)) {
#line 117
      goto while_break;
    }
    {
#line 118
    art_free((void *)svp->segs[i].points);
#line 117
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  art_free((void *)svp);
  }
#line 120
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp.c"
int art_svp_seg_compare(void const   *s1 , void const   *s2 ) 
{ 
  ArtSVPSeg const   *seg1 ;
  ArtSVPSeg const   *seg2 ;

  {
#line 139
  seg1 = (ArtSVPSeg const   *)s1;
#line 140
  seg2 = (ArtSVPSeg const   *)s2;
#line 142
  if ((seg1->points + 0)->y - (double )0 > (seg2->points + 0)->y) {
#line 142
    return (1);
  } else
#line 143
  if ((seg1->points + 0)->y + (double )0 < (seg2->points + 0)->y) {
#line 143
    return (-1);
  } else
#line 144
  if ((seg1->points + 0)->x - (double )0 > (seg2->points + 0)->x) {
#line 144
    return (1);
  } else
#line 145
  if ((seg1->points + 0)->x + (double )0 < (seg2->points + 0)->x) {
#line 145
    return (-1);
  } else
#line 146
  if (((seg1->points + 1)->x - (seg1->points + 0)->x) * ((seg2->points + 1)->y - (seg2->points + 0)->y) - ((seg1->points + 1)->y - (seg1->points + 0)->y) * ((seg2->points + 1)->x - (seg2->points + 0)->x) > (double )0) {
#line 149
    return (1);
  } else {
#line 150
    return (-1);
  }
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_affine.h"
void art_rgb_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 , int dst_rowstride ,
                    art_u8 const   *src , int src_width , int src_height , int src_rowstride ,
                    double const   *affine , ArtFilterLevel level , ArtAlphaGamma *alphagamma ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_affine.c"
void art_rgb_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 , int dst_rowstride ,
                    art_u8 const   *src , int src_width , int src_height , int src_rowstride ,
                    double const   *affine , ArtFilterLevel level , ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  int run_x0 ;
  int run_x1 ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 82
  dst_linestart = dst;
#line 83
  art_affine_invert((double *)(inv), affine);
#line 84
  y = y0___0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (y < y1___0)) {
#line 84
      goto while_break;
    }
    {
#line 86
    pt.y = (double )y + 0.5;
#line 87
    run_x0 = x0;
#line 88
    run_x1 = x1;
#line 89
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 91
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 92
    x = run_x0;
    }
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 92
      if (! (x < run_x1)) {
#line 92
        goto while_break___0;
      }
      {
#line 94
      pt.x = (double )x + 0.5;
#line 95
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 96
      tmp = floor(src_pt.x);
#line 96
      src_x = (int )tmp;
#line 97
      tmp___0 = floor(src_pt.y);
#line 97
      src_y = (int )tmp___0;
#line 98
      src_p = (src + src_y * src_rowstride) + src_x * 3;
#line 99
      *(dst_p + 0) = (art_u8 )*(src_p + 0);
#line 100
      *(dst_p + 1) = (art_u8 )*(src_p + 1);
#line 101
      *(dst_p + 2) = (art_u8 )*(src_p + 2);
#line 102
      dst_p += 3;
#line 92
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 104
    dst_linestart += dst_rowstride;
#line 84
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.h"
void art_irect_copy(ArtIRect *dest , ArtIRect const   *src ) ;
#line 44
void art_irect_union(ArtIRect *dest , ArtIRect const   *src1 , ArtIRect const   *src2 ) ;
#line 48
void art_irect_intersect(ArtIRect *dest , ArtIRect const   *src1 , ArtIRect const   *src2 ) ;
#line 52
int art_irect_empty(ArtIRect const   *src ) ;
#line 62
void art_drect_intersect(ArtDRect *dest , ArtDRect const   *src1 , ArtDRect const   *src2 ) ;
#line 66
int art_drect_empty(ArtDRect const   *src ) ;
#line 68
void art_drect_affine_transform(ArtDRect *dst , ArtDRect const   *src , double const   *matrix ) ;
#line 72
void art_drect_to_irect(ArtIRect *dst , ArtDRect *src ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_irect_copy(ArtIRect *dest , ArtIRect const   *src ) 
{ 


  {
#line 44
  dest->x0 = (int )src->x0;
#line 45
  dest->y0 = (int )src->y0;
#line 46
  dest->x1 = (int )src->x1;
#line 47
  dest->y1 = (int )src->y1;
#line 48
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_irect_union(ArtIRect *dest , ArtIRect const   *src1 , ArtIRect const   *src2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 60
  tmp___0 = art_irect_empty(src1);
  }
#line 60
  if (tmp___0) {
    {
#line 61
    art_irect_copy(dest, src2);
    }
  } else {
    {
#line 62
    tmp = art_irect_empty(src2);
    }
#line 62
    if (tmp) {
      {
#line 63
      art_irect_copy(dest, src1);
      }
    } else {
#line 65
      if (src1->x0 < src2->x0) {
#line 65
        dest->x0 = (int )src1->x0;
      } else {
#line 65
        dest->x0 = (int )src2->x0;
      }
#line 66
      if (src1->y0 < src2->y0) {
#line 66
        dest->y0 = (int )src1->y0;
      } else {
#line 66
        dest->y0 = (int )src2->y0;
      }
#line 67
      if (src1->x1 > src2->x1) {
#line 67
        dest->x1 = (int )src1->x1;
      } else {
#line 67
        dest->x1 = (int )src2->x1;
      }
#line 68
      if (src1->y1 > src2->y1) {
#line 68
        dest->y1 = (int )src1->y1;
      } else {
#line 68
        dest->y1 = (int )src2->y1;
      }
    }
  }
#line 70
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_irect_intersect(ArtIRect *dest , ArtIRect const   *src1 , ArtIRect const   *src2 ) 
{ 


  {
#line 82
  if (src1->x0 > src2->x0) {
#line 82
    dest->x0 = (int )src1->x0;
  } else {
#line 82
    dest->x0 = (int )src2->x0;
  }
#line 83
  if (src1->y0 > src2->y0) {
#line 83
    dest->y0 = (int )src1->y0;
  } else {
#line 83
    dest->y0 = (int )src2->y0;
  }
#line 84
  if (src1->x1 < src2->x1) {
#line 84
    dest->x1 = (int )src1->x1;
  } else {
#line 84
    dest->x1 = (int )src2->x1;
  }
#line 85
  if (src1->y1 < src2->y1) {
#line 85
    dest->y1 = (int )src1->y1;
  } else {
#line 85
    dest->y1 = (int )src2->y1;
  }
#line 86
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
int art_irect_empty(ArtIRect const   *src ) 
{ 
  int tmp ;

  {
#line 96
  if (src->x1 <= src->x0) {
#line 96
    tmp = 1;
  } else
#line 96
  if (src->y1 <= src->y0) {
#line 96
    tmp = 1;
  } else {
#line 96
    tmp = 0;
  }
#line 96
  return (tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_drect_copy(ArtDRect *dest , ArtDRect const   *src ) 
{ 


  {
#line 115
  dest->x0 = (double )src->x0;
#line 116
  dest->y0 = (double )src->y0;
#line 117
  dest->x1 = (double )src->x1;
#line 118
  dest->y1 = (double )src->y1;
#line 119
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_drect_union(ArtDRect *dest , ArtDRect const   *src1 , ArtDRect const   *src2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 131
  tmp___0 = art_drect_empty(src1);
  }
#line 131
  if (tmp___0) {
    {
#line 132
    art_drect_copy(dest, src2);
    }
  } else {
    {
#line 133
    tmp = art_drect_empty(src2);
    }
#line 133
    if (tmp) {
      {
#line 134
      art_drect_copy(dest, src1);
      }
    } else {
#line 136
      if (src1->x0 < src2->x0) {
#line 136
        dest->x0 = (double )src1->x0;
      } else {
#line 136
        dest->x0 = (double )src2->x0;
      }
#line 137
      if (src1->y0 < src2->y0) {
#line 137
        dest->y0 = (double )src1->y0;
      } else {
#line 137
        dest->y0 = (double )src2->y0;
      }
#line 138
      if (src1->x1 > src2->x1) {
#line 138
        dest->x1 = (double )src1->x1;
      } else {
#line 138
        dest->x1 = (double )src2->x1;
      }
#line 139
      if (src1->y1 > src2->y1) {
#line 139
        dest->y1 = (double )src1->y1;
      } else {
#line 139
        dest->y1 = (double )src2->y1;
      }
    }
  }
#line 141
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_drect_intersect(ArtDRect *dest , ArtDRect const   *src1 , ArtDRect const   *src2 ) 
{ 


  {
#line 153
  if (src1->x0 > src2->x0) {
#line 153
    dest->x0 = (double )src1->x0;
  } else {
#line 153
    dest->x0 = (double )src2->x0;
  }
#line 154
  if (src1->y0 > src2->y0) {
#line 154
    dest->y0 = (double )src1->y0;
  } else {
#line 154
    dest->y0 = (double )src2->y0;
  }
#line 155
  if (src1->x1 < src2->x1) {
#line 155
    dest->x1 = (double )src1->x1;
  } else {
#line 155
    dest->x1 = (double )src2->x1;
  }
#line 156
  if (src1->y1 < src2->y1) {
#line 156
    dest->y1 = (double )src1->y1;
  } else {
#line 156
    dest->y1 = (double )src2->y1;
  }
#line 157
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
int art_drect_empty(ArtDRect const   *src ) 
{ 
  int tmp ;

  {
#line 167
  if (src->x1 <= src->x0) {
#line 167
    tmp = 1;
  } else
#line 167
  if (src->y1 <= src->y0) {
#line 167
    tmp = 1;
  } else {
#line 167
    tmp = 0;
  }
#line 167
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_drect_affine_transform(ArtDRect *dst , ArtDRect const   *src , double const   *matrix ) 
{ 
  double x00 ;
  double y00 ;
  double x10 ;
  double y10 ;
  double x01 ;
  double y01 ;
  double x11 ;
  double y11 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;

  {
#line 187
  x00 = (double )((src->x0 * *(matrix + 0) + src->y0 * *(matrix + 2)) + *(matrix + 4));
#line 188
  y00 = (double )((src->x0 * *(matrix + 1) + src->y0 * *(matrix + 3)) + *(matrix + 5));
#line 189
  x10 = (double )((src->x1 * *(matrix + 0) + src->y0 * *(matrix + 2)) + *(matrix + 4));
#line 190
  y10 = (double )((src->x1 * *(matrix + 1) + src->y0 * *(matrix + 3)) + *(matrix + 5));
#line 191
  x01 = (double )((src->x0 * *(matrix + 0) + src->y1 * *(matrix + 2)) + *(matrix + 4));
#line 192
  y01 = (double )((src->x0 * *(matrix + 1) + src->y1 * *(matrix + 3)) + *(matrix + 5));
#line 193
  x11 = (double )((src->x1 * *(matrix + 0) + src->y1 * *(matrix + 2)) + *(matrix + 4));
#line 194
  y11 = (double )((src->x1 * *(matrix + 1) + src->y1 * *(matrix + 3)) + *(matrix + 5));
#line 195
  if (x00 < x10) {
#line 195
    tmp___3 = x00;
  } else {
#line 195
    tmp___3 = x10;
  }
#line 195
  if (x01 < x11) {
#line 195
    tmp___4 = x01;
  } else {
#line 195
    tmp___4 = x11;
  }
#line 195
  if (tmp___3 < tmp___4) {
#line 195
    if (x00 < x10) {
#line 195
      tmp___1 = x00;
    } else {
#line 195
      tmp___1 = x10;
    }
#line 195
    dst->x0 = tmp___1;
  } else {
#line 195
    if (x01 < x11) {
#line 195
      tmp___2 = x01;
    } else {
#line 195
      tmp___2 = x11;
    }
#line 195
    dst->x0 = tmp___2;
  }
#line 196
  if (y00 < y10) {
#line 196
    tmp___9 = y00;
  } else {
#line 196
    tmp___9 = y10;
  }
#line 196
  if (y01 < y11) {
#line 196
    tmp___10 = y01;
  } else {
#line 196
    tmp___10 = y11;
  }
#line 196
  if (tmp___9 < tmp___10) {
#line 196
    if (y00 < y10) {
#line 196
      tmp___7 = y00;
    } else {
#line 196
      tmp___7 = y10;
    }
#line 196
    dst->y0 = tmp___7;
  } else {
#line 196
    if (y01 < y11) {
#line 196
      tmp___8 = y01;
    } else {
#line 196
      tmp___8 = y11;
    }
#line 196
    dst->y0 = tmp___8;
  }
#line 197
  if (x00 > x10) {
#line 197
    tmp___15 = x00;
  } else {
#line 197
    tmp___15 = x10;
  }
#line 197
  if (x01 > x11) {
#line 197
    tmp___16 = x01;
  } else {
#line 197
    tmp___16 = x11;
  }
#line 197
  if (tmp___15 > tmp___16) {
#line 197
    if (x00 > x10) {
#line 197
      tmp___13 = x00;
    } else {
#line 197
      tmp___13 = x10;
    }
#line 197
    dst->x1 = tmp___13;
  } else {
#line 197
    if (x01 > x11) {
#line 197
      tmp___14 = x01;
    } else {
#line 197
      tmp___14 = x11;
    }
#line 197
    dst->x1 = tmp___14;
  }
#line 198
  if (y00 > y10) {
#line 198
    tmp___21 = y00;
  } else {
#line 198
    tmp___21 = y10;
  }
#line 198
  if (y01 > y11) {
#line 198
    tmp___22 = y01;
  } else {
#line 198
    tmp___22 = y11;
  }
#line 198
  if (tmp___21 > tmp___22) {
#line 198
    if (y00 > y10) {
#line 198
      tmp___19 = y00;
    } else {
#line 198
      tmp___19 = y10;
    }
#line 198
    dst->y1 = tmp___19;
  } else {
#line 198
    if (y01 > y11) {
#line 198
      tmp___20 = y01;
    } else {
#line 198
      tmp___20 = y11;
    }
#line 198
    dst->y1 = tmp___20;
  }
#line 199
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect.c"
void art_drect_to_irect(ArtIRect *dst , ArtDRect *src ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 211
  tmp = floor(src->x0);
#line 211
  dst->x0 = (int )tmp;
#line 212
  tmp___0 = floor(src->y0);
#line 212
  dst->y0 = (int )tmp___0;
#line 213
  tmp___1 = ceil(src->x1);
#line 213
  dst->x1 = (int )tmp___1;
#line 214
  tmp___2 = ceil(src->y1);
#line 214
  dst->y1 = (int )tmp___2;
  }
#line 215
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.h"
void art_vpath_bbox_irect(ArtVpath const   *vec , ArtIRect *irect ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_vpath.h"
void art_uta_add_line(ArtUta *uta , double x0 , double y0___0 , double x1 , double y1___0 ,
                      int *rbuf , int rbuf_rowstride ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_vpath.c"
void art_uta_add_line(ArtUta *uta , double x0 , double y0___0 , double x1 , double y1___0 ,
                      int *rbuf , int rbuf_rowstride ) 
{ 
  int xmin ;
  int ymin ;
  double xmax ;
  double ymax ;
  int xmaxf ;
  int ymaxf ;
  int xmaxc ;
  int ymaxc ;
  int xt0 ;
  int yt0 ;
  int xt1 ;
  int yt1 ;
  int xf0 ;
  int yf0 ;
  int xf1 ;
  int yf1 ;
  int ix ;
  int ix1 ;
  ArtUtaBbox bb ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  ArtUtaBbox tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  double dx ;
  double dy ;
  int sx ;
  int sy ;
  int tmp___11 ;
  int tmp___12 ;
  ArtUtaBbox tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  double dx_dy ;
  double x ;
  double y ;
  double xn ;
  double yn___0 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  int dix ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  ArtUtaBbox tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  ArtUtaBbox tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;

  {
#line 72
  if (x0 < x1) {
#line 72
    tmp = x0;
  } else {
#line 72
    tmp = x1;
  }
  {
#line 72
  tmp___0 = floor(tmp);
#line 72
  xmin = (int )tmp___0;
  }
#line 73
  if (x0 > x1) {
#line 73
    xmax = x0;
  } else {
#line 73
    xmax = x1;
  }
  {
#line 74
  tmp___1 = floor(xmax);
#line 74
  xmaxf = (int )tmp___1;
#line 75
  tmp___2 = ceil(xmax);
#line 75
  xmaxc = (int )tmp___2;
  }
#line 76
  if (y0___0 < y1___0) {
#line 76
    tmp___3 = y0___0;
  } else {
#line 76
    tmp___3 = y1___0;
  }
  {
#line 76
  tmp___4 = floor(tmp___3);
#line 76
  ymin = (int )tmp___4;
  }
#line 77
  if (y0___0 > y1___0) {
#line 77
    ymax = y0___0;
  } else {
#line 77
    ymax = y1___0;
  }
  {
#line 78
  tmp___5 = floor(ymax);
#line 78
  ymaxf = (int )tmp___5;
#line 79
  tmp___6 = ceil(ymax);
#line 79
  ymaxc = (int )tmp___6;
#line 80
  xt0 = (xmin >> 5) - uta->x0;
#line 81
  yt0 = (ymin >> 5) - uta->y0;
#line 82
  xt1 = (xmaxf >> 5) - uta->x0;
#line 83
  yt1 = (ymaxf >> 5) - uta->y0;
  }
#line 84
  if (xt0 == xt1) {
#line 84
    if (yt0 == yt1) {
#line 87
      xf0 = xmin & ((1 << 5) - 1);
#line 88
      yf0 = ymin & ((1 << 5) - 1);
#line 89
      xf1 = ((xmaxf & ((1 << 5) - 1)) + xmaxc) - xmaxf;
#line 90
      yf1 = ((ymaxf & ((1 << 5) - 1)) + ymaxc) - ymaxf;
#line 92
      ix = yt0 * uta->width + xt0;
#line 93
      bb = *(uta->utiles + ix);
#line 94
      if (bb == 0U) {
#line 95
        bb = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | (xf1 << 8)) | yf1);
      } else {
#line 97
        if (bb >> 24 < (ArtUtaBbox )xf0) {
#line 97
          tmp___7 = bb >> 24;
        } else {
#line 97
          tmp___7 = (ArtUtaBbox )xf0;
        }
#line 97
        if (((bb >> 16) & 255U) < (unsigned int )yf0) {
#line 97
          tmp___8 = (bb >> 16) & 255U;
        } else {
#line 97
          tmp___8 = (unsigned int )yf0;
        }
#line 97
        if (((bb >> 8) & 255U) > (unsigned int )xf1) {
#line 97
          tmp___9 = (bb >> 8) & 255U;
        } else {
#line 97
          tmp___9 = (unsigned int )xf1;
        }
#line 97
        if ((bb & 255U) > (unsigned int )yf1) {
#line 97
          tmp___10 = bb & 255U;
        } else {
#line 97
          tmp___10 = (unsigned int )yf1;
        }
#line 97
        bb = (((tmp___7 << 24) | (tmp___8 << 16)) | (tmp___9 << 8)) | tmp___10;
      }
#line 101
      *(uta->utiles + ix) = bb;
    } else {
#line 84
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 108
    dx = x1 - x0;
#line 109
    dy = y1___0 - y0___0;
#line 110
    if (dx > (double )0) {
#line 110
      sx = 1;
    } else {
#line 110
      if (dx < (double )0) {
#line 110
        tmp___11 = -1;
      } else {
#line 110
        tmp___11 = 0;
      }
#line 110
      sx = tmp___11;
    }
#line 111
    if (dy > (double )0) {
#line 111
      sy = 1;
    } else {
#line 111
      if (dy < (double )0) {
#line 111
        tmp___12 = -1;
      } else {
#line 111
        tmp___12 = 0;
      }
#line 111
      sy = tmp___12;
    }
#line 112
    if (ymin == ymaxf) {
#line 115
      xf0 = xmin & ((1 << 5) - 1);
#line 116
      yf0 = ymin & ((1 << 5) - 1);
#line 117
      xf1 = ((xmaxf & ((1 << 5) - 1)) + xmaxc) - xmaxf;
#line 118
      yf1 = ((ymaxf & ((1 << 5) - 1)) + ymaxc) - ymaxf;
#line 120
      ix = yt0 * uta->width + xt0;
#line 121
      ix1 = yt0 * uta->width + xt1;
      {
#line 122
      while (1) {
        while_continue: /* CIL Label */ ;
#line 122
        if (! (ix != ix1)) {
#line 122
          goto while_break;
        }
#line 124
        bb = *(uta->utiles + ix);
#line 125
        if (bb == 0U) {
#line 126
          bb = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | ((1 << 5) << 8)) | yf1);
        } else {
#line 128
          if (bb >> 24 < (ArtUtaBbox )xf0) {
#line 128
            tmp___13 = bb >> 24;
          } else {
#line 128
            tmp___13 = (ArtUtaBbox )xf0;
          }
#line 128
          if (((bb >> 16) & 255U) < (unsigned int )yf0) {
#line 128
            tmp___14 = (bb >> 16) & 255U;
          } else {
#line 128
            tmp___14 = (unsigned int )yf0;
          }
#line 128
          if ((bb & 255U) > (unsigned int )yf1) {
#line 128
            tmp___15 = bb & 255U;
          } else {
#line 128
            tmp___15 = (unsigned int )yf1;
          }
#line 128
          bb = (((tmp___13 << 24) | (tmp___14 << 16)) | (unsigned int )((1 << 5) << 8)) | tmp___15;
        }
#line 132
        *(uta->utiles + ix) = bb;
#line 133
        xf0 = 0;
#line 134
        ix ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 136
      bb = *(uta->utiles + ix);
#line 137
      if (bb == 0U) {
#line 138
        bb = (ArtUtaBbox )(((yf0 << 16) | (xf1 << 8)) | yf1);
      } else {
#line 140
        if (((bb >> 16) & 255U) < (unsigned int )yf0) {
#line 140
          tmp___16 = (bb >> 16) & 255U;
        } else {
#line 140
          tmp___16 = (unsigned int )yf0;
        }
#line 140
        if (((bb >> 8) & 255U) > (unsigned int )xf1) {
#line 140
          tmp___17 = (bb >> 8) & 255U;
        } else {
#line 140
          tmp___17 = (unsigned int )xf1;
        }
#line 140
        if ((bb & 255U) > (unsigned int )yf1) {
#line 140
          tmp___18 = bb & 255U;
        } else {
#line 140
          tmp___18 = (unsigned int )yf1;
        }
#line 140
        bb = ((tmp___16 << 16) | (tmp___17 << 8)) | tmp___18;
      }
#line 144
      *(uta->utiles + ix) = bb;
    } else {
#line 154
      x0 -= (double )(uta->x0 << 5);
#line 155
      y0___0 -= (double )(uta->y0 << 5);
#line 156
      x1 -= (double )(uta->x0 << 5);
#line 157
      y1___0 -= (double )(uta->y0 << 5);
#line 158
      if (dy < (double )0) {
#line 162
        tmp___19 = x0;
#line 163
        x0 = x1;
#line 164
        x1 = tmp___19;
#line 166
        tmp___19 = y0___0;
#line 167
        y0___0 = y1___0;
#line 168
        y1___0 = tmp___19;
#line 170
        dx = - dx;
#line 171
        sx = - sx;
#line 172
        dy = - dy;
      }
      {
#line 176
      tmp___20 = floor(x0);
#line 176
      xt0 = (int )tmp___20 >> 5;
#line 177
      tmp___21 = floor(x1);
#line 177
      xt1 = (int )tmp___21 >> 5;
#line 180
      ix = yt0 * uta->width + xt0;
#line 181
      ix1 = yt1 * uta->width + xt1;
#line 186
      dx_dy = dx / dy;
#line 187
      x = x0;
#line 188
      y = y0___0;
      }
      {
#line 189
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 189
        if (! (ix != ix1)) {
#line 189
          goto while_break___0;
        }
        {
#line 197
        yn___0 = (double )((yt0 + 1) << 5);
#line 202
        xn = x1 + dx_dy * (yn___0 - y1___0);
#line 204
        tmp___29 = floor(xn);
        }
#line 204
        if (xt0 != (int )tmp___29 >> 5) {
#line 207
          xt0 += sx;
#line 208
          dix = sx;
#line 209
          if (dx > (double )0) {
            {
#line 211
            xn = (double )(xt0 << 5);
#line 212
            yn___0 = y0___0 + (xn - x0) / dx_dy;
#line 214
            tmp___22 = floor(x);
#line 214
            xf0 = (int )tmp___22 & ((1 << 5) - 1);
#line 215
            xf1 = 1 << 5;
            }
          } else {
            {
#line 219
            xn = (double )((xt0 + 1) << 5);
#line 220
            yn___0 = y0___0 + (xn - x0) / dx_dy;
#line 222
            xf0 = 0;
#line 223
            tmp___23 = ceil(x);
#line 223
            xmaxc = (int )tmp___23;
#line 224
            xf1 = xmaxc - ((xt0 + 1) << 5);
            }
          }
          {
#line 226
          tmp___24 = floor(yn___0);
#line 226
          ymaxf = (int )tmp___24;
#line 227
          tmp___25 = ceil(yn___0);
#line 227
          ymaxc = (int )tmp___25;
#line 228
          yf1 = ((ymaxf & ((1 << 5) - 1)) + ymaxc) - ymaxf;
          }
        } else {
#line 233
          dix = uta->width;
#line 234
          if (x < xn) {
#line 234
            tmp___26 = x;
          } else {
#line 234
            tmp___26 = xn;
          }
          {
#line 234
          tmp___27 = floor(tmp___26);
#line 234
          xf0 = (int )tmp___27 & ((1 << 5) - 1);
          }
#line 235
          if (x > xn) {
#line 235
            xmax = x;
          } else {
#line 235
            xmax = xn;
          }
          {
#line 236
          tmp___28 = ceil(xmax);
#line 236
          xmaxc = (int )tmp___28;
#line 237
          xf1 = xmaxc - (xt0 << 5);
#line 238
          yf1 = 1 << 5;
          }
#line 240
          if ((unsigned long )rbuf != (unsigned long )((void *)0)) {
#line 241
            *(rbuf + (yt0 * rbuf_rowstride + xt0)) += sy;
          }
#line 243
          yt0 ++;
        }
        {
#line 245
        tmp___30 = floor(y);
#line 245
        yf0 = (int )tmp___30 & ((1 << 5) - 1);
#line 246
        bb = *(uta->utiles + ix);
        }
#line 247
        if (bb == 0U) {
#line 248
          bb = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | (xf1 << 8)) | yf1);
        } else {
#line 250
          if (bb >> 24 < (ArtUtaBbox )xf0) {
#line 250
            tmp___31 = bb >> 24;
          } else {
#line 250
            tmp___31 = (ArtUtaBbox )xf0;
          }
#line 250
          if (((bb >> 16) & 255U) < (unsigned int )yf0) {
#line 250
            tmp___32 = (bb >> 16) & 255U;
          } else {
#line 250
            tmp___32 = (unsigned int )yf0;
          }
#line 250
          if (((bb >> 8) & 255U) > (unsigned int )xf1) {
#line 250
            tmp___33 = (bb >> 8) & 255U;
          } else {
#line 250
            tmp___33 = (unsigned int )xf1;
          }
#line 250
          if ((bb & 255U) > (unsigned int )yf1) {
#line 250
            tmp___34 = bb & 255U;
          } else {
#line 250
            tmp___34 = (unsigned int )yf1;
          }
#line 250
          bb = (((tmp___31 << 24) | (tmp___32 << 16)) | (tmp___33 << 8)) | tmp___34;
        }
#line 254
        *(uta->utiles + ix) = bb;
#line 256
        x = xn;
#line 257
        y = yn___0;
#line 258
        ix += dix;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 260
      if (x > x1) {
#line 260
        xmax = x;
      } else {
#line 260
        xmax = x1;
      }
      {
#line 261
      tmp___35 = ceil(xmax);
#line 261
      xmaxc = (int )tmp___35;
#line 262
      tmp___36 = ceil(y1___0);
#line 262
      ymaxc = (int )tmp___36;
      }
#line 263
      if (x1 < x) {
#line 263
        tmp___37 = x1;
      } else {
#line 263
        tmp___37 = x;
      }
      {
#line 263
      tmp___38 = floor(tmp___37);
#line 263
      xf0 = (int )tmp___38 & ((1 << 5) - 1);
#line 264
      tmp___39 = floor(y);
#line 264
      yf0 = (int )tmp___39 & ((1 << 5) - 1);
#line 265
      xf1 = xmaxc - (xt0 << 5);
#line 266
      yf1 = ymaxc - (yt0 << 5);
#line 267
      bb = *(uta->utiles + ix);
      }
#line 268
      if (bb == 0U) {
#line 269
        bb = (ArtUtaBbox )((((xf0 << 24) | (yf0 << 16)) | (xf1 << 8)) | yf1);
      } else {
#line 271
        if (bb >> 24 < (ArtUtaBbox )xf0) {
#line 271
          tmp___40 = bb >> 24;
        } else {
#line 271
          tmp___40 = (ArtUtaBbox )xf0;
        }
#line 271
        if (((bb >> 16) & 255U) < (unsigned int )yf0) {
#line 271
          tmp___41 = (bb >> 16) & 255U;
        } else {
#line 271
          tmp___41 = (unsigned int )yf0;
        }
#line 271
        if (((bb >> 8) & 255U) > (unsigned int )xf1) {
#line 271
          tmp___42 = (bb >> 8) & 255U;
        } else {
#line 271
          tmp___42 = (unsigned int )xf1;
        }
#line 271
        if ((bb & 255U) > (unsigned int )yf1) {
#line 271
          tmp___43 = bb & 255U;
        } else {
#line 271
          tmp___43 = (unsigned int )yf1;
        }
#line 271
        bb = (((tmp___40 << 24) | (tmp___41 << 16)) | (tmp___42 << 8)) | tmp___43;
      }
#line 275
      *(uta->utiles + ix) = bb;
    }
  }
#line 278
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_vpath.c"
ArtUta *art_uta_from_vpath(ArtVpath const   *vec ) 
{ 
  ArtUta *uta ;
  ArtIRect bbox ;
  int *rbuf ;
  int i ;
  double x ;
  double y ;
  int sum ;
  int xt ;
  int yt ;
  ArtUtaBbox *utiles ;
  ArtUtaBbox bb ;
  int width ;
  int height ;
  int ix ;
  void *tmp ;

  {
  {
#line 305
  art_vpath_bbox_irect(vec, & bbox);
#line 307
  uta = art_uta_new_coords(bbox.x0, bbox.y0, bbox.x1, bbox.y1);
#line 309
  width = uta->width;
#line 310
  height = uta->height;
#line 311
  utiles = uta->utiles;
#line 313
  tmp = art_alloc((unsigned long )(width * height) * sizeof(int ));
#line 313
  rbuf = (int *)tmp;
#line 314
  i = 0;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < width * height)) {
#line 314
      goto while_break;
    }
#line 315
    *(rbuf + i) = 0;
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  x = (double )0;
#line 318
  y = (double )0;
#line 319
  i = 0;
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 319
    if (! ((unsigned int const   )(vec + i)->code != 4U)) {
#line 319
      goto while_break___0;
    }
    {
#line 323
    if ((unsigned int const   )(vec + i)->code == 0U) {
#line 323
      goto case_0;
    }
#line 327
    if ((unsigned int const   )(vec + i)->code == 3U) {
#line 327
      goto case_3;
    }
#line 332
    goto switch_default;
    case_0: /* CIL Label */ 
#line 324
    x = (double )(vec + i)->x;
#line 325
    y = (double )(vec + i)->y;
#line 326
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 328
    art_uta_add_line(uta, (double )(vec + i)->x, (double )(vec + i)->y, x, y, rbuf,
                     width);
#line 329
    x = (double )(vec + i)->x;
#line 330
    y = (double )(vec + i)->y;
    }
#line 331
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 334
    art_free((void *)rbuf);
#line 335
    art_free((void *)uta);
    }
#line 336
    return ((ArtUta *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
#line 319
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 341
  ix = 0;
#line 342
  yt = 0;
  {
#line 342
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 342
    if (! (yt < height)) {
#line 342
      goto while_break___1;
    }
#line 344
    sum = 0;
#line 345
    xt = 0;
    {
#line 345
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 345
      if (! (xt < width)) {
#line 345
        goto while_break___2;
      }
#line 347
      sum += *(rbuf + ix);
#line 350
      if (sum != 0) {
#line 352
        bb = *(utiles + ix);
#line 353
        bb &= 4294901760U;
#line 354
        bb |= (unsigned int )(((1 << 5) << 8) | (1 << 5));
#line 355
        *(utiles + ix) = bb;
#line 356
        if (xt != width - 1) {
#line 358
          bb = *(utiles + (ix + 1));
#line 359
          bb &= 16776960U;
#line 360
          bb |= (unsigned int )(1 << 5);
#line 361
          *(utiles + (ix + 1)) = bb;
        }
#line 363
        if (yt != height - 1) {
#line 365
          bb = *(utiles + (ix + width));
#line 366
          bb &= 4278190335U;
#line 367
          bb |= (unsigned int )((1 << 5) << 8);
#line 368
          *(utiles + (ix + width)) = bb;
#line 369
          if (xt != width - 1) {
#line 371
            *(utiles + ((ix + width) + 1)) &= 65535U;
          }
        }
      }
#line 375
      ix ++;
#line 345
      xt ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 342
    yt ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 379
  art_free((void *)rbuf);
  }
#line 381
  return (uta);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_point.h"
int art_svp_point_wind(ArtSVP *svp , double x , double y ) ;
#line 38
double art_svp_point_dist(ArtSVP *svp , double x , double y ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_point.c"
int art_svp_point_wind(ArtSVP *svp , double x , double y ) 
{ 
  int i ;
  int j ;
  int wind ;
  ArtSVPSeg *seg ;
  int tmp ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double dx ;
  double dy ;
  int tmp___0 ;

  {
#line 45
  wind = 0;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < svp->n_segs)) {
#line 47
      goto while_break;
    }
#line 49
    seg = & svp->segs[i];
#line 51
    if (seg->bbox.y0 > y) {
#line 52
      goto while_break;
    }
#line 54
    if (seg->bbox.y1 > y) {
#line 56
      if (seg->bbox.x1 < x) {
#line 57
        if (seg->dir) {
#line 57
          tmp = 1;
        } else {
#line 57
          tmp = -1;
        }
#line 57
        wind += tmp;
      } else
#line 58
      if (seg->bbox.x0 <= x) {
#line 62
        j = 0;
        {
#line 62
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 62
          if (! (j < seg->n_points - 1)) {
#line 62
            goto while_break___0;
          }
#line 64
          if ((seg->points + (j + 1))->y > y) {
#line 65
            goto while_break___0;
          }
#line 62
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 67
        x0 = (seg->points + j)->x;
#line 68
        y0___0 = (seg->points + j)->y;
#line 69
        x1 = (seg->points + (j + 1))->x;
#line 70
        y1___0 = (seg->points + (j + 1))->y;
#line 72
        dx = x1 - x0;
#line 73
        dy = y1___0 - y0___0;
#line 74
        if ((x - x0) * dy > (y - y0___0) * dx) {
#line 75
          if (seg->dir) {
#line 75
            tmp___0 = 1;
          } else {
#line 75
            tmp___0 = -1;
          }
#line 75
          wind += tmp___0;
        }
      }
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (wind);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_point.c"
double art_svp_point_dist(ArtSVP *svp , double x , double y ) 
{ 
  int i ;
  int j ;
  double dist_sq ;
  double best_sq ;
  ArtSVPSeg *seg ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double dx ;
  double dy ;
  double dxx0 ;
  double dyy0 ;
  double dot ;
  double rr ;
  double perp ;
  double tmp ;

  {
#line 99
  best_sq = (double )-1;
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < svp->n_segs)) {
#line 101
      goto while_break;
    }
#line 103
    seg = & svp->segs[i];
#line 104
    j = 0;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! (j < seg->n_points - 1)) {
#line 104
        goto while_break___0;
      }
#line 106
      x0 = (seg->points + j)->x;
#line 107
      y0___0 = (seg->points + j)->y;
#line 108
      x1 = (seg->points + (j + 1))->x;
#line 109
      y1___0 = (seg->points + (j + 1))->y;
#line 111
      dx = x1 - x0;
#line 112
      dy = y1___0 - y0___0;
#line 114
      dxx0 = x - x0;
#line 115
      dyy0 = y - y0___0;
#line 117
      dot = dxx0 * dx + dyy0 * dy;
#line 119
      if (dot < (double )0) {
#line 120
        dist_sq = dxx0 * dxx0 + dyy0 * dyy0;
      } else {
#line 123
        rr = dx * dx + dy * dy;
#line 125
        if (dot > rr) {
#line 126
          dist_sq = (x - x1) * (x - x1) + (y - y1___0) * (y - y1___0);
        } else {
#line 129
          perp = (y - y0___0) * dx - (x - x0) * dy;
#line 131
          dist_sq = (perp * perp) / rr;
        }
      }
#line 134
      if (best_sq < (double )0) {
#line 135
        best_sq = dist_sq;
      } else
#line 134
      if (dist_sq < best_sq) {
#line 135
        best_sq = dist_sq;
      }
#line 104
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (best_sq >= (double )0) {
    {
#line 140
    tmp = sqrt(best_sq);
    }
#line 140
    return (tmp);
  } else {
#line 142
    return (1e12);
  }
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgba.h"
void art_rgba_rgba_composite(art_u8 *dst , art_u8 const   *src , int n ) ;
#line 39
void art_rgba_fill_run(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int n ) ;
#line 42
void art_rgba_run_alpha(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int alpha ,
                        int n ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgba.c"
void art_rgba_rgba_composite(art_u8 *dst , art_u8 const   *src , int n ) 
{ 
  int i ;
  art_u32 src_abgr ;
  art_u32 dst_abgr ;
  art_u8 src_alpha ;
  art_u8 dst_alpha ;
  int r ;
  int g ;
  int b ;
  int a ;
  int src_r ;
  int src_g ;
  int src_b ;
  int dst_r ;
  int dst_g ;
  int dst_b ;
  int tmp ;
  int c ;

  {
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < n)) {
#line 51
      goto while_break;
    }
#line 57
    src_abgr = *((art_u32 *)src + i);
#line 58
    src_alpha = (art_u8 )((src_abgr >> 24) & 255U);
#line 60
    if (src_alpha) {
#line 62
      if ((int )src_alpha == 255) {
#line 75
        *((art_u32 *)dst + i) = src_abgr;
      } else {
#line 62
        dst_abgr = *((art_u32 *)dst + i);
#line 62
        dst_alpha = (art_u8 )(dst_abgr >> 24);
#line 62
        if ((int )dst_alpha == 0) {
#line 75
          *((art_u32 *)dst + i) = src_abgr;
        } else {
#line 86
          tmp = (255 - (int )src_alpha) * (255 - (int )dst_alpha) + 128;
#line 87
          a = 255 - ((tmp + (tmp >> 8)) >> 8);
#line 88
          c = (((int )src_alpha << 16) + (a >> 1)) / a;
#line 102
          src_r = (int )(src_abgr & 255U);
#line 103
          src_g = (int )((src_abgr >> 8) & 255U);
#line 104
          src_b = (int )((src_abgr >> 16) & 255U);
#line 105
          dst_r = (int )(dst_abgr & 255U);
#line 106
          dst_g = (int )((dst_abgr >> 8) & 255U);
#line 107
          dst_b = (int )((dst_abgr >> 16) & 255U);
#line 109
          r = dst_r + (((src_r - dst_r) * c + 32768) >> 16);
#line 110
          g = dst_g + (((src_g - dst_g) * c + 32768) >> 16);
#line 111
          b = dst_b + (((src_b - dst_b) * c + 32768) >> 16);
#line 115
          *((art_u32 *)dst + i) = (art_u32 )((((a << 24) | (b << 16)) | (g << 8)) | r);
        }
      }
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgba.c"
void art_rgba_fill_run(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int n ) 
{ 
  int i ;
  art_u32 src_abgr ;

  {
#line 166
  src_abgr = (art_u32 )((((255 << 24) | ((int )b << 16)) | ((int )g << 8)) | (int )r);
#line 168
  i = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < n)) {
#line 168
      goto while_break;
    }
#line 173
    *((art_u32 *)buf + i) = src_abgr;
#line 168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgba.c"
void art_rgba_run_alpha(art_u8 *buf , art_u8 r , art_u8 g , art_u8 b , int alpha ,
                        int n ) 
{ 
  int i ;
  art_u32 src_abgr ;
  art_u32 dst_abgr ;
  art_u8 dst_alpha ;
  int a ;
  int dst_r ;
  int dst_g ;
  int dst_b ;
  int tmp ;
  int c ;

  {
#line 209
  src_abgr = (art_u32 )((((alpha << 24) | ((int )b << 16)) | ((int )g << 8)) | (int )r);
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < n)) {
#line 211
      goto while_break;
    }
#line 217
    dst_abgr = *((art_u32 *)buf + i);
#line 218
    dst_alpha = (art_u8 )((dst_abgr >> 24) & 255U);
#line 220
    if (dst_alpha) {
#line 223
      tmp = (255 - alpha) * (255 - (int )dst_alpha) + 128;
#line 224
      a = 255 - ((tmp + (tmp >> 8)) >> 8);
#line 225
      c = ((alpha << 16) + (a >> 1)) / a;
#line 236
      dst_r = (int )(dst_abgr & 255U);
#line 237
      dst_g = (int )((dst_abgr >> 8) & 255U);
#line 238
      dst_b = (int )((dst_abgr >> 16) & 255U);
#line 240
      dst_r += (((int )r - dst_r) * c + 32768) >> 16;
#line 241
      dst_g += (((int )g - dst_g) * c + 32768) >> 16;
#line 242
      dst_b += (((int )b - dst_b) * c + 32768) >> 16;
#line 246
      *((art_u32 *)buf + i) = (art_u32 )((((a << 24) | (dst_b << 16)) | (dst_g << 8)) | dst_r);
    } else {
#line 254
      *((art_u32 *)buf + i) = src_abgr;
    }
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rect_uta.c"
ArtIRect *art_rect_list_from_uta(ArtUta *uta , int max_width , int max_height , int *p_nrects ) 
{ 
  ArtIRect *rects ;
  int n_rects ;
  int n_rects_max ;
  int x ;
  int y ;
  int width ;
  int height ;
  int ix ;
  int left_ix ;
  ArtUtaBbox *utiles ;
  ArtUtaBbox bb ;
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int *glom ;
  int glom_rect ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 61
  n_rects = 0;
#line 62
  n_rects_max = 1;
#line 63
  tmp = art_alloc((unsigned long )n_rects_max * sizeof(ArtIRect ));
#line 63
  rects = (ArtIRect *)tmp;
#line 65
  width = uta->width;
#line 66
  height = uta->height;
#line 67
  utiles = uta->utiles;
#line 69
  tmp___0 = art_alloc((unsigned long )(width * height) * sizeof(int ));
#line 69
  glom = (int *)tmp___0;
#line 70
  ix = 0;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (ix < width * height)) {
#line 70
      goto while_break;
    }
#line 71
    *(glom + ix) = -1;
#line 70
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  ix = 0;
#line 74
  y = 0;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (y < height)) {
#line 74
      goto while_break___0;
    }
#line 75
    x = 0;
    {
#line 75
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 75
      if (! (x < width)) {
#line 75
        goto while_break___1;
      }
#line 77
      bb = *(utiles + ix);
#line 78
      if (bb) {
#line 80
        x0 = (int )((ArtUtaBbox )((uta->x0 + x) << 5) + (bb >> 24));
#line 81
        y0 = (int )((unsigned int )((uta->y0 + y) << 5) + ((bb >> 16) & 255U));
#line 82
        y1 = (int )((unsigned int )((uta->y0 + y) << 5) + (bb & 255U));
#line 84
        left_ix = ix;
        {
#line 86
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 86
          if (x != width - 1) {
#line 86
            if (((bb >> 8) & 255U) == (unsigned int )(1 << 5)) {
#line 86
              if ((((bb & 16777215U) ^ *(utiles + (ix + 1))) & 4294902015U) == 0U) {
#line 86
                if (! (((unsigned int )(((uta->x0 + x) + 1) << 5) + ((*(utiles + (ix + 1)) >> 8) & 255U)) - (unsigned int )x0 <= (unsigned int )max_width)) {
#line 86
                  goto while_break___2;
                }
              } else {
#line 86
                goto while_break___2;
              }
            } else {
#line 86
              goto while_break___2;
            }
          } else {
#line 86
            goto while_break___2;
          }
#line 93
          bb = *(utiles + (ix + 1));
#line 94
          ix ++;
#line 95
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 97
        x1 = (int )((unsigned int )((uta->x0 + x) << 5) + ((bb >> 8) & 255U));
#line 101
        if ((x1 ^ x0) | (y1 ^ y0)) {
#line 104
          glom_rect = *(glom + left_ix);
#line 105
          if (glom_rect != -1) {
#line 105
            if (x0 == (rects + glom_rect)->x0) {
#line 105
              if (x1 == (rects + glom_rect)->x1) {
#line 105
                if (y0 == (rects + glom_rect)->y1) {
#line 105
                  if (y1 - (rects + glom_rect)->y0 <= max_height) {
#line 111
                    (rects + glom_rect)->y1 = y1;
                  } else {
#line 105
                    goto _L___2;
                  }
                } else {
#line 105
                  goto _L___2;
                }
              } else {
#line 105
                goto _L___2;
              }
            } else {
#line 105
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 115
            if (n_rects == n_rects_max) {
              {
#line 116
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 116
                if (n_rects_max) {
                  {
#line 116
                  n_rects_max <<= 1;
#line 116
                  tmp___1 = art_realloc((void *)rects, (unsigned long )n_rects_max * sizeof(ArtIRect ));
#line 116
                  rects = (ArtIRect *)tmp___1;
                  }
                } else {
                  {
#line 116
                  n_rects_max = 1;
#line 116
                  tmp___2 = art_alloc(sizeof(ArtIRect ));
#line 116
                  rects = (ArtIRect *)tmp___2;
                  }
                }
#line 116
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
#line 117
            (rects + n_rects)->x0 = x0;
#line 118
            (rects + n_rects)->y0 = y0;
#line 119
            (rects + n_rects)->x1 = x1;
#line 120
            (rects + n_rects)->y1 = y1;
#line 121
            glom_rect = n_rects;
#line 122
            n_rects ++;
          }
#line 124
          if (y != height - 1) {
#line 125
            *(glom + (left_ix + width)) = glom_rect;
          }
        }
      }
#line 128
      ix ++;
#line 75
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 74
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 131
  art_free((void *)glom);
#line 132
  *p_nrects = n_rects;
  }
#line 133
  return (rects);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.h"
ArtVpath *art_vpath_dash(ArtVpath const   *vpath , ArtVpathDash const   *dash ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.c"
static int art_vpath_dash_max_subpath(ArtVpath const   *vpath ) 
{ 
  int max_subpath ;
  int i ;
  int start ;

  {
#line 41
  max_subpath = 0;
#line 42
  start = 0;
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! ((unsigned int const   )(vpath + i)->code != 4U)) {
#line 43
      goto while_break;
    }
#line 45
    if ((unsigned int const   )(vpath + i)->code == 0U) {
#line 45
      goto _L;
    } else
#line 45
    if ((unsigned int const   )(vpath + i)->code == 1U) {
      _L: /* CIL Label */ 
#line 47
      if (i - start > max_subpath) {
#line 48
        max_subpath = i - start;
      }
#line 49
      start = i;
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (i - start > max_subpath) {
#line 53
    max_subpath = i - start;
  }
#line 55
  return (max_subpath);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.c"
ArtVpath *art_vpath_dash(ArtVpath const   *vpath , ArtVpathDash const   *dash ) 
{ 
  int max_subpath ;
  double *dists ;
  ArtVpath *result ;
  int n_result ;
  int n_result_max ;
  int start ;
  int end ;
  int i ;
  double total_dist ;
  int offset ;
  int toggle ;
  double phase ;
  int offset_init ;
  int toggle_init ;
  double phase_init ;
  void *tmp ;
  void *tmp___0 ;
  double dx ;
  double dy ;
  double dist ;
  double a ;
  double x ;
  double y ;
  int tmp___1 ;

  {
  {
#line 100
  max_subpath = art_vpath_dash_max_subpath(vpath);
#line 101
  tmp = art_alloc((unsigned long )max_subpath * sizeof(double ));
#line 101
  dists = (double *)tmp;
#line 103
  n_result = 0;
#line 104
  n_result_max = 16;
#line 105
  tmp___0 = art_alloc((unsigned long )n_result_max * sizeof(ArtVpath ));
#line 105
  result = (ArtVpath *)tmp___0;
#line 108
  toggle_init = 1;
#line 109
  offset_init = 0;
#line 110
  phase_init = (double )dash->offset;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (phase_init >= *(dash->dash + offset_init))) {
#line 111
      goto while_break;
    }
#line 113
    toggle_init = ! toggle_init;
#line 114
    phase_init -= *(dash->dash + offset_init);
#line 115
    offset_init ++;
#line 116
    if (offset_init == (int )dash->n_dash) {
#line 117
      offset_init = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  start = 0;
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! ((unsigned int const   )(vpath + start)->code != 4U)) {
#line 120
      goto while_break___0;
    }
#line 122
    end = start + 1;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (! ((unsigned int const   )(vpath + end)->code == 3U)) {
#line 122
        goto while_break___1;
      }
#line 122
      end ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 124
    total_dist = (double )0;
#line 125
    i = start;
    {
#line 125
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 125
      if (! (i < end - 1)) {
#line 125
        goto while_break___2;
      }
      {
#line 129
      dx = (double )((vpath + (i + 1))->x - (vpath + i)->x);
#line 130
      dy = (double )((vpath + (i + 1))->y - (vpath + i)->y);
#line 131
      *(dists + (i - start)) = sqrt(dx * dx + dy * dy);
#line 132
      total_dist += *(dists + (i - start));
#line 125
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 134
    if (total_dist <= *(dash->dash + offset_init) - phase_init) {
#line 137
      if (toggle_init) {
#line 139
        i = start;
        {
#line 139
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 139
          if (! (i < end)) {
#line 139
            goto while_break___3;
          }
          {
#line 140
          art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )(vpath + i)->code,
                              (double )(vpath + i)->x, (double )(vpath + i)->y);
#line 139
          i ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else {
#line 150
      phase = phase_init;
#line 151
      offset = offset_init;
#line 152
      toggle = toggle_init;
#line 153
      dist = (double )0;
#line 154
      i = start;
#line 155
      if (toggle) {
        {
#line 156
        art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )1,
                            (double )(vpath + i)->x, (double )(vpath + i)->y);
        }
      }
      {
#line 158
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 158
        if (! (i != end - 1)) {
#line 158
          goto while_break___4;
        }
#line 160
        if (*(dists + (i - start)) - dist > *(dash->dash + offset) - phase) {
#line 166
          dist += *(dash->dash + offset) - phase;
#line 167
          a = dist / *(dists + (i - start));
#line 168
          x = (double )((vpath + i)->x + (double const   )(a * (double )((vpath + (i + 1))->x - (vpath + i)->x)));
#line 169
          y = (double )((vpath + i)->y + (double const   )(a * (double )((vpath + (i + 1))->y - (vpath + i)->y)));
#line 170
          if (toggle) {
#line 170
            tmp___1 = 3;
          } else {
#line 170
            tmp___1 = 1;
          }
          {
#line 170
          art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )tmp___1,
                              x, y);
#line 174
          toggle = ! toggle;
#line 175
          phase = (double )0;
#line 176
          offset ++;
          }
#line 177
          if (offset == (int )dash->n_dash) {
#line 178
            offset = 0;
          }
        } else {
#line 183
          phase += *(dists + (i - start)) - dist;
#line 184
          i ++;
#line 185
          dist = (double )0;
#line 186
          if (toggle) {
            {
#line 187
            art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )3,
                                (double )(vpath + i)->x, (double )(vpath + i)->y);
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 120
    start = end;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 194
  art_vpath_add_point(& result, & n_result, & n_result_max, (ArtPathcode )4, (double )0,
                      (double )0);
#line 197
  art_free((void *)dists);
  }
#line 199
  return (result);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_rgba_affine.h"
void art_rgb_rgba_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 ,
                         int dst_rowstride , art_u8 const   *src , int src_width ,
                         int src_height , int src_rowstride , double const   *affine ,
                         ArtFilterLevel level , ArtAlphaGamma *alphagamma ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_rgba_affine.c"
void art_rgb_rgba_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 ,
                         int dst_rowstride , art_u8 const   *src , int src_width ,
                         int src_height , int src_rowstride , double const   *affine ,
                         ArtFilterLevel level , ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  int alpha ;
  art_u8 bg_r ;
  art_u8 bg_g ;
  art_u8 bg_b ;
  art_u8 fg_r ;
  art_u8 fg_g ;
  art_u8 fg_b ;
  int tmp ;
  int run_x0 ;
  int run_x1 ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 89
  dst_linestart = dst;
#line 90
  art_affine_invert((double *)(inv), affine);
#line 91
  y = y0___0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (y < y1___0)) {
#line 91
      goto while_break;
    }
    {
#line 93
    pt.y = (double )y + 0.5;
#line 94
    run_x0 = x0;
#line 95
    run_x1 = x1;
#line 96
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 98
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 99
    x = run_x0;
    }
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 99
      if (! (x < run_x1)) {
#line 99
        goto while_break___0;
      }
      {
#line 101
      pt.x = (double )x + 0.5;
#line 102
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 103
      tmp___0 = floor(src_pt.x);
#line 103
      src_x = (int )tmp___0;
#line 104
      tmp___1 = floor(src_pt.y);
#line 104
      src_y = (int )tmp___1;
#line 105
      src_p = (src + src_y * src_rowstride) + src_x * 4;
      }
#line 106
      if (src_x >= 0) {
#line 106
        if (src_x < src_width) {
#line 106
          if (src_y >= 0) {
#line 106
            if (src_y < src_height) {
#line 110
              alpha = (int )*(src_p + 3);
#line 111
              if (alpha) {
#line 113
                if (alpha == 255) {
#line 115
                  *(dst_p + 0) = (art_u8 )*(src_p + 0);
#line 116
                  *(dst_p + 1) = (art_u8 )*(src_p + 1);
#line 117
                  *(dst_p + 2) = (art_u8 )*(src_p + 2);
                } else {
#line 121
                  bg_r = *(dst_p + 0);
#line 122
                  bg_g = *(dst_p + 1);
#line 123
                  bg_b = *(dst_p + 2);
#line 125
                  tmp = (int )(((int const   )*(src_p + 0) - (int const   )bg_r) * (int const   )alpha);
#line 126
                  fg_r = (art_u8 )((int )bg_r + (((tmp + (tmp >> 8)) + 128) >> 8));
#line 127
                  tmp = (int )(((int const   )*(src_p + 1) - (int const   )bg_g) * (int const   )alpha);
#line 128
                  fg_g = (art_u8 )((int )bg_g + (((tmp + (tmp >> 8)) + 128) >> 8));
#line 129
                  tmp = (int )(((int const   )*(src_p + 2) - (int const   )bg_b) * (int const   )alpha);
#line 130
                  fg_b = (art_u8 )((int )bg_b + (((tmp + (tmp >> 8)) + 128) >> 8));
#line 132
                  *(dst_p + 0) = fg_r;
#line 133
                  *(dst_p + 1) = fg_g;
#line 134
                  *(dst_p + 2) = fg_b;
                }
              }
            } else {
#line 137
              *(dst_p + 0) = (art_u8 )255;
#line 137
              *(dst_p + 1) = (art_u8 )0;
#line 137
              *(dst_p + 2) = (art_u8 )0;
            }
          } else {
#line 137
            *(dst_p + 0) = (art_u8 )255;
#line 137
            *(dst_p + 1) = (art_u8 )0;
#line 137
            *(dst_p + 2) = (art_u8 )0;
          }
        } else {
#line 137
          *(dst_p + 0) = (art_u8 )255;
#line 137
          *(dst_p + 1) = (art_u8 )0;
#line 137
          *(dst_p + 2) = (art_u8 )0;
        }
      } else {
#line 137
        *(dst_p + 0) = (art_u8 )255;
#line 137
        *(dst_p + 1) = (art_u8 )0;
#line 137
        *(dst_p + 2) = (art_u8 )0;
      }
#line 138
      dst_p += 3;
#line 99
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 140
    dst_linestart += dst_rowstride;
#line 91
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_alphagamma.h"
ArtAlphaGamma *art_alphagamma_new(double gamma___0 ) ;
#line 48
void art_alphagamma_free(ArtAlphaGamma *alphagamma ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_alphagamma.c"
ArtAlphaGamma *art_alphagamma_new(double gamma___0 ) 
{ 
  int tablesize ;
  ArtAlphaGamma *alphagamma ;
  int i ;
  int *table ;
  art_u8 *invtable ;
  double s ;
  double r_gamma ;
  double tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  {
#line 51
  tmp = ceil(gamma___0 * (double )8);
#line 51
  tablesize = (int )tmp;
  }
#line 52
  if (tablesize < 10) {
#line 53
    tablesize = 10;
  }
  {
#line 55
  tmp___0 = art_alloc(sizeof(ArtAlphaGamma ) + (unsigned long )((1 << tablesize) - 1) * sizeof(art_u8 ));
#line 55
  alphagamma = (ArtAlphaGamma *)tmp___0;
#line 58
  alphagamma->gamma = gamma___0;
#line 59
  alphagamma->invtable_size = tablesize;
#line 61
  table = alphagamma->table;
#line 62
  i = 0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i < 256)) {
#line 62
      goto while_break;
    }
    {
#line 63
    tmp___1 = pow((double )i * (1.0 / (double )255), gamma___0);
#line 63
    tmp___2 = floor((double )((1 << tablesize) - 1) * tmp___1 + 0.5);
#line 63
    *(table + i) = (int )tmp___2;
#line 62
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  invtable = alphagamma->invtable;
#line 67
  s = 1.0 / (double )((1 << tablesize) - 1);
#line 68
  r_gamma = 1.0 / gamma___0;
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 1 << tablesize)) {
#line 69
      goto while_break___0;
    }
    {
#line 70
    tmp___3 = pow((double )i * s, r_gamma);
#line 70
    tmp___4 = floor((double )255 * tmp___3 + 0.5);
#line 70
    *(invtable + i) = (art_u8 )((int )tmp___4);
#line 69
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  return (alphagamma);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_alphagamma.c"
void art_alphagamma_free(ArtAlphaGamma *alphagamma ) 
{ 


  {
  {
#line 84
  art_free((void *)alphagamma);
  }
#line 85
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.h"
ArtPixBuf *art_pixbuf_new_rgb(art_u8 *pixels , int width , int height , int rowstride ) ;
#line 70
ArtPixBuf *art_pixbuf_new_rgba(art_u8 *pixels , int width , int height , int rowstride ) ;
#line 74
ArtPixBuf *art_pixbuf_new_const_rgb(art_u8 const   *pixels , int width , int height ,
                                    int rowstride ) ;
#line 77
ArtPixBuf *art_pixbuf_new_const_rgba(art_u8 const   *pixels , int width , int height ,
                                     int rowstride ) ;
#line 81
ArtPixBuf *art_pixbuf_new_rgb_dnotify(art_u8 *pixels , int width , int height , int rowstride ,
                                      void *dfunc_data , void (*dfunc)(void *func_data ,
                                                                       void *data ) ) ;
#line 85
ArtPixBuf *art_pixbuf_new_rgba_dnotify(art_u8 *pixels , int width , int height , int rowstride ,
                                       void *dfunc_data , void (*dfunc)(void *func_data ,
                                                                        void *data ) ) ;
#line 90
void art_pixbuf_free(ArtPixBuf *pixbuf ) ;
#line 94
void art_pixbuf_free_shallow(ArtPixBuf *pixbuf ) ;
#line 97
ArtPixBuf *art_pixbuf_duplicate(ArtPixBuf const   *pixbuf ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_new_rgb_dnotify(art_u8 *pixels , int width , int height , int rowstride ,
                                      void *dfunc_data , void (*dfunc)(void *func_data ,
                                                                       void *data ) ) 
{ 
  ArtPixBuf *pixbuf ;
  void *tmp ;

  {
  {
#line 53
  tmp = art_alloc(sizeof(ArtPixBuf ));
#line 53
  pixbuf = (ArtPixBuf *)tmp;
#line 55
  pixbuf->format = (ArtPixFormat )0;
#line 56
  pixbuf->n_channels = 3;
#line 57
  pixbuf->has_alpha = 0;
#line 58
  pixbuf->bits_per_sample = 8;
#line 60
  pixbuf->pixels = pixels;
#line 61
  pixbuf->width = width;
#line 62
  pixbuf->height = height;
#line 63
  pixbuf->rowstride = rowstride;
#line 64
  pixbuf->destroy_data = dfunc_data;
#line 65
  pixbuf->destroy = dfunc;
  }
#line 67
  return (pixbuf);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_new_rgba_dnotify(art_u8 *pixels , int width , int height , int rowstride ,
                                       void *dfunc_data , void (*dfunc)(void *func_data ,
                                                                        void *data ) ) 
{ 
  ArtPixBuf *pixbuf ;
  void *tmp ;

  {
  {
#line 97
  tmp = art_alloc(sizeof(ArtPixBuf ));
#line 97
  pixbuf = (ArtPixBuf *)tmp;
#line 99
  pixbuf->format = (ArtPixFormat )0;
#line 100
  pixbuf->n_channels = 4;
#line 101
  pixbuf->has_alpha = 1;
#line 102
  pixbuf->bits_per_sample = 8;
#line 104
  pixbuf->pixels = pixels;
#line 105
  pixbuf->width = width;
#line 106
  pixbuf->height = height;
#line 107
  pixbuf->rowstride = rowstride;
#line 108
  pixbuf->destroy_data = dfunc_data;
#line 109
  pixbuf->destroy = dfunc;
  }
#line 111
  return (pixbuf);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_new_const_rgb(art_u8 const   *pixels , int width , int height ,
                                    int rowstride ) 
{ 
  ArtPixBuf *tmp ;

  {
  {
#line 134
  tmp = art_pixbuf_new_rgb_dnotify((art_u8 *)pixels, width, height, rowstride, (void *)0,
                                   (void (*)(void *func_data , void *data ))((void *)0));
  }
#line 134
  return (tmp);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_new_const_rgba(art_u8 const   *pixels , int width , int height ,
                                     int rowstride ) 
{ 
  ArtPixBuf *tmp ;

  {
  {
#line 157
  tmp = art_pixbuf_new_rgba_dnotify((art_u8 *)pixels, width, height, rowstride, (void *)0,
                                    (void (*)(void *func_data , void *data ))((void *)0));
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
static void art_pixel_destroy(void *func_data , void *data ) 
{ 


  {
  {
#line 163
  art_free(data);
  }
#line 164
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_new_rgb(art_u8 *pixels , int width , int height , int rowstride ) 
{ 
  ArtPixBuf *tmp ;

  {
  {
#line 186
  tmp = art_pixbuf_new_rgb_dnotify(pixels, width, height, rowstride, (void *)0, & art_pixel_destroy);
  }
#line 186
  return (tmp);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_new_rgba(art_u8 *pixels , int width , int height , int rowstride ) 
{ 
  ArtPixBuf *tmp ;

  {
  {
#line 209
  tmp = art_pixbuf_new_rgba_dnotify(pixels, width, height, rowstride, (void *)0, & art_pixel_destroy);
  }
#line 209
  return (tmp);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
void art_pixbuf_free(ArtPixBuf *pixbuf ) 
{ 
  void (*destroy)(void *func_data , void *data ) ;
  void *destroy_data ;
  art_u8 *pixels ;

  {
#line 223
  destroy = pixbuf->destroy;
#line 224
  destroy_data = pixbuf->destroy_data;
#line 225
  pixels = pixbuf->pixels;
#line 227
  pixbuf->pixels = (art_u8 *)((void *)0);
#line 228
  pixbuf->destroy = (void (*)(void *func_data , void *data ))((void *)0);
#line 229
  pixbuf->destroy_data = (void *)0;
#line 231
  if (destroy) {
    {
#line 232
    (*destroy)(destroy_data, (void *)pixels);
    }
  }
  {
#line 234
  art_free((void *)pixbuf);
  }
#line 235
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
void art_pixbuf_free_shallow(ArtPixBuf *pixbuf ) 
{ 


  {
  {
#line 249
  art_free((void *)pixbuf);
  }
#line 250
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
ArtPixBuf *art_pixbuf_duplicate(ArtPixBuf const   *pixbuf ) 
{ 
  ArtPixBuf *result ;
  int size ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 266
  tmp = art_alloc(sizeof(ArtPixBuf ));
#line 266
  result = (ArtPixBuf *)tmp;
#line 268
  result->format = (ArtPixFormat )pixbuf->format;
#line 269
  result->n_channels = (int )pixbuf->n_channels;
#line 270
  result->has_alpha = (int )pixbuf->has_alpha;
#line 271
  result->bits_per_sample = (int )pixbuf->bits_per_sample;
#line 273
  size = (int )((pixbuf->height - 1) * pixbuf->rowstride + pixbuf->width * ((pixbuf->n_channels * pixbuf->bits_per_sample + 7) >> 3));
#line 275
  tmp___0 = art_alloc((size_t )size);
#line 275
  result->pixels = (art_u8 *)tmp___0;
#line 276
  memcpy((void */* __restrict  */)result->pixels, (void const   */* __restrict  */)pixbuf->pixels,
         (size_t )size);
#line 278
  result->width = (int )pixbuf->width;
#line 279
  result->height = (int )pixbuf->height;
#line 280
  result->rowstride = (int )pixbuf->rowstride;
#line 281
  result->destroy_data = (void *)0;
#line 282
  result->destroy = & art_pixel_destroy;
  }
#line 284
  return (result);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.h"
ArtRender *art_render_new(int x0 , int y0 , int x1 , int y1 , art_u8 *pixels , int rowstride ,
                          int n_chan , int depth , ArtAlphaType alpha_type , ArtAlphaGamma *alphagamma ) ;
#line 152
void art_render_invoke(ArtRender *render ) ;
#line 155
void art_render_clear(ArtRender *render , ArtPixMaxDepth const   *clear_color ) ;
#line 158
void art_render_clear_rgb(ArtRender *render , art_u32 clear_rgb ) ;
#line 161
void art_render_mask_solid(ArtRender *render , int opacity ) ;
#line 164
void art_render_image_solid(ArtRender *render , ArtPixMaxDepth *color ) ;
#line 168
void art_render_add_mask_source(ArtRender *render , ArtMaskSource *mask_source ) ;
#line 171
void art_render_invoke_callbacks(ArtRender *render , art_u8 *dest , int y ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
ArtRender *art_render_new(int x0 , int y0 , int x1 , int y1 , art_u8 *pixels , int rowstride ,
                          int n_chan , int depth , ArtAlphaType alpha_type , ArtAlphaGamma *alphagamma ) 
{ 
  ArtRenderPriv *priv ;
  ArtRender *result ;
  void *tmp ;

  {
  {
#line 51
  tmp = art_alloc(sizeof(ArtRenderPriv ));
#line 51
  priv = (ArtRenderPriv *)tmp;
#line 52
  result = & priv->super;
  }
#line 54
  if (n_chan > 16) {
    {
#line 56
    art_warn("art_render_new: n_chan = %d, exceeds %d max\n", n_chan, 16);
    }
#line 58
    return ((ArtRender *)((void *)0));
  }
#line 60
  if (depth > 16) {
    {
#line 62
    art_warn("art_render_new: depth = %d, exceeds %d max\n", depth, 16);
    }
#line 64
    return ((ArtRender *)((void *)0));
  }
#line 66
  if (x0 >= x1) {
    {
#line 68
    art_warn("art_render_new: x0 >= x1 (x0 = %d, x1 = %d)\n", x0, x1);
    }
#line 69
    return ((ArtRender *)((void *)0));
  }
#line 71
  result->x0 = x0;
#line 72
  result->y0 = y0;
#line 73
  result->x1 = x1;
#line 74
  result->y1 = y1;
#line 75
  result->pixels = pixels;
#line 76
  result->rowstride = rowstride;
#line 77
  result->n_chan = n_chan;
#line 78
  result->depth = depth;
#line 79
  result->alpha_type = alpha_type;
#line 81
  result->clear = 0;
#line 82
  result->opacity = (art_u32 )65536;
#line 83
  result->compositing_mode = (ArtCompositingMode )0;
#line 84
  result->alphagamma = alphagamma;
#line 86
  result->alpha_buf = (art_u8 *)((void *)0);
#line 87
  result->image_buf = (art_u8 *)((void *)0);
#line 89
  result->run = (ArtRenderMaskRun *)((void *)0);
#line 90
  result->span_x = (int *)((void *)0);
#line 92
  result->need_span = 0;
#line 94
  priv->image_source = (ArtImageSource *)((void *)0);
#line 96
  priv->n_mask_source = 0;
#line 97
  priv->mask_source = (ArtMaskSource **)((void *)0);
#line 99
  return (result);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_clear(ArtRender *render , ArtPixMaxDepth const   *clear_color ) 
{ 
  int i ;
  int n_ch ;

  {
#line 117
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 119
  render->clear = 1;
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < n_ch)) {
#line 120
      goto while_break;
    }
#line 121
    render->clear_color[i] = (ArtPixMaxDepth )*(clear_color + i);
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_clear_rgb(ArtRender *render , art_u32 clear_rgb ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 134
  if (render->n_chan != 3) {
    {
#line 135
    art_warn("art_render_clear_rgb: called on render with %d channels, only works with 3\n",
             render->n_chan);
    }
  } else {
#line 141
    render->clear = 1;
#line 142
    r = (int )(clear_rgb >> 16);
#line 143
    g = (int )((clear_rgb >> 8) & 255U);
#line 144
    b = (int )(clear_rgb & 255U);
#line 145
    render->clear_color[0] = (ArtPixMaxDepth )(r | (r << 8));
#line 146
    render->clear_color[1] = (ArtPixMaxDepth )(g | (g << 8));
#line 147
    render->clear_color[2] = (ArtPixMaxDepth )(b | (b << 8));
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_nop_done(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_rgb8(ArtRenderCallback *self , ArtRender *render ,
                                         art_u8 *dest , int y ) 
{ 
  int width ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  ArtPixMaxDepth color_max ;

  {
  {
#line 160
  width = render->x1 - render->x0;
#line 164
  color_max = render->clear_color[0];
#line 165
  r = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 166
  color_max = render->clear_color[1];
#line 167
  g = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 168
  color_max = render->clear_color[2];
#line 169
  b = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 171
  art_rgb_fill_run(dest, r, g, b, width);
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_8(ArtRenderCallback *self , ArtRender *render ,
                                      art_u8 *dest , int y ) 
{ 
  int width ;
  int i ;
  int j ;
  int n_ch ;
  int ix ;
  art_u8 color[17] ;
  ArtPixMaxDepth color_max ;
  int tmp ;

  {
#line 178
  width = render->x1 - render->x0;
#line 180
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 184
  j = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (j < n_ch)) {
#line 184
      goto while_break;
    }
#line 186
    color_max = render->clear_color[j];
#line 187
    color[j] = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 184
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  ix = 0;
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 191
    if (! (i < width)) {
#line 191
      goto while_break___0;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if (! (j < n_ch)) {
#line 192
        goto while_break___1;
      }
#line 193
      tmp = ix;
#line 193
      ix ++;
#line 193
      *(dest + tmp) = color[j];
#line 192
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_clear_rgb8_obj  =    {& art_render_clear_render_rgb8, & art_render_nop_done};
#line 202 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_clear_8_obj  =    {& art_render_clear_render_8, & art_render_nop_done};
#line 210 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_16(ArtRenderCallback *self , ArtRender *render ,
                                       art_u8 *dest , int y ) 
{ 
  int width ;
  int i ;
  int j ;
  int n_ch ;
  int ix ;
  art_u16 *dest_16 ;
  art_u8 color[17] ;
  int color_16 ;
  int tmp ;

  {
#line 214
  width = render->x1 - render->x0;
#line 216
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 218
  dest_16 = (art_u16 *)dest;
#line 221
  j = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (j < n_ch)) {
#line 221
      goto while_break;
    }
#line 223
    color_16 = (int )render->clear_color[j];
#line 224
    color[j] = (art_u8 )color_16;
#line 221
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  ix = 0;
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! (i < width)) {
#line 228
      goto while_break___0;
    }
#line 229
    j = 0;
    {
#line 229
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 229
      if (! (j < n_ch)) {
#line 229
        goto while_break___1;
      }
#line 230
      tmp = ix;
#line 230
      ix ++;
#line 230
      *(dest_16 + tmp) = (art_u16 )color[j];
#line 229
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 228
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_clear_16_obj  =    {& art_render_clear_render_16, & art_render_nop_done};
#line 242 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static ArtRenderCallback *art_render_choose_clear_callback(ArtRender *render ) 
{ 
  ArtRenderCallback *clear_callback ;

  {
#line 247
  if (render->depth == 8) {
#line 249
    if (render->n_chan == 3) {
#line 249
      if ((unsigned int )render->alpha_type == 0U) {
#line 251
        clear_callback = (ArtRenderCallback *)(& art_render_clear_rgb8_obj);
      } else {
#line 253
        clear_callback = (ArtRenderCallback *)(& art_render_clear_8_obj);
      }
    } else {
#line 253
      clear_callback = (ArtRenderCallback *)(& art_render_clear_8_obj);
    }
  } else
#line 256
  if (render->depth == 16) {
#line 257
    clear_callback = (ArtRenderCallback *)(& art_render_clear_16_obj);
  } else {
    {
#line 261
    art_die("art_render_choose_clear_callback: inconsistent render->depth = %d\n",
            render->depth);
    }
  }
#line 264
  return (clear_callback);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                                 int y ) 
{ 
  ArtRenderMaskRun *run ;
  art_u32 depth ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *alpha_buf ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  art_u32 alpha ;
  int image_ix ;
  art_u16 src[17] ;
  art_u16 dst[17] ;
  int n_chan ;
  ArtAlphaType alpha_type ;
  int n_ch ;
  int dst_pixstride ;
  int buf_depth ;
  ArtAlphaType buf_alpha ;
  int buf_n_ch ;
  int buf_pixstride ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 srcv ;
  art_u32 dstv ;
  art_u32 tmp___0 ;

  {
#line 286
  run = render->run;
#line 287
  depth = (art_u32 )render->depth;
#line 288
  n_run = render->n_run;
#line 289
  x0 = render->x0;
#line 292
  alpha_buf = render->alpha_buf;
#line 293
  image_buf = render->image_buf;
#line 301
  n_chan = render->n_chan;
#line 302
  alpha_type = render->alpha_type;
#line 303
  n_ch = n_chan + ((unsigned int )alpha_type != 0U);
#line 304
  dst_pixstride = (int )((art_u32 )n_ch * (depth >> 3));
#line 305
  buf_depth = render->buf_depth;
#line 306
  buf_alpha = render->buf_alpha;
#line 307
  buf_n_ch = n_chan + ((unsigned int )buf_alpha != 0U);
#line 308
  buf_pixstride = buf_n_ch * (buf_depth >> 3);
#line 316
  image_ix = 0;
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (i < n_run - 1)) {
#line 317
      goto while_break;
    }
#line 319
    run_x0 = (run + i)->x;
#line 320
    run_x1 = (run + (i + 1))->x;
#line 321
    tmp = (art_u32 )(run + i)->alpha;
#line 322
    if (tmp < 33024U) {
#line 323
      goto __Cont;
    }
#line 325
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 326
    bufptr = image_buf + (run_x0 - x0) * buf_pixstride;
#line 327
    dstptr = dest + (run_x0 - x0) * dst_pixstride;
#line 328
    x = run_x0;
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! (x < run_x1)) {
#line 328
        goto while_break___0;
      }
#line 330
      if (alpha_buf) {
#line 332
        if (depth == 8U) {
#line 334
          tmp = run_alpha * (art_u32 )*(alpha_buf + (x - x0)) + 128U;
#line 336
          alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
        } else {
#line 340
          tmp = (art_u32 )*((art_u16 *)alpha_buf + (x - x0));
#line 341
          tmp = (run_alpha * tmp + 32768U) >> 8;
#line 343
          alpha = (tmp + (tmp >> 16)) >> 8;
        }
      } else {
#line 347
        alpha = run_alpha;
      }
#line 352
      if ((unsigned int )buf_alpha == 0U) {
#line 354
        src_alpha = alpha;
#line 355
        src_mul = src_alpha;
      } else {
#line 359
        if (buf_depth == 8) {
#line 361
          tmp = alpha * (art_u32 )*(bufptr + n_chan) + 128U;
#line 363
          src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
        } else {
#line 367
          tmp = (art_u32 )*((art_u16 *)bufptr + n_chan);
#line 368
          tmp = (alpha * tmp + 32768U) >> 8;
#line 370
          src_alpha = (tmp + (tmp >> 16)) >> 8;
        }
#line 372
        if ((unsigned int )buf_alpha == 1U) {
#line 373
          src_mul = src_alpha;
        } else {
#line 375
          src_mul = alpha;
        }
      }
#line 380
      if (buf_depth == 8) {
#line 382
        src_mul *= 257U;
#line 383
        j = 0;
        {
#line 383
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 383
          if (! (j < n_chan)) {
#line 383
            goto while_break___1;
          }
#line 384
          src[j] = (art_u16 )(((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16);
#line 383
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 386
      if (buf_depth == 16) {
#line 388
        j = 0;
        {
#line 388
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 388
          if (! (j < n_chan)) {
#line 388
            goto while_break___2;
          }
#line 389
          src[j] = (art_u16 )(((art_u32 )*((art_u16 *)bufptr + j) * src_mul + 32768U) >> 16);
#line 388
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 391
      bufptr += buf_pixstride;
#line 399
      if ((unsigned int )alpha_type == 0U) {
#line 401
        dst_alpha = (art_u32 )65536;
#line 402
        dst_mul = dst_alpha;
      } else {
#line 406
        if (depth == 8U) {
#line 408
          tmp = (art_u32 )*(dstptr + n_chan);
#line 410
          dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
        } else {
#line 414
          tmp = (art_u32 )*((art_u16 *)dstptr + n_chan);
#line 415
          dst_alpha = tmp + (tmp >> 15);
        }
#line 417
        if ((unsigned int )alpha_type == 1U) {
#line 418
          dst_mul = dst_alpha;
        } else {
#line 420
          dst_mul = (art_u32 )65536;
        }
      }
#line 425
      if (depth == 8U) {
#line 427
        dst_mul *= 257U;
#line 428
        j = 0;
        {
#line 428
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 428
          if (! (j < n_chan)) {
#line 428
            goto while_break___3;
          }
#line 429
          dst[j] = (art_u16 )(((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16);
#line 428
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 431
      if (buf_depth == 16) {
#line 433
        j = 0;
        {
#line 433
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 433
          if (! (j < n_chan)) {
#line 433
            goto while_break___4;
          }
#line 434
          dst[j] = (art_u16 )(((art_u32 )*((art_u16 *)dstptr + j) * dst_mul + 32768U) >> 16);
#line 433
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 438
      j = 0;
      {
#line 438
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 438
        if (! (j < n_chan)) {
#line 438
          goto while_break___5;
        }
#line 443
        srcv = (art_u32 )src[j];
#line 444
        dstv = (art_u32 )dst[j];
#line 445
        tmp___0 = ((dstv * (65536U - src_alpha) + 32768U) >> 16) + srcv;
#line 446
        tmp___0 -= tmp___0 >> 16;
#line 447
        dst[j] = (art_u16 )tmp___0;
#line 438
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 450
      if ((unsigned int )alpha_type == 0U) {
#line 452
        if (depth == 8U) {
#line 453
          dst_mul = (art_u32 )255;
        } else {
#line 455
          dst_mul = (art_u32 )65535;
        }
      } else {
#line 459
        if (src_alpha >= 65536U) {
#line 460
          dst_alpha = (art_u32 )65536;
        } else {
#line 462
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 463
        if ((unsigned int )alpha_type == 2U) {
#line 463
          goto _L;
        } else
#line 463
        if (dst_alpha == 0U) {
          _L: /* CIL Label */ 
#line 465
          if (depth == 8U) {
#line 466
            dst_mul = (art_u32 )255;
          } else {
#line 468
            dst_mul = (art_u32 )65535;
          }
        } else
#line 472
        if (depth == 8U) {
#line 473
          dst_mul = 16711680U / dst_alpha;
        } else {
#line 475
          dst_mul = 4294901760U / dst_alpha;
        }
      }
#line 478
      if (depth == 8U) {
#line 480
        j = 0;
        {
#line 480
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 480
          if (! (j < n_chan)) {
#line 480
            goto while_break___6;
          }
#line 481
          *(dstptr + j) = (art_u8 )(((art_u32 )dst[j] * dst_mul + 32768U) >> 16);
#line 480
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 482
        if ((unsigned int )alpha_type != 0U) {
#line 483
          *(dstptr + n_chan) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
        }
      } else
#line 485
      if (depth == 16U) {
#line 487
        j = 0;
        {
#line 487
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 487
          if (! (j < n_chan)) {
#line 487
            goto while_break___7;
          }
#line 488
          *((art_u16 *)dstptr + j) = (art_u16 )(((art_u32 )dst[j] * dst_mul + 32768U) >> 16);
#line 487
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 489
        if ((unsigned int )alpha_type != 0U) {
#line 490
          *((art_u16 *)dstptr + n_chan) = (art_u16 )((dst_alpha * 65535U + 32768U) >> 16);
        }
      }
#line 492
      dstptr += dst_pixstride;
#line 328
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return;
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_composite_obj  =    {& art_render_composite, & art_render_nop_done};
#line 503 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                                   int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *alpha_buf ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  art_u32 alpha ;
  int image_ix ;
  int n_chan ;
  ArtAlphaType alpha_type ;
  int n_ch ;
  int dst_pixstride ;
  ArtAlphaType buf_alpha ;
  int buf_n_ch ;
  int buf_pixstride ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___0 ;

  {
#line 507
  run = render->run;
#line 508
  n_run = render->n_run;
#line 509
  x0 = render->x0;
#line 512
  alpha_buf = render->alpha_buf;
#line 513
  image_buf = render->image_buf;
#line 519
  n_chan = render->n_chan;
#line 520
  alpha_type = render->alpha_type;
#line 521
  n_ch = n_chan + ((unsigned int )alpha_type != 0U);
#line 522
  dst_pixstride = n_ch;
#line 523
  buf_alpha = render->buf_alpha;
#line 524
  buf_n_ch = n_chan + ((unsigned int )buf_alpha != 0U);
#line 525
  buf_pixstride = buf_n_ch;
#line 533
  image_ix = 0;
#line 534
  i = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < n_run - 1)) {
#line 534
      goto while_break;
    }
#line 536
    run_x0 = (run + i)->x;
#line 537
    run_x1 = (run + (i + 1))->x;
#line 538
    tmp = (art_u32 )(run + i)->alpha;
#line 539
    if (tmp < 65536U) {
#line 540
      goto __Cont;
    }
#line 542
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 543
    bufptr = image_buf + (run_x0 - x0) * buf_pixstride;
#line 544
    dstptr = dest + (run_x0 - x0) * dst_pixstride;
#line 545
    x = run_x0;
    {
#line 545
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 545
      if (! (x < run_x1)) {
#line 545
        goto while_break___0;
      }
#line 547
      if (alpha_buf) {
#line 549
        tmp = run_alpha * (art_u32 )*(alpha_buf + (x - x0)) + 128U;
#line 551
        alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
      } else {
#line 554
        alpha = run_alpha;
      }
#line 559
      if ((unsigned int )buf_alpha == 0U) {
#line 561
        src_alpha = alpha;
#line 562
        src_mul = src_alpha;
      } else {
#line 566
        tmp = alpha * (art_u32 )*(bufptr + n_chan) + 128U;
#line 568
        src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
#line 570
        if ((unsigned int )buf_alpha == 1U) {
#line 571
          src_mul = src_alpha;
        } else {
#line 573
          src_mul = alpha;
        }
      }
#line 578
      src_mul *= 257U;
#line 580
      if ((unsigned int )alpha_type == 0U) {
#line 582
        dst_alpha = (art_u32 )65536;
#line 583
        dst_mul = dst_alpha;
      } else {
#line 587
        tmp = (art_u32 )*(dstptr + n_chan);
#line 589
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 590
        if ((unsigned int )alpha_type == 1U) {
#line 591
          dst_mul = dst_alpha;
        } else {
#line 593
          dst_mul = (art_u32 )65536;
        }
      }
#line 598
      dst_mul *= 257U;
#line 600
      if ((unsigned int )alpha_type == 0U) {
#line 602
        dst_save_mul = (art_u32 )255;
      } else {
#line 606
        if (src_alpha >= 65536U) {
#line 607
          dst_alpha = (art_u32 )65536;
        } else {
#line 609
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 610
        if ((unsigned int )alpha_type == 2U) {
#line 612
          dst_save_mul = (art_u32 )255;
        } else
#line 610
        if (dst_alpha == 0U) {
#line 612
          dst_save_mul = (art_u32 )255;
        } else {
#line 616
          dst_save_mul = 16711680U / dst_alpha;
        }
      }
#line 620
      j = 0;
      {
#line 620
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 620
        if (! (j < n_chan)) {
#line 620
          goto while_break___1;
        }
#line 625
        src = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 626
        dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 627
        tmp___0 = ((dst * (65536U - src_alpha) + 32768U) >> 16) + src;
#line 628
        tmp___0 -= tmp___0 >> 16;
#line 629
        *(dstptr + j) = (art_u8 )((tmp___0 * dst_save_mul + 32768U) >> 16);
#line 620
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 631
      if ((unsigned int )alpha_type != 0U) {
#line 632
        *(dstptr + n_chan) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
      }
#line 634
      bufptr += buf_pixstride;
#line 635
      dstptr += dst_pixstride;
#line 545
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  return;
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_composite_8_obj  =    {& art_render_composite_8, & art_render_nop_done};
#line 653 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8_opt1(ArtRenderCallback *self , ArtRender *render ,
                                        art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  int image_ix ;
  art_u8 *bufptr ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;
  art_u8 *tmp___3 ;
  art_u8 *tmp___4 ;
  art_u8 *tmp___5 ;
  art_u8 *tmp___6 ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___7 ;

  {
#line 657
  run = render->run;
#line 658
  n_run = render->n_run;
#line 659
  x0 = render->x0;
#line 662
  image_buf = render->image_buf;
#line 673
  image_ix = 0;
#line 674
  i = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (i < n_run - 1)) {
#line 674
      goto while_break;
    }
#line 676
    run_x0 = (run + i)->x;
#line 677
    run_x1 = (run + (i + 1))->x;
#line 678
    tmp = (art_u32 )(run + i)->alpha;
#line 679
    if (tmp < 65536U) {
#line 680
      goto __Cont;
    }
#line 682
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 683
    bufptr = image_buf + (run_x0 - x0) * 3;
#line 684
    dstptr = dest + (run_x0 - x0) * 4;
#line 685
    if (run_alpha == 65536U) {
#line 687
      x = run_x0;
      {
#line 687
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 687
        if (! (x < run_x1)) {
#line 687
          goto while_break___0;
        }
#line 689
        tmp___0 = dstptr;
#line 689
        dstptr ++;
#line 689
        tmp___1 = bufptr;
#line 689
        bufptr ++;
#line 689
        *tmp___0 = *tmp___1;
#line 690
        tmp___2 = dstptr;
#line 690
        dstptr ++;
#line 690
        tmp___3 = bufptr;
#line 690
        bufptr ++;
#line 690
        *tmp___2 = *tmp___3;
#line 691
        tmp___4 = dstptr;
#line 691
        dstptr ++;
#line 691
        tmp___5 = bufptr;
#line 691
        bufptr ++;
#line 691
        *tmp___4 = *tmp___5;
#line 692
        tmp___6 = dstptr;
#line 692
        dstptr ++;
#line 692
        *tmp___6 = (art_u8 )255;
#line 687
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 697
      x = run_x0;
      {
#line 697
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 697
        if (! (x < run_x1)) {
#line 697
          goto while_break___1;
        }
#line 699
        src_mul = run_alpha * 257U;
#line 701
        tmp = (art_u32 )*(dstptr + 3);
#line 703
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 704
        dst_mul = dst_alpha;
#line 708
        dst_mul *= 257U;
#line 710
        dst_alpha += (((65536U - dst_alpha) * run_alpha >> 8) + 128U) >> 8;
#line 711
        if (dst_alpha == 0U) {
#line 712
          dst_save_mul = (art_u32 )255;
        } else {
#line 714
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 716
        j = 0;
        {
#line 716
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 716
          if (! (j < 3)) {
#line 716
            goto while_break___2;
          }
#line 721
          src = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 722
          dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 723
          tmp___7 = ((dst * (65536U - run_alpha) + 32768U) >> 16) + src;
#line 724
          tmp___7 -= tmp___7 >> 16;
#line 725
          *(dstptr + j) = (art_u8 )((tmp___7 * dst_save_mul + 32768U) >> 16);
#line 716
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 727
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 729
        bufptr += 3;
#line 730
        dstptr += 4;
#line 697
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 674
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_composite_8_opt1_obj  =    {& art_render_composite_8_opt1, & art_render_nop_done};
#line 749 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8_opt2(ArtRenderCallback *self , ArtRender *render ,
                                        art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  int image_ix ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___0 ;
  art_u32 src___0 ;
  art_u32 dst___0 ;
  art_u32 tmp___1 ;

  {
#line 753
  run = render->run;
#line 754
  n_run = render->n_run;
#line 755
  x0 = render->x0;
#line 758
  image_buf = render->image_buf;
#line 770
  image_ix = 0;
#line 771
  i = 0;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i < n_run - 1)) {
#line 771
      goto while_break;
    }
#line 773
    run_x0 = (run + i)->x;
#line 774
    run_x1 = (run + (i + 1))->x;
#line 775
    tmp = (art_u32 )(run + i)->alpha;
#line 776
    if (tmp < 65536U) {
#line 777
      goto __Cont;
    }
#line 779
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 780
    bufptr = image_buf + (run_x0 - x0) * 4;
#line 781
    dstptr = dest + (run_x0 - x0) * 4;
#line 782
    if (run_alpha == 65536U) {
#line 784
      x = run_x0;
      {
#line 784
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 784
        if (! (x < run_x1)) {
#line 784
          goto while_break___0;
        }
#line 786
        src_alpha = (art_u32 )((((int )*(bufptr + 3) << 8) + (int )*(bufptr + 3)) + ((int )*(bufptr + 3) >> 7));
#line 790
        dst_alpha = (art_u32 )((((int )*(dstptr + 3) << 8) + (int )*(dstptr + 3)) + ((int )*(dstptr + 3) >> 7));
#line 794
        dst_mul = dst_alpha * 257U;
#line 796
        if (src_alpha >= 65536U) {
#line 797
          dst_alpha = (art_u32 )65536;
        } else {
#line 799
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 801
        if (dst_alpha == 0U) {
#line 802
          dst_save_mul = (art_u32 )255;
        } else {
#line 804
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 806
        j = 0;
        {
#line 806
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 806
          if (! (j < 3)) {
#line 806
            goto while_break___1;
          }
#line 811
          src = (art_u32 )(((int )*(bufptr + j) << 8) | (int )*(bufptr + j));
#line 812
          dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 813
          tmp___0 = ((dst * (65536U - src_alpha) + 32768U) >> 16) + src;
#line 814
          tmp___0 -= tmp___0 >> 16;
#line 815
          *(dstptr + j) = (art_u8 )((tmp___0 * dst_save_mul + 32768U) >> 16);
#line 806
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 817
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 819
        bufptr += 4;
#line 820
        dstptr += 4;
#line 784
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 825
      x = run_x0;
      {
#line 825
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 825
        if (! (x < run_x1)) {
#line 825
          goto while_break___2;
        }
#line 827
        tmp = run_alpha * (art_u32 )*(bufptr + 3) + 128U;
#line 829
        src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
#line 833
        src_mul = run_alpha * 257U;
#line 835
        tmp = (art_u32 )*(dstptr + 3);
#line 837
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 838
        dst_mul = dst_alpha;
#line 842
        dst_mul *= 257U;
#line 844
        if (src_alpha >= 65536U) {
#line 845
          dst_alpha = (art_u32 )65536;
        } else {
#line 847
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 849
        if (dst_alpha == 0U) {
#line 851
          dst_save_mul = (art_u32 )255;
        } else {
#line 855
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 858
        j = 0;
        {
#line 858
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 858
          if (! (j < 3)) {
#line 858
            goto while_break___3;
          }
#line 863
          src___0 = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 864
          dst___0 = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 865
          tmp___1 = ((dst___0 * (65536U - src_alpha) + 32768U) >> 16) + src___0;
#line 866
          tmp___1 -= tmp___1 >> 16;
#line 867
          *(dstptr + j) = (art_u8 )((tmp___1 * dst_save_mul + 32768U) >> 16);
#line 858
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 869
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 871
        bufptr += 4;
#line 872
        dstptr += 4;
#line 825
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
struct _ArtRenderCallback  const  art_render_composite_8_opt2_obj  =    {& art_render_composite_8_opt2, & art_render_nop_done};
#line 886 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static ArtRenderCallback *art_render_choose_compositing_callback(ArtRender *render ) 
{ 


  {
#line 889
  if (render->depth == 8) {
#line 889
    if (render->buf_depth == 8) {
#line 891
      if (render->n_chan == 3) {
#line 891
        if ((unsigned long )render->alpha_buf == (unsigned long )((void *)0)) {
#line 891
          if ((unsigned int )render->alpha_type == 1U) {
#line 895
            if ((unsigned int )render->buf_alpha == 0U) {
#line 896
              return ((ArtRenderCallback *)(& art_render_composite_8_opt1_obj));
            } else
#line 897
            if ((unsigned int )render->buf_alpha == 2U) {
#line 898
              return ((ArtRenderCallback *)(& art_render_composite_8_opt2_obj));
            }
          }
        }
      }
#line 901
      return ((ArtRenderCallback *)(& art_render_composite_8_obj));
    }
  }
#line 903
  return ((ArtRenderCallback *)(& art_render_composite_obj));
}
}
#line 917 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_invoke_callbacks(ArtRender *render , art_u8 *dest , int y ) 
{ 
  ArtRenderPriv *priv ;
  int i ;
  ArtRenderCallback *callback ;

  {
#line 920
  priv = (ArtRenderPriv *)render;
#line 923
  i = 0;
  {
#line 923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 923
    if (! (i < priv->n_callbacks)) {
#line 923
      goto while_break;
    }
    {
#line 927
    callback = *(priv->callbacks + i);
#line 928
    (*(callback->render))(callback, render, dest, y);
#line 923
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  return;
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_invoke(ArtRender *render ) 
{ 
  ArtRenderPriv *priv ;
  int width ;
  int best_driver ;
  int best_score ;
  int i ;
  int n_callbacks ;
  int n_callbacks_max ;
  ArtImageSource *image_source ;
  ArtImageSourceFlags image_flags ;
  int buf_depth ;
  ArtAlphaType buf_alpha ;
  art_boolean first ;
  void *tmp ;
  int score ;
  ArtMaskSource *mask_source ;
  void *tmp___0 ;
  void *tmp___1 ;
  ArtMaskSource *mask_source___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int bytespp ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  ArtMaskSource *driver ;
  art_u8 *dest_ptr ;
  int y ;
  ArtRenderCallback *callback ;

  {
#line 942
  priv = (ArtRenderPriv *)render;
#line 951
  first = 1;
#line 953
  if ((unsigned long )render == (unsigned long )((void *)0)) {
    {
#line 955
    art_warn("art_render_invoke: called with render == NULL\n");
    }
#line 956
    return;
  }
#line 958
  if ((unsigned long )priv->image_source == (unsigned long )((void *)0)) {
    {
#line 960
    art_warn("art_render_invoke: no image source given\n");
    }
#line 961
    return;
  }
  {
#line 964
  width = render->x1 - render->x0;
#line 966
  tmp = art_alloc((unsigned long )(width + 1) * sizeof(ArtRenderMaskRun ));
#line 966
  render->run = (ArtRenderMaskRun *)tmp;
#line 969
  best_driver = -1;
#line 970
  best_score = 0;
#line 971
  i = 0;
  }
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! (i < priv->n_mask_source)) {
#line 971
      goto while_break;
    }
    {
#line 976
    mask_source = *(priv->mask_source + i);
#line 977
    score = (*(mask_source->can_drive))(mask_source, render);
    }
#line 978
    if (score > best_score) {
#line 980
      best_score = score;
#line 981
      best_driver = i;
    }
#line 971
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  if (priv->n_mask_source > 1) {
    {
#line 989
    tmp___0 = art_alloc((unsigned long )(width * render->depth >> 3) * sizeof(art_u8 ));
#line 989
    render->alpha_buf = (art_u8 *)tmp___0;
    }
  } else
#line 986
  if (priv->n_mask_source == 1) {
#line 986
    if (best_driver < 0) {
      {
#line 989
      tmp___0 = art_alloc((unsigned long )(width * render->depth >> 3) * sizeof(art_u8 ));
#line 989
      render->alpha_buf = (art_u8 *)tmp___0;
      }
    }
  }
  {
#line 993
  image_source = priv->image_source;
#line 994
  (*(image_source->negotiate))(image_source, render, & image_flags, & buf_depth, & buf_alpha);
#line 998
  n_callbacks_max = priv->n_mask_source + 3;
#line 999
  tmp___1 = art_alloc((unsigned long )n_callbacks_max * sizeof(ArtRenderCallback *));
#line 999
  priv->callbacks = (ArtRenderCallback **)tmp___1;
#line 1000
  n_callbacks = 0;
#line 1001
  i = 0;
  }
  {
#line 1001
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1001
    if (! (i < priv->n_mask_source)) {
#line 1001
      goto while_break___0;
    }
#line 1002
    if (i != best_driver) {
      {
#line 1004
      mask_source___0 = *(priv->mask_source + i);
#line 1006
      (*(mask_source___0->prepare))(mask_source___0, render, first);
#line 1007
      first = 0;
#line 1008
      tmp___2 = n_callbacks;
#line 1008
      n_callbacks ++;
#line 1008
      *(priv->callbacks + tmp___2) = & mask_source___0->super;
      }
    }
#line 1001
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1011
  if (render->clear) {
#line 1011
    if (! ((unsigned int )image_flags & 1U)) {
      {
#line 1012
      tmp___3 = n_callbacks;
#line 1012
      n_callbacks ++;
#line 1012
      *(priv->callbacks + tmp___3) = art_render_choose_clear_callback(render);
      }
    }
  }
#line 1015
  tmp___4 = n_callbacks;
#line 1015
  n_callbacks ++;
#line 1015
  *(priv->callbacks + tmp___4) = & image_source->super;
#line 1018
  if (! ((unsigned int )image_flags & 2U)) {
    {
#line 1020
    bytespp = (render->n_chan + ((unsigned int )buf_alpha != 0U)) * buf_depth >> 3;
#line 1022
    render->buf_depth = buf_depth;
#line 1023
    render->buf_alpha = buf_alpha;
#line 1024
    tmp___5 = art_alloc((unsigned long )(width * bytespp) * sizeof(art_u8 ));
#line 1024
    render->image_buf = (art_u8 *)tmp___5;
#line 1025
    tmp___6 = n_callbacks;
#line 1025
    n_callbacks ++;
#line 1025
    *(priv->callbacks + tmp___6) = art_render_choose_compositing_callback(render);
    }
  }
#line 1029
  priv->n_callbacks = n_callbacks;
#line 1031
  if (render->need_span) {
    {
#line 1032
    tmp___7 = art_alloc((unsigned long )(width + 1) * sizeof(int ));
#line 1032
    render->span_x = (int *)tmp___7;
    }
  }
#line 1035
  if (best_driver >= 0) {
    {
#line 1039
    driver = *(priv->mask_source + best_driver);
#line 1040
    (*(driver->invoke_driver))(driver, render);
    }
  } else {
#line 1044
    dest_ptr = render->pixels;
#line 1048
    render->n_run = 2;
#line 1049
    (render->run + 0)->x = render->x0;
#line 1050
    (render->run + 0)->alpha = (int )(32768U + 255U * render->opacity);
#line 1051
    (render->run + 1)->x = render->x1;
#line 1052
    (render->run + 1)->alpha = 32768;
#line 1053
    if (render->need_span) {
#line 1055
      render->n_span = 2;
#line 1056
      *(render->span_x + 0) = render->x0;
#line 1057
      *(render->span_x + 1) = render->x1;
    }
#line 1059
    y = render->y0;
    {
#line 1059
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1059
      if (! (y < render->y1)) {
#line 1059
        goto while_break___1;
      }
      {
#line 1061
      art_render_invoke_callbacks(render, dest_ptr, y);
#line 1062
      dest_ptr += render->rowstride;
#line 1059
      y ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1066
  if ((unsigned long )priv->mask_source != (unsigned long )((void *)0)) {
    {
#line 1067
    art_free((void *)priv->mask_source);
    }
  }
#line 1070
  i = 0;
  {
#line 1070
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1070
    if (! (i < priv->n_callbacks)) {
#line 1070
      goto while_break___2;
    }
    {
#line 1074
    callback = *(priv->callbacks + i);
#line 1075
    (*(callback->done))(callback, render);
#line 1070
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1079
  if ((unsigned long )render->alpha_buf != (unsigned long )((void *)0)) {
    {
#line 1080
    art_free((void *)render->alpha_buf);
    }
  }
#line 1081
  if ((unsigned long )render->image_buf != (unsigned long )((void *)0)) {
    {
#line 1082
    art_free((void *)render->image_buf);
    }
  }
  {
#line 1083
  art_free((void *)render->run);
  }
#line 1084
  if ((unsigned long )render->span_x != (unsigned long )((void *)0)) {
    {
#line 1085
    art_free((void *)render->span_x);
    }
  }
  {
#line 1086
  art_free((void *)priv->callbacks);
#line 1087
  art_free((void *)render);
  }
#line 1088
  return;
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_mask_solid(ArtRender *render , int opacity ) 
{ 
  art_u32 old_opacity ;
  art_u32 new_opacity_tmp ;

  {
#line 1100
  old_opacity = render->opacity;
#line 1103
  if (opacity == 65536) {
#line 1105
    return;
  }
#line 1106
  new_opacity_tmp = old_opacity * (art_u32 )opacity + 32768U;
#line 1107
  render->opacity = new_opacity_tmp >> 16;
#line 1108
  return;
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_add_mask_source(ArtRender *render , ArtMaskSource *mask_source ) 
{ 
  ArtRenderPriv *priv ;
  int n_mask_source ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1124
  priv = (ArtRenderPriv *)render;
#line 1125
  tmp = priv->n_mask_source;
#line 1125
  (priv->n_mask_source) ++;
#line 1125
  n_mask_source = tmp;
#line 1127
  if (n_mask_source == 0) {
    {
#line 1128
    tmp___0 = art_alloc(sizeof(ArtMaskSource *));
#line 1128
    priv->mask_source = (ArtMaskSource **)tmp___0;
    }
  } else
#line 1130
  if (! (n_mask_source & (n_mask_source - 1))) {
    {
#line 1131
    tmp___1 = art_realloc((void *)priv->mask_source, (unsigned long )(n_mask_source << 1) * sizeof(ArtMaskSource *));
#line 1131
    priv->mask_source = (ArtMaskSource **)tmp___1;
    }
  }
#line 1134
  *(priv->mask_source + n_mask_source) = mask_source;
#line 1135
  return;
}
}
#line 1148 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_add_image_source(ArtRender *render , ArtImageSource *image_source ) 
{ 
  ArtRenderPriv *priv ;

  {
#line 1151
  priv = (ArtRenderPriv *)render;
#line 1153
  if ((unsigned long )priv->image_source != (unsigned long )((void *)0)) {
    {
#line 1155
    art_warn("art_render_add_image_source: image source already present.\n");
    }
#line 1156
    return;
  }
#line 1158
  priv->image_source = image_source;
#line 1159
  return;
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_done(ArtRenderCallback *self , ArtRender *render ) 
{ 
  ArtImageSourceSolid *z ;

  {
#line 1176
  z = (ArtImageSourceSolid *)self;
#line 1178
  if ((unsigned long )z->rgbtab != (unsigned long )((void *)0)) {
    {
#line 1179
    art_free((void *)z->rgbtab);
    }
  }
  {
#line 1180
  art_free((void *)self);
  }
#line 1181
  return;
}
}
#line 1183 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8_opaq_init(ArtImageSourceSolid *self , ArtRender *render ) 
{ 
  ArtImageSourceSolid *z ;
  ArtPixMaxDepth color_max ;
  int r_fg ;
  int g_fg ;
  int b_fg ;
  int r_bg ;
  int g_bg ;
  int b_bg ;
  int r ;
  int g ;
  int b ;
  int dr ;
  int dg ;
  int db ;
  int i ;
  int tmp ;
  art_u32 *rgbtab ;
  void *tmp___0 ;

  {
  {
#line 1186
  z = self;
#line 1196
  tmp___0 = art_alloc(256UL * sizeof(art_u32 ));
#line 1196
  rgbtab = (art_u32 *)tmp___0;
#line 1197
  z->rgbtab = rgbtab;
#line 1199
  color_max = self->color[0];
#line 1200
  r_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1201
  color_max = self->color[1];
#line 1202
  g_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1203
  color_max = self->color[2];
#line 1204
  b_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1206
  color_max = render->clear_color[0];
#line 1207
  r_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1208
  color_max = render->clear_color[1];
#line 1209
  g_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1210
  color_max = render->clear_color[2];
#line 1211
  b_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1213
  r = (r_bg << 16) + 32768;
#line 1214
  g = (g_bg << 16) + 32768;
#line 1215
  b = (b_bg << 16) + 32768;
#line 1216
  tmp = ((r_fg - r_bg) << 16) + 128;
#line 1217
  dr = (tmp + (tmp >> 8)) >> 8;
#line 1218
  tmp = ((g_fg - g_bg) << 16) + 128;
#line 1219
  dg = (tmp + (tmp >> 8)) >> 8;
#line 1220
  tmp = ((b_fg - b_bg) << 16) + 128;
#line 1221
  db = (tmp + (tmp >> 8)) >> 8;
#line 1223
  i = 0;
  }
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (i < 256)) {
#line 1223
      goto while_break;
    }
#line 1225
    *(rgbtab + i) = (art_u32 )(((r & 16711680) | ((g & 16711680) >> 8)) | (b >> 16));
#line 1226
    r += dr;
#line 1227
    g += dg;
#line 1228
    b += db;
#line 1223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1230
  return;
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8_opaq(ArtRenderCallback *self , ArtRender *render ,
                                             art_u8 *dest , int y ) 
{ 
  ArtImageSourceSolid *z ;
  ArtRenderMaskRun *run ;
  int n_run ;
  art_u32 *rgbtab ;
  art_u32 rgb ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  int i ;
  int ix ;

  {
#line 1236
  z = (ArtImageSourceSolid *)self;
#line 1237
  run = render->run;
#line 1238
  n_run = render->n_run;
#line 1239
  rgbtab = z->rgbtab;
#line 1241
  x0 = render->x0;
#line 1242
  x1 = render->x1;
#line 1247
  if (n_run > 0) {
#line 1249
    run_x1 = (run + 0)->x;
#line 1250
    if (run_x1 > x0) {
      {
#line 1252
      rgb = *(rgbtab + 0);
#line 1253
      art_rgb_fill_run(dest, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U), (art_u8 )(rgb & 255U),
                       run_x1 - x0);
      }
    }
#line 1257
    i = 0;
    {
#line 1257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1257
      if (! (i < n_run - 1)) {
#line 1257
        goto while_break;
      }
#line 1259
      run_x0 = run_x1;
#line 1260
      run_x1 = (run + (i + 1))->x;
#line 1261
      rgb = *(rgbtab + (((run + i)->alpha >> 16) & 255));
#line 1262
      ix = (run_x0 - x0) * 3;
#line 1265
      if (run_x1 - run_x0 == 1) {
#line 1267
        *(dest + ix) = (art_u8 )(rgb >> 16);
#line 1268
        *(dest + (ix + 1)) = (art_u8 )((rgb >> 8) & 255U);
#line 1269
        *(dest + (ix + 2)) = (art_u8 )(rgb & 255U);
      } else {
        {
#line 1273
        art_rgb_fill_run(dest + ix, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                         (art_u8 )(rgb & 255U), run_x1 - run_x0);
        }
      }
#line 1257
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1286
    run_x1 = x0;
  }
#line 1288
  if (run_x1 < x1) {
    {
#line 1290
    rgb = *(rgbtab + 0);
#line 1291
    art_rgb_fill_run(dest + (run_x1 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                     (art_u8 )(rgb & 255U), x1 - run_x1);
    }
  }
#line 1295
  return;
}
}
#line 1297 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8(ArtRenderCallback *self , ArtRender *render ,
                                        art_u8 *dest , int y ) 
{ 
  ArtImageSourceSolid *z ;
  int width ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  ArtPixMaxDepth color_max ;

  {
#line 1301
  z = (ArtImageSourceSolid *)self;
#line 1302
  width = render->x1 - render->x0;
#line 1307
  if (z->init) {
#line 1308
    return;
  }
  {
#line 1309
  z->init = 1;
#line 1311
  color_max = z->color[0];
#line 1312
  r = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1313
  color_max = z->color[1];
#line 1314
  g = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1315
  color_max = z->color[2];
#line 1316
  b = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1318
  art_rgb_fill_run(render->image_buf, r, g, b, width);
  }
#line 1319
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void (*render_cbk)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                          int y )  ;
#line 1321 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_negotiate(ArtImageSource *self , ArtRender *render ,
                                             ArtImageSourceFlags *p_flags , int *p_buf_depth ,
                                             ArtAlphaType *p_alpha ) 
{ 
  ArtImageSourceSolid *z ;
  ArtImageSourceFlags flags ;

  {
#line 1326
  z = (ArtImageSourceSolid *)self;
#line 1327
  flags = (ArtImageSourceFlags )0;
#line 1331
  render_cbk = (void (*)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                         int y ))((void *)0);
#line 1333
  if (render->depth == 8) {
#line 1333
    if (render->n_chan == 3) {
#line 1333
      if ((unsigned int )render->alpha_type == 0U) {
#line 1336
        if (render->clear) {
          {
#line 1338
          render_cbk = & art_render_image_solid_rgb8_opaq;
#line 1339
          flags = (ArtImageSourceFlags )((unsigned int )flags | 3U);
#line 1340
          art_render_image_solid_rgb8_opaq_init(z, render);
          }
        }
      }
    }
  }
#line 1343
  if ((unsigned long )render_cbk == (unsigned long )((void *)0)) {
#line 1345
    if (render->depth == 8) {
#line 1347
      render_cbk = & art_render_image_solid_rgb8;
#line 1348
      *p_buf_depth = 8;
#line 1349
      *p_alpha = (ArtAlphaType )0;
    }
  }
#line 1353
  self->super.render = render_cbk;
#line 1354
  *p_flags = flags;
#line 1355
  return;
}
}
#line 1365 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
void art_render_image_solid(ArtRender *render , ArtPixMaxDepth *color ) 
{ 
  ArtImageSourceSolid *image_source ;
  int i ;
  void *tmp ;

  {
  {
#line 1371
  tmp = art_alloc(sizeof(ArtImageSourceSolid ));
#line 1371
  image_source = (ArtImageSourceSolid *)tmp;
#line 1372
  image_source->super.super.render = (void (*)(ArtRenderCallback *self , ArtRender *render ,
                                               art_u8 *dest , int y ))((void *)0);
#line 1373
  image_source->super.super.done = & art_render_image_solid_done;
#line 1374
  image_source->super.negotiate = & art_render_image_solid_negotiate;
#line 1376
  i = 0;
  }
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! (i < render->n_chan)) {
#line 1376
      goto while_break;
    }
#line 1377
    image_source->color[i] = *(color + i);
#line 1376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1379
  image_source->rgbtab = (art_u32 *)((void *)0);
#line 1380
  image_source->init = 0;
#line 1382
  art_render_add_image_source(render, & image_source->super);
  }
#line 1383
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtPriQ *art_pri_new(void) 
{ 
  ArtPriQ *result ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 65
  tmp = art_alloc(sizeof(ArtPriQ ));
#line 65
  result = (ArtPriQ *)tmp;
#line 67
  result->n_items = 0;
#line 68
  result->n_items_max = 16;
#line 69
  tmp___0 = art_alloc((unsigned long )result->n_items_max * sizeof(ArtPriPoint *));
#line 69
  result->items = (ArtPriPoint **)tmp___0;
  }
#line 70
  return (result);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_free(ArtPriQ *pq ) 
{ 


  {
  {
#line 76
  art_free((void *)pq->items);
#line 77
  art_free((void *)pq);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static art_boolean art_pri_empty(ArtPriQ *pq ) 
{ 


  {
#line 83
  return (pq->n_items == 0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_bubble_up(ArtPriQ *pq , int vacant , ArtPriPoint *missing ) 
{ 
  ArtPriPoint **items ;
  int parent ;

  {
#line 94
  items = pq->items;
#line 97
  parent = (vacant - 1) >> 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (vacant > 0) {
#line 98
      if (! (missing->y < (*(items + parent))->y)) {
#line 98
        if (missing->y == (*(items + parent))->y) {
#line 98
          if (! (missing->x < (*(items + parent))->x)) {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
      }
    } else {
#line 98
      goto while_break;
    }
#line 102
    *(items + vacant) = *(items + parent);
#line 103
    vacant = parent;
#line 104
    parent = (vacant - 1) >> 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  *(items + vacant) = missing;
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_insert(ArtPriQ *pq , ArtPriPoint *point ) 
{ 
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 113
  if (pq->n_items == pq->n_items_max) {
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (pq->n_items_max) {
        {
#line 114
        tmp = pq->n_items_max << 1;
#line 114
        pq->n_items_max = tmp;
#line 114
        tmp___0 = art_realloc((void *)pq->items, (unsigned long )tmp * sizeof(ArtPriPoint *));
#line 114
        pq->items = (ArtPriPoint **)tmp___0;
        }
      } else {
        {
#line 114
        pq->n_items_max = 1;
#line 114
        tmp___1 = art_alloc(sizeof(ArtPriPoint *));
#line 114
        pq->items = (ArtPriPoint **)tmp___1;
        }
      }
#line 114
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 116
  tmp___2 = pq->n_items;
#line 116
  (pq->n_items) ++;
#line 116
  art_pri_bubble_up(pq, tmp___2, point);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_sift_down_from_root(ArtPriQ *pq , ArtPriPoint *missing ) 
{ 
  ArtPriPoint **items ;
  int vacant ;
  int child ;
  int n ;

  {
#line 122
  items = pq->items;
#line 123
  vacant = 0;
#line 123
  child = 2;
#line 124
  n = pq->n_items;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (child < n)) {
#line 126
      goto while_break;
    }
#line 128
    if ((*(items + (child - 1)))->y < (*(items + child))->y) {
#line 131
      child --;
    } else
#line 128
    if ((*(items + (child - 1)))->y == (*(items + child))->y) {
#line 128
      if ((*(items + (child - 1)))->x < (*(items + child))->x) {
#line 131
        child --;
      }
    }
#line 132
    *(items + vacant) = *(items + child);
#line 133
    vacant = child;
#line 134
    child = (vacant + 1) << 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (child == n) {
#line 138
    *(items + vacant) = *(items + (n - 1));
#line 139
    vacant = n - 1;
  }
  {
#line 142
  art_pri_bubble_up(pq, vacant, missing);
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtPriPoint *art_pri_choose(ArtPriQ *pq ) 
{ 
  ArtPriPoint *result ;

  {
  {
#line 148
  result = *(pq->items + 0);
#line 150
  (pq->n_items) --;
#line 150
  art_pri_sift_down_from_root(pq, *(pq->items + pq->n_items));
  }
#line 151
  return (result);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static int art_svp_writer_rewind_add_segment(ArtSvpWriter *self , int wind_left ,
                                             int delta_wind , double x , double y ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVP *svp ;
  ArtSVPSeg *seg ;
  art_boolean left_filled ;
  art_boolean right_filled ;
  int wind_right ;
  int seg_num ;
  int init_n_points_max ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 318
  swr = (ArtSvpWriterRewind *)self;
#line 322
  wind_right = wind_left + delta_wind;
#line 324
  init_n_points_max = 4;
  {
#line 328
  if ((unsigned int )swr->rule == 0U) {
#line 328
    goto case_0;
  }
#line 332
  if ((unsigned int )swr->rule == 1U) {
#line 332
    goto case_1;
  }
#line 336
  if ((unsigned int )swr->rule == 2U) {
#line 336
    goto case_2;
  }
#line 340
  if ((unsigned int )swr->rule == 3U) {
#line 340
    goto case_3;
  }
#line 344
  goto switch_default;
  case_0: /* CIL Label */ 
#line 329
  left_filled = wind_left != 0;
#line 330
  right_filled = wind_right != 0;
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 333
  left_filled = wind_left > 1;
#line 334
  right_filled = wind_right > 1;
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
#line 337
  left_filled = wind_left & 1;
#line 338
  right_filled = wind_right & 1;
#line 339
  goto switch_break;
  case_3: /* CIL Label */ 
#line 341
  left_filled = wind_left > 0;
#line 342
  right_filled = wind_right > 0;
#line 343
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 345
  art_die("Unknown wind rule %d\n", (unsigned int )swr->rule);
  }
  switch_break: /* CIL Label */ ;
  }
#line 347
  if (left_filled == right_filled) {
#line 354
    return (-1);
  }
#line 357
  svp = swr->svp;
#line 358
  tmp = svp->n_segs;
#line 358
  (svp->n_segs) ++;
#line 358
  seg_num = tmp;
#line 359
  if (swr->n_segs_max == seg_num) {
    {
#line 361
    swr->n_segs_max <<= 1;
#line 362
    tmp___0 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(swr->n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 362
    svp = (ArtSVP *)tmp___0;
#line 365
    swr->svp = svp;
#line 366
    tmp___1 = art_realloc((void *)swr->n_points_max, (unsigned long )swr->n_segs_max * sizeof(int ));
#line 366
    swr->n_points_max = (int *)tmp___1;
    }
  }
  {
#line 369
  seg = & svp->segs[seg_num];
#line 370
  seg->n_points = 1;
#line 371
  seg->dir = right_filled;
#line 372
  *(swr->n_points_max + seg_num) = init_n_points_max;
#line 373
  seg->bbox.x0 = x;
#line 374
  seg->bbox.y0 = y;
#line 375
  seg->bbox.x1 = x;
#line 376
  seg->bbox.y1 = y;
#line 377
  tmp___2 = art_alloc((unsigned long )init_n_points_max * sizeof(ArtPoint ));
#line 377
  seg->points = (ArtPoint *)tmp___2;
#line 378
  (seg->points + 0)->x = x;
#line 379
  (seg->points + 0)->y = y;
  }
#line 385
  return (seg_num);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_writer_rewind_add_point(ArtSvpWriter *self , int seg_id , double x ,
                                            double y ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVPSeg *seg ;
  int n_points ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 392
  swr = (ArtSvpWriterRewind *)self;
#line 399
  if (seg_id < 0) {
#line 401
    return;
  }
#line 403
  seg = & (swr->svp)->segs[seg_id];
#line 404
  tmp = seg->n_points;
#line 404
  (seg->n_points) ++;
#line 404
  n_points = tmp;
#line 405
  if (*(swr->n_points_max + seg_id) == n_points) {
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
#line 406
      if (*(swr->n_points_max + seg_id)) {
        {
#line 406
        tmp___0 = *(swr->n_points_max + seg_id) << 1;
#line 406
        *(swr->n_points_max + seg_id) = tmp___0;
#line 406
        tmp___1 = art_realloc((void *)seg->points, (unsigned long )tmp___0 * sizeof(ArtPoint ));
#line 406
        seg->points = (ArtPoint *)tmp___1;
        }
      } else {
        {
#line 406
        *(swr->n_points_max + seg_id) = 1;
#line 406
        tmp___2 = art_alloc(sizeof(ArtPoint ));
#line 406
        seg->points = (ArtPoint *)tmp___2;
        }
      }
#line 406
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 407
  (seg->points + n_points)->x = x;
#line 408
  (seg->points + n_points)->y = y;
#line 409
  if (x < seg->bbox.x0) {
#line 410
    seg->bbox.x0 = x;
  }
#line 411
  if (x > seg->bbox.x1) {
#line 412
    seg->bbox.x1 = x;
  }
#line 413
  seg->bbox.y1 = y;
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_writer_rewind_close_segment(ArtSvpWriter *self , int seg_id ) 
{ 


  {
#line 437
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
ArtSVP *art_svp_writer_rewind_reap(ArtSvpWriter *self ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVP *result ;

  {
  {
#line 442
  swr = (ArtSvpWriterRewind *)self;
#line 443
  result = swr->svp;
#line 445
  art_free((void *)swr->n_points_max);
#line 446
  art_free((void *)swr);
  }
#line 447
  return (result);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
ArtSvpWriter *art_svp_writer_rewind_new(ArtWindRule rule ) 
{ 
  ArtSvpWriterRewind *result ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 453
  tmp = art_alloc(sizeof(ArtSvpWriterRewind ));
#line 453
  result = (ArtSvpWriterRewind *)tmp;
#line 455
  result->super.add_segment = & art_svp_writer_rewind_add_segment;
#line 456
  result->super.add_point = & art_svp_writer_rewind_add_point;
#line 457
  result->super.close_segment = & art_svp_writer_rewind_close_segment;
#line 459
  result->rule = rule;
#line 460
  result->n_segs_max = 16;
#line 461
  tmp___0 = art_alloc(sizeof(ArtSVP ) + (unsigned long )(result->n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 461
  result->svp = (ArtSVP *)tmp___0;
#line 463
  (result->svp)->n_segs = 0;
#line 464
  tmp___1 = art_alloc((unsigned long )result->n_segs_max * sizeof(int ));
#line 464
  result->n_points_max = (int *)tmp___1;
  }
#line 466
  return (& result->super);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_setup_seg(ArtActiveSeg *seg , ArtPriPoint *pri_pt ) 
{ 
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  int tmp ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double dx ;
  double dy ;
  double s ;
  double a ;
  double b ;
  double r2 ;
  double tmp___0 ;

  {
#line 549
  in_seg = seg->in_seg;
#line 550
  tmp = seg->in_curs;
#line 550
  (seg->in_curs) ++;
#line 550
  in_curs = tmp;
#line 555
  x0 = (in_seg->points + in_curs)->x;
#line 556
  y0___0 = (in_seg->points + in_curs)->y;
#line 557
  x1 = (in_seg->points + (in_curs + 1))->x;
#line 558
  y1___0 = (in_seg->points + (in_curs + 1))->y;
#line 559
  pri_pt->x = x1;
#line 560
  pri_pt->y = y1___0;
#line 561
  dx = x1 - x0;
#line 562
  dy = y1___0 - y0___0;
#line 563
  r2 = dx * dx + dy * dy;
#line 564
  if (r2 == (double )0) {
#line 564
    s = (double )1;
  } else {
    {
#line 564
    tmp___0 = sqrt(r2);
#line 564
    s = (double )1 / tmp___0;
    }
  }
#line 565
  a = dy * s;
#line 565
  seg->a = a;
#line 566
  b = - dx * s;
#line 566
  seg->b = b;
#line 567
  seg->c = - (a * x0 + b * y0___0);
#line 568
  seg->flags = (seg->flags & -2) | (dx > (double )0);
#line 569
  seg->x[0] = x0;
#line 570
  seg->x[1] = x1;
#line 571
  seg->y0 = y0___0;
#line 572
  seg->y1 = y1___0;
#line 573
  seg->n_stack = 1;
#line 574
  (seg->stack + 0)->x = x1;
#line 575
  (seg->stack + 0)->y = y1___0;
#line 576
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_add_horiz(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg **pp ;
  ArtActiveSeg *place ;
  ArtActiveSeg *place_right ;

  {
#line 596
  pp = & ctx->horiz_last;
#line 598
  place_right = (ArtActiveSeg *)((void *)0);
#line 602
  if (seg->flags & 16) {
    {
#line 604
    art_warn("*** attempt to put segment in horiz list twice\n");
    }
#line 605
    return;
  }
#line 607
  seg->flags |= 16;
#line 613
  place = *pp;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if ((unsigned long )place != (unsigned long )((void *)0)) {
#line 613
      if (! (place->horiz_x > seg->horiz_x)) {
#line 613
        if (place->horiz_x == seg->horiz_x) {
#line 613
          if (! (place->b < seg->b)) {
#line 613
            goto while_break;
          }
        } else {
#line 613
          goto while_break;
        }
      }
    } else {
#line 613
      goto while_break;
    }
#line 618
    place_right = place;
#line 619
    pp = & place->horiz_left;
#line 613
    place = *pp;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  *pp = seg;
#line 622
  seg->horiz_left = place;
#line 623
  seg->horiz_right = place_right;
#line 624
  if ((unsigned long )place == (unsigned long )((void *)0)) {
#line 625
    ctx->horiz_first = seg;
  } else {
#line 627
    place->horiz_right = seg;
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_push_pt(ArtIntersectCtx *ctx , ArtActiveSeg *seg , double x ,
                                      double y ) 
{ 
  ArtPriPoint *pri_pt ;
  int n_stack ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 635
  n_stack = seg->n_stack;
#line 637
  if (n_stack == seg->n_stack_max) {
    {
#line 638
    while (1) {
      while_continue: /* CIL Label */ ;
#line 638
      if (seg->n_stack_max) {
        {
#line 638
        tmp = seg->n_stack_max << 1;
#line 638
        seg->n_stack_max = tmp;
#line 638
        tmp___0 = art_realloc((void *)seg->stack, (unsigned long )tmp * sizeof(ArtPoint ));
#line 638
        seg->stack = (ArtPoint *)tmp___0;
        }
      } else {
        {
#line 638
        seg->n_stack_max = 1;
#line 638
        tmp___1 = art_alloc(sizeof(ArtPoint ));
#line 638
        seg->stack = (ArtPoint *)tmp___1;
        }
      }
#line 638
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 639
  (seg->stack + n_stack)->x = x;
#line 640
  (seg->stack + n_stack)->y = y;
#line 641
  (seg->n_stack) ++;
#line 643
  seg->x[1] = x;
#line 644
  seg->y1 = y;
#line 646
  tmp___2 = art_alloc(sizeof(ArtPriPoint ));
#line 646
  pri_pt = (ArtPriPoint *)tmp___2;
#line 647
  pri_pt->x = x;
#line 648
  pri_pt->y = y;
#line 649
  pri_pt->user_data = (void *)seg;
#line 650
  art_pri_insert(ctx->pq, pri_pt);
  }
#line 651
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static double art_svp_intersect_break(ArtIntersectCtx *ctx , ArtActiveSeg *seg , double x_ref ,
                                      double y , ArtBreakFlags break_flags ) 
{ 
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  double x ;
  int tmp ;

  {
#line 671
  in_seg = seg->in_seg;
#line 672
  in_curs = seg->in_curs;
#line 675
  x0 = (in_seg->points + (in_curs - 1))->x;
#line 676
  y0___0 = (in_seg->points + (in_curs - 1))->y;
#line 677
  x1 = (in_seg->points + in_curs)->x;
#line 678
  y1___0 = (in_seg->points + in_curs)->y;
#line 679
  x = x0 + (x1 - x0) * ((y - y0___0) / (y1___0 - y0___0));
#line 680
  if ((unsigned int )break_flags == 1U) {
#line 680
    if (x > x_ref) {
#line 680
      tmp = 1;
    } else {
#line 680
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 680
  if ((unsigned int )break_flags == 2U) {
#line 680
    if (x < x_ref) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 693
  if (y > ctx->y) {
    {
#line 694
    art_svp_intersect_push_pt(ctx, seg, x, y);
    }
  } else {
    {
#line 697
    seg->x[0] = x;
#line 698
    seg->y0 = y;
#line 699
    seg->horiz_x = x;
#line 700
    art_svp_intersect_add_horiz(ctx, seg);
    }
  }
#line 703
  return (x);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtActiveSeg *art_svp_intersect_add_point(ArtIntersectCtx *ctx , double x ,
                                                 double y , ArtActiveSeg *seg , ArtBreakFlags break_flags ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  double x_min ;
  double x_max ;
  art_boolean left_live ;
  art_boolean right_live ;
  double d ;
  double new_x ;
  ArtActiveSeg *test ;
  ArtActiveSeg *result ;
  double x_test ;
  int tmp ;
  int tmp___0 ;

  {
#line 721
  x_min = x;
#line 721
  x_max = x;
#line 725
  result = (ArtActiveSeg *)((void *)0);
#line 728
  left = seg;
#line 729
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 730
    right = ctx->active_head;
  } else {
#line 732
    right = left->right;
  }
#line 733
  if ((unsigned int )break_flags & 1U) {
#line 733
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 733
      tmp = 1;
    } else {
#line 733
      tmp = 0;
    }
  } else {
#line 733
    tmp = 0;
  }
#line 733
  left_live = tmp;
#line 734
  if ((unsigned int )break_flags & 2U) {
#line 734
    if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 734
      tmp___0 = 1;
    } else {
#line 734
      tmp___0 = 0;
    }
  } else {
#line 734
    tmp___0 = 0;
  }
#line 734
  right_live = tmp___0;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! left_live) {
#line 735
      if (! right_live) {
#line 735
        goto while_break;
      }
    }
#line 737
    if (left_live) {
#line 739
      if (x <= left->x[left->flags & 1]) {
#line 739
        if (y != left->y0) {
#line 739
          if (y < left->y1) {
#line 744
            d = (x_min * left->a + y * left->b) + left->c;
#line 745
            if (d < 1e-5) {
              {
#line 747
              new_x = art_svp_intersect_break(ctx, left, x_min, y, (ArtBreakFlags )1);
              }
#line 749
              if (new_x > x_max) {
#line 751
                x_max = new_x;
#line 752
                right_live = (unsigned long )right != (unsigned long )((void *)0);
              } else
#line 754
              if (new_x < x_min) {
#line 755
                x_min = new_x;
              }
#line 756
              left = left->left;
#line 757
              left_live = (unsigned long )left != (unsigned long )((void *)0);
            } else {
#line 760
              left_live = 0;
            }
          } else {
#line 763
            left_live = 0;
          }
        } else {
#line 763
          left_live = 0;
        }
      } else {
#line 763
        left_live = 0;
      }
    } else
#line 765
    if (right_live) {
#line 767
      if (x >= right->x[(right->flags & 1) ^ 1]) {
#line 767
        if (y != right->y0) {
#line 767
          if (y < right->y1) {
#line 772
            d = (x_max * right->a + y * right->b) + right->c;
#line 773
            if (d > - 1e-5) {
              {
#line 775
              new_x = art_svp_intersect_break(ctx, right, x_max, y, (ArtBreakFlags )2);
              }
#line 777
              if (new_x < x_min) {
#line 779
                x_min = new_x;
#line 780
                left_live = (unsigned long )left != (unsigned long )((void *)0);
              } else
#line 782
              if (new_x >= x_max) {
#line 783
                x_max = new_x;
              }
#line 784
              right = right->right;
#line 785
              right_live = (unsigned long )right != (unsigned long )((void *)0);
            } else {
#line 788
              right_live = 0;
            }
          } else {
#line 791
            right_live = 0;
          }
        } else {
#line 791
          right_live = 0;
        }
      } else {
#line 791
        right_live = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 800
    test = ctx->active_head;
  } else {
#line 800
    test = left->right;
  }
#line 801
  result = left;
#line 802
  if ((unsigned long )test != (unsigned long )((void *)0)) {
#line 802
    if ((unsigned long )test != (unsigned long )right) {
#line 804
      if (y == test->y0) {
#line 805
        x_test = test->x[0];
      } else {
#line 807
        x_test = test->x[1];
      }
      {
#line 808
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 810
        if (x_test <= x) {
#line 811
          result = test;
        }
#line 812
        test = test->right;
#line 813
        if ((unsigned long )test == (unsigned long )right) {
#line 814
          goto while_break___0;
        }
#line 815
        new_x = x_test;
#line 816
        if (new_x < x_test) {
          {
#line 818
          art_warn("art_svp_intersect_add_point: non-ascending x\n");
          }
        }
#line 820
        x_test = new_x;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 823
  return (result);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_swap_active(ArtIntersectCtx *ctx , ArtActiveSeg *left_seg ,
                                          ArtActiveSeg *right_seg ) 
{ 


  {
#line 830
  right_seg->left = left_seg->left;
#line 831
  if ((unsigned long )right_seg->left != (unsigned long )((void *)0)) {
#line 832
    (right_seg->left)->right = right_seg;
  } else {
#line 834
    ctx->active_head = right_seg;
  }
#line 835
  left_seg->right = right_seg->right;
#line 836
  if ((unsigned long )left_seg->right != (unsigned long )((void *)0)) {
#line 837
    (left_seg->right)->left = left_seg;
  }
#line 838
  left_seg->left = right_seg;
#line 839
  right_seg->right = left_seg;
#line 840
  return;
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static art_boolean art_svp_intersect_test_cross(ArtIntersectCtx *ctx , ArtActiveSeg *left_seg ,
                                                ArtActiveSeg *right_seg , ArtBreakFlags break_flags ) 
{ 
  double left_x0 ;
  double left_y0 ;
  double left_x1 ;
  double left_y1 ;
  double right_y1 ;
  double d ;
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  double d0 ;
  double d1 ;
  double t ;
  double x ;
  double y ;
  double left_x1___0 ;
  double right_x1 ;
  double tmp ;
  double right_x1___0 ;
  double left_x1___1 ;
  double tmp___0 ;
  double left_x1___2 ;
  double right_x1___1 ;
  double left_x1___3 ;
  double right_x1___2 ;
  double tmp___1 ;
  double right_x1___3 ;
  double left_x1___4 ;
  double tmp___2 ;
  double left_x1___5 ;
  double right_x1___4 ;
  ArtActiveSeg *winner ;
  ArtActiveSeg *loser ;

  {
#line 861
  left_y1 = left_seg->y1;
#line 862
  right_y1 = right_seg->y1;
#line 877
  if (left_seg->y0 == right_seg->y0) {
#line 877
    if (left_seg->x[0] == right_seg->x[0]) {
#line 884
      if (left_y1 < right_y1) {
#line 887
        left_x1___0 = left_seg->x[1];
#line 889
        if (left_x1___0 < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 892
          return (0);
        } else
#line 889
        if (left_y1 == right_seg->y0) {
#line 892
          return (0);
        }
#line 893
        d = (left_x1___0 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 894
        if (d < - 1e-5) {
#line 895
          return (0);
        } else
#line 896
        if (d < 1e-5) {
          {
#line 899
          tmp = art_svp_intersect_break(ctx, right_seg, left_x1___0, left_y1, (ArtBreakFlags )2);
#line 899
          right_x1 = tmp;
          }
#line 902
          if (left_x1___0 <= right_x1) {
#line 903
            return (0);
          }
        }
      } else
#line 906
      if (left_y1 > right_y1) {
#line 909
        right_x1___0 = right_seg->x[1];
#line 911
        if (right_x1___0 > left_seg->x[left_seg->flags & 1]) {
#line 913
          return (0);
        } else
#line 911
        if (right_y1 == left_seg->y0) {
#line 913
          return (0);
        }
#line 914
        d = (right_x1___0 * left_seg->a + right_y1 * left_seg->b) + left_seg->c;
#line 915
        if (d > 1e-5) {
#line 916
          return (0);
        } else
#line 917
        if (d > - 1e-5) {
          {
#line 920
          tmp___0 = art_svp_intersect_break(ctx, left_seg, right_x1___0, right_y1,
                                            (ArtBreakFlags )1);
#line 920
          left_x1___1 = tmp___0;
          }
#line 923
          if (left_x1___1 <= right_x1___0) {
#line 924
            return (0);
          }
        }
      } else {
#line 929
        left_x1___2 = left_seg->x[1];
#line 930
        right_x1___1 = right_seg->x[1];
#line 932
        if (left_x1___2 <= right_x1___1) {
#line 933
          return (0);
        }
      }
      {
#line 935
      art_svp_intersect_swap_active(ctx, left_seg, right_seg);
      }
#line 936
      return (1);
    }
  }
#line 939
  if (left_y1 < right_y1) {
#line 942
    left_x1___3 = left_seg->x[1];
#line 944
    if (left_x1___3 < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 947
      return (0);
    } else
#line 944
    if (left_y1 == right_seg->y0) {
#line 947
      return (0);
    }
#line 948
    d = (left_x1___3 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 949
    if (d < - 1e-5) {
#line 950
      return (0);
    } else
#line 951
    if (d < 1e-5) {
      {
#line 953
      tmp___1 = art_svp_intersect_break(ctx, right_seg, left_x1___3, left_y1, (ArtBreakFlags )2);
#line 953
      right_x1___2 = tmp___1;
      }
#line 956
      if (left_x1___3 <= right_x1___2) {
#line 957
        return (0);
      }
    }
  } else
#line 960
  if (left_y1 > right_y1) {
#line 963
    right_x1___3 = right_seg->x[1];
#line 965
    if (right_x1___3 > left_seg->x[left_seg->flags & 1]) {
#line 967
      return (0);
    } else
#line 965
    if (right_y1 == left_seg->y0) {
#line 967
      return (0);
    }
#line 968
    d = (right_x1___3 * left_seg->a + right_y1 * left_seg->b) + left_seg->c;
#line 969
    if (d > 1e-5) {
#line 970
      return (0);
    } else
#line 971
    if (d > - 1e-5) {
      {
#line 973
      tmp___2 = art_svp_intersect_break(ctx, left_seg, right_x1___3, right_y1, (ArtBreakFlags )1);
#line 973
      left_x1___4 = tmp___2;
      }
#line 976
      if (left_x1___4 <= right_x1___3) {
#line 977
        return (0);
      }
    }
  } else {
#line 982
    left_x1___5 = left_seg->x[1];
#line 983
    right_x1___4 = right_seg->x[1];
#line 985
    if (left_x1___5 <= right_x1___4) {
#line 986
      return (0);
    }
  }
#line 991
  in_seg = left_seg->in_seg;
#line 992
  in_curs = left_seg->in_curs;
#line 993
  left_x0 = (in_seg->points + (in_curs - 1))->x;
#line 994
  left_y0 = (in_seg->points + (in_curs - 1))->y;
#line 995
  left_x1 = (in_seg->points + in_curs)->x;
#line 996
  left_y1 = (in_seg->points + in_curs)->y;
#line 997
  d0 = (left_x0 * right_seg->a + left_y0 * right_seg->b) + right_seg->c;
#line 998
  d1 = (left_x1 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 999
  if (d0 == d1) {
#line 1001
    x = left_x0;
#line 1002
    y = left_y0;
  } else {
#line 1007
    t = d0 / (d0 - d1);
#line 1008
    if (t <= (double )0) {
#line 1010
      x = left_x0;
#line 1011
      y = left_y0;
    } else
#line 1013
    if (t >= (double )1) {
#line 1015
      x = left_x1;
#line 1016
      y = left_y1;
    } else {
#line 1020
      x = left_x0 + t * (left_x1 - left_x0);
#line 1021
      y = left_y0 + t * (left_y1 - left_y0);
    }
  }
#line 1026
  if (y < right_seg->y0) {
#line 1028
    x = right_seg->x[0];
#line 1029
    y = right_seg->y0;
  } else
#line 1031
  if (y > right_seg->y1) {
#line 1033
    x = right_seg->x[1];
#line 1034
    y = right_seg->y1;
  } else
#line 1036
  if (x < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 1037
    x = right_seg->x[(right_seg->flags & 1) ^ 1];
  } else
#line 1038
  if (x > right_seg->x[right_seg->flags & 1]) {
#line 1039
    x = right_seg->x[right_seg->flags & 1];
  }
#line 1041
  if (y == left_seg->y0) {
#line 1043
    if (y != right_seg->y0) {
      {
#line 1049
      art_svp_intersect_push_pt(ctx, right_seg, x, y);
      }
#line 1050
      if ((unsigned int )break_flags & 2U) {
#line 1050
        if ((unsigned long )right_seg->right != (unsigned long )((void *)0)) {
          {
#line 1051
          art_svp_intersect_add_point(ctx, x, y, right_seg->right, break_flags);
          }
        }
      }
    } else {
#line 1062
      if (left_seg->a > right_seg->a) {
#line 1064
        winner = left_seg;
#line 1065
        loser = right_seg;
      } else {
#line 1069
        winner = right_seg;
#line 1070
        loser = left_seg;
      }
      {
#line 1073
      loser->x[0] = winner->x[0];
#line 1074
      loser->horiz_x = loser->x[0];
#line 1075
      loser->horiz_delta_wind += loser->delta_wind;
#line 1076
      winner->horiz_delta_wind -= loser->delta_wind;
#line 1078
      art_svp_intersect_swap_active(ctx, left_seg, right_seg);
      }
#line 1079
      return (1);
    }
  } else
#line 1082
  if (y == right_seg->y0) {
    {
#line 1088
    art_svp_intersect_push_pt(ctx, left_seg, x, y);
    }
#line 1089
    if ((unsigned int )break_flags & 1U) {
#line 1089
      if ((unsigned long )left_seg->left != (unsigned long )((void *)0)) {
        {
#line 1090
        art_svp_intersect_add_point(ctx, x, y, left_seg->left, break_flags);
        }
      }
    }
  } else {
    {
#line 1100
    art_svp_intersect_push_pt(ctx, left_seg, x, y);
#line 1101
    art_svp_intersect_push_pt(ctx, right_seg, x, y);
    }
#line 1102
    if ((unsigned int )break_flags & 1U) {
#line 1102
      if ((unsigned long )left_seg->left != (unsigned long )((void *)0)) {
        {
#line 1103
        art_svp_intersect_add_point(ctx, x, y, left_seg->left, break_flags);
        }
      }
    }
#line 1104
    if ((unsigned int )break_flags & 2U) {
#line 1104
      if ((unsigned long )right_seg->right != (unsigned long )((void *)0)) {
        {
#line 1105
        art_svp_intersect_add_point(ctx, x, y, right_seg->right, break_flags);
        }
      }
    }
  }
#line 1107
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_active_delete(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;

  {
#line 1120
  left = seg->left;
#line 1120
  right = seg->right;
#line 1122
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1123
    left->right = right;
  } else {
#line 1125
    ctx->active_head = right;
  }
#line 1126
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1127
    right->left = left;
  }
#line 1128
  return;
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_active_free(ArtActiveSeg *seg ) 
{ 


  {
  {
#line 1139
  art_free((void *)seg->stack);
#line 1143
  art_free((void *)seg);
  }
#line 1144
  return;
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_insert_cross(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  ArtActiveSeg *leftc ;
  art_boolean tmp ;
  ArtActiveSeg *rightc ;
  art_boolean tmp___0 ;

  {
#line 1156
  left = seg;
#line 1156
  right = seg;
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1164
      leftc = left->left;
      {
#line 1164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1164
        if (! ((unsigned long )leftc != (unsigned long )((void *)0))) {
#line 1164
          goto while_break___0;
        }
#line 1165
        if (! (leftc->flags & 4)) {
#line 1166
          goto while_break___0;
        }
#line 1164
        leftc = leftc->left;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1167
      if ((unsigned long )leftc != (unsigned long )((void *)0)) {
        {
#line 1167
        tmp = art_svp_intersect_test_cross(ctx, leftc, left, (ArtBreakFlags )1);
        }
#line 1167
        if (tmp) {
#line 1171
          if ((unsigned long )left == (unsigned long )right) {
#line 1172
            right = left->right;
          } else
#line 1171
          if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 1172
            right = left->right;
          }
        } else {
#line 1176
          left = (ArtActiveSeg *)((void *)0);
        }
      } else {
#line 1176
        left = (ArtActiveSeg *)((void *)0);
      }
    } else
#line 1179
    if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1179
      if ((unsigned long )right->right != (unsigned long )((void *)0)) {
#line 1183
        rightc = right->right;
        {
#line 1183
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1183
          if (! ((unsigned long )rightc != (unsigned long )((void *)0))) {
#line 1183
            goto while_break___1;
          }
#line 1184
          if (! (rightc->flags & 4)) {
#line 1185
            goto while_break___1;
          }
#line 1183
          rightc = rightc->right;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1186
        if ((unsigned long )rightc != (unsigned long )((void *)0)) {
          {
#line 1186
          tmp___0 = art_svp_intersect_test_cross(ctx, right, rightc, (ArtBreakFlags )2);
          }
#line 1186
          if (tmp___0) {
#line 1190
            if ((unsigned long )left == (unsigned long )right) {
#line 1191
              left = right->left;
            } else
#line 1190
            if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 1191
              left = right->left;
            }
          } else {
#line 1195
            right = (ArtActiveSeg *)((void *)0);
          }
        } else {
#line 1195
          right = (ArtActiveSeg *)((void *)0);
        }
      } else {
#line 1199
        goto while_break;
      }
    } else {
#line 1199
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1201
  return;
}
}
#line 1213 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_horiz(ArtIntersectCtx *ctx , ArtActiveSeg *seg , double x0 ,
                                    double x1 ) 
{ 
  ArtActiveSeg *hs ;
  void *tmp ;
  ArtSvpWriter *swr ;
  ArtActiveSeg *left ;
  art_boolean first ;
  int left_bneg ;
  ArtActiveSeg *right ;
  art_boolean first___0 ;
  int right_bneg ;

  {
#line 1219
  if (x0 == x1) {
#line 1220
    return;
  }
  {
#line 1222
  tmp = art_alloc(sizeof(ArtActiveSeg ));
#line 1222
  hs = (ArtActiveSeg *)tmp;
#line 1224
  hs->flags = 4 | (seg->flags & 8);
  }
#line 1225
  if (seg->flags & 8) {
    {
#line 1227
    swr = ctx->out;
#line 1229
    (*(swr->add_point))(swr, seg->seg_id, x0, ctx->y);
    }
  }
  {
#line 1231
  hs->seg_id = seg->seg_id;
#line 1232
  hs->horiz_x = x0;
#line 1233
  hs->horiz_delta_wind = seg->delta_wind;
#line 1234
  hs->stack = (ArtPoint *)((void *)0);
#line 1241
  hs->a = 0.0;
#line 1242
  hs->b = 0.0;
#line 1243
  hs->c = 0.0;
#line 1245
  seg->horiz_delta_wind -= seg->delta_wind;
#line 1247
  art_svp_intersect_add_horiz(ctx, hs);
  }
#line 1249
  if (x0 > x1) {
#line 1252
    first = 1;
#line 1254
    left = seg->left;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 1254
        goto while_break;
      }
#line 1256
      left_bneg = left->flags & 1;
#line 1258
      if (left->x[left_bneg] <= x1) {
#line 1259
        goto while_break;
      }
#line 1260
      if (left->x[left_bneg ^ 1] <= x1) {
#line 1260
        if ((x1 * left->a + ctx->y * left->b) + left->c >= (double )0) {
#line 1262
          goto while_break;
        }
      }
#line 1263
      if (left->y0 != ctx->y) {
#line 1263
        if (left->y1 != ctx->y) {
          {
#line 1265
          art_svp_intersect_break(ctx, left, x1, ctx->y, (ArtBreakFlags )1);
          }
        }
      }
      {
#line 1271
      art_svp_intersect_swap_active(ctx, left, seg);
      }
#line 1272
      if (first) {
#line 1272
        if ((unsigned long )left->right != (unsigned long )((void *)0)) {
          {
#line 1274
          art_svp_intersect_test_cross(ctx, left, left->right, (ArtBreakFlags )2);
#line 1276
          first = 0;
          }
        }
      }
#line 1254
      left = seg->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1283
    first___0 = 1;
#line 1285
    right = seg->right;
    {
#line 1285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1285
      if (! ((unsigned long )right != (unsigned long )((void *)0))) {
#line 1285
        goto while_break___0;
      }
#line 1287
      right_bneg = right->flags & 1;
#line 1289
      if (right->x[right_bneg ^ 1] >= x1) {
#line 1290
        goto while_break___0;
      }
#line 1291
      if (right->x[right_bneg] >= x1) {
#line 1291
        if ((x1 * right->a + ctx->y * right->b) + right->c <= (double )0) {
#line 1293
          goto while_break___0;
        }
      }
#line 1294
      if (right->y0 != ctx->y) {
#line 1294
        if (right->y1 != ctx->y) {
          {
#line 1296
          art_svp_intersect_break(ctx, right, x1, ctx->y, (ArtBreakFlags )1);
          }
        }
      }
      {
#line 1303
      art_svp_intersect_swap_active(ctx, seg, right);
      }
#line 1304
      if (first___0) {
#line 1304
        if ((unsigned long )right->left != (unsigned long )((void *)0)) {
          {
#line 1306
          art_svp_intersect_test_cross(ctx, right->left, right, (ArtBreakFlags )2);
#line 1308
          first___0 = 0;
          }
        }
      }
#line 1285
      right = seg->right;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1313
  seg->x[0] = x1;
#line 1314
  seg->x[1] = x1;
#line 1315
  seg->horiz_x = x1;
#line 1316
  seg->flags &= -9;
#line 1317
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_insert_line(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 


  {
#line 1331
  if (seg->y1 == seg->y0) {
    {
#line 1337
    art_svp_intersect_horiz(ctx, seg, seg->x[0], seg->x[1]);
    }
  } else {
    {
#line 1341
    art_svp_intersect_insert_cross(ctx, seg);
#line 1342
    art_svp_intersect_add_horiz(ctx, seg);
    }
  }
#line 1344
  return;
}
}
#line 1346 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_process_intersection(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  int n_stack ;

  {
  {
#line 1350
  (seg->n_stack) --;
#line 1350
  n_stack = seg->n_stack;
#line 1351
  seg->x[1] = (seg->stack + (n_stack - 1))->x;
#line 1352
  seg->y1 = (seg->stack + (n_stack - 1))->y;
#line 1353
  seg->x[0] = (seg->stack + n_stack)->x;
#line 1354
  seg->y0 = (seg->stack + n_stack)->y;
#line 1355
  seg->horiz_x = seg->x[0];
#line 1356
  art_svp_intersect_insert_line(ctx, seg);
  }
#line 1357
  return;
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_advance_cursor(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                             ArtPriPoint *pri_pt ) 
{ 
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  ArtSvpWriter *swr ;
  ArtSvpWriter *tmp ;
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;

  {
#line 1363
  in_seg = seg->in_seg;
#line 1364
  in_curs = seg->in_curs;
#line 1365
  if (seg->flags & 8) {
#line 1365
    tmp = ctx->out;
  } else {
#line 1365
    tmp = (ArtSvpWriter *)((void *)0);
  }
#line 1365
  swr = tmp;
#line 1367
  if ((unsigned long )swr != (unsigned long )((void *)0)) {
    {
#line 1368
    (*(swr->add_point))(swr, seg->seg_id, seg->x[1], seg->y1);
    }
  }
#line 1369
  if (in_curs + 1 == (int )in_seg->n_points) {
    {
#line 1371
    left = seg->left;
#line 1371
    right = seg->right;
#line 1378
    seg->flags |= 4;
#line 1379
    art_svp_intersect_add_horiz(ctx, seg);
#line 1380
    art_svp_intersect_active_delete(ctx, seg);
    }
#line 1381
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1381
      if ((unsigned long )right != (unsigned long )((void *)0)) {
        {
#line 1382
        art_svp_intersect_test_cross(ctx, left, right, (ArtBreakFlags )3);
        }
      }
    }
    {
#line 1384
    art_free((void *)pri_pt);
    }
  } else {
    {
#line 1388
    seg->horiz_x = seg->x[1];
#line 1390
    art_svp_intersect_setup_seg(seg, pri_pt);
#line 1391
    art_pri_insert(ctx->pq, pri_pt);
#line 1392
    art_svp_intersect_insert_line(ctx, seg);
    }
  }
#line 1394
  return;
}
}
#line 1396 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_add_seg(ArtIntersectCtx *ctx , ArtSVPSeg const   *in_seg ) 
{ 
  ArtActiveSeg *seg ;
  void *tmp ;
  ArtActiveSeg *test ;
  double x0 ;
  double y0___0 ;
  ArtActiveSeg *beg_range ;
  ArtActiveSeg *last ;
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  ArtPriPoint *pri_pt ;
  void *tmp___0 ;
  void *tmp___1 ;
  double d ;
  int test_bneg ;

  {
  {
#line 1399
  tmp = art_alloc(sizeof(ArtActiveSeg ));
#line 1399
  seg = (ArtActiveSeg *)tmp;
#line 1403
  last = (ArtActiveSeg *)((void *)0);
#line 1405
  tmp___0 = art_alloc(sizeof(ArtPriPoint ));
#line 1405
  pri_pt = (ArtPriPoint *)tmp___0;
#line 1407
  seg->flags = 0;
#line 1408
  seg->in_seg = in_seg;
#line 1409
  seg->in_curs = 0;
#line 1411
  seg->n_stack_max = 4;
#line 1412
  tmp___1 = art_alloc((unsigned long )seg->n_stack_max * sizeof(ArtPoint ));
#line 1412
  seg->stack = (ArtPoint *)tmp___1;
#line 1414
  seg->horiz_delta_wind = 0;
#line 1416
  seg->wind_left = 0;
#line 1418
  pri_pt->user_data = (void *)seg;
#line 1419
  art_svp_intersect_setup_seg(seg, pri_pt);
#line 1420
  art_pri_insert(ctx->pq, pri_pt);
#line 1426
  x0 = (in_seg->points + 0)->x;
#line 1427
  y0___0 = (in_seg->points + 0)->y;
#line 1428
  beg_range = (ArtActiveSeg *)((void *)0);
#line 1429
  test = ctx->active_head;
  }
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 1429
      goto while_break;
    }
#line 1432
    test_bneg = test->flags & 1;
#line 1434
    if (x0 < test->x[test_bneg]) {
#line 1436
      if (x0 < test->x[test_bneg ^ 1]) {
#line 1437
        goto while_break;
      }
#line 1438
      d = (x0 * test->a + y0___0 * test->b) + test->c;
#line 1439
      if (d < (double )0) {
#line 1440
        goto while_break;
      }
    }
#line 1442
    last = test;
#line 1429
    test = test->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1445
  left = art_svp_intersect_add_point(ctx, x0, y0___0, last, (ArtBreakFlags )3);
#line 1446
  seg->left = left;
  }
#line 1447
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 1449
    right = ctx->active_head;
#line 1450
    ctx->active_head = seg;
  } else {
#line 1454
    right = left->right;
#line 1455
    left->right = seg;
  }
#line 1457
  seg->right = right;
#line 1458
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1459
    right->left = seg;
  }
#line 1461
  if (in_seg->dir) {
#line 1461
    seg->delta_wind = 1;
  } else {
#line 1461
    seg->delta_wind = -1;
  }
  {
#line 1462
  seg->horiz_x = x0;
#line 1464
  art_svp_intersect_insert_line(ctx, seg);
  }
#line 1465
  return;
}
}
#line 1512 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_horiz_commit(ArtIntersectCtx *ctx ) 
{ 
  ArtActiveSeg *seg ;
  int winding_number ;
  int horiz_wind ;
  double last_x ;
  ArtActiveSeg *curs ;
  double x ;
  ArtSvpWriter *swr ;
  int seg_id ;
  ArtSvpWriter *swr___0 ;
  ArtActiveSeg *next ;
  ArtSvpWriter *swr___1 ;

  {
#line 1516
  winding_number = 0;
#line 1517
  horiz_wind = 0;
#line 1518
  last_x = (double )0;
#line 1528
  seg = ctx->horiz_first;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! ((unsigned long )seg != (unsigned long )((void *)0))) {
#line 1528
      goto while_break;
    }
#line 1532
    x = seg->horiz_x;
#line 1535
    if (horiz_wind != 0) {
      {
#line 1537
      swr = ctx->out;
#line 1540
      seg_id = (*(swr->add_segment))(swr, winding_number, horiz_wind, last_x, ctx->y);
#line 1542
      (*(swr->add_point))(swr, seg_id, x, ctx->y);
#line 1543
      (*(swr->close_segment))(swr, seg_id);
      }
    }
#line 1548
    curs = seg;
    {
#line 1548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1548
      if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1548
        if (! (curs->horiz_x == x)) {
#line 1548
          goto while_break___0;
        }
      } else {
#line 1548
        goto while_break___0;
      }
#line 1550
      if (! (curs->flags & 4)) {
#line 1551
        goto while_break___0;
      }
#line 1548
      curs = curs->horiz_right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1553
    if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1553
      if (curs->horiz_x == x) {
        {
#line 1558
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1558
          if (! ((unsigned long )curs->left != (unsigned long )((void *)0))) {
#line 1558
            goto while_break___1;
          }
#line 1559
          if ((curs->left)->horiz_x != x) {
#line 1560
            goto while_break___1;
          }
#line 1558
          curs = curs->left;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1562
        if ((unsigned long )curs->left != (unsigned long )((void *)0)) {
#line 1563
          winding_number = (curs->left)->wind_left + (curs->left)->delta_wind;
        } else {
#line 1565
          winding_number = 0;
        }
        {
#line 1567
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1573
          if (! (curs->flags & 8)) {
#line 1573
            goto _L;
          } else
#line 1573
          if (curs->wind_left != winding_number) {
            _L: /* CIL Label */ 
#line 1576
            swr___0 = ctx->out;
#line 1578
            if (curs->flags & 8) {
              {
#line 1580
              (*(swr___0->add_point))(swr___0, curs->seg_id, curs->horiz_x, ctx->y);
#line 1582
              (*(swr___0->close_segment))(swr___0, curs->seg_id);
              }
            }
            {
#line 1585
            curs->seg_id = (*(swr___0->add_segment))(swr___0, winding_number, curs->delta_wind,
                                                     x, ctx->y);
#line 1588
            curs->flags |= 8;
            }
          }
#line 1590
          curs->wind_left = winding_number;
#line 1591
          winding_number += curs->delta_wind;
#line 1592
          curs = curs->right;
#line 1567
          if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1567
            if (! (curs->horiz_x == x)) {
#line 1567
              goto while_break___2;
            }
          } else {
#line 1567
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 1598
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1600
      next = seg->horiz_right;
#line 1602
      seg->flags &= -17;
#line 1603
      horiz_wind += seg->horiz_delta_wind;
#line 1604
      seg->horiz_delta_wind = 0;
#line 1605
      if (seg->flags & 4) {
#line 1607
        if (seg->flags & 8) {
          {
#line 1609
          swr___1 = ctx->out;
#line 1610
          (*(swr___1->close_segment))(swr___1, seg->seg_id);
          }
        }
        {
#line 1612
        art_svp_intersect_active_free(seg);
        }
      }
#line 1614
      seg = next;
#line 1598
      if ((unsigned long )seg != (unsigned long )((void *)0)) {
#line 1598
        if (! (seg->horiz_x == x)) {
#line 1598
          goto while_break___3;
        }
      } else {
#line 1598
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1618
    last_x = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 1620
  ctx->horiz_first = (ArtActiveSeg *)((void *)0);
#line 1621
  ctx->horiz_last = (ArtActiveSeg *)((void *)0);
#line 1625
  return;
}
}
#line 1712 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
void art_svp_intersector(ArtSVP const   *in , ArtSvpWriter *out ) 
{ 
  ArtIntersectCtx *ctx ;
  ArtPriQ *pq ;
  ArtPriPoint *first_point ;
  void *tmp ;
  void *tmp___0 ;
  ArtPriPoint *pri_point ;
  ArtPriPoint *tmp___1 ;
  ArtActiveSeg *seg ;
  ArtSVPSeg const   *in_seg ;
  int tmp___2 ;
  ArtSVPSeg const   *next_seg ;
  int n_stack ;
  art_boolean tmp___3 ;

  {
#line 1722
  if (in->n_segs == 0) {
#line 1723
    return;
  }
  {
#line 1725
  tmp = art_alloc(sizeof(ArtIntersectCtx ));
#line 1725
  ctx = (ArtIntersectCtx *)tmp;
#line 1726
  ctx->in = in;
#line 1727
  ctx->out = out;
#line 1728
  pq = art_pri_new();
#line 1729
  ctx->pq = pq;
#line 1731
  ctx->active_head = (ArtActiveSeg *)((void *)0);
#line 1733
  ctx->horiz_first = (ArtActiveSeg *)((void *)0);
#line 1734
  ctx->horiz_last = (ArtActiveSeg *)((void *)0);
#line 1736
  ctx->in_curs = 0;
#line 1737
  tmp___0 = art_alloc(sizeof(ArtPriPoint ));
#line 1737
  first_point = (ArtPriPoint *)tmp___0;
#line 1738
  first_point->x = (in->segs[0].points + 0)->x;
#line 1739
  first_point->y = (in->segs[0].points + 0)->y;
#line 1740
  first_point->user_data = (void *)0;
#line 1741
  ctx->y = first_point->y;
#line 1742
  art_pri_insert(pq, first_point);
  }
  {
#line 1744
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1744
    tmp___3 = art_pri_empty(pq);
    }
#line 1744
    if (tmp___3) {
#line 1744
      goto while_break;
    }
    {
#line 1746
    tmp___1 = art_pri_choose(pq);
#line 1746
    pri_point = tmp___1;
#line 1747
    seg = (ArtActiveSeg *)pri_point->user_data;
    }
#line 1759
    if (ctx->y != pri_point->y) {
      {
#line 1761
      art_svp_intersect_horiz_commit(ctx);
#line 1762
      ctx->y = pri_point->y;
      }
    }
#line 1765
    if ((unsigned long )seg == (unsigned long )((void *)0)) {
      {
#line 1768
      tmp___2 = ctx->in_curs;
#line 1768
      (ctx->in_curs) ++;
#line 1768
      in_seg = (ArtSVPSeg const   *)(& in->segs[tmp___2]);
#line 1769
      art_svp_intersect_add_seg(ctx, in_seg);
      }
#line 1770
      if (ctx->in_curs < (int )in->n_segs) {
        {
#line 1772
        next_seg = (ArtSVPSeg const   *)(& in->segs[ctx->in_curs]);
#line 1773
        pri_point->x = (next_seg->points + 0)->x;
#line 1774
        pri_point->y = (next_seg->points + 0)->y;
#line 1776
        art_pri_insert(pq, pri_point);
        }
      } else {
        {
#line 1779
        art_free((void *)pri_point);
        }
      }
    } else {
#line 1783
      n_stack = seg->n_stack;
#line 1785
      if (n_stack > 1) {
        {
#line 1787
        art_svp_intersect_process_intersection(ctx, seg);
#line 1788
        art_free((void *)pri_point);
        }
      } else {
        {
#line 1792
        art_svp_intersect_advance_cursor(ctx, seg, pri_point);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1797
  art_svp_intersect_horiz_commit(ctx);
#line 1799
  art_pri_free(pq);
#line 1800
  art_free((void *)ctx);
  }
#line 1801
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.h"
char const   *libart_version ;
#line 22
void libart_preinit(void *app , void *modinfo ) ;
#line 23
void libart_postinit(void *app , void *modinfo ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.c"
unsigned int const   libart_major_version  =    (unsigned int const   )2;
#line 4 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.c"
unsigned int const   libart_minor_version  =    (unsigned int const   )3;
#line 4 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.c"
unsigned int const   libart_micro_version  =    (unsigned int const   )21;
#line 8 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.c"
char const   *libart_version  =    "2.3.21";
#line 10 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.c"
void libart_preinit(void *app , void *modinfo ) 
{ 


  {
#line 13
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/libart-features.c"
void libart_postinit(void *app , void *modinfo ) 
{ 


  {
#line 18
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.h"
void art_render_svp(ArtRender *render , ArtSVP const   *svp ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_done(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 40
  art_free((void *)self);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static int art_render_svp_can_drive(ArtMaskSource *self , ArtRender *render ) 
{ 


  {
#line 46
  return (10);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                    int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int i ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;

  {
#line 58
  z = (ArtMaskSourceSVP *)callback_data;
#line 59
  render = z->render;
#line 60
  n_run = 0;
#line 62
  running_sum = start;
#line 63
  x0 = render->x0;
#line 64
  x1 = render->x1;
#line 66
  run = render->run;
#line 68
  if (n_steps > 0) {
#line 70
    run_x1 = (steps + 0)->x;
#line 71
    if (run_x1 > x0) {
#line 71
      if (running_sum > 33023) {
#line 73
        (run + 0)->x = x0;
#line 74
        (run + 0)->alpha = running_sum;
#line 75
        n_run ++;
      }
    }
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if (! (i < n_steps - 1)) {
#line 78
        goto while_break;
      }
#line 80
      running_sum += (steps + i)->delta;
#line 81
      run_x0 = run_x1;
#line 82
      run_x1 = (steps + (i + 1))->x;
#line 83
      if (run_x1 > run_x0) {
#line 85
        (run + n_run)->x = run_x0;
#line 86
        (run + n_run)->alpha = running_sum;
#line 87
        n_run ++;
      }
#line 78
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    if (x1 > run_x1) {
#line 92
      running_sum += (steps + (n_steps - 1))->delta;
#line 93
      (run + n_run)->x = run_x1;
#line 94
      (run + n_run)->alpha = running_sum;
#line 95
      n_run ++;
    }
#line 97
    if (running_sum > 33023) {
#line 99
      (run + n_run)->x = x1;
#line 100
      (run + n_run)->alpha = 32768;
#line 101
      n_run ++;
    }
  } else
#line 104
  if (running_sum >> 16 > 0) {
#line 106
    (run + 0)->x = x0;
#line 107
    (run + 0)->alpha = running_sum;
#line 108
    (run + 1)->x = x1;
#line 109
    (run + 1)->alpha = running_sum;
#line 110
    n_run = 2;
  }
  {
#line 113
  render->n_run = n_run;
#line 115
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 117
  z->dest_ptr += render->rowstride;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_span(void *callback_data , int y , int start ,
                                         ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int n_span ;
  int i ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  int *span_x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 124
  z = (ArtMaskSourceSVP *)callback_data;
#line 125
  render = z->render;
#line 126
  n_run = 0;
#line 127
  n_span = 0;
#line 129
  running_sum = start;
#line 130
  x0 = render->x0;
#line 131
  x1 = render->x1;
#line 133
  run = render->run;
#line 134
  span_x = render->span_x;
#line 136
  if (n_steps > 0) {
#line 138
    run_x1 = (steps + 0)->x;
#line 139
    if (run_x1 > x0) {
#line 139
      if (running_sum > 33023) {
#line 141
        (run + 0)->x = x0;
#line 142
        (run + 0)->alpha = running_sum;
#line 143
        n_run ++;
#line 144
        *(span_x + 0) = x0;
#line 145
        n_span ++;
      }
    }
#line 148
    i = 0;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! (i < n_steps - 1)) {
#line 148
        goto while_break;
      }
#line 150
      running_sum += (steps + i)->delta;
#line 151
      run_x0 = run_x1;
#line 152
      run_x1 = (steps + (i + 1))->x;
#line 153
      if (run_x1 > run_x0) {
#line 155
        (run + n_run)->x = run_x0;
#line 156
        (run + n_run)->alpha = running_sum;
#line 157
        n_run ++;
#line 158
        if ((n_span & 1) != (running_sum > 33023)) {
#line 159
          tmp = n_span;
#line 159
          n_span ++;
#line 159
          *(span_x + tmp) = run_x0;
        }
      }
#line 148
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 162
    if (x1 > run_x1) {
#line 164
      running_sum += (steps + (n_steps - 1))->delta;
#line 165
      (run + n_run)->x = run_x1;
#line 166
      (run + n_run)->alpha = running_sum;
#line 167
      n_run ++;
#line 168
      if ((n_span & 1) != (running_sum > 33023)) {
#line 169
        tmp___0 = n_span;
#line 169
        n_span ++;
#line 169
        *(span_x + tmp___0) = run_x1;
      }
    }
#line 171
    if (running_sum > 33023) {
#line 173
      (run + n_run)->x = x1;
#line 174
      (run + n_run)->alpha = 32768;
#line 175
      n_run ++;
#line 176
      tmp___1 = n_span;
#line 176
      n_span ++;
#line 176
      *(span_x + tmp___1) = x1;
    }
  } else
#line 179
  if (running_sum >> 16 > 0) {
#line 181
    (run + 0)->x = x0;
#line 182
    (run + 0)->alpha = running_sum;
#line 183
    (run + 1)->x = x1;
#line 184
    (run + 1)->alpha = running_sum;
#line 185
    n_run = 2;
#line 186
    *(span_x + 0) = x0;
#line 187
    *(span_x + 1) = x1;
#line 188
    n_span = 2;
  }
  {
#line 191
  render->n_run = n_run;
#line 192
  render->n_span = n_span;
#line 194
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 196
  z->dest_ptr += render->rowstride;
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_opacity(void *callback_data , int y , int start ,
                                            ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int i ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  art_u32 opacity ;
  art_u32 alpha ;

  {
#line 203
  z = (ArtMaskSourceSVP *)callback_data;
#line 204
  render = z->render;
#line 205
  n_run = 0;
#line 208
  x0 = render->x0;
#line 209
  x1 = render->x1;
#line 211
  run = render->run;
#line 212
  opacity = render->opacity;
#line 215
  running_sum = (art_u32 )(start - 32640);
#line 217
  if (n_steps > 0) {
#line 219
    run_x1 = (steps + 0)->x;
#line 220
    alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 221
    if (run_x1 > x0) {
#line 221
      if (alpha > 33023U) {
#line 223
        (run + 0)->x = x0;
#line 224
        (run + 0)->alpha = (int )alpha;
#line 225
        n_run ++;
      }
    }
#line 228
    i = 0;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n_steps - 1)) {
#line 228
        goto while_break;
      }
#line 230
      running_sum += (art_u32 )(steps + i)->delta;
#line 231
      run_x0 = run_x1;
#line 232
      run_x1 = (steps + (i + 1))->x;
#line 233
      if (run_x1 > run_x0) {
#line 235
        (run + n_run)->x = run_x0;
#line 236
        alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 237
        (run + n_run)->alpha = (int )alpha;
#line 238
        n_run ++;
      }
#line 228
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 241
    if (x1 > run_x1) {
#line 243
      running_sum += (art_u32 )(steps + (n_steps - 1))->delta;
#line 244
      (run + n_run)->x = run_x1;
#line 245
      alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 246
      (run + n_run)->alpha = (int )alpha;
#line 247
      n_run ++;
    }
#line 249
    if (alpha > 33023U) {
#line 251
      (run + n_run)->x = x1;
#line 252
      (run + n_run)->alpha = 32768;
#line 253
      n_run ++;
    }
  } else
#line 256
  if (running_sum >> 16 > 0U) {
#line 258
    (run + 0)->x = x0;
#line 259
    (run + 0)->alpha = (int )running_sum;
#line 260
    (run + 1)->x = x1;
#line 261
    (run + 1)->alpha = (int )running_sum;
#line 262
    n_run = 2;
  }
  {
#line 265
  render->n_run = n_run;
#line 267
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 269
  z->dest_ptr += render->rowstride;
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_opacity_span(void *callback_data , int y , int start ,
                                                 ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int n_span ;
  int i ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  int *span_x ;
  art_u32 opacity ;
  art_u32 alpha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  z = (ArtMaskSourceSVP *)callback_data;
#line 277
  render = z->render;
#line 278
  n_run = 0;
#line 279
  n_span = 0;
#line 282
  x0 = render->x0;
#line 283
  x1 = render->x1;
#line 285
  run = render->run;
#line 286
  span_x = render->span_x;
#line 287
  opacity = render->opacity;
#line 290
  running_sum = (art_u32 )(start - 32640);
#line 292
  if (n_steps > 0) {
#line 294
    run_x1 = (steps + 0)->x;
#line 295
    alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 296
    if (run_x1 > x0) {
#line 296
      if (alpha > 33023U) {
#line 298
        (run + 0)->x = x0;
#line 299
        (run + 0)->alpha = (int )alpha;
#line 300
        n_run ++;
#line 301
        *(span_x + 0) = x0;
#line 302
        n_span ++;
      }
    }
#line 305
    i = 0;
    {
#line 305
    while (1) {
      while_continue: /* CIL Label */ ;
#line 305
      if (! (i < n_steps - 1)) {
#line 305
        goto while_break;
      }
#line 307
      running_sum += (art_u32 )(steps + i)->delta;
#line 308
      run_x0 = run_x1;
#line 309
      run_x1 = (steps + (i + 1))->x;
#line 310
      if (run_x1 > run_x0) {
#line 312
        (run + n_run)->x = run_x0;
#line 313
        alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 314
        (run + n_run)->alpha = (int )alpha;
#line 315
        n_run ++;
#line 316
        if ((n_span & 1) != (alpha > 33023U)) {
#line 317
          tmp = n_span;
#line 317
          n_span ++;
#line 317
          *(span_x + tmp) = run_x0;
        }
      }
#line 305
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 320
    if (x1 > run_x1) {
#line 322
      running_sum += (art_u32 )(steps + (n_steps - 1))->delta;
#line 323
      (run + n_run)->x = run_x1;
#line 324
      alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 325
      (run + n_run)->alpha = (int )alpha;
#line 326
      n_run ++;
#line 327
      if ((n_span & 1) != (alpha > 33023U)) {
#line 328
        tmp___0 = n_span;
#line 328
        n_span ++;
#line 328
        *(span_x + tmp___0) = run_x1;
      }
    }
#line 330
    if (alpha > 33023U) {
#line 332
      (run + n_run)->x = x1;
#line 333
      (run + n_run)->alpha = 32768;
#line 334
      n_run ++;
#line 335
      tmp___1 = n_span;
#line 335
      n_span ++;
#line 335
      *(span_x + tmp___1) = x1;
    }
  } else
#line 338
  if (running_sum >> 16 > 0U) {
#line 340
    (run + 0)->x = x0;
#line 341
    (run + 0)->alpha = (int )running_sum;
#line 342
    (run + 1)->x = x1;
#line 343
    (run + 1)->alpha = (int )running_sum;
#line 344
    n_run = 2;
#line 345
    *(span_x + 0) = x0;
#line 346
    *(span_x + 1) = x1;
#line 347
    n_span = 2;
  }
  {
#line 350
  render->n_run = n_run;
#line 351
  render->n_span = n_span;
#line 353
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 355
  z->dest_ptr += render->rowstride;
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_invoke_driver(ArtMaskSource *self , ArtRender *render ) 
{ 
  ArtMaskSourceSVP *z ;
  void (*callback)(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                   int n_steps ) ;

  {
#line 361
  z = (ArtMaskSourceSVP *)self;
#line 367
  z->dest_ptr = render->pixels;
#line 368
  if (render->opacity == 65536U) {
#line 370
    if (render->need_span) {
#line 371
      callback = & art_render_svp_callback_span;
    } else {
#line 373
      callback = & art_render_svp_callback;
    }
  } else
#line 377
  if (render->need_span) {
#line 378
    callback = & art_render_svp_callback_opacity_span;
  } else {
#line 380
    callback = & art_render_svp_callback_opacity;
  }
  {
#line 383
  art_svp_render_aa(z->svp, render->x0, render->y0, render->x1, render->y1, callback,
                    (void *)self);
#line 387
  art_render_svp_done(& self->super, render);
  }
#line 388
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_prepare(ArtMaskSource *self , ArtRender *render , art_boolean first ) 
{ 


  {
  {
#line 395
  art_die("art_render_svp non-driver mode not yet implemented.\n");
  }
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
void art_render_svp(ArtRender *render , ArtSVP const   *svp ) 
{ 
  ArtMaskSourceSVP *mask_source ;
  void *tmp ;

  {
  {
#line 410
  tmp = art_alloc(sizeof(ArtMaskSourceSVP ));
#line 410
  mask_source = (ArtMaskSourceSVP *)tmp;
#line 412
  mask_source->super.super.render = (void (*)(ArtRenderCallback *self , ArtRender *render ,
                                              art_u8 *dest , int y ))((void *)0);
#line 413
  mask_source->super.super.done = & art_render_svp_done;
#line 414
  mask_source->super.can_drive = & art_render_svp_can_drive;
#line 415
  mask_source->super.invoke_driver = & art_render_svp_invoke_driver;
#line 416
  mask_source->super.prepare = & art_render_svp_prepare;
#line 417
  mask_source->render = render;
#line 418
  mask_source->svp = svp;
#line 420
  art_render_add_mask_source(render, & mask_source->super);
  }
#line 421
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_svp.h"
ArtUta *art_uta_from_svp(ArtSVP const   *svp ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_svp.c"
ArtUta *art_uta_from_svp(ArtSVP const   *svp ) 
{ 
  ArtVpath *vpath ;
  ArtUta *uta ;

  {
  {
#line 50
  vpath = art_vpath_from_svp(svp);
#line 51
  uta = art_uta_from_vpath((ArtVpath const   *)vpath);
#line 52
  art_free((void *)vpath);
  }
#line 53
  return (uta);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_bitmap_affine.h"
void art_rgb_bitmap_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 ,
                           int dst_rowstride , art_u8 const   *src , int src_width ,
                           int src_height , int src_rowstride , art_u32 rgba , double const   *affine ,
                           ArtFilterLevel level , ArtAlphaGamma *alphagamma ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_bitmap_affine.c"
static void art_rgb_bitmap_affine_opaque(art_u8 *dst , int x0 , int y0___0 , int x1 ,
                                         int y1___0 , int dst_rowstride , art_u8 const   *src ,
                                         int src_width , int src_height , int src_rowstride ,
                                         art_u32 rgb , double const   *affine , ArtFilterLevel level ,
                                         ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int run_x0 ;
  int run_x1 ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 59
  r = (art_u8 )(rgb >> 16);
#line 60
  g = (art_u8 )((rgb >> 8) & 255U);
#line 61
  b = (art_u8 )(rgb & 255U);
#line 62
  dst_linestart = dst;
#line 63
  art_affine_invert((double *)(inv), affine);
#line 64
  y = y0___0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (y < y1___0)) {
#line 64
      goto while_break;
    }
    {
#line 66
    pt.y = (double )y + 0.5;
#line 67
    run_x0 = x0;
#line 68
    run_x1 = x1;
#line 69
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 71
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 72
    x = run_x0;
    }
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! (x < run_x1)) {
#line 72
        goto while_break___0;
      }
      {
#line 74
      pt.x = (double )x + 0.5;
#line 75
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 76
      tmp = floor(src_pt.x);
#line 76
      src_x = (int )tmp;
#line 77
      tmp___0 = floor(src_pt.y);
#line 77
      src_y = (int )tmp___0;
#line 78
      src_p = (src + src_y * src_rowstride) + (src_x >> 3);
      }
#line 79
      if ((int const   )*src_p & (int const   )(128 >> (src_x & 7))) {
#line 81
        *(dst_p + 0) = r;
#line 82
        *(dst_p + 1) = g;
#line 83
        *(dst_p + 2) = b;
      }
#line 85
      dst_p += 3;
#line 72
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    dst_linestart += dst_rowstride;
#line 64
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_bitmap_affine.c"
void art_rgb_bitmap_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 ,
                           int dst_rowstride , art_u8 const   *src , int src_width ,
                           int src_height , int src_rowstride , art_u32 rgba , double const   *affine ,
                           ArtFilterLevel level , ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  int alpha ;
  art_u8 bg_r ;
  art_u8 bg_g ;
  art_u8 bg_b ;
  art_u8 fg_r ;
  art_u8 fg_g ;
  art_u8 fg_b ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int run_x0 ;
  int run_x1 ;
  double tmp ;
  double tmp___0 ;

  {
#line 146
  alpha = (int )(rgba & 255U);
#line 147
  if (alpha == 255) {
    {
#line 149
    art_rgb_bitmap_affine_opaque(dst, x0, y0___0, x1, y1___0, dst_rowstride, src,
                                 src_width, src_height, src_rowstride, rgba >> 8,
                                 affine, level, alphagamma);
    }
#line 156
    return;
  }
  {
#line 159
  alpha = ((alpha << 8) + alpha) + (alpha >> 7);
#line 160
  r = (art_u8 )(rgba >> 24);
#line 161
  g = (art_u8 )((rgba >> 16) & 255U);
#line 162
  b = (art_u8 )((rgba >> 8) & 255U);
#line 163
  dst_linestart = dst;
#line 164
  art_affine_invert((double *)(inv), affine);
#line 165
  y = y0___0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (y < y1___0)) {
#line 165
      goto while_break;
    }
    {
#line 167
    pt.y = (double )y + 0.5;
#line 168
    run_x0 = x0;
#line 169
    run_x1 = x1;
#line 170
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 172
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 173
    x = run_x0;
    }
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (! (x < run_x1)) {
#line 173
        goto while_break___0;
      }
      {
#line 175
      pt.x = (double )x + 0.5;
#line 176
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 177
      tmp = floor(src_pt.x);
#line 177
      src_x = (int )tmp;
#line 178
      tmp___0 = floor(src_pt.y);
#line 178
      src_y = (int )tmp___0;
#line 179
      src_p = (src + src_y * src_rowstride) + (src_x >> 3);
      }
#line 180
      if ((int const   )*src_p & (int const   )(128 >> (src_x & 7))) {
#line 182
        bg_r = *(dst_p + 0);
#line 183
        bg_g = *(dst_p + 1);
#line 184
        bg_b = *(dst_p + 2);
#line 186
        fg_r = (art_u8 )((int )bg_r + ((((int )r - (int )bg_r) * alpha + 32768) >> 16));
#line 187
        fg_g = (art_u8 )((int )bg_g + ((((int )g - (int )bg_g) * alpha + 32768) >> 16));
#line 188
        fg_b = (art_u8 )((int )bg_b + ((((int )b - (int )bg_b) * alpha + 32768) >> 16));
#line 190
        *(dst_p + 0) = fg_r;
#line 191
        *(dst_p + 1) = fg_g;
#line 192
        *(dst_p + 2) = fg_b;
      }
#line 194
      dst_p += 3;
#line 173
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 196
    dst_linestart += dst_rowstride;
#line 165
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.h"
void art_render_mask(ArtRender *render , int x0 , int y0 , int x1 , int y1 , art_u8 const   *mask_buf ,
                     int rowstride ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_done(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 48
  art_free((void *)self);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static int art_render_mask_can_drive(ArtMaskSource *self , ArtRender *render ) 
{ 


  {
#line 54
  return (0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_render(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                                   int y ) 
{ 
  ArtMaskSourceMask *z ;
  int x0 ;
  int x1 ;
  int z_x0 ;
  int z_x1 ;
  int width ;
  int z_width ;
  art_u8 *alpha_buf ;
  art_u8 const   *src_line ;
  art_u8 *dst_line ;
  int x ;
  int v ;

  {
#line 61
  z = (ArtMaskSourceMask *)self;
#line 62
  x0 = render->x0;
#line 62
  x1 = render->x1;
#line 63
  z_x0 = z->x0;
#line 63
  z_x1 = z->x1;
#line 64
  width = x1 - x0;
#line 65
  z_width = z_x1 - z_x0;
#line 66
  alpha_buf = render->alpha_buf;
#line 68
  if (y < z->y0) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else
#line 68
  if (y >= z->y1) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else
#line 68
  if (z_width <= 0) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else {
#line 72
    src_line = z->mask_buf + (y - z->y0) * z->rowstride;
#line 73
    dst_line = (alpha_buf + z_x0) - x0;
#line 75
    if (z_x0 > x0) {
      {
#line 76
      memset((void *)alpha_buf, 0, (size_t )(z_x0 - x0));
      }
    }
#line 78
    if (z->first) {
      {
#line 79
      memcpy((void */* __restrict  */)dst_line, (void const   */* __restrict  */)src_line,
             (size_t )z_width);
      }
    } else {
#line 84
      x = 0;
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;
#line 84
        if (! (x < z_width)) {
#line 84
          goto while_break;
        }
#line 87
        v = (int )*(src_line + x);
#line 88
        if (v) {
#line 90
          v = v * (int )*(dst_line + x) + 128;
#line 91
          v = (v + (v >> 8)) >> 8;
#line 92
          *(dst_line + x) = (art_u8 )v;
        } else {
#line 96
          *(dst_line + x) = (art_u8 )0;
        }
#line 84
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 101
    if (z_x1 < x1) {
      {
#line 102
      memset((void *)((alpha_buf + z_x1) - x0), 0, (size_t )(x1 - z_x1));
      }
    }
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_prepare(ArtMaskSource *self , ArtRender *render , art_boolean first ) 
{ 
  ArtMaskSourceMask *z ;

  {
#line 110
  z = (ArtMaskSourceMask *)self;
#line 111
  self->super.render = & art_render_mask_render;
#line 112
  z->first = first;
#line 113
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
void art_render_mask(ArtRender *render , int x0 , int y0 , int x1 , int y1 , art_u8 const   *mask_buf ,
                     int rowstride ) 
{ 
  ArtMaskSourceMask *mask_source ;
  void *tmp ;

  {
#line 135
  if (x0 < render->x0) {
#line 137
    mask_buf += render->x0 - x0;
#line 138
    x0 = render->x0;
  }
#line 140
  if (x1 > render->x1) {
#line 141
    x1 = render->x1;
  }
#line 143
  if (y0 < render->y0) {
#line 145
    mask_buf += (render->y0 - y0) * rowstride;
#line 146
    y0 = render->y0;
  }
#line 148
  if (y1 > render->y1) {
#line 149
    y1 = render->y1;
  }
  {
#line 151
  tmp = art_alloc(sizeof(ArtMaskSourceMask ));
#line 151
  mask_source = (ArtMaskSourceMask *)tmp;
#line 153
  mask_source->super.super.render = (void (*)(ArtRenderCallback *self , ArtRender *render ,
                                              art_u8 *dest , int y ))((void *)0);
#line 154
  mask_source->super.super.done = & art_render_mask_done;
#line 155
  mask_source->super.can_drive = & art_render_mask_can_drive;
#line 156
  mask_source->super.invoke_driver = (void (*)(ArtMaskSource *self , ArtRender *render ))((void *)0);
#line 157
  mask_source->super.prepare = & art_render_mask_prepare;
#line 158
  mask_source->render = render;
#line 159
  mask_source->x0 = x0;
#line 160
  mask_source->y0 = y0;
#line 161
  mask_source->x1 = x1;
#line 162
  mask_source->y1 = y1;
#line 163
  mask_source->mask_buf = mask_buf;
#line 164
  mask_source->rowstride = rowstride;
#line 166
  art_render_add_mask_source(render, & mask_source->super);
  }
#line 168
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.h"
ArtSVP *art_svp_union(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) ;
#line 36
ArtSVP *art_svp_intersect(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) ;
#line 37
ArtSVP *art_svp_diff(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) ;
#line 38
ArtSVP *art_svp_minus(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
static ArtSVP *art_svp_merge(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp_new ;
  int ix ;
  int ix1 ;
  int ix2 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 62
  tmp = art_alloc(sizeof(ArtSVP ) + (unsigned long )((svp1->n_segs + svp2->n_segs) - 1) * sizeof(ArtSVPSeg ));
#line 62
  svp_new = (ArtSVP *)tmp;
#line 65
  ix1 = 0;
#line 66
  ix2 = 0;
#line 67
  ix = 0;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (ix < (int )(svp1->n_segs + svp2->n_segs))) {
#line 67
      goto while_break;
    }
#line 69
    if (ix1 < (int )svp1->n_segs) {
#line 69
      if (ix2 == (int )svp2->n_segs) {
#line 72
        tmp___0 = ix1;
#line 72
        ix1 ++;
#line 72
        svp_new->segs[ix] = svp1->segs[tmp___0];
      } else {
        {
#line 69
        tmp___2 = art_svp_seg_compare((void const   *)(& svp1->segs[ix1]), (void const   *)(& svp2->segs[ix2]));
        }
#line 69
        if (tmp___2 < 1) {
#line 72
          tmp___0 = ix1;
#line 72
          ix1 ++;
#line 72
          svp_new->segs[ix] = svp1->segs[tmp___0];
        } else {
#line 74
          tmp___1 = ix2;
#line 74
          ix2 ++;
#line 74
          svp_new->segs[ix] = svp2->segs[tmp___1];
        }
      }
    } else {
#line 74
      tmp___1 = ix2;
#line 74
      ix2 ++;
#line 74
      svp_new->segs[ix] = svp2->segs[tmp___1];
    }
#line 67
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  svp_new->n_segs = ix;
#line 78
  return (svp_new);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
ArtSVP *art_svp_union(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp3 ;
  ArtSVP *svp_new ;
  ArtSvpWriter *swr ;

  {
  {
#line 225
  svp3 = art_svp_merge(svp1, svp2);
#line 226
  swr = art_svp_writer_rewind_new((ArtWindRule )3);
#line 227
  art_svp_intersector((ArtSVP const   *)svp3, swr);
#line 228
  svp_new = art_svp_writer_rewind_reap(swr);
#line 229
  art_free((void *)svp3);
  }
#line 231
  return (svp_new);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
ArtSVP *art_svp_intersect(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp3 ;
  ArtSVP *svp_new ;
  ArtSvpWriter *swr ;

  {
  {
#line 290
  svp3 = art_svp_merge(svp1, svp2);
#line 291
  swr = art_svp_writer_rewind_new((ArtWindRule )1);
#line 292
  art_svp_intersector((ArtSVP const   *)svp3, swr);
#line 293
  svp_new = art_svp_writer_rewind_reap(swr);
#line 294
  art_free((void *)svp3);
  }
#line 296
  return (svp_new);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
ArtSVP *art_svp_diff(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp3 ;
  ArtSVP *svp_new ;
  ArtSvpWriter *swr ;

  {
  {
#line 354
  svp3 = art_svp_merge(svp1, svp2);
#line 355
  swr = art_svp_writer_rewind_new((ArtWindRule )2);
#line 356
  art_svp_intersector((ArtSVP const   *)svp3, swr);
#line 357
  svp_new = art_svp_writer_rewind_reap(swr);
#line 358
  art_free((void *)svp3);
  }
#line 360
  return (svp_new);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
ArtSVP *art_svp_minus(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp2_mod ;
  ArtSVP *svp3 ;
  ArtSVP *svp_new ;
  ArtSvpWriter *swr ;
  int i ;

  {
#line 383
  svp2_mod = (ArtSVP *)svp2;
#line 386
  i = 0;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! (i < svp2_mod->n_segs)) {
#line 386
      goto while_break;
    }
#line 387
    svp2_mod->segs[i].dir = ! svp2_mod->segs[i].dir;
#line 386
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  svp3 = art_svp_merge(svp1, (ArtSVP const   *)svp2_mod);
#line 390
  swr = art_svp_writer_rewind_new((ArtWindRule )3);
#line 391
  art_svp_intersector((ArtSVP const   *)svp3, swr);
#line 392
  svp_new = art_svp_writer_rewind_reap(swr);
#line 393
  art_free((void *)svp3);
#line 396
  i = 0;
  }
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 396
    if (! (i < svp2_mod->n_segs)) {
#line 396
      goto while_break___0;
    }
#line 397
    svp2_mod->segs[i].dir = ! svp2_mod->segs[i].dir;
#line 396
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 399
  return (svp_new);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_ops.h"
ArtUta *art_uta_union(ArtUta *uta1 , ArtUta *uta2 ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_uta_ops.c"
ArtUta *art_uta_union(ArtUta *uta1 , ArtUta *uta2 ) 
{ 
  ArtUta *uta ;
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int x ;
  int y ;
  int ix ;
  int ix1 ;
  int ix2 ;
  ArtUtaBbox bb ;
  ArtUtaBbox bb1 ;
  ArtUtaBbox bb2 ;
  ArtUtaBbox tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 66
  if (uta1->x0 < uta2->x0) {
#line 66
    x0 = uta1->x0;
  } else {
#line 66
    x0 = uta2->x0;
  }
#line 67
  if (uta1->y0 < uta2->y0) {
#line 67
    y0 = uta1->y0;
  } else {
#line 67
    y0 = uta2->y0;
  }
#line 68
  if (uta1->x0 + uta1->width > uta2->x0 + uta2->width) {
#line 68
    x1 = uta1->x0 + uta1->width;
  } else {
#line 68
    x1 = uta2->x0 + uta2->width;
  }
#line 69
  if (uta1->y0 + uta1->height > uta2->y0 + uta2->height) {
#line 69
    y1 = uta1->y0 + uta1->height;
  } else {
#line 69
    y1 = uta2->y0 + uta2->height;
  }
  {
#line 70
  uta = art_uta_new(x0, y0, x1, y1);
#line 73
  ix = 0;
#line 74
  y = y0;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (y < y1)) {
#line 74
      goto while_break;
    }
#line 76
    ix1 = ((y - uta1->y0) * uta1->width + x0) - uta1->x0;
#line 77
    ix2 = ((y - uta2->y0) * uta2->width + x0) - uta2->x0;
#line 78
    x = x0;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! (x < x1)) {
#line 78
        goto while_break___0;
      }
#line 80
      if (x < uta1->x0) {
#line 82
        bb1 = (ArtUtaBbox )0;
      } else
#line 80
      if (y < uta1->y0) {
#line 82
        bb1 = (ArtUtaBbox )0;
      } else
#line 80
      if (x >= uta1->x0 + uta1->width) {
#line 82
        bb1 = (ArtUtaBbox )0;
      } else
#line 80
      if (y >= uta1->y0 + uta1->height) {
#line 82
        bb1 = (ArtUtaBbox )0;
      } else {
#line 84
        bb1 = *(uta1->utiles + ix1);
      }
#line 86
      if (x < uta2->x0) {
#line 88
        bb2 = (ArtUtaBbox )0;
      } else
#line 86
      if (y < uta2->y0) {
#line 88
        bb2 = (ArtUtaBbox )0;
      } else
#line 86
      if (x >= uta2->x0 + uta2->width) {
#line 88
        bb2 = (ArtUtaBbox )0;
      } else
#line 86
      if (y >= uta2->y0 + uta2->height) {
#line 88
        bb2 = (ArtUtaBbox )0;
      } else {
#line 90
        bb2 = *(uta2->utiles + ix2);
      }
#line 92
      if (bb1 == 0U) {
#line 93
        bb = bb2;
      } else
#line 94
      if (bb2 == 0U) {
#line 95
        bb = bb1;
      } else {
#line 97
        if (bb1 >> 24 < bb2 >> 24) {
#line 97
          tmp = bb1 >> 24;
        } else {
#line 97
          tmp = bb2 >> 24;
        }
#line 97
        if (((bb1 >> 16) & 255U) < ((bb2 >> 16) & 255U)) {
#line 97
          tmp___0 = (bb1 >> 16) & 255U;
        } else {
#line 97
          tmp___0 = (bb2 >> 16) & 255U;
        }
#line 97
        if (((bb1 >> 8) & 255U) > ((bb2 >> 8) & 255U)) {
#line 97
          tmp___1 = (bb1 >> 8) & 255U;
        } else {
#line 97
          tmp___1 = (bb2 >> 8) & 255U;
        }
#line 97
        if ((bb1 & 255U) > (bb2 & 255U)) {
#line 97
          tmp___2 = bb1 & 255U;
        } else {
#line 97
          tmp___2 = bb2 & 255U;
        }
#line 97
        bb = (((tmp << 24) | (tmp___0 << 16)) | (tmp___1 << 8)) | tmp___2;
      }
#line 105
      *(uta->utiles + ix) = bb;
#line 106
      ix ++;
#line 107
      ix1 ++;
#line 108
      ix2 ++;
#line 78
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 74
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return (uta);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.h"
ArtVpath *art_vpath_new_circle(double x , double y , double r ) ;
#line 55
ArtVpath *art_vpath_affine_transform(ArtVpath const   *src , double const   *matrix ) ;
#line 58
void art_vpath_bbox_drect(ArtVpath const   *vec , ArtDRect *drect ) ;
#line 64
ArtVpath *art_vpath_perturb(ArtVpath *src ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.c"
void art_vpath_add_point(ArtVpath **p_vpath , int *pn_points , int *pn_points_max ,
                         ArtPathcode code , double x , double y ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 54
  tmp = *pn_points;
#line 54
  (*pn_points) ++;
#line 54
  i = tmp;
#line 55
  if (i == *pn_points_max) {
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
#line 56
      if (*pn_points_max) {
        {
#line 56
        tmp___0 = *pn_points_max << 1;
#line 56
        *pn_points_max = tmp___0;
#line 56
        tmp___1 = art_realloc((void *)*p_vpath, (unsigned long )tmp___0 * sizeof(ArtVpath ));
#line 56
        *p_vpath = (ArtVpath *)tmp___1;
        }
      } else {
        {
#line 56
        *pn_points_max = 1;
#line 56
        tmp___2 = art_alloc(sizeof(ArtVpath ));
#line 56
        *p_vpath = (ArtVpath *)tmp___2;
        }
      }
#line 56
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 57
  (*p_vpath + i)->code = code;
#line 58
  (*p_vpath + i)->x = x;
#line 59
  (*p_vpath + i)->y = y;
#line 60
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.c"
ArtVpath *art_vpath_new_circle(double x , double y , double r ) 
{ 
  int i ;
  ArtVpath *vec ;
  double theta ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 84
  tmp = art_alloc(130UL * sizeof(ArtVpath ));
#line 84
  vec = (ArtVpath *)tmp;
#line 86
  i = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 129)) {
#line 86
      goto while_break;
    }
#line 88
    if (i) {
#line 88
      (vec + i)->code = (ArtPathcode )3;
    } else {
#line 88
      (vec + i)->code = (ArtPathcode )0;
    }
    {
#line 89
    theta = (double )(i & 127) * ((3.14159265358979323846 * 2.0) / (double )128);
#line 90
    tmp___0 = cos(theta);
#line 90
    (vec + i)->x = x + r * tmp___0;
#line 91
    tmp___1 = sin(theta);
#line 91
    (vec + i)->y = y - r * tmp___1;
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  (vec + i)->code = (ArtPathcode )4;
#line 95
  return (vec);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.c"
ArtVpath *art_vpath_affine_transform(ArtVpath const   *src , double const   *matrix ) 
{ 
  int i ;
  int size ;
  ArtVpath *new ;
  double x ;
  double y ;
  void *tmp ;

  {
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned int const   )(src + i)->code != 4U)) {
#line 118
      goto while_break;
    }
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  size = i;
#line 121
  tmp = art_alloc((unsigned long )(size + 1) * sizeof(ArtVpath ));
#line 121
  new = (ArtVpath *)tmp;
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 123
    if (! (i < size)) {
#line 123
      goto while_break___0;
    }
#line 125
    (new + i)->code = (ArtPathcode )(src + i)->code;
#line 126
    x = (double )(src + i)->x;
#line 127
    y = (double )(src + i)->y;
#line 128
    (new + i)->x = (double )((*(matrix + 0) * (double const   )x + *(matrix + 2) * (double const   )y) + *(matrix + 4));
#line 129
    (new + i)->y = (double )((*(matrix + 1) * (double const   )x + *(matrix + 3) * (double const   )y) + *(matrix + 5));
#line 123
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 131
  (new + i)->code = (ArtPathcode )4;
#line 133
  return (new);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.c"
void art_vpath_bbox_drect(ArtVpath const   *vec , ArtDRect *drect ) 
{ 
  int i ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;

  {
#line 149
  if ((unsigned int const   )(vec + 0)->code == 4U) {
#line 151
    y1___0 = (double )0;
#line 151
    x1 = y1___0;
#line 151
    y0___0 = x1;
#line 151
    x0 = y0___0;
  } else {
#line 155
    x1 = (double )(vec + 0)->x;
#line 155
    x0 = x1;
#line 156
    y1___0 = (double )(vec + 0)->y;
#line 156
    y0___0 = y1___0;
#line 157
    i = 1;
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 157
      if (! ((unsigned int const   )(vec + i)->code != 4U)) {
#line 157
        goto while_break;
      }
#line 159
      if ((vec + i)->x < (double const   )x0) {
#line 159
        x0 = (double )(vec + i)->x;
      }
#line 160
      if ((vec + i)->x > (double const   )x1) {
#line 160
        x1 = (double )(vec + i)->x;
      }
#line 161
      if ((vec + i)->y < (double const   )y0___0) {
#line 161
        y0___0 = (double )(vec + i)->y;
      }
#line 162
      if ((vec + i)->y > (double const   )y1___0) {
#line 162
        y1___0 = (double )(vec + i)->y;
      }
#line 157
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 165
  drect->x0 = x0;
#line 166
  drect->y0 = y0___0;
#line 167
  drect->x1 = x1;
#line 168
  drect->y1 = y1___0;
#line 169
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.c"
void art_vpath_bbox_irect(ArtVpath const   *vec , ArtIRect *irect ) 
{ 
  ArtDRect drect ;

  {
  {
#line 183
  art_vpath_bbox_drect(vec, & drect);
#line 184
  art_drect_to_irect(irect, & drect);
  }
#line 185
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath.c"
ArtVpath *art_vpath_perturb(ArtVpath *src ) 
{ 
  int i ;
  int size ;
  ArtVpath *new ;
  double x ;
  double y ;
  double x_start ;
  double y_start ;
  int open ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! ((unsigned int )(src + i)->code != 4U)) {
#line 209
      goto while_break;
    }
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  size = i;
#line 212
  tmp = art_alloc((unsigned long )(size + 1) * sizeof(ArtVpath ));
#line 212
  new = (ArtVpath *)tmp;
#line 214
  x_start = (double )0;
#line 215
  y_start = (double )0;
#line 216
  open = 0;
#line 217
  i = 0;
  }
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (i < size)) {
#line 217
      goto while_break___0;
    }
    {
#line 219
    (new + i)->code = (src + i)->code;
#line 220
    tmp___0 = rand();
#line 220
    x = ((src + i)->x + (2e-3 * (double )tmp___0) / (double )2147483647) - 2e-3 * 0.5;
#line 221
    tmp___1 = rand();
#line 221
    y = ((src + i)->y + (2e-3 * (double )tmp___1) / (double )2147483647) - 2e-3 * 0.5;
    }
#line 222
    if ((unsigned int )(src + i)->code == 0U) {
#line 224
      x_start = x;
#line 225
      y_start = y;
#line 226
      open = 0;
    } else
#line 228
    if ((unsigned int )(src + i)->code == 1U) {
#line 229
      open = 1;
    }
#line 230
    if (! open) {
#line 230
      if (i + 1 == size) {
#line 232
        x = x_start;
#line 233
        y = y_start;
      } else
#line 230
      if ((unsigned int )(src + (i + 1))->code != 3U) {
#line 232
        x = x_start;
#line 233
        y = y_start;
      }
    }
#line 235
    (new + i)->x = x;
#line 236
    (new + i)->y = y;
#line 217
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 238
  (new + i)->code = (ArtPathcode )4;
#line 240
  return (new);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_bpath.h"
ArtBpath *art_bpath_affine_transform(ArtBpath const   *src , double const   *matrix ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_bpath.c"
ArtBpath *art_bpath_affine_transform(ArtBpath const   *src , double const   *matrix ) 
{ 
  int i ;
  int size ;
  ArtBpath *new ;
  ArtPathcode code ;
  double x ;
  double y ;
  void *tmp ;

  {
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! ((unsigned int const   )(src + i)->code != 4U)) {
#line 50
      goto while_break;
    }
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 51
  size = i;
#line 53
  tmp = art_alloc((unsigned long )(size + 1) * sizeof(ArtBpath ));
#line 53
  new = (ArtBpath *)tmp;
#line 55
  i = 0;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (i < size)) {
#line 55
      goto while_break___0;
    }
#line 57
    code = (ArtPathcode )(src + i)->code;
#line 58
    (new + i)->code = code;
#line 59
    if ((unsigned int )code == 2U) {
#line 61
      x = (double )(src + i)->x1;
#line 62
      y = (double )(src + i)->y1;
#line 63
      (new + i)->x1 = (double )((*(matrix + 0) * (double const   )x + *(matrix + 2) * (double const   )y) + *(matrix + 4));
#line 64
      (new + i)->y1 = (double )((*(matrix + 1) * (double const   )x + *(matrix + 3) * (double const   )y) + *(matrix + 5));
#line 65
      x = (double )(src + i)->x2;
#line 66
      y = (double )(src + i)->y2;
#line 67
      (new + i)->x2 = (double )((*(matrix + 0) * (double const   )x + *(matrix + 2) * (double const   )y) + *(matrix + 4));
#line 68
      (new + i)->y2 = (double )((*(matrix + 1) * (double const   )x + *(matrix + 3) * (double const   )y) + *(matrix + 5));
    } else {
#line 72
      (new + i)->x1 = (double )0;
#line 73
      (new + i)->y1 = (double )0;
#line 74
      (new + i)->x2 = (double )0;
#line 75
      (new + i)->y2 = (double )0;
    }
#line 77
    x = (double )(src + i)->x3;
#line 78
    y = (double )(src + i)->y3;
#line 79
    (new + i)->x3 = (double )((*(matrix + 0) * (double const   )x + *(matrix + 2) * (double const   )y) + *(matrix + 4));
#line 80
    (new + i)->y3 = (double )((*(matrix + 1) * (double const   )x + *(matrix + 3) * (double const   )y) + *(matrix + 5));
#line 55
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 82
  (new + i)->code = (ArtPathcode )4;
#line 83
  (new + i)->x1 = (double )0;
#line 84
  (new + i)->y1 = (double )0;
#line 85
  (new + i)->x2 = (double )0;
#line 86
  (new + i)->y2 = (double )0;
#line 87
  (new + i)->x3 = (double )0;
#line 88
  (new + i)->y3 = (double )0;
#line 90
  return (new);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.h"
ArtSVP *art_svp_uncross(ArtSVP *vp ) ;
#line 49
ArtSVP *art_svp_rewind_uncrossed(ArtSVP *vp , ArtWindRule rule ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int intersect_lines(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ,
                           ArtPoint *p ) 
{ 
  double a01 ;
  double b01 ;
  double c01 ;
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double det ;

  {
#line 55
  if (z0.x == z2.x) {
#line 55
    if (z0.y == z2.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 55
  if (z0.x == z3.x) {
#line 55
    if (z0.y == z3.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 55
  if (z1.x == z2.x) {
#line 55
    if (z1.y == z2.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 55
  if (z1.x == z3.x) {
#line 55
    if (z1.y == z3.y) {
#line 56
      return (0);
    }
  }
#line 64
  a01 = z0.y - z1.y;
#line 65
  b01 = z1.x - z0.x;
#line 66
  c01 = - (z0.x * a01 + z0.y * b01);
#line 70
  d2 = (a01 * z2.x + b01 * z2.y) + c01;
#line 71
  d3 = (a01 * z3.x + b01 * z3.y) + c01;
#line 72
  if ((d2 > (double )0) == (d3 > (double )0)) {
#line 73
    return (0);
  }
#line 75
  a23 = z2.y - z3.y;
#line 76
  b23 = z3.x - z2.x;
#line 77
  c23 = - (z2.x * a23 + z2.y * b23);
#line 79
  d0 = (a23 * z0.x + b23 * z0.y) + c23;
#line 80
  d1 = (a23 * z1.x + b23 * z1.y) + c23;
#line 81
  if ((d0 > (double )0) == (d1 > (double )0)) {
#line 82
    return (0);
  }
#line 86
  det = 1.0 / (a01 * b23 - a23 * b01);
#line 87
  p->x = det * (c23 * b01 - c01 * b23);
#line 88
  p->y = det * (c01 * a23 - c23 * a01);
#line 90
  return (1);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static double trap_epsilon(double v ) 
{ 
  double epsilon ;

  {
#line 98
  epsilon = 1e-6;
#line 100
  if (v < epsilon) {
#line 100
    if (v > - epsilon) {
#line 100
      return ((double )0);
    } else {
#line 101
      return (v);
    }
  } else {
#line 101
    return (v);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int x_order(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ) 
{ 
  double a01 ;
  double b01 ;
  double c01 ;
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double x01min ;
  double x01max ;
  double x23min ;
  double x23max ;

  {
#line 132
  if (z0.y == z1.y) {
#line 134
    if (z2.y == z3.y) {
#line 139
      if (z0.x > z1.x) {
#line 141
        x01min = z1.x;
#line 142
        x01max = z0.x;
      } else {
#line 146
        x01min = z0.x;
#line 147
        x01max = z1.x;
      }
#line 150
      if (z2.x > z3.x) {
#line 152
        x23min = z3.x;
#line 153
        x23max = z2.x;
      } else {
#line 157
        x23min = z2.x;
#line 158
        x23max = z3.x;
      }
#line 161
      if (x23min >= x01max) {
#line 161
        return (1);
      } else
#line 162
      if (x01min >= x23max) {
#line 162
        return (-1);
      } else {
#line 163
        return (0);
      }
    } else {
#line 168
      a23 = z2.y - z3.y;
#line 169
      b23 = z3.x - z2.x;
#line 170
      c23 = - (z2.x * a23 + z2.y * b23);
#line 172
      if (z3.y < z2.y) {
#line 174
        a23 = - a23;
#line 175
        b23 = - b23;
#line 176
        c23 = - c23;
      }
      {
#line 179
      d0 = trap_epsilon((a23 * z0.x + b23 * z0.y) + c23);
#line 180
      d1 = trap_epsilon((a23 * z1.x + b23 * z1.y) + c23);
      }
#line 182
      if (d0 > (double )0) {
#line 184
        if (d1 >= (double )0) {
#line 184
          return (1);
        } else {
#line 185
          return (0);
        }
      } else
#line 187
      if (d0 == (double )0) {
#line 189
        if (d1 > (double )0) {
#line 189
          return (1);
        } else
#line 190
        if (d1 < (double )0) {
#line 190
          return (-1);
        } else {
          {
#line 191
          printf((char const   */* __restrict  */)"case 1 degenerate\n");
          }
        }
#line 192
        return (0);
      } else
#line 196
      if (d1 <= (double )0) {
#line 196
        return (-1);
      } else {
#line 197
        return (0);
      }
    }
  } else
#line 201
  if (z2.y == z3.y) {
#line 204
    a01 = z0.y - z1.y;
#line 205
    b01 = z1.x - z0.x;
#line 206
    c01 = - (z0.x * a01 + z0.y * b01);
#line 210
    if (z1.y < z0.y) {
#line 212
      a01 = - a01;
#line 213
      b01 = - b01;
#line 214
      c01 = - c01;
    }
    {
#line 217
    d2 = trap_epsilon((a01 * z2.x + b01 * z2.y) + c01);
#line 218
    d3 = trap_epsilon((a01 * z3.x + b01 * z3.y) + c01);
    }
#line 220
    if (d2 > (double )0) {
#line 222
      if (d3 >= (double )0) {
#line 222
        return (-1);
      } else {
#line 223
        return (0);
      }
    } else
#line 225
    if (d2 == (double )0) {
#line 227
      if (d3 > (double )0) {
#line 227
        return (-1);
      } else
#line 228
      if (d3 < (double )0) {
#line 228
        return (1);
      } else {
        {
#line 229
        printf((char const   */* __restrict  */)"case 2 degenerate\n");
        }
      }
#line 230
      return (0);
    } else
#line 234
    if (d3 <= (double )0) {
#line 234
      return (1);
    } else {
#line 235
      return (0);
    }
  }
#line 240
  a01 = z0.y - z1.y;
#line 241
  b01 = z1.x - z0.x;
#line 242
  c01 = - (z0.x * a01 + z0.y * b01);
#line 246
  if (a01 > (double )0) {
#line 248
    a01 = - a01;
#line 249
    b01 = - b01;
#line 250
    c01 = - c01;
  }
  {
#line 255
  d2 = trap_epsilon((a01 * z2.x + b01 * z2.y) + c01);
#line 256
  d3 = trap_epsilon((a01 * z3.x + b01 * z3.y) + c01);
  }
#line 257
  if (d2 > (double )0) {
#line 259
    if (d3 >= (double )0) {
#line 259
      return (-1);
    }
  } else
#line 261
  if (d2 == (double )0) {
#line 263
    if (d3 > (double )0) {
#line 263
      return (-1);
    } else
#line 264
    if (d3 < (double )0) {
#line 264
      return (1);
    } else {
      {
#line 266
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colinear!\n");
      }
    }
  } else
#line 270
  if (d3 <= (double )0) {
#line 270
    return (1);
  }
#line 273
  a23 = z2.y - z3.y;
#line 274
  b23 = z3.x - z2.x;
#line 275
  c23 = - (z2.x * a23 + z2.y * b23);
#line 277
  if (a23 > (double )0) {
#line 279
    a23 = - a23;
#line 280
    b23 = - b23;
#line 281
    c23 = - c23;
  }
  {
#line 283
  d0 = trap_epsilon((a23 * z0.x + b23 * z0.y) + c23);
#line 284
  d1 = trap_epsilon((a23 * z1.x + b23 * z1.y) + c23);
  }
#line 285
  if (d0 > (double )0) {
#line 287
    if (d1 >= (double )0) {
#line 287
      return (1);
    }
  } else
#line 289
  if (d0 == (double )0) {
#line 291
    if (d1 > (double )0) {
#line 291
      return (1);
    } else
#line 292
    if (d1 < (double )0) {
#line 292
      return (-1);
    } else {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colinear!\n");
      }
    }
  } else
#line 298
  if (d1 <= (double )0) {
#line 298
    return (-1);
  }
#line 301
  return (0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int x_order_2(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ) 
{ 
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;

  {
#line 312
  a23 = z2.y - z3.y;
#line 313
  b23 = z3.x - z2.x;
#line 314
  c23 = - (z2.x * a23 + z2.y * b23);
#line 316
  if (a23 > (double )0) {
#line 318
    a23 = - a23;
#line 319
    b23 = - b23;
#line 320
    c23 = - c23;
  }
#line 323
  d0 = (a23 * z0.x + b23 * z0.y) + c23;
#line 325
  if (d0 > 1e-6) {
#line 326
    return (-1);
  } else
#line 327
  if (d0 < - 1e-6) {
#line 328
    return (1);
  }
#line 330
  d1 = (a23 * z1.x + b23 * z1.y) + c23;
#line 331
  if (d1 > 1e-6) {
#line 332
    return (-1);
  } else
#line 333
  if (d1 < - 1e-6) {
#line 334
    return (1);
  }
#line 336
  if (z0.x == z1.x) {
#line 336
    if (z1.x == z2.x) {
#line 336
      if (z2.x == z3.x) {
        {
#line 338
        art_dprint("x_order_2: colinear and horizontally aligned!\n");
        }
#line 339
        return (0);
      }
    }
  }
#line 342
  if (z0.x <= z2.x) {
#line 342
    if (z1.x <= z2.x) {
#line 342
      if (z0.x <= z3.x) {
#line 342
        if (z1.x <= z3.x) {
#line 343
          return (-1);
        }
      }
    }
  }
#line 344
  if (z0.x >= z2.x) {
#line 344
    if (z1.x >= z2.x) {
#line 344
      if (z0.x >= z3.x) {
#line 344
        if (z1.x >= z3.x) {
#line 345
          return (1);
        }
      }
    }
  }
  {
#line 347
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x_order_2: colinear!\n");
  }
#line 348
  return (0);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void insert_ip(int seg_i , int *n_ips , int *n_ips_max , ArtPoint **ips , ArtPoint ip ) 
{ 
  int i ;
  ArtPoint tmp1 ;
  ArtPoint tmp2 ;
  int n_ipl ;
  ArtPoint *ipl ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 488
  tmp = *(n_ips + seg_i);
#line 488
  (*(n_ips + seg_i)) ++;
#line 488
  n_ipl = tmp;
#line 489
  if (n_ipl == *(n_ips_max + seg_i)) {
    {
#line 490
    while (1) {
      while_continue: /* CIL Label */ ;
#line 490
      if (*(n_ips_max + seg_i)) {
        {
#line 490
        tmp___0 = *(n_ips_max + seg_i) << 1;
#line 490
        *(n_ips_max + seg_i) = tmp___0;
#line 490
        tmp___1 = art_realloc((void *)*(ips + seg_i), (unsigned long )tmp___0 * sizeof(ArtPoint ));
#line 490
        *(ips + seg_i) = (ArtPoint *)tmp___1;
        }
      } else {
        {
#line 490
        *(n_ips_max + seg_i) = 1;
#line 490
        tmp___2 = art_alloc(sizeof(ArtPoint ));
#line 490
        *(ips + seg_i) = (ArtPoint *)tmp___2;
        }
      }
#line 490
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 491
  ipl = *(ips + seg_i);
#line 492
  i = 1;
  {
#line 492
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 492
    if (! (i < n_ipl)) {
#line 492
      goto while_break___0;
    }
#line 493
    if ((ipl + i)->y > ip.y) {
#line 494
      goto while_break___0;
    }
#line 492
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 495
  tmp1 = ip;
  {
#line 496
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 496
    if (! (i <= n_ipl)) {
#line 496
      goto while_break___1;
    }
#line 498
    tmp2 = *(ipl + i);
#line 499
    *(ipl + i) = tmp1;
#line 500
    tmp1 = tmp2;
#line 496
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 502
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void intersect_neighbors(int i , int *active_segs , int *n_ips , int *n_ips_max ,
                                ArtPoint **ips , int *cursor , ArtSVP *vp ) 
{ 
  ArtPoint z0 ;
  ArtPoint z1 ;
  ArtPoint z2 ;
  ArtPoint z3 ;
  int asi01 ;
  int asi23 ;
  ArtPoint ip ;
  int tmp ;

  {
#line 515
  asi01 = *(active_segs + (i - 1));
#line 517
  z0 = *(*(ips + asi01) + 0);
#line 518
  if (*(n_ips + asi01) == 1) {
#line 519
    z1 = *(vp->segs[asi01].points + (*(cursor + asi01) + 1));
  } else {
#line 521
    z1 = *(*(ips + asi01) + 1);
  }
#line 523
  asi23 = *(active_segs + i);
#line 525
  z2 = *(*(ips + asi23) + 0);
#line 526
  if (*(n_ips + asi23) == 1) {
#line 527
    z3 = *(vp->segs[asi23].points + (*(cursor + asi23) + 1));
  } else {
#line 529
    z3 = *(*(ips + asi23) + 1);
  }
  {
#line 531
  tmp = intersect_lines(z0, z1, z2, z3, & ip);
  }
#line 531
  if (tmp) {
    {
#line 536
    insert_ip(asi01, n_ips, n_ips_max, ips, ip);
#line 537
    insert_ip(asi23, n_ips, n_ips_max, ips, ip);
    }
  }
#line 539
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void svp_add_point(ArtSVP *svp , int *n_points_max , ArtPoint p , int *seg_map ,
                          int *active_segs , int n_active_segs , int i ) 
{ 
  int asi ;
  int asi_left ;
  int asi_right ;
  int n_points ;
  int n_points_left ;
  int n_points_right ;
  ArtSVPSeg *seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 556
  asi = *(seg_map + *(active_segs + i));
#line 557
  seg = & svp->segs[asi];
#line 558
  n_points = seg->n_points;
#line 560
  if (i > 0) {
#line 562
    asi_left = *(seg_map + *(active_segs + (i - 1)));
#line 563
    n_points_left = svp->segs[asi_left].n_points;
#line 564
    if (n_points_left > 1) {
#line 564
      if ((svp->segs[asi_left].points + (n_points_left - 2))->x == (svp->segs[asi].points + (n_points - 1))->x) {
#line 564
        if ((svp->segs[asi_left].points + (n_points_left - 2))->y == (svp->segs[asi].points + (n_points - 1))->y) {
          {
#line 570
          tmp = x_order(*(svp->segs[asi_left].points + (n_points_left - 2)), *(svp->segs[asi_left].points + (n_points_left - 1)),
                        *(svp->segs[asi].points + (n_points - 1)), p);
          }
        }
      }
    }
  }
#line 583
  if (i + 1 < n_active_segs) {
#line 585
    asi_right = *(seg_map + *(active_segs + (i + 1)));
#line 586
    n_points_right = svp->segs[asi_right].n_points;
#line 587
    if (n_points_right > 1) {
#line 587
      if ((svp->segs[asi_right].points + (n_points_right - 2))->x == (svp->segs[asi].points + (n_points - 1))->x) {
#line 587
        if ((svp->segs[asi_right].points + (n_points_right - 2))->y == (svp->segs[asi].points + (n_points - 1))->y) {
          {
#line 593
          tmp___0 = x_order(*(svp->segs[asi_right].points + (n_points_right - 2)),
                            *(svp->segs[asi_right].points + (n_points_right - 1)),
                            *(svp->segs[asi].points + (n_points - 1)), p);
          }
        }
      }
    }
  }
#line 604
  if (*(n_points_max + asi) == n_points) {
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      if (*(n_points_max + asi)) {
        {
#line 605
        tmp___1 = *(n_points_max + asi) << 1;
#line 605
        *(n_points_max + asi) = tmp___1;
#line 605
        tmp___2 = art_realloc((void *)seg->points, (unsigned long )tmp___1 * sizeof(ArtPoint ));
#line 605
        seg->points = (ArtPoint *)tmp___2;
        }
      } else {
        {
#line 605
        *(n_points_max + asi) = 1;
#line 605
        tmp___3 = art_alloc(sizeof(ArtPoint ));
#line 605
        seg->points = (ArtPoint *)tmp___3;
        }
      }
#line 605
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 606
  *(seg->points + n_points) = p;
#line 607
  if (p.x < seg->bbox.x0) {
#line 608
    seg->bbox.x0 = p.x;
  } else
#line 609
  if (p.x > seg->bbox.x1) {
#line 610
    seg->bbox.x1 = p.x;
  }
#line 611
  seg->bbox.y1 = p.y;
#line 612
  (seg->n_points) ++;
#line 613
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void fix_crossing(int start , int end , int *active_segs , int n_active_segs ,
                         int *cursor , ArtPoint **ips , int *n_ips , int *n_ips_max ,
                         ArtSVP *vp , int *seg_map , ArtSVP **p_new_vp , int *pn_segs_max ,
                         int **pn_points_max ) 
{ 
  int i ;
  int j ;
  int target ;
  int asi ;
  int asj ;
  ArtPoint p0i ;
  ArtPoint p1i ;
  ArtPoint p0j ;
  ArtPoint p1j ;
  int swap ;
  ArtPoint *pts ;
  int tmp ;
  int seg_num ;
  void *tmp___0 ;
  int as_start ;
  int as_end ;

  {
#line 719
  swap = 0;
#line 732
  if (start == -1) {
#line 733
    return;
  }
#line 735
  i = start + 1;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! (i < end)) {
#line 735
      goto while_break;
    }
#line 738
    asi = *(active_segs + i);
#line 739
    if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 740
      p0i = *(*(ips + asi) + 0);
#line 741
      if (*(n_ips + asi) == 1) {
#line 742
        p1i = *(vp->segs[asi].points + (*(cursor + asi) + 1));
      } else {
#line 744
        p1i = *(*(ips + asi) + 1);
      }
#line 746
      j = i - 1;
      {
#line 746
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 746
        if (! (j >= start)) {
#line 746
          goto while_break___0;
        }
#line 748
        asj = *(active_segs + j);
#line 749
        if (*(cursor + asj) < vp->segs[asj].n_points - 1) {
#line 751
          p0j = *(*(ips + asj) + 0);
#line 752
          if (*(n_ips + asj) == 1) {
#line 753
            p1j = *(vp->segs[asj].points + (*(cursor + asj) + 1));
          } else {
#line 755
            p1j = *(*(ips + asj) + 1);
          }
          {
#line 758
          tmp = x_order_2(p0j, p1j, p0i, p1i);
          }
#line 758
          if (tmp == -1) {
#line 759
            goto while_break___0;
          }
        }
#line 746
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 763
      target = j + 1;
#line 766
      if (target != i) {
#line 768
        swap = 1;
#line 775
        j = i;
        {
#line 775
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 775
          if (! (j >= target)) {
#line 775
            goto while_break___1;
          }
#line 777
          asi = *(active_segs + j);
#line 784
          if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 784
            if ((*p_new_vp)->segs[*(seg_map + asi)].n_points != 1) {
              {
#line 793
              tmp___0 = art_alloc(16UL * sizeof(ArtPoint ));
#line 793
              pts = (ArtPoint *)tmp___0;
#line 794
              *(pts + 0) = *(*(ips + asi) + 0);
#line 795
              seg_num = art_svp_add_segment(p_new_vp, pn_segs_max, pn_points_max,
                                            1, vp->segs[asi].dir, pts, (ArtDRect *)((void *)0));
#line 800
              *(*pn_points_max + seg_num) = 16;
#line 801
              *(seg_map + asi) = seg_num;
              }
            }
          }
#line 775
          j --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 806
        asi = *(active_segs + i);
#line 807
        j = i;
        {
#line 807
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 807
          if (! (j > target)) {
#line 807
            goto while_break___2;
          }
#line 808
          *(active_segs + j) = *(active_segs + (j - 1));
#line 807
          j --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 809
        *(active_segs + j) = asi;
      }
    }
#line 735
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 813
  if (swap) {
#line 813
    if (start > 0) {
#line 817
      as_start = *(active_segs + start);
#line 818
      if (*(cursor + as_start) < vp->segs[as_start].n_points) {
        {
#line 823
        intersect_neighbors(start, active_segs, n_ips, n_ips_max, ips, cursor, vp);
        }
      }
    }
  }
#line 829
  if (swap) {
#line 829
    if (end < n_active_segs) {
#line 833
      as_end = *(active_segs + (end - 1));
#line 834
      if (*(cursor + as_end) < vp->segs[as_end].n_points) {
        {
#line 839
        intersect_neighbors(end, active_segs, n_ips, n_ips_max, ips, cursor, vp);
        }
      }
    }
  }
#line 853
  return;
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
ArtSVP *art_svp_uncross(ArtSVP *vp ) 
{ 
  int *active_segs ;
  int n_active_segs ;
  int *cursor ;
  int seg_idx ;
  double y ;
  int tmp1 ;
  int tmp2 ;
  int asi ;
  int i ;
  int j ;
  int *n_ips ;
  int *n_ips_max ;
  ArtPoint **ips ;
  int n_segs_max ;
  int seg_num ;
  ArtSVP *new_vp ;
  int *n_points_max ;
  int *seg_map ;
  double y_curs ;
  ArtPoint p_curs ;
  int first_share ;
  double share_x ;
  ArtPoint *pts ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 1006
  n_segs_max = 16;
#line 1007
  tmp = art_alloc(sizeof(ArtSVP ) + (unsigned long )(n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 1007
  new_vp = (ArtSVP *)tmp;
#line 1009
  new_vp->n_segs = 0;
  }
#line 1011
  if (vp->n_segs == 0) {
#line 1012
    return (new_vp);
  }
  {
#line 1014
  tmp___0 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1014
  active_segs = (int *)tmp___0;
#line 1015
  tmp___1 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1015
  cursor = (int *)tmp___1;
#line 1017
  tmp___2 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1017
  seg_map = (int *)tmp___2;
#line 1018
  tmp___3 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1018
  n_ips = (int *)tmp___3;
#line 1019
  tmp___4 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1019
  n_ips_max = (int *)tmp___4;
#line 1020
  tmp___5 = art_alloc((unsigned long )vp->n_segs * sizeof(ArtPoint *));
#line 1020
  ips = (ArtPoint **)tmp___5;
#line 1022
  tmp___6 = art_alloc((unsigned long )n_segs_max * sizeof(int ));
#line 1022
  n_points_max = (int *)tmp___6;
#line 1024
  n_active_segs = 0;
#line 1025
  seg_idx = 0;
#line 1026
  y = (vp->segs[0].points + 0)->y;
  }
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1027
    if (! (seg_idx < vp->n_segs)) {
#line 1027
      if (! (n_active_segs > 0)) {
#line 1027
        goto while_break;
      }
    }
#line 1037
    i = 0;
    {
#line 1037
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1037
      if (! (i < n_active_segs)) {
#line 1037
        goto while_break___0;
      }
#line 1039
      asi = *(active_segs + i);
#line 1040
      if (vp->segs[asi].n_points - 1 == *(cursor + asi)) {
#line 1040
        if ((vp->segs[asi].points + *(cursor + asi))->y == y) {
          {
#line 1043
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1048
            art_free((void *)*(ips + asi));
#line 1049
            n_active_segs --;
#line 1050
            j = i;
            }
            {
#line 1050
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1050
              if (! (j < n_active_segs)) {
#line 1050
                goto while_break___2;
              }
#line 1051
              *(active_segs + j) = *(active_segs + (j + 1));
#line 1050
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 1052
            if (i < n_active_segs) {
#line 1053
              asi = *(active_segs + i);
            } else {
#line 1055
              goto while_break___1;
            }
#line 1043
            if (vp->segs[asi].n_points - 1 == *(cursor + asi)) {
#line 1043
              if (! ((vp->segs[asi].points + *(cursor + asi))->y == y)) {
#line 1043
                goto while_break___1;
              }
            } else {
#line 1043
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1061
          if (i > 0) {
#line 1061
            if (i < n_active_segs) {
              {
#line 1062
              intersect_neighbors(i, active_segs, n_ips, n_ips_max, ips, cursor, vp);
              }
            }
          }
#line 1066
          i --;
        }
      }
#line 1037
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1071
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1071
      if (seg_idx < vp->n_segs) {
#line 1071
        if (! (y == (vp->segs[seg_idx].points + 0)->y)) {
#line 1071
          goto while_break___3;
        }
      } else {
#line 1071
        goto while_break___3;
      }
#line 1076
      *(cursor + seg_idx) = 0;
#line 1077
      i = 0;
      {
#line 1077
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1077
        if (! (i < n_active_segs)) {
#line 1077
          goto while_break___4;
        }
        {
#line 1079
        asi = *(active_segs + i);
#line 1080
        tmp___7 = x_order_2(*(vp->segs[seg_idx].points + 0), *(vp->segs[seg_idx].points + 1),
                            *(vp->segs[asi].points + *(cursor + asi)), *(vp->segs[asi].points + (*(cursor + asi) + 1)));
        }
#line 1080
        if (tmp___7 == -1) {
#line 1084
          goto while_break___4;
        }
#line 1077
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1088
      *(n_ips + seg_idx) = 1;
#line 1089
      *(n_ips_max + seg_idx) = 2;
#line 1090
      tmp___8 = art_alloc((unsigned long )*(n_ips_max + seg_idx) * sizeof(ArtPoint ));
#line 1090
      *(ips + seg_idx) = (ArtPoint *)tmp___8;
#line 1091
      *(*(ips + seg_idx) + 0) = *(vp->segs[seg_idx].points + 0);
#line 1094
      tmp___9 = art_alloc(16UL * sizeof(ArtPoint ));
#line 1094
      pts = (ArtPoint *)tmp___9;
#line 1095
      *(pts + 0) = *(vp->segs[seg_idx].points + 0);
#line 1096
      seg_num = art_svp_add_segment(& new_vp, & n_segs_max, & n_points_max, 1, vp->segs[seg_idx].dir,
                                    pts, (ArtDRect *)((void *)0));
#line 1101
      *(n_points_max + seg_num) = 16;
#line 1102
      *(seg_map + seg_idx) = seg_num;
#line 1104
      tmp1 = seg_idx;
#line 1105
      j = i;
      }
      {
#line 1105
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1105
        if (! (j < n_active_segs)) {
#line 1105
          goto while_break___5;
        }
#line 1107
        tmp2 = *(active_segs + j);
#line 1108
        *(active_segs + j) = tmp1;
#line 1109
        tmp1 = tmp2;
#line 1105
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1111
      *(active_segs + n_active_segs) = tmp1;
#line 1112
      n_active_segs ++;
#line 1114
      if (i > 0) {
        {
#line 1115
        intersect_neighbors(i, active_segs, n_ips, n_ips_max, ips, cursor, vp);
        }
      }
#line 1119
      if (i + 1 < n_active_segs) {
        {
#line 1120
        intersect_neighbors(i + 1, active_segs, n_ips, n_ips_max, ips, cursor, vp);
        }
      }
#line 1124
      seg_idx ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1148
    if (n_active_segs == 0) {
#line 1150
      if (seg_idx < vp->n_segs) {
#line 1151
        y = (vp->segs[seg_idx].points + 0)->y;
      }
    } else {
#line 1156
      asi = *(active_segs + 0);
#line 1157
      if (*(n_ips + asi) == 1) {
#line 1158
        y = (vp->segs[asi].points + (*(cursor + asi) + 1))->y;
      } else {
#line 1160
        y = (*(ips + asi) + 1)->y;
      }
#line 1161
      i = 1;
      {
#line 1161
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1161
        if (! (i < n_active_segs)) {
#line 1161
          goto while_break___6;
        }
#line 1163
        asi = *(active_segs + i);
#line 1164
        if (*(n_ips + asi) == 1) {
#line 1165
          y_curs = (vp->segs[asi].points + (*(cursor + asi) + 1))->y;
        } else {
#line 1167
          y_curs = (*(ips + asi) + 1)->y;
        }
#line 1168
        if (y > y_curs) {
#line 1169
          y = y_curs;
        }
#line 1161
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1171
      if (seg_idx < vp->n_segs) {
#line 1171
        if (y > (vp->segs[seg_idx].points + 0)->y) {
#line 1172
          y = (vp->segs[seg_idx].points + 0)->y;
        }
      }
    }
#line 1175
    first_share = -1;
#line 1176
    share_x = (double )0;
#line 1179
    i = 0;
    {
#line 1179
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1179
      if (! (i < n_active_segs)) {
#line 1179
        goto while_break___7;
      }
#line 1181
      asi = *(active_segs + i);
#line 1182
      if (*(n_ips + asi) == 1) {
#line 1183
        p_curs = *(vp->segs[asi].points + (*(cursor + asi) + 1));
      } else {
#line 1185
        p_curs = *(*(ips + asi) + 1);
      }
#line 1186
      if (p_curs.y == y) {
        {
#line 1188
        svp_add_point(new_vp, n_points_max, p_curs, seg_map, active_segs, n_active_segs,
                      i);
#line 1191
        (*(n_ips + asi)) --;
#line 1192
        j = 0;
        }
        {
#line 1192
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1192
          if (! (j < *(n_ips + asi))) {
#line 1192
            goto while_break___8;
          }
#line 1193
          *(*(ips + asi) + j) = *(*(ips + asi) + (j + 1));
#line 1192
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1195
        if (*(n_ips + asi) == 0) {
#line 1197
          *(*(ips + asi) + 0) = p_curs;
#line 1198
          *(n_ips + asi) = 1;
#line 1199
          (*(cursor + asi)) ++;
        }
#line 1202
        if (first_share < 0) {
          {
#line 1207
          fix_crossing(first_share, i, active_segs, n_active_segs, cursor, ips, n_ips,
                       n_ips_max, vp, seg_map, & new_vp, & n_segs_max, & n_points_max);
#line 1213
          first_share = i;
#line 1214
          share_x = p_curs.x;
          }
        } else
#line 1202
        if (p_curs.x != share_x) {
          {
#line 1207
          fix_crossing(first_share, i, active_segs, n_active_segs, cursor, ips, n_ips,
                       n_ips_max, vp, seg_map, & new_vp, & n_segs_max, & n_points_max);
#line 1213
          first_share = i;
#line 1214
          share_x = p_curs.x;
          }
        }
#line 1217
        if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 1220
          if (i > 0) {
            {
#line 1221
            intersect_neighbors(i, active_segs, n_ips, n_ips_max, ips, cursor, vp);
            }
          }
#line 1225
          if (i + 1 < n_active_segs) {
            {
#line 1226
            intersect_neighbors(i + 1, active_segs, n_ips, n_ips_max, ips, cursor,
                                vp);
            }
          }
        }
      } else {
        {
#line 1234
        fix_crossing(first_share, i, active_segs, n_active_segs, cursor, ips, n_ips,
                     n_ips_max, vp, seg_map, & new_vp, & n_segs_max, & n_points_max);
#line 1239
        first_share = -1;
        }
      }
#line 1179
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1244
    fix_crossing(first_share, i, active_segs, n_active_segs, cursor, ips, n_ips, n_ips_max,
                 vp, seg_map, & new_vp, & n_segs_max, & n_points_max);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1277
  art_free((void *)n_points_max);
#line 1278
  art_free((void *)seg_map);
#line 1279
  art_free((void *)n_ips_max);
#line 1280
  art_free((void *)n_ips);
#line 1281
  art_free((void *)ips);
#line 1282
  art_free((void *)cursor);
#line 1283
  art_free((void *)active_segs);
  }
#line 1285
  return (new_vp);
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
ArtSVP *art_svp_rewind_uncrossed(ArtSVP *vp , ArtWindRule rule ) 
{ 
  int *active_segs ;
  int n_active_segs ;
  int *cursor ;
  int seg_idx ;
  double y ;
  int tmp1 ;
  int tmp2 ;
  int asi ;
  int i ;
  int j ;
  ArtSVP *new_vp ;
  int n_segs_max ;
  int *winding ;
  int left_wind ;
  int wind ;
  int keep ;
  int invert ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ArtPoint *points ;
  ArtPoint *new_points ;
  int n_points ;
  int new_dir ;
  void *tmp___5 ;

  {
  {
#line 1364
  n_segs_max = 16;
#line 1365
  tmp = art_alloc(sizeof(ArtSVP ) + (unsigned long )(n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 1365
  new_vp = (ArtSVP *)tmp;
#line 1367
  new_vp->n_segs = 0;
  }
#line 1369
  if (vp->n_segs == 0) {
#line 1370
    return (new_vp);
  }
  {
#line 1372
  tmp___0 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1372
  winding = (int *)tmp___0;
#line 1374
  tmp___1 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1374
  active_segs = (int *)tmp___1;
#line 1375
  tmp___2 = art_alloc((unsigned long )vp->n_segs * sizeof(int ));
#line 1375
  cursor = (int *)tmp___2;
#line 1377
  n_active_segs = 0;
#line 1378
  seg_idx = 0;
#line 1379
  y = (vp->segs[0].points + 0)->y;
  }
  {
#line 1380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1380
    if (! (seg_idx < vp->n_segs)) {
#line 1380
      if (! (n_active_segs > 0)) {
#line 1380
        goto while_break;
      }
    }
#line 1386
    i = 0;
    {
#line 1386
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1386
      if (! (i < n_active_segs)) {
#line 1386
        goto while_break___0;
      }
#line 1388
      asi = *(active_segs + i);
#line 1389
      if (vp->segs[asi].n_points - 1 == *(cursor + asi)) {
#line 1389
        if ((vp->segs[asi].points + *(cursor + asi))->y == y) {
#line 1395
          n_active_segs --;
#line 1396
          j = i;
          {
#line 1396
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1396
            if (! (j < n_active_segs)) {
#line 1396
              goto while_break___1;
            }
#line 1397
            *(active_segs + j) = *(active_segs + (j + 1));
#line 1396
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1398
          i --;
        }
      }
#line 1386
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1403
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1403
      if (seg_idx < vp->n_segs) {
#line 1403
        if (! (y == (vp->segs[seg_idx].points + 0)->y)) {
#line 1403
          goto while_break___2;
        }
      } else {
#line 1403
        goto while_break___2;
      }
#line 1408
      *(cursor + seg_idx) = 0;
#line 1409
      i = 0;
      {
#line 1409
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1409
        if (! (i < n_active_segs)) {
#line 1409
          goto while_break___3;
        }
        {
#line 1411
        asi = *(active_segs + i);
#line 1412
        tmp___3 = x_order_2(*(vp->segs[seg_idx].points + 0), *(vp->segs[seg_idx].points + 1),
                            *(vp->segs[asi].points + *(cursor + asi)), *(vp->segs[asi].points + (*(cursor + asi) + 1)));
        }
#line 1412
        if (tmp___3 == -1) {
#line 1416
          goto while_break___3;
        }
#line 1409
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1420
      if (i == 0) {
#line 1421
        left_wind = 0;
      } else
#line 1422
      if (vp->segs[*(active_segs + (i - 1))].dir) {
#line 1423
        left_wind = *(winding + *(active_segs + (i - 1)));
      } else {
#line 1425
        left_wind = *(winding + *(active_segs + (i - 1))) - 1;
      }
#line 1427
      if (vp->segs[seg_idx].dir) {
#line 1428
        wind = left_wind + 1;
      } else {
#line 1430
        wind = left_wind;
      }
#line 1432
      *(winding + seg_idx) = wind;
      {
#line 1436
      if ((unsigned int )rule == 0U) {
#line 1436
        goto case_0;
      }
#line 1440
      if ((unsigned int )rule == 1U) {
#line 1440
        goto case_1;
      }
#line 1444
      if ((unsigned int )rule == 2U) {
#line 1444
        goto case_2;
      }
#line 1448
      if ((unsigned int )rule == 3U) {
#line 1448
        goto case_3;
      }
#line 1452
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1437
      if (wind == 1) {
#line 1437
        tmp___4 = 1;
      } else
#line 1437
      if (wind == 0) {
#line 1437
        tmp___4 = 1;
      } else {
#line 1437
        tmp___4 = 0;
      }
#line 1437
      keep = tmp___4;
#line 1438
      invert = wind == 0;
#line 1439
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1441
      keep = wind == 2;
#line 1442
      invert = 0;
#line 1443
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1445
      keep = 1;
#line 1446
      invert = ! (wind & 1);
#line 1447
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1449
      keep = wind == 1;
#line 1450
      invert = 0;
#line 1451
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1453
      keep = 0;
#line 1454
      invert = 0;
#line 1455
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1458
      if (keep) {
        {
#line 1467
        n_points = vp->segs[seg_idx].n_points;
#line 1468
        points = vp->segs[seg_idx].points;
#line 1469
        tmp___5 = art_alloc((unsigned long )n_points * sizeof(ArtPoint ));
#line 1469
        new_points = (ArtPoint *)tmp___5;
#line 1470
        memcpy((void */* __restrict  */)new_points, (void const   */* __restrict  */)points,
               (unsigned long )n_points * sizeof(ArtPoint ));
#line 1471
        new_dir = vp->segs[seg_idx].dir ^ invert;
#line 1472
        art_svp_add_segment(& new_vp, & n_segs_max, (int **)((void *)0), n_points,
                            new_dir, new_points, & vp->segs[seg_idx].bbox);
        }
      }
#line 1478
      tmp1 = seg_idx;
#line 1479
      j = i;
      {
#line 1479
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1479
        if (! (j < n_active_segs)) {
#line 1479
          goto while_break___4;
        }
#line 1481
        tmp2 = *(active_segs + j);
#line 1482
        *(active_segs + j) = tmp1;
#line 1483
        tmp1 = tmp2;
#line 1479
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1485
      *(active_segs + n_active_segs) = tmp1;
#line 1486
      n_active_segs ++;
#line 1487
      seg_idx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1508
    if (n_active_segs == 0) {
#line 1510
      if (seg_idx < vp->n_segs) {
#line 1511
        y = (vp->segs[seg_idx].points + 0)->y;
      }
    } else {
#line 1516
      asi = *(active_segs + 0);
#line 1517
      y = (vp->segs[asi].points + (*(cursor + asi) + 1))->y;
#line 1518
      i = 1;
      {
#line 1518
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1518
        if (! (i < n_active_segs)) {
#line 1518
          goto while_break___5;
        }
#line 1520
        asi = *(active_segs + i);
#line 1521
        if (y > (vp->segs[asi].points + (*(cursor + asi) + 1))->y) {
#line 1522
          y = (vp->segs[asi].points + (*(cursor + asi) + 1))->y;
        }
#line 1518
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1524
      if (seg_idx < vp->n_segs) {
#line 1524
        if (y > (vp->segs[seg_idx].points + 0)->y) {
#line 1525
          y = (vp->segs[seg_idx].points + 0)->y;
        }
      }
    }
#line 1529
    i = 0;
    {
#line 1529
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1529
      if (! (i < n_active_segs)) {
#line 1529
        goto while_break___6;
      }
#line 1531
      asi = *(active_segs + i);
      {
#line 1532
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1532
        if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 1532
          if (! (y >= (vp->segs[asi].points + (*(cursor + asi) + 1))->y)) {
#line 1532
            goto while_break___7;
          }
        } else {
#line 1532
          goto while_break___7;
        }
#line 1534
        (*(cursor + asi)) ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1529
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1540
  art_free((void *)cursor);
#line 1541
  art_free((void *)active_segs);
#line 1542
  art_free((void *)winding);
  }
#line 1544
  return (new_vp);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.h"
void art_gray_svp_aa(ArtSVP const   *svp , int x0 , int y0 , int x1 , int y1 , art_u8 *buf ,
                     int rowstride ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
static void art_gray_svp_callback(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                  int n_steps ) 
{ 
  ArtGraySVPData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int k ;

  {
#line 43
  data = (ArtGraySVPData *)callback_data;
#line 46
  running_sum = start;
#line 61
  linebuf = data->buf;
#line 62
  x0 = data->x0;
#line 63
  x1 = data->x1;
#line 65
  if (n_steps > 0) {
#line 67
    run_x1 = (steps + 0)->x;
#line 68
    if (run_x1 > x0) {
      {
#line 69
      memset((void *)linebuf, running_sum >> 16, (size_t )(run_x1 - x0));
      }
    }
#line 71
    k = 0;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (k < n_steps - 1)) {
#line 71
        goto while_break;
      }
#line 73
      running_sum += (steps + k)->delta;
#line 74
      run_x0 = run_x1;
#line 75
      run_x1 = (steps + (k + 1))->x;
#line 76
      if (run_x1 > run_x0) {
        {
#line 77
        memset((void *)((linebuf + run_x0) - x0), running_sum >> 16, (size_t )(run_x1 - run_x0));
        }
      }
#line 71
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 79
    running_sum += (steps + k)->delta;
#line 80
    if (x1 > run_x1) {
      {
#line 81
      memset((void *)((linebuf + run_x1) - x0), running_sum >> 16, (size_t )(x1 - run_x1));
      }
    }
  } else {
    {
#line 85
    memset((void *)linebuf, running_sum >> 16, (size_t )(x1 - x0));
    }
  }
#line 88
  data->buf += data->rowstride;
#line 89
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
void art_gray_svp_aa(ArtSVP const   *svp , int x0 , int y0 , int x1 , int y1 , art_u8 *buf ,
                     int rowstride ) 
{ 
  ArtGraySVPData data ;

  {
  {
#line 118
  data.buf = buf;
#line 119
  data.rowstride = rowstride;
#line 120
  data.x0 = x0;
#line 121
  data.x1 = x1;
#line 122
  art_svp_render_aa(svp, x0, y0, x1, y1, & art_gray_svp_callback, (void *)(& data));
  }
#line 123
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_pixbuf_affine.h"
void art_rgb_pixbuf_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 ,
                           int dst_rowstride , ArtPixBuf const   *pixbuf , double const   *affine ,
                           ArtFilterLevel level , ArtAlphaGamma *alphagamma ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_pixbuf_affine.c"
void art_rgb_pixbuf_affine(art_u8 *dst , int x0 , int y0___0 , int x1 , int y1___0 ,
                           int dst_rowstride , ArtPixBuf const   *pixbuf , double const   *affine ,
                           ArtFilterLevel level , ArtAlphaGamma *alphagamma ) 
{ 


  {
#line 72
  if ((unsigned int const   )pixbuf->format != 0U) {
    {
#line 74
    art_warn("art_rgb_pixbuf_affine: need RGB format image\n");
    }
#line 75
    return;
  }
#line 78
  if (pixbuf->bits_per_sample != 8) {
    {
#line 80
    art_warn("art_rgb_pixbuf_affine: need 8-bit sample data\n");
    }
#line 81
    return;
  }
#line 84
  if (pixbuf->n_channels != (int const   )(3 + (pixbuf->has_alpha != 0))) {
    {
#line 86
    art_warn("art_rgb_pixbuf_affine: need 8-bit sample data\n");
    }
#line 87
    return;
  }
#line 90
  if (pixbuf->has_alpha) {
    {
#line 91
    art_rgb_rgba_affine(dst, x0, y0___0, x1, y1___0, dst_rowstride, (art_u8 const   *)pixbuf->pixels,
                        (int )pixbuf->width, (int )pixbuf->height, (int )pixbuf->rowstride,
                        affine, level, alphagamma);
    }
  } else {
    {
#line 98
    art_rgb_affine(dst, x0, y0___0, x1, y1___0, dst_rowstride, (art_u8 const   *)pixbuf->pixels,
                   (int )pixbuf->width, (int )pixbuf->height, (int )pixbuf->rowstride,
                   affine, level, alphagamma);
    }
  }
#line 104
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_done___0(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 48
  art_free((void *)self);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static int art_render_mask_can_drive___0(ArtMaskSource *self , ArtRender *render ) 
{ 


  {
#line 54
  return (0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_render___0(ArtRenderCallback *self , ArtRender *render ,
                                       art_u8 *dest , int y ) 
{ 
  ArtMaskSourceMask *z ;
  int x0 ;
  int x1 ;
  int z_x0 ;
  int z_x1 ;
  int width ;
  int z_width ;
  art_u8 *alpha_buf ;
  art_u8 const   *src_line ;
  art_u8 *dst_line ;
  int x ;
  int v ;

  {
#line 61
  z = (ArtMaskSourceMask *)self;
#line 62
  x0 = render->x0;
#line 62
  x1 = render->x1;
#line 63
  z_x0 = z->x0;
#line 63
  z_x1 = z->x1;
#line 64
  width = x1 - x0;
#line 65
  z_width = z_x1 - z_x0;
#line 66
  alpha_buf = render->alpha_buf;
#line 68
  if (y < z->y0) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else
#line 68
  if (y >= z->y1) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else
#line 68
  if (z_width <= 0) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else {
#line 72
    src_line = z->mask_buf + (y - z->y0) * z->rowstride;
#line 73
    dst_line = (alpha_buf + z_x0) - x0;
#line 75
    if (z_x0 > x0) {
      {
#line 76
      memset((void *)alpha_buf, 0, (size_t )(z_x0 - x0));
      }
    }
#line 78
    if (z->first) {
      {
#line 79
      memcpy((void */* __restrict  */)dst_line, (void const   */* __restrict  */)src_line,
             (size_t )z_width);
      }
    } else {
#line 84
      x = 0;
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;
#line 84
        if (! (x < z_width)) {
#line 84
          goto while_break;
        }
#line 87
        v = (int )*(src_line + x);
#line 88
        if (v) {
#line 90
          v = v * (int )*(dst_line + x) + 128;
#line 91
          v = (v + (v >> 8)) >> 8;
#line 92
          *(dst_line + x) = (art_u8 )v;
        } else {
#line 96
          *(dst_line + x) = (art_u8 )0;
        }
#line 84
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 101
    if (z_x1 < x1) {
      {
#line 102
      memset((void *)((alpha_buf + z_x1) - x0), 0, (size_t )(x1 - z_x1));
      }
    }
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_prepare___0(ArtMaskSource *self , ArtRender *render ,
                                        art_boolean first ) 
{ 
  ArtMaskSourceMask *z ;

  {
#line 110
  z = (ArtMaskSourceMask *)self;
#line 111
  self->super.render = & art_render_mask_render___0;
#line 112
  z->first = first;
#line 113
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_bitmap_affine.c"
static void art_rgb_bitmap_affine_opaque___0(art_u8 *dst , int x0 , int y0___0 , int x1 ,
                                             int y1___0 , int dst_rowstride , art_u8 const   *src ,
                                             int src_width , int src_height , int src_rowstride ,
                                             art_u32 rgb , double const   *affine ,
                                             ArtFilterLevel level , ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int run_x0 ;
  int run_x1 ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 59
  r = (art_u8 )(rgb >> 16);
#line 60
  g = (art_u8 )((rgb >> 8) & 255U);
#line 61
  b = (art_u8 )(rgb & 255U);
#line 62
  dst_linestart = dst;
#line 63
  art_affine_invert((double *)(inv), affine);
#line 64
  y = y0___0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (y < y1___0)) {
#line 64
      goto while_break;
    }
    {
#line 66
    pt.y = (double )y + 0.5;
#line 67
    run_x0 = x0;
#line 68
    run_x1 = x1;
#line 69
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 71
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 72
    x = run_x0;
    }
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! (x < run_x1)) {
#line 72
        goto while_break___0;
      }
      {
#line 74
      pt.x = (double )x + 0.5;
#line 75
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 76
      tmp = floor(src_pt.x);
#line 76
      src_x = (int )tmp;
#line 77
      tmp___0 = floor(src_pt.y);
#line 77
      src_y = (int )tmp___0;
#line 78
      src_p = (src + src_y * src_rowstride) + (src_x >> 3);
      }
#line 79
      if ((int const   )*src_p & (int const   )(128 >> (src_x & 7))) {
#line 81
        *(dst_p + 0) = r;
#line 82
        *(dst_p + 1) = g;
#line 83
        *(dst_p + 2) = b;
      }
#line 85
      dst_p += 3;
#line 72
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    dst_linestart += dst_rowstride;
#line 64
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_rgba_gradient_run___0(art_u8 *buf , art_u8 *color1 , art_u8 *color2 ,
                                      int len ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int a ;
  int dr ;
  int dg ;
  int db ;
  int da ;
  art_u8 *tmp ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;

  {
#line 108
  r = ((int )*(color1 + 0) << 16) + 32768;
#line 109
  g = ((int )*(color1 + 1) << 16) + 32768;
#line 110
  b = ((int )*(color1 + 2) << 16) + 32768;
#line 111
  a = ((int )*(color1 + 3) << 16) + 32768;
#line 112
  dr = (((int )*(color2 + 0) - (int )*(color1 + 0)) << 16) / len;
#line 113
  dg = (((int )*(color2 + 1) - (int )*(color1 + 1)) << 16) / len;
#line 114
  db = (((int )*(color2 + 2) - (int )*(color1 + 2)) << 16) / len;
#line 115
  da = (((int )*(color2 + 3) - (int )*(color1 + 3)) << 16) / len;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < len)) {
#line 117
      goto while_break;
    }
#line 119
    tmp = buf;
#line 119
    buf ++;
#line 119
    *tmp = (art_u8 )(r >> 16);
#line 120
    tmp___0 = buf;
#line 120
    buf ++;
#line 120
    *tmp___0 = (art_u8 )(g >> 16);
#line 121
    tmp___1 = buf;
#line 121
    buf ++;
#line 121
    *tmp___1 = (art_u8 )(b >> 16);
#line 122
    tmp___2 = buf;
#line 122
    buf ++;
#line 122
    *tmp___2 = (art_u8 )(a >> 16);
#line 124
    r += dr;
#line 125
    g += dg;
#line 126
    b += db;
#line 127
    a += da;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void calc_color_at___0(ArtGradientStop *stops , int n_stops , ArtGradientSpread spread ,
                              double offset , double offset_fraction , int favor_start ,
                              int ix , art_u8 *color ) 
{ 
  double off0 ;
  double off1 ;
  int j ;
  double interp ;
  double o ;
  double tmp ;
  double tmp___0 ;
  int z0 ;
  int z1 ;
  int z ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 144
  if ((unsigned int )spread == 0U) {
#line 146
    if (offset < 0.0) {
#line 148
      *(color + 0) = (art_u8 )((((int )(stops + 0)->color[0] + 128) - (((int )(stops + 0)->color[0] + 128) >> 8)) >> 8);
#line 149
      *(color + 1) = (art_u8 )((((int )(stops + 0)->color[1] + 128) - (((int )(stops + 0)->color[1] + 128) >> 8)) >> 8);
#line 150
      *(color + 2) = (art_u8 )((((int )(stops + 0)->color[2] + 128) - (((int )(stops + 0)->color[2] + 128) >> 8)) >> 8);
#line 151
      *(color + 3) = (art_u8 )((((int )(stops + 0)->color[3] + 128) - (((int )(stops + 0)->color[3] + 128) >> 8)) >> 8);
#line 152
      return;
    }
#line 154
    if (offset >= 1.0) {
#line 156
      *(color + 0) = (art_u8 )((((int )(stops + (n_stops - 1))->color[0] + 128) - (((int )(stops + (n_stops - 1))->color[0] + 128) >> 8)) >> 8);
#line 157
      *(color + 1) = (art_u8 )((((int )(stops + (n_stops - 1))->color[1] + 128) - (((int )(stops + (n_stops - 1))->color[1] + 128) >> 8)) >> 8);
#line 158
      *(color + 2) = (art_u8 )((((int )(stops + (n_stops - 1))->color[2] + 128) - (((int )(stops + (n_stops - 1))->color[2] + 128) >> 8)) >> 8);
#line 159
      *(color + 3) = (art_u8 )((((int )(stops + (n_stops - 1))->color[3] + 128) - (((int )(stops + (n_stops - 1))->color[3] + 128) >> 8)) >> 8);
#line 160
      return;
    }
  }
#line 164
  if (ix > 0) {
#line 164
    if (ix < n_stops) {
      {
#line 166
      off0 = (stops + (ix - 1))->offset;
#line 167
      off1 = (stops + ix)->offset;
#line 168
      tmp___2 = fabs(off1 - off0);
      }
#line 168
      if (tmp___2 > 1e-6) {
        {
#line 172
        o = offset_fraction;
#line 174
        tmp___0 = fabs(o);
        }
#line 174
        if (tmp___0 < 1e-6) {
#line 174
          if (! favor_start) {
#line 175
            o = 1.0;
          } else {
#line 174
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 176
          tmp = fabs(o - 1.0);
          }
#line 176
          if (tmp < 1e-6) {
#line 176
            if (favor_start) {
#line 177
              o = 0.0;
            }
          }
        }
#line 184
        interp = (o - off0) / (off1 - off0);
#line 185
        j = 0;
        {
#line 185
        while (1) {
          while_continue: /* CIL Label */ ;
#line 185
          if (! (j < 4)) {
#line 185
            goto while_break;
          }
          {
#line 189
          z0 = (int )(stops + (ix - 1))->color[j];
#line 190
          z1 = (int )(stops + ix)->color[j];
#line 191
          tmp___1 = floor(((double )z0 + (double )(z1 - z0) * interp) + 0.5);
#line 191
          z = (int )tmp___1;
#line 192
          *(color + j) = (art_u8 )(((z + 128) - ((z + 128) >> 8)) >> 8);
#line 185
          j ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 194
        return;
      }
#line 198
      *(color + 0) = (art_u8 )((((int )(stops + ix)->color[0] + 128) - (((int )(stops + ix)->color[0] + 128) >> 8)) >> 8);
#line 199
      *(color + 1) = (art_u8 )((((int )(stops + ix)->color[1] + 128) - (((int )(stops + ix)->color[1] + 128) >> 8)) >> 8);
#line 200
      *(color + 2) = (art_u8 )((((int )(stops + ix)->color[2] + 128) - (((int )(stops + ix)->color[2] + 128) >> 8)) >> 8);
#line 201
      *(color + 3) = (art_u8 )((((int )(stops + ix)->color[3] + 128) - (((int )(stops + ix)->color[3] + 128) >> 8)) >> 8);
#line 202
      return;
    }
  }
  {
#line 205
  printf((char const   */* __restrict  */)"WARNING! bad ix %d in calc_color_at() [internal error]\n",
         ix);
#line 206
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                206U, "calc_color_at");
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_render_8___0(ArtRenderCallback *self , ArtRender *render ,
                                                    art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradLin *z ;
  ArtGradientLinear const   *gradient ;
  int i ;
  int width ;
  int len ;
  double offset ;
  double d_offset ;
  double offset_fraction ;
  int next_stop ;
  int ix ;
  art_u8 color1[4] ;
  art_u8 color2[4] ;
  int n_stops ;
  int extra_stops ;
  ArtGradientStop *stops ;
  ArtGradientStop *tmp_stops ;
  art_u8 *bufp ;
  ArtGradientSpread spread ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double o ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
#line 214
  z = (ArtImageSourceGradLin *)self;
#line 215
  gradient = (ArtGradientLinear const   *)(& z->gradient);
#line 217
  width = render->x1 - render->x0;
#line 224
  n_stops = (int )gradient->n_stops;
#line 226
  stops = (ArtGradientStop *)gradient->stops;
#line 228
  bufp = render->image_buf;
#line 229
  spread = (ArtGradientSpread )gradient->spread;
#line 242
  offset = (double )(((double const   )render->x0 * gradient->a + (double const   )y * gradient->b) + gradient->c);
#line 243
  d_offset = (double )gradient->a;
#line 248
  if ((gradient->stops + 0)->offset > 1e-6) {
#line 248
    goto _L;
  } else
#line 248
  if ((gradient->stops + (n_stops - 1))->offset < 1.0 - 1e-6) {
    _L: /* CIL Label */ 
    {
#line 251
    extra_stops = 0;
#line 252
    tmp = __builtin_alloca(sizeof(ArtGradientStop ) * (unsigned long )(n_stops + 2));
#line 252
    stops = (ArtGradientStop *)tmp;
#line 252
    tmp_stops = stops;
    }
#line 253
    if ((gradient->stops + 0)->offset > 1e-6) {
      {
#line 255
      memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)gradient->stops,
             sizeof(ArtGradientStop ));
#line 256
      (tmp_stops + 0)->offset = 0.0;
#line 257
      tmp_stops ++;
#line 258
      extra_stops ++;
      }
    }
    {
#line 260
    memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)gradient->stops,
           sizeof(ArtGradientStop ) * (unsigned long )n_stops);
    }
#line 261
    if ((gradient->stops + (n_stops - 1))->offset < 1.0 - 1e-6) {
      {
#line 263
      tmp_stops += n_stops;
#line 264
      memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)(gradient->stops + (n_stops - 1)),
             sizeof(ArtGradientStop ));
#line 265
      (tmp_stops + 0)->offset = 1.0;
#line 266
      extra_stops ++;
      }
    }
#line 268
    n_stops += extra_stops;
  }
#line 282
  if ((unsigned int )spread == 1U) {
    {
#line 284
    tmp_stops = stops;
#line 285
    tmp___0 = __builtin_alloca((sizeof(ArtGradientStop ) * (unsigned long )n_stops) * 2UL);
#line 285
    stops = (ArtGradientStop *)tmp___0;
#line 286
    memcpy((void */* __restrict  */)stops, (void const   */* __restrict  */)tmp_stops,
           sizeof(ArtGradientStop ) * (unsigned long )n_stops);
#line 288
    i = 0;
    }
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < n_stops)) {
#line 288
        goto while_break;
      }
      {
#line 290
      (stops + ((n_stops * 2 - 1) - i))->offset = 1.0 - (stops + i)->offset / 2.0;
#line 291
      memcpy((void */* __restrict  */)((stops + ((n_stops * 2 - 1) - i))->color),
             (void const   */* __restrict  */)((stops + i)->color), sizeof((stops + i)->color));
#line 292
      (stops + i)->offset /= 2.0;
#line 288
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 295
    spread = (ArtGradientSpread )2;
#line 296
    offset /= 2.0;
#line 297
    d_offset /= 2.0;
#line 299
    n_stops = 2 * n_stops;
  }
  {
#line 311
  tmp___1 = floor(offset);
#line 311
  offset_fraction = offset - tmp___1;
#line 321
  ix = 0;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! (ix < n_stops)) {
#line 321
      goto while_break___0;
    }
#line 322
    if ((stops + ix)->offset > offset_fraction) {
#line 324
      goto while_break___0;
    } else
#line 322
    if (d_offset < 0.0) {
      {
#line 322
      tmp___2 = fabs((stops + ix)->offset - offset_fraction);
      }
#line 322
      if (tmp___2 < 1e-6) {
#line 324
        goto while_break___0;
      }
    }
#line 321
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  if (ix == 0) {
#line 326
    ix = n_stops - 1;
  } else
#line 327
  if (ix == n_stops) {
#line 328
    ix = n_stops - 1;
  }
#line 334
  if (! (ix > 0)) {
    {
#line 334
    __assert_fail("ix > 0", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  334U, "art_render_gradient_linear_render_8");
    }
  }
#line 335
  if (! (ix < n_stops)) {
    {
#line 335
    __assert_fail("ix < n_stops", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  335U, "art_render_gradient_linear_render_8");
    }
  }
#line 336
  if (! ((stops + (ix - 1))->offset <= offset_fraction + 1e-6)) {
#line 336
    if ((stops + ix)->offset > 1.0 - 1e-6) {
#line 336
      if (! (offset_fraction < 1e-6)) {
        {
#line 336
        __assert_fail("(stops[ix-1].offset <= offset_fraction + 1e-6) || ((stops[ix].offset > (1.0 - 1e-6)) && (offset_fraction < 1e-6 ))",
                      "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                      337U, "art_render_gradient_linear_render_8");
        }
      }
    } else {
      {
#line 336
      __assert_fail("(stops[ix-1].offset <= offset_fraction + 1e-6) || ((stops[ix].offset > (1.0 - 1e-6)) && (offset_fraction < 1e-6 ))",
                    "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                    337U, "art_render_gradient_linear_render_8");
      }
    }
  }
#line 338
  if (! (offset_fraction <= (stops + ix)->offset)) {
    {
#line 338
    __assert_fail("offset_fraction <= stops[ix].offset", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  338U, "art_render_gradient_linear_render_8");
    }
  }
  {
#line 348
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 348
    if (! (width > 0)) {
#line 348
      goto while_break___1;
    }
    {
#line 354
    calc_color_at___0(stops, n_stops, spread, offset, offset_fraction, d_offset > - 1e-6,
                      ix, color1);
    }
#line 362
    if (d_offset > (double )0) {
#line 363
      next_stop = ix;
    } else {
#line 365
      next_stop = ix - 1;
    }
    {
#line 370
    tmp___7 = fabs(d_offset);
    }
#line 370
    if (tmp___7 > 1e-6) {
      {
#line 373
      o = offset_fraction;
#line 375
      tmp___4 = fabs(o);
      }
#line 375
      if (tmp___4 <= 1e-6) {
#line 375
        if (ix == n_stops - 1) {
#line 376
          o = 1.0;
        } else {
#line 375
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 377
        tmp___3 = fabs(o - 1.0);
        }
#line 377
        if (tmp___3 <= 1e-6) {
#line 377
          if (ix == 1) {
#line 378
            o = 0.0;
          }
        }
      }
      {
#line 383
      tmp___5 = fabs(((stops + next_stop)->offset - o) / d_offset);
#line 383
      tmp___6 = floor(tmp___5);
#line 383
      len = (int )tmp___6 + 1;
      }
#line 384
      if (len > 0) {
#line 384
        len = len;
      } else {
#line 384
        len = 0;
      }
#line 385
      if (len < width) {
#line 385
        len = len;
      } else {
#line 385
        len = width;
      }
    } else {
#line 389
      len = width;
    }
#line 394
    if (len > 0) {
      {
#line 396
      offset += (double )(len - 1) * d_offset;
#line 397
      tmp___8 = floor(offset);
#line 397
      offset_fraction = offset - tmp___8;
#line 401
      calc_color_at___0(stops, n_stops, spread, offset, offset_fraction, d_offset < 1e-6,
                        ix, color2);
#line 409
      art_rgba_gradient_run___0(bufp, color1, color2, len);
#line 413
      offset += d_offset;
#line 414
      tmp___9 = floor(offset);
#line 414
      offset_fraction = offset - tmp___9;
      }
    }
#line 417
    if (d_offset > (double )0) {
      {
#line 419
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 421
        ix ++;
#line 422
        if (ix == n_stops) {
#line 423
          ix = 1;
        }
#line 419
        if ((stops + (ix - 1))->offset <= offset_fraction) {
#line 419
          if (offset_fraction < (stops + ix)->offset) {
#line 419
            goto while_break___2;
          } else {
#line 419
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 419
        if (ix == 1) {
#line 419
          if (offset_fraction > 1.0 - 1e-6) {
#line 419
            goto while_break___2;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 436
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 438
        ix --;
#line 439
        if (ix == 0) {
#line 440
          ix = n_stops - 1;
        }
#line 436
        if ((stops + (ix - 1))->offset < offset_fraction) {
#line 436
          if (offset_fraction <= (stops + ix)->offset) {
#line 436
            goto while_break___3;
          } else {
#line 436
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 436
        if (ix == n_stops - 1) {
#line 436
          if (offset_fraction < 1e-6) {
#line 436
            goto while_break___3;
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 447
    bufp += 4 * len;
#line 448
    width -= len;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 450
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_setpix___0(ArtRender *render , art_u8 *dst , int n_stops ,
                                           ArtGradientStop *stops , double offset ) 
{ 
  int ix ;
  int j ;
  double off0 ;
  double off1 ;
  int n_ch ;
  double interp ;
  int z0 ;
  int z1 ;
  int z ;
  double tmp ;
  double tmp___0 ;
  int z___0 ;

  {
#line 474
  n_ch = render->n_chan + 1;
#line 476
  ix = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (ix < n_stops)) {
#line 476
      goto while_break;
    }
#line 477
    if ((stops + ix)->offset > offset) {
#line 478
      goto while_break;
    }
#line 476
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  if (ix > 0) {
#line 480
    if (ix < n_stops) {
      {
#line 482
      off0 = (stops + (ix - 1))->offset;
#line 483
      off1 = (stops + ix)->offset;
#line 484
      tmp___0 = fabs(off1 - off0);
      }
#line 484
      if (tmp___0 > 1e-6) {
#line 488
        interp = (offset - off0) / (off1 - off0);
#line 489
        j = 0;
        {
#line 489
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 489
          if (! (j < n_ch)) {
#line 489
            goto while_break___0;
          }
          {
#line 493
          z0 = (int )(stops + (ix - 1))->color[j];
#line 494
          z1 = (int )(stops + ix)->color[j];
#line 495
          tmp = floor(((double )z0 + (double )(z1 - z0) * interp) + 0.5);
#line 495
          z = (int )tmp;
          }
#line 496
          if (render->buf_depth == 8) {
#line 497
            *(dst + j) = (art_u8 )(((z + 128) - ((z + 128) >> 8)) >> 8);
          } else {
#line 499
            *((art_u16 *)dst + j) = (art_u16 )z;
          }
#line 489
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 501
        return;
      }
    } else {
#line 480
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 504
  if (ix == n_stops) {
#line 505
    ix --;
  }
#line 507
  j = 0;
  {
#line 507
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 507
    if (! (j < n_ch)) {
#line 507
      goto while_break___1;
    }
#line 510
    z___0 = (int )(stops + ix)->color[j];
#line 511
    if (render->buf_depth == 8) {
#line 512
      *(dst + j) = (art_u8 )(((z___0 + 128) - ((z___0 + 128) >> 8)) >> 8);
    } else {
#line 514
      *((art_u16 *)dst + j) = (art_u16 )z___0;
    }
#line 507
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_done___0(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 521
  art_free((void *)self);
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_render___0(ArtRenderCallback *self , ArtRender *render ,
                                                  art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradLin *z ;
  ArtGradientLinear const   *gradient ;
  int pixstride ;
  int x ;
  int width ;
  double offset ;
  double d_offset ;
  double actual_offset ;
  int n_stops ;
  ArtGradientStop *stops ;
  art_u8 *bufp ;
  ArtGradientSpread spread ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 528
  z = (ArtImageSourceGradLin *)self;
#line 529
  gradient = (ArtGradientLinear const   *)(& z->gradient);
#line 530
  pixstride = (render->n_chan + 1) * (render->depth >> 3);
#line 532
  width = render->x1 - render->x0;
#line 535
  n_stops = (int )gradient->n_stops;
#line 536
  stops = (ArtGradientStop *)gradient->stops;
#line 537
  bufp = render->image_buf;
#line 538
  spread = (ArtGradientSpread )gradient->spread;
#line 540
  offset = (double )(((double const   )render->x0 * gradient->a + (double const   )y * gradient->b) + gradient->c);
#line 541
  d_offset = (double )gradient->a;
#line 543
  x = 0;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (x < width)) {
#line 543
      goto while_break;
    }
#line 545
    if ((unsigned int )spread == 0U) {
#line 546
      actual_offset = offset;
    } else
#line 547
    if ((unsigned int )spread == 2U) {
      {
#line 548
      tmp = floor(offset);
#line 548
      actual_offset = offset - tmp;
      }
    } else {
      {
#line 553
      tmp___1 = floor(0.5 * offset);
#line 553
      tmp___0 = offset - (double )2 * tmp___1;
      }
#line 554
      if (tmp___0 > (double )1) {
#line 554
        actual_offset = (double )2 - tmp___0;
      } else {
#line 554
        actual_offset = tmp___0;
      }
    }
    {
#line 556
    art_render_gradient_setpix___0(render, bufp, n_stops, stops, actual_offset);
#line 557
    offset += d_offset;
#line 558
    bufp += pixstride;
#line 543
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_negotiate___0(ArtImageSource *self , ArtRender *render ,
                                                     ArtImageSourceFlags *p_flags ,
                                                     int *p_buf_depth , ArtAlphaType *p_alpha ) 
{ 


  {
#line 567
  if (render->depth == 8) {
#line 567
    if (render->n_chan == 3) {
#line 570
      self->super.render = & art_render_gradient_linear_render_8___0;
#line 571
      *p_flags = (ArtImageSourceFlags )0;
#line 572
      *p_buf_depth = 8;
#line 573
      *p_alpha = (ArtAlphaType )2;
#line 574
      return;
    }
  }
#line 577
  self->super.render = & art_render_gradient_linear_render___0;
#line 578
  *p_flags = (ArtImageSourceFlags )0;
#line 579
  *p_buf_depth = render->depth;
#line 580
  *p_alpha = (ArtAlphaType )2;
#line 581
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_done___0(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 614
  art_free((void *)self);
  }
#line 615
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_render___0(ArtRenderCallback *self , ArtRender *render ,
                                                  art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradRad *z ;
  ArtGradientRadial const   *gradient ;
  int pixstride ;
  int x ;
  int x0 ;
  int width ;
  int n_stops ;
  ArtGradientStop *stops ;
  art_u8 *bufp ;
  double fx ;
  double fy ;
  double dx ;
  double dy ;
  double const   *affine ;
  double aff0 ;
  double aff1 ;
  double a ;
  double arecip ;
  double b ;
  double db ;
  double c ;
  double dc ;
  double ddc ;
  double b_a ;
  double db_a ;
  double rad ;
  double drad ;
  double ddrad ;
  double z___0 ;
  double tmp ;

  {
#line 621
  z = (ArtImageSourceGradRad *)self;
#line 622
  gradient = (ArtGradientRadial const   *)(& z->gradient);
#line 623
  pixstride = (render->n_chan + 1) * (render->depth >> 3);
#line 625
  x0 = render->x0;
#line 626
  width = render->x1 - x0;
#line 627
  n_stops = (int )gradient->n_stops;
#line 628
  stops = (ArtGradientStop *)gradient->stops;
#line 629
  bufp = render->image_buf;
#line 630
  fx = (double )gradient->fx;
#line 631
  fy = (double )gradient->fy;
#line 633
  affine = (double const   *)(gradient->affine);
#line 634
  aff0 = (double )*(affine + 0);
#line 635
  aff1 = (double )*(affine + 1);
#line 636
  a = z->a;
#line 637
  arecip = 1.0 / a;
#line 643
  dx = (((double )x0 * aff0 + (double )((double const   )y * *(affine + 2))) + (double )*(affine + 4)) - fx;
#line 644
  dy = (((double )x0 * aff1 + (double )((double const   )y * *(affine + 3))) + (double )*(affine + 5)) - fy;
#line 645
  b = dx * fx + dy * fy;
#line 646
  db = aff0 * fx + aff1 * fy;
#line 647
  c = dx * dx + dy * dy;
#line 648
  dc = ((((double )2 * aff0) * dx + aff0 * aff0) + ((double )2 * aff1) * dy) + aff1 * aff1;
#line 649
  ddc = ((double )2 * aff0) * aff0 + ((double )2 * aff1) * aff1;
#line 651
  b_a = b * arecip;
#line 652
  db_a = db * arecip;
#line 654
  rad = b_a * b_a + c * arecip;
#line 655
  drad = (((double )2 * b_a) * db_a + db_a * db_a) + dc * arecip;
#line 656
  ddrad = ((double )2 * db_a) * db_a + ddc * arecip;
#line 658
  x = 0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (x < width)) {
#line 658
      goto while_break;
    }
#line 662
    if (rad > (double )0) {
      {
#line 663
      tmp = sqrt(rad);
#line 663
      z___0 = b_a + tmp;
      }
    } else {
#line 665
      z___0 = b_a;
    }
    {
#line 666
    art_render_gradient_setpix___0(render, bufp, n_stops, stops, z___0);
#line 667
    bufp += pixstride;
#line 668
    b_a += db_a;
#line 669
    rad += drad;
#line 670
    drad += ddrad;
#line 658
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_negotiate___0(ArtImageSource *self , ArtRender *render ,
                                                     ArtImageSourceFlags *p_flags ,
                                                     int *p_buf_depth , ArtAlphaType *p_alpha ) 
{ 


  {
#line 679
  self->super.render = & art_render_gradient_radial_render___0;
#line 680
  *p_flags = (ArtImageSourceFlags )0;
#line 681
  *p_buf_depth = render->depth;
#line 682
  *p_alpha = (ArtAlphaType )2;
#line 683
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_done___0(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 40
  art_free((void *)self);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static int art_render_svp_can_drive___0(ArtMaskSource *self , ArtRender *render ) 
{ 


  {
#line 46
  return (10);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback___0(void *callback_data , int y , int start ,
                                        ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int i ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;

  {
#line 58
  z = (ArtMaskSourceSVP *)callback_data;
#line 59
  render = z->render;
#line 60
  n_run = 0;
#line 62
  running_sum = start;
#line 63
  x0 = render->x0;
#line 64
  x1 = render->x1;
#line 66
  run = render->run;
#line 68
  if (n_steps > 0) {
#line 70
    run_x1 = (steps + 0)->x;
#line 71
    if (run_x1 > x0) {
#line 71
      if (running_sum > 33023) {
#line 73
        (run + 0)->x = x0;
#line 74
        (run + 0)->alpha = running_sum;
#line 75
        n_run ++;
      }
    }
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if (! (i < n_steps - 1)) {
#line 78
        goto while_break;
      }
#line 80
      running_sum += (steps + i)->delta;
#line 81
      run_x0 = run_x1;
#line 82
      run_x1 = (steps + (i + 1))->x;
#line 83
      if (run_x1 > run_x0) {
#line 85
        (run + n_run)->x = run_x0;
#line 86
        (run + n_run)->alpha = running_sum;
#line 87
        n_run ++;
      }
#line 78
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    if (x1 > run_x1) {
#line 92
      running_sum += (steps + (n_steps - 1))->delta;
#line 93
      (run + n_run)->x = run_x1;
#line 94
      (run + n_run)->alpha = running_sum;
#line 95
      n_run ++;
    }
#line 97
    if (running_sum > 33023) {
#line 99
      (run + n_run)->x = x1;
#line 100
      (run + n_run)->alpha = 32768;
#line 101
      n_run ++;
    }
  } else
#line 104
  if (running_sum >> 16 > 0) {
#line 106
    (run + 0)->x = x0;
#line 107
    (run + 0)->alpha = running_sum;
#line 108
    (run + 1)->x = x1;
#line 109
    (run + 1)->alpha = running_sum;
#line 110
    n_run = 2;
  }
  {
#line 113
  render->n_run = n_run;
#line 115
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 117
  z->dest_ptr += render->rowstride;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_span___0(void *callback_data , int y , int start ,
                                             ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int n_span ;
  int i ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  int *span_x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 124
  z = (ArtMaskSourceSVP *)callback_data;
#line 125
  render = z->render;
#line 126
  n_run = 0;
#line 127
  n_span = 0;
#line 129
  running_sum = start;
#line 130
  x0 = render->x0;
#line 131
  x1 = render->x1;
#line 133
  run = render->run;
#line 134
  span_x = render->span_x;
#line 136
  if (n_steps > 0) {
#line 138
    run_x1 = (steps + 0)->x;
#line 139
    if (run_x1 > x0) {
#line 139
      if (running_sum > 33023) {
#line 141
        (run + 0)->x = x0;
#line 142
        (run + 0)->alpha = running_sum;
#line 143
        n_run ++;
#line 144
        *(span_x + 0) = x0;
#line 145
        n_span ++;
      }
    }
#line 148
    i = 0;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! (i < n_steps - 1)) {
#line 148
        goto while_break;
      }
#line 150
      running_sum += (steps + i)->delta;
#line 151
      run_x0 = run_x1;
#line 152
      run_x1 = (steps + (i + 1))->x;
#line 153
      if (run_x1 > run_x0) {
#line 155
        (run + n_run)->x = run_x0;
#line 156
        (run + n_run)->alpha = running_sum;
#line 157
        n_run ++;
#line 158
        if ((n_span & 1) != (running_sum > 33023)) {
#line 159
          tmp = n_span;
#line 159
          n_span ++;
#line 159
          *(span_x + tmp) = run_x0;
        }
      }
#line 148
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 162
    if (x1 > run_x1) {
#line 164
      running_sum += (steps + (n_steps - 1))->delta;
#line 165
      (run + n_run)->x = run_x1;
#line 166
      (run + n_run)->alpha = running_sum;
#line 167
      n_run ++;
#line 168
      if ((n_span & 1) != (running_sum > 33023)) {
#line 169
        tmp___0 = n_span;
#line 169
        n_span ++;
#line 169
        *(span_x + tmp___0) = run_x1;
      }
    }
#line 171
    if (running_sum > 33023) {
#line 173
      (run + n_run)->x = x1;
#line 174
      (run + n_run)->alpha = 32768;
#line 175
      n_run ++;
#line 176
      tmp___1 = n_span;
#line 176
      n_span ++;
#line 176
      *(span_x + tmp___1) = x1;
    }
  } else
#line 179
  if (running_sum >> 16 > 0) {
#line 181
    (run + 0)->x = x0;
#line 182
    (run + 0)->alpha = running_sum;
#line 183
    (run + 1)->x = x1;
#line 184
    (run + 1)->alpha = running_sum;
#line 185
    n_run = 2;
#line 186
    *(span_x + 0) = x0;
#line 187
    *(span_x + 1) = x1;
#line 188
    n_span = 2;
  }
  {
#line 191
  render->n_run = n_run;
#line 192
  render->n_span = n_span;
#line 194
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 196
  z->dest_ptr += render->rowstride;
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_opacity___0(void *callback_data , int y , int start ,
                                                ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int i ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  art_u32 opacity ;
  art_u32 alpha ;

  {
#line 203
  z = (ArtMaskSourceSVP *)callback_data;
#line 204
  render = z->render;
#line 205
  n_run = 0;
#line 208
  x0 = render->x0;
#line 209
  x1 = render->x1;
#line 211
  run = render->run;
#line 212
  opacity = render->opacity;
#line 215
  running_sum = (art_u32 )(start - 32640);
#line 217
  if (n_steps > 0) {
#line 219
    run_x1 = (steps + 0)->x;
#line 220
    alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 221
    if (run_x1 > x0) {
#line 221
      if (alpha > 33023U) {
#line 223
        (run + 0)->x = x0;
#line 224
        (run + 0)->alpha = (int )alpha;
#line 225
        n_run ++;
      }
    }
#line 228
    i = 0;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n_steps - 1)) {
#line 228
        goto while_break;
      }
#line 230
      running_sum += (art_u32 )(steps + i)->delta;
#line 231
      run_x0 = run_x1;
#line 232
      run_x1 = (steps + (i + 1))->x;
#line 233
      if (run_x1 > run_x0) {
#line 235
        (run + n_run)->x = run_x0;
#line 236
        alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 237
        (run + n_run)->alpha = (int )alpha;
#line 238
        n_run ++;
      }
#line 228
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 241
    if (x1 > run_x1) {
#line 243
      running_sum += (art_u32 )(steps + (n_steps - 1))->delta;
#line 244
      (run + n_run)->x = run_x1;
#line 245
      alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 246
      (run + n_run)->alpha = (int )alpha;
#line 247
      n_run ++;
    }
#line 249
    if (alpha > 33023U) {
#line 251
      (run + n_run)->x = x1;
#line 252
      (run + n_run)->alpha = 32768;
#line 253
      n_run ++;
    }
  } else
#line 256
  if (running_sum >> 16 > 0U) {
#line 258
    (run + 0)->x = x0;
#line 259
    (run + 0)->alpha = (int )running_sum;
#line 260
    (run + 1)->x = x1;
#line 261
    (run + 1)->alpha = (int )running_sum;
#line 262
    n_run = 2;
  }
  {
#line 265
  render->n_run = n_run;
#line 267
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 269
  z->dest_ptr += render->rowstride;
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_opacity_span___0(void *callback_data , int y ,
                                                     int start , ArtSVPRenderAAStep *steps ,
                                                     int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int n_span ;
  int i ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  int *span_x ;
  art_u32 opacity ;
  art_u32 alpha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  z = (ArtMaskSourceSVP *)callback_data;
#line 277
  render = z->render;
#line 278
  n_run = 0;
#line 279
  n_span = 0;
#line 282
  x0 = render->x0;
#line 283
  x1 = render->x1;
#line 285
  run = render->run;
#line 286
  span_x = render->span_x;
#line 287
  opacity = render->opacity;
#line 290
  running_sum = (art_u32 )(start - 32640);
#line 292
  if (n_steps > 0) {
#line 294
    run_x1 = (steps + 0)->x;
#line 295
    alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 296
    if (run_x1 > x0) {
#line 296
      if (alpha > 33023U) {
#line 298
        (run + 0)->x = x0;
#line 299
        (run + 0)->alpha = (int )alpha;
#line 300
        n_run ++;
#line 301
        *(span_x + 0) = x0;
#line 302
        n_span ++;
      }
    }
#line 305
    i = 0;
    {
#line 305
    while (1) {
      while_continue: /* CIL Label */ ;
#line 305
      if (! (i < n_steps - 1)) {
#line 305
        goto while_break;
      }
#line 307
      running_sum += (art_u32 )(steps + i)->delta;
#line 308
      run_x0 = run_x1;
#line 309
      run_x1 = (steps + (i + 1))->x;
#line 310
      if (run_x1 > run_x0) {
#line 312
        (run + n_run)->x = run_x0;
#line 313
        alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 314
        (run + n_run)->alpha = (int )alpha;
#line 315
        n_run ++;
#line 316
        if ((n_span & 1) != (alpha > 33023U)) {
#line 317
          tmp = n_span;
#line 317
          n_span ++;
#line 317
          *(span_x + tmp) = run_x0;
        }
      }
#line 305
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 320
    if (x1 > run_x1) {
#line 322
      running_sum += (art_u32 )(steps + (n_steps - 1))->delta;
#line 323
      (run + n_run)->x = run_x1;
#line 324
      alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 325
      (run + n_run)->alpha = (int )alpha;
#line 326
      n_run ++;
#line 327
      if ((n_span & 1) != (alpha > 33023U)) {
#line 328
        tmp___0 = n_span;
#line 328
        n_span ++;
#line 328
        *(span_x + tmp___0) = run_x1;
      }
    }
#line 330
    if (alpha > 33023U) {
#line 332
      (run + n_run)->x = x1;
#line 333
      (run + n_run)->alpha = 32768;
#line 334
      n_run ++;
#line 335
      tmp___1 = n_span;
#line 335
      n_span ++;
#line 335
      *(span_x + tmp___1) = x1;
    }
  } else
#line 338
  if (running_sum >> 16 > 0U) {
#line 340
    (run + 0)->x = x0;
#line 341
    (run + 0)->alpha = (int )running_sum;
#line 342
    (run + 1)->x = x1;
#line 343
    (run + 1)->alpha = (int )running_sum;
#line 344
    n_run = 2;
#line 345
    *(span_x + 0) = x0;
#line 346
    *(span_x + 1) = x1;
#line 347
    n_span = 2;
  }
  {
#line 350
  render->n_run = n_run;
#line 351
  render->n_span = n_span;
#line 353
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 355
  z->dest_ptr += render->rowstride;
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_invoke_driver___0(ArtMaskSource *self , ArtRender *render ) 
{ 
  ArtMaskSourceSVP *z ;
  void (*callback)(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                   int n_steps ) ;

  {
#line 361
  z = (ArtMaskSourceSVP *)self;
#line 367
  z->dest_ptr = render->pixels;
#line 368
  if (render->opacity == 65536U) {
#line 370
    if (render->need_span) {
#line 371
      callback = & art_render_svp_callback_span___0;
    } else {
#line 373
      callback = & art_render_svp_callback___0;
    }
  } else
#line 377
  if (render->need_span) {
#line 378
    callback = & art_render_svp_callback_opacity_span___0;
  } else {
#line 380
    callback = & art_render_svp_callback_opacity___0;
  }
  {
#line 383
  art_svp_render_aa(z->svp, render->x0, render->y0, render->x1, render->y1, callback,
                    (void *)self);
#line 387
  art_render_svp_done___0(& self->super, render);
  }
#line 388
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_prepare___0(ArtMaskSource *self , ArtRender *render , art_boolean first ) 
{ 


  {
  {
#line 395
  art_die("art_render_svp non-driver mode not yet implemented.\n");
  }
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int intersect_lines___0(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ,
                               ArtPoint *p ) 
{ 
  double a01 ;
  double b01 ;
  double c01 ;
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double det ;

  {
#line 55
  if (z0.x == z2.x) {
#line 55
    if (z0.y == z2.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 55
  if (z0.x == z3.x) {
#line 55
    if (z0.y == z3.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 55
  if (z1.x == z2.x) {
#line 55
    if (z1.y == z2.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 55
  if (z1.x == z3.x) {
#line 55
    if (z1.y == z3.y) {
#line 56
      return (0);
    }
  }
#line 64
  a01 = z0.y - z1.y;
#line 65
  b01 = z1.x - z0.x;
#line 66
  c01 = - (z0.x * a01 + z0.y * b01);
#line 70
  d2 = (a01 * z2.x + b01 * z2.y) + c01;
#line 71
  d3 = (a01 * z3.x + b01 * z3.y) + c01;
#line 72
  if ((d2 > (double )0) == (d3 > (double )0)) {
#line 73
    return (0);
  }
#line 75
  a23 = z2.y - z3.y;
#line 76
  b23 = z3.x - z2.x;
#line 77
  c23 = - (z2.x * a23 + z2.y * b23);
#line 79
  d0 = (a23 * z0.x + b23 * z0.y) + c23;
#line 80
  d1 = (a23 * z1.x + b23 * z1.y) + c23;
#line 81
  if ((d0 > (double )0) == (d1 > (double )0)) {
#line 82
    return (0);
  }
#line 86
  det = 1.0 / (a01 * b23 - a23 * b01);
#line 87
  p->x = det * (c23 * b01 - c01 * b23);
#line 88
  p->y = det * (c01 * a23 - c23 * a01);
#line 90
  return (1);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static double trap_epsilon___0(double v ) 
{ 
  double epsilon ;

  {
#line 98
  epsilon = 1e-6;
#line 100
  if (v < epsilon) {
#line 100
    if (v > - epsilon) {
#line 100
      return ((double )0);
    } else {
#line 101
      return (v);
    }
  } else {
#line 101
    return (v);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int x_order___0(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ) 
{ 
  double a01 ;
  double b01 ;
  double c01 ;
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double x01min ;
  double x01max ;
  double x23min ;
  double x23max ;

  {
#line 132
  if (z0.y == z1.y) {
#line 134
    if (z2.y == z3.y) {
#line 139
      if (z0.x > z1.x) {
#line 141
        x01min = z1.x;
#line 142
        x01max = z0.x;
      } else {
#line 146
        x01min = z0.x;
#line 147
        x01max = z1.x;
      }
#line 150
      if (z2.x > z3.x) {
#line 152
        x23min = z3.x;
#line 153
        x23max = z2.x;
      } else {
#line 157
        x23min = z2.x;
#line 158
        x23max = z3.x;
      }
#line 161
      if (x23min >= x01max) {
#line 161
        return (1);
      } else
#line 162
      if (x01min >= x23max) {
#line 162
        return (-1);
      } else {
#line 163
        return (0);
      }
    } else {
#line 168
      a23 = z2.y - z3.y;
#line 169
      b23 = z3.x - z2.x;
#line 170
      c23 = - (z2.x * a23 + z2.y * b23);
#line 172
      if (z3.y < z2.y) {
#line 174
        a23 = - a23;
#line 175
        b23 = - b23;
#line 176
        c23 = - c23;
      }
      {
#line 179
      d0 = trap_epsilon___0((a23 * z0.x + b23 * z0.y) + c23);
#line 180
      d1 = trap_epsilon___0((a23 * z1.x + b23 * z1.y) + c23);
      }
#line 182
      if (d0 > (double )0) {
#line 184
        if (d1 >= (double )0) {
#line 184
          return (1);
        } else {
#line 185
          return (0);
        }
      } else
#line 187
      if (d0 == (double )0) {
#line 189
        if (d1 > (double )0) {
#line 189
          return (1);
        } else
#line 190
        if (d1 < (double )0) {
#line 190
          return (-1);
        } else {
          {
#line 191
          printf((char const   */* __restrict  */)"case 1 degenerate\n");
          }
        }
#line 192
        return (0);
      } else
#line 196
      if (d1 <= (double )0) {
#line 196
        return (-1);
      } else {
#line 197
        return (0);
      }
    }
  } else
#line 201
  if (z2.y == z3.y) {
#line 204
    a01 = z0.y - z1.y;
#line 205
    b01 = z1.x - z0.x;
#line 206
    c01 = - (z0.x * a01 + z0.y * b01);
#line 210
    if (z1.y < z0.y) {
#line 212
      a01 = - a01;
#line 213
      b01 = - b01;
#line 214
      c01 = - c01;
    }
    {
#line 217
    d2 = trap_epsilon___0((a01 * z2.x + b01 * z2.y) + c01);
#line 218
    d3 = trap_epsilon___0((a01 * z3.x + b01 * z3.y) + c01);
    }
#line 220
    if (d2 > (double )0) {
#line 222
      if (d3 >= (double )0) {
#line 222
        return (-1);
      } else {
#line 223
        return (0);
      }
    } else
#line 225
    if (d2 == (double )0) {
#line 227
      if (d3 > (double )0) {
#line 227
        return (-1);
      } else
#line 228
      if (d3 < (double )0) {
#line 228
        return (1);
      } else {
        {
#line 229
        printf((char const   */* __restrict  */)"case 2 degenerate\n");
        }
      }
#line 230
      return (0);
    } else
#line 234
    if (d3 <= (double )0) {
#line 234
      return (1);
    } else {
#line 235
      return (0);
    }
  }
#line 240
  a01 = z0.y - z1.y;
#line 241
  b01 = z1.x - z0.x;
#line 242
  c01 = - (z0.x * a01 + z0.y * b01);
#line 246
  if (a01 > (double )0) {
#line 248
    a01 = - a01;
#line 249
    b01 = - b01;
#line 250
    c01 = - c01;
  }
  {
#line 255
  d2 = trap_epsilon___0((a01 * z2.x + b01 * z2.y) + c01);
#line 256
  d3 = trap_epsilon___0((a01 * z3.x + b01 * z3.y) + c01);
  }
#line 257
  if (d2 > (double )0) {
#line 259
    if (d3 >= (double )0) {
#line 259
      return (-1);
    }
  } else
#line 261
  if (d2 == (double )0) {
#line 263
    if (d3 > (double )0) {
#line 263
      return (-1);
    } else
#line 264
    if (d3 < (double )0) {
#line 264
      return (1);
    } else {
      {
#line 266
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colinear!\n");
      }
    }
  } else
#line 270
  if (d3 <= (double )0) {
#line 270
    return (1);
  }
#line 273
  a23 = z2.y - z3.y;
#line 274
  b23 = z3.x - z2.x;
#line 275
  c23 = - (z2.x * a23 + z2.y * b23);
#line 277
  if (a23 > (double )0) {
#line 279
    a23 = - a23;
#line 280
    b23 = - b23;
#line 281
    c23 = - c23;
  }
  {
#line 283
  d0 = trap_epsilon___0((a23 * z0.x + b23 * z0.y) + c23);
#line 284
  d1 = trap_epsilon___0((a23 * z1.x + b23 * z1.y) + c23);
  }
#line 285
  if (d0 > (double )0) {
#line 287
    if (d1 >= (double )0) {
#line 287
      return (1);
    }
  } else
#line 289
  if (d0 == (double )0) {
#line 291
    if (d1 > (double )0) {
#line 291
      return (1);
    } else
#line 292
    if (d1 < (double )0) {
#line 292
      return (-1);
    } else {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colinear!\n");
      }
    }
  } else
#line 298
  if (d1 <= (double )0) {
#line 298
    return (-1);
  }
#line 301
  return (0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int x_order_2___0(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ) 
{ 
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;

  {
#line 312
  a23 = z2.y - z3.y;
#line 313
  b23 = z3.x - z2.x;
#line 314
  c23 = - (z2.x * a23 + z2.y * b23);
#line 316
  if (a23 > (double )0) {
#line 318
    a23 = - a23;
#line 319
    b23 = - b23;
#line 320
    c23 = - c23;
  }
#line 323
  d0 = (a23 * z0.x + b23 * z0.y) + c23;
#line 325
  if (d0 > 1e-6) {
#line 326
    return (-1);
  } else
#line 327
  if (d0 < - 1e-6) {
#line 328
    return (1);
  }
#line 330
  d1 = (a23 * z1.x + b23 * z1.y) + c23;
#line 331
  if (d1 > 1e-6) {
#line 332
    return (-1);
  } else
#line 333
  if (d1 < - 1e-6) {
#line 334
    return (1);
  }
#line 336
  if (z0.x == z1.x) {
#line 336
    if (z1.x == z2.x) {
#line 336
      if (z2.x == z3.x) {
        {
#line 338
        art_dprint("x_order_2: colinear and horizontally aligned!\n");
        }
#line 339
        return (0);
      }
    }
  }
#line 342
  if (z0.x <= z2.x) {
#line 342
    if (z1.x <= z2.x) {
#line 342
      if (z0.x <= z3.x) {
#line 342
        if (z1.x <= z3.x) {
#line 343
          return (-1);
        }
      }
    }
  }
#line 344
  if (z0.x >= z2.x) {
#line 344
    if (z1.x >= z2.x) {
#line 344
      if (z0.x >= z3.x) {
#line 344
        if (z1.x >= z3.x) {
#line 345
          return (1);
        }
      }
    }
  }
  {
#line 347
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x_order_2: colinear!\n");
  }
#line 348
  return (0);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void insert_ip___0(int seg_i , int *n_ips , int *n_ips_max , ArtPoint **ips ,
                          ArtPoint ip ) 
{ 
  int i ;
  ArtPoint tmp1 ;
  ArtPoint tmp2 ;
  int n_ipl ;
  ArtPoint *ipl ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 488
  tmp = *(n_ips + seg_i);
#line 488
  (*(n_ips + seg_i)) ++;
#line 488
  n_ipl = tmp;
#line 489
  if (n_ipl == *(n_ips_max + seg_i)) {
    {
#line 490
    while (1) {
      while_continue: /* CIL Label */ ;
#line 490
      if (*(n_ips_max + seg_i)) {
        {
#line 490
        tmp___0 = *(n_ips_max + seg_i) << 1;
#line 490
        *(n_ips_max + seg_i) = tmp___0;
#line 490
        tmp___1 = art_realloc((void *)*(ips + seg_i), (unsigned long )tmp___0 * sizeof(ArtPoint ));
#line 490
        *(ips + seg_i) = (ArtPoint *)tmp___1;
        }
      } else {
        {
#line 490
        *(n_ips_max + seg_i) = 1;
#line 490
        tmp___2 = art_alloc(sizeof(ArtPoint ));
#line 490
        *(ips + seg_i) = (ArtPoint *)tmp___2;
        }
      }
#line 490
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 491
  ipl = *(ips + seg_i);
#line 492
  i = 1;
  {
#line 492
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 492
    if (! (i < n_ipl)) {
#line 492
      goto while_break___0;
    }
#line 493
    if ((ipl + i)->y > ip.y) {
#line 494
      goto while_break___0;
    }
#line 492
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 495
  tmp1 = ip;
  {
#line 496
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 496
    if (! (i <= n_ipl)) {
#line 496
      goto while_break___1;
    }
#line 498
    tmp2 = *(ipl + i);
#line 499
    *(ipl + i) = tmp1;
#line 500
    tmp1 = tmp2;
#line 496
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 502
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void intersect_neighbors___0(int i , int *active_segs , int *n_ips , int *n_ips_max ,
                                    ArtPoint **ips , int *cursor , ArtSVP *vp ) 
{ 
  ArtPoint z0 ;
  ArtPoint z1 ;
  ArtPoint z2 ;
  ArtPoint z3 ;
  int asi01 ;
  int asi23 ;
  ArtPoint ip ;
  int tmp ;

  {
#line 515
  asi01 = *(active_segs + (i - 1));
#line 517
  z0 = *(*(ips + asi01) + 0);
#line 518
  if (*(n_ips + asi01) == 1) {
#line 519
    z1 = *(vp->segs[asi01].points + (*(cursor + asi01) + 1));
  } else {
#line 521
    z1 = *(*(ips + asi01) + 1);
  }
#line 523
  asi23 = *(active_segs + i);
#line 525
  z2 = *(*(ips + asi23) + 0);
#line 526
  if (*(n_ips + asi23) == 1) {
#line 527
    z3 = *(vp->segs[asi23].points + (*(cursor + asi23) + 1));
  } else {
#line 529
    z3 = *(*(ips + asi23) + 1);
  }
  {
#line 531
  tmp = intersect_lines___0(z0, z1, z2, z3, & ip);
  }
#line 531
  if (tmp) {
    {
#line 536
    insert_ip___0(asi01, n_ips, n_ips_max, ips, ip);
#line 537
    insert_ip___0(asi23, n_ips, n_ips_max, ips, ip);
    }
  }
#line 539
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void svp_add_point___0(ArtSVP *svp , int *n_points_max , ArtPoint p , int *seg_map ,
                              int *active_segs , int n_active_segs , int i ) 
{ 
  int asi ;
  int asi_left ;
  int asi_right ;
  int n_points ;
  int n_points_left ;
  int n_points_right ;
  ArtSVPSeg *seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 556
  asi = *(seg_map + *(active_segs + i));
#line 557
  seg = & svp->segs[asi];
#line 558
  n_points = seg->n_points;
#line 560
  if (i > 0) {
#line 562
    asi_left = *(seg_map + *(active_segs + (i - 1)));
#line 563
    n_points_left = svp->segs[asi_left].n_points;
#line 564
    if (n_points_left > 1) {
#line 564
      if ((svp->segs[asi_left].points + (n_points_left - 2))->x == (svp->segs[asi].points + (n_points - 1))->x) {
#line 564
        if ((svp->segs[asi_left].points + (n_points_left - 2))->y == (svp->segs[asi].points + (n_points - 1))->y) {
          {
#line 570
          tmp = x_order___0(*(svp->segs[asi_left].points + (n_points_left - 2)), *(svp->segs[asi_left].points + (n_points_left - 1)),
                            *(svp->segs[asi].points + (n_points - 1)), p);
          }
        }
      }
    }
  }
#line 583
  if (i + 1 < n_active_segs) {
#line 585
    asi_right = *(seg_map + *(active_segs + (i + 1)));
#line 586
    n_points_right = svp->segs[asi_right].n_points;
#line 587
    if (n_points_right > 1) {
#line 587
      if ((svp->segs[asi_right].points + (n_points_right - 2))->x == (svp->segs[asi].points + (n_points - 1))->x) {
#line 587
        if ((svp->segs[asi_right].points + (n_points_right - 2))->y == (svp->segs[asi].points + (n_points - 1))->y) {
          {
#line 593
          tmp___0 = x_order___0(*(svp->segs[asi_right].points + (n_points_right - 2)),
                                *(svp->segs[asi_right].points + (n_points_right - 1)),
                                *(svp->segs[asi].points + (n_points - 1)), p);
          }
        }
      }
    }
  }
#line 604
  if (*(n_points_max + asi) == n_points) {
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      if (*(n_points_max + asi)) {
        {
#line 605
        tmp___1 = *(n_points_max + asi) << 1;
#line 605
        *(n_points_max + asi) = tmp___1;
#line 605
        tmp___2 = art_realloc((void *)seg->points, (unsigned long )tmp___1 * sizeof(ArtPoint ));
#line 605
        seg->points = (ArtPoint *)tmp___2;
        }
      } else {
        {
#line 605
        *(n_points_max + asi) = 1;
#line 605
        tmp___3 = art_alloc(sizeof(ArtPoint ));
#line 605
        seg->points = (ArtPoint *)tmp___3;
        }
      }
#line 605
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 606
  *(seg->points + n_points) = p;
#line 607
  if (p.x < seg->bbox.x0) {
#line 608
    seg->bbox.x0 = p.x;
  } else
#line 609
  if (p.x > seg->bbox.x1) {
#line 610
    seg->bbox.x1 = p.x;
  }
#line 611
  seg->bbox.y1 = p.y;
#line 612
  (seg->n_points) ++;
#line 613
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void fix_crossing___0(int start , int end , int *active_segs , int n_active_segs ,
                             int *cursor , ArtPoint **ips , int *n_ips , int *n_ips_max ,
                             ArtSVP *vp , int *seg_map , ArtSVP **p_new_vp , int *pn_segs_max ,
                             int **pn_points_max ) 
{ 
  int i ;
  int j ;
  int target ;
  int asi ;
  int asj ;
  ArtPoint p0i ;
  ArtPoint p1i ;
  ArtPoint p0j ;
  ArtPoint p1j ;
  int swap ;
  ArtPoint *pts ;
  int tmp ;
  int seg_num ;
  void *tmp___0 ;
  int as_start ;
  int as_end ;

  {
#line 719
  swap = 0;
#line 732
  if (start == -1) {
#line 733
    return;
  }
#line 735
  i = start + 1;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! (i < end)) {
#line 735
      goto while_break;
    }
#line 738
    asi = *(active_segs + i);
#line 739
    if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 740
      p0i = *(*(ips + asi) + 0);
#line 741
      if (*(n_ips + asi) == 1) {
#line 742
        p1i = *(vp->segs[asi].points + (*(cursor + asi) + 1));
      } else {
#line 744
        p1i = *(*(ips + asi) + 1);
      }
#line 746
      j = i - 1;
      {
#line 746
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 746
        if (! (j >= start)) {
#line 746
          goto while_break___0;
        }
#line 748
        asj = *(active_segs + j);
#line 749
        if (*(cursor + asj) < vp->segs[asj].n_points - 1) {
#line 751
          p0j = *(*(ips + asj) + 0);
#line 752
          if (*(n_ips + asj) == 1) {
#line 753
            p1j = *(vp->segs[asj].points + (*(cursor + asj) + 1));
          } else {
#line 755
            p1j = *(*(ips + asj) + 1);
          }
          {
#line 758
          tmp = x_order_2___0(p0j, p1j, p0i, p1i);
          }
#line 758
          if (tmp == -1) {
#line 759
            goto while_break___0;
          }
        }
#line 746
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 763
      target = j + 1;
#line 766
      if (target != i) {
#line 768
        swap = 1;
#line 775
        j = i;
        {
#line 775
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 775
          if (! (j >= target)) {
#line 775
            goto while_break___1;
          }
#line 777
          asi = *(active_segs + j);
#line 784
          if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 784
            if ((*p_new_vp)->segs[*(seg_map + asi)].n_points != 1) {
              {
#line 793
              tmp___0 = art_alloc(16UL * sizeof(ArtPoint ));
#line 793
              pts = (ArtPoint *)tmp___0;
#line 794
              *(pts + 0) = *(*(ips + asi) + 0);
#line 795
              seg_num = art_svp_add_segment(p_new_vp, pn_segs_max, pn_points_max,
                                            1, vp->segs[asi].dir, pts, (ArtDRect *)((void *)0));
#line 800
              *(*pn_points_max + seg_num) = 16;
#line 801
              *(seg_map + asi) = seg_num;
              }
            }
          }
#line 775
          j --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 806
        asi = *(active_segs + i);
#line 807
        j = i;
        {
#line 807
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 807
          if (! (j > target)) {
#line 807
            goto while_break___2;
          }
#line 808
          *(active_segs + j) = *(active_segs + (j - 1));
#line 807
          j --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 809
        *(active_segs + j) = asi;
      }
    }
#line 735
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 813
  if (swap) {
#line 813
    if (start > 0) {
#line 817
      as_start = *(active_segs + start);
#line 818
      if (*(cursor + as_start) < vp->segs[as_start].n_points) {
        {
#line 823
        intersect_neighbors___0(start, active_segs, n_ips, n_ips_max, ips, cursor,
                                vp);
        }
      }
    }
  }
#line 829
  if (swap) {
#line 829
    if (end < n_active_segs) {
#line 833
      as_end = *(active_segs + (end - 1));
#line 834
      if (*(cursor + as_end) < vp->segs[as_end].n_points) {
        {
#line 839
        intersect_neighbors___0(end, active_segs, n_ips, n_ips_max, ips, cursor, vp);
        }
      }
    }
  }
#line 853
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtPriQ *art_pri_new___0(void) 
{ 
  ArtPriQ *result ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 65
  tmp = art_alloc(sizeof(ArtPriQ ));
#line 65
  result = (ArtPriQ *)tmp;
#line 67
  result->n_items = 0;
#line 68
  result->n_items_max = 16;
#line 69
  tmp___0 = art_alloc((unsigned long )result->n_items_max * sizeof(ArtPriPoint *));
#line 69
  result->items = (ArtPriPoint **)tmp___0;
  }
#line 70
  return (result);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_free___0(ArtPriQ *pq ) 
{ 


  {
  {
#line 76
  art_free((void *)pq->items);
#line 77
  art_free((void *)pq);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static art_boolean art_pri_empty___0(ArtPriQ *pq ) 
{ 


  {
#line 83
  return (pq->n_items == 0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_bubble_up___0(ArtPriQ *pq , int vacant , ArtPriPoint *missing ) 
{ 
  ArtPriPoint **items ;
  int parent ;

  {
#line 94
  items = pq->items;
#line 97
  parent = (vacant - 1) >> 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (vacant > 0) {
#line 98
      if (! (missing->y < (*(items + parent))->y)) {
#line 98
        if (missing->y == (*(items + parent))->y) {
#line 98
          if (! (missing->x < (*(items + parent))->x)) {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
      }
    } else {
#line 98
      goto while_break;
    }
#line 102
    *(items + vacant) = *(items + parent);
#line 103
    vacant = parent;
#line 104
    parent = (vacant - 1) >> 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  *(items + vacant) = missing;
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_insert___0(ArtPriQ *pq , ArtPriPoint *point ) 
{ 
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 113
  if (pq->n_items == pq->n_items_max) {
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (pq->n_items_max) {
        {
#line 114
        tmp = pq->n_items_max << 1;
#line 114
        pq->n_items_max = tmp;
#line 114
        tmp___0 = art_realloc((void *)pq->items, (unsigned long )tmp * sizeof(ArtPriPoint *));
#line 114
        pq->items = (ArtPriPoint **)tmp___0;
        }
      } else {
        {
#line 114
        pq->n_items_max = 1;
#line 114
        tmp___1 = art_alloc(sizeof(ArtPriPoint *));
#line 114
        pq->items = (ArtPriPoint **)tmp___1;
        }
      }
#line 114
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 116
  tmp___2 = pq->n_items;
#line 116
  (pq->n_items) ++;
#line 116
  art_pri_bubble_up___0(pq, tmp___2, point);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_sift_down_from_root___0(ArtPriQ *pq , ArtPriPoint *missing ) 
{ 
  ArtPriPoint **items ;
  int vacant ;
  int child ;
  int n ;

  {
#line 122
  items = pq->items;
#line 123
  vacant = 0;
#line 123
  child = 2;
#line 124
  n = pq->n_items;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (child < n)) {
#line 126
      goto while_break;
    }
#line 128
    if ((*(items + (child - 1)))->y < (*(items + child))->y) {
#line 131
      child --;
    } else
#line 128
    if ((*(items + (child - 1)))->y == (*(items + child))->y) {
#line 128
      if ((*(items + (child - 1)))->x < (*(items + child))->x) {
#line 131
        child --;
      }
    }
#line 132
    *(items + vacant) = *(items + child);
#line 133
    vacant = child;
#line 134
    child = (vacant + 1) << 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (child == n) {
#line 138
    *(items + vacant) = *(items + (n - 1));
#line 139
    vacant = n - 1;
  }
  {
#line 142
  art_pri_bubble_up___0(pq, vacant, missing);
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtPriPoint *art_pri_choose___0(ArtPriQ *pq ) 
{ 
  ArtPriPoint *result ;

  {
  {
#line 148
  result = *(pq->items + 0);
#line 150
  (pq->n_items) --;
#line 150
  art_pri_sift_down_from_root___0(pq, *(pq->items + pq->n_items));
  }
#line 151
  return (result);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static int art_svp_writer_rewind_add_segment___0(ArtSvpWriter *self , int wind_left ,
                                                 int delta_wind , double x , double y ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVP *svp ;
  ArtSVPSeg *seg ;
  art_boolean left_filled ;
  art_boolean right_filled ;
  int wind_right ;
  int seg_num ;
  int init_n_points_max ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 318
  swr = (ArtSvpWriterRewind *)self;
#line 322
  wind_right = wind_left + delta_wind;
#line 324
  init_n_points_max = 4;
  {
#line 328
  if ((unsigned int )swr->rule == 0U) {
#line 328
    goto case_0;
  }
#line 332
  if ((unsigned int )swr->rule == 1U) {
#line 332
    goto case_1;
  }
#line 336
  if ((unsigned int )swr->rule == 2U) {
#line 336
    goto case_2;
  }
#line 340
  if ((unsigned int )swr->rule == 3U) {
#line 340
    goto case_3;
  }
#line 344
  goto switch_default;
  case_0: /* CIL Label */ 
#line 329
  left_filled = wind_left != 0;
#line 330
  right_filled = wind_right != 0;
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 333
  left_filled = wind_left > 1;
#line 334
  right_filled = wind_right > 1;
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
#line 337
  left_filled = wind_left & 1;
#line 338
  right_filled = wind_right & 1;
#line 339
  goto switch_break;
  case_3: /* CIL Label */ 
#line 341
  left_filled = wind_left > 0;
#line 342
  right_filled = wind_right > 0;
#line 343
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 345
  art_die("Unknown wind rule %d\n", (unsigned int )swr->rule);
  }
  switch_break: /* CIL Label */ ;
  }
#line 347
  if (left_filled == right_filled) {
#line 354
    return (-1);
  }
#line 357
  svp = swr->svp;
#line 358
  tmp = svp->n_segs;
#line 358
  (svp->n_segs) ++;
#line 358
  seg_num = tmp;
#line 359
  if (swr->n_segs_max == seg_num) {
    {
#line 361
    swr->n_segs_max <<= 1;
#line 362
    tmp___0 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(swr->n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 362
    svp = (ArtSVP *)tmp___0;
#line 365
    swr->svp = svp;
#line 366
    tmp___1 = art_realloc((void *)swr->n_points_max, (unsigned long )swr->n_segs_max * sizeof(int ));
#line 366
    swr->n_points_max = (int *)tmp___1;
    }
  }
  {
#line 369
  seg = & svp->segs[seg_num];
#line 370
  seg->n_points = 1;
#line 371
  seg->dir = right_filled;
#line 372
  *(swr->n_points_max + seg_num) = init_n_points_max;
#line 373
  seg->bbox.x0 = x;
#line 374
  seg->bbox.y0 = y;
#line 375
  seg->bbox.x1 = x;
#line 376
  seg->bbox.y1 = y;
#line 377
  tmp___2 = art_alloc((unsigned long )init_n_points_max * sizeof(ArtPoint ));
#line 377
  seg->points = (ArtPoint *)tmp___2;
#line 378
  (seg->points + 0)->x = x;
#line 379
  (seg->points + 0)->y = y;
  }
#line 385
  return (seg_num);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_writer_rewind_add_point___0(ArtSvpWriter *self , int seg_id ,
                                                double x , double y ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVPSeg *seg ;
  int n_points ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 392
  swr = (ArtSvpWriterRewind *)self;
#line 399
  if (seg_id < 0) {
#line 401
    return;
  }
#line 403
  seg = & (swr->svp)->segs[seg_id];
#line 404
  tmp = seg->n_points;
#line 404
  (seg->n_points) ++;
#line 404
  n_points = tmp;
#line 405
  if (*(swr->n_points_max + seg_id) == n_points) {
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
#line 406
      if (*(swr->n_points_max + seg_id)) {
        {
#line 406
        tmp___0 = *(swr->n_points_max + seg_id) << 1;
#line 406
        *(swr->n_points_max + seg_id) = tmp___0;
#line 406
        tmp___1 = art_realloc((void *)seg->points, (unsigned long )tmp___0 * sizeof(ArtPoint ));
#line 406
        seg->points = (ArtPoint *)tmp___1;
        }
      } else {
        {
#line 406
        *(swr->n_points_max + seg_id) = 1;
#line 406
        tmp___2 = art_alloc(sizeof(ArtPoint ));
#line 406
        seg->points = (ArtPoint *)tmp___2;
        }
      }
#line 406
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 407
  (seg->points + n_points)->x = x;
#line 408
  (seg->points + n_points)->y = y;
#line 409
  if (x < seg->bbox.x0) {
#line 410
    seg->bbox.x0 = x;
  }
#line 411
  if (x > seg->bbox.x1) {
#line 412
    seg->bbox.x1 = x;
  }
#line 413
  seg->bbox.y1 = y;
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_writer_rewind_close_segment___0(ArtSvpWriter *self , int seg_id ) 
{ 


  {
#line 437
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_setup_seg___0(ArtActiveSeg *seg , ArtPriPoint *pri_pt ) 
{ 
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  int tmp ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double dx ;
  double dy ;
  double s ;
  double a ;
  double b ;
  double r2 ;
  double tmp___0 ;

  {
#line 549
  in_seg = seg->in_seg;
#line 550
  tmp = seg->in_curs;
#line 550
  (seg->in_curs) ++;
#line 550
  in_curs = tmp;
#line 555
  x0 = (in_seg->points + in_curs)->x;
#line 556
  y0___0 = (in_seg->points + in_curs)->y;
#line 557
  x1 = (in_seg->points + (in_curs + 1))->x;
#line 558
  y1___0 = (in_seg->points + (in_curs + 1))->y;
#line 559
  pri_pt->x = x1;
#line 560
  pri_pt->y = y1___0;
#line 561
  dx = x1 - x0;
#line 562
  dy = y1___0 - y0___0;
#line 563
  r2 = dx * dx + dy * dy;
#line 564
  if (r2 == (double )0) {
#line 564
    s = (double )1;
  } else {
    {
#line 564
    tmp___0 = sqrt(r2);
#line 564
    s = (double )1 / tmp___0;
    }
  }
#line 565
  a = dy * s;
#line 565
  seg->a = a;
#line 566
  b = - dx * s;
#line 566
  seg->b = b;
#line 567
  seg->c = - (a * x0 + b * y0___0);
#line 568
  seg->flags = (seg->flags & -2) | (dx > (double )0);
#line 569
  seg->x[0] = x0;
#line 570
  seg->x[1] = x1;
#line 571
  seg->y0 = y0___0;
#line 572
  seg->y1 = y1___0;
#line 573
  seg->n_stack = 1;
#line 574
  (seg->stack + 0)->x = x1;
#line 575
  (seg->stack + 0)->y = y1___0;
#line 576
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_add_horiz___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg **pp ;
  ArtActiveSeg *place ;
  ArtActiveSeg *place_right ;

  {
#line 596
  pp = & ctx->horiz_last;
#line 598
  place_right = (ArtActiveSeg *)((void *)0);
#line 602
  if (seg->flags & 16) {
    {
#line 604
    art_warn("*** attempt to put segment in horiz list twice\n");
    }
#line 605
    return;
  }
#line 607
  seg->flags |= 16;
#line 613
  place = *pp;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if ((unsigned long )place != (unsigned long )((void *)0)) {
#line 613
      if (! (place->horiz_x > seg->horiz_x)) {
#line 613
        if (place->horiz_x == seg->horiz_x) {
#line 613
          if (! (place->b < seg->b)) {
#line 613
            goto while_break;
          }
        } else {
#line 613
          goto while_break;
        }
      }
    } else {
#line 613
      goto while_break;
    }
#line 618
    place_right = place;
#line 619
    pp = & place->horiz_left;
#line 613
    place = *pp;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  *pp = seg;
#line 622
  seg->horiz_left = place;
#line 623
  seg->horiz_right = place_right;
#line 624
  if ((unsigned long )place == (unsigned long )((void *)0)) {
#line 625
    ctx->horiz_first = seg;
  } else {
#line 627
    place->horiz_right = seg;
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_push_pt___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                          double x , double y ) 
{ 
  ArtPriPoint *pri_pt ;
  int n_stack ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 635
  n_stack = seg->n_stack;
#line 637
  if (n_stack == seg->n_stack_max) {
    {
#line 638
    while (1) {
      while_continue: /* CIL Label */ ;
#line 638
      if (seg->n_stack_max) {
        {
#line 638
        tmp = seg->n_stack_max << 1;
#line 638
        seg->n_stack_max = tmp;
#line 638
        tmp___0 = art_realloc((void *)seg->stack, (unsigned long )tmp * sizeof(ArtPoint ));
#line 638
        seg->stack = (ArtPoint *)tmp___0;
        }
      } else {
        {
#line 638
        seg->n_stack_max = 1;
#line 638
        tmp___1 = art_alloc(sizeof(ArtPoint ));
#line 638
        seg->stack = (ArtPoint *)tmp___1;
        }
      }
#line 638
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 639
  (seg->stack + n_stack)->x = x;
#line 640
  (seg->stack + n_stack)->y = y;
#line 641
  (seg->n_stack) ++;
#line 643
  seg->x[1] = x;
#line 644
  seg->y1 = y;
#line 646
  tmp___2 = art_alloc(sizeof(ArtPriPoint ));
#line 646
  pri_pt = (ArtPriPoint *)tmp___2;
#line 647
  pri_pt->x = x;
#line 648
  pri_pt->y = y;
#line 649
  pri_pt->user_data = (void *)seg;
#line 650
  art_pri_insert___0(ctx->pq, pri_pt);
  }
#line 651
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static double art_svp_intersect_break___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                          double x_ref , double y , ArtBreakFlags break_flags ) 
{ 
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  double x ;
  int tmp ;

  {
#line 671
  in_seg = seg->in_seg;
#line 672
  in_curs = seg->in_curs;
#line 675
  x0 = (in_seg->points + (in_curs - 1))->x;
#line 676
  y0___0 = (in_seg->points + (in_curs - 1))->y;
#line 677
  x1 = (in_seg->points + in_curs)->x;
#line 678
  y1___0 = (in_seg->points + in_curs)->y;
#line 679
  x = x0 + (x1 - x0) * ((y - y0___0) / (y1___0 - y0___0));
#line 680
  if ((unsigned int )break_flags == 1U) {
#line 680
    if (x > x_ref) {
#line 680
      tmp = 1;
    } else {
#line 680
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 680
  if ((unsigned int )break_flags == 2U) {
#line 680
    if (x < x_ref) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 693
  if (y > ctx->y) {
    {
#line 694
    art_svp_intersect_push_pt___0(ctx, seg, x, y);
    }
  } else {
    {
#line 697
    seg->x[0] = x;
#line 698
    seg->y0 = y;
#line 699
    seg->horiz_x = x;
#line 700
    art_svp_intersect_add_horiz___0(ctx, seg);
    }
  }
#line 703
  return (x);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtActiveSeg *art_svp_intersect_add_point___0(ArtIntersectCtx *ctx , double x ,
                                                     double y , ArtActiveSeg *seg ,
                                                     ArtBreakFlags break_flags ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  double x_min ;
  double x_max ;
  art_boolean left_live ;
  art_boolean right_live ;
  double d ;
  double new_x ;
  ArtActiveSeg *test ;
  ArtActiveSeg *result ;
  double x_test ;
  int tmp ;
  int tmp___0 ;

  {
#line 721
  x_min = x;
#line 721
  x_max = x;
#line 725
  result = (ArtActiveSeg *)((void *)0);
#line 728
  left = seg;
#line 729
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 730
    right = ctx->active_head;
  } else {
#line 732
    right = left->right;
  }
#line 733
  if ((unsigned int )break_flags & 1U) {
#line 733
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 733
      tmp = 1;
    } else {
#line 733
      tmp = 0;
    }
  } else {
#line 733
    tmp = 0;
  }
#line 733
  left_live = tmp;
#line 734
  if ((unsigned int )break_flags & 2U) {
#line 734
    if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 734
      tmp___0 = 1;
    } else {
#line 734
      tmp___0 = 0;
    }
  } else {
#line 734
    tmp___0 = 0;
  }
#line 734
  right_live = tmp___0;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! left_live) {
#line 735
      if (! right_live) {
#line 735
        goto while_break;
      }
    }
#line 737
    if (left_live) {
#line 739
      if (x <= left->x[left->flags & 1]) {
#line 739
        if (y != left->y0) {
#line 739
          if (y < left->y1) {
#line 744
            d = (x_min * left->a + y * left->b) + left->c;
#line 745
            if (d < 1e-5) {
              {
#line 747
              new_x = art_svp_intersect_break___0(ctx, left, x_min, y, (ArtBreakFlags )1);
              }
#line 749
              if (new_x > x_max) {
#line 751
                x_max = new_x;
#line 752
                right_live = (unsigned long )right != (unsigned long )((void *)0);
              } else
#line 754
              if (new_x < x_min) {
#line 755
                x_min = new_x;
              }
#line 756
              left = left->left;
#line 757
              left_live = (unsigned long )left != (unsigned long )((void *)0);
            } else {
#line 760
              left_live = 0;
            }
          } else {
#line 763
            left_live = 0;
          }
        } else {
#line 763
          left_live = 0;
        }
      } else {
#line 763
        left_live = 0;
      }
    } else
#line 765
    if (right_live) {
#line 767
      if (x >= right->x[(right->flags & 1) ^ 1]) {
#line 767
        if (y != right->y0) {
#line 767
          if (y < right->y1) {
#line 772
            d = (x_max * right->a + y * right->b) + right->c;
#line 773
            if (d > - 1e-5) {
              {
#line 775
              new_x = art_svp_intersect_break___0(ctx, right, x_max, y, (ArtBreakFlags )2);
              }
#line 777
              if (new_x < x_min) {
#line 779
                x_min = new_x;
#line 780
                left_live = (unsigned long )left != (unsigned long )((void *)0);
              } else
#line 782
              if (new_x >= x_max) {
#line 783
                x_max = new_x;
              }
#line 784
              right = right->right;
#line 785
              right_live = (unsigned long )right != (unsigned long )((void *)0);
            } else {
#line 788
              right_live = 0;
            }
          } else {
#line 791
            right_live = 0;
          }
        } else {
#line 791
          right_live = 0;
        }
      } else {
#line 791
        right_live = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 800
    test = ctx->active_head;
  } else {
#line 800
    test = left->right;
  }
#line 801
  result = left;
#line 802
  if ((unsigned long )test != (unsigned long )((void *)0)) {
#line 802
    if ((unsigned long )test != (unsigned long )right) {
#line 804
      if (y == test->y0) {
#line 805
        x_test = test->x[0];
      } else {
#line 807
        x_test = test->x[1];
      }
      {
#line 808
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 810
        if (x_test <= x) {
#line 811
          result = test;
        }
#line 812
        test = test->right;
#line 813
        if ((unsigned long )test == (unsigned long )right) {
#line 814
          goto while_break___0;
        }
#line 815
        new_x = x_test;
#line 816
        if (new_x < x_test) {
          {
#line 818
          art_warn("art_svp_intersect_add_point: non-ascending x\n");
          }
        }
#line 820
        x_test = new_x;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 823
  return (result);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_swap_active___0(ArtIntersectCtx *ctx , ArtActiveSeg *left_seg ,
                                              ArtActiveSeg *right_seg ) 
{ 


  {
#line 830
  right_seg->left = left_seg->left;
#line 831
  if ((unsigned long )right_seg->left != (unsigned long )((void *)0)) {
#line 832
    (right_seg->left)->right = right_seg;
  } else {
#line 834
    ctx->active_head = right_seg;
  }
#line 835
  left_seg->right = right_seg->right;
#line 836
  if ((unsigned long )left_seg->right != (unsigned long )((void *)0)) {
#line 837
    (left_seg->right)->left = left_seg;
  }
#line 838
  left_seg->left = right_seg;
#line 839
  right_seg->right = left_seg;
#line 840
  return;
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static art_boolean art_svp_intersect_test_cross___0(ArtIntersectCtx *ctx , ArtActiveSeg *left_seg ,
                                                    ArtActiveSeg *right_seg , ArtBreakFlags break_flags ) 
{ 
  double left_x0 ;
  double left_y0 ;
  double left_x1 ;
  double left_y1 ;
  double right_y1 ;
  double d ;
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  double d0 ;
  double d1 ;
  double t ;
  double x ;
  double y ;
  double left_x1___0 ;
  double right_x1 ;
  double tmp ;
  double right_x1___0 ;
  double left_x1___1 ;
  double tmp___0 ;
  double left_x1___2 ;
  double right_x1___1 ;
  double left_x1___3 ;
  double right_x1___2 ;
  double tmp___1 ;
  double right_x1___3 ;
  double left_x1___4 ;
  double tmp___2 ;
  double left_x1___5 ;
  double right_x1___4 ;
  ArtActiveSeg *winner ;
  ArtActiveSeg *loser ;

  {
#line 861
  left_y1 = left_seg->y1;
#line 862
  right_y1 = right_seg->y1;
#line 877
  if (left_seg->y0 == right_seg->y0) {
#line 877
    if (left_seg->x[0] == right_seg->x[0]) {
#line 884
      if (left_y1 < right_y1) {
#line 887
        left_x1___0 = left_seg->x[1];
#line 889
        if (left_x1___0 < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 892
          return (0);
        } else
#line 889
        if (left_y1 == right_seg->y0) {
#line 892
          return (0);
        }
#line 893
        d = (left_x1___0 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 894
        if (d < - 1e-5) {
#line 895
          return (0);
        } else
#line 896
        if (d < 1e-5) {
          {
#line 899
          tmp = art_svp_intersect_break___0(ctx, right_seg, left_x1___0, left_y1,
                                            (ArtBreakFlags )2);
#line 899
          right_x1 = tmp;
          }
#line 902
          if (left_x1___0 <= right_x1) {
#line 903
            return (0);
          }
        }
      } else
#line 906
      if (left_y1 > right_y1) {
#line 909
        right_x1___0 = right_seg->x[1];
#line 911
        if (right_x1___0 > left_seg->x[left_seg->flags & 1]) {
#line 913
          return (0);
        } else
#line 911
        if (right_y1 == left_seg->y0) {
#line 913
          return (0);
        }
#line 914
        d = (right_x1___0 * left_seg->a + right_y1 * left_seg->b) + left_seg->c;
#line 915
        if (d > 1e-5) {
#line 916
          return (0);
        } else
#line 917
        if (d > - 1e-5) {
          {
#line 920
          tmp___0 = art_svp_intersect_break___0(ctx, left_seg, right_x1___0, right_y1,
                                                (ArtBreakFlags )1);
#line 920
          left_x1___1 = tmp___0;
          }
#line 923
          if (left_x1___1 <= right_x1___0) {
#line 924
            return (0);
          }
        }
      } else {
#line 929
        left_x1___2 = left_seg->x[1];
#line 930
        right_x1___1 = right_seg->x[1];
#line 932
        if (left_x1___2 <= right_x1___1) {
#line 933
          return (0);
        }
      }
      {
#line 935
      art_svp_intersect_swap_active___0(ctx, left_seg, right_seg);
      }
#line 936
      return (1);
    }
  }
#line 939
  if (left_y1 < right_y1) {
#line 942
    left_x1___3 = left_seg->x[1];
#line 944
    if (left_x1___3 < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 947
      return (0);
    } else
#line 944
    if (left_y1 == right_seg->y0) {
#line 947
      return (0);
    }
#line 948
    d = (left_x1___3 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 949
    if (d < - 1e-5) {
#line 950
      return (0);
    } else
#line 951
    if (d < 1e-5) {
      {
#line 953
      tmp___1 = art_svp_intersect_break___0(ctx, right_seg, left_x1___3, left_y1,
                                            (ArtBreakFlags )2);
#line 953
      right_x1___2 = tmp___1;
      }
#line 956
      if (left_x1___3 <= right_x1___2) {
#line 957
        return (0);
      }
    }
  } else
#line 960
  if (left_y1 > right_y1) {
#line 963
    right_x1___3 = right_seg->x[1];
#line 965
    if (right_x1___3 > left_seg->x[left_seg->flags & 1]) {
#line 967
      return (0);
    } else
#line 965
    if (right_y1 == left_seg->y0) {
#line 967
      return (0);
    }
#line 968
    d = (right_x1___3 * left_seg->a + right_y1 * left_seg->b) + left_seg->c;
#line 969
    if (d > 1e-5) {
#line 970
      return (0);
    } else
#line 971
    if (d > - 1e-5) {
      {
#line 973
      tmp___2 = art_svp_intersect_break___0(ctx, left_seg, right_x1___3, right_y1,
                                            (ArtBreakFlags )1);
#line 973
      left_x1___4 = tmp___2;
      }
#line 976
      if (left_x1___4 <= right_x1___3) {
#line 977
        return (0);
      }
    }
  } else {
#line 982
    left_x1___5 = left_seg->x[1];
#line 983
    right_x1___4 = right_seg->x[1];
#line 985
    if (left_x1___5 <= right_x1___4) {
#line 986
      return (0);
    }
  }
#line 991
  in_seg = left_seg->in_seg;
#line 992
  in_curs = left_seg->in_curs;
#line 993
  left_x0 = (in_seg->points + (in_curs - 1))->x;
#line 994
  left_y0 = (in_seg->points + (in_curs - 1))->y;
#line 995
  left_x1 = (in_seg->points + in_curs)->x;
#line 996
  left_y1 = (in_seg->points + in_curs)->y;
#line 997
  d0 = (left_x0 * right_seg->a + left_y0 * right_seg->b) + right_seg->c;
#line 998
  d1 = (left_x1 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 999
  if (d0 == d1) {
#line 1001
    x = left_x0;
#line 1002
    y = left_y0;
  } else {
#line 1007
    t = d0 / (d0 - d1);
#line 1008
    if (t <= (double )0) {
#line 1010
      x = left_x0;
#line 1011
      y = left_y0;
    } else
#line 1013
    if (t >= (double )1) {
#line 1015
      x = left_x1;
#line 1016
      y = left_y1;
    } else {
#line 1020
      x = left_x0 + t * (left_x1 - left_x0);
#line 1021
      y = left_y0 + t * (left_y1 - left_y0);
    }
  }
#line 1026
  if (y < right_seg->y0) {
#line 1028
    x = right_seg->x[0];
#line 1029
    y = right_seg->y0;
  } else
#line 1031
  if (y > right_seg->y1) {
#line 1033
    x = right_seg->x[1];
#line 1034
    y = right_seg->y1;
  } else
#line 1036
  if (x < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 1037
    x = right_seg->x[(right_seg->flags & 1) ^ 1];
  } else
#line 1038
  if (x > right_seg->x[right_seg->flags & 1]) {
#line 1039
    x = right_seg->x[right_seg->flags & 1];
  }
#line 1041
  if (y == left_seg->y0) {
#line 1043
    if (y != right_seg->y0) {
      {
#line 1049
      art_svp_intersect_push_pt___0(ctx, right_seg, x, y);
      }
#line 1050
      if ((unsigned int )break_flags & 2U) {
#line 1050
        if ((unsigned long )right_seg->right != (unsigned long )((void *)0)) {
          {
#line 1051
          art_svp_intersect_add_point___0(ctx, x, y, right_seg->right, break_flags);
          }
        }
      }
    } else {
#line 1062
      if (left_seg->a > right_seg->a) {
#line 1064
        winner = left_seg;
#line 1065
        loser = right_seg;
      } else {
#line 1069
        winner = right_seg;
#line 1070
        loser = left_seg;
      }
      {
#line 1073
      loser->x[0] = winner->x[0];
#line 1074
      loser->horiz_x = loser->x[0];
#line 1075
      loser->horiz_delta_wind += loser->delta_wind;
#line 1076
      winner->horiz_delta_wind -= loser->delta_wind;
#line 1078
      art_svp_intersect_swap_active___0(ctx, left_seg, right_seg);
      }
#line 1079
      return (1);
    }
  } else
#line 1082
  if (y == right_seg->y0) {
    {
#line 1088
    art_svp_intersect_push_pt___0(ctx, left_seg, x, y);
    }
#line 1089
    if ((unsigned int )break_flags & 1U) {
#line 1089
      if ((unsigned long )left_seg->left != (unsigned long )((void *)0)) {
        {
#line 1090
        art_svp_intersect_add_point___0(ctx, x, y, left_seg->left, break_flags);
        }
      }
    }
  } else {
    {
#line 1100
    art_svp_intersect_push_pt___0(ctx, left_seg, x, y);
#line 1101
    art_svp_intersect_push_pt___0(ctx, right_seg, x, y);
    }
#line 1102
    if ((unsigned int )break_flags & 1U) {
#line 1102
      if ((unsigned long )left_seg->left != (unsigned long )((void *)0)) {
        {
#line 1103
        art_svp_intersect_add_point___0(ctx, x, y, left_seg->left, break_flags);
        }
      }
    }
#line 1104
    if ((unsigned int )break_flags & 2U) {
#line 1104
      if ((unsigned long )right_seg->right != (unsigned long )((void *)0)) {
        {
#line 1105
        art_svp_intersect_add_point___0(ctx, x, y, right_seg->right, break_flags);
        }
      }
    }
  }
#line 1107
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_active_delete___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;

  {
#line 1120
  left = seg->left;
#line 1120
  right = seg->right;
#line 1122
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1123
    left->right = right;
  } else {
#line 1125
    ctx->active_head = right;
  }
#line 1126
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1127
    right->left = left;
  }
#line 1128
  return;
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_active_free___0(ArtActiveSeg *seg ) 
{ 


  {
  {
#line 1139
  art_free((void *)seg->stack);
#line 1143
  art_free((void *)seg);
  }
#line 1144
  return;
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_insert_cross___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  ArtActiveSeg *leftc ;
  art_boolean tmp ;
  ArtActiveSeg *rightc ;
  art_boolean tmp___0 ;

  {
#line 1156
  left = seg;
#line 1156
  right = seg;
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1164
      leftc = left->left;
      {
#line 1164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1164
        if (! ((unsigned long )leftc != (unsigned long )((void *)0))) {
#line 1164
          goto while_break___0;
        }
#line 1165
        if (! (leftc->flags & 4)) {
#line 1166
          goto while_break___0;
        }
#line 1164
        leftc = leftc->left;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1167
      if ((unsigned long )leftc != (unsigned long )((void *)0)) {
        {
#line 1167
        tmp = art_svp_intersect_test_cross___0(ctx, leftc, left, (ArtBreakFlags )1);
        }
#line 1167
        if (tmp) {
#line 1171
          if ((unsigned long )left == (unsigned long )right) {
#line 1172
            right = left->right;
          } else
#line 1171
          if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 1172
            right = left->right;
          }
        } else {
#line 1176
          left = (ArtActiveSeg *)((void *)0);
        }
      } else {
#line 1176
        left = (ArtActiveSeg *)((void *)0);
      }
    } else
#line 1179
    if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1179
      if ((unsigned long )right->right != (unsigned long )((void *)0)) {
#line 1183
        rightc = right->right;
        {
#line 1183
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1183
          if (! ((unsigned long )rightc != (unsigned long )((void *)0))) {
#line 1183
            goto while_break___1;
          }
#line 1184
          if (! (rightc->flags & 4)) {
#line 1185
            goto while_break___1;
          }
#line 1183
          rightc = rightc->right;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1186
        if ((unsigned long )rightc != (unsigned long )((void *)0)) {
          {
#line 1186
          tmp___0 = art_svp_intersect_test_cross___0(ctx, right, rightc, (ArtBreakFlags )2);
          }
#line 1186
          if (tmp___0) {
#line 1190
            if ((unsigned long )left == (unsigned long )right) {
#line 1191
              left = right->left;
            } else
#line 1190
            if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 1191
              left = right->left;
            }
          } else {
#line 1195
            right = (ArtActiveSeg *)((void *)0);
          }
        } else {
#line 1195
          right = (ArtActiveSeg *)((void *)0);
        }
      } else {
#line 1199
        goto while_break;
      }
    } else {
#line 1199
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1201
  return;
}
}
#line 1213 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_horiz___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                        double x0 , double x1 ) 
{ 
  ArtActiveSeg *hs ;
  void *tmp ;
  ArtSvpWriter *swr ;
  ArtActiveSeg *left ;
  art_boolean first ;
  int left_bneg ;
  ArtActiveSeg *right ;
  art_boolean first___0 ;
  int right_bneg ;

  {
#line 1219
  if (x0 == x1) {
#line 1220
    return;
  }
  {
#line 1222
  tmp = art_alloc(sizeof(ArtActiveSeg ));
#line 1222
  hs = (ArtActiveSeg *)tmp;
#line 1224
  hs->flags = 4 | (seg->flags & 8);
  }
#line 1225
  if (seg->flags & 8) {
    {
#line 1227
    swr = ctx->out;
#line 1229
    (*(swr->add_point))(swr, seg->seg_id, x0, ctx->y);
    }
  }
  {
#line 1231
  hs->seg_id = seg->seg_id;
#line 1232
  hs->horiz_x = x0;
#line 1233
  hs->horiz_delta_wind = seg->delta_wind;
#line 1234
  hs->stack = (ArtPoint *)((void *)0);
#line 1241
  hs->a = 0.0;
#line 1242
  hs->b = 0.0;
#line 1243
  hs->c = 0.0;
#line 1245
  seg->horiz_delta_wind -= seg->delta_wind;
#line 1247
  art_svp_intersect_add_horiz___0(ctx, hs);
  }
#line 1249
  if (x0 > x1) {
#line 1252
    first = 1;
#line 1254
    left = seg->left;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 1254
        goto while_break;
      }
#line 1256
      left_bneg = left->flags & 1;
#line 1258
      if (left->x[left_bneg] <= x1) {
#line 1259
        goto while_break;
      }
#line 1260
      if (left->x[left_bneg ^ 1] <= x1) {
#line 1260
        if ((x1 * left->a + ctx->y * left->b) + left->c >= (double )0) {
#line 1262
          goto while_break;
        }
      }
#line 1263
      if (left->y0 != ctx->y) {
#line 1263
        if (left->y1 != ctx->y) {
          {
#line 1265
          art_svp_intersect_break___0(ctx, left, x1, ctx->y, (ArtBreakFlags )1);
          }
        }
      }
      {
#line 1271
      art_svp_intersect_swap_active___0(ctx, left, seg);
      }
#line 1272
      if (first) {
#line 1272
        if ((unsigned long )left->right != (unsigned long )((void *)0)) {
          {
#line 1274
          art_svp_intersect_test_cross___0(ctx, left, left->right, (ArtBreakFlags )2);
#line 1276
          first = 0;
          }
        }
      }
#line 1254
      left = seg->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1283
    first___0 = 1;
#line 1285
    right = seg->right;
    {
#line 1285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1285
      if (! ((unsigned long )right != (unsigned long )((void *)0))) {
#line 1285
        goto while_break___0;
      }
#line 1287
      right_bneg = right->flags & 1;
#line 1289
      if (right->x[right_bneg ^ 1] >= x1) {
#line 1290
        goto while_break___0;
      }
#line 1291
      if (right->x[right_bneg] >= x1) {
#line 1291
        if ((x1 * right->a + ctx->y * right->b) + right->c <= (double )0) {
#line 1293
          goto while_break___0;
        }
      }
#line 1294
      if (right->y0 != ctx->y) {
#line 1294
        if (right->y1 != ctx->y) {
          {
#line 1296
          art_svp_intersect_break___0(ctx, right, x1, ctx->y, (ArtBreakFlags )1);
          }
        }
      }
      {
#line 1303
      art_svp_intersect_swap_active___0(ctx, seg, right);
      }
#line 1304
      if (first___0) {
#line 1304
        if ((unsigned long )right->left != (unsigned long )((void *)0)) {
          {
#line 1306
          art_svp_intersect_test_cross___0(ctx, right->left, right, (ArtBreakFlags )2);
#line 1308
          first___0 = 0;
          }
        }
      }
#line 1285
      right = seg->right;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1313
  seg->x[0] = x1;
#line 1314
  seg->x[1] = x1;
#line 1315
  seg->horiz_x = x1;
#line 1316
  seg->flags &= -9;
#line 1317
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_insert_line___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 


  {
#line 1331
  if (seg->y1 == seg->y0) {
    {
#line 1337
    art_svp_intersect_horiz___0(ctx, seg, seg->x[0], seg->x[1]);
    }
  } else {
    {
#line 1341
    art_svp_intersect_insert_cross___0(ctx, seg);
#line 1342
    art_svp_intersect_add_horiz___0(ctx, seg);
    }
  }
#line 1344
  return;
}
}
#line 1346 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_process_intersection___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  int n_stack ;

  {
  {
#line 1350
  (seg->n_stack) --;
#line 1350
  n_stack = seg->n_stack;
#line 1351
  seg->x[1] = (seg->stack + (n_stack - 1))->x;
#line 1352
  seg->y1 = (seg->stack + (n_stack - 1))->y;
#line 1353
  seg->x[0] = (seg->stack + n_stack)->x;
#line 1354
  seg->y0 = (seg->stack + n_stack)->y;
#line 1355
  seg->horiz_x = seg->x[0];
#line 1356
  art_svp_intersect_insert_line___0(ctx, seg);
  }
#line 1357
  return;
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_advance_cursor___0(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                                 ArtPriPoint *pri_pt ) 
{ 
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  ArtSvpWriter *swr ;
  ArtSvpWriter *tmp ;
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;

  {
#line 1363
  in_seg = seg->in_seg;
#line 1364
  in_curs = seg->in_curs;
#line 1365
  if (seg->flags & 8) {
#line 1365
    tmp = ctx->out;
  } else {
#line 1365
    tmp = (ArtSvpWriter *)((void *)0);
  }
#line 1365
  swr = tmp;
#line 1367
  if ((unsigned long )swr != (unsigned long )((void *)0)) {
    {
#line 1368
    (*(swr->add_point))(swr, seg->seg_id, seg->x[1], seg->y1);
    }
  }
#line 1369
  if (in_curs + 1 == (int )in_seg->n_points) {
    {
#line 1371
    left = seg->left;
#line 1371
    right = seg->right;
#line 1378
    seg->flags |= 4;
#line 1379
    art_svp_intersect_add_horiz___0(ctx, seg);
#line 1380
    art_svp_intersect_active_delete___0(ctx, seg);
    }
#line 1381
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1381
      if ((unsigned long )right != (unsigned long )((void *)0)) {
        {
#line 1382
        art_svp_intersect_test_cross___0(ctx, left, right, (ArtBreakFlags )3);
        }
      }
    }
    {
#line 1384
    art_free((void *)pri_pt);
    }
  } else {
    {
#line 1388
    seg->horiz_x = seg->x[1];
#line 1390
    art_svp_intersect_setup_seg___0(seg, pri_pt);
#line 1391
    art_pri_insert___0(ctx->pq, pri_pt);
#line 1392
    art_svp_intersect_insert_line___0(ctx, seg);
    }
  }
#line 1394
  return;
}
}
#line 1396 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_add_seg___0(ArtIntersectCtx *ctx , ArtSVPSeg const   *in_seg ) 
{ 
  ArtActiveSeg *seg ;
  void *tmp ;
  ArtActiveSeg *test ;
  double x0 ;
  double y0___0 ;
  ArtActiveSeg *beg_range ;
  ArtActiveSeg *last ;
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  ArtPriPoint *pri_pt ;
  void *tmp___0 ;
  void *tmp___1 ;
  double d ;
  int test_bneg ;

  {
  {
#line 1399
  tmp = art_alloc(sizeof(ArtActiveSeg ));
#line 1399
  seg = (ArtActiveSeg *)tmp;
#line 1403
  last = (ArtActiveSeg *)((void *)0);
#line 1405
  tmp___0 = art_alloc(sizeof(ArtPriPoint ));
#line 1405
  pri_pt = (ArtPriPoint *)tmp___0;
#line 1407
  seg->flags = 0;
#line 1408
  seg->in_seg = in_seg;
#line 1409
  seg->in_curs = 0;
#line 1411
  seg->n_stack_max = 4;
#line 1412
  tmp___1 = art_alloc((unsigned long )seg->n_stack_max * sizeof(ArtPoint ));
#line 1412
  seg->stack = (ArtPoint *)tmp___1;
#line 1414
  seg->horiz_delta_wind = 0;
#line 1416
  seg->wind_left = 0;
#line 1418
  pri_pt->user_data = (void *)seg;
#line 1419
  art_svp_intersect_setup_seg___0(seg, pri_pt);
#line 1420
  art_pri_insert___0(ctx->pq, pri_pt);
#line 1426
  x0 = (in_seg->points + 0)->x;
#line 1427
  y0___0 = (in_seg->points + 0)->y;
#line 1428
  beg_range = (ArtActiveSeg *)((void *)0);
#line 1429
  test = ctx->active_head;
  }
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 1429
      goto while_break;
    }
#line 1432
    test_bneg = test->flags & 1;
#line 1434
    if (x0 < test->x[test_bneg]) {
#line 1436
      if (x0 < test->x[test_bneg ^ 1]) {
#line 1437
        goto while_break;
      }
#line 1438
      d = (x0 * test->a + y0___0 * test->b) + test->c;
#line 1439
      if (d < (double )0) {
#line 1440
        goto while_break;
      }
    }
#line 1442
    last = test;
#line 1429
    test = test->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1445
  left = art_svp_intersect_add_point___0(ctx, x0, y0___0, last, (ArtBreakFlags )3);
#line 1446
  seg->left = left;
  }
#line 1447
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 1449
    right = ctx->active_head;
#line 1450
    ctx->active_head = seg;
  } else {
#line 1454
    right = left->right;
#line 1455
    left->right = seg;
  }
#line 1457
  seg->right = right;
#line 1458
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1459
    right->left = seg;
  }
#line 1461
  if (in_seg->dir) {
#line 1461
    seg->delta_wind = 1;
  } else {
#line 1461
    seg->delta_wind = -1;
  }
  {
#line 1462
  seg->horiz_x = x0;
#line 1464
  art_svp_intersect_insert_line___0(ctx, seg);
  }
#line 1465
  return;
}
}
#line 1512 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_horiz_commit___0(ArtIntersectCtx *ctx ) 
{ 
  ArtActiveSeg *seg ;
  int winding_number ;
  int horiz_wind ;
  double last_x ;
  ArtActiveSeg *curs ;
  double x ;
  ArtSvpWriter *swr ;
  int seg_id ;
  ArtSvpWriter *swr___0 ;
  ArtActiveSeg *next ;
  ArtSvpWriter *swr___1 ;

  {
#line 1516
  winding_number = 0;
#line 1517
  horiz_wind = 0;
#line 1518
  last_x = (double )0;
#line 1528
  seg = ctx->horiz_first;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! ((unsigned long )seg != (unsigned long )((void *)0))) {
#line 1528
      goto while_break;
    }
#line 1532
    x = seg->horiz_x;
#line 1535
    if (horiz_wind != 0) {
      {
#line 1537
      swr = ctx->out;
#line 1540
      seg_id = (*(swr->add_segment))(swr, winding_number, horiz_wind, last_x, ctx->y);
#line 1542
      (*(swr->add_point))(swr, seg_id, x, ctx->y);
#line 1543
      (*(swr->close_segment))(swr, seg_id);
      }
    }
#line 1548
    curs = seg;
    {
#line 1548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1548
      if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1548
        if (! (curs->horiz_x == x)) {
#line 1548
          goto while_break___0;
        }
      } else {
#line 1548
        goto while_break___0;
      }
#line 1550
      if (! (curs->flags & 4)) {
#line 1551
        goto while_break___0;
      }
#line 1548
      curs = curs->horiz_right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1553
    if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1553
      if (curs->horiz_x == x) {
        {
#line 1558
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1558
          if (! ((unsigned long )curs->left != (unsigned long )((void *)0))) {
#line 1558
            goto while_break___1;
          }
#line 1559
          if ((curs->left)->horiz_x != x) {
#line 1560
            goto while_break___1;
          }
#line 1558
          curs = curs->left;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1562
        if ((unsigned long )curs->left != (unsigned long )((void *)0)) {
#line 1563
          winding_number = (curs->left)->wind_left + (curs->left)->delta_wind;
        } else {
#line 1565
          winding_number = 0;
        }
        {
#line 1567
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1573
          if (! (curs->flags & 8)) {
#line 1573
            goto _L;
          } else
#line 1573
          if (curs->wind_left != winding_number) {
            _L: /* CIL Label */ 
#line 1576
            swr___0 = ctx->out;
#line 1578
            if (curs->flags & 8) {
              {
#line 1580
              (*(swr___0->add_point))(swr___0, curs->seg_id, curs->horiz_x, ctx->y);
#line 1582
              (*(swr___0->close_segment))(swr___0, curs->seg_id);
              }
            }
            {
#line 1585
            curs->seg_id = (*(swr___0->add_segment))(swr___0, winding_number, curs->delta_wind,
                                                     x, ctx->y);
#line 1588
            curs->flags |= 8;
            }
          }
#line 1590
          curs->wind_left = winding_number;
#line 1591
          winding_number += curs->delta_wind;
#line 1592
          curs = curs->right;
#line 1567
          if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1567
            if (! (curs->horiz_x == x)) {
#line 1567
              goto while_break___2;
            }
          } else {
#line 1567
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 1598
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1600
      next = seg->horiz_right;
#line 1602
      seg->flags &= -17;
#line 1603
      horiz_wind += seg->horiz_delta_wind;
#line 1604
      seg->horiz_delta_wind = 0;
#line 1605
      if (seg->flags & 4) {
#line 1607
        if (seg->flags & 8) {
          {
#line 1609
          swr___1 = ctx->out;
#line 1610
          (*(swr___1->close_segment))(swr___1, seg->seg_id);
          }
        }
        {
#line 1612
        art_svp_intersect_active_free___0(seg);
        }
      }
#line 1614
      seg = next;
#line 1598
      if ((unsigned long )seg != (unsigned long )((void *)0)) {
#line 1598
        if (! (seg->horiz_x == x)) {
#line 1598
          goto while_break___3;
        }
      } else {
#line 1598
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1618
    last_x = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 1620
  ctx->horiz_first = (ArtActiveSeg *)((void *)0);
#line 1621
  ctx->horiz_last = (ArtActiveSeg *)((void *)0);
#line 1625
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
static int art_vpath_svp_point_compare___0(double x1 , double y1 , double x2 , double y2 ) 
{ 


  {
#line 44
  if (y1 - 1e-6 > y2) {
#line 44
    return (1);
  }
#line 45
  if (y1 + 1e-6 < y2) {
#line 45
    return (-1);
  }
#line 46
  if (x1 - 1e-6 > x2) {
#line 46
    return (1);
  }
#line 47
  if (x1 + 1e-6 < x2) {
#line 47
    return (-1);
  }
#line 48
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
static int art_vpath_svp_compare___0(void const   *s1 , void const   *s2 ) 
{ 
  ArtVpathSVPEnd const   *e1 ;
  ArtVpathSVPEnd const   *e2 ;
  int tmp ;

  {
  {
#line 54
  e1 = (ArtVpathSVPEnd const   *)s1;
#line 55
  e2 = (ArtVpathSVPEnd const   *)s2;
#line 57
  tmp = art_vpath_svp_point_compare___0((double )e1->x, (double )e1->y, (double )e2->x,
                                        (double )e2->y);
  }
#line 57
  return (tmp);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
static void art_svp_render_insert_active___0(int i , int *active_segs , int n_active_segs ,
                                             artfloat *seg_x , artfloat *seg_dx ) 
{ 
  int j ;
  artfloat x ;
  int tmp1 ;
  int tmp2 ;

  {
#line 60
  x = *(seg_x + i) + 0.001 * *(seg_dx + i);
#line 61
  j = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (j < n_active_segs) {
#line 61
      if (! (*(seg_x + *(active_segs + j)) < x)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
#line 61
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  tmp1 = i;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (! (j < n_active_segs)) {
#line 64
      goto while_break___0;
    }
#line 66
    tmp2 = *(active_segs + j);
#line 67
    *(active_segs + j) = tmp1;
#line 68
    tmp1 = tmp2;
#line 69
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  *(active_segs + j) = tmp1;
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
static void art_svp_render_delete_active___0(int *active_segs , int j , int n_active_segs ) 
{ 
  int k ;

  {
#line 79
  k = j;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (k < n_active_segs)) {
#line 79
      goto while_break;
    }
#line 80
    *(active_segs + k) = *(active_segs + (k + 1));
#line 79
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_nop_done___0(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_rgb8___0(ArtRenderCallback *self , ArtRender *render ,
                                             art_u8 *dest , int y ) 
{ 
  int width ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  ArtPixMaxDepth color_max ;

  {
  {
#line 160
  width = render->x1 - render->x0;
#line 164
  color_max = render->clear_color[0];
#line 165
  r = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 166
  color_max = render->clear_color[1];
#line 167
  g = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 168
  color_max = render->clear_color[2];
#line 169
  b = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 171
  art_rgb_fill_run(dest, r, g, b, width);
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_8___0(ArtRenderCallback *self , ArtRender *render ,
                                          art_u8 *dest , int y ) 
{ 
  int width ;
  int i ;
  int j ;
  int n_ch ;
  int ix ;
  art_u8 color[17] ;
  ArtPixMaxDepth color_max ;
  int tmp ;

  {
#line 178
  width = render->x1 - render->x0;
#line 180
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 184
  j = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (j < n_ch)) {
#line 184
      goto while_break;
    }
#line 186
    color_max = render->clear_color[j];
#line 187
    color[j] = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 184
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  ix = 0;
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 191
    if (! (i < width)) {
#line 191
      goto while_break___0;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if (! (j < n_ch)) {
#line 192
        goto while_break___1;
      }
#line 193
      tmp = ix;
#line 193
      ix ++;
#line 193
      *(dest + tmp) = color[j];
#line 192
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_16___0(ArtRenderCallback *self , ArtRender *render ,
                                           art_u8 *dest , int y ) 
{ 
  int width ;
  int i ;
  int j ;
  int n_ch ;
  int ix ;
  art_u16 *dest_16 ;
  art_u8 color[17] ;
  int color_16 ;
  int tmp ;

  {
#line 214
  width = render->x1 - render->x0;
#line 216
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 218
  dest_16 = (art_u16 *)dest;
#line 221
  j = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (j < n_ch)) {
#line 221
      goto while_break;
    }
#line 223
    color_16 = (int )render->clear_color[j];
#line 224
    color[j] = (art_u8 )color_16;
#line 221
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  ix = 0;
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! (i < width)) {
#line 228
      goto while_break___0;
    }
#line 229
    j = 0;
    {
#line 229
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 229
      if (! (j < n_ch)) {
#line 229
        goto while_break___1;
      }
#line 230
      tmp = ix;
#line 230
      ix ++;
#line 230
      *(dest_16 + tmp) = (art_u16 )color[j];
#line 229
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 228
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static ArtRenderCallback *art_render_choose_clear_callback___0(ArtRender *render ) 
{ 
  ArtRenderCallback *clear_callback ;

  {
#line 247
  if (render->depth == 8) {
#line 249
    if (render->n_chan == 3) {
#line 249
      if ((unsigned int )render->alpha_type == 0U) {
#line 251
        clear_callback = (ArtRenderCallback *)(& art_render_clear_rgb8_obj);
      } else {
#line 253
        clear_callback = (ArtRenderCallback *)(& art_render_clear_8_obj);
      }
    } else {
#line 253
      clear_callback = (ArtRenderCallback *)(& art_render_clear_8_obj);
    }
  } else
#line 256
  if (render->depth == 16) {
#line 257
    clear_callback = (ArtRenderCallback *)(& art_render_clear_16_obj);
  } else {
    {
#line 261
    art_die("art_render_choose_clear_callback: inconsistent render->depth = %d\n",
            render->depth);
    }
  }
#line 264
  return (clear_callback);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite___0(ArtRenderCallback *self , ArtRender *render ,
                                     art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  art_u32 depth ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *alpha_buf ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  art_u32 alpha ;
  int image_ix ;
  art_u16 src[17] ;
  art_u16 dst[17] ;
  int n_chan ;
  ArtAlphaType alpha_type ;
  int n_ch ;
  int dst_pixstride ;
  int buf_depth ;
  ArtAlphaType buf_alpha ;
  int buf_n_ch ;
  int buf_pixstride ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 srcv ;
  art_u32 dstv ;
  art_u32 tmp___0 ;

  {
#line 286
  run = render->run;
#line 287
  depth = (art_u32 )render->depth;
#line 288
  n_run = render->n_run;
#line 289
  x0 = render->x0;
#line 292
  alpha_buf = render->alpha_buf;
#line 293
  image_buf = render->image_buf;
#line 301
  n_chan = render->n_chan;
#line 302
  alpha_type = render->alpha_type;
#line 303
  n_ch = n_chan + ((unsigned int )alpha_type != 0U);
#line 304
  dst_pixstride = (int )((art_u32 )n_ch * (depth >> 3));
#line 305
  buf_depth = render->buf_depth;
#line 306
  buf_alpha = render->buf_alpha;
#line 307
  buf_n_ch = n_chan + ((unsigned int )buf_alpha != 0U);
#line 308
  buf_pixstride = buf_n_ch * (buf_depth >> 3);
#line 316
  image_ix = 0;
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (i < n_run - 1)) {
#line 317
      goto while_break;
    }
#line 319
    run_x0 = (run + i)->x;
#line 320
    run_x1 = (run + (i + 1))->x;
#line 321
    tmp = (art_u32 )(run + i)->alpha;
#line 322
    if (tmp < 33024U) {
#line 323
      goto __Cont;
    }
#line 325
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 326
    bufptr = image_buf + (run_x0 - x0) * buf_pixstride;
#line 327
    dstptr = dest + (run_x0 - x0) * dst_pixstride;
#line 328
    x = run_x0;
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! (x < run_x1)) {
#line 328
        goto while_break___0;
      }
#line 330
      if (alpha_buf) {
#line 332
        if (depth == 8U) {
#line 334
          tmp = run_alpha * (art_u32 )*(alpha_buf + (x - x0)) + 128U;
#line 336
          alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
        } else {
#line 340
          tmp = (art_u32 )*((art_u16 *)alpha_buf + (x - x0));
#line 341
          tmp = (run_alpha * tmp + 32768U) >> 8;
#line 343
          alpha = (tmp + (tmp >> 16)) >> 8;
        }
      } else {
#line 347
        alpha = run_alpha;
      }
#line 352
      if ((unsigned int )buf_alpha == 0U) {
#line 354
        src_alpha = alpha;
#line 355
        src_mul = src_alpha;
      } else {
#line 359
        if (buf_depth == 8) {
#line 361
          tmp = alpha * (art_u32 )*(bufptr + n_chan) + 128U;
#line 363
          src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
        } else {
#line 367
          tmp = (art_u32 )*((art_u16 *)bufptr + n_chan);
#line 368
          tmp = (alpha * tmp + 32768U) >> 8;
#line 370
          src_alpha = (tmp + (tmp >> 16)) >> 8;
        }
#line 372
        if ((unsigned int )buf_alpha == 1U) {
#line 373
          src_mul = src_alpha;
        } else {
#line 375
          src_mul = alpha;
        }
      }
#line 380
      if (buf_depth == 8) {
#line 382
        src_mul *= 257U;
#line 383
        j = 0;
        {
#line 383
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 383
          if (! (j < n_chan)) {
#line 383
            goto while_break___1;
          }
#line 384
          src[j] = (art_u16 )(((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16);
#line 383
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 386
      if (buf_depth == 16) {
#line 388
        j = 0;
        {
#line 388
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 388
          if (! (j < n_chan)) {
#line 388
            goto while_break___2;
          }
#line 389
          src[j] = (art_u16 )(((art_u32 )*((art_u16 *)bufptr + j) * src_mul + 32768U) >> 16);
#line 388
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 391
      bufptr += buf_pixstride;
#line 399
      if ((unsigned int )alpha_type == 0U) {
#line 401
        dst_alpha = (art_u32 )65536;
#line 402
        dst_mul = dst_alpha;
      } else {
#line 406
        if (depth == 8U) {
#line 408
          tmp = (art_u32 )*(dstptr + n_chan);
#line 410
          dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
        } else {
#line 414
          tmp = (art_u32 )*((art_u16 *)dstptr + n_chan);
#line 415
          dst_alpha = tmp + (tmp >> 15);
        }
#line 417
        if ((unsigned int )alpha_type == 1U) {
#line 418
          dst_mul = dst_alpha;
        } else {
#line 420
          dst_mul = (art_u32 )65536;
        }
      }
#line 425
      if (depth == 8U) {
#line 427
        dst_mul *= 257U;
#line 428
        j = 0;
        {
#line 428
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 428
          if (! (j < n_chan)) {
#line 428
            goto while_break___3;
          }
#line 429
          dst[j] = (art_u16 )(((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16);
#line 428
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 431
      if (buf_depth == 16) {
#line 433
        j = 0;
        {
#line 433
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 433
          if (! (j < n_chan)) {
#line 433
            goto while_break___4;
          }
#line 434
          dst[j] = (art_u16 )(((art_u32 )*((art_u16 *)dstptr + j) * dst_mul + 32768U) >> 16);
#line 433
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 438
      j = 0;
      {
#line 438
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 438
        if (! (j < n_chan)) {
#line 438
          goto while_break___5;
        }
#line 443
        srcv = (art_u32 )src[j];
#line 444
        dstv = (art_u32 )dst[j];
#line 445
        tmp___0 = ((dstv * (65536U - src_alpha) + 32768U) >> 16) + srcv;
#line 446
        tmp___0 -= tmp___0 >> 16;
#line 447
        dst[j] = (art_u16 )tmp___0;
#line 438
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 450
      if ((unsigned int )alpha_type == 0U) {
#line 452
        if (depth == 8U) {
#line 453
          dst_mul = (art_u32 )255;
        } else {
#line 455
          dst_mul = (art_u32 )65535;
        }
      } else {
#line 459
        if (src_alpha >= 65536U) {
#line 460
          dst_alpha = (art_u32 )65536;
        } else {
#line 462
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 463
        if ((unsigned int )alpha_type == 2U) {
#line 463
          goto _L;
        } else
#line 463
        if (dst_alpha == 0U) {
          _L: /* CIL Label */ 
#line 465
          if (depth == 8U) {
#line 466
            dst_mul = (art_u32 )255;
          } else {
#line 468
            dst_mul = (art_u32 )65535;
          }
        } else
#line 472
        if (depth == 8U) {
#line 473
          dst_mul = 16711680U / dst_alpha;
        } else {
#line 475
          dst_mul = 4294901760U / dst_alpha;
        }
      }
#line 478
      if (depth == 8U) {
#line 480
        j = 0;
        {
#line 480
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 480
          if (! (j < n_chan)) {
#line 480
            goto while_break___6;
          }
#line 481
          *(dstptr + j) = (art_u8 )(((art_u32 )dst[j] * dst_mul + 32768U) >> 16);
#line 480
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 482
        if ((unsigned int )alpha_type != 0U) {
#line 483
          *(dstptr + n_chan) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
        }
      } else
#line 485
      if (depth == 16U) {
#line 487
        j = 0;
        {
#line 487
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 487
          if (! (j < n_chan)) {
#line 487
            goto while_break___7;
          }
#line 488
          *((art_u16 *)dstptr + j) = (art_u16 )(((art_u32 )dst[j] * dst_mul + 32768U) >> 16);
#line 487
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 489
        if ((unsigned int )alpha_type != 0U) {
#line 490
          *((art_u16 *)dstptr + n_chan) = (art_u16 )((dst_alpha * 65535U + 32768U) >> 16);
        }
      }
#line 492
      dstptr += dst_pixstride;
#line 328
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8___0(ArtRenderCallback *self , ArtRender *render ,
                                       art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *alpha_buf ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  art_u32 alpha ;
  int image_ix ;
  int n_chan ;
  ArtAlphaType alpha_type ;
  int n_ch ;
  int dst_pixstride ;
  ArtAlphaType buf_alpha ;
  int buf_n_ch ;
  int buf_pixstride ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___0 ;

  {
#line 507
  run = render->run;
#line 508
  n_run = render->n_run;
#line 509
  x0 = render->x0;
#line 512
  alpha_buf = render->alpha_buf;
#line 513
  image_buf = render->image_buf;
#line 519
  n_chan = render->n_chan;
#line 520
  alpha_type = render->alpha_type;
#line 521
  n_ch = n_chan + ((unsigned int )alpha_type != 0U);
#line 522
  dst_pixstride = n_ch;
#line 523
  buf_alpha = render->buf_alpha;
#line 524
  buf_n_ch = n_chan + ((unsigned int )buf_alpha != 0U);
#line 525
  buf_pixstride = buf_n_ch;
#line 533
  image_ix = 0;
#line 534
  i = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < n_run - 1)) {
#line 534
      goto while_break;
    }
#line 536
    run_x0 = (run + i)->x;
#line 537
    run_x1 = (run + (i + 1))->x;
#line 538
    tmp = (art_u32 )(run + i)->alpha;
#line 539
    if (tmp < 65536U) {
#line 540
      goto __Cont;
    }
#line 542
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 543
    bufptr = image_buf + (run_x0 - x0) * buf_pixstride;
#line 544
    dstptr = dest + (run_x0 - x0) * dst_pixstride;
#line 545
    x = run_x0;
    {
#line 545
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 545
      if (! (x < run_x1)) {
#line 545
        goto while_break___0;
      }
#line 547
      if (alpha_buf) {
#line 549
        tmp = run_alpha * (art_u32 )*(alpha_buf + (x - x0)) + 128U;
#line 551
        alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
      } else {
#line 554
        alpha = run_alpha;
      }
#line 559
      if ((unsigned int )buf_alpha == 0U) {
#line 561
        src_alpha = alpha;
#line 562
        src_mul = src_alpha;
      } else {
#line 566
        tmp = alpha * (art_u32 )*(bufptr + n_chan) + 128U;
#line 568
        src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
#line 570
        if ((unsigned int )buf_alpha == 1U) {
#line 571
          src_mul = src_alpha;
        } else {
#line 573
          src_mul = alpha;
        }
      }
#line 578
      src_mul *= 257U;
#line 580
      if ((unsigned int )alpha_type == 0U) {
#line 582
        dst_alpha = (art_u32 )65536;
#line 583
        dst_mul = dst_alpha;
      } else {
#line 587
        tmp = (art_u32 )*(dstptr + n_chan);
#line 589
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 590
        if ((unsigned int )alpha_type == 1U) {
#line 591
          dst_mul = dst_alpha;
        } else {
#line 593
          dst_mul = (art_u32 )65536;
        }
      }
#line 598
      dst_mul *= 257U;
#line 600
      if ((unsigned int )alpha_type == 0U) {
#line 602
        dst_save_mul = (art_u32 )255;
      } else {
#line 606
        if (src_alpha >= 65536U) {
#line 607
          dst_alpha = (art_u32 )65536;
        } else {
#line 609
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 610
        if ((unsigned int )alpha_type == 2U) {
#line 612
          dst_save_mul = (art_u32 )255;
        } else
#line 610
        if (dst_alpha == 0U) {
#line 612
          dst_save_mul = (art_u32 )255;
        } else {
#line 616
          dst_save_mul = 16711680U / dst_alpha;
        }
      }
#line 620
      j = 0;
      {
#line 620
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 620
        if (! (j < n_chan)) {
#line 620
          goto while_break___1;
        }
#line 625
        src = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 626
        dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 627
        tmp___0 = ((dst * (65536U - src_alpha) + 32768U) >> 16) + src;
#line 628
        tmp___0 -= tmp___0 >> 16;
#line 629
        *(dstptr + j) = (art_u8 )((tmp___0 * dst_save_mul + 32768U) >> 16);
#line 620
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 631
      if ((unsigned int )alpha_type != 0U) {
#line 632
        *(dstptr + n_chan) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
      }
#line 634
      bufptr += buf_pixstride;
#line 635
      dstptr += dst_pixstride;
#line 545
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8_opt1___0(ArtRenderCallback *self , ArtRender *render ,
                                            art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  int image_ix ;
  art_u8 *bufptr ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;
  art_u8 *tmp___3 ;
  art_u8 *tmp___4 ;
  art_u8 *tmp___5 ;
  art_u8 *tmp___6 ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___7 ;

  {
#line 657
  run = render->run;
#line 658
  n_run = render->n_run;
#line 659
  x0 = render->x0;
#line 662
  image_buf = render->image_buf;
#line 673
  image_ix = 0;
#line 674
  i = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (i < n_run - 1)) {
#line 674
      goto while_break;
    }
#line 676
    run_x0 = (run + i)->x;
#line 677
    run_x1 = (run + (i + 1))->x;
#line 678
    tmp = (art_u32 )(run + i)->alpha;
#line 679
    if (tmp < 65536U) {
#line 680
      goto __Cont;
    }
#line 682
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 683
    bufptr = image_buf + (run_x0 - x0) * 3;
#line 684
    dstptr = dest + (run_x0 - x0) * 4;
#line 685
    if (run_alpha == 65536U) {
#line 687
      x = run_x0;
      {
#line 687
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 687
        if (! (x < run_x1)) {
#line 687
          goto while_break___0;
        }
#line 689
        tmp___0 = dstptr;
#line 689
        dstptr ++;
#line 689
        tmp___1 = bufptr;
#line 689
        bufptr ++;
#line 689
        *tmp___0 = *tmp___1;
#line 690
        tmp___2 = dstptr;
#line 690
        dstptr ++;
#line 690
        tmp___3 = bufptr;
#line 690
        bufptr ++;
#line 690
        *tmp___2 = *tmp___3;
#line 691
        tmp___4 = dstptr;
#line 691
        dstptr ++;
#line 691
        tmp___5 = bufptr;
#line 691
        bufptr ++;
#line 691
        *tmp___4 = *tmp___5;
#line 692
        tmp___6 = dstptr;
#line 692
        dstptr ++;
#line 692
        *tmp___6 = (art_u8 )255;
#line 687
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 697
      x = run_x0;
      {
#line 697
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 697
        if (! (x < run_x1)) {
#line 697
          goto while_break___1;
        }
#line 699
        src_mul = run_alpha * 257U;
#line 701
        tmp = (art_u32 )*(dstptr + 3);
#line 703
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 704
        dst_mul = dst_alpha;
#line 708
        dst_mul *= 257U;
#line 710
        dst_alpha += (((65536U - dst_alpha) * run_alpha >> 8) + 128U) >> 8;
#line 711
        if (dst_alpha == 0U) {
#line 712
          dst_save_mul = (art_u32 )255;
        } else {
#line 714
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 716
        j = 0;
        {
#line 716
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 716
          if (! (j < 3)) {
#line 716
            goto while_break___2;
          }
#line 721
          src = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 722
          dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 723
          tmp___7 = ((dst * (65536U - run_alpha) + 32768U) >> 16) + src;
#line 724
          tmp___7 -= tmp___7 >> 16;
#line 725
          *(dstptr + j) = (art_u8 )((tmp___7 * dst_save_mul + 32768U) >> 16);
#line 716
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 727
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 729
        bufptr += 3;
#line 730
        dstptr += 4;
#line 697
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 674
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8_opt2___0(ArtRenderCallback *self , ArtRender *render ,
                                            art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  int image_ix ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___0 ;
  art_u32 src___0 ;
  art_u32 dst___0 ;
  art_u32 tmp___1 ;

  {
#line 753
  run = render->run;
#line 754
  n_run = render->n_run;
#line 755
  x0 = render->x0;
#line 758
  image_buf = render->image_buf;
#line 770
  image_ix = 0;
#line 771
  i = 0;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i < n_run - 1)) {
#line 771
      goto while_break;
    }
#line 773
    run_x0 = (run + i)->x;
#line 774
    run_x1 = (run + (i + 1))->x;
#line 775
    tmp = (art_u32 )(run + i)->alpha;
#line 776
    if (tmp < 65536U) {
#line 777
      goto __Cont;
    }
#line 779
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 780
    bufptr = image_buf + (run_x0 - x0) * 4;
#line 781
    dstptr = dest + (run_x0 - x0) * 4;
#line 782
    if (run_alpha == 65536U) {
#line 784
      x = run_x0;
      {
#line 784
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 784
        if (! (x < run_x1)) {
#line 784
          goto while_break___0;
        }
#line 786
        src_alpha = (art_u32 )((((int )*(bufptr + 3) << 8) + (int )*(bufptr + 3)) + ((int )*(bufptr + 3) >> 7));
#line 790
        dst_alpha = (art_u32 )((((int )*(dstptr + 3) << 8) + (int )*(dstptr + 3)) + ((int )*(dstptr + 3) >> 7));
#line 794
        dst_mul = dst_alpha * 257U;
#line 796
        if (src_alpha >= 65536U) {
#line 797
          dst_alpha = (art_u32 )65536;
        } else {
#line 799
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 801
        if (dst_alpha == 0U) {
#line 802
          dst_save_mul = (art_u32 )255;
        } else {
#line 804
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 806
        j = 0;
        {
#line 806
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 806
          if (! (j < 3)) {
#line 806
            goto while_break___1;
          }
#line 811
          src = (art_u32 )(((int )*(bufptr + j) << 8) | (int )*(bufptr + j));
#line 812
          dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 813
          tmp___0 = ((dst * (65536U - src_alpha) + 32768U) >> 16) + src;
#line 814
          tmp___0 -= tmp___0 >> 16;
#line 815
          *(dstptr + j) = (art_u8 )((tmp___0 * dst_save_mul + 32768U) >> 16);
#line 806
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 817
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 819
        bufptr += 4;
#line 820
        dstptr += 4;
#line 784
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 825
      x = run_x0;
      {
#line 825
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 825
        if (! (x < run_x1)) {
#line 825
          goto while_break___2;
        }
#line 827
        tmp = run_alpha * (art_u32 )*(bufptr + 3) + 128U;
#line 829
        src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
#line 833
        src_mul = run_alpha * 257U;
#line 835
        tmp = (art_u32 )*(dstptr + 3);
#line 837
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 838
        dst_mul = dst_alpha;
#line 842
        dst_mul *= 257U;
#line 844
        if (src_alpha >= 65536U) {
#line 845
          dst_alpha = (art_u32 )65536;
        } else {
#line 847
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 849
        if (dst_alpha == 0U) {
#line 851
          dst_save_mul = (art_u32 )255;
        } else {
#line 855
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 858
        j = 0;
        {
#line 858
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 858
          if (! (j < 3)) {
#line 858
            goto while_break___3;
          }
#line 863
          src___0 = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 864
          dst___0 = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 865
          tmp___1 = ((dst___0 * (65536U - src_alpha) + 32768U) >> 16) + src___0;
#line 866
          tmp___1 -= tmp___1 >> 16;
#line 867
          *(dstptr + j) = (art_u8 )((tmp___1 * dst_save_mul + 32768U) >> 16);
#line 858
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 869
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 871
        bufptr += 4;
#line 872
        dstptr += 4;
#line 825
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static ArtRenderCallback *art_render_choose_compositing_callback___0(ArtRender *render ) 
{ 


  {
#line 889
  if (render->depth == 8) {
#line 889
    if (render->buf_depth == 8) {
#line 891
      if (render->n_chan == 3) {
#line 891
        if ((unsigned long )render->alpha_buf == (unsigned long )((void *)0)) {
#line 891
          if ((unsigned int )render->alpha_type == 1U) {
#line 895
            if ((unsigned int )render->buf_alpha == 0U) {
#line 896
              return ((ArtRenderCallback *)(& art_render_composite_8_opt1_obj));
            } else
#line 897
            if ((unsigned int )render->buf_alpha == 2U) {
#line 898
              return ((ArtRenderCallback *)(& art_render_composite_8_opt2_obj));
            }
          }
        }
      }
#line 901
      return ((ArtRenderCallback *)(& art_render_composite_8_obj));
    }
  }
#line 903
  return ((ArtRenderCallback *)(& art_render_composite_obj));
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_done___0(ArtRenderCallback *self , ArtRender *render ) 
{ 
  ArtImageSourceSolid *z ;

  {
#line 1176
  z = (ArtImageSourceSolid *)self;
#line 1178
  if ((unsigned long )z->rgbtab != (unsigned long )((void *)0)) {
    {
#line 1179
    art_free((void *)z->rgbtab);
    }
  }
  {
#line 1180
  art_free((void *)self);
  }
#line 1181
  return;
}
}
#line 1183 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8_opaq_init___0(ArtImageSourceSolid *self ,
                                                      ArtRender *render ) 
{ 
  ArtImageSourceSolid *z ;
  ArtPixMaxDepth color_max ;
  int r_fg ;
  int g_fg ;
  int b_fg ;
  int r_bg ;
  int g_bg ;
  int b_bg ;
  int r ;
  int g ;
  int b ;
  int dr ;
  int dg ;
  int db ;
  int i ;
  int tmp ;
  art_u32 *rgbtab ;
  void *tmp___0 ;

  {
  {
#line 1186
  z = self;
#line 1196
  tmp___0 = art_alloc(256UL * sizeof(art_u32 ));
#line 1196
  rgbtab = (art_u32 *)tmp___0;
#line 1197
  z->rgbtab = rgbtab;
#line 1199
  color_max = self->color[0];
#line 1200
  r_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1201
  color_max = self->color[1];
#line 1202
  g_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1203
  color_max = self->color[2];
#line 1204
  b_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1206
  color_max = render->clear_color[0];
#line 1207
  r_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1208
  color_max = render->clear_color[1];
#line 1209
  g_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1210
  color_max = render->clear_color[2];
#line 1211
  b_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1213
  r = (r_bg << 16) + 32768;
#line 1214
  g = (g_bg << 16) + 32768;
#line 1215
  b = (b_bg << 16) + 32768;
#line 1216
  tmp = ((r_fg - r_bg) << 16) + 128;
#line 1217
  dr = (tmp + (tmp >> 8)) >> 8;
#line 1218
  tmp = ((g_fg - g_bg) << 16) + 128;
#line 1219
  dg = (tmp + (tmp >> 8)) >> 8;
#line 1220
  tmp = ((b_fg - b_bg) << 16) + 128;
#line 1221
  db = (tmp + (tmp >> 8)) >> 8;
#line 1223
  i = 0;
  }
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (i < 256)) {
#line 1223
      goto while_break;
    }
#line 1225
    *(rgbtab + i) = (art_u32 )(((r & 16711680) | ((g & 16711680) >> 8)) | (b >> 16));
#line 1226
    r += dr;
#line 1227
    g += dg;
#line 1228
    b += db;
#line 1223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1230
  return;
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8_opaq___0(ArtRenderCallback *self , ArtRender *render ,
                                                 art_u8 *dest , int y ) 
{ 
  ArtImageSourceSolid *z ;
  ArtRenderMaskRun *run ;
  int n_run ;
  art_u32 *rgbtab ;
  art_u32 rgb ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  int i ;
  int ix ;

  {
#line 1236
  z = (ArtImageSourceSolid *)self;
#line 1237
  run = render->run;
#line 1238
  n_run = render->n_run;
#line 1239
  rgbtab = z->rgbtab;
#line 1241
  x0 = render->x0;
#line 1242
  x1 = render->x1;
#line 1247
  if (n_run > 0) {
#line 1249
    run_x1 = (run + 0)->x;
#line 1250
    if (run_x1 > x0) {
      {
#line 1252
      rgb = *(rgbtab + 0);
#line 1253
      art_rgb_fill_run(dest, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U), (art_u8 )(rgb & 255U),
                       run_x1 - x0);
      }
    }
#line 1257
    i = 0;
    {
#line 1257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1257
      if (! (i < n_run - 1)) {
#line 1257
        goto while_break;
      }
#line 1259
      run_x0 = run_x1;
#line 1260
      run_x1 = (run + (i + 1))->x;
#line 1261
      rgb = *(rgbtab + (((run + i)->alpha >> 16) & 255));
#line 1262
      ix = (run_x0 - x0) * 3;
#line 1265
      if (run_x1 - run_x0 == 1) {
#line 1267
        *(dest + ix) = (art_u8 )(rgb >> 16);
#line 1268
        *(dest + (ix + 1)) = (art_u8 )((rgb >> 8) & 255U);
#line 1269
        *(dest + (ix + 2)) = (art_u8 )(rgb & 255U);
      } else {
        {
#line 1273
        art_rgb_fill_run(dest + ix, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                         (art_u8 )(rgb & 255U), run_x1 - run_x0);
        }
      }
#line 1257
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1286
    run_x1 = x0;
  }
#line 1288
  if (run_x1 < x1) {
    {
#line 1290
    rgb = *(rgbtab + 0);
#line 1291
    art_rgb_fill_run(dest + (run_x1 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                     (art_u8 )(rgb & 255U), x1 - run_x1);
    }
  }
#line 1295
  return;
}
}
#line 1297 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8___0(ArtRenderCallback *self , ArtRender *render ,
                                            art_u8 *dest , int y ) 
{ 
  ArtImageSourceSolid *z ;
  int width ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  ArtPixMaxDepth color_max ;

  {
#line 1301
  z = (ArtImageSourceSolid *)self;
#line 1302
  width = render->x1 - render->x0;
#line 1307
  if (z->init) {
#line 1308
    return;
  }
  {
#line 1309
  z->init = 1;
#line 1311
  color_max = z->color[0];
#line 1312
  r = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1313
  color_max = z->color[1];
#line 1314
  g = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1315
  color_max = z->color[2];
#line 1316
  b = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1318
  art_rgb_fill_run(render->image_buf, r, g, b, width);
  }
#line 1319
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void (*render_cbk___0)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                              int y )  ;
#line 1321 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_negotiate___0(ArtImageSource *self , ArtRender *render ,
                                                 ArtImageSourceFlags *p_flags , int *p_buf_depth ,
                                                 ArtAlphaType *p_alpha ) 
{ 
  ArtImageSourceSolid *z ;
  ArtImageSourceFlags flags ;

  {
#line 1326
  z = (ArtImageSourceSolid *)self;
#line 1327
  flags = (ArtImageSourceFlags )0;
#line 1331
  render_cbk___0 = (void (*)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                             int y ))((void *)0);
#line 1333
  if (render->depth == 8) {
#line 1333
    if (render->n_chan == 3) {
#line 1333
      if ((unsigned int )render->alpha_type == 0U) {
#line 1336
        if (render->clear) {
          {
#line 1338
          render_cbk___0 = & art_render_image_solid_rgb8_opaq___0;
#line 1339
          flags = (ArtImageSourceFlags )((unsigned int )flags | 3U);
#line 1340
          art_render_image_solid_rgb8_opaq_init___0(z, render);
          }
        }
      }
    }
  }
#line 1343
  if ((unsigned long )render_cbk___0 == (unsigned long )((void *)0)) {
#line 1345
    if (render->depth == 8) {
#line 1347
      render_cbk___0 = & art_render_image_solid_rgb8___0;
#line 1348
      *p_buf_depth = 8;
#line 1349
      *p_alpha = (ArtAlphaType )0;
    }
  }
#line 1353
  self->super.render = render_cbk___0;
#line 1354
  *p_flags = flags;
#line 1355
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath.c"
static void reverse_points___0(ArtPoint *points , int n_points ) 
{ 
  int i ;
  ArtPoint tmp_p ;

  {
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < n_points >> 1)) {
#line 41
      goto while_break;
    }
#line 43
    tmp_p = *(points + i);
#line 44
    *(points + i) = *(points + (n_points - (i + 1)));
#line 45
    *(points + (n_points - (i + 1))) = tmp_p;
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
static int art_ftoa___0(char *str , double x ) 
{ 
  char *p ;
  int i ;
  int j ;
  double tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int ix ;
  char *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;

  {
  {
#line 113
  p = (char *)str;
#line 116
  p = (char *)str;
#line 117
  tmp = fabs(x);
  }
#line 117
  if (tmp < 1e-6 / (double )2) {
    {
#line 119
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"0");
    }
#line 120
    return (1);
  }
#line 122
  if (x < (double )0) {
#line 124
    tmp___0 = p;
#line 124
    p ++;
#line 124
    *tmp___0 = (char )'-';
#line 125
    x = - x;
  }
  {
#line 127
  tmp___9 = floor((double )(x + 1e-6 / (double )2 < (double )1));
  }
#line 127
  if ((int )tmp___9) {
    {
#line 129
    tmp___1 = p;
#line 129
    p ++;
#line 129
    *tmp___1 = (char )'0';
#line 130
    tmp___2 = p;
#line 130
    p ++;
#line 130
    *tmp___2 = (char )'.';
#line 131
    tmp___3 = floor((x + 1e-6 / (double )2) * 1e6);
#line 131
    i = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%06d",
                (int )tmp___3);
    }
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (i) {
#line 132
        if (! ((int )*(p + (i - 1)) == 48)) {
#line 132
          goto while_break;
        }
      } else {
#line 132
        goto while_break;
      }
#line 133
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 134
    if (i == 0) {
#line 135
      i --;
    }
#line 136
    p += i;
  } else
#line 138
  if (x < 1e6) {
    {
#line 140
    tmp___4 = floor(x + 1e-6 / (double )2);
#line 140
    i = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d",
                (int )tmp___4);
#line 141
    p += i;
    }
#line 142
    if (i < 6) {
      {
#line 146
      tmp___5 = p;
#line 146
      p ++;
#line 146
      *tmp___5 = (char )'.';
#line 147
      tmp___6 = floor(x + 1e-6 / (double )2);
#line 147
      x -= tmp___6;
#line 148
      j = i;
      }
      {
#line 148
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 148
        if (! (j < 6)) {
#line 148
          goto while_break___0;
        }
#line 149
        x *= (double )10;
#line 148
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 150
      tmp___7 = floor(x + 0.5);
#line 150
      ix = (int )tmp___7;
#line 152
      j = 0;
      }
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 152
        if (! (j < i)) {
#line 152
          goto while_break___1;
        }
#line 153
        ix *= 10;
#line 152
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 157
      if (ix == 1000000) {
#line 158
        ix = 999999;
      }
      {
#line 160
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%06d",
              ix);
#line 161
      i = 6 - i;
      }
      {
#line 162
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 162
        if (i) {
#line 162
          if (! ((int )*(p + (i - 1)) == 48)) {
#line 162
            goto while_break___2;
          }
        } else {
#line 162
          goto while_break___2;
        }
#line 163
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 164
      if (i == 0) {
#line 165
        i --;
      }
#line 166
      p += i;
    }
  } else {
    {
#line 170
    tmp___8 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%g",
                      x);
#line 170
    p += tmp___8;
    }
  }
#line 172
  *p = (char )'\000';
#line 173
  return ((int )(p - (char *)str));
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_bpath.c"
static void art_vpath_render_bez___0(ArtVpath **p_vpath , int *pn , int *pn_max ,
                                     double x0 , double y0___0 , double x1 , double y1___0 ,
                                     double x2 , double y2 , double x3 , double y3 ,
                                     double flatness ) 
{ 
  double x3_0 ;
  double y3_0 ;
  double z3_0_dot ;
  double z1_dot ;
  double z2_dot ;
  double z1_perp ;
  double z2_perp ;
  double max_perp_sq ;
  double x_m ;
  double y_m ;
  double xa1 ;
  double ya1 ;
  double xa2 ;
  double ya2 ;
  double xb1 ;
  double yb1 ;
  double xb2 ;
  double yb2 ;
  double tmp ;
  double tmp___0 ;

  {
#line 161
  x3_0 = x3 - x0;
#line 162
  y3_0 = y3 - y0___0;
#line 165
  z3_0_dot = x3_0 * x3_0 + y3_0 * y3_0;
#line 167
  if (z3_0_dot < 0.001) {
    {
#line 174
    tmp = hypot(x1 - x0, y1___0 - y0___0);
    }
#line 174
    if (tmp < 0.001) {
      {
#line 174
      tmp___0 = hypot(x2 - x0, y2 - y0___0);
      }
#line 174
      if (tmp___0 < 0.001) {
#line 176
        goto nosubdivide;
      } else {
#line 178
        goto subdivide;
      }
    } else {
#line 178
      goto subdivide;
    }
  }
#line 192
  max_perp_sq = (flatness * flatness) * z3_0_dot;
#line 194
  z1_perp = (y1___0 - y0___0) * x3_0 - (x1 - x0) * y3_0;
#line 195
  if (z1_perp * z1_perp > max_perp_sq) {
#line 196
    goto subdivide;
  }
#line 198
  z2_perp = (y3 - y2) * x3_0 - (x3 - x2) * y3_0;
#line 199
  if (z2_perp * z2_perp > max_perp_sq) {
#line 200
    goto subdivide;
  }
#line 202
  z1_dot = (x1 - x0) * x3_0 + (y1___0 - y0___0) * y3_0;
#line 203
  if (z1_dot < (double )0) {
#line 203
    if (z1_dot * z1_dot > max_perp_sq) {
#line 204
      goto subdivide;
    }
  }
#line 206
  z2_dot = (x3 - x2) * x3_0 + (y3 - y2) * y3_0;
#line 207
  if (z2_dot < (double )0) {
#line 207
    if (z2_dot * z2_dot > max_perp_sq) {
#line 208
      goto subdivide;
    }
  }
#line 210
  if (z1_dot + z1_dot > z3_0_dot) {
#line 211
    goto subdivide;
  }
#line 213
  if (z2_dot + z2_dot > z3_0_dot) {
#line 214
    goto subdivide;
  }
  nosubdivide: 
  {
#line 219
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, x3, y3);
  }
#line 221
  return;
  subdivide: 
  {
#line 225
  xa1 = (x0 + x1) * 0.5;
#line 226
  ya1 = (y0___0 + y1___0) * 0.5;
#line 227
  xa2 = ((x0 + (double )2 * x1) + x2) * 0.25;
#line 228
  ya2 = ((y0___0 + (double )2 * y1___0) + y2) * 0.25;
#line 229
  xb1 = ((x1 + (double )2 * x2) + x3) * 0.25;
#line 230
  yb1 = ((y1___0 + (double )2 * y2) + y3) * 0.25;
#line 231
  xb2 = (x2 + x3) * 0.5;
#line 232
  yb2 = (y2 + y3) * 0.5;
#line 233
  x_m = (xa2 + xb1) * 0.5;
#line 234
  y_m = (ya2 + yb1) * 0.5;
#line 239
  art_vpath_render_bez___0(p_vpath, pn, pn_max, x0, y0___0, xa1, ya1, xa2, ya2, x_m,
                           y_m, flatness);
#line 241
  art_vpath_render_bez___0(p_vpath, pn, pn_max, x_m, y_m, xb1, yb1, xb2, yb2, x3,
                           y3, flatness);
  }
#line 243
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
static ArtSVP *art_svp_merge___0(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp_new ;
  int ix ;
  int ix1 ;
  int ix2 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 62
  tmp = art_alloc(sizeof(ArtSVP ) + (unsigned long )((svp1->n_segs + svp2->n_segs) - 1) * sizeof(ArtSVPSeg ));
#line 62
  svp_new = (ArtSVP *)tmp;
#line 65
  ix1 = 0;
#line 66
  ix2 = 0;
#line 67
  ix = 0;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (ix < (int )(svp1->n_segs + svp2->n_segs))) {
#line 67
      goto while_break;
    }
#line 69
    if (ix1 < (int )svp1->n_segs) {
#line 69
      if (ix2 == (int )svp2->n_segs) {
#line 72
        tmp___0 = ix1;
#line 72
        ix1 ++;
#line 72
        svp_new->segs[ix] = svp1->segs[tmp___0];
      } else {
        {
#line 69
        tmp___2 = art_svp_seg_compare((void const   *)(& svp1->segs[ix1]), (void const   *)(& svp2->segs[ix2]));
        }
#line 69
        if (tmp___2 < 1) {
#line 72
          tmp___0 = ix1;
#line 72
          ix1 ++;
#line 72
          svp_new->segs[ix] = svp1->segs[tmp___0];
        } else {
#line 74
          tmp___1 = ix2;
#line 74
          ix2 ++;
#line 74
          svp_new->segs[ix] = svp2->segs[tmp___1];
        }
      }
    } else {
#line 74
      tmp___1 = ix2;
#line 74
      ix2 ++;
#line 74
      svp_new->segs[ix] = svp2->segs[tmp___1];
    }
#line 67
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  svp_new->n_segs = ix;
#line 78
  return (svp_new);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void art_svp_vpath_stroke_arc___0(ArtVpath **p_vpath , int *pn , int *pn_max ,
                                         double xc , double yc , double x0 , double y0___0 ,
                                         double x1 , double y1___0 , double radius ,
                                         double flatness ) 
{ 
  double theta ;
  double th_0 ;
  double th_1 ;
  int n_pts ;
  int i ;
  double aradius ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 64
  aradius = fabs(radius);
#line 65
  tmp = sqrt(flatness / aradius);
#line 65
  theta = ((double )2 * 1.41421356237309504880) * tmp;
#line 66
  th_0 = atan2(y0___0, x0);
#line 67
  th_1 = atan2(y1___0, x1);
  }
#line 68
  if (radius > (double )0) {
#line 71
    if (th_0 < th_1) {
#line 71
      th_0 += 3.14159265358979323846 * (double )2;
    }
    {
#line 72
    tmp___0 = ceil((th_0 - th_1) / theta);
#line 72
    n_pts = (int )tmp___0;
    }
  } else {
#line 77
    if (th_1 < th_0) {
#line 77
      th_1 += 3.14159265358979323846 * (double )2;
    }
    {
#line 78
    tmp___1 = ceil((th_1 - th_0) / theta);
#line 78
    n_pts = (int )tmp___1;
    }
  }
  {
#line 83
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + x0, yc + y0___0);
#line 85
  i = 1;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < n_pts)) {
#line 85
      goto while_break;
    }
    {
#line 87
    theta = th_0 + ((th_1 - th_0) * (double )i) / (double )n_pts;
#line 88
    tmp___2 = sin(theta);
#line 88
    tmp___3 = cos(theta);
#line 88
    art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + tmp___3 * aradius,
                        yc + tmp___2 * aradius);
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + x1, yc + y1___0);
  }
#line 100
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void render_seg___0(ArtVpath **p_forw , int *pn_forw , int *pn_forw_max , ArtVpath **p_rev ,
                           int *pn_rev , int *pn_rev_max , ArtVpath *vpath , int i0 ,
                           int i1 , int i2 , ArtPathStrokeJoinType join , double line_width ,
                           double miter_limit , double flatness ) 
{ 
  double dx0 ;
  double dy0 ;
  double dx1 ;
  double dy1 ;
  double dlx0 ;
  double dly0 ;
  double dlx1 ;
  double dly1 ;
  double dmx ;
  double dmy ;
  double dmr2 ;
  double scale ;
  double cross ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 136
  dx0 = (vpath + i1)->x - (vpath + i0)->x;
#line 137
  dy0 = (vpath + i1)->y - (vpath + i0)->y;
#line 139
  dx1 = (vpath + i2)->x - (vpath + i1)->x;
#line 140
  dy1 = (vpath + i2)->y - (vpath + i1)->y;
#line 144
  tmp = sqrt(dx0 * dx0 + dy0 * dy0);
#line 144
  scale = line_width / tmp;
#line 145
  dlx0 = dy0 * scale;
#line 146
  dly0 = - dx0 * scale;
#line 150
  tmp___0 = sqrt(dx1 * dx1 + dy1 * dy1);
#line 150
  scale = line_width / tmp___0;
#line 151
  dlx1 = dy1 * scale;
#line 152
  dly1 = - dx1 * scale;
#line 171
  cross = dx1 * dy0 - dx0 * dy1;
#line 173
  dmx = (dlx0 + dlx1) * 0.5;
#line 174
  dmy = (dly0 + dly1) * 0.5;
#line 175
  dmr2 = dmx * dmx + dmy * dmy;
  }
#line 177
  if ((unsigned int )join == 0U) {
#line 177
    if ((dmr2 * miter_limit) * miter_limit < line_width * line_width) {
#line 179
      join = (ArtPathStrokeJoinType )2;
    }
  }
#line 186
  if (dmr2 > 1e-12) {
#line 188
    scale = (line_width * line_width) / dmr2;
#line 189
    dmx *= scale;
#line 190
    dmy *= scale;
  }
#line 193
  if (cross * cross < 1e-12) {
#line 193
    if (dx0 * dx1 + dy0 * dy1 >= (double )0) {
      {
#line 199
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 201
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
      }
    } else {
#line 193
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 204
  if (cross > (double )0) {
#line 211
    if (dmr2 > 1e-12) {
#line 211
      if ((dx0 + dmx) * dx0 + (dy0 + dmy) * dy0 > (double )0) {
#line 211
        if ((dx1 - dmx) * dx1 + (dy1 - dmy) * dy1 > (double )0) {
          {
#line 230
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dmx,
                              (vpath + i1)->y + dmy);
          }
        } else {
          {
#line 236
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                              (vpath + i1)->y + dly0);
#line 238
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                              (vpath + i1)->y);
#line 240
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                              (vpath + i1)->y + dly1);
          }
        }
      } else {
        {
#line 236
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                            (vpath + i1)->y + dly0);
#line 238
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                            (vpath + i1)->y);
#line 240
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                            (vpath + i1)->y + dly1);
        }
      }
    } else {
      {
#line 236
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
#line 238
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                          (vpath + i1)->y);
#line 240
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                          (vpath + i1)->y + dly1);
      }
    }
#line 244
    if ((unsigned int )join == 2U) {
      {
#line 247
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 249
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                          (vpath + i1)->y - dly1);
      }
    } else
#line 252
    if ((unsigned int )join == 0U) {
      {
#line 254
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dmx,
                          (vpath + i1)->y - dmy);
      }
    } else
#line 257
    if ((unsigned int )join == 1U) {
      {
#line 258
      art_svp_vpath_stroke_arc___0(p_forw, pn_forw, pn_forw_max, (vpath + i1)->x,
                                   (vpath + i1)->y, - dlx0, - dly0, - dlx1, - dly1,
                                   line_width, flatness);
      }
    }
  } else {
#line 272
    if (dmr2 > 1e-12) {
#line 272
      if ((dx0 - dmx) * dx0 + (dy0 - dmy) * dy0 > (double )0) {
#line 272
        if ((dx1 + dmx) * dx1 + (dy1 + dmy) * dy1 > (double )0) {
          {
#line 291
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dmx,
                              (vpath + i1)->y - dmy);
          }
        } else {
          {
#line 297
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                              (vpath + i1)->y - dly0);
#line 299
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                              (vpath + i1)->y);
#line 301
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                              (vpath + i1)->y - dly1);
          }
        }
      } else {
        {
#line 297
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                            (vpath + i1)->y - dly0);
#line 299
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                            (vpath + i1)->y);
#line 301
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                            (vpath + i1)->y - dly1);
        }
      }
    } else {
      {
#line 297
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 299
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                          (vpath + i1)->y);
#line 301
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                          (vpath + i1)->y - dly1);
      }
    }
#line 305
    if ((unsigned int )join == 2U) {
      {
#line 308
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
#line 310
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                          (vpath + i1)->y + dly1);
      }
    } else
#line 313
    if ((unsigned int )join == 0U) {
      {
#line 315
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dmx,
                          (vpath + i1)->y + dmy);
      }
    } else
#line 318
    if ((unsigned int )join == 1U) {
      {
#line 319
      art_svp_vpath_stroke_arc___0(p_rev, pn_rev, pn_rev_max, (vpath + i1)->x, (vpath + i1)->y,
                                   dlx0, dly0, dlx1, dly1, - line_width, flatness);
      }
    }
  }
#line 327
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void render_cap___0(ArtVpath **p_result , int *pn_result , int *pn_result_max ,
                           ArtVpath *vpath , int i0 , int i1 , ArtPathStrokeCapType cap ,
                           double line_width , double flatness ) 
{ 
  double dx0 ;
  double dy0 ;
  double dlx0 ;
  double dly0 ;
  double scale ;
  int n_pts ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double theta ;
  double c_th ;
  double s_th ;

  {
  {
#line 341
  dx0 = (vpath + i1)->x - (vpath + i0)->x;
#line 342
  dy0 = (vpath + i1)->y - (vpath + i0)->y;
#line 346
  tmp = sqrt(dx0 * dx0 + dy0 * dy0);
#line 346
  scale = line_width / tmp;
#line 347
  dlx0 = dy0 * scale;
#line 348
  dly0 = - dx0 * scale;
  }
  {
#line 356
  if ((unsigned int )cap == 0U) {
#line 356
    goto case_0;
  }
#line 362
  if ((unsigned int )cap == 1U) {
#line 362
    goto case_1;
  }
#line 381
  if ((unsigned int )cap == 2U) {
#line 381
    goto case_2;
  }
#line 354
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 357
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                      (vpath + i1)->y - dly0);
#line 359
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                      (vpath + i1)->y + dly0);
  }
#line 361
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 363
  tmp___0 = sqrt(flatness / line_width);
#line 363
  tmp___1 = ceil(3.14159265358979323846 / ((2.0 * 1.41421356237309504880) * tmp___0));
#line 363
  n_pts = (int )tmp___1;
#line 364
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                      (vpath + i1)->y - dly0);
#line 366
  i = 1;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (i < n_pts)) {
#line 366
      goto while_break;
    }
    {
#line 370
    theta = (3.14159265358979323846 * (double )i) / (double )n_pts;
#line 371
    c_th = cos(theta);
#line 372
    s_th = sin(theta);
#line 373
    art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x - dlx0 * c_th) - dly0 * s_th,
                        ((vpath + i1)->y - dly0 * c_th) + dlx0 * s_th);
#line 366
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                      (vpath + i1)->y + dly0);
  }
#line 380
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 382
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x - dlx0) - dly0,
                      ((vpath + i1)->y - dly0) + dlx0);
#line 386
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x + dlx0) - dly0,
                      ((vpath + i1)->y + dly0) + dlx0);
  }
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
static void art_pixel_destroy___0(void *func_data , void *data ) 
{ 


  {
  {
#line 163
  art_free(data);
  }
#line 164
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_callback___0(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                     int n_steps ) 
{ 
  ArtRgbSVPData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  art_u32 rgb ;
  int x0 ;
  int x1 ;
  int k ;

  {
#line 51
  data = (ArtRgbSVPData *)callback_data;
#line 54
  running_sum = (art_u32 )start;
#line 59
  linebuf = data->buf;
#line 60
  x0 = data->x0;
#line 61
  x1 = data->x1;
#line 63
  if (n_steps > 0) {
#line 65
    run_x1 = (steps + 0)->x;
#line 66
    if (run_x1 > x0) {
      {
#line 68
      rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 69
      art_rgb_fill_run(linebuf, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                       (art_u8 )(rgb & 255U), run_x1 - x0);
      }
    }
#line 74
    k = 0;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! (k < n_steps - 1)) {
#line 74
        goto while_break;
      }
#line 76
      running_sum += (art_u32 )(steps + k)->delta;
#line 77
      run_x0 = run_x1;
#line 78
      run_x1 = (steps + (k + 1))->x;
#line 79
      if (run_x1 > run_x0) {
        {
#line 81
        rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 82
        art_rgb_fill_run(linebuf + (run_x0 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                         (art_u8 )(rgb & 255U), run_x1 - run_x0);
        }
      }
#line 74
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 87
    running_sum += (art_u32 )(steps + k)->delta;
#line 88
    if (x1 > run_x1) {
      {
#line 90
      rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 91
      art_rgb_fill_run(linebuf + (run_x1 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                       (art_u8 )(rgb & 255U), x1 - run_x1);
      }
    }
  } else {
    {
#line 98
    rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 99
    art_rgb_fill_run(linebuf, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                     (art_u8 )(rgb & 255U), x1 - x0);
    }
  }
#line 104
  data->buf += data->rowstride;
#line 105
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_alpha_callback___0(void *callback_data , int y , int start ,
                                           ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtRgbSVPAlphaData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int k ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int *alphatab ;
  int alpha ;

  {
#line 222
  data = (ArtRgbSVPAlphaData *)callback_data;
#line 225
  running_sum = (art_u32 )start;
#line 232
  linebuf = data->buf;
#line 233
  x0 = data->x0;
#line 234
  x1 = data->x1;
#line 236
  r = data->r;
#line 237
  g = data->g;
#line 238
  b = data->b;
#line 239
  alphatab = data->alphatab;
#line 241
  if (n_steps > 0) {
#line 243
    run_x1 = (steps + 0)->x;
#line 244
    if (run_x1 > x0) {
#line 246
      alpha = (int )((running_sum >> 16) & 255U);
#line 247
      if (alpha) {
        {
#line 248
        art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), run_x1 - x0);
        }
      }
    }
#line 253
    k = 0;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (! (k < n_steps - 1)) {
#line 253
        goto while_break;
      }
#line 255
      running_sum += (art_u32 )(steps + k)->delta;
#line 256
      run_x0 = run_x1;
#line 257
      run_x1 = (steps + (k + 1))->x;
#line 258
      if (run_x1 > run_x0) {
#line 260
        alpha = (int )((running_sum >> 16) & 255U);
#line 261
        if (alpha) {
          {
#line 262
          art_rgb_run_alpha(linebuf + (run_x0 - x0) * 3, r, g, b, *(alphatab + alpha),
                            run_x1 - run_x0);
          }
        }
      }
#line 253
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 267
    running_sum += (art_u32 )(steps + k)->delta;
#line 268
    if (x1 > run_x1) {
#line 270
      alpha = (int )((running_sum >> 16) & 255U);
#line 271
      if (alpha) {
        {
#line 272
        art_rgb_run_alpha(linebuf + (run_x1 - x0) * 3, r, g, b, *(alphatab + alpha),
                          x1 - run_x1);
        }
      }
    }
  } else {
#line 279
    alpha = (int )((running_sum >> 16) & 255U);
#line 280
    if (alpha) {
      {
#line 281
      art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), x1 - x0);
      }
    }
  }
#line 286
  data->buf += data->rowstride;
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_alpha_opaque_callback___0(void *callback_data , int y , int start ,
                                                  ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtRgbSVPAlphaData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int k ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int *alphatab ;
  int alpha ;

  {
#line 294
  data = (ArtRgbSVPAlphaData *)callback_data;
#line 297
  running_sum = (art_u32 )start;
#line 304
  linebuf = data->buf;
#line 305
  x0 = data->x0;
#line 306
  x1 = data->x1;
#line 308
  r = data->r;
#line 309
  g = data->g;
#line 310
  b = data->b;
#line 311
  alphatab = data->alphatab;
#line 313
  if (n_steps > 0) {
#line 315
    run_x1 = (steps + 0)->x;
#line 316
    if (run_x1 > x0) {
#line 318
      alpha = (int )(running_sum >> 16);
#line 319
      if (alpha) {
#line 321
        if (alpha >= 255) {
          {
#line 322
          art_rgb_fill_run(linebuf, r, g, b, run_x1 - x0);
          }
        } else {
          {
#line 326
          art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), run_x1 - x0);
          }
        }
      }
    }
#line 332
    k = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (! (k < n_steps - 1)) {
#line 332
        goto while_break;
      }
#line 334
      running_sum += (art_u32 )(steps + k)->delta;
#line 335
      run_x0 = run_x1;
#line 336
      run_x1 = (steps + (k + 1))->x;
#line 337
      if (run_x1 > run_x0) {
#line 339
        alpha = (int )(running_sum >> 16);
#line 340
        if (alpha) {
#line 342
          if (alpha >= 255) {
            {
#line 343
            art_rgb_fill_run(linebuf + (run_x0 - x0) * 3, r, g, b, run_x1 - run_x0);
            }
          } else {
            {
#line 347
            art_rgb_run_alpha(linebuf + (run_x0 - x0) * 3, r, g, b, *(alphatab + alpha),
                              run_x1 - run_x0);
            }
          }
        }
      }
#line 332
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 353
    running_sum += (art_u32 )(steps + k)->delta;
#line 354
    if (x1 > run_x1) {
#line 356
      alpha = (int )(running_sum >> 16);
#line 357
      if (alpha) {
#line 359
        if (alpha >= 255) {
          {
#line 360
          art_rgb_fill_run(linebuf + (run_x1 - x0) * 3, r, g, b, x1 - run_x1);
          }
        } else {
          {
#line 364
          art_rgb_run_alpha(linebuf + (run_x1 - x0) * 3, r, g, b, *(alphatab + alpha),
                            x1 - run_x1);
          }
        }
      }
    }
  } else {
#line 372
    alpha = (int )(running_sum >> 16);
#line 373
    if (alpha) {
#line 375
      if (alpha >= 255) {
        {
#line 376
        art_rgb_fill_run(linebuf, r, g, b, x1 - x0);
        }
      } else {
        {
#line 380
        art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), x1 - x0);
        }
      }
    }
  }
#line 386
  data->buf += data->rowstride;
#line 387
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.c"
static int art_vpath_dash_max_subpath___0(ArtVpath const   *vpath ) 
{ 
  int max_subpath ;
  int i ;
  int start ;

  {
#line 41
  max_subpath = 0;
#line 42
  start = 0;
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! ((unsigned int const   )(vpath + i)->code != 4U)) {
#line 43
      goto while_break;
    }
#line 45
    if ((unsigned int const   )(vpath + i)->code == 0U) {
#line 45
      goto _L;
    } else
#line 45
    if ((unsigned int const   )(vpath + i)->code == 1U) {
      _L: /* CIL Label */ 
#line 47
      if (i - start > max_subpath) {
#line 48
        max_subpath = i - start;
      }
#line 49
      start = i;
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (i - start > max_subpath) {
#line 53
    max_subpath = i - start;
  }
#line 55
  return (max_subpath);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
static void art_gray_svp_callback___0(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                      int n_steps ) 
{ 
  ArtGraySVPData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int k ;

  {
#line 43
  data = (ArtGraySVPData *)callback_data;
#line 46
  running_sum = start;
#line 61
  linebuf = data->buf;
#line 62
  x0 = data->x0;
#line 63
  x1 = data->x1;
#line 65
  if (n_steps > 0) {
#line 67
    run_x1 = (steps + 0)->x;
#line 68
    if (run_x1 > x0) {
      {
#line 69
      memset((void *)linebuf, running_sum >> 16, (size_t )(run_x1 - x0));
      }
    }
#line 71
    k = 0;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (k < n_steps - 1)) {
#line 71
        goto while_break;
      }
#line 73
      running_sum += (steps + k)->delta;
#line 74
      run_x0 = run_x1;
#line 75
      run_x1 = (steps + (k + 1))->x;
#line 76
      if (run_x1 > run_x0) {
        {
#line 77
        memset((void *)((linebuf + run_x0) - x0), running_sum >> 16, (size_t )(run_x1 - run_x0));
        }
      }
#line 71
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 79
    running_sum += (steps + k)->delta;
#line 80
    if (x1 > run_x1) {
      {
#line 81
      memset((void *)((linebuf + run_x1) - x0), running_sum >> 16, (size_t )(x1 - run_x1));
      }
    }
  } else {
    {
#line 85
    memset((void *)linebuf, running_sum >> 16, (size_t )(x1 - x0));
    }
  }
#line 88
  data->buf += data->rowstride;
#line 89
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void art_svp_vpath_stroke_arc___1(ArtVpath **p_vpath , int *pn , int *pn_max ,
                                         double xc , double yc , double x0 , double y0___0 ,
                                         double x1 , double y1___0 , double radius ,
                                         double flatness ) 
{ 
  double theta ;
  double th_0 ;
  double th_1 ;
  int n_pts ;
  int i ;
  double aradius ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  {
#line 64
  aradius = fabs(radius);
#line 65
  tmp = sqrt(flatness / aradius);
#line 65
  theta = ((double )2 * 1.41421356237309504880) * tmp;
#line 66
  th_0 = atan2(y0___0, x0);
#line 67
  th_1 = atan2(y1___0, x1);
  }
#line 68
  if (radius > (double )0) {
#line 71
    if (th_0 < th_1) {
#line 71
      th_0 += 3.14159265358979323846 * (double )2;
    }
    {
#line 72
    tmp___0 = ceil((th_0 - th_1) / theta);
#line 72
    n_pts = (int )tmp___0;
    }
  } else {
#line 77
    if (th_1 < th_0) {
#line 77
      th_1 += 3.14159265358979323846 * (double )2;
    }
    {
#line 78
    tmp___1 = ceil((th_1 - th_0) / theta);
#line 78
    n_pts = (int )tmp___1;
    }
  }
  {
#line 83
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + x0, yc + y0___0);
#line 85
  i = 1;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < n_pts)) {
#line 85
      goto while_break;
    }
    {
#line 87
    theta = th_0 + ((th_1 - th_0) * (double )i) / (double )n_pts;
#line 88
    tmp___2 = sin(theta);
#line 88
    tmp___3 = cos(theta);
#line 88
    art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + tmp___3 * aradius,
                        yc + tmp___2 * aradius);
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, xc + x1, yc + y1___0);
  }
#line 100
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void render_seg___1(ArtVpath **p_forw , int *pn_forw , int *pn_forw_max , ArtVpath **p_rev ,
                           int *pn_rev , int *pn_rev_max , ArtVpath *vpath , int i0 ,
                           int i1 , int i2 , ArtPathStrokeJoinType join , double line_width ,
                           double miter_limit , double flatness ) 
{ 
  double dx0 ;
  double dy0 ;
  double dx1 ;
  double dy1 ;
  double dlx0 ;
  double dly0 ;
  double dlx1 ;
  double dly1 ;
  double dmx ;
  double dmy ;
  double dmr2 ;
  double scale ;
  double cross ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 136
  dx0 = (vpath + i1)->x - (vpath + i0)->x;
#line 137
  dy0 = (vpath + i1)->y - (vpath + i0)->y;
#line 139
  dx1 = (vpath + i2)->x - (vpath + i1)->x;
#line 140
  dy1 = (vpath + i2)->y - (vpath + i1)->y;
#line 144
  tmp = sqrt(dx0 * dx0 + dy0 * dy0);
#line 144
  scale = line_width / tmp;
#line 145
  dlx0 = dy0 * scale;
#line 146
  dly0 = - dx0 * scale;
#line 150
  tmp___0 = sqrt(dx1 * dx1 + dy1 * dy1);
#line 150
  scale = line_width / tmp___0;
#line 151
  dlx1 = dy1 * scale;
#line 152
  dly1 = - dx1 * scale;
#line 171
  cross = dx1 * dy0 - dx0 * dy1;
#line 173
  dmx = (dlx0 + dlx1) * 0.5;
#line 174
  dmy = (dly0 + dly1) * 0.5;
#line 175
  dmr2 = dmx * dmx + dmy * dmy;
  }
#line 177
  if ((unsigned int )join == 0U) {
#line 177
    if ((dmr2 * miter_limit) * miter_limit < line_width * line_width) {
#line 179
      join = (ArtPathStrokeJoinType )2;
    }
  }
#line 186
  if (dmr2 > 1e-12) {
#line 188
    scale = (line_width * line_width) / dmr2;
#line 189
    dmx *= scale;
#line 190
    dmy *= scale;
  }
#line 193
  if (cross * cross < 1e-12) {
#line 193
    if (dx0 * dx1 + dy0 * dy1 >= (double )0) {
      {
#line 199
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 201
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
      }
    } else {
#line 193
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 204
  if (cross > (double )0) {
#line 211
    if (dmr2 > 1e-12) {
#line 211
      if ((dx0 + dmx) * dx0 + (dy0 + dmy) * dy0 > (double )0) {
#line 211
        if ((dx1 - dmx) * dx1 + (dy1 - dmy) * dy1 > (double )0) {
          {
#line 230
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dmx,
                              (vpath + i1)->y + dmy);
          }
        } else {
          {
#line 236
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                              (vpath + i1)->y + dly0);
#line 238
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                              (vpath + i1)->y);
#line 240
          art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                              (vpath + i1)->y + dly1);
          }
        }
      } else {
        {
#line 236
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                            (vpath + i1)->y + dly0);
#line 238
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                            (vpath + i1)->y);
#line 240
        art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                            (vpath + i1)->y + dly1);
        }
      }
    } else {
      {
#line 236
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
#line 238
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x,
                          (vpath + i1)->y);
#line 240
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                          (vpath + i1)->y + dly1);
      }
    }
#line 244
    if ((unsigned int )join == 2U) {
      {
#line 247
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 249
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                          (vpath + i1)->y - dly1);
      }
    } else
#line 252
    if ((unsigned int )join == 0U) {
      {
#line 254
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dmx,
                          (vpath + i1)->y - dmy);
      }
    } else
#line 257
    if ((unsigned int )join == 1U) {
      {
#line 258
      art_svp_vpath_stroke_arc___1(p_forw, pn_forw, pn_forw_max, (vpath + i1)->x,
                                   (vpath + i1)->y, - dlx0, - dly0, - dlx1, - dly1,
                                   line_width, flatness);
      }
    }
  } else {
#line 272
    if (dmr2 > 1e-12) {
#line 272
      if ((dx0 - dmx) * dx0 + (dy0 - dmy) * dy0 > (double )0) {
#line 272
        if ((dx1 + dmx) * dx1 + (dy1 + dmy) * dy1 > (double )0) {
          {
#line 291
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dmx,
                              (vpath + i1)->y - dmy);
          }
        } else {
          {
#line 297
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                              (vpath + i1)->y - dly0);
#line 299
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                              (vpath + i1)->y);
#line 301
          art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                              (vpath + i1)->y - dly1);
          }
        }
      } else {
        {
#line 297
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                            (vpath + i1)->y - dly0);
#line 299
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                            (vpath + i1)->y);
#line 301
        art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                            (vpath + i1)->y - dly1);
        }
      }
    } else {
      {
#line 297
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                          (vpath + i1)->y - dly0);
#line 299
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x,
                          (vpath + i1)->y);
#line 301
      art_vpath_add_point(p_forw, pn_forw, pn_forw_max, (ArtPathcode )3, (vpath + i1)->x - dlx1,
                          (vpath + i1)->y - dly1);
      }
    }
#line 305
    if ((unsigned int )join == 2U) {
      {
#line 308
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                          (vpath + i1)->y + dly0);
#line 310
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dlx1,
                          (vpath + i1)->y + dly1);
      }
    } else
#line 313
    if ((unsigned int )join == 0U) {
      {
#line 315
      art_vpath_add_point(p_rev, pn_rev, pn_rev_max, (ArtPathcode )3, (vpath + i1)->x + dmx,
                          (vpath + i1)->y + dmy);
      }
    } else
#line 318
    if ((unsigned int )join == 1U) {
      {
#line 319
      art_svp_vpath_stroke_arc___1(p_rev, pn_rev, pn_rev_max, (vpath + i1)->x, (vpath + i1)->y,
                                   dlx0, dly0, dlx1, dly1, - line_width, flatness);
      }
    }
  }
#line 327
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath_stroke.c"
static void render_cap___1(ArtVpath **p_result , int *pn_result , int *pn_result_max ,
                           ArtVpath *vpath , int i0 , int i1 , ArtPathStrokeCapType cap ,
                           double line_width , double flatness ) 
{ 
  double dx0 ;
  double dy0 ;
  double dlx0 ;
  double dly0 ;
  double scale ;
  int n_pts ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double theta ;
  double c_th ;
  double s_th ;

  {
  {
#line 341
  dx0 = (vpath + i1)->x - (vpath + i0)->x;
#line 342
  dy0 = (vpath + i1)->y - (vpath + i0)->y;
#line 346
  tmp = sqrt(dx0 * dx0 + dy0 * dy0);
#line 346
  scale = line_width / tmp;
#line 347
  dlx0 = dy0 * scale;
#line 348
  dly0 = - dx0 * scale;
  }
  {
#line 356
  if ((unsigned int )cap == 0U) {
#line 356
    goto case_0;
  }
#line 362
  if ((unsigned int )cap == 1U) {
#line 362
    goto case_1;
  }
#line 381
  if ((unsigned int )cap == 2U) {
#line 381
    goto case_2;
  }
#line 354
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 357
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                      (vpath + i1)->y - dly0);
#line 359
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                      (vpath + i1)->y + dly0);
  }
#line 361
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 363
  tmp___0 = sqrt(flatness / line_width);
#line 363
  tmp___1 = ceil(3.14159265358979323846 / ((2.0 * 1.41421356237309504880) * tmp___0));
#line 363
  n_pts = (int )tmp___1;
#line 364
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x - dlx0,
                      (vpath + i1)->y - dly0);
#line 366
  i = 1;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (i < n_pts)) {
#line 366
      goto while_break;
    }
    {
#line 370
    theta = (3.14159265358979323846 * (double )i) / (double )n_pts;
#line 371
    c_th = cos(theta);
#line 372
    s_th = sin(theta);
#line 373
    art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x - dlx0 * c_th) - dly0 * s_th,
                        ((vpath + i1)->y - dly0 * c_th) + dlx0 * s_th);
#line 366
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, (vpath + i1)->x + dlx0,
                      (vpath + i1)->y + dly0);
  }
#line 380
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 382
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x - dlx0) - dly0,
                      ((vpath + i1)->y - dly0) + dlx0);
#line 386
  art_vpath_add_point(p_result, pn_result, pn_result_max, (ArtPathcode )3, ((vpath + i1)->x + dlx0) - dly0,
                      ((vpath + i1)->y + dly0) + dlx0);
  }
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_bpath.c"
static void art_vpath_render_bez___1(ArtVpath **p_vpath , int *pn , int *pn_max ,
                                     double x0 , double y0___0 , double x1 , double y1___0 ,
                                     double x2 , double y2 , double x3 , double y3 ,
                                     double flatness ) 
{ 
  double x3_0 ;
  double y3_0 ;
  double z3_0_dot ;
  double z1_dot ;
  double z2_dot ;
  double z1_perp ;
  double z2_perp ;
  double max_perp_sq ;
  double x_m ;
  double y_m ;
  double xa1 ;
  double ya1 ;
  double xa2 ;
  double ya2 ;
  double xb1 ;
  double yb1 ;
  double xb2 ;
  double yb2 ;
  double tmp ;
  double tmp___0 ;

  {
#line 161
  x3_0 = x3 - x0;
#line 162
  y3_0 = y3 - y0___0;
#line 165
  z3_0_dot = x3_0 * x3_0 + y3_0 * y3_0;
#line 167
  if (z3_0_dot < 0.001) {
    {
#line 174
    tmp = hypot(x1 - x0, y1___0 - y0___0);
    }
#line 174
    if (tmp < 0.001) {
      {
#line 174
      tmp___0 = hypot(x2 - x0, y2 - y0___0);
      }
#line 174
      if (tmp___0 < 0.001) {
#line 176
        goto nosubdivide;
      } else {
#line 178
        goto subdivide;
      }
    } else {
#line 178
      goto subdivide;
    }
  }
#line 192
  max_perp_sq = (flatness * flatness) * z3_0_dot;
#line 194
  z1_perp = (y1___0 - y0___0) * x3_0 - (x1 - x0) * y3_0;
#line 195
  if (z1_perp * z1_perp > max_perp_sq) {
#line 196
    goto subdivide;
  }
#line 198
  z2_perp = (y3 - y2) * x3_0 - (x3 - x2) * y3_0;
#line 199
  if (z2_perp * z2_perp > max_perp_sq) {
#line 200
    goto subdivide;
  }
#line 202
  z1_dot = (x1 - x0) * x3_0 + (y1___0 - y0___0) * y3_0;
#line 203
  if (z1_dot < (double )0) {
#line 203
    if (z1_dot * z1_dot > max_perp_sq) {
#line 204
      goto subdivide;
    }
  }
#line 206
  z2_dot = (x3 - x2) * x3_0 + (y3 - y2) * y3_0;
#line 207
  if (z2_dot < (double )0) {
#line 207
    if (z2_dot * z2_dot > max_perp_sq) {
#line 208
      goto subdivide;
    }
  }
#line 210
  if (z1_dot + z1_dot > z3_0_dot) {
#line 211
    goto subdivide;
  }
#line 213
  if (z2_dot + z2_dot > z3_0_dot) {
#line 214
    goto subdivide;
  }
  nosubdivide: 
  {
#line 219
  art_vpath_add_point(p_vpath, pn, pn_max, (ArtPathcode )3, x3, y3);
  }
#line 221
  return;
  subdivide: 
  {
#line 225
  xa1 = (x0 + x1) * 0.5;
#line 226
  ya1 = (y0___0 + y1___0) * 0.5;
#line 227
  xa2 = ((x0 + (double )2 * x1) + x2) * 0.25;
#line 228
  ya2 = ((y0___0 + (double )2 * y1___0) + y2) * 0.25;
#line 229
  xb1 = ((x1 + (double )2 * x2) + x3) * 0.25;
#line 230
  yb1 = ((y1___0 + (double )2 * y2) + y3) * 0.25;
#line 231
  xb2 = (x2 + x3) * 0.5;
#line 232
  yb2 = (y2 + y3) * 0.5;
#line 233
  x_m = (xa2 + xb1) * 0.5;
#line 234
  y_m = (ya2 + yb1) * 0.5;
#line 239
  art_vpath_render_bez___1(p_vpath, pn, pn_max, x0, y0___0, xa1, ya1, xa2, ya2, x_m,
                           y_m, flatness);
#line 241
  art_vpath_render_bez___1(p_vpath, pn, pn_max, x_m, y_m, xb1, yb1, xb2, yb2, x3,
                           y3, flatness);
  }
#line 243
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
static void art_svp_render_insert_active___1(int i , int *active_segs , int n_active_segs ,
                                             artfloat *seg_x , artfloat *seg_dx ) 
{ 
  int j ;
  artfloat x ;
  int tmp1 ;
  int tmp2 ;

  {
#line 60
  x = *(seg_x + i) + 0.001 * *(seg_dx + i);
#line 61
  j = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (j < n_active_segs) {
#line 61
      if (! (*(seg_x + *(active_segs + j)) < x)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
#line 61
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  tmp1 = i;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (! (j < n_active_segs)) {
#line 64
      goto while_break___0;
    }
#line 66
    tmp2 = *(active_segs + j);
#line 67
    *(active_segs + j) = tmp1;
#line 68
    tmp1 = tmp2;
#line 69
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  *(active_segs + j) = tmp1;
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_render_aa.c"
static void art_svp_render_delete_active___1(int *active_segs , int j , int n_active_segs ) 
{ 
  int k ;

  {
#line 79
  k = j;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (k < n_active_segs)) {
#line 79
      goto while_break;
    }
#line 80
    *(active_segs + k) = *(active_segs + (k + 1));
#line 79
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_rgba_gradient_run___1(art_u8 *buf , art_u8 *color1 , art_u8 *color2 ,
                                      int len ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int a ;
  int dr ;
  int dg ;
  int db ;
  int da ;
  art_u8 *tmp ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;

  {
#line 108
  r = ((int )*(color1 + 0) << 16) + 32768;
#line 109
  g = ((int )*(color1 + 1) << 16) + 32768;
#line 110
  b = ((int )*(color1 + 2) << 16) + 32768;
#line 111
  a = ((int )*(color1 + 3) << 16) + 32768;
#line 112
  dr = (((int )*(color2 + 0) - (int )*(color1 + 0)) << 16) / len;
#line 113
  dg = (((int )*(color2 + 1) - (int )*(color1 + 1)) << 16) / len;
#line 114
  db = (((int )*(color2 + 2) - (int )*(color1 + 2)) << 16) / len;
#line 115
  da = (((int )*(color2 + 3) - (int )*(color1 + 3)) << 16) / len;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < len)) {
#line 117
      goto while_break;
    }
#line 119
    tmp = buf;
#line 119
    buf ++;
#line 119
    *tmp = (art_u8 )(r >> 16);
#line 120
    tmp___0 = buf;
#line 120
    buf ++;
#line 120
    *tmp___0 = (art_u8 )(g >> 16);
#line 121
    tmp___1 = buf;
#line 121
    buf ++;
#line 121
    *tmp___1 = (art_u8 )(b >> 16);
#line 122
    tmp___2 = buf;
#line 122
    buf ++;
#line 122
    *tmp___2 = (art_u8 )(a >> 16);
#line 124
    r += dr;
#line 125
    g += dg;
#line 126
    b += db;
#line 127
    a += da;
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void calc_color_at___1(ArtGradientStop *stops , int n_stops , ArtGradientSpread spread ,
                              double offset , double offset_fraction , int favor_start ,
                              int ix , art_u8 *color ) 
{ 
  double off0 ;
  double off1 ;
  int j ;
  double interp ;
  double o ;
  double tmp ;
  double tmp___0 ;
  int z0 ;
  int z1 ;
  int z ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 144
  if ((unsigned int )spread == 0U) {
#line 146
    if (offset < 0.0) {
#line 148
      *(color + 0) = (art_u8 )((((int )(stops + 0)->color[0] + 128) - (((int )(stops + 0)->color[0] + 128) >> 8)) >> 8);
#line 149
      *(color + 1) = (art_u8 )((((int )(stops + 0)->color[1] + 128) - (((int )(stops + 0)->color[1] + 128) >> 8)) >> 8);
#line 150
      *(color + 2) = (art_u8 )((((int )(stops + 0)->color[2] + 128) - (((int )(stops + 0)->color[2] + 128) >> 8)) >> 8);
#line 151
      *(color + 3) = (art_u8 )((((int )(stops + 0)->color[3] + 128) - (((int )(stops + 0)->color[3] + 128) >> 8)) >> 8);
#line 152
      return;
    }
#line 154
    if (offset >= 1.0) {
#line 156
      *(color + 0) = (art_u8 )((((int )(stops + (n_stops - 1))->color[0] + 128) - (((int )(stops + (n_stops - 1))->color[0] + 128) >> 8)) >> 8);
#line 157
      *(color + 1) = (art_u8 )((((int )(stops + (n_stops - 1))->color[1] + 128) - (((int )(stops + (n_stops - 1))->color[1] + 128) >> 8)) >> 8);
#line 158
      *(color + 2) = (art_u8 )((((int )(stops + (n_stops - 1))->color[2] + 128) - (((int )(stops + (n_stops - 1))->color[2] + 128) >> 8)) >> 8);
#line 159
      *(color + 3) = (art_u8 )((((int )(stops + (n_stops - 1))->color[3] + 128) - (((int )(stops + (n_stops - 1))->color[3] + 128) >> 8)) >> 8);
#line 160
      return;
    }
  }
#line 164
  if (ix > 0) {
#line 164
    if (ix < n_stops) {
      {
#line 166
      off0 = (stops + (ix - 1))->offset;
#line 167
      off1 = (stops + ix)->offset;
#line 168
      tmp___2 = fabs(off1 - off0);
      }
#line 168
      if (tmp___2 > 1e-6) {
        {
#line 172
        o = offset_fraction;
#line 174
        tmp___0 = fabs(o);
        }
#line 174
        if (tmp___0 < 1e-6) {
#line 174
          if (! favor_start) {
#line 175
            o = 1.0;
          } else {
#line 174
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 176
          tmp = fabs(o - 1.0);
          }
#line 176
          if (tmp < 1e-6) {
#line 176
            if (favor_start) {
#line 177
              o = 0.0;
            }
          }
        }
#line 184
        interp = (o - off0) / (off1 - off0);
#line 185
        j = 0;
        {
#line 185
        while (1) {
          while_continue: /* CIL Label */ ;
#line 185
          if (! (j < 4)) {
#line 185
            goto while_break;
          }
          {
#line 189
          z0 = (int )(stops + (ix - 1))->color[j];
#line 190
          z1 = (int )(stops + ix)->color[j];
#line 191
          tmp___1 = floor(((double )z0 + (double )(z1 - z0) * interp) + 0.5);
#line 191
          z = (int )tmp___1;
#line 192
          *(color + j) = (art_u8 )(((z + 128) - ((z + 128) >> 8)) >> 8);
#line 185
          j ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 194
        return;
      }
#line 198
      *(color + 0) = (art_u8 )((((int )(stops + ix)->color[0] + 128) - (((int )(stops + ix)->color[0] + 128) >> 8)) >> 8);
#line 199
      *(color + 1) = (art_u8 )((((int )(stops + ix)->color[1] + 128) - (((int )(stops + ix)->color[1] + 128) >> 8)) >> 8);
#line 200
      *(color + 2) = (art_u8 )((((int )(stops + ix)->color[2] + 128) - (((int )(stops + ix)->color[2] + 128) >> 8)) >> 8);
#line 201
      *(color + 3) = (art_u8 )((((int )(stops + ix)->color[3] + 128) - (((int )(stops + ix)->color[3] + 128) >> 8)) >> 8);
#line 202
      return;
    }
  }
  {
#line 205
  printf((char const   */* __restrict  */)"WARNING! bad ix %d in calc_color_at() [internal error]\n",
         ix);
#line 206
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                206U, "calc_color_at");
  }
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_render_8___1(ArtRenderCallback *self , ArtRender *render ,
                                                    art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradLin *z ;
  ArtGradientLinear const   *gradient ;
  int i ;
  int width ;
  int len ;
  double offset ;
  double d_offset ;
  double offset_fraction ;
  int next_stop ;
  int ix ;
  art_u8 color1[4] ;
  art_u8 color2[4] ;
  int n_stops ;
  int extra_stops ;
  ArtGradientStop *stops ;
  ArtGradientStop *tmp_stops ;
  art_u8 *bufp ;
  ArtGradientSpread spread ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double o ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
#line 214
  z = (ArtImageSourceGradLin *)self;
#line 215
  gradient = (ArtGradientLinear const   *)(& z->gradient);
#line 217
  width = render->x1 - render->x0;
#line 224
  n_stops = (int )gradient->n_stops;
#line 226
  stops = (ArtGradientStop *)gradient->stops;
#line 228
  bufp = render->image_buf;
#line 229
  spread = (ArtGradientSpread )gradient->spread;
#line 242
  offset = (double )(((double const   )render->x0 * gradient->a + (double const   )y * gradient->b) + gradient->c);
#line 243
  d_offset = (double )gradient->a;
#line 248
  if ((gradient->stops + 0)->offset > 1e-6) {
#line 248
    goto _L;
  } else
#line 248
  if ((gradient->stops + (n_stops - 1))->offset < 1.0 - 1e-6) {
    _L: /* CIL Label */ 
    {
#line 251
    extra_stops = 0;
#line 252
    tmp = __builtin_alloca(sizeof(ArtGradientStop ) * (unsigned long )(n_stops + 2));
#line 252
    stops = (ArtGradientStop *)tmp;
#line 252
    tmp_stops = stops;
    }
#line 253
    if ((gradient->stops + 0)->offset > 1e-6) {
      {
#line 255
      memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)gradient->stops,
             sizeof(ArtGradientStop ));
#line 256
      (tmp_stops + 0)->offset = 0.0;
#line 257
      tmp_stops ++;
#line 258
      extra_stops ++;
      }
    }
    {
#line 260
    memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)gradient->stops,
           sizeof(ArtGradientStop ) * (unsigned long )n_stops);
    }
#line 261
    if ((gradient->stops + (n_stops - 1))->offset < 1.0 - 1e-6) {
      {
#line 263
      tmp_stops += n_stops;
#line 264
      memcpy((void */* __restrict  */)tmp_stops, (void const   */* __restrict  */)(gradient->stops + (n_stops - 1)),
             sizeof(ArtGradientStop ));
#line 265
      (tmp_stops + 0)->offset = 1.0;
#line 266
      extra_stops ++;
      }
    }
#line 268
    n_stops += extra_stops;
  }
#line 282
  if ((unsigned int )spread == 1U) {
    {
#line 284
    tmp_stops = stops;
#line 285
    tmp___0 = __builtin_alloca((sizeof(ArtGradientStop ) * (unsigned long )n_stops) * 2UL);
#line 285
    stops = (ArtGradientStop *)tmp___0;
#line 286
    memcpy((void */* __restrict  */)stops, (void const   */* __restrict  */)tmp_stops,
           sizeof(ArtGradientStop ) * (unsigned long )n_stops);
#line 288
    i = 0;
    }
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < n_stops)) {
#line 288
        goto while_break;
      }
      {
#line 290
      (stops + ((n_stops * 2 - 1) - i))->offset = 1.0 - (stops + i)->offset / 2.0;
#line 291
      memcpy((void */* __restrict  */)((stops + ((n_stops * 2 - 1) - i))->color),
             (void const   */* __restrict  */)((stops + i)->color), sizeof((stops + i)->color));
#line 292
      (stops + i)->offset /= 2.0;
#line 288
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 295
    spread = (ArtGradientSpread )2;
#line 296
    offset /= 2.0;
#line 297
    d_offset /= 2.0;
#line 299
    n_stops = 2 * n_stops;
  }
  {
#line 311
  tmp___1 = floor(offset);
#line 311
  offset_fraction = offset - tmp___1;
#line 321
  ix = 0;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! (ix < n_stops)) {
#line 321
      goto while_break___0;
    }
#line 322
    if ((stops + ix)->offset > offset_fraction) {
#line 324
      goto while_break___0;
    } else
#line 322
    if (d_offset < 0.0) {
      {
#line 322
      tmp___2 = fabs((stops + ix)->offset - offset_fraction);
      }
#line 322
      if (tmp___2 < 1e-6) {
#line 324
        goto while_break___0;
      }
    }
#line 321
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  if (ix == 0) {
#line 326
    ix = n_stops - 1;
  } else
#line 327
  if (ix == n_stops) {
#line 328
    ix = n_stops - 1;
  }
#line 334
  if (! (ix > 0)) {
    {
#line 334
    __assert_fail("ix > 0", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  334U, "art_render_gradient_linear_render_8");
    }
  }
#line 335
  if (! (ix < n_stops)) {
    {
#line 335
    __assert_fail("ix < n_stops", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  335U, "art_render_gradient_linear_render_8");
    }
  }
#line 336
  if (! ((stops + (ix - 1))->offset <= offset_fraction + 1e-6)) {
#line 336
    if ((stops + ix)->offset > 1.0 - 1e-6) {
#line 336
      if (! (offset_fraction < 1e-6)) {
        {
#line 336
        __assert_fail("(stops[ix-1].offset <= offset_fraction + 1e-6) || ((stops[ix].offset > (1.0 - 1e-6)) && (offset_fraction < 1e-6 ))",
                      "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                      337U, "art_render_gradient_linear_render_8");
        }
      }
    } else {
      {
#line 336
      __assert_fail("(stops[ix-1].offset <= offset_fraction + 1e-6) || ((stops[ix].offset > (1.0 - 1e-6)) && (offset_fraction < 1e-6 ))",
                    "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                    337U, "art_render_gradient_linear_render_8");
      }
    }
  }
#line 338
  if (! (offset_fraction <= (stops + ix)->offset)) {
    {
#line 338
    __assert_fail("offset_fraction <= stops[ix].offset", "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c",
                  338U, "art_render_gradient_linear_render_8");
    }
  }
  {
#line 348
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 348
    if (! (width > 0)) {
#line 348
      goto while_break___1;
    }
    {
#line 354
    calc_color_at___1(stops, n_stops, spread, offset, offset_fraction, d_offset > - 1e-6,
                      ix, color1);
    }
#line 362
    if (d_offset > (double )0) {
#line 363
      next_stop = ix;
    } else {
#line 365
      next_stop = ix - 1;
    }
    {
#line 370
    tmp___7 = fabs(d_offset);
    }
#line 370
    if (tmp___7 > 1e-6) {
      {
#line 373
      o = offset_fraction;
#line 375
      tmp___4 = fabs(o);
      }
#line 375
      if (tmp___4 <= 1e-6) {
#line 375
        if (ix == n_stops - 1) {
#line 376
          o = 1.0;
        } else {
#line 375
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 377
        tmp___3 = fabs(o - 1.0);
        }
#line 377
        if (tmp___3 <= 1e-6) {
#line 377
          if (ix == 1) {
#line 378
            o = 0.0;
          }
        }
      }
      {
#line 383
      tmp___5 = fabs(((stops + next_stop)->offset - o) / d_offset);
#line 383
      tmp___6 = floor(tmp___5);
#line 383
      len = (int )tmp___6 + 1;
      }
#line 384
      if (len > 0) {
#line 384
        len = len;
      } else {
#line 384
        len = 0;
      }
#line 385
      if (len < width) {
#line 385
        len = len;
      } else {
#line 385
        len = width;
      }
    } else {
#line 389
      len = width;
    }
#line 394
    if (len > 0) {
      {
#line 396
      offset += (double )(len - 1) * d_offset;
#line 397
      tmp___8 = floor(offset);
#line 397
      offset_fraction = offset - tmp___8;
#line 401
      calc_color_at___1(stops, n_stops, spread, offset, offset_fraction, d_offset < 1e-6,
                        ix, color2);
#line 409
      art_rgba_gradient_run___1(bufp, color1, color2, len);
#line 413
      offset += d_offset;
#line 414
      tmp___9 = floor(offset);
#line 414
      offset_fraction = offset - tmp___9;
      }
    }
#line 417
    if (d_offset > (double )0) {
      {
#line 419
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 421
        ix ++;
#line 422
        if (ix == n_stops) {
#line 423
          ix = 1;
        }
#line 419
        if ((stops + (ix - 1))->offset <= offset_fraction) {
#line 419
          if (offset_fraction < (stops + ix)->offset) {
#line 419
            goto while_break___2;
          } else {
#line 419
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 419
        if (ix == 1) {
#line 419
          if (offset_fraction > 1.0 - 1e-6) {
#line 419
            goto while_break___2;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 436
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 438
        ix --;
#line 439
        if (ix == 0) {
#line 440
          ix = n_stops - 1;
        }
#line 436
        if ((stops + (ix - 1))->offset < offset_fraction) {
#line 436
          if (offset_fraction <= (stops + ix)->offset) {
#line 436
            goto while_break___3;
          } else {
#line 436
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 436
        if (ix == n_stops - 1) {
#line 436
          if (offset_fraction < 1e-6) {
#line 436
            goto while_break___3;
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 447
    bufp += 4 * len;
#line 448
    width -= len;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 450
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_setpix___1(ArtRender *render , art_u8 *dst , int n_stops ,
                                           ArtGradientStop *stops , double offset ) 
{ 
  int ix ;
  int j ;
  double off0 ;
  double off1 ;
  int n_ch ;
  double interp ;
  int z0 ;
  int z1 ;
  int z ;
  double tmp ;
  double tmp___0 ;
  int z___0 ;

  {
#line 474
  n_ch = render->n_chan + 1;
#line 476
  ix = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (ix < n_stops)) {
#line 476
      goto while_break;
    }
#line 477
    if ((stops + ix)->offset > offset) {
#line 478
      goto while_break;
    }
#line 476
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  if (ix > 0) {
#line 480
    if (ix < n_stops) {
      {
#line 482
      off0 = (stops + (ix - 1))->offset;
#line 483
      off1 = (stops + ix)->offset;
#line 484
      tmp___0 = fabs(off1 - off0);
      }
#line 484
      if (tmp___0 > 1e-6) {
#line 488
        interp = (offset - off0) / (off1 - off0);
#line 489
        j = 0;
        {
#line 489
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 489
          if (! (j < n_ch)) {
#line 489
            goto while_break___0;
          }
          {
#line 493
          z0 = (int )(stops + (ix - 1))->color[j];
#line 494
          z1 = (int )(stops + ix)->color[j];
#line 495
          tmp = floor(((double )z0 + (double )(z1 - z0) * interp) + 0.5);
#line 495
          z = (int )tmp;
          }
#line 496
          if (render->buf_depth == 8) {
#line 497
            *(dst + j) = (art_u8 )(((z + 128) - ((z + 128) >> 8)) >> 8);
          } else {
#line 499
            *((art_u16 *)dst + j) = (art_u16 )z;
          }
#line 489
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 501
        return;
      }
    } else {
#line 480
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 504
  if (ix == n_stops) {
#line 505
    ix --;
  }
#line 507
  j = 0;
  {
#line 507
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 507
    if (! (j < n_ch)) {
#line 507
      goto while_break___1;
    }
#line 510
    z___0 = (int )(stops + ix)->color[j];
#line 511
    if (render->buf_depth == 8) {
#line 512
      *(dst + j) = (art_u8 )(((z___0 + 128) - ((z___0 + 128) >> 8)) >> 8);
    } else {
#line 514
      *((art_u16 *)dst + j) = (art_u16 )z___0;
    }
#line 507
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_done___1(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 521
  art_free((void *)self);
  }
#line 522
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_render___1(ArtRenderCallback *self , ArtRender *render ,
                                                  art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradLin *z ;
  ArtGradientLinear const   *gradient ;
  int pixstride ;
  int x ;
  int width ;
  double offset ;
  double d_offset ;
  double actual_offset ;
  int n_stops ;
  ArtGradientStop *stops ;
  art_u8 *bufp ;
  ArtGradientSpread spread ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 528
  z = (ArtImageSourceGradLin *)self;
#line 529
  gradient = (ArtGradientLinear const   *)(& z->gradient);
#line 530
  pixstride = (render->n_chan + 1) * (render->depth >> 3);
#line 532
  width = render->x1 - render->x0;
#line 535
  n_stops = (int )gradient->n_stops;
#line 536
  stops = (ArtGradientStop *)gradient->stops;
#line 537
  bufp = render->image_buf;
#line 538
  spread = (ArtGradientSpread )gradient->spread;
#line 540
  offset = (double )(((double const   )render->x0 * gradient->a + (double const   )y * gradient->b) + gradient->c);
#line 541
  d_offset = (double )gradient->a;
#line 543
  x = 0;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (x < width)) {
#line 543
      goto while_break;
    }
#line 545
    if ((unsigned int )spread == 0U) {
#line 546
      actual_offset = offset;
    } else
#line 547
    if ((unsigned int )spread == 2U) {
      {
#line 548
      tmp = floor(offset);
#line 548
      actual_offset = offset - tmp;
      }
    } else {
      {
#line 553
      tmp___1 = floor(0.5 * offset);
#line 553
      tmp___0 = offset - (double )2 * tmp___1;
      }
#line 554
      if (tmp___0 > (double )1) {
#line 554
        actual_offset = (double )2 - tmp___0;
      } else {
#line 554
        actual_offset = tmp___0;
      }
    }
    {
#line 556
    art_render_gradient_setpix___1(render, bufp, n_stops, stops, actual_offset);
#line 557
    offset += d_offset;
#line 558
    bufp += pixstride;
#line 543
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_linear_negotiate___1(ArtImageSource *self , ArtRender *render ,
                                                     ArtImageSourceFlags *p_flags ,
                                                     int *p_buf_depth , ArtAlphaType *p_alpha ) 
{ 


  {
#line 567
  if (render->depth == 8) {
#line 567
    if (render->n_chan == 3) {
#line 570
      self->super.render = & art_render_gradient_linear_render_8___1;
#line 571
      *p_flags = (ArtImageSourceFlags )0;
#line 572
      *p_buf_depth = 8;
#line 573
      *p_alpha = (ArtAlphaType )2;
#line 574
      return;
    }
  }
#line 577
  self->super.render = & art_render_gradient_linear_render___1;
#line 578
  *p_flags = (ArtImageSourceFlags )0;
#line 579
  *p_buf_depth = render->depth;
#line 580
  *p_alpha = (ArtAlphaType )2;
#line 581
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_done___1(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 614
  art_free((void *)self);
  }
#line 615
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_render___1(ArtRenderCallback *self , ArtRender *render ,
                                                  art_u8 *dest , int y ) 
{ 
  ArtImageSourceGradRad *z ;
  ArtGradientRadial const   *gradient ;
  int pixstride ;
  int x ;
  int x0 ;
  int width ;
  int n_stops ;
  ArtGradientStop *stops ;
  art_u8 *bufp ;
  double fx ;
  double fy ;
  double dx ;
  double dy ;
  double const   *affine ;
  double aff0 ;
  double aff1 ;
  double a ;
  double arecip ;
  double b ;
  double db ;
  double c ;
  double dc ;
  double ddc ;
  double b_a ;
  double db_a ;
  double rad ;
  double drad ;
  double ddrad ;
  double z___0 ;
  double tmp ;

  {
#line 621
  z = (ArtImageSourceGradRad *)self;
#line 622
  gradient = (ArtGradientRadial const   *)(& z->gradient);
#line 623
  pixstride = (render->n_chan + 1) * (render->depth >> 3);
#line 625
  x0 = render->x0;
#line 626
  width = render->x1 - x0;
#line 627
  n_stops = (int )gradient->n_stops;
#line 628
  stops = (ArtGradientStop *)gradient->stops;
#line 629
  bufp = render->image_buf;
#line 630
  fx = (double )gradient->fx;
#line 631
  fy = (double )gradient->fy;
#line 633
  affine = (double const   *)(gradient->affine);
#line 634
  aff0 = (double )*(affine + 0);
#line 635
  aff1 = (double )*(affine + 1);
#line 636
  a = z->a;
#line 637
  arecip = 1.0 / a;
#line 643
  dx = (((double )x0 * aff0 + (double )((double const   )y * *(affine + 2))) + (double )*(affine + 4)) - fx;
#line 644
  dy = (((double )x0 * aff1 + (double )((double const   )y * *(affine + 3))) + (double )*(affine + 5)) - fy;
#line 645
  b = dx * fx + dy * fy;
#line 646
  db = aff0 * fx + aff1 * fy;
#line 647
  c = dx * dx + dy * dy;
#line 648
  dc = ((((double )2 * aff0) * dx + aff0 * aff0) + ((double )2 * aff1) * dy) + aff1 * aff1;
#line 649
  ddc = ((double )2 * aff0) * aff0 + ((double )2 * aff1) * aff1;
#line 651
  b_a = b * arecip;
#line 652
  db_a = db * arecip;
#line 654
  rad = b_a * b_a + c * arecip;
#line 655
  drad = (((double )2 * b_a) * db_a + db_a * db_a) + dc * arecip;
#line 656
  ddrad = ((double )2 * db_a) * db_a + ddc * arecip;
#line 658
  x = 0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (x < width)) {
#line 658
      goto while_break;
    }
#line 662
    if (rad > (double )0) {
      {
#line 663
      tmp = sqrt(rad);
#line 663
      z___0 = b_a + tmp;
      }
    } else {
#line 665
      z___0 = b_a;
    }
    {
#line 666
    art_render_gradient_setpix___1(render, bufp, n_stops, stops, z___0);
#line 667
    bufp += pixstride;
#line 668
    b_a += db_a;
#line 669
    rad += drad;
#line 670
    drad += ddrad;
#line 658
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_gradient.c"
static void art_render_gradient_radial_negotiate___1(ArtImageSource *self , ArtRender *render ,
                                                     ArtImageSourceFlags *p_flags ,
                                                     int *p_buf_depth , ArtAlphaType *p_alpha ) 
{ 


  {
#line 679
  self->super.render = & art_render_gradient_radial_render___1;
#line 680
  *p_flags = (ArtImageSourceFlags )0;
#line 681
  *p_buf_depth = render->depth;
#line 682
  *p_alpha = (ArtAlphaType )2;
#line 683
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_callback___1(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                     int n_steps ) 
{ 
  ArtRgbSVPData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  art_u32 rgb ;
  int x0 ;
  int x1 ;
  int k ;

  {
#line 51
  data = (ArtRgbSVPData *)callback_data;
#line 54
  running_sum = (art_u32 )start;
#line 59
  linebuf = data->buf;
#line 60
  x0 = data->x0;
#line 61
  x1 = data->x1;
#line 63
  if (n_steps > 0) {
#line 65
    run_x1 = (steps + 0)->x;
#line 66
    if (run_x1 > x0) {
      {
#line 68
      rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 69
      art_rgb_fill_run(linebuf, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                       (art_u8 )(rgb & 255U), run_x1 - x0);
      }
    }
#line 74
    k = 0;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! (k < n_steps - 1)) {
#line 74
        goto while_break;
      }
#line 76
      running_sum += (art_u32 )(steps + k)->delta;
#line 77
      run_x0 = run_x1;
#line 78
      run_x1 = (steps + (k + 1))->x;
#line 79
      if (run_x1 > run_x0) {
        {
#line 81
        rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 82
        art_rgb_fill_run(linebuf + (run_x0 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                         (art_u8 )(rgb & 255U), run_x1 - run_x0);
        }
      }
#line 74
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 87
    running_sum += (art_u32 )(steps + k)->delta;
#line 88
    if (x1 > run_x1) {
      {
#line 90
      rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 91
      art_rgb_fill_run(linebuf + (run_x1 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                       (art_u8 )(rgb & 255U), x1 - run_x1);
      }
    }
  } else {
    {
#line 98
    rgb = data->rgbtab[(running_sum >> 16) & 255U];
#line 99
    art_rgb_fill_run(linebuf, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                     (art_u8 )(rgb & 255U), x1 - x0);
    }
  }
#line 104
  data->buf += data->rowstride;
#line 105
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_alpha_callback___1(void *callback_data , int y , int start ,
                                           ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtRgbSVPAlphaData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int k ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int *alphatab ;
  int alpha ;

  {
#line 222
  data = (ArtRgbSVPAlphaData *)callback_data;
#line 225
  running_sum = (art_u32 )start;
#line 232
  linebuf = data->buf;
#line 233
  x0 = data->x0;
#line 234
  x1 = data->x1;
#line 236
  r = data->r;
#line 237
  g = data->g;
#line 238
  b = data->b;
#line 239
  alphatab = data->alphatab;
#line 241
  if (n_steps > 0) {
#line 243
    run_x1 = (steps + 0)->x;
#line 244
    if (run_x1 > x0) {
#line 246
      alpha = (int )((running_sum >> 16) & 255U);
#line 247
      if (alpha) {
        {
#line 248
        art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), run_x1 - x0);
        }
      }
    }
#line 253
    k = 0;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (! (k < n_steps - 1)) {
#line 253
        goto while_break;
      }
#line 255
      running_sum += (art_u32 )(steps + k)->delta;
#line 256
      run_x0 = run_x1;
#line 257
      run_x1 = (steps + (k + 1))->x;
#line 258
      if (run_x1 > run_x0) {
#line 260
        alpha = (int )((running_sum >> 16) & 255U);
#line 261
        if (alpha) {
          {
#line 262
          art_rgb_run_alpha(linebuf + (run_x0 - x0) * 3, r, g, b, *(alphatab + alpha),
                            run_x1 - run_x0);
          }
        }
      }
#line 253
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 267
    running_sum += (art_u32 )(steps + k)->delta;
#line 268
    if (x1 > run_x1) {
#line 270
      alpha = (int )((running_sum >> 16) & 255U);
#line 271
      if (alpha) {
        {
#line 272
        art_rgb_run_alpha(linebuf + (run_x1 - x0) * 3, r, g, b, *(alphatab + alpha),
                          x1 - run_x1);
        }
      }
    }
  } else {
#line 279
    alpha = (int )((running_sum >> 16) & 255U);
#line 280
    if (alpha) {
      {
#line 281
      art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), x1 - x0);
      }
    }
  }
#line 286
  data->buf += data->rowstride;
#line 287
  return;
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_svp.c"
static void art_rgb_svp_alpha_opaque_callback___1(void *callback_data , int y , int start ,
                                                  ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtRgbSVPAlphaData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int k ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int *alphatab ;
  int alpha ;

  {
#line 294
  data = (ArtRgbSVPAlphaData *)callback_data;
#line 297
  running_sum = (art_u32 )start;
#line 304
  linebuf = data->buf;
#line 305
  x0 = data->x0;
#line 306
  x1 = data->x1;
#line 308
  r = data->r;
#line 309
  g = data->g;
#line 310
  b = data->b;
#line 311
  alphatab = data->alphatab;
#line 313
  if (n_steps > 0) {
#line 315
    run_x1 = (steps + 0)->x;
#line 316
    if (run_x1 > x0) {
#line 318
      alpha = (int )(running_sum >> 16);
#line 319
      if (alpha) {
#line 321
        if (alpha >= 255) {
          {
#line 322
          art_rgb_fill_run(linebuf, r, g, b, run_x1 - x0);
          }
        } else {
          {
#line 326
          art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), run_x1 - x0);
          }
        }
      }
    }
#line 332
    k = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (! (k < n_steps - 1)) {
#line 332
        goto while_break;
      }
#line 334
      running_sum += (art_u32 )(steps + k)->delta;
#line 335
      run_x0 = run_x1;
#line 336
      run_x1 = (steps + (k + 1))->x;
#line 337
      if (run_x1 > run_x0) {
#line 339
        alpha = (int )(running_sum >> 16);
#line 340
        if (alpha) {
#line 342
          if (alpha >= 255) {
            {
#line 343
            art_rgb_fill_run(linebuf + (run_x0 - x0) * 3, r, g, b, run_x1 - run_x0);
            }
          } else {
            {
#line 347
            art_rgb_run_alpha(linebuf + (run_x0 - x0) * 3, r, g, b, *(alphatab + alpha),
                              run_x1 - run_x0);
            }
          }
        }
      }
#line 332
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 353
    running_sum += (art_u32 )(steps + k)->delta;
#line 354
    if (x1 > run_x1) {
#line 356
      alpha = (int )(running_sum >> 16);
#line 357
      if (alpha) {
#line 359
        if (alpha >= 255) {
          {
#line 360
          art_rgb_fill_run(linebuf + (run_x1 - x0) * 3, r, g, b, x1 - run_x1);
          }
        } else {
          {
#line 364
          art_rgb_run_alpha(linebuf + (run_x1 - x0) * 3, r, g, b, *(alphatab + alpha),
                            x1 - run_x1);
          }
        }
      }
    }
  } else {
#line 372
    alpha = (int )(running_sum >> 16);
#line 373
    if (alpha) {
#line 375
      if (alpha >= 255) {
        {
#line 376
        art_rgb_fill_run(linebuf, r, g, b, x1 - x0);
        }
      } else {
        {
#line 380
        art_rgb_run_alpha(linebuf, r, g, b, *(alphatab + alpha), x1 - x0);
        }
      }
    }
  }
#line 386
  data->buf += data->rowstride;
#line 387
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
static int art_vpath_svp_point_compare___1(double x1 , double y1 , double x2 , double y2 ) 
{ 


  {
#line 44
  if (y1 - 1e-6 > y2) {
#line 44
    return (1);
  }
#line 45
  if (y1 + 1e-6 < y2) {
#line 45
    return (-1);
  }
#line 46
  if (x1 - 1e-6 > x2) {
#line 46
    return (1);
  }
#line 47
  if (x1 + 1e-6 < x2) {
#line 47
    return (-1);
  }
#line 48
  return (0);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_svp.c"
static int art_vpath_svp_compare___1(void const   *s1 , void const   *s2 ) 
{ 
  ArtVpathSVPEnd const   *e1 ;
  ArtVpathSVPEnd const   *e2 ;
  int tmp ;

  {
  {
#line 54
  e1 = (ArtVpathSVPEnd const   *)s1;
#line 55
  e2 = (ArtVpathSVPEnd const   *)s2;
#line 57
  tmp = art_vpath_svp_point_compare___1((double )e1->x, (double )e1->y, (double )e2->x,
                                        (double )e2->y);
  }
#line 57
  return (tmp);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static ArtVpath *randstar___0(int n ) 
{ 
  ArtVpath *vec ;
  int i ;
  double r ;
  double th ;
  void *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  {
#line 115
  tmp = art_alloc((unsigned long )(n + 2) * sizeof(ArtVpath ));
#line 115
  vec = (ArtVpath *)tmp;
#line 116
  i = 0;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < n)) {
#line 116
      goto while_break;
    }
#line 118
    if (i) {
#line 118
      (vec + i)->code = (ArtPathcode )3;
    } else {
#line 118
      (vec + i)->code = (ArtPathcode )0;
    }
    {
#line 119
    tmp___0 = rand();
#line 119
    r = (double )tmp___0 * (250.0 / (double )2147483647);
#line 123
    th = ((double )(i * 2) * 3.14159265358979323846) / (double )n;
#line 124
    tmp___1 = cos(th);
#line 124
    (vec + i)->x = (double )250 + r * tmp___1;
#line 125
    tmp___2 = sin(th);
#line 125
    (vec + i)->y = (double )250 - r * tmp___2;
#line 116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  (vec + i)->code = (ArtPathcode )3;
#line 128
  (vec + i)->x = (vec + 0)->x;
#line 129
  (vec + i)->y = (vec + 0)->y;
#line 130
  i ++;
#line 131
  (vec + i)->code = (ArtPathcode )4;
#line 132
  (vec + i)->x = (double )0;
#line 133
  (vec + i)->y = (double )0;
#line 134
  return (vec);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void print_svp(ArtSVP *vp ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;

  {
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < vp->n_segs)) {
#line 153
      goto while_break;
    }
#line 155
    if (vp->segs[i].dir) {
#line 155
      tmp = "down";
    } else {
#line 155
      tmp = "up";
    }
    {
#line 155
    printf((char const   */* __restrict  */)"segment %d, dir = %s (%f, %f) - (%f, %f)\n",
           i, tmp, vp->segs[i].bbox.x0, vp->segs[i].bbox.y0, vp->segs[i].bbox.x1,
           vp->segs[i].bbox.y1);
#line 161
    j = 0;
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 161
      if (! (j < vp->segs[i].n_points)) {
#line 161
        goto while_break___0;
      }
      {
#line 162
      printf((char const   */* __restrict  */)"  (%g, %g)\n", (vp->segs[i].points + j)->x,
             (vp->segs[i].points + j)->y);
#line 161
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 153
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void print_vpath(ArtVpath *vpath ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned int )(vpath + i)->code != 4U)) {
#line 174
      goto while_break;
    }
#line 175
    if ((unsigned int )(vpath + i)->code == 1U) {
#line 175
      tmp___1 = "moveto %open";
    } else {
#line 175
      if ((unsigned int )(vpath + i)->code == 0U) {
#line 175
        tmp___0 = "moveto";
      } else {
#line 175
        if ((unsigned int )(vpath + i)->code == 3U) {
#line 175
          tmp = "lineto";
        } else {
#line 175
          tmp = "?";
        }
#line 175
        tmp___0 = tmp;
      }
#line 175
      tmp___1 = tmp___0;
    }
    {
#line 175
    printf((char const   */* __restrict  */)"%g %g %s\n", (vpath + i)->x, (vpath + i)->y,
           tmp___1);
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  printf((char const   */* __restrict  */)"stroke\n");
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void make_testpat(void) 
{ 
  ArtVpath *vpath ;
  ArtVpath *vpath2 ;
  ArtVpath *vpath3 ;
  ArtSVP *svp ;
  ArtSVP *svp2 ;
  ArtSVP *svp3 ;
  art_u8 buf[786432] ;
  int i ;
  int j ;
  int iter ;
  art_u8 colorimg[256][256][3] ;
  art_u8 rgbaimg[256][256][4] ;
  art_u8 bitimg[16][2] ;
  int x ;
  int y ;
  double affine[6] ;
  double affine2[6] ;
  double affine3[6] ;
  ArtAlphaGamma *alphagamma ;
  double dash_data[1] ;
  ArtVpathDash dash ;

  {
  {
#line 202
  dash_data[0] = (double )20;
#line 205
  dash.offset = (double )0;
#line 206
  dash.n_dash = 1;
#line 207
  dash.dash = dash_data;
#line 214
  vpath = randstar___0(50);
#line 215
  svp = art_svp_from_vpath(vpath);
#line 216
  art_free((void *)vpath);
#line 218
  vpath2 = randstar___0(50);
#line 220
  vpath3 = art_vpath_dash((ArtVpath const   *)vpath2, (ArtVpathDash const   *)(& dash));
#line 221
  art_free((void *)vpath2);
#line 222
  svp2 = art_svp_vpath_stroke(vpath3, (ArtPathStrokeJoinType )0, (ArtPathStrokeCapType )0,
                              (double )15, (double )4, 0.5);
#line 228
  art_free((void *)vpath3);
#line 234
  svp3 = art_svp_intersect((ArtSVP const   *)svp, (ArtSVP const   *)svp2);
#line 243
  y = 0;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (y < 256)) {
#line 243
      goto while_break;
    }
#line 244
    x = 0;
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if (! (x < 256)) {
#line 244
        goto while_break___0;
      }
#line 246
      colorimg[y][x][0] = (art_u8 )((x + y) >> 1);
#line 247
      colorimg[y][x][1] = (art_u8 )((x + (255 - y)) >> 1);
#line 248
      colorimg[y][x][2] = (art_u8 )(((255 - x) + y) >> 1);
#line 250
      rgbaimg[y][x][0] = (art_u8 )((x + y) >> 1);
#line 251
      rgbaimg[y][x][1] = (art_u8 )((x + (255 - y)) >> 1);
#line 252
      rgbaimg[y][x][2] = (art_u8 )(((255 - x) + y) >> 1);
#line 253
      rgbaimg[y][x][3] = (art_u8 )y;
#line 244
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 243
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  y = 0;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    if (! (y < 16)) {
#line 256
      goto while_break___1;
    }
#line 257
    x = 0;
    {
#line 257
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 257
      if (! (x < 2)) {
#line 257
        goto while_break___2;
      }
#line 258
      bitimg[y][x] = (art_u8 )((x << 4) | y);
#line 257
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 256
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 260
  affine[0] = 0.5;
#line 261
  affine[1] = .2;
#line 262
  affine[2] = - .2;
#line 263
  affine[3] = 0.5;
#line 264
  affine[4] = (double )64;
#line 265
  affine[5] = (double )64;
#line 267
  affine2[0] = (double )1;
#line 268
  affine2[1] = - .2;
#line 269
  affine2[2] = .2;
#line 270
  affine2[3] = (double )1;
#line 271
  affine2[4] = (double )128;
#line 272
  affine2[5] = (double )128;
#line 274
  affine3[0] = (double )5;
#line 275
  affine3[1] = - .2;
#line 276
  affine3[2] = .2;
#line 277
  affine3[3] = (double )5;
#line 278
  affine3[4] = (double )384;
#line 279
  affine3[5] = (double )32;
#line 284
  alphagamma = (ArtAlphaGamma *)((void *)0);
#line 288
  printf((char const   */* __restrict  */)"P6\n512 512\n255\n");
#line 292
  iter = 0;
  }
  {
#line 292
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 292
    if (! (iter < 1)) {
#line 292
      goto while_break___3;
    }
#line 293
    j = 0;
    {
#line 293
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 293
      if (! (j < 512)) {
#line 293
        goto while_break___4;
      }
#line 294
      i = 0;
      {
#line 294
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 294
        if (! (i < 512)) {
#line 294
          goto while_break___5;
        }
        {
#line 297
        art_rgb_svp_aa((ArtSVP const   *)svp, i, j, i + 512, j + 512, (art_u32 )16769184,
                       (art_u32 )1048640, buf + (j * 512 + i) * 3, 1536, alphagamma);
#line 301
        art_rgb_svp_alpha((ArtSVP const   *)svp2, i, j, i + 512, j + 512, 4278190208U,
                          buf + (j * 512 + i) * 3, 1536, alphagamma);
#line 305
        art_rgb_svp_alpha((ArtSVP const   *)svp3, i, j, i + 512, j + 512, (art_u32 )16711808,
                          buf + (j * 512 + i) * 3, 1536, alphagamma);
#line 309
        art_rgb_affine(buf + (j * 512 + i) * 3, i, j, i + 512, j + 512, 1536, (art_u8 const   *)((art_u8 *)(colorimg)),
                       256, 256, 768, (double const   *)(affine), (ArtFilterLevel )0,
                       alphagamma);
#line 314
        art_rgb_rgba_affine(buf + (j * 512 + i) * 3, i, j, i + 512, j + 512, 1536,
                            (art_u8 const   *)((art_u8 *)(rgbaimg)), 256, 256, 1024,
                            (double const   *)(affine2), (ArtFilterLevel )0, alphagamma);
#line 320
        art_rgb_bitmap_affine(buf + (j * 512 + i) * 3, i, j, i + 512, j + 512, 1536,
                              (art_u8 const   *)((art_u8 *)(bitimg)), 16, 16, 2, 4294902015U,
                              (double const   *)(affine3), (ArtFilterLevel )0, alphagamma);
#line 294
        i += 512;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 293
      j += 512;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 292
    iter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 333
  art_svp_free(svp2);
#line 334
  art_svp_free(svp3);
#line 335
  art_svp_free(svp);
#line 338
  fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )786432, (FILE */* __restrict  */)stdout);
  }
#line 340
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void test_dist(void) 
{ 
  ArtVpath *vpath ;
  ArtSVP *svp ;
  art_u8 buf[786432] ;
  int x ;
  int y ;
  int ix ;
  double dist ;
  int wind ;

  {
  {
#line 353
  vpath = randstar___0(20);
#line 357
  svp = art_svp_vpath_stroke(vpath, (ArtPathStrokeJoinType )0, (ArtPathStrokeCapType )0,
                             (double )15, (double )4, 0.5);
#line 365
  art_rgb_svp_aa((ArtSVP const   *)svp, 0, 0, 512, 512, (art_u32 )16769184, (art_u32 )1048640,
                 buf, 1536, (ArtAlphaGamma *)((void *)0));
#line 370
  ix = 0;
#line 371
  y = 0;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (y < 512)) {
#line 371
      goto while_break;
    }
#line 373
    x = 0;
    {
#line 373
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 373
      if (! (x < 512)) {
#line 373
        goto while_break___0;
      }
      {
#line 375
      wind = art_svp_point_wind(svp, (double )x, (double )y);
#line 376
      buf[ix] = (art_u8 )(204 - wind * 51);
#line 377
      dist = art_svp_point_dist(svp, (double )x, (double )y);
      }
#line 378
      if (((x | y) & 63) == 0) {
        {
#line 380
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d,%d: %f\n",
                x, y, dist);
        }
      }
#line 382
      buf[ix + 1] = (art_u8 )((double )255 - dist);
#line 383
      ix += 3;
#line 373
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 387
  printf((char const   */* __restrict  */)"P6\n512 512\n255\n");
#line 388
  fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )786432, (FILE */* __restrict  */)stdout);
  }
#line 390
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void test_dash(void) 
{ 
  ArtVpath *vpath ;
  ArtVpath *vpath2 ;
  double dash_data[4] ;
  ArtVpathDash dash ;

  {
  {
#line 396
  dash_data[0] = (double )10;
#line 396
  dash_data[1] = (double )4;
#line 396
  dash_data[2] = (double )1;
#line 396
  dash_data[3] = (double )4;
#line 399
  dash.offset = (double )0;
#line 400
  dash.n_dash = 3;
#line 401
  dash.dash = dash_data;
#line 403
  vpath = randstar___0(50);
#line 404
  vpath2 = art_vpath_dash((ArtVpath const   *)vpath, (ArtVpathDash const   *)(& dash));
#line 405
  printf((char const   */* __restrict  */)"%%!\n");
#line 406
  print_vpath(vpath2);
#line 407
  printf((char const   */* __restrict  */)"showpage\n");
#line 408
  art_free((void *)vpath);
#line 409
  art_free((void *)vpath2);
  }
#line 410
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void test_render_gradient(art_u8 *buf ) 
{ 
  ArtGradientLinear gradient ;
  ArtGradientStop stops[3] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  ArtVpath *vpath ;
  ArtSVP *svp ;
  ArtRender *render ;

  {
#line 416
  stops[0].offset = 0.0;
#line 416
  stops[0].color[0] = (ArtPixMaxDepth )32767;
#line 416
  stops[0].color[1] = (ArtPixMaxDepth )0;
#line 416
  stops[0].color[2] = (ArtPixMaxDepth )0;
#line 416
  stops[0].color[3] = (ArtPixMaxDepth )32767;
#line 416
  tmp = 4U;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (tmp >= 17U) {
#line 416
      goto while_break;
    }
#line 416
    stops[0].color[tmp] = (unsigned short)0;
#line 416
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  stops[1].offset = 0.5;
#line 416
  stops[1].color[0] = (ArtPixMaxDepth )0;
#line 416
  stops[1].color[1] = (ArtPixMaxDepth )0;
#line 416
  stops[1].color[2] = (ArtPixMaxDepth )0;
#line 416
  stops[1].color[3] = (ArtPixMaxDepth )4096;
#line 416
  tmp___0 = 4U;
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 416
    if (tmp___0 >= 17U) {
#line 416
      goto while_break___0;
    }
#line 416
    stops[1].color[tmp___0] = (unsigned short)0;
#line 416
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 416
  stops[2].offset = 1.0;
#line 416
  stops[2].color[0] = (ArtPixMaxDepth )0;
#line 416
  stops[2].color[1] = (ArtPixMaxDepth )32767;
#line 416
  stops[2].color[2] = (ArtPixMaxDepth )0;
#line 416
  stops[2].color[3] = (ArtPixMaxDepth )32767;
#line 416
  tmp___1 = 4U;
  {
#line 416
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 416
    if (tmp___1 >= 17U) {
#line 416
      goto while_break___1;
    }
#line 416
    stops[2].color[tmp___1] = (unsigned short)0;
#line 416
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 425
  gradient.a = 0.003;
#line 426
  gradient.b = - 0.0015;
#line 427
  gradient.c = 0.1;
#line 428
  gradient.spread = (ArtGradientSpread )0;
#line 429
  gradient.n_stops = (int )(sizeof(stops) / sizeof(stops[0]));
#line 430
  gradient.stops = stops;
#line 432
  vpath = randstar___0(50);
#line 433
  svp = art_svp_from_vpath(vpath);
#line 435
  render = art_render_new(0, 0, 512, 512, buf, 1536, 3, 8, (ArtAlphaType )0, (ArtAlphaGamma *)((void *)0));
#line 437
  art_render_svp(render, (ArtSVP const   *)svp);
#line 438
  art_render_gradient_linear(render, (ArtGradientLinear const   *)(& gradient), (ArtFilterLevel )0);
#line 439
  art_render_invoke(render);
  }
#line 441
  return;
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void test_render_rad_gradient(art_u8 *buf ) 
{ 
  ArtGradientRadial gradient ;
  ArtGradientStop stops[3] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  ArtVpath *vpath ;
  ArtSVP *svp ;
  ArtRender *render ;

  {
#line 447
  stops[0].offset = 0.0;
#line 447
  stops[0].color[0] = (ArtPixMaxDepth )65535;
#line 447
  stops[0].color[1] = (ArtPixMaxDepth )0;
#line 447
  stops[0].color[2] = (ArtPixMaxDepth )0;
#line 447
  stops[0].color[3] = (ArtPixMaxDepth )65535;
#line 447
  tmp = 4U;
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (tmp >= 17U) {
#line 447
      goto while_break;
    }
#line 447
    stops[0].color[tmp] = (unsigned short)0;
#line 447
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  stops[1].offset = 0.5;
#line 447
  stops[1].color[0] = (ArtPixMaxDepth )57344;
#line 447
  stops[1].color[1] = (ArtPixMaxDepth )57344;
#line 447
  stops[1].color[2] = (ArtPixMaxDepth )0;
#line 447
  stops[1].color[3] = (ArtPixMaxDepth )57344;
#line 447
  tmp___0 = 4U;
  {
#line 447
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 447
    if (tmp___0 >= 17U) {
#line 447
      goto while_break___0;
    }
#line 447
    stops[1].color[tmp___0] = (unsigned short)0;
#line 447
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 447
  stops[2].offset = 1.0;
#line 447
  stops[2].color[0] = (ArtPixMaxDepth )0;
#line 447
  stops[2].color[1] = (ArtPixMaxDepth )0;
#line 447
  stops[2].color[2] = (ArtPixMaxDepth )0;
#line 447
  stops[2].color[3] = (ArtPixMaxDepth )0;
#line 447
  tmp___1 = 4U;
  {
#line 447
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 447
    if (tmp___1 >= 17U) {
#line 447
      goto while_break___1;
    }
#line 447
    stops[2].color[tmp___1] = (unsigned short)0;
#line 447
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 456
  gradient.affine[0] = 3.0 / (double )512;
#line 457
  gradient.affine[1] = (double )0;
#line 458
  gradient.affine[2] = (double )0;
#line 459
  gradient.affine[3] = 3.0 / (double )512;
#line 460
  gradient.affine[4] = - 1.5;
#line 461
  gradient.affine[5] = - 1.5;
#line 462
  gradient.fx = 0.9;
#line 463
  gradient.fy = 0.1;
#line 465
  gradient.n_stops = (int )(sizeof(stops) / sizeof(stops[0]));
#line 466
  gradient.stops = stops;
#line 468
  vpath = randstar___0(50);
#line 469
  svp = art_svp_from_vpath(vpath);
#line 471
  render = art_render_new(0, 0, 512, 512, buf, 1536, 3, 8, (ArtAlphaType )0, (ArtAlphaGamma *)((void *)0));
#line 473
  art_render_svp(render, (ArtSVP const   *)svp);
#line 474
  art_render_gradient_radial(render, (ArtGradientRadial const   *)(& gradient), (ArtFilterLevel )0);
#line 475
  art_render_invoke(render);
  }
#line 477
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void test_gradient(void) 
{ 
  ArtVpath *vpath ;
  ArtSVP *svp ;
  art_u8 buf[786432] ;
  ArtRender *render ;
  ArtPixMaxDepth color[3] ;
  int i ;
  int n_iter ;

  {
  {
#line 486
  color[0] = (ArtPixMaxDepth )0;
#line 486
  color[1] = (ArtPixMaxDepth )0;
#line 486
  color[2] = (ArtPixMaxDepth )32768;
#line 488
  n_iter = 1;
#line 490
  vpath = randstar___0(50);
#line 491
  svp = art_svp_from_vpath(vpath);
#line 493
  i = 0;
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! (i < n_iter)) {
#line 493
      goto while_break;
    }
    {
#line 497
    render = art_render_new(0, 0, 512, 512, buf, 1536, 3, 8, (ArtAlphaType )0, (ArtAlphaGamma *)((void *)0));
#line 499
    art_render_clear_rgb(render, (art_u32 )16773312);
#line 500
    art_render_svp(render, (ArtSVP const   *)svp);
#line 501
    art_render_image_solid(render, color);
#line 502
    art_render_invoke(render);
#line 493
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  test_render_gradient(buf);
#line 512
  test_render_rad_gradient(buf);
#line 514
  printf((char const   */* __restrict  */)"P6\n512 512\n255\n");
#line 515
  fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )786432, (FILE */* __restrict  */)stdout);
  }
#line 516
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void test_intersect(void) 
{ 
  ArtVpath vpath[11] ;
  ArtSVP *svp ;
  ArtSVP *svp2 ;
  ArtSvpWriter *swr ;

  {
  {
#line 533
  vpath[0].code = (ArtPathcode )0;
#line 533
  vpath[0].x = (double )100;
#line 533
  vpath[0].y = (double )100;
#line 533
  vpath[1].code = (ArtPathcode )3;
#line 533
  vpath[1].x = (double )100;
#line 533
  vpath[1].y = (double )400;
#line 533
  vpath[2].code = (ArtPathcode )3;
#line 533
  vpath[2].x = (double )400;
#line 533
  vpath[2].y = (double )400;
#line 533
  vpath[3].code = (ArtPathcode )3;
#line 533
  vpath[3].x = (double )400;
#line 533
  vpath[3].y = (double )100;
#line 533
  vpath[4].code = (ArtPathcode )3;
#line 533
  vpath[4].x = (double )100;
#line 533
  vpath[4].y = (double )100;
#line 533
  vpath[5].code = (ArtPathcode )0;
#line 533
  vpath[5].x = (double )110;
#line 533
  vpath[5].y = (double )110;
#line 533
  vpath[6].code = (ArtPathcode )3;
#line 533
  vpath[6].x = (double )110;
#line 533
  vpath[6].y = (double )410;
#line 533
  vpath[7].code = (ArtPathcode )3;
#line 533
  vpath[7].x = (double )410;
#line 533
  vpath[7].y = (double )410;
#line 533
  vpath[8].code = (ArtPathcode )3;
#line 533
  vpath[8].x = (double )410;
#line 533
  vpath[8].y = (double )110;
#line 533
  vpath[9].code = (ArtPathcode )3;
#line 533
  vpath[9].x = (double )110;
#line 533
  vpath[9].y = (double )110;
#line 533
  vpath[10].code = (ArtPathcode )4;
#line 533
  vpath[10].x = (double )0;
#line 533
  vpath[10].y = (double )0;
#line 581
  svp = art_svp_from_vpath(vpath);
#line 585
  swr = art_svp_writer_rewind_new((ArtWindRule )2);
#line 586
  art_svp_intersector((ArtSVP const   *)svp, swr);
#line 588
  svp2 = art_svp_writer_rewind_reap(swr);
#line 594
  print_svp(svp2);
#line 597
  art_svp_free(svp);
#line 600
  art_svp_free(svp2);
  }
#line 602
  return;
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/testart.c"
static void usage(void) 
{ 


  {
  {
#line 607
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: testart <test>\n  where <test> is one of:\n  testpat    -- make random star + gradients test pattern\n  gradient   -- test pattern for rendered gradients\n  dash       -- dash test (output is valid PostScript)\n  dist       -- distance test\n  intersect  -- softball test for intersector\n");
#line 614
  exit(1);
  }
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_vpath.c"
static void reverse_points___1(ArtPoint *points , int n_points ) 
{ 
  int i ;
  ArtPoint tmp_p ;

  {
#line 41
  i = 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < n_points >> 1)) {
#line 41
      goto while_break;
    }
#line 43
    tmp_p = *(points + i);
#line 44
    *(points + i) = *(points + (n_points - (i + 1)));
#line 45
    *(points + (n_points - (i + 1))) = tmp_p;
#line 41
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_affine.c"
static int art_ftoa___1(char *str , double x ) 
{ 
  char *p ;
  int i ;
  int j ;
  double tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int ix ;
  char *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;

  {
  {
#line 113
  p = (char *)str;
#line 116
  p = (char *)str;
#line 117
  tmp = fabs(x);
  }
#line 117
  if (tmp < 1e-6 / (double )2) {
    {
#line 119
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"0");
    }
#line 120
    return (1);
  }
#line 122
  if (x < (double )0) {
#line 124
    tmp___0 = p;
#line 124
    p ++;
#line 124
    *tmp___0 = (char )'-';
#line 125
    x = - x;
  }
  {
#line 127
  tmp___9 = floor((double )(x + 1e-6 / (double )2 < (double )1));
  }
#line 127
  if ((int )tmp___9) {
    {
#line 129
    tmp___1 = p;
#line 129
    p ++;
#line 129
    *tmp___1 = (char )'0';
#line 130
    tmp___2 = p;
#line 130
    p ++;
#line 130
    *tmp___2 = (char )'.';
#line 131
    tmp___3 = floor((x + 1e-6 / (double )2) * 1e6);
#line 131
    i = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%06d",
                (int )tmp___3);
    }
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (i) {
#line 132
        if (! ((int )*(p + (i - 1)) == 48)) {
#line 132
          goto while_break;
        }
      } else {
#line 132
        goto while_break;
      }
#line 133
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 134
    if (i == 0) {
#line 135
      i --;
    }
#line 136
    p += i;
  } else
#line 138
  if (x < 1e6) {
    {
#line 140
    tmp___4 = floor(x + 1e-6 / (double )2);
#line 140
    i = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d",
                (int )tmp___4);
#line 141
    p += i;
    }
#line 142
    if (i < 6) {
      {
#line 146
      tmp___5 = p;
#line 146
      p ++;
#line 146
      *tmp___5 = (char )'.';
#line 147
      tmp___6 = floor(x + 1e-6 / (double )2);
#line 147
      x -= tmp___6;
#line 148
      j = i;
      }
      {
#line 148
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 148
        if (! (j < 6)) {
#line 148
          goto while_break___0;
        }
#line 149
        x *= (double )10;
#line 148
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 150
      tmp___7 = floor(x + 0.5);
#line 150
      ix = (int )tmp___7;
#line 152
      j = 0;
      }
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 152
        if (! (j < i)) {
#line 152
          goto while_break___1;
        }
#line 153
        ix *= 10;
#line 152
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 157
      if (ix == 1000000) {
#line 158
        ix = 999999;
      }
      {
#line 160
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%06d",
              ix);
#line 161
      i = 6 - i;
      }
      {
#line 162
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 162
        if (i) {
#line 162
          if (! ((int )*(p + (i - 1)) == 48)) {
#line 162
            goto while_break___2;
          }
        } else {
#line 162
          goto while_break___2;
        }
#line 163
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 164
      if (i == 0) {
#line 165
        i --;
      }
#line 166
      p += i;
    }
  } else {
    {
#line 170
    tmp___8 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%g",
                      x);
#line 170
    p += tmp___8;
    }
  }
#line 172
  *p = (char )'\000';
#line 173
  return ((int )(p - (char *)str));
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_vpath_dash.c"
static int art_vpath_dash_max_subpath___1(ArtVpath const   *vpath ) 
{ 
  int max_subpath ;
  int i ;
  int start ;

  {
#line 41
  max_subpath = 0;
#line 42
  start = 0;
#line 43
  i = 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! ((unsigned int const   )(vpath + i)->code != 4U)) {
#line 43
      goto while_break;
    }
#line 45
    if ((unsigned int const   )(vpath + i)->code == 0U) {
#line 45
      goto _L;
    } else
#line 45
    if ((unsigned int const   )(vpath + i)->code == 1U) {
      _L: /* CIL Label */ 
#line 47
      if (i - start > max_subpath) {
#line 48
        max_subpath = i - start;
      }
#line 49
      start = i;
    }
#line 43
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (i - start > max_subpath) {
#line 53
    max_subpath = i - start;
  }
#line 55
  return (max_subpath);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_pixbuf.c"
static void art_pixel_destroy___1(void *func_data , void *data ) 
{ 


  {
  {
#line 163
  art_free(data);
  }
#line 164
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_nop_done___1(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_rgb8___1(ArtRenderCallback *self , ArtRender *render ,
                                             art_u8 *dest , int y ) 
{ 
  int width ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  ArtPixMaxDepth color_max ;

  {
  {
#line 160
  width = render->x1 - render->x0;
#line 164
  color_max = render->clear_color[0];
#line 165
  r = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 166
  color_max = render->clear_color[1];
#line 167
  g = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 168
  color_max = render->clear_color[2];
#line 169
  b = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 171
  art_rgb_fill_run(dest, r, g, b, width);
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_8___1(ArtRenderCallback *self , ArtRender *render ,
                                          art_u8 *dest , int y ) 
{ 
  int width ;
  int i ;
  int j ;
  int n_ch ;
  int ix ;
  art_u8 color[17] ;
  ArtPixMaxDepth color_max ;
  int tmp ;

  {
#line 178
  width = render->x1 - render->x0;
#line 180
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 184
  j = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (j < n_ch)) {
#line 184
      goto while_break;
    }
#line 186
    color_max = render->clear_color[j];
#line 187
    color[j] = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 184
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  ix = 0;
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 191
    if (! (i < width)) {
#line 191
      goto while_break___0;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if (! (j < n_ch)) {
#line 192
        goto while_break___1;
      }
#line 193
      tmp = ix;
#line 193
      ix ++;
#line 193
      *(dest + tmp) = color[j];
#line 192
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_clear_render_16___1(ArtRenderCallback *self , ArtRender *render ,
                                           art_u8 *dest , int y ) 
{ 
  int width ;
  int i ;
  int j ;
  int n_ch ;
  int ix ;
  art_u16 *dest_16 ;
  art_u8 color[17] ;
  int color_16 ;
  int tmp ;

  {
#line 214
  width = render->x1 - render->x0;
#line 216
  n_ch = render->n_chan + ((unsigned int )render->alpha_type != 0U);
#line 218
  dest_16 = (art_u16 *)dest;
#line 221
  j = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (j < n_ch)) {
#line 221
      goto while_break;
    }
#line 223
    color_16 = (int )render->clear_color[j];
#line 224
    color[j] = (art_u8 )color_16;
#line 221
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  ix = 0;
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! (i < width)) {
#line 228
      goto while_break___0;
    }
#line 229
    j = 0;
    {
#line 229
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 229
      if (! (j < n_ch)) {
#line 229
        goto while_break___1;
      }
#line 230
      tmp = ix;
#line 230
      ix ++;
#line 230
      *(dest_16 + tmp) = (art_u16 )color[j];
#line 229
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 228
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static ArtRenderCallback *art_render_choose_clear_callback___1(ArtRender *render ) 
{ 
  ArtRenderCallback *clear_callback ;

  {
#line 247
  if (render->depth == 8) {
#line 249
    if (render->n_chan == 3) {
#line 249
      if ((unsigned int )render->alpha_type == 0U) {
#line 251
        clear_callback = (ArtRenderCallback *)(& art_render_clear_rgb8_obj);
      } else {
#line 253
        clear_callback = (ArtRenderCallback *)(& art_render_clear_8_obj);
      }
    } else {
#line 253
      clear_callback = (ArtRenderCallback *)(& art_render_clear_8_obj);
    }
  } else
#line 256
  if (render->depth == 16) {
#line 257
    clear_callback = (ArtRenderCallback *)(& art_render_clear_16_obj);
  } else {
    {
#line 261
    art_die("art_render_choose_clear_callback: inconsistent render->depth = %d\n",
            render->depth);
    }
  }
#line 264
  return (clear_callback);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite___1(ArtRenderCallback *self , ArtRender *render ,
                                     art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  art_u32 depth ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *alpha_buf ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  art_u32 alpha ;
  int image_ix ;
  art_u16 src[17] ;
  art_u16 dst[17] ;
  int n_chan ;
  ArtAlphaType alpha_type ;
  int n_ch ;
  int dst_pixstride ;
  int buf_depth ;
  ArtAlphaType buf_alpha ;
  int buf_n_ch ;
  int buf_pixstride ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 srcv ;
  art_u32 dstv ;
  art_u32 tmp___0 ;

  {
#line 286
  run = render->run;
#line 287
  depth = (art_u32 )render->depth;
#line 288
  n_run = render->n_run;
#line 289
  x0 = render->x0;
#line 292
  alpha_buf = render->alpha_buf;
#line 293
  image_buf = render->image_buf;
#line 301
  n_chan = render->n_chan;
#line 302
  alpha_type = render->alpha_type;
#line 303
  n_ch = n_chan + ((unsigned int )alpha_type != 0U);
#line 304
  dst_pixstride = (int )((art_u32 )n_ch * (depth >> 3));
#line 305
  buf_depth = render->buf_depth;
#line 306
  buf_alpha = render->buf_alpha;
#line 307
  buf_n_ch = n_chan + ((unsigned int )buf_alpha != 0U);
#line 308
  buf_pixstride = buf_n_ch * (buf_depth >> 3);
#line 316
  image_ix = 0;
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! (i < n_run - 1)) {
#line 317
      goto while_break;
    }
#line 319
    run_x0 = (run + i)->x;
#line 320
    run_x1 = (run + (i + 1))->x;
#line 321
    tmp = (art_u32 )(run + i)->alpha;
#line 322
    if (tmp < 33024U) {
#line 323
      goto __Cont;
    }
#line 325
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 326
    bufptr = image_buf + (run_x0 - x0) * buf_pixstride;
#line 327
    dstptr = dest + (run_x0 - x0) * dst_pixstride;
#line 328
    x = run_x0;
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! (x < run_x1)) {
#line 328
        goto while_break___0;
      }
#line 330
      if (alpha_buf) {
#line 332
        if (depth == 8U) {
#line 334
          tmp = run_alpha * (art_u32 )*(alpha_buf + (x - x0)) + 128U;
#line 336
          alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
        } else {
#line 340
          tmp = (art_u32 )*((art_u16 *)alpha_buf + (x - x0));
#line 341
          tmp = (run_alpha * tmp + 32768U) >> 8;
#line 343
          alpha = (tmp + (tmp >> 16)) >> 8;
        }
      } else {
#line 347
        alpha = run_alpha;
      }
#line 352
      if ((unsigned int )buf_alpha == 0U) {
#line 354
        src_alpha = alpha;
#line 355
        src_mul = src_alpha;
      } else {
#line 359
        if (buf_depth == 8) {
#line 361
          tmp = alpha * (art_u32 )*(bufptr + n_chan) + 128U;
#line 363
          src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
        } else {
#line 367
          tmp = (art_u32 )*((art_u16 *)bufptr + n_chan);
#line 368
          tmp = (alpha * tmp + 32768U) >> 8;
#line 370
          src_alpha = (tmp + (tmp >> 16)) >> 8;
        }
#line 372
        if ((unsigned int )buf_alpha == 1U) {
#line 373
          src_mul = src_alpha;
        } else {
#line 375
          src_mul = alpha;
        }
      }
#line 380
      if (buf_depth == 8) {
#line 382
        src_mul *= 257U;
#line 383
        j = 0;
        {
#line 383
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 383
          if (! (j < n_chan)) {
#line 383
            goto while_break___1;
          }
#line 384
          src[j] = (art_u16 )(((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16);
#line 383
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 386
      if (buf_depth == 16) {
#line 388
        j = 0;
        {
#line 388
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 388
          if (! (j < n_chan)) {
#line 388
            goto while_break___2;
          }
#line 389
          src[j] = (art_u16 )(((art_u32 )*((art_u16 *)bufptr + j) * src_mul + 32768U) >> 16);
#line 388
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 391
      bufptr += buf_pixstride;
#line 399
      if ((unsigned int )alpha_type == 0U) {
#line 401
        dst_alpha = (art_u32 )65536;
#line 402
        dst_mul = dst_alpha;
      } else {
#line 406
        if (depth == 8U) {
#line 408
          tmp = (art_u32 )*(dstptr + n_chan);
#line 410
          dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
        } else {
#line 414
          tmp = (art_u32 )*((art_u16 *)dstptr + n_chan);
#line 415
          dst_alpha = tmp + (tmp >> 15);
        }
#line 417
        if ((unsigned int )alpha_type == 1U) {
#line 418
          dst_mul = dst_alpha;
        } else {
#line 420
          dst_mul = (art_u32 )65536;
        }
      }
#line 425
      if (depth == 8U) {
#line 427
        dst_mul *= 257U;
#line 428
        j = 0;
        {
#line 428
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 428
          if (! (j < n_chan)) {
#line 428
            goto while_break___3;
          }
#line 429
          dst[j] = (art_u16 )(((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16);
#line 428
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 431
      if (buf_depth == 16) {
#line 433
        j = 0;
        {
#line 433
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 433
          if (! (j < n_chan)) {
#line 433
            goto while_break___4;
          }
#line 434
          dst[j] = (art_u16 )(((art_u32 )*((art_u16 *)dstptr + j) * dst_mul + 32768U) >> 16);
#line 433
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 438
      j = 0;
      {
#line 438
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 438
        if (! (j < n_chan)) {
#line 438
          goto while_break___5;
        }
#line 443
        srcv = (art_u32 )src[j];
#line 444
        dstv = (art_u32 )dst[j];
#line 445
        tmp___0 = ((dstv * (65536U - src_alpha) + 32768U) >> 16) + srcv;
#line 446
        tmp___0 -= tmp___0 >> 16;
#line 447
        dst[j] = (art_u16 )tmp___0;
#line 438
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 450
      if ((unsigned int )alpha_type == 0U) {
#line 452
        if (depth == 8U) {
#line 453
          dst_mul = (art_u32 )255;
        } else {
#line 455
          dst_mul = (art_u32 )65535;
        }
      } else {
#line 459
        if (src_alpha >= 65536U) {
#line 460
          dst_alpha = (art_u32 )65536;
        } else {
#line 462
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 463
        if ((unsigned int )alpha_type == 2U) {
#line 463
          goto _L;
        } else
#line 463
        if (dst_alpha == 0U) {
          _L: /* CIL Label */ 
#line 465
          if (depth == 8U) {
#line 466
            dst_mul = (art_u32 )255;
          } else {
#line 468
            dst_mul = (art_u32 )65535;
          }
        } else
#line 472
        if (depth == 8U) {
#line 473
          dst_mul = 16711680U / dst_alpha;
        } else {
#line 475
          dst_mul = 4294901760U / dst_alpha;
        }
      }
#line 478
      if (depth == 8U) {
#line 480
        j = 0;
        {
#line 480
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 480
          if (! (j < n_chan)) {
#line 480
            goto while_break___6;
          }
#line 481
          *(dstptr + j) = (art_u8 )(((art_u32 )dst[j] * dst_mul + 32768U) >> 16);
#line 480
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 482
        if ((unsigned int )alpha_type != 0U) {
#line 483
          *(dstptr + n_chan) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
        }
      } else
#line 485
      if (depth == 16U) {
#line 487
        j = 0;
        {
#line 487
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 487
          if (! (j < n_chan)) {
#line 487
            goto while_break___7;
          }
#line 488
          *((art_u16 *)dstptr + j) = (art_u16 )(((art_u32 )dst[j] * dst_mul + 32768U) >> 16);
#line 487
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 489
        if ((unsigned int )alpha_type != 0U) {
#line 490
          *((art_u16 *)dstptr + n_chan) = (art_u16 )((dst_alpha * 65535U + 32768U) >> 16);
        }
      }
#line 492
      dstptr += dst_pixstride;
#line 328
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return;
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8___1(ArtRenderCallback *self , ArtRender *render ,
                                       art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *alpha_buf ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  art_u32 alpha ;
  int image_ix ;
  int n_chan ;
  ArtAlphaType alpha_type ;
  int n_ch ;
  int dst_pixstride ;
  ArtAlphaType buf_alpha ;
  int buf_n_ch ;
  int buf_pixstride ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___0 ;

  {
#line 507
  run = render->run;
#line 508
  n_run = render->n_run;
#line 509
  x0 = render->x0;
#line 512
  alpha_buf = render->alpha_buf;
#line 513
  image_buf = render->image_buf;
#line 519
  n_chan = render->n_chan;
#line 520
  alpha_type = render->alpha_type;
#line 521
  n_ch = n_chan + ((unsigned int )alpha_type != 0U);
#line 522
  dst_pixstride = n_ch;
#line 523
  buf_alpha = render->buf_alpha;
#line 524
  buf_n_ch = n_chan + ((unsigned int )buf_alpha != 0U);
#line 525
  buf_pixstride = buf_n_ch;
#line 533
  image_ix = 0;
#line 534
  i = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < n_run - 1)) {
#line 534
      goto while_break;
    }
#line 536
    run_x0 = (run + i)->x;
#line 537
    run_x1 = (run + (i + 1))->x;
#line 538
    tmp = (art_u32 )(run + i)->alpha;
#line 539
    if (tmp < 65536U) {
#line 540
      goto __Cont;
    }
#line 542
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 543
    bufptr = image_buf + (run_x0 - x0) * buf_pixstride;
#line 544
    dstptr = dest + (run_x0 - x0) * dst_pixstride;
#line 545
    x = run_x0;
    {
#line 545
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 545
      if (! (x < run_x1)) {
#line 545
        goto while_break___0;
      }
#line 547
      if (alpha_buf) {
#line 549
        tmp = run_alpha * (art_u32 )*(alpha_buf + (x - x0)) + 128U;
#line 551
        alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
      } else {
#line 554
        alpha = run_alpha;
      }
#line 559
      if ((unsigned int )buf_alpha == 0U) {
#line 561
        src_alpha = alpha;
#line 562
        src_mul = src_alpha;
      } else {
#line 566
        tmp = alpha * (art_u32 )*(bufptr + n_chan) + 128U;
#line 568
        src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
#line 570
        if ((unsigned int )buf_alpha == 1U) {
#line 571
          src_mul = src_alpha;
        } else {
#line 573
          src_mul = alpha;
        }
      }
#line 578
      src_mul *= 257U;
#line 580
      if ((unsigned int )alpha_type == 0U) {
#line 582
        dst_alpha = (art_u32 )65536;
#line 583
        dst_mul = dst_alpha;
      } else {
#line 587
        tmp = (art_u32 )*(dstptr + n_chan);
#line 589
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 590
        if ((unsigned int )alpha_type == 1U) {
#line 591
          dst_mul = dst_alpha;
        } else {
#line 593
          dst_mul = (art_u32 )65536;
        }
      }
#line 598
      dst_mul *= 257U;
#line 600
      if ((unsigned int )alpha_type == 0U) {
#line 602
        dst_save_mul = (art_u32 )255;
      } else {
#line 606
        if (src_alpha >= 65536U) {
#line 607
          dst_alpha = (art_u32 )65536;
        } else {
#line 609
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 610
        if ((unsigned int )alpha_type == 2U) {
#line 612
          dst_save_mul = (art_u32 )255;
        } else
#line 610
        if (dst_alpha == 0U) {
#line 612
          dst_save_mul = (art_u32 )255;
        } else {
#line 616
          dst_save_mul = 16711680U / dst_alpha;
        }
      }
#line 620
      j = 0;
      {
#line 620
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 620
        if (! (j < n_chan)) {
#line 620
          goto while_break___1;
        }
#line 625
        src = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 626
        dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 627
        tmp___0 = ((dst * (65536U - src_alpha) + 32768U) >> 16) + src;
#line 628
        tmp___0 -= tmp___0 >> 16;
#line 629
        *(dstptr + j) = (art_u8 )((tmp___0 * dst_save_mul + 32768U) >> 16);
#line 620
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 631
      if ((unsigned int )alpha_type != 0U) {
#line 632
        *(dstptr + n_chan) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
      }
#line 634
      bufptr += buf_pixstride;
#line 635
      dstptr += dst_pixstride;
#line 545
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8_opt1___1(ArtRenderCallback *self , ArtRender *render ,
                                            art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  int image_ix ;
  art_u8 *bufptr ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u8 *tmp___0 ;
  art_u8 *tmp___1 ;
  art_u8 *tmp___2 ;
  art_u8 *tmp___3 ;
  art_u8 *tmp___4 ;
  art_u8 *tmp___5 ;
  art_u8 *tmp___6 ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___7 ;

  {
#line 657
  run = render->run;
#line 658
  n_run = render->n_run;
#line 659
  x0 = render->x0;
#line 662
  image_buf = render->image_buf;
#line 673
  image_ix = 0;
#line 674
  i = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (i < n_run - 1)) {
#line 674
      goto while_break;
    }
#line 676
    run_x0 = (run + i)->x;
#line 677
    run_x1 = (run + (i + 1))->x;
#line 678
    tmp = (art_u32 )(run + i)->alpha;
#line 679
    if (tmp < 65536U) {
#line 680
      goto __Cont;
    }
#line 682
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 683
    bufptr = image_buf + (run_x0 - x0) * 3;
#line 684
    dstptr = dest + (run_x0 - x0) * 4;
#line 685
    if (run_alpha == 65536U) {
#line 687
      x = run_x0;
      {
#line 687
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 687
        if (! (x < run_x1)) {
#line 687
          goto while_break___0;
        }
#line 689
        tmp___0 = dstptr;
#line 689
        dstptr ++;
#line 689
        tmp___1 = bufptr;
#line 689
        bufptr ++;
#line 689
        *tmp___0 = *tmp___1;
#line 690
        tmp___2 = dstptr;
#line 690
        dstptr ++;
#line 690
        tmp___3 = bufptr;
#line 690
        bufptr ++;
#line 690
        *tmp___2 = *tmp___3;
#line 691
        tmp___4 = dstptr;
#line 691
        dstptr ++;
#line 691
        tmp___5 = bufptr;
#line 691
        bufptr ++;
#line 691
        *tmp___4 = *tmp___5;
#line 692
        tmp___6 = dstptr;
#line 692
        dstptr ++;
#line 692
        *tmp___6 = (art_u8 )255;
#line 687
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 697
      x = run_x0;
      {
#line 697
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 697
        if (! (x < run_x1)) {
#line 697
          goto while_break___1;
        }
#line 699
        src_mul = run_alpha * 257U;
#line 701
        tmp = (art_u32 )*(dstptr + 3);
#line 703
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 704
        dst_mul = dst_alpha;
#line 708
        dst_mul *= 257U;
#line 710
        dst_alpha += (((65536U - dst_alpha) * run_alpha >> 8) + 128U) >> 8;
#line 711
        if (dst_alpha == 0U) {
#line 712
          dst_save_mul = (art_u32 )255;
        } else {
#line 714
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 716
        j = 0;
        {
#line 716
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 716
          if (! (j < 3)) {
#line 716
            goto while_break___2;
          }
#line 721
          src = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 722
          dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 723
          tmp___7 = ((dst * (65536U - run_alpha) + 32768U) >> 16) + src;
#line 724
          tmp___7 -= tmp___7 >> 16;
#line 725
          *(dstptr + j) = (art_u8 )((tmp___7 * dst_save_mul + 32768U) >> 16);
#line 716
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 727
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 729
        bufptr += 3;
#line 730
        dstptr += 4;
#line 697
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 674
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_composite_8_opt2___1(ArtRenderCallback *self , ArtRender *render ,
                                            art_u8 *dest , int y ) 
{ 
  ArtRenderMaskRun *run ;
  int n_run ;
  int x0 ;
  int x ;
  int run_x0 ;
  int run_x1 ;
  art_u8 *image_buf ;
  int i ;
  int j ;
  art_u32 tmp ;
  art_u32 run_alpha ;
  int image_ix ;
  art_u8 *bufptr ;
  art_u32 src_alpha ;
  art_u32 src_mul ;
  art_u8 *dstptr ;
  art_u32 dst_alpha ;
  art_u32 dst_mul ;
  art_u32 dst_save_mul ;
  art_u32 src ;
  art_u32 dst ;
  art_u32 tmp___0 ;
  art_u32 src___0 ;
  art_u32 dst___0 ;
  art_u32 tmp___1 ;

  {
#line 753
  run = render->run;
#line 754
  n_run = render->n_run;
#line 755
  x0 = render->x0;
#line 758
  image_buf = render->image_buf;
#line 770
  image_ix = 0;
#line 771
  i = 0;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i < n_run - 1)) {
#line 771
      goto while_break;
    }
#line 773
    run_x0 = (run + i)->x;
#line 774
    run_x1 = (run + (i + 1))->x;
#line 775
    tmp = (art_u32 )(run + i)->alpha;
#line 776
    if (tmp < 65536U) {
#line 777
      goto __Cont;
    }
#line 779
    run_alpha = (((tmp + (tmp >> 8)) + (tmp >> 16)) - 32768U) >> 8;
#line 780
    bufptr = image_buf + (run_x0 - x0) * 4;
#line 781
    dstptr = dest + (run_x0 - x0) * 4;
#line 782
    if (run_alpha == 65536U) {
#line 784
      x = run_x0;
      {
#line 784
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 784
        if (! (x < run_x1)) {
#line 784
          goto while_break___0;
        }
#line 786
        src_alpha = (art_u32 )((((int )*(bufptr + 3) << 8) + (int )*(bufptr + 3)) + ((int )*(bufptr + 3) >> 7));
#line 790
        dst_alpha = (art_u32 )((((int )*(dstptr + 3) << 8) + (int )*(dstptr + 3)) + ((int )*(dstptr + 3) >> 7));
#line 794
        dst_mul = dst_alpha * 257U;
#line 796
        if (src_alpha >= 65536U) {
#line 797
          dst_alpha = (art_u32 )65536;
        } else {
#line 799
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 801
        if (dst_alpha == 0U) {
#line 802
          dst_save_mul = (art_u32 )255;
        } else {
#line 804
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 806
        j = 0;
        {
#line 806
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 806
          if (! (j < 3)) {
#line 806
            goto while_break___1;
          }
#line 811
          src = (art_u32 )(((int )*(bufptr + j) << 8) | (int )*(bufptr + j));
#line 812
          dst = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 813
          tmp___0 = ((dst * (65536U - src_alpha) + 32768U) >> 16) + src;
#line 814
          tmp___0 -= tmp___0 >> 16;
#line 815
          *(dstptr + j) = (art_u8 )((tmp___0 * dst_save_mul + 32768U) >> 16);
#line 806
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 817
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 819
        bufptr += 4;
#line 820
        dstptr += 4;
#line 784
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 825
      x = run_x0;
      {
#line 825
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 825
        if (! (x < run_x1)) {
#line 825
          goto while_break___2;
        }
#line 827
        tmp = run_alpha * (art_u32 )*(bufptr + 3) + 128U;
#line 829
        src_alpha = ((tmp + (tmp >> 8)) + (tmp >> 16)) >> 8;
#line 833
        src_mul = run_alpha * 257U;
#line 835
        tmp = (art_u32 )*(dstptr + 3);
#line 837
        dst_alpha = ((tmp << 8) + tmp) + (tmp >> 7);
#line 838
        dst_mul = dst_alpha;
#line 842
        dst_mul *= 257U;
#line 844
        if (src_alpha >= 65536U) {
#line 845
          dst_alpha = (art_u32 )65536;
        } else {
#line 847
          dst_alpha += (((65536U - dst_alpha) * src_alpha >> 8) + 128U) >> 8;
        }
#line 849
        if (dst_alpha == 0U) {
#line 851
          dst_save_mul = (art_u32 )255;
        } else {
#line 855
          dst_save_mul = 16711680U / dst_alpha;
        }
#line 858
        j = 0;
        {
#line 858
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 858
          if (! (j < 3)) {
#line 858
            goto while_break___3;
          }
#line 863
          src___0 = ((art_u32 )*(bufptr + j) * src_mul + 32768U) >> 16;
#line 864
          dst___0 = ((art_u32 )*(dstptr + j) * dst_mul + 32768U) >> 16;
#line 865
          tmp___1 = ((dst___0 * (65536U - src_alpha) + 32768U) >> 16) + src___0;
#line 866
          tmp___1 -= tmp___1 >> 16;
#line 867
          *(dstptr + j) = (art_u8 )((tmp___1 * dst_save_mul + 32768U) >> 16);
#line 858
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 869
        *(dstptr + 3) = (art_u8 )((dst_alpha * 255U + 32768U) >> 16);
#line 871
        bufptr += 4;
#line 872
        dstptr += 4;
#line 825
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static ArtRenderCallback *art_render_choose_compositing_callback___1(ArtRender *render ) 
{ 


  {
#line 889
  if (render->depth == 8) {
#line 889
    if (render->buf_depth == 8) {
#line 891
      if (render->n_chan == 3) {
#line 891
        if ((unsigned long )render->alpha_buf == (unsigned long )((void *)0)) {
#line 891
          if ((unsigned int )render->alpha_type == 1U) {
#line 895
            if ((unsigned int )render->buf_alpha == 0U) {
#line 896
              return ((ArtRenderCallback *)(& art_render_composite_8_opt1_obj));
            } else
#line 897
            if ((unsigned int )render->buf_alpha == 2U) {
#line 898
              return ((ArtRenderCallback *)(& art_render_composite_8_opt2_obj));
            }
          }
        }
      }
#line 901
      return ((ArtRenderCallback *)(& art_render_composite_8_obj));
    }
  }
#line 903
  return ((ArtRenderCallback *)(& art_render_composite_obj));
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_done___1(ArtRenderCallback *self , ArtRender *render ) 
{ 
  ArtImageSourceSolid *z ;

  {
#line 1176
  z = (ArtImageSourceSolid *)self;
#line 1178
  if ((unsigned long )z->rgbtab != (unsigned long )((void *)0)) {
    {
#line 1179
    art_free((void *)z->rgbtab);
    }
  }
  {
#line 1180
  art_free((void *)self);
  }
#line 1181
  return;
}
}
#line 1183 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8_opaq_init___1(ArtImageSourceSolid *self ,
                                                      ArtRender *render ) 
{ 
  ArtImageSourceSolid *z ;
  ArtPixMaxDepth color_max ;
  int r_fg ;
  int g_fg ;
  int b_fg ;
  int r_bg ;
  int g_bg ;
  int b_bg ;
  int r ;
  int g ;
  int b ;
  int dr ;
  int dg ;
  int db ;
  int i ;
  int tmp ;
  art_u32 *rgbtab ;
  void *tmp___0 ;

  {
  {
#line 1186
  z = self;
#line 1196
  tmp___0 = art_alloc(256UL * sizeof(art_u32 ));
#line 1196
  rgbtab = (art_u32 *)tmp___0;
#line 1197
  z->rgbtab = rgbtab;
#line 1199
  color_max = self->color[0];
#line 1200
  r_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1201
  color_max = self->color[1];
#line 1202
  g_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1203
  color_max = self->color[2];
#line 1204
  b_fg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1206
  color_max = render->clear_color[0];
#line 1207
  r_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1208
  color_max = render->clear_color[1];
#line 1209
  g_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1210
  color_max = render->clear_color[2];
#line 1211
  b_bg = (((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8;
#line 1213
  r = (r_bg << 16) + 32768;
#line 1214
  g = (g_bg << 16) + 32768;
#line 1215
  b = (b_bg << 16) + 32768;
#line 1216
  tmp = ((r_fg - r_bg) << 16) + 128;
#line 1217
  dr = (tmp + (tmp >> 8)) >> 8;
#line 1218
  tmp = ((g_fg - g_bg) << 16) + 128;
#line 1219
  dg = (tmp + (tmp >> 8)) >> 8;
#line 1220
  tmp = ((b_fg - b_bg) << 16) + 128;
#line 1221
  db = (tmp + (tmp >> 8)) >> 8;
#line 1223
  i = 0;
  }
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (i < 256)) {
#line 1223
      goto while_break;
    }
#line 1225
    *(rgbtab + i) = (art_u32 )(((r & 16711680) | ((g & 16711680) >> 8)) | (b >> 16));
#line 1226
    r += dr;
#line 1227
    g += dg;
#line 1228
    b += db;
#line 1223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1230
  return;
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8_opaq___1(ArtRenderCallback *self , ArtRender *render ,
                                                 art_u8 *dest , int y ) 
{ 
  ArtImageSourceSolid *z ;
  ArtRenderMaskRun *run ;
  int n_run ;
  art_u32 *rgbtab ;
  art_u32 rgb ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  int i ;
  int ix ;

  {
#line 1236
  z = (ArtImageSourceSolid *)self;
#line 1237
  run = render->run;
#line 1238
  n_run = render->n_run;
#line 1239
  rgbtab = z->rgbtab;
#line 1241
  x0 = render->x0;
#line 1242
  x1 = render->x1;
#line 1247
  if (n_run > 0) {
#line 1249
    run_x1 = (run + 0)->x;
#line 1250
    if (run_x1 > x0) {
      {
#line 1252
      rgb = *(rgbtab + 0);
#line 1253
      art_rgb_fill_run(dest, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U), (art_u8 )(rgb & 255U),
                       run_x1 - x0);
      }
    }
#line 1257
    i = 0;
    {
#line 1257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1257
      if (! (i < n_run - 1)) {
#line 1257
        goto while_break;
      }
#line 1259
      run_x0 = run_x1;
#line 1260
      run_x1 = (run + (i + 1))->x;
#line 1261
      rgb = *(rgbtab + (((run + i)->alpha >> 16) & 255));
#line 1262
      ix = (run_x0 - x0) * 3;
#line 1265
      if (run_x1 - run_x0 == 1) {
#line 1267
        *(dest + ix) = (art_u8 )(rgb >> 16);
#line 1268
        *(dest + (ix + 1)) = (art_u8 )((rgb >> 8) & 255U);
#line 1269
        *(dest + (ix + 2)) = (art_u8 )(rgb & 255U);
      } else {
        {
#line 1273
        art_rgb_fill_run(dest + ix, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                         (art_u8 )(rgb & 255U), run_x1 - run_x0);
        }
      }
#line 1257
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1286
    run_x1 = x0;
  }
#line 1288
  if (run_x1 < x1) {
    {
#line 1290
    rgb = *(rgbtab + 0);
#line 1291
    art_rgb_fill_run(dest + (run_x1 - x0) * 3, (art_u8 )(rgb >> 16), (art_u8 )((rgb >> 8) & 255U),
                     (art_u8 )(rgb & 255U), x1 - run_x1);
    }
  }
#line 1295
  return;
}
}
#line 1297 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_rgb8___1(ArtRenderCallback *self , ArtRender *render ,
                                            art_u8 *dest , int y ) 
{ 
  ArtImageSourceSolid *z ;
  int width ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  ArtPixMaxDepth color_max ;

  {
#line 1301
  z = (ArtImageSourceSolid *)self;
#line 1302
  width = render->x1 - render->x0;
#line 1307
  if (z->init) {
#line 1308
    return;
  }
  {
#line 1309
  z->init = 1;
#line 1311
  color_max = z->color[0];
#line 1312
  r = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1313
  color_max = z->color[1];
#line 1314
  g = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1315
  color_max = z->color[2];
#line 1316
  b = (art_u8 )((((int )color_max + 128) - (((int )color_max + 128) >> 8)) >> 8);
#line 1318
  art_rgb_fill_run(render->image_buf, r, g, b, width);
  }
#line 1319
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void (*render_cbk___1)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                              int y )  ;
#line 1321 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render.c"
static void art_render_image_solid_negotiate___1(ArtImageSource *self , ArtRender *render ,
                                                 ArtImageSourceFlags *p_flags , int *p_buf_depth ,
                                                 ArtAlphaType *p_alpha ) 
{ 
  ArtImageSourceSolid *z ;
  ArtImageSourceFlags flags ;

  {
#line 1326
  z = (ArtImageSourceSolid *)self;
#line 1327
  flags = (ArtImageSourceFlags )0;
#line 1331
  render_cbk___1 = (void (*)(ArtRenderCallback *self , ArtRender *render , art_u8 *dest ,
                             int y ))((void *)0);
#line 1333
  if (render->depth == 8) {
#line 1333
    if (render->n_chan == 3) {
#line 1333
      if ((unsigned int )render->alpha_type == 0U) {
#line 1336
        if (render->clear) {
          {
#line 1338
          render_cbk___1 = & art_render_image_solid_rgb8_opaq___1;
#line 1339
          flags = (ArtImageSourceFlags )((unsigned int )flags | 3U);
#line 1340
          art_render_image_solid_rgb8_opaq_init___1(z, render);
          }
        }
      }
    }
  }
#line 1343
  if ((unsigned long )render_cbk___1 == (unsigned long )((void *)0)) {
#line 1345
    if (render->depth == 8) {
#line 1347
      render_cbk___1 = & art_render_image_solid_rgb8___1;
#line 1348
      *p_buf_depth = 8;
#line 1349
      *p_alpha = (ArtAlphaType )0;
    }
  }
#line 1353
  self->super.render = render_cbk___1;
#line 1354
  *p_flags = flags;
#line 1355
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtPriQ *art_pri_new___1(void) 
{ 
  ArtPriQ *result ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 65
  tmp = art_alloc(sizeof(ArtPriQ ));
#line 65
  result = (ArtPriQ *)tmp;
#line 67
  result->n_items = 0;
#line 68
  result->n_items_max = 16;
#line 69
  tmp___0 = art_alloc((unsigned long )result->n_items_max * sizeof(ArtPriPoint *));
#line 69
  result->items = (ArtPriPoint **)tmp___0;
  }
#line 70
  return (result);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_free___1(ArtPriQ *pq ) 
{ 


  {
  {
#line 76
  art_free((void *)pq->items);
#line 77
  art_free((void *)pq);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static art_boolean art_pri_empty___1(ArtPriQ *pq ) 
{ 


  {
#line 83
  return (pq->n_items == 0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_bubble_up___1(ArtPriQ *pq , int vacant , ArtPriPoint *missing ) 
{ 
  ArtPriPoint **items ;
  int parent ;

  {
#line 94
  items = pq->items;
#line 97
  parent = (vacant - 1) >> 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (vacant > 0) {
#line 98
      if (! (missing->y < (*(items + parent))->y)) {
#line 98
        if (missing->y == (*(items + parent))->y) {
#line 98
          if (! (missing->x < (*(items + parent))->x)) {
#line 98
            goto while_break;
          }
        } else {
#line 98
          goto while_break;
        }
      }
    } else {
#line 98
      goto while_break;
    }
#line 102
    *(items + vacant) = *(items + parent);
#line 103
    vacant = parent;
#line 104
    parent = (vacant - 1) >> 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  *(items + vacant) = missing;
#line 108
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_insert___1(ArtPriQ *pq , ArtPriPoint *point ) 
{ 
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 113
  if (pq->n_items == pq->n_items_max) {
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (pq->n_items_max) {
        {
#line 114
        tmp = pq->n_items_max << 1;
#line 114
        pq->n_items_max = tmp;
#line 114
        tmp___0 = art_realloc((void *)pq->items, (unsigned long )tmp * sizeof(ArtPriPoint *));
#line 114
        pq->items = (ArtPriPoint **)tmp___0;
        }
      } else {
        {
#line 114
        pq->n_items_max = 1;
#line 114
        tmp___1 = art_alloc(sizeof(ArtPriPoint *));
#line 114
        pq->items = (ArtPriPoint **)tmp___1;
        }
      }
#line 114
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 116
  tmp___2 = pq->n_items;
#line 116
  (pq->n_items) ++;
#line 116
  art_pri_bubble_up___1(pq, tmp___2, point);
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_pri_sift_down_from_root___1(ArtPriQ *pq , ArtPriPoint *missing ) 
{ 
  ArtPriPoint **items ;
  int vacant ;
  int child ;
  int n ;

  {
#line 122
  items = pq->items;
#line 123
  vacant = 0;
#line 123
  child = 2;
#line 124
  n = pq->n_items;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (child < n)) {
#line 126
      goto while_break;
    }
#line 128
    if ((*(items + (child - 1)))->y < (*(items + child))->y) {
#line 131
      child --;
    } else
#line 128
    if ((*(items + (child - 1)))->y == (*(items + child))->y) {
#line 128
      if ((*(items + (child - 1)))->x < (*(items + child))->x) {
#line 131
        child --;
      }
    }
#line 132
    *(items + vacant) = *(items + child);
#line 133
    vacant = child;
#line 134
    child = (vacant + 1) << 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (child == n) {
#line 138
    *(items + vacant) = *(items + (n - 1));
#line 139
    vacant = n - 1;
  }
  {
#line 142
  art_pri_bubble_up___1(pq, vacant, missing);
  }
#line 143
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtPriPoint *art_pri_choose___1(ArtPriQ *pq ) 
{ 
  ArtPriPoint *result ;

  {
  {
#line 148
  result = *(pq->items + 0);
#line 150
  (pq->n_items) --;
#line 150
  art_pri_sift_down_from_root___1(pq, *(pq->items + pq->n_items));
  }
#line 151
  return (result);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static int art_svp_writer_rewind_add_segment___1(ArtSvpWriter *self , int wind_left ,
                                                 int delta_wind , double x , double y ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVP *svp ;
  ArtSVPSeg *seg ;
  art_boolean left_filled ;
  art_boolean right_filled ;
  int wind_right ;
  int seg_num ;
  int init_n_points_max ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 318
  swr = (ArtSvpWriterRewind *)self;
#line 322
  wind_right = wind_left + delta_wind;
#line 324
  init_n_points_max = 4;
  {
#line 328
  if ((unsigned int )swr->rule == 0U) {
#line 328
    goto case_0;
  }
#line 332
  if ((unsigned int )swr->rule == 1U) {
#line 332
    goto case_1;
  }
#line 336
  if ((unsigned int )swr->rule == 2U) {
#line 336
    goto case_2;
  }
#line 340
  if ((unsigned int )swr->rule == 3U) {
#line 340
    goto case_3;
  }
#line 344
  goto switch_default;
  case_0: /* CIL Label */ 
#line 329
  left_filled = wind_left != 0;
#line 330
  right_filled = wind_right != 0;
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 333
  left_filled = wind_left > 1;
#line 334
  right_filled = wind_right > 1;
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
#line 337
  left_filled = wind_left & 1;
#line 338
  right_filled = wind_right & 1;
#line 339
  goto switch_break;
  case_3: /* CIL Label */ 
#line 341
  left_filled = wind_left > 0;
#line 342
  right_filled = wind_right > 0;
#line 343
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 345
  art_die("Unknown wind rule %d\n", (unsigned int )swr->rule);
  }
  switch_break: /* CIL Label */ ;
  }
#line 347
  if (left_filled == right_filled) {
#line 354
    return (-1);
  }
#line 357
  svp = swr->svp;
#line 358
  tmp = svp->n_segs;
#line 358
  (svp->n_segs) ++;
#line 358
  seg_num = tmp;
#line 359
  if (swr->n_segs_max == seg_num) {
    {
#line 361
    swr->n_segs_max <<= 1;
#line 362
    tmp___0 = art_realloc((void *)svp, sizeof(ArtSVP ) + (unsigned long )(swr->n_segs_max - 1) * sizeof(ArtSVPSeg ));
#line 362
    svp = (ArtSVP *)tmp___0;
#line 365
    swr->svp = svp;
#line 366
    tmp___1 = art_realloc((void *)swr->n_points_max, (unsigned long )swr->n_segs_max * sizeof(int ));
#line 366
    swr->n_points_max = (int *)tmp___1;
    }
  }
  {
#line 369
  seg = & svp->segs[seg_num];
#line 370
  seg->n_points = 1;
#line 371
  seg->dir = right_filled;
#line 372
  *(swr->n_points_max + seg_num) = init_n_points_max;
#line 373
  seg->bbox.x0 = x;
#line 374
  seg->bbox.y0 = y;
#line 375
  seg->bbox.x1 = x;
#line 376
  seg->bbox.y1 = y;
#line 377
  tmp___2 = art_alloc((unsigned long )init_n_points_max * sizeof(ArtPoint ));
#line 377
  seg->points = (ArtPoint *)tmp___2;
#line 378
  (seg->points + 0)->x = x;
#line 379
  (seg->points + 0)->y = y;
  }
#line 385
  return (seg_num);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_writer_rewind_add_point___1(ArtSvpWriter *self , int seg_id ,
                                                double x , double y ) 
{ 
  ArtSvpWriterRewind *swr ;
  ArtSVPSeg *seg ;
  int n_points ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 392
  swr = (ArtSvpWriterRewind *)self;
#line 399
  if (seg_id < 0) {
#line 401
    return;
  }
#line 403
  seg = & (swr->svp)->segs[seg_id];
#line 404
  tmp = seg->n_points;
#line 404
  (seg->n_points) ++;
#line 404
  n_points = tmp;
#line 405
  if (*(swr->n_points_max + seg_id) == n_points) {
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
#line 406
      if (*(swr->n_points_max + seg_id)) {
        {
#line 406
        tmp___0 = *(swr->n_points_max + seg_id) << 1;
#line 406
        *(swr->n_points_max + seg_id) = tmp___0;
#line 406
        tmp___1 = art_realloc((void *)seg->points, (unsigned long )tmp___0 * sizeof(ArtPoint ));
#line 406
        seg->points = (ArtPoint *)tmp___1;
        }
      } else {
        {
#line 406
        *(swr->n_points_max + seg_id) = 1;
#line 406
        tmp___2 = art_alloc(sizeof(ArtPoint ));
#line 406
        seg->points = (ArtPoint *)tmp___2;
        }
      }
#line 406
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 407
  (seg->points + n_points)->x = x;
#line 408
  (seg->points + n_points)->y = y;
#line 409
  if (x < seg->bbox.x0) {
#line 410
    seg->bbox.x0 = x;
  }
#line 411
  if (x > seg->bbox.x1) {
#line 412
    seg->bbox.x1 = x;
  }
#line 413
  seg->bbox.y1 = y;
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_writer_rewind_close_segment___1(ArtSvpWriter *self , int seg_id ) 
{ 


  {
#line 437
  return;
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_setup_seg___1(ArtActiveSeg *seg , ArtPriPoint *pri_pt ) 
{ 
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  int tmp ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double dx ;
  double dy ;
  double s ;
  double a ;
  double b ;
  double r2 ;
  double tmp___0 ;

  {
#line 549
  in_seg = seg->in_seg;
#line 550
  tmp = seg->in_curs;
#line 550
  (seg->in_curs) ++;
#line 550
  in_curs = tmp;
#line 555
  x0 = (in_seg->points + in_curs)->x;
#line 556
  y0___0 = (in_seg->points + in_curs)->y;
#line 557
  x1 = (in_seg->points + (in_curs + 1))->x;
#line 558
  y1___0 = (in_seg->points + (in_curs + 1))->y;
#line 559
  pri_pt->x = x1;
#line 560
  pri_pt->y = y1___0;
#line 561
  dx = x1 - x0;
#line 562
  dy = y1___0 - y0___0;
#line 563
  r2 = dx * dx + dy * dy;
#line 564
  if (r2 == (double )0) {
#line 564
    s = (double )1;
  } else {
    {
#line 564
    tmp___0 = sqrt(r2);
#line 564
    s = (double )1 / tmp___0;
    }
  }
#line 565
  a = dy * s;
#line 565
  seg->a = a;
#line 566
  b = - dx * s;
#line 566
  seg->b = b;
#line 567
  seg->c = - (a * x0 + b * y0___0);
#line 568
  seg->flags = (seg->flags & -2) | (dx > (double )0);
#line 569
  seg->x[0] = x0;
#line 570
  seg->x[1] = x1;
#line 571
  seg->y0 = y0___0;
#line 572
  seg->y1 = y1___0;
#line 573
  seg->n_stack = 1;
#line 574
  (seg->stack + 0)->x = x1;
#line 575
  (seg->stack + 0)->y = y1___0;
#line 576
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_add_horiz___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg **pp ;
  ArtActiveSeg *place ;
  ArtActiveSeg *place_right ;

  {
#line 596
  pp = & ctx->horiz_last;
#line 598
  place_right = (ArtActiveSeg *)((void *)0);
#line 602
  if (seg->flags & 16) {
    {
#line 604
    art_warn("*** attempt to put segment in horiz list twice\n");
    }
#line 605
    return;
  }
#line 607
  seg->flags |= 16;
#line 613
  place = *pp;
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if ((unsigned long )place != (unsigned long )((void *)0)) {
#line 613
      if (! (place->horiz_x > seg->horiz_x)) {
#line 613
        if (place->horiz_x == seg->horiz_x) {
#line 613
          if (! (place->b < seg->b)) {
#line 613
            goto while_break;
          }
        } else {
#line 613
          goto while_break;
        }
      }
    } else {
#line 613
      goto while_break;
    }
#line 618
    place_right = place;
#line 619
    pp = & place->horiz_left;
#line 613
    place = *pp;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  *pp = seg;
#line 622
  seg->horiz_left = place;
#line 623
  seg->horiz_right = place_right;
#line 624
  if ((unsigned long )place == (unsigned long )((void *)0)) {
#line 625
    ctx->horiz_first = seg;
  } else {
#line 627
    place->horiz_right = seg;
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_push_pt___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                          double x , double y ) 
{ 
  ArtPriPoint *pri_pt ;
  int n_stack ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 635
  n_stack = seg->n_stack;
#line 637
  if (n_stack == seg->n_stack_max) {
    {
#line 638
    while (1) {
      while_continue: /* CIL Label */ ;
#line 638
      if (seg->n_stack_max) {
        {
#line 638
        tmp = seg->n_stack_max << 1;
#line 638
        seg->n_stack_max = tmp;
#line 638
        tmp___0 = art_realloc((void *)seg->stack, (unsigned long )tmp * sizeof(ArtPoint ));
#line 638
        seg->stack = (ArtPoint *)tmp___0;
        }
      } else {
        {
#line 638
        seg->n_stack_max = 1;
#line 638
        tmp___1 = art_alloc(sizeof(ArtPoint ));
#line 638
        seg->stack = (ArtPoint *)tmp___1;
        }
      }
#line 638
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 639
  (seg->stack + n_stack)->x = x;
#line 640
  (seg->stack + n_stack)->y = y;
#line 641
  (seg->n_stack) ++;
#line 643
  seg->x[1] = x;
#line 644
  seg->y1 = y;
#line 646
  tmp___2 = art_alloc(sizeof(ArtPriPoint ));
#line 646
  pri_pt = (ArtPriPoint *)tmp___2;
#line 647
  pri_pt->x = x;
#line 648
  pri_pt->y = y;
#line 649
  pri_pt->user_data = (void *)seg;
#line 650
  art_pri_insert___1(ctx->pq, pri_pt);
  }
#line 651
  return;
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static double art_svp_intersect_break___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                          double x_ref , double y , ArtBreakFlags break_flags ) 
{ 
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  double x ;
  int tmp ;

  {
#line 671
  in_seg = seg->in_seg;
#line 672
  in_curs = seg->in_curs;
#line 675
  x0 = (in_seg->points + (in_curs - 1))->x;
#line 676
  y0___0 = (in_seg->points + (in_curs - 1))->y;
#line 677
  x1 = (in_seg->points + in_curs)->x;
#line 678
  y1___0 = (in_seg->points + in_curs)->y;
#line 679
  x = x0 + (x1 - x0) * ((y - y0___0) / (y1___0 - y0___0));
#line 680
  if ((unsigned int )break_flags == 1U) {
#line 680
    if (x > x_ref) {
#line 680
      tmp = 1;
    } else {
#line 680
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 680
  if ((unsigned int )break_flags == 2U) {
#line 680
    if (x < x_ref) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 693
  if (y > ctx->y) {
    {
#line 694
    art_svp_intersect_push_pt___1(ctx, seg, x, y);
    }
  } else {
    {
#line 697
    seg->x[0] = x;
#line 698
    seg->y0 = y;
#line 699
    seg->horiz_x = x;
#line 700
    art_svp_intersect_add_horiz___1(ctx, seg);
    }
  }
#line 703
  return (x);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static ArtActiveSeg *art_svp_intersect_add_point___1(ArtIntersectCtx *ctx , double x ,
                                                     double y , ArtActiveSeg *seg ,
                                                     ArtBreakFlags break_flags ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  double x_min ;
  double x_max ;
  art_boolean left_live ;
  art_boolean right_live ;
  double d ;
  double new_x ;
  ArtActiveSeg *test ;
  ArtActiveSeg *result ;
  double x_test ;
  int tmp ;
  int tmp___0 ;

  {
#line 721
  x_min = x;
#line 721
  x_max = x;
#line 725
  result = (ArtActiveSeg *)((void *)0);
#line 728
  left = seg;
#line 729
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 730
    right = ctx->active_head;
  } else {
#line 732
    right = left->right;
  }
#line 733
  if ((unsigned int )break_flags & 1U) {
#line 733
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 733
      tmp = 1;
    } else {
#line 733
      tmp = 0;
    }
  } else {
#line 733
    tmp = 0;
  }
#line 733
  left_live = tmp;
#line 734
  if ((unsigned int )break_flags & 2U) {
#line 734
    if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 734
      tmp___0 = 1;
    } else {
#line 734
      tmp___0 = 0;
    }
  } else {
#line 734
    tmp___0 = 0;
  }
#line 734
  right_live = tmp___0;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! left_live) {
#line 735
      if (! right_live) {
#line 735
        goto while_break;
      }
    }
#line 737
    if (left_live) {
#line 739
      if (x <= left->x[left->flags & 1]) {
#line 739
        if (y != left->y0) {
#line 739
          if (y < left->y1) {
#line 744
            d = (x_min * left->a + y * left->b) + left->c;
#line 745
            if (d < 1e-5) {
              {
#line 747
              new_x = art_svp_intersect_break___1(ctx, left, x_min, y, (ArtBreakFlags )1);
              }
#line 749
              if (new_x > x_max) {
#line 751
                x_max = new_x;
#line 752
                right_live = (unsigned long )right != (unsigned long )((void *)0);
              } else
#line 754
              if (new_x < x_min) {
#line 755
                x_min = new_x;
              }
#line 756
              left = left->left;
#line 757
              left_live = (unsigned long )left != (unsigned long )((void *)0);
            } else {
#line 760
              left_live = 0;
            }
          } else {
#line 763
            left_live = 0;
          }
        } else {
#line 763
          left_live = 0;
        }
      } else {
#line 763
        left_live = 0;
      }
    } else
#line 765
    if (right_live) {
#line 767
      if (x >= right->x[(right->flags & 1) ^ 1]) {
#line 767
        if (y != right->y0) {
#line 767
          if (y < right->y1) {
#line 772
            d = (x_max * right->a + y * right->b) + right->c;
#line 773
            if (d > - 1e-5) {
              {
#line 775
              new_x = art_svp_intersect_break___1(ctx, right, x_max, y, (ArtBreakFlags )2);
              }
#line 777
              if (new_x < x_min) {
#line 779
                x_min = new_x;
#line 780
                left_live = (unsigned long )left != (unsigned long )((void *)0);
              } else
#line 782
              if (new_x >= x_max) {
#line 783
                x_max = new_x;
              }
#line 784
              right = right->right;
#line 785
              right_live = (unsigned long )right != (unsigned long )((void *)0);
            } else {
#line 788
              right_live = 0;
            }
          } else {
#line 791
            right_live = 0;
          }
        } else {
#line 791
          right_live = 0;
        }
      } else {
#line 791
        right_live = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 800
    test = ctx->active_head;
  } else {
#line 800
    test = left->right;
  }
#line 801
  result = left;
#line 802
  if ((unsigned long )test != (unsigned long )((void *)0)) {
#line 802
    if ((unsigned long )test != (unsigned long )right) {
#line 804
      if (y == test->y0) {
#line 805
        x_test = test->x[0];
      } else {
#line 807
        x_test = test->x[1];
      }
      {
#line 808
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 810
        if (x_test <= x) {
#line 811
          result = test;
        }
#line 812
        test = test->right;
#line 813
        if ((unsigned long )test == (unsigned long )right) {
#line 814
          goto while_break___0;
        }
#line 815
        new_x = x_test;
#line 816
        if (new_x < x_test) {
          {
#line 818
          art_warn("art_svp_intersect_add_point: non-ascending x\n");
          }
        }
#line 820
        x_test = new_x;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 823
  return (result);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_swap_active___1(ArtIntersectCtx *ctx , ArtActiveSeg *left_seg ,
                                              ArtActiveSeg *right_seg ) 
{ 


  {
#line 830
  right_seg->left = left_seg->left;
#line 831
  if ((unsigned long )right_seg->left != (unsigned long )((void *)0)) {
#line 832
    (right_seg->left)->right = right_seg;
  } else {
#line 834
    ctx->active_head = right_seg;
  }
#line 835
  left_seg->right = right_seg->right;
#line 836
  if ((unsigned long )left_seg->right != (unsigned long )((void *)0)) {
#line 837
    (left_seg->right)->left = left_seg;
  }
#line 838
  left_seg->left = right_seg;
#line 839
  right_seg->right = left_seg;
#line 840
  return;
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static art_boolean art_svp_intersect_test_cross___1(ArtIntersectCtx *ctx , ArtActiveSeg *left_seg ,
                                                    ArtActiveSeg *right_seg , ArtBreakFlags break_flags ) 
{ 
  double left_x0 ;
  double left_y0 ;
  double left_x1 ;
  double left_y1 ;
  double right_y1 ;
  double d ;
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  double d0 ;
  double d1 ;
  double t ;
  double x ;
  double y ;
  double left_x1___0 ;
  double right_x1 ;
  double tmp ;
  double right_x1___0 ;
  double left_x1___1 ;
  double tmp___0 ;
  double left_x1___2 ;
  double right_x1___1 ;
  double left_x1___3 ;
  double right_x1___2 ;
  double tmp___1 ;
  double right_x1___3 ;
  double left_x1___4 ;
  double tmp___2 ;
  double left_x1___5 ;
  double right_x1___4 ;
  ArtActiveSeg *winner ;
  ArtActiveSeg *loser ;

  {
#line 861
  left_y1 = left_seg->y1;
#line 862
  right_y1 = right_seg->y1;
#line 877
  if (left_seg->y0 == right_seg->y0) {
#line 877
    if (left_seg->x[0] == right_seg->x[0]) {
#line 884
      if (left_y1 < right_y1) {
#line 887
        left_x1___0 = left_seg->x[1];
#line 889
        if (left_x1___0 < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 892
          return (0);
        } else
#line 889
        if (left_y1 == right_seg->y0) {
#line 892
          return (0);
        }
#line 893
        d = (left_x1___0 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 894
        if (d < - 1e-5) {
#line 895
          return (0);
        } else
#line 896
        if (d < 1e-5) {
          {
#line 899
          tmp = art_svp_intersect_break___1(ctx, right_seg, left_x1___0, left_y1,
                                            (ArtBreakFlags )2);
#line 899
          right_x1 = tmp;
          }
#line 902
          if (left_x1___0 <= right_x1) {
#line 903
            return (0);
          }
        }
      } else
#line 906
      if (left_y1 > right_y1) {
#line 909
        right_x1___0 = right_seg->x[1];
#line 911
        if (right_x1___0 > left_seg->x[left_seg->flags & 1]) {
#line 913
          return (0);
        } else
#line 911
        if (right_y1 == left_seg->y0) {
#line 913
          return (0);
        }
#line 914
        d = (right_x1___0 * left_seg->a + right_y1 * left_seg->b) + left_seg->c;
#line 915
        if (d > 1e-5) {
#line 916
          return (0);
        } else
#line 917
        if (d > - 1e-5) {
          {
#line 920
          tmp___0 = art_svp_intersect_break___1(ctx, left_seg, right_x1___0, right_y1,
                                                (ArtBreakFlags )1);
#line 920
          left_x1___1 = tmp___0;
          }
#line 923
          if (left_x1___1 <= right_x1___0) {
#line 924
            return (0);
          }
        }
      } else {
#line 929
        left_x1___2 = left_seg->x[1];
#line 930
        right_x1___1 = right_seg->x[1];
#line 932
        if (left_x1___2 <= right_x1___1) {
#line 933
          return (0);
        }
      }
      {
#line 935
      art_svp_intersect_swap_active___1(ctx, left_seg, right_seg);
      }
#line 936
      return (1);
    }
  }
#line 939
  if (left_y1 < right_y1) {
#line 942
    left_x1___3 = left_seg->x[1];
#line 944
    if (left_x1___3 < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 947
      return (0);
    } else
#line 944
    if (left_y1 == right_seg->y0) {
#line 947
      return (0);
    }
#line 948
    d = (left_x1___3 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 949
    if (d < - 1e-5) {
#line 950
      return (0);
    } else
#line 951
    if (d < 1e-5) {
      {
#line 953
      tmp___1 = art_svp_intersect_break___1(ctx, right_seg, left_x1___3, left_y1,
                                            (ArtBreakFlags )2);
#line 953
      right_x1___2 = tmp___1;
      }
#line 956
      if (left_x1___3 <= right_x1___2) {
#line 957
        return (0);
      }
    }
  } else
#line 960
  if (left_y1 > right_y1) {
#line 963
    right_x1___3 = right_seg->x[1];
#line 965
    if (right_x1___3 > left_seg->x[left_seg->flags & 1]) {
#line 967
      return (0);
    } else
#line 965
    if (right_y1 == left_seg->y0) {
#line 967
      return (0);
    }
#line 968
    d = (right_x1___3 * left_seg->a + right_y1 * left_seg->b) + left_seg->c;
#line 969
    if (d > 1e-5) {
#line 970
      return (0);
    } else
#line 971
    if (d > - 1e-5) {
      {
#line 973
      tmp___2 = art_svp_intersect_break___1(ctx, left_seg, right_x1___3, right_y1,
                                            (ArtBreakFlags )1);
#line 973
      left_x1___4 = tmp___2;
      }
#line 976
      if (left_x1___4 <= right_x1___3) {
#line 977
        return (0);
      }
    }
  } else {
#line 982
    left_x1___5 = left_seg->x[1];
#line 983
    right_x1___4 = right_seg->x[1];
#line 985
    if (left_x1___5 <= right_x1___4) {
#line 986
      return (0);
    }
  }
#line 991
  in_seg = left_seg->in_seg;
#line 992
  in_curs = left_seg->in_curs;
#line 993
  left_x0 = (in_seg->points + (in_curs - 1))->x;
#line 994
  left_y0 = (in_seg->points + (in_curs - 1))->y;
#line 995
  left_x1 = (in_seg->points + in_curs)->x;
#line 996
  left_y1 = (in_seg->points + in_curs)->y;
#line 997
  d0 = (left_x0 * right_seg->a + left_y0 * right_seg->b) + right_seg->c;
#line 998
  d1 = (left_x1 * right_seg->a + left_y1 * right_seg->b) + right_seg->c;
#line 999
  if (d0 == d1) {
#line 1001
    x = left_x0;
#line 1002
    y = left_y0;
  } else {
#line 1007
    t = d0 / (d0 - d1);
#line 1008
    if (t <= (double )0) {
#line 1010
      x = left_x0;
#line 1011
      y = left_y0;
    } else
#line 1013
    if (t >= (double )1) {
#line 1015
      x = left_x1;
#line 1016
      y = left_y1;
    } else {
#line 1020
      x = left_x0 + t * (left_x1 - left_x0);
#line 1021
      y = left_y0 + t * (left_y1 - left_y0);
    }
  }
#line 1026
  if (y < right_seg->y0) {
#line 1028
    x = right_seg->x[0];
#line 1029
    y = right_seg->y0;
  } else
#line 1031
  if (y > right_seg->y1) {
#line 1033
    x = right_seg->x[1];
#line 1034
    y = right_seg->y1;
  } else
#line 1036
  if (x < right_seg->x[(right_seg->flags & 1) ^ 1]) {
#line 1037
    x = right_seg->x[(right_seg->flags & 1) ^ 1];
  } else
#line 1038
  if (x > right_seg->x[right_seg->flags & 1]) {
#line 1039
    x = right_seg->x[right_seg->flags & 1];
  }
#line 1041
  if (y == left_seg->y0) {
#line 1043
    if (y != right_seg->y0) {
      {
#line 1049
      art_svp_intersect_push_pt___1(ctx, right_seg, x, y);
      }
#line 1050
      if ((unsigned int )break_flags & 2U) {
#line 1050
        if ((unsigned long )right_seg->right != (unsigned long )((void *)0)) {
          {
#line 1051
          art_svp_intersect_add_point___1(ctx, x, y, right_seg->right, break_flags);
          }
        }
      }
    } else {
#line 1062
      if (left_seg->a > right_seg->a) {
#line 1064
        winner = left_seg;
#line 1065
        loser = right_seg;
      } else {
#line 1069
        winner = right_seg;
#line 1070
        loser = left_seg;
      }
      {
#line 1073
      loser->x[0] = winner->x[0];
#line 1074
      loser->horiz_x = loser->x[0];
#line 1075
      loser->horiz_delta_wind += loser->delta_wind;
#line 1076
      winner->horiz_delta_wind -= loser->delta_wind;
#line 1078
      art_svp_intersect_swap_active___1(ctx, left_seg, right_seg);
      }
#line 1079
      return (1);
    }
  } else
#line 1082
  if (y == right_seg->y0) {
    {
#line 1088
    art_svp_intersect_push_pt___1(ctx, left_seg, x, y);
    }
#line 1089
    if ((unsigned int )break_flags & 1U) {
#line 1089
      if ((unsigned long )left_seg->left != (unsigned long )((void *)0)) {
        {
#line 1090
        art_svp_intersect_add_point___1(ctx, x, y, left_seg->left, break_flags);
        }
      }
    }
  } else {
    {
#line 1100
    art_svp_intersect_push_pt___1(ctx, left_seg, x, y);
#line 1101
    art_svp_intersect_push_pt___1(ctx, right_seg, x, y);
    }
#line 1102
    if ((unsigned int )break_flags & 1U) {
#line 1102
      if ((unsigned long )left_seg->left != (unsigned long )((void *)0)) {
        {
#line 1103
        art_svp_intersect_add_point___1(ctx, x, y, left_seg->left, break_flags);
        }
      }
    }
#line 1104
    if ((unsigned int )break_flags & 2U) {
#line 1104
      if ((unsigned long )right_seg->right != (unsigned long )((void *)0)) {
        {
#line 1105
        art_svp_intersect_add_point___1(ctx, x, y, right_seg->right, break_flags);
        }
      }
    }
  }
#line 1107
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_active_delete___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;

  {
#line 1120
  left = seg->left;
#line 1120
  right = seg->right;
#line 1122
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1123
    left->right = right;
  } else {
#line 1125
    ctx->active_head = right;
  }
#line 1126
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1127
    right->left = left;
  }
#line 1128
  return;
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_active_free___1(ArtActiveSeg *seg ) 
{ 


  {
  {
#line 1139
  art_free((void *)seg->stack);
#line 1143
  art_free((void *)seg);
  }
#line 1144
  return;
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_insert_cross___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  ArtActiveSeg *leftc ;
  art_boolean tmp ;
  ArtActiveSeg *rightc ;
  art_boolean tmp___0 ;

  {
#line 1156
  left = seg;
#line 1156
  right = seg;
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1164
      leftc = left->left;
      {
#line 1164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1164
        if (! ((unsigned long )leftc != (unsigned long )((void *)0))) {
#line 1164
          goto while_break___0;
        }
#line 1165
        if (! (leftc->flags & 4)) {
#line 1166
          goto while_break___0;
        }
#line 1164
        leftc = leftc->left;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1167
      if ((unsigned long )leftc != (unsigned long )((void *)0)) {
        {
#line 1167
        tmp = art_svp_intersect_test_cross___1(ctx, leftc, left, (ArtBreakFlags )1);
        }
#line 1167
        if (tmp) {
#line 1171
          if ((unsigned long )left == (unsigned long )right) {
#line 1172
            right = left->right;
          } else
#line 1171
          if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 1172
            right = left->right;
          }
        } else {
#line 1176
          left = (ArtActiveSeg *)((void *)0);
        }
      } else {
#line 1176
        left = (ArtActiveSeg *)((void *)0);
      }
    } else
#line 1179
    if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1179
      if ((unsigned long )right->right != (unsigned long )((void *)0)) {
#line 1183
        rightc = right->right;
        {
#line 1183
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1183
          if (! ((unsigned long )rightc != (unsigned long )((void *)0))) {
#line 1183
            goto while_break___1;
          }
#line 1184
          if (! (rightc->flags & 4)) {
#line 1185
            goto while_break___1;
          }
#line 1183
          rightc = rightc->right;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1186
        if ((unsigned long )rightc != (unsigned long )((void *)0)) {
          {
#line 1186
          tmp___0 = art_svp_intersect_test_cross___1(ctx, right, rightc, (ArtBreakFlags )2);
          }
#line 1186
          if (tmp___0) {
#line 1190
            if ((unsigned long )left == (unsigned long )right) {
#line 1191
              left = right->left;
            } else
#line 1190
            if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 1191
              left = right->left;
            }
          } else {
#line 1195
            right = (ArtActiveSeg *)((void *)0);
          }
        } else {
#line 1195
          right = (ArtActiveSeg *)((void *)0);
        }
      } else {
#line 1199
        goto while_break;
      }
    } else {
#line 1199
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1201
  return;
}
}
#line 1213 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_horiz___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                        double x0 , double x1 ) 
{ 
  ArtActiveSeg *hs ;
  void *tmp ;
  ArtSvpWriter *swr ;
  ArtActiveSeg *left ;
  art_boolean first ;
  int left_bneg ;
  ArtActiveSeg *right ;
  art_boolean first___0 ;
  int right_bneg ;

  {
#line 1219
  if (x0 == x1) {
#line 1220
    return;
  }
  {
#line 1222
  tmp = art_alloc(sizeof(ArtActiveSeg ));
#line 1222
  hs = (ArtActiveSeg *)tmp;
#line 1224
  hs->flags = 4 | (seg->flags & 8);
  }
#line 1225
  if (seg->flags & 8) {
    {
#line 1227
    swr = ctx->out;
#line 1229
    (*(swr->add_point))(swr, seg->seg_id, x0, ctx->y);
    }
  }
  {
#line 1231
  hs->seg_id = seg->seg_id;
#line 1232
  hs->horiz_x = x0;
#line 1233
  hs->horiz_delta_wind = seg->delta_wind;
#line 1234
  hs->stack = (ArtPoint *)((void *)0);
#line 1241
  hs->a = 0.0;
#line 1242
  hs->b = 0.0;
#line 1243
  hs->c = 0.0;
#line 1245
  seg->horiz_delta_wind -= seg->delta_wind;
#line 1247
  art_svp_intersect_add_horiz___1(ctx, hs);
  }
#line 1249
  if (x0 > x1) {
#line 1252
    first = 1;
#line 1254
    left = seg->left;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 1254
        goto while_break;
      }
#line 1256
      left_bneg = left->flags & 1;
#line 1258
      if (left->x[left_bneg] <= x1) {
#line 1259
        goto while_break;
      }
#line 1260
      if (left->x[left_bneg ^ 1] <= x1) {
#line 1260
        if ((x1 * left->a + ctx->y * left->b) + left->c >= (double )0) {
#line 1262
          goto while_break;
        }
      }
#line 1263
      if (left->y0 != ctx->y) {
#line 1263
        if (left->y1 != ctx->y) {
          {
#line 1265
          art_svp_intersect_break___1(ctx, left, x1, ctx->y, (ArtBreakFlags )1);
          }
        }
      }
      {
#line 1271
      art_svp_intersect_swap_active___1(ctx, left, seg);
      }
#line 1272
      if (first) {
#line 1272
        if ((unsigned long )left->right != (unsigned long )((void *)0)) {
          {
#line 1274
          art_svp_intersect_test_cross___1(ctx, left, left->right, (ArtBreakFlags )2);
#line 1276
          first = 0;
          }
        }
      }
#line 1254
      left = seg->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1283
    first___0 = 1;
#line 1285
    right = seg->right;
    {
#line 1285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1285
      if (! ((unsigned long )right != (unsigned long )((void *)0))) {
#line 1285
        goto while_break___0;
      }
#line 1287
      right_bneg = right->flags & 1;
#line 1289
      if (right->x[right_bneg ^ 1] >= x1) {
#line 1290
        goto while_break___0;
      }
#line 1291
      if (right->x[right_bneg] >= x1) {
#line 1291
        if ((x1 * right->a + ctx->y * right->b) + right->c <= (double )0) {
#line 1293
          goto while_break___0;
        }
      }
#line 1294
      if (right->y0 != ctx->y) {
#line 1294
        if (right->y1 != ctx->y) {
          {
#line 1296
          art_svp_intersect_break___1(ctx, right, x1, ctx->y, (ArtBreakFlags )1);
          }
        }
      }
      {
#line 1303
      art_svp_intersect_swap_active___1(ctx, seg, right);
      }
#line 1304
      if (first___0) {
#line 1304
        if ((unsigned long )right->left != (unsigned long )((void *)0)) {
          {
#line 1306
          art_svp_intersect_test_cross___1(ctx, right->left, right, (ArtBreakFlags )2);
#line 1308
          first___0 = 0;
          }
        }
      }
#line 1285
      right = seg->right;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1313
  seg->x[0] = x1;
#line 1314
  seg->x[1] = x1;
#line 1315
  seg->horiz_x = x1;
#line 1316
  seg->flags &= -9;
#line 1317
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_insert_line___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 


  {
#line 1331
  if (seg->y1 == seg->y0) {
    {
#line 1337
    art_svp_intersect_horiz___1(ctx, seg, seg->x[0], seg->x[1]);
    }
  } else {
    {
#line 1341
    art_svp_intersect_insert_cross___1(ctx, seg);
#line 1342
    art_svp_intersect_add_horiz___1(ctx, seg);
    }
  }
#line 1344
  return;
}
}
#line 1346 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_process_intersection___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ) 
{ 
  int n_stack ;

  {
  {
#line 1350
  (seg->n_stack) --;
#line 1350
  n_stack = seg->n_stack;
#line 1351
  seg->x[1] = (seg->stack + (n_stack - 1))->x;
#line 1352
  seg->y1 = (seg->stack + (n_stack - 1))->y;
#line 1353
  seg->x[0] = (seg->stack + n_stack)->x;
#line 1354
  seg->y0 = (seg->stack + n_stack)->y;
#line 1355
  seg->horiz_x = seg->x[0];
#line 1356
  art_svp_intersect_insert_line___1(ctx, seg);
  }
#line 1357
  return;
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_advance_cursor___1(ArtIntersectCtx *ctx , ArtActiveSeg *seg ,
                                                 ArtPriPoint *pri_pt ) 
{ 
  ArtSVPSeg const   *in_seg ;
  int in_curs ;
  ArtSvpWriter *swr ;
  ArtSvpWriter *tmp ;
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;

  {
#line 1363
  in_seg = seg->in_seg;
#line 1364
  in_curs = seg->in_curs;
#line 1365
  if (seg->flags & 8) {
#line 1365
    tmp = ctx->out;
  } else {
#line 1365
    tmp = (ArtSvpWriter *)((void *)0);
  }
#line 1365
  swr = tmp;
#line 1367
  if ((unsigned long )swr != (unsigned long )((void *)0)) {
    {
#line 1368
    (*(swr->add_point))(swr, seg->seg_id, seg->x[1], seg->y1);
    }
  }
#line 1369
  if (in_curs + 1 == (int )in_seg->n_points) {
    {
#line 1371
    left = seg->left;
#line 1371
    right = seg->right;
#line 1378
    seg->flags |= 4;
#line 1379
    art_svp_intersect_add_horiz___1(ctx, seg);
#line 1380
    art_svp_intersect_active_delete___1(ctx, seg);
    }
#line 1381
    if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 1381
      if ((unsigned long )right != (unsigned long )((void *)0)) {
        {
#line 1382
        art_svp_intersect_test_cross___1(ctx, left, right, (ArtBreakFlags )3);
        }
      }
    }
    {
#line 1384
    art_free((void *)pri_pt);
    }
  } else {
    {
#line 1388
    seg->horiz_x = seg->x[1];
#line 1390
    art_svp_intersect_setup_seg___1(seg, pri_pt);
#line 1391
    art_pri_insert___1(ctx->pq, pri_pt);
#line 1392
    art_svp_intersect_insert_line___1(ctx, seg);
    }
  }
#line 1394
  return;
}
}
#line 1396 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_add_seg___1(ArtIntersectCtx *ctx , ArtSVPSeg const   *in_seg ) 
{ 
  ArtActiveSeg *seg ;
  void *tmp ;
  ArtActiveSeg *test ;
  double x0 ;
  double y0___0 ;
  ArtActiveSeg *beg_range ;
  ArtActiveSeg *last ;
  ArtActiveSeg *left ;
  ArtActiveSeg *right ;
  ArtPriPoint *pri_pt ;
  void *tmp___0 ;
  void *tmp___1 ;
  double d ;
  int test_bneg ;

  {
  {
#line 1399
  tmp = art_alloc(sizeof(ArtActiveSeg ));
#line 1399
  seg = (ArtActiveSeg *)tmp;
#line 1403
  last = (ArtActiveSeg *)((void *)0);
#line 1405
  tmp___0 = art_alloc(sizeof(ArtPriPoint ));
#line 1405
  pri_pt = (ArtPriPoint *)tmp___0;
#line 1407
  seg->flags = 0;
#line 1408
  seg->in_seg = in_seg;
#line 1409
  seg->in_curs = 0;
#line 1411
  seg->n_stack_max = 4;
#line 1412
  tmp___1 = art_alloc((unsigned long )seg->n_stack_max * sizeof(ArtPoint ));
#line 1412
  seg->stack = (ArtPoint *)tmp___1;
#line 1414
  seg->horiz_delta_wind = 0;
#line 1416
  seg->wind_left = 0;
#line 1418
  pri_pt->user_data = (void *)seg;
#line 1419
  art_svp_intersect_setup_seg___1(seg, pri_pt);
#line 1420
  art_pri_insert___1(ctx->pq, pri_pt);
#line 1426
  x0 = (in_seg->points + 0)->x;
#line 1427
  y0___0 = (in_seg->points + 0)->y;
#line 1428
  beg_range = (ArtActiveSeg *)((void *)0);
#line 1429
  test = ctx->active_head;
  }
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 1429
      goto while_break;
    }
#line 1432
    test_bneg = test->flags & 1;
#line 1434
    if (x0 < test->x[test_bneg]) {
#line 1436
      if (x0 < test->x[test_bneg ^ 1]) {
#line 1437
        goto while_break;
      }
#line 1438
      d = (x0 * test->a + y0___0 * test->b) + test->c;
#line 1439
      if (d < (double )0) {
#line 1440
        goto while_break;
      }
    }
#line 1442
    last = test;
#line 1429
    test = test->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1445
  left = art_svp_intersect_add_point___1(ctx, x0, y0___0, last, (ArtBreakFlags )3);
#line 1446
  seg->left = left;
  }
#line 1447
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 1449
    right = ctx->active_head;
#line 1450
    ctx->active_head = seg;
  } else {
#line 1454
    right = left->right;
#line 1455
    left->right = seg;
  }
#line 1457
  seg->right = right;
#line 1458
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 1459
    right->left = seg;
  }
#line 1461
  if (in_seg->dir) {
#line 1461
    seg->delta_wind = 1;
  } else {
#line 1461
    seg->delta_wind = -1;
  }
  {
#line 1462
  seg->horiz_x = x0;
#line 1464
  art_svp_intersect_insert_line___1(ctx, seg);
  }
#line 1465
  return;
}
}
#line 1512 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_intersect.c"
static void art_svp_intersect_horiz_commit___1(ArtIntersectCtx *ctx ) 
{ 
  ArtActiveSeg *seg ;
  int winding_number ;
  int horiz_wind ;
  double last_x ;
  ArtActiveSeg *curs ;
  double x ;
  ArtSvpWriter *swr ;
  int seg_id ;
  ArtSvpWriter *swr___0 ;
  ArtActiveSeg *next ;
  ArtSvpWriter *swr___1 ;

  {
#line 1516
  winding_number = 0;
#line 1517
  horiz_wind = 0;
#line 1518
  last_x = (double )0;
#line 1528
  seg = ctx->horiz_first;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! ((unsigned long )seg != (unsigned long )((void *)0))) {
#line 1528
      goto while_break;
    }
#line 1532
    x = seg->horiz_x;
#line 1535
    if (horiz_wind != 0) {
      {
#line 1537
      swr = ctx->out;
#line 1540
      seg_id = (*(swr->add_segment))(swr, winding_number, horiz_wind, last_x, ctx->y);
#line 1542
      (*(swr->add_point))(swr, seg_id, x, ctx->y);
#line 1543
      (*(swr->close_segment))(swr, seg_id);
      }
    }
#line 1548
    curs = seg;
    {
#line 1548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1548
      if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1548
        if (! (curs->horiz_x == x)) {
#line 1548
          goto while_break___0;
        }
      } else {
#line 1548
        goto while_break___0;
      }
#line 1550
      if (! (curs->flags & 4)) {
#line 1551
        goto while_break___0;
      }
#line 1548
      curs = curs->horiz_right;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1553
    if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1553
      if (curs->horiz_x == x) {
        {
#line 1558
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1558
          if (! ((unsigned long )curs->left != (unsigned long )((void *)0))) {
#line 1558
            goto while_break___1;
          }
#line 1559
          if ((curs->left)->horiz_x != x) {
#line 1560
            goto while_break___1;
          }
#line 1558
          curs = curs->left;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1562
        if ((unsigned long )curs->left != (unsigned long )((void *)0)) {
#line 1563
          winding_number = (curs->left)->wind_left + (curs->left)->delta_wind;
        } else {
#line 1565
          winding_number = 0;
        }
        {
#line 1567
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1573
          if (! (curs->flags & 8)) {
#line 1573
            goto _L;
          } else
#line 1573
          if (curs->wind_left != winding_number) {
            _L: /* CIL Label */ 
#line 1576
            swr___0 = ctx->out;
#line 1578
            if (curs->flags & 8) {
              {
#line 1580
              (*(swr___0->add_point))(swr___0, curs->seg_id, curs->horiz_x, ctx->y);
#line 1582
              (*(swr___0->close_segment))(swr___0, curs->seg_id);
              }
            }
            {
#line 1585
            curs->seg_id = (*(swr___0->add_segment))(swr___0, winding_number, curs->delta_wind,
                                                     x, ctx->y);
#line 1588
            curs->flags |= 8;
            }
          }
#line 1590
          curs->wind_left = winding_number;
#line 1591
          winding_number += curs->delta_wind;
#line 1592
          curs = curs->right;
#line 1567
          if ((unsigned long )curs != (unsigned long )((void *)0)) {
#line 1567
            if (! (curs->horiz_x == x)) {
#line 1567
              goto while_break___2;
            }
          } else {
#line 1567
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 1598
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1600
      next = seg->horiz_right;
#line 1602
      seg->flags &= -17;
#line 1603
      horiz_wind += seg->horiz_delta_wind;
#line 1604
      seg->horiz_delta_wind = 0;
#line 1605
      if (seg->flags & 4) {
#line 1607
        if (seg->flags & 8) {
          {
#line 1609
          swr___1 = ctx->out;
#line 1610
          (*(swr___1->close_segment))(swr___1, seg->seg_id);
          }
        }
        {
#line 1612
        art_svp_intersect_active_free___1(seg);
        }
      }
#line 1614
      seg = next;
#line 1598
      if ((unsigned long )seg != (unsigned long )((void *)0)) {
#line 1598
        if (! (seg->horiz_x == x)) {
#line 1598
          goto while_break___3;
        }
      } else {
#line 1598
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1618
    last_x = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 1620
  ctx->horiz_first = (ArtActiveSeg *)((void *)0);
#line 1621
  ctx->horiz_last = (ArtActiveSeg *)((void *)0);
#line 1625
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_done___1(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 40
  art_free((void *)self);
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static int art_render_svp_can_drive___1(ArtMaskSource *self , ArtRender *render ) 
{ 


  {
#line 46
  return (10);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback___1(void *callback_data , int y , int start ,
                                        ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int i ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;

  {
#line 58
  z = (ArtMaskSourceSVP *)callback_data;
#line 59
  render = z->render;
#line 60
  n_run = 0;
#line 62
  running_sum = start;
#line 63
  x0 = render->x0;
#line 64
  x1 = render->x1;
#line 66
  run = render->run;
#line 68
  if (n_steps > 0) {
#line 70
    run_x1 = (steps + 0)->x;
#line 71
    if (run_x1 > x0) {
#line 71
      if (running_sum > 33023) {
#line 73
        (run + 0)->x = x0;
#line 74
        (run + 0)->alpha = running_sum;
#line 75
        n_run ++;
      }
    }
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
#line 78
      if (! (i < n_steps - 1)) {
#line 78
        goto while_break;
      }
#line 80
      running_sum += (steps + i)->delta;
#line 81
      run_x0 = run_x1;
#line 82
      run_x1 = (steps + (i + 1))->x;
#line 83
      if (run_x1 > run_x0) {
#line 85
        (run + n_run)->x = run_x0;
#line 86
        (run + n_run)->alpha = running_sum;
#line 87
        n_run ++;
      }
#line 78
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    if (x1 > run_x1) {
#line 92
      running_sum += (steps + (n_steps - 1))->delta;
#line 93
      (run + n_run)->x = run_x1;
#line 94
      (run + n_run)->alpha = running_sum;
#line 95
      n_run ++;
    }
#line 97
    if (running_sum > 33023) {
#line 99
      (run + n_run)->x = x1;
#line 100
      (run + n_run)->alpha = 32768;
#line 101
      n_run ++;
    }
  } else
#line 104
  if (running_sum >> 16 > 0) {
#line 106
    (run + 0)->x = x0;
#line 107
    (run + 0)->alpha = running_sum;
#line 108
    (run + 1)->x = x1;
#line 109
    (run + 1)->alpha = running_sum;
#line 110
    n_run = 2;
  }
  {
#line 113
  render->n_run = n_run;
#line 115
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 117
  z->dest_ptr += render->rowstride;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_span___1(void *callback_data , int y , int start ,
                                             ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int n_span ;
  int i ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  int *span_x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 124
  z = (ArtMaskSourceSVP *)callback_data;
#line 125
  render = z->render;
#line 126
  n_run = 0;
#line 127
  n_span = 0;
#line 129
  running_sum = start;
#line 130
  x0 = render->x0;
#line 131
  x1 = render->x1;
#line 133
  run = render->run;
#line 134
  span_x = render->span_x;
#line 136
  if (n_steps > 0) {
#line 138
    run_x1 = (steps + 0)->x;
#line 139
    if (run_x1 > x0) {
#line 139
      if (running_sum > 33023) {
#line 141
        (run + 0)->x = x0;
#line 142
        (run + 0)->alpha = running_sum;
#line 143
        n_run ++;
#line 144
        *(span_x + 0) = x0;
#line 145
        n_span ++;
      }
    }
#line 148
    i = 0;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! (i < n_steps - 1)) {
#line 148
        goto while_break;
      }
#line 150
      running_sum += (steps + i)->delta;
#line 151
      run_x0 = run_x1;
#line 152
      run_x1 = (steps + (i + 1))->x;
#line 153
      if (run_x1 > run_x0) {
#line 155
        (run + n_run)->x = run_x0;
#line 156
        (run + n_run)->alpha = running_sum;
#line 157
        n_run ++;
#line 158
        if ((n_span & 1) != (running_sum > 33023)) {
#line 159
          tmp = n_span;
#line 159
          n_span ++;
#line 159
          *(span_x + tmp) = run_x0;
        }
      }
#line 148
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 162
    if (x1 > run_x1) {
#line 164
      running_sum += (steps + (n_steps - 1))->delta;
#line 165
      (run + n_run)->x = run_x1;
#line 166
      (run + n_run)->alpha = running_sum;
#line 167
      n_run ++;
#line 168
      if ((n_span & 1) != (running_sum > 33023)) {
#line 169
        tmp___0 = n_span;
#line 169
        n_span ++;
#line 169
        *(span_x + tmp___0) = run_x1;
      }
    }
#line 171
    if (running_sum > 33023) {
#line 173
      (run + n_run)->x = x1;
#line 174
      (run + n_run)->alpha = 32768;
#line 175
      n_run ++;
#line 176
      tmp___1 = n_span;
#line 176
      n_span ++;
#line 176
      *(span_x + tmp___1) = x1;
    }
  } else
#line 179
  if (running_sum >> 16 > 0) {
#line 181
    (run + 0)->x = x0;
#line 182
    (run + 0)->alpha = running_sum;
#line 183
    (run + 1)->x = x1;
#line 184
    (run + 1)->alpha = running_sum;
#line 185
    n_run = 2;
#line 186
    *(span_x + 0) = x0;
#line 187
    *(span_x + 1) = x1;
#line 188
    n_span = 2;
  }
  {
#line 191
  render->n_run = n_run;
#line 192
  render->n_span = n_span;
#line 194
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 196
  z->dest_ptr += render->rowstride;
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_opacity___1(void *callback_data , int y , int start ,
                                                ArtSVPRenderAAStep *steps , int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int i ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  art_u32 opacity ;
  art_u32 alpha ;

  {
#line 203
  z = (ArtMaskSourceSVP *)callback_data;
#line 204
  render = z->render;
#line 205
  n_run = 0;
#line 208
  x0 = render->x0;
#line 209
  x1 = render->x1;
#line 211
  run = render->run;
#line 212
  opacity = render->opacity;
#line 215
  running_sum = (art_u32 )(start - 32640);
#line 217
  if (n_steps > 0) {
#line 219
    run_x1 = (steps + 0)->x;
#line 220
    alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 221
    if (run_x1 > x0) {
#line 221
      if (alpha > 33023U) {
#line 223
        (run + 0)->x = x0;
#line 224
        (run + 0)->alpha = (int )alpha;
#line 225
        n_run ++;
      }
    }
#line 228
    i = 0;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n_steps - 1)) {
#line 228
        goto while_break;
      }
#line 230
      running_sum += (art_u32 )(steps + i)->delta;
#line 231
      run_x0 = run_x1;
#line 232
      run_x1 = (steps + (i + 1))->x;
#line 233
      if (run_x1 > run_x0) {
#line 235
        (run + n_run)->x = run_x0;
#line 236
        alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 237
        (run + n_run)->alpha = (int )alpha;
#line 238
        n_run ++;
      }
#line 228
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 241
    if (x1 > run_x1) {
#line 243
      running_sum += (art_u32 )(steps + (n_steps - 1))->delta;
#line 244
      (run + n_run)->x = run_x1;
#line 245
      alpha = ((running_sum >> 8) * opacity + 524416U) >> 8;
#line 246
      (run + n_run)->alpha = (int )alpha;
#line 247
      n_run ++;
    }
#line 249
    if (alpha > 33023U) {
#line 251
      (run + n_run)->x = x1;
#line 252
      (run + n_run)->alpha = 32768;
#line 253
      n_run ++;
    }
  } else
#line 256
  if (running_sum >> 16 > 0U) {
#line 258
    (run + 0)->x = x0;
#line 259
    (run + 0)->alpha = (int )running_sum;
#line 260
    (run + 1)->x = x1;
#line 261
    (run + 1)->alpha = (int )running_sum;
#line 262
    n_run = 2;
  }
  {
#line 265
  render->n_run = n_run;
#line 267
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 269
  z->dest_ptr += render->rowstride;
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_callback_opacity_span___1(void *callback_data , int y ,
                                                     int start , ArtSVPRenderAAStep *steps ,
                                                     int n_steps ) 
{ 
  ArtMaskSourceSVP *z ;
  ArtRender *render ;
  int n_run ;
  int n_span ;
  int i ;
  art_u32 running_sum ;
  int x0 ;
  int x1 ;
  int run_x0 ;
  int run_x1 ;
  ArtRenderMaskRun *run ;
  int *span_x ;
  art_u32 opacity ;
  art_u32 alpha ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  z = (ArtMaskSourceSVP *)callback_data;
#line 277
  render = z->render;
#line 278
  n_run = 0;
#line 279
  n_span = 0;
#line 282
  x0 = render->x0;
#line 283
  x1 = render->x1;
#line 285
  run = render->run;
#line 286
  span_x = render->span_x;
#line 287
  opacity = render->opacity;
#line 290
  running_sum = (art_u32 )(start - 32640);
#line 292
  if (n_steps > 0) {
#line 294
    run_x1 = (steps + 0)->x;
#line 295
    alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 296
    if (run_x1 > x0) {
#line 296
      if (alpha > 33023U) {
#line 298
        (run + 0)->x = x0;
#line 299
        (run + 0)->alpha = (int )alpha;
#line 300
        n_run ++;
#line 301
        *(span_x + 0) = x0;
#line 302
        n_span ++;
      }
    }
#line 305
    i = 0;
    {
#line 305
    while (1) {
      while_continue: /* CIL Label */ ;
#line 305
      if (! (i < n_steps - 1)) {
#line 305
        goto while_break;
      }
#line 307
      running_sum += (art_u32 )(steps + i)->delta;
#line 308
      run_x0 = run_x1;
#line 309
      run_x1 = (steps + (i + 1))->x;
#line 310
      if (run_x1 > run_x0) {
#line 312
        (run + n_run)->x = run_x0;
#line 313
        alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 314
        (run + n_run)->alpha = (int )alpha;
#line 315
        n_run ++;
#line 316
        if ((n_span & 1) != (alpha > 33023U)) {
#line 317
          tmp = n_span;
#line 317
          n_span ++;
#line 317
          *(span_x + tmp) = run_x0;
        }
      }
#line 305
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 320
    if (x1 > run_x1) {
#line 322
      running_sum += (art_u32 )(steps + (n_steps - 1))->delta;
#line 323
      (run + n_run)->x = run_x1;
#line 324
      alpha = ((running_sum >> 8) * opacity + 8388736U) >> 8;
#line 325
      (run + n_run)->alpha = (int )alpha;
#line 326
      n_run ++;
#line 327
      if ((n_span & 1) != (alpha > 33023U)) {
#line 328
        tmp___0 = n_span;
#line 328
        n_span ++;
#line 328
        *(span_x + tmp___0) = run_x1;
      }
    }
#line 330
    if (alpha > 33023U) {
#line 332
      (run + n_run)->x = x1;
#line 333
      (run + n_run)->alpha = 32768;
#line 334
      n_run ++;
#line 335
      tmp___1 = n_span;
#line 335
      n_span ++;
#line 335
      *(span_x + tmp___1) = x1;
    }
  } else
#line 338
  if (running_sum >> 16 > 0U) {
#line 340
    (run + 0)->x = x0;
#line 341
    (run + 0)->alpha = (int )running_sum;
#line 342
    (run + 1)->x = x1;
#line 343
    (run + 1)->alpha = (int )running_sum;
#line 344
    n_run = 2;
#line 345
    *(span_x + 0) = x0;
#line 346
    *(span_x + 1) = x1;
#line 347
    n_span = 2;
  }
  {
#line 350
  render->n_run = n_run;
#line 351
  render->n_span = n_span;
#line 353
  art_render_invoke_callbacks(render, z->dest_ptr, y);
#line 355
  z->dest_ptr += render->rowstride;
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_invoke_driver___1(ArtMaskSource *self , ArtRender *render ) 
{ 
  ArtMaskSourceSVP *z ;
  void (*callback)(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                   int n_steps ) ;

  {
#line 361
  z = (ArtMaskSourceSVP *)self;
#line 367
  z->dest_ptr = render->pixels;
#line 368
  if (render->opacity == 65536U) {
#line 370
    if (render->need_span) {
#line 371
      callback = & art_render_svp_callback_span___1;
    } else {
#line 373
      callback = & art_render_svp_callback___1;
    }
  } else
#line 377
  if (render->need_span) {
#line 378
    callback = & art_render_svp_callback_opacity_span___1;
  } else {
#line 380
    callback = & art_render_svp_callback_opacity___1;
  }
  {
#line 383
  art_svp_render_aa(z->svp, render->x0, render->y0, render->x1, render->y1, callback,
                    (void *)self);
#line 387
  art_render_svp_done___1(& self->super, render);
  }
#line 388
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_svp.c"
static void art_render_svp_prepare___1(ArtMaskSource *self , ArtRender *render , art_boolean first ) 
{ 


  {
  {
#line 395
  art_die("art_render_svp non-driver mode not yet implemented.\n");
  }
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_rgb_bitmap_affine.c"
static void art_rgb_bitmap_affine_opaque___1(art_u8 *dst , int x0 , int y0___0 , int x1 ,
                                             int y1___0 , int dst_rowstride , art_u8 const   *src ,
                                             int src_width , int src_height , int src_rowstride ,
                                             art_u32 rgb , double const   *affine ,
                                             ArtFilterLevel level , ArtAlphaGamma *alphagamma ) 
{ 
  int x ;
  int y ;
  double inv[6] ;
  art_u8 *dst_p ;
  art_u8 *dst_linestart ;
  art_u8 const   *src_p ;
  ArtPoint pt ;
  ArtPoint src_pt ;
  int src_x ;
  int src_y ;
  art_u8 r ;
  art_u8 g ;
  art_u8 b ;
  int run_x0 ;
  int run_x1 ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 59
  r = (art_u8 )(rgb >> 16);
#line 60
  g = (art_u8 )((rgb >> 8) & 255U);
#line 61
  b = (art_u8 )(rgb & 255U);
#line 62
  dst_linestart = dst;
#line 63
  art_affine_invert((double *)(inv), affine);
#line 64
  y = y0___0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (y < y1___0)) {
#line 64
      goto while_break;
    }
    {
#line 66
    pt.y = (double )y + 0.5;
#line 67
    run_x0 = x0;
#line 68
    run_x1 = x1;
#line 69
    art_rgb_affine_run(& run_x0, & run_x1, y, src_width, src_height, (double const   *)(inv));
#line 71
    dst_p = dst_linestart + (run_x0 - x0) * 3;
#line 72
    x = run_x0;
    }
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (! (x < run_x1)) {
#line 72
        goto while_break___0;
      }
      {
#line 74
      pt.x = (double )x + 0.5;
#line 75
      art_affine_point(& src_pt, (ArtPoint const   *)(& pt), (double const   *)(inv));
#line 76
      tmp = floor(src_pt.x);
#line 76
      src_x = (int )tmp;
#line 77
      tmp___0 = floor(src_pt.y);
#line 77
      src_y = (int )tmp___0;
#line 78
      src_p = (src + src_y * src_rowstride) + (src_x >> 3);
      }
#line 79
      if ((int const   )*src_p & (int const   )(128 >> (src_x & 7))) {
#line 81
        *(dst_p + 0) = r;
#line 82
        *(dst_p + 1) = g;
#line 83
        *(dst_p + 2) = b;
      }
#line 85
      dst_p += 3;
#line 72
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    dst_linestart += dst_rowstride;
#line 64
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_done___1(ArtRenderCallback *self , ArtRender *render ) 
{ 


  {
  {
#line 48
  art_free((void *)self);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static int art_render_mask_can_drive___1(ArtMaskSource *self , ArtRender *render ) 
{ 


  {
#line 54
  return (0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_render___1(ArtRenderCallback *self , ArtRender *render ,
                                       art_u8 *dest , int y ) 
{ 
  ArtMaskSourceMask *z ;
  int x0 ;
  int x1 ;
  int z_x0 ;
  int z_x1 ;
  int width ;
  int z_width ;
  art_u8 *alpha_buf ;
  art_u8 const   *src_line ;
  art_u8 *dst_line ;
  int x ;
  int v ;

  {
#line 61
  z = (ArtMaskSourceMask *)self;
#line 62
  x0 = render->x0;
#line 62
  x1 = render->x1;
#line 63
  z_x0 = z->x0;
#line 63
  z_x1 = z->x1;
#line 64
  width = x1 - x0;
#line 65
  z_width = z_x1 - z_x0;
#line 66
  alpha_buf = render->alpha_buf;
#line 68
  if (y < z->y0) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else
#line 68
  if (y >= z->y1) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else
#line 68
  if (z_width <= 0) {
    {
#line 69
    memset((void *)alpha_buf, 0, (size_t )width);
    }
  } else {
#line 72
    src_line = z->mask_buf + (y - z->y0) * z->rowstride;
#line 73
    dst_line = (alpha_buf + z_x0) - x0;
#line 75
    if (z_x0 > x0) {
      {
#line 76
      memset((void *)alpha_buf, 0, (size_t )(z_x0 - x0));
      }
    }
#line 78
    if (z->first) {
      {
#line 79
      memcpy((void */* __restrict  */)dst_line, (void const   */* __restrict  */)src_line,
             (size_t )z_width);
      }
    } else {
#line 84
      x = 0;
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;
#line 84
        if (! (x < z_width)) {
#line 84
          goto while_break;
        }
#line 87
        v = (int )*(src_line + x);
#line 88
        if (v) {
#line 90
          v = v * (int )*(dst_line + x) + 128;
#line 91
          v = (v + (v >> 8)) >> 8;
#line 92
          *(dst_line + x) = (art_u8 )v;
        } else {
#line 96
          *(dst_line + x) = (art_u8 )0;
        }
#line 84
        x ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 101
    if (z_x1 < x1) {
      {
#line 102
      memset((void *)((alpha_buf + z_x1) - x0), 0, (size_t )(x1 - z_x1));
      }
    }
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_render_mask.c"
static void art_render_mask_prepare___1(ArtMaskSource *self , ArtRender *render ,
                                        art_boolean first ) 
{ 
  ArtMaskSourceMask *z ;

  {
#line 110
  z = (ArtMaskSourceMask *)self;
#line 111
  self->super.render = & art_render_mask_render___1;
#line 112
  z->first = first;
#line 113
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_ops.c"
static ArtSVP *art_svp_merge___1(ArtSVP const   *svp1 , ArtSVP const   *svp2 ) 
{ 
  ArtSVP *svp_new ;
  int ix ;
  int ix1 ;
  int ix2 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 62
  tmp = art_alloc(sizeof(ArtSVP ) + (unsigned long )((svp1->n_segs + svp2->n_segs) - 1) * sizeof(ArtSVPSeg ));
#line 62
  svp_new = (ArtSVP *)tmp;
#line 65
  ix1 = 0;
#line 66
  ix2 = 0;
#line 67
  ix = 0;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (ix < (int )(svp1->n_segs + svp2->n_segs))) {
#line 67
      goto while_break;
    }
#line 69
    if (ix1 < (int )svp1->n_segs) {
#line 69
      if (ix2 == (int )svp2->n_segs) {
#line 72
        tmp___0 = ix1;
#line 72
        ix1 ++;
#line 72
        svp_new->segs[ix] = svp1->segs[tmp___0];
      } else {
        {
#line 69
        tmp___2 = art_svp_seg_compare((void const   *)(& svp1->segs[ix1]), (void const   *)(& svp2->segs[ix2]));
        }
#line 69
        if (tmp___2 < 1) {
#line 72
          tmp___0 = ix1;
#line 72
          ix1 ++;
#line 72
          svp_new->segs[ix] = svp1->segs[tmp___0];
        } else {
#line 74
          tmp___1 = ix2;
#line 74
          ix2 ++;
#line 74
          svp_new->segs[ix] = svp2->segs[tmp___1];
        }
      }
    } else {
#line 74
      tmp___1 = ix2;
#line 74
      ix2 ++;
#line 74
      svp_new->segs[ix] = svp2->segs[tmp___1];
    }
#line 67
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  svp_new->n_segs = ix;
#line 78
  return (svp_new);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int intersect_lines___1(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ,
                               ArtPoint *p ) 
{ 
  double a01 ;
  double b01 ;
  double c01 ;
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double det ;

  {
#line 55
  if (z0.x == z2.x) {
#line 55
    if (z0.y == z2.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 55
  if (z0.x == z3.x) {
#line 55
    if (z0.y == z3.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 55
  if (z1.x == z2.x) {
#line 55
    if (z1.y == z2.y) {
#line 56
      return (0);
    } else {
#line 55
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 55
  if (z1.x == z3.x) {
#line 55
    if (z1.y == z3.y) {
#line 56
      return (0);
    }
  }
#line 64
  a01 = z0.y - z1.y;
#line 65
  b01 = z1.x - z0.x;
#line 66
  c01 = - (z0.x * a01 + z0.y * b01);
#line 70
  d2 = (a01 * z2.x + b01 * z2.y) + c01;
#line 71
  d3 = (a01 * z3.x + b01 * z3.y) + c01;
#line 72
  if ((d2 > (double )0) == (d3 > (double )0)) {
#line 73
    return (0);
  }
#line 75
  a23 = z2.y - z3.y;
#line 76
  b23 = z3.x - z2.x;
#line 77
  c23 = - (z2.x * a23 + z2.y * b23);
#line 79
  d0 = (a23 * z0.x + b23 * z0.y) + c23;
#line 80
  d1 = (a23 * z1.x + b23 * z1.y) + c23;
#line 81
  if ((d0 > (double )0) == (d1 > (double )0)) {
#line 82
    return (0);
  }
#line 86
  det = 1.0 / (a01 * b23 - a23 * b01);
#line 87
  p->x = det * (c23 * b01 - c01 * b23);
#line 88
  p->y = det * (c01 * a23 - c23 * a01);
#line 90
  return (1);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static double trap_epsilon___1(double v ) 
{ 
  double epsilon ;

  {
#line 98
  epsilon = 1e-6;
#line 100
  if (v < epsilon) {
#line 100
    if (v > - epsilon) {
#line 100
      return ((double )0);
    } else {
#line 101
      return (v);
    }
  } else {
#line 101
    return (v);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int x_order___1(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ) 
{ 
  double a01 ;
  double b01 ;
  double c01 ;
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double x01min ;
  double x01max ;
  double x23min ;
  double x23max ;

  {
#line 132
  if (z0.y == z1.y) {
#line 134
    if (z2.y == z3.y) {
#line 139
      if (z0.x > z1.x) {
#line 141
        x01min = z1.x;
#line 142
        x01max = z0.x;
      } else {
#line 146
        x01min = z0.x;
#line 147
        x01max = z1.x;
      }
#line 150
      if (z2.x > z3.x) {
#line 152
        x23min = z3.x;
#line 153
        x23max = z2.x;
      } else {
#line 157
        x23min = z2.x;
#line 158
        x23max = z3.x;
      }
#line 161
      if (x23min >= x01max) {
#line 161
        return (1);
      } else
#line 162
      if (x01min >= x23max) {
#line 162
        return (-1);
      } else {
#line 163
        return (0);
      }
    } else {
#line 168
      a23 = z2.y - z3.y;
#line 169
      b23 = z3.x - z2.x;
#line 170
      c23 = - (z2.x * a23 + z2.y * b23);
#line 172
      if (z3.y < z2.y) {
#line 174
        a23 = - a23;
#line 175
        b23 = - b23;
#line 176
        c23 = - c23;
      }
      {
#line 179
      d0 = trap_epsilon___1((a23 * z0.x + b23 * z0.y) + c23);
#line 180
      d1 = trap_epsilon___1((a23 * z1.x + b23 * z1.y) + c23);
      }
#line 182
      if (d0 > (double )0) {
#line 184
        if (d1 >= (double )0) {
#line 184
          return (1);
        } else {
#line 185
          return (0);
        }
      } else
#line 187
      if (d0 == (double )0) {
#line 189
        if (d1 > (double )0) {
#line 189
          return (1);
        } else
#line 190
        if (d1 < (double )0) {
#line 190
          return (-1);
        } else {
          {
#line 191
          printf((char const   */* __restrict  */)"case 1 degenerate\n");
          }
        }
#line 192
        return (0);
      } else
#line 196
      if (d1 <= (double )0) {
#line 196
        return (-1);
      } else {
#line 197
        return (0);
      }
    }
  } else
#line 201
  if (z2.y == z3.y) {
#line 204
    a01 = z0.y - z1.y;
#line 205
    b01 = z1.x - z0.x;
#line 206
    c01 = - (z0.x * a01 + z0.y * b01);
#line 210
    if (z1.y < z0.y) {
#line 212
      a01 = - a01;
#line 213
      b01 = - b01;
#line 214
      c01 = - c01;
    }
    {
#line 217
    d2 = trap_epsilon___1((a01 * z2.x + b01 * z2.y) + c01);
#line 218
    d3 = trap_epsilon___1((a01 * z3.x + b01 * z3.y) + c01);
    }
#line 220
    if (d2 > (double )0) {
#line 222
      if (d3 >= (double )0) {
#line 222
        return (-1);
      } else {
#line 223
        return (0);
      }
    } else
#line 225
    if (d2 == (double )0) {
#line 227
      if (d3 > (double )0) {
#line 227
        return (-1);
      } else
#line 228
      if (d3 < (double )0) {
#line 228
        return (1);
      } else {
        {
#line 229
        printf((char const   */* __restrict  */)"case 2 degenerate\n");
        }
      }
#line 230
      return (0);
    } else
#line 234
    if (d3 <= (double )0) {
#line 234
      return (1);
    } else {
#line 235
      return (0);
    }
  }
#line 240
  a01 = z0.y - z1.y;
#line 241
  b01 = z1.x - z0.x;
#line 242
  c01 = - (z0.x * a01 + z0.y * b01);
#line 246
  if (a01 > (double )0) {
#line 248
    a01 = - a01;
#line 249
    b01 = - b01;
#line 250
    c01 = - c01;
  }
  {
#line 255
  d2 = trap_epsilon___1((a01 * z2.x + b01 * z2.y) + c01);
#line 256
  d3 = trap_epsilon___1((a01 * z3.x + b01 * z3.y) + c01);
  }
#line 257
  if (d2 > (double )0) {
#line 259
    if (d3 >= (double )0) {
#line 259
      return (-1);
    }
  } else
#line 261
  if (d2 == (double )0) {
#line 263
    if (d3 > (double )0) {
#line 263
      return (-1);
    } else
#line 264
    if (d3 < (double )0) {
#line 264
      return (1);
    } else {
      {
#line 266
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colinear!\n");
      }
    }
  } else
#line 270
  if (d3 <= (double )0) {
#line 270
    return (1);
  }
#line 273
  a23 = z2.y - z3.y;
#line 274
  b23 = z3.x - z2.x;
#line 275
  c23 = - (z2.x * a23 + z2.y * b23);
#line 277
  if (a23 > (double )0) {
#line 279
    a23 = - a23;
#line 280
    b23 = - b23;
#line 281
    c23 = - c23;
  }
  {
#line 283
  d0 = trap_epsilon___1((a23 * z0.x + b23 * z0.y) + c23);
#line 284
  d1 = trap_epsilon___1((a23 * z1.x + b23 * z1.y) + c23);
  }
#line 285
  if (d0 > (double )0) {
#line 287
    if (d1 >= (double )0) {
#line 287
      return (1);
    }
  } else
#line 289
  if (d0 == (double )0) {
#line 291
    if (d1 > (double )0) {
#line 291
      return (1);
    } else
#line 292
    if (d1 < (double )0) {
#line 292
      return (-1);
    } else {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"colinear!\n");
      }
    }
  } else
#line 298
  if (d1 <= (double )0) {
#line 298
    return (-1);
  }
#line 301
  return (0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static int x_order_2___1(ArtPoint z0 , ArtPoint z1 , ArtPoint z2 , ArtPoint z3 ) 
{ 
  double a23 ;
  double b23 ;
  double c23 ;
  double d0 ;
  double d1 ;

  {
#line 312
  a23 = z2.y - z3.y;
#line 313
  b23 = z3.x - z2.x;
#line 314
  c23 = - (z2.x * a23 + z2.y * b23);
#line 316
  if (a23 > (double )0) {
#line 318
    a23 = - a23;
#line 319
    b23 = - b23;
#line 320
    c23 = - c23;
  }
#line 323
  d0 = (a23 * z0.x + b23 * z0.y) + c23;
#line 325
  if (d0 > 1e-6) {
#line 326
    return (-1);
  } else
#line 327
  if (d0 < - 1e-6) {
#line 328
    return (1);
  }
#line 330
  d1 = (a23 * z1.x + b23 * z1.y) + c23;
#line 331
  if (d1 > 1e-6) {
#line 332
    return (-1);
  } else
#line 333
  if (d1 < - 1e-6) {
#line 334
    return (1);
  }
#line 336
  if (z0.x == z1.x) {
#line 336
    if (z1.x == z2.x) {
#line 336
      if (z2.x == z3.x) {
        {
#line 338
        art_dprint("x_order_2: colinear and horizontally aligned!\n");
        }
#line 339
        return (0);
      }
    }
  }
#line 342
  if (z0.x <= z2.x) {
#line 342
    if (z1.x <= z2.x) {
#line 342
      if (z0.x <= z3.x) {
#line 342
        if (z1.x <= z3.x) {
#line 343
          return (-1);
        }
      }
    }
  }
#line 344
  if (z0.x >= z2.x) {
#line 344
    if (z1.x >= z2.x) {
#line 344
      if (z0.x >= z3.x) {
#line 344
        if (z1.x >= z3.x) {
#line 345
          return (1);
        }
      }
    }
  }
  {
#line 347
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"x_order_2: colinear!\n");
  }
#line 348
  return (0);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void insert_ip___1(int seg_i , int *n_ips , int *n_ips_max , ArtPoint **ips ,
                          ArtPoint ip ) 
{ 
  int i ;
  ArtPoint tmp1 ;
  ArtPoint tmp2 ;
  int n_ipl ;
  ArtPoint *ipl ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 488
  tmp = *(n_ips + seg_i);
#line 488
  (*(n_ips + seg_i)) ++;
#line 488
  n_ipl = tmp;
#line 489
  if (n_ipl == *(n_ips_max + seg_i)) {
    {
#line 490
    while (1) {
      while_continue: /* CIL Label */ ;
#line 490
      if (*(n_ips_max + seg_i)) {
        {
#line 490
        tmp___0 = *(n_ips_max + seg_i) << 1;
#line 490
        *(n_ips_max + seg_i) = tmp___0;
#line 490
        tmp___1 = art_realloc((void *)*(ips + seg_i), (unsigned long )tmp___0 * sizeof(ArtPoint ));
#line 490
        *(ips + seg_i) = (ArtPoint *)tmp___1;
        }
      } else {
        {
#line 490
        *(n_ips_max + seg_i) = 1;
#line 490
        tmp___2 = art_alloc(sizeof(ArtPoint ));
#line 490
        *(ips + seg_i) = (ArtPoint *)tmp___2;
        }
      }
#line 490
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 491
  ipl = *(ips + seg_i);
#line 492
  i = 1;
  {
#line 492
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 492
    if (! (i < n_ipl)) {
#line 492
      goto while_break___0;
    }
#line 493
    if ((ipl + i)->y > ip.y) {
#line 494
      goto while_break___0;
    }
#line 492
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 495
  tmp1 = ip;
  {
#line 496
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 496
    if (! (i <= n_ipl)) {
#line 496
      goto while_break___1;
    }
#line 498
    tmp2 = *(ipl + i);
#line 499
    *(ipl + i) = tmp1;
#line 500
    tmp1 = tmp2;
#line 496
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 502
  return;
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void intersect_neighbors___1(int i , int *active_segs , int *n_ips , int *n_ips_max ,
                                    ArtPoint **ips , int *cursor , ArtSVP *vp ) 
{ 
  ArtPoint z0 ;
  ArtPoint z1 ;
  ArtPoint z2 ;
  ArtPoint z3 ;
  int asi01 ;
  int asi23 ;
  ArtPoint ip ;
  int tmp ;

  {
#line 515
  asi01 = *(active_segs + (i - 1));
#line 517
  z0 = *(*(ips + asi01) + 0);
#line 518
  if (*(n_ips + asi01) == 1) {
#line 519
    z1 = *(vp->segs[asi01].points + (*(cursor + asi01) + 1));
  } else {
#line 521
    z1 = *(*(ips + asi01) + 1);
  }
#line 523
  asi23 = *(active_segs + i);
#line 525
  z2 = *(*(ips + asi23) + 0);
#line 526
  if (*(n_ips + asi23) == 1) {
#line 527
    z3 = *(vp->segs[asi23].points + (*(cursor + asi23) + 1));
  } else {
#line 529
    z3 = *(*(ips + asi23) + 1);
  }
  {
#line 531
  tmp = intersect_lines___1(z0, z1, z2, z3, & ip);
  }
#line 531
  if (tmp) {
    {
#line 536
    insert_ip___1(asi01, n_ips, n_ips_max, ips, ip);
#line 537
    insert_ip___1(asi23, n_ips, n_ips_max, ips, ip);
    }
  }
#line 539
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void svp_add_point___1(ArtSVP *svp , int *n_points_max , ArtPoint p , int *seg_map ,
                              int *active_segs , int n_active_segs , int i ) 
{ 
  int asi ;
  int asi_left ;
  int asi_right ;
  int n_points ;
  int n_points_left ;
  int n_points_right ;
  ArtSVPSeg *seg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 556
  asi = *(seg_map + *(active_segs + i));
#line 557
  seg = & svp->segs[asi];
#line 558
  n_points = seg->n_points;
#line 560
  if (i > 0) {
#line 562
    asi_left = *(seg_map + *(active_segs + (i - 1)));
#line 563
    n_points_left = svp->segs[asi_left].n_points;
#line 564
    if (n_points_left > 1) {
#line 564
      if ((svp->segs[asi_left].points + (n_points_left - 2))->x == (svp->segs[asi].points + (n_points - 1))->x) {
#line 564
        if ((svp->segs[asi_left].points + (n_points_left - 2))->y == (svp->segs[asi].points + (n_points - 1))->y) {
          {
#line 570
          tmp = x_order___1(*(svp->segs[asi_left].points + (n_points_left - 2)), *(svp->segs[asi_left].points + (n_points_left - 1)),
                            *(svp->segs[asi].points + (n_points - 1)), p);
          }
        }
      }
    }
  }
#line 583
  if (i + 1 < n_active_segs) {
#line 585
    asi_right = *(seg_map + *(active_segs + (i + 1)));
#line 586
    n_points_right = svp->segs[asi_right].n_points;
#line 587
    if (n_points_right > 1) {
#line 587
      if ((svp->segs[asi_right].points + (n_points_right - 2))->x == (svp->segs[asi].points + (n_points - 1))->x) {
#line 587
        if ((svp->segs[asi_right].points + (n_points_right - 2))->y == (svp->segs[asi].points + (n_points - 1))->y) {
          {
#line 593
          tmp___0 = x_order___1(*(svp->segs[asi_right].points + (n_points_right - 2)),
                                *(svp->segs[asi_right].points + (n_points_right - 1)),
                                *(svp->segs[asi].points + (n_points - 1)), p);
          }
        }
      }
    }
  }
#line 604
  if (*(n_points_max + asi) == n_points) {
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      if (*(n_points_max + asi)) {
        {
#line 605
        tmp___1 = *(n_points_max + asi) << 1;
#line 605
        *(n_points_max + asi) = tmp___1;
#line 605
        tmp___2 = art_realloc((void *)seg->points, (unsigned long )tmp___1 * sizeof(ArtPoint ));
#line 605
        seg->points = (ArtPoint *)tmp___2;
        }
      } else {
        {
#line 605
        *(n_points_max + asi) = 1;
#line 605
        tmp___3 = art_alloc(sizeof(ArtPoint ));
#line 605
        seg->points = (ArtPoint *)tmp___3;
        }
      }
#line 605
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 606
  *(seg->points + n_points) = p;
#line 607
  if (p.x < seg->bbox.x0) {
#line 608
    seg->bbox.x0 = p.x;
  } else
#line 609
  if (p.x > seg->bbox.x1) {
#line 610
    seg->bbox.x1 = p.x;
  }
#line 611
  seg->bbox.y1 = p.y;
#line 612
  (seg->n_points) ++;
#line 613
  return;
}
}
#line 707 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_svp_wind.c"
static void fix_crossing___1(int start , int end , int *active_segs , int n_active_segs ,
                             int *cursor , ArtPoint **ips , int *n_ips , int *n_ips_max ,
                             ArtSVP *vp , int *seg_map , ArtSVP **p_new_vp , int *pn_segs_max ,
                             int **pn_points_max ) 
{ 
  int i ;
  int j ;
  int target ;
  int asi ;
  int asj ;
  ArtPoint p0i ;
  ArtPoint p1i ;
  ArtPoint p0j ;
  ArtPoint p1j ;
  int swap ;
  ArtPoint *pts ;
  int tmp ;
  int seg_num ;
  void *tmp___0 ;
  int as_start ;
  int as_end ;

  {
#line 719
  swap = 0;
#line 732
  if (start == -1) {
#line 733
    return;
  }
#line 735
  i = start + 1;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! (i < end)) {
#line 735
      goto while_break;
    }
#line 738
    asi = *(active_segs + i);
#line 739
    if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 740
      p0i = *(*(ips + asi) + 0);
#line 741
      if (*(n_ips + asi) == 1) {
#line 742
        p1i = *(vp->segs[asi].points + (*(cursor + asi) + 1));
      } else {
#line 744
        p1i = *(*(ips + asi) + 1);
      }
#line 746
      j = i - 1;
      {
#line 746
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 746
        if (! (j >= start)) {
#line 746
          goto while_break___0;
        }
#line 748
        asj = *(active_segs + j);
#line 749
        if (*(cursor + asj) < vp->segs[asj].n_points - 1) {
#line 751
          p0j = *(*(ips + asj) + 0);
#line 752
          if (*(n_ips + asj) == 1) {
#line 753
            p1j = *(vp->segs[asj].points + (*(cursor + asj) + 1));
          } else {
#line 755
            p1j = *(*(ips + asj) + 1);
          }
          {
#line 758
          tmp = x_order_2___1(p0j, p1j, p0i, p1i);
          }
#line 758
          if (tmp == -1) {
#line 759
            goto while_break___0;
          }
        }
#line 746
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 763
      target = j + 1;
#line 766
      if (target != i) {
#line 768
        swap = 1;
#line 775
        j = i;
        {
#line 775
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 775
          if (! (j >= target)) {
#line 775
            goto while_break___1;
          }
#line 777
          asi = *(active_segs + j);
#line 784
          if (*(cursor + asi) < vp->segs[asi].n_points - 1) {
#line 784
            if ((*p_new_vp)->segs[*(seg_map + asi)].n_points != 1) {
              {
#line 793
              tmp___0 = art_alloc(16UL * sizeof(ArtPoint ));
#line 793
              pts = (ArtPoint *)tmp___0;
#line 794
              *(pts + 0) = *(*(ips + asi) + 0);
#line 795
              seg_num = art_svp_add_segment(p_new_vp, pn_segs_max, pn_points_max,
                                            1, vp->segs[asi].dir, pts, (ArtDRect *)((void *)0));
#line 800
              *(*pn_points_max + seg_num) = 16;
#line 801
              *(seg_map + asi) = seg_num;
              }
            }
          }
#line 775
          j --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 806
        asi = *(active_segs + i);
#line 807
        j = i;
        {
#line 807
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 807
          if (! (j > target)) {
#line 807
            goto while_break___2;
          }
#line 808
          *(active_segs + j) = *(active_segs + (j - 1));
#line 807
          j --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 809
        *(active_segs + j) = asi;
      }
    }
#line 735
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 813
  if (swap) {
#line 813
    if (start > 0) {
#line 817
      as_start = *(active_segs + start);
#line 818
      if (*(cursor + as_start) < vp->segs[as_start].n_points) {
        {
#line 823
        intersect_neighbors___1(start, active_segs, n_ips, n_ips_max, ips, cursor,
                                vp);
        }
      }
    }
  }
#line 829
  if (swap) {
#line 829
    if (end < n_active_segs) {
#line 833
      as_end = *(active_segs + (end - 1));
#line 834
      if (*(cursor + as_end) < vp->segs[as_end].n_points) {
        {
#line 839
        intersect_neighbors___1(end, active_segs, n_ips, n_ips_max, ips, cursor, vp);
        }
      }
    }
  }
#line 853
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libart-lgpl-2.3.21/art_gray_svp.c"
static void art_gray_svp_callback___1(void *callback_data , int y , int start , ArtSVPRenderAAStep *steps ,
                                      int n_steps ) 
{ 
  ArtGraySVPData *data ;
  art_u8 *linebuf ;
  int run_x0 ;
  int run_x1 ;
  int running_sum ;
  int x0 ;
  int x1 ;
  int k ;

  {
#line 43
  data = (ArtGraySVPData *)callback_data;
#line 46
  running_sum = start;
#line 61
  linebuf = data->buf;
#line 62
  x0 = data->x0;
#line 63
  x1 = data->x1;
#line 65
  if (n_steps > 0) {
#line 67
    run_x1 = (steps + 0)->x;
#line 68
    if (run_x1 > x0) {
      {
#line 69
      memset((void *)linebuf, running_sum >> 16, (size_t )(run_x1 - x0));
      }
    }
#line 71
    k = 0;
    {
#line 71
    while (1) {
      while_continue: /* CIL Label */ ;
#line 71
      if (! (k < n_steps - 1)) {
#line 71
        goto while_break;
      }
#line 73
      running_sum += (steps + k)->delta;
#line 74
      run_x0 = run_x1;
#line 75
      run_x1 = (steps + (k + 1))->x;
#line 76
      if (run_x1 > run_x0) {
        {
#line 77
        memset((void *)((linebuf + run_x0) - x0), running_sum >> 16, (size_t )(run_x1 - run_x0));
        }
      }
#line 71
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 79
    running_sum += (steps + k)->delta;
#line 80
    if (x1 > run_x1) {
      {
#line 81
      memset((void *)((linebuf + run_x1) - x0), running_sum >> 16, (size_t )(x1 - run_x1));
      }
    }
  } else {
    {
#line 85
    memset((void *)linebuf, running_sum >> 16, (size_t )(x1 - x0));
    }
  }
#line 88
  data->buf += data->rowstride;
#line 89
  return;
}
}
