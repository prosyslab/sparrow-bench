/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
struct SReadlineInfo {
   char *buf ;
   char *bufPtr ;
   char *bufLim ;
   size_t bufSize ;
   size_t bufSizeMax ;
   int malloc ;
   int fd ;
   int timeoutLen ;
   int requireEOLN ;
};
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
typedef struct SReadlineInfo SReadlineInfo;
#line 219 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPLine;
#line 219 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPLine *FTPLinePtr;
#line 220 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPLine {
   FTPLinePtr prev ;
   FTPLinePtr next ;
   char *line ;
};
#line 225 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPLineList {
   FTPLinePtr first ;
   FTPLinePtr last ;
   int nLines ;
};
#line 225 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPLineList FTPLineList;
#line 225 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPLineList *FTPLineListPtr;
#line 230 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct Response {
   FTPLineList msg ;
   int codeType ;
   int code ;
   int printMode ;
   int eofOkay ;
   int hadEof ;
};
#line 230 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct Response *ResponsePtr;
#line 254 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPLibraryInfo {
   char magic[16] ;
   int init ;
   int socksInit ;
   unsigned int defaultPort ;
   char defaultAnonPassword[80] ;
};
#line 254 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPLibraryInfo *FTPLIPtr;
#line 262
struct FTPConnectionInfo;
#line 262 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPConnectionInfo *FTPCIPtr;
#line 271 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPConnectionInfo {
   char magic[16] ;
   char host[128] ;
   char user[128] ;
   char pass[256] ;
   char acct[64] ;
   unsigned int passIsEmpty ;
   unsigned int port ;
   int errNo ;
   char lastFTPCmdResultStr[128] ;
   FTPLineList lastFTPCmdResultLL ;
   int lastFTPCmdResultNum ;
   FILE *debugLog ;
   int debugTimestamping ;
   void (*debugLogProc)(FTPCIPtr const    , char * ) ;
   unsigned int xferTimeout ;
   unsigned int connTimeout ;
   unsigned int ctrlTimeout ;
   unsigned int abortTimeout ;
   int maxDials ;
   int redialDelay ;
   int dataPortMode ;
   int firewallType ;
   char firewallHost[64] ;
   char firewallUser[64] ;
   char firewallPass[64] ;
   unsigned int firewallPort ;
   size_t ctrlSocketRBufSize ;
   size_t ctrlSocketSBufSize ;
   size_t dataSocketRBufSize ;
   size_t dataSocketSBufSize ;
   char const   *asciiFilenameExtensions ;
   int shutdownUnusedSideOfSockets ;
   unsigned short ephemLo ;
   unsigned short ephemHi ;
   void (*onConnectMsgProc)(FTPCIPtr const    , ResponsePtr  ) ;
   void (*redialStatusProc)(FTPCIPtr const    , int  , int  ) ;
   void (*printResponseProc)(FTPCIPtr const    , ResponsePtr  ) ;
   void (*onLoginMsgProc)(FTPCIPtr const    , ResponsePtr  ) ;
   void (*passphraseProc)(FTPCIPtr const    , FTPLineListPtr pwPrompt , char *pass ,
                          size_t dsize ) ;
   void (*progress)(FTPCIPtr const    , int  ) ;
   long long bytesTransferred ;
   int useProgressMeter ;
   struct timeval t0 ;
   double sec ;
   double secLeft ;
   double kBytesPerSec ;
   double percentCompleted ;
   long long expectedSize ;
   time_t mdtm ;
   time_t nextProgressUpdate ;
   char const   *rname ;
   char const   *lname ;
   int stalled ;
   int dataTimedOut ;
   int cancelXfer ;
   int canceling ;
   int canceled ;
   char actualHost[64] ;
   char ip[32] ;
   char *startingWorkingDirectory ;
   int connected ;
   int loggedIn ;
   int curTransferType ;
   long long startPoint ;
   FILE *errLog ;
   void (*errLogProc)(FTPCIPtr const    , char * ) ;
   FTPLIPtr lip ;
   int hasPASV ;
   int hasSIZE ;
   int hasMDTM ;
   int hasMDTM_set ;
   int hasMFMT ;
   int hasMFF ;
   int hasREST ;
   int hasNLST_a ;
   int hasNLST_d ;
   int hasFEAT ;
   int hasMLSD ;
   int hasMLST ;
   int usedMLS ;
   int hasCLNT ;
   int hasHELP_SITE ;
   int hasSITE_UTIME ;
   int hasSITE_RETRBUFSIZE ;
   int hasSITE_RBUFSIZ ;
   int hasSITE_RBUFSZ ;
   int hasSITE_STORBUFSIZE ;
   int hasSITE_SBUFSIZ ;
   int hasSITE_SBUFSZ ;
   int hasSITE_BUFSIZE ;
   int hasRETR_tar ;
   int mlsFeatures ;
   int STATfileParamWorks ;
   int NLSTfileParamWorks ;
   struct sockaddr_in servCtlAddr ;
   struct sockaddr_in servDataAddr ;
   struct sockaddr_in ourCtlAddr ;
   struct sockaddr_in ourDataAddr ;
   int netMode ;
   char *buf ;
   size_t bufSize ;
   int doAllocBuf ;
   FILE *cin ;
   FILE *cout ;
   int ctrlSocketR ;
   int ctrlSocketW ;
   int dataSocket ;
   int dataSocketConnected ;
   int leavePass ;
   int eofOkay ;
   int require20 ;
   int allowProxyForPORT ;
   int usingTAR ;
   int serverType ;
   int ietfCompatLevel ;
   int numDials ;
   int totalDials ;
   struct timeval initTime ;
   struct timeval startTime ;
   struct timeval connectTime ;
   struct timeval loginTime ;
   struct timeval disconnectTime ;
   struct timeval lastCmdStart ;
   struct timeval lastCmdFinish ;
   int numDownloads ;
   int numUploads ;
   int numListings ;
   int doNotGetStartingWorkingDirectory ;
   char textEOLN[4] ;
   int asciiTranslationMode ;
   char const   *manualOverrideFeatures ;
   struct sockaddr_in clientKnownExternalAddr ;
   struct sockaddr_in preferredLocalAddr ;
   int maxNumberOfSuccessivePASVAttempts ;
   char srlBuf[768] ;
   SReadlineInfo ctrlSrl ;
   int iUser ;
   void *pUser ;
   long long llUser ;
   int reserved[32] ;
};
#line 472 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct MLstItem {
   char fname[512] ;
   char linkto[512] ;
   int ftype ;
   long long fsize ;
   time_t ftime ;
   int mode ;
   int uid ;
   int gid ;
   char perm[16] ;
   char owner[16] ;
   char group[16] ;
};
#line 472 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct MLstItem MLstItem;
#line 472 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct MLstItem *MLstItemPtr;
#line 446
struct FTPFileInfo;
#line 446 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPFileInfo *FTPFileInfoPtr;
#line 446 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPFileInfo **FTPFileInfoVec;
#line 447 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPFileInfo {
   FTPFileInfoPtr prev ;
   FTPFileInfoPtr next ;
   char *relname ;
   char *rname ;
   char *rlinkto ;
   char *lname ;
   char *plug ;
   int type ;
   time_t mdtm ;
   long long size ;
   size_t relnameLen ;
   int mode ;
};
#line 461 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FTPFileInfoList {
   FTPFileInfoPtr first ;
   FTPFileInfoPtr last ;
   FTPFileInfoVec vec ;
   size_t maxFileLen ;
   size_t maxPlugLen ;
   int nFileInfos ;
   int sortKey ;
   int sortOrder ;
};
#line 461 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPFileInfoList FTPFileInfoList;
#line 461 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPFileInfoList *FTPFileInfoListPtr;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.h"
struct Bookmark;
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.h"
struct Bookmark {
   char bookmarkName[16] ;
   char name[64] ;
   char user[64] ;
   char pass[64] ;
   char acct[64] ;
   char dir[160] ;
   char ldir[160] ;
   int xferType ;
   unsigned int port ;
   time_t lastCall ;
   int hasSIZE ;
   int hasMDTM ;
   int hasPASV ;
   int isUnix ;
   char lastIP[32] ;
   char comment[128] ;
   int xferMode ;
   int hasUTIME ;
   int deleted ;
};
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.h"
typedef struct Bookmark Bookmark;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.h"
typedef struct Bookmark *BookmarkPtr;
#line 11 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrInternal.h"
struct DStr {
   char *s ;
   size_t len ;
   size_t allocSize ;
};
#line 11 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrInternal.h"
typedef struct DStr DStr;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_5 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_5 __sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 254 "../libncftp/ncftp.h"
typedef struct FTPLibraryInfo FTPLibraryInfo;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 230 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct Response Response;
#line 11 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
typedef char str16[16];
#line 12 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
typedef char longstring[512];
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 788 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FtwInfo;
#line 788 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FtwInfo *FtwInfoPtr;
#line 792 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct FtwInfo {
   unsigned int init ;
   int (*proc)(FtwInfoPtr const   ftwip ) ;
   char *curPath ;
   size_t curPathLen ;
   size_t curPathAllocSize ;
   size_t startPathLen ;
   char *curFile ;
   size_t curFileLen ;
   int curType ;
   struct stat curStat ;
   int noAutoMallocAndFree ;
   int dirSeparator ;
   char rootDir[4] ;
   int autoGrow ;
   size_t depth ;
   size_t maxDepth ;
   size_t numDirs ;
   size_t numFiles ;
   size_t numLinks ;
   char const   *rlinkto ;
   size_t direntbufSize ;
   void *direntbuf ;
   void *cip ;
   void *userdata ;
};
#line 792 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FtwInfo FtwInfo;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
struct FtwSubDirList;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
typedef struct FtwSubDirList *FtwSubDirListPtr;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
struct FtwSubDirList {
   FtwSubDirListPtr next ;
   struct stat st ;
   size_t fnLen ;
   char name[1] ;
};
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
typedef struct FtwSubDirList FtwSubDirList;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 271 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPConnectionInfo FTPConnectionInfo;
#line 220 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPLine FTPLine;
#line 447 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct FTPFileInfo FTPFileInfo;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.h"
struct PrefOpt {
   char const   *varname ;
   void (*proc)(char const   * const   , FILE * const  fp ) ;
   int visible ;
};
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.h"
typedef struct PrefOpt PrefOpt;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 390 "/usr/include/curses.h"
struct __anonstruct_cchar_t_64 {
   attr_t attr ;
   wchar_t chars[5] ;
};
#line 390 "/usr/include/curses.h"
typedef struct __anonstruct_cchar_t_64 cchar_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
   cchar_t _bkgrnd ;
};
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.h"
struct WGetsParams {
   WINDOW *w ;
   int sy ;
   int sx ;
   char *dst ;
   int fieldLen ;
   size_t dstSize ;
   int useCurrentContents ;
   int echoMode ;
   int changed ;
   int dstLen ;
   FTPLineListPtr history ;
};
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.h"
typedef struct WGetsParams *WGetsParamPtr;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 61 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglobr.c"
struct MyFtwExtraInfo {
   size_t limitMaxDirs ;
   size_t limitMaxFiles ;
   size_t limitMaxDepth ;
   FTPFileInfoListPtr fileList ;
};
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
struct ArgvInfo {
   char *cargv[255] ;
   int cargc ;
   int noglobargv[255] ;
   int reserved ;
   char argbuf[2048] ;
};
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
typedef struct ArgvInfo ArgvInfo;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
typedef struct ArgvInfo *ArgvInfoPtr;
#line 29
struct Command;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
typedef struct Command *CommandPtr;
#line 42 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
struct Command {
   char const   *name ;
   void (*proc)(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
   char const   *usage ;
   char const   *help ;
   int flags ;
   int minargs ;
   int maxargs ;
};
#line 42 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
typedef struct Command Command;
#line 241 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_gettar.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 241 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_gettar.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 344 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_gettar.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 344 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_gettar.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglobr.c"
struct LRFLState {
   int relativePathStartOffset ;
   FTPFileInfoListPtr filp ;
};
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglobr.c"
typedef struct LRFLState LRFLState;
#line 10 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.h"
struct LsCacheItem {
   char *itempath ;
   FTPFileInfoList fil ;
   time_t expiration ;
   int hits ;
};
#line 10 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.h"
typedef struct LsCacheItem LsCacheItem;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
struct SelectSet {
   fd_set fds ;
   struct timeval timeout ;
   int maxfd ;
   int numfds ;
};
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
typedef struct SelectSet SelectSet;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
typedef struct SelectSet *SelectSetPtr;
#line 819 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct GetoptInfo {
   unsigned int init ;
   int err ;
   int ind ;
   int opt ;
   char *arg ;
   char *place ;
};
#line 819 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
typedef struct GetoptInfo GetoptInfo;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_43 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_44 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_45 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_46 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_47 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_48 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_49 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_42 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_43 _kill ;
   struct __anonstruct__timer_44 _timer ;
   struct __anonstruct__rt_45 _rt ;
   struct __anonstruct__sigchld_46 _sigchld ;
   struct __anonstruct__sigfault_47 _sigfault ;
   struct __anonstruct__sigpoll_48 _sigpoll ;
   struct __anonstruct__sigsys_49 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_41 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_42 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_41 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_61 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_61 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 77 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_feat.c"
enum ConnInfoOptions {
    kOptPASV = 0,
    kOptSIZE = 1,
    kOptMDTM = 2,
    kOptMDTM_set = 3,
    kOptREST = 4,
    kOptNLST_a = 5,
    kOptNLST_d = 6,
    kOptFEAT = 7,
    kOptMLSD = 8,
    kOptMLST = 9,
    kOptCLNT = 10,
    kOptHELP_SITE = 11,
    kOptSITE_UTIME = 12,
    kOptSTATfileParamWorks = 13,
    kOptNLSTfileParamWorks = 14,
    kOptRequire20 = 15,
    kOptAllowProxyForPORT = 16,
    kOptDoNotGetStartCWD = 17,
    kOptNumConnInfoOptions = 18
} ;
#line 77 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_feat.c"
typedef enum ConnInfoOptions ConnInfoOptions;
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 379 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 66 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
struct SpoolCmdInfo {
   int xtype ;
   int deleteFlag ;
   int recurseFlag ;
   int renameMode ;
   time_t when ;
   char const   *lcwd ;
   char const   *rcwd ;
   int base ;
};
#line 66 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
typedef struct SpoolCmdInfo SpoolCmdInfo;
#line 991 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 990 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 1657 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 1657 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 3597 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 3597 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 872 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPChdir(FTPCIPtr const   cip , char const   * const  cdCwd ) ;
#line 891
int FTPFileType(FTPCIPtr const   cip , char const   * const  file , int * const  ftype ) ;
#line 893
int FTPGetCWD(FTPCIPtr const   cip , char * const  newCwd , size_t const   newCwdSize ) ;
#line 899
int FTPIsDir(FTPCIPtr const   cip , char const   * const  dir___3 ) ;
#line 900
int FTPIsRegularFile(FTPCIPtr const   cip , char const   * const  file ) ;
#line 1016
int FTPMListOneFile(FTPCIPtr const   cip , char const   * const  file , MLstItemPtr const   mlip ) ;
#line 1065
int FTPFileExists2(FTPCIPtr const   cip , char const   * const  file , int const   tryMDTM ,
                   int const   trySIZE , int const   tryMLST , int const   trySTAT ,
                   int const   tryNLST ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_filetype.c"
int FTPFileType(FTPCIPtr const   cip , char const   * const  file , int * const  ftype ) 
{ 
  int result ;
  MLstItem mlsInfo ;
  int tmp ;

  {
#line 19
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 20
    return (-139);
  }
  {
#line 21
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 21
  if (tmp) {
#line 22
    return (-138);
  }
#line 24
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 25
    cip->errNo = -139;
#line 26
    return (-139);
  } else
#line 24
  if ((int const   )*(file + 0) == 0) {
#line 25
    cip->errNo = -139;
#line 26
    return (-139);
  }
#line 29
  if ((unsigned long )ftype == (unsigned long )((void *)0)) {
#line 30
    cip->errNo = -139;
#line 31
    return (-139);
  }
  {
#line 34
  *ftype = 0;
#line 35
  result = FTPMListOneFile(cip, file, (MLstItemPtr const   )(& mlsInfo));
  }
#line 36
  if (result == 0) {
#line 37
    *ftype = mlsInfo.ftype;
#line 38
    return (0);
  }
  {
#line 42
  FTPGetCWD(cip, (char */* const  */)cip->buf, (size_t const   )cip->bufSize);
#line 44
  result = FTPChdir(cip, file);
  }
#line 45
  if (result == 0) {
    {
#line 46
    *ftype = 'd';
#line 50
    FTPChdir(cip, (char const   */* const  */)cip->buf);
    }
#line 56
    return (0);
  }
  {
#line 59
  result = FTPFileExists2(cip, file, (int const   )1, (int const   )1, (int const   )0,
                          (int const   )1, (int const   )1);
  }
#line 60
  if (result != -188) {
#line 61
    result = -190;
  }
#line 63
  return (result);
}
}
#line 69 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_filetype.c"
int FTPIsDir(FTPCIPtr const   cip , char const   * const  dir___3 ) 
{ 
  int result ;
  int ftype ;
  int tmp ;

  {
#line 74
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 75
    return (-139);
  }
  {
#line 76
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 76
  if (tmp) {
#line 77
    return (-138);
  }
#line 79
  if ((unsigned long )dir___3 == (unsigned long )((void *)0)) {
#line 80
    cip->errNo = -122;
#line 81
    return (-122);
  } else
#line 79
  if ((int const   )*(dir___3 + 0) == 0) {
#line 80
    cip->errNo = -122;
#line 81
    return (-122);
  }
  {
#line 84
  result = FTPFileType(cip, dir___3, (int */* const  */)(& ftype));
  }
#line 85
  if (result == 0) {
#line 85
    goto _L;
  } else
#line 85
  if (result == -190) {
    _L: /* CIL Label */ 
#line 86
    result = 0;
#line 87
    if (ftype == 100) {
#line 88
      result = 1;
    }
  }
#line 90
  return (result);
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_filetype.c"
int FTPIsRegularFile(FTPCIPtr const   cip , char const   * const  file ) 
{ 
  int result ;
  int ftype ;
  int tmp ;

  {
#line 101
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 102
    return (-139);
  }
  {
#line 103
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 103
  if (tmp) {
#line 104
    return (-138);
  }
#line 106
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 107
    cip->errNo = -139;
#line 108
    return (-139);
  } else
#line 106
  if ((int const   )*(file + 0) == 0) {
#line 107
    cip->errNo = -139;
#line 108
    return (-139);
  }
  {
#line 111
  result = FTPFileType(cip, file, (int */* const  */)(& ftype));
  }
#line 112
  if (result == 0) {
#line 112
    goto _L;
  } else
#line 112
  if (result == -190) {
    _L: /* CIL Label */ 
#line 113
    result = 1;
#line 114
    if (ftype == 100) {
#line 115
      result = 0;
    }
  }
#line 117
  return (result);
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 873 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPChdirAndGetCWD(FTPCIPtr const   cip , char const   * const  cdCwd , char * const  newCwd ,
                      size_t const   newCwdSize ) ;
#line 874
int FTPChdir3(FTPCIPtr cip , char const   * const  cdCwd , char * const  newCwd ,
              size_t const   newCwdSize , int flags___0 ) ;
#line 875
int FTPChdirList(FTPCIPtr cip , FTPLineListPtr const   cdlist , char * const  newCwd ,
                 size_t const   newCwdSize , int flags___0 ) ;
#line 878
int ( /* format attribute */  FTPCmd)(FTPCIPtr const   cip , char const   * const  cmdspec 
                                      , ...) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_chdirlist.c"
int FTPChdirList(FTPCIPtr cip , FTPLineListPtr const   cdlist , char * const  newCwd ,
                 size_t const   newCwdSize , int flags___0 ) 
{ 
  size_t len ;
  char *cdstr ;
  FTPLinePtr lp ;
  int lastSubDir ;
  int mkd ;
  int pwd ;
  int result ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 26
  if (flags___0 == 0) {
#line 27
    flags___0 = 8;
  }
#line 29
  if ((flags___0 & 8) != 0) {
#line 30
    len = (size_t )0;
#line 31
    lp = cdlist->first;
    {
#line 31
    while (1) {
      while_continue: /* CIL Label */ ;
#line 31
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 31
        goto while_break;
      }
      {
#line 32
      tmp = strlen((char const   *)lp->line);
#line 32
      len += tmp;
#line 33
      len ++;
#line 31
      lp = lp->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 35
    tmp___0 = malloc(len + 1UL);
#line 35
    cdstr = (char *)tmp___0;
    }
#line 36
    if ((unsigned long )cdstr == (unsigned long )((void *)0)) {
#line 37
      tmp___1 = -123;
#line 37
      cip->errNo = tmp___1;
#line 37
      return (tmp___1);
    }
#line 38
    *(cdstr + 0) = (char )'\000';
#line 39
    lp = cdlist->first;
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 39
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 39
        goto while_break___0;
      }
      {
#line 40
      strcat((char */* __restrict  */)cdstr, (char const   */* __restrict  */)lp->line);
      }
#line 41
      if ((unsigned long )lp->next != (unsigned long )((void *)0)) {
        {
#line 42
        strcat((char */* __restrict  */)cdstr, (char const   */* __restrict  */)"/");
        }
      }
#line 39
      lp = lp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 44
    tmp___2 = FTPChdir3(cip, (char const   */* const  */)cdstr, newCwd, newCwdSize,
                        flags___0 & -5);
    }
#line 44
    if (tmp___2 == 0) {
      {
#line 45
      free((void *)cdstr);
      }
#line 46
      return (0);
    }
    {
#line 48
    free((void *)cdstr);
    }
  }
#line 51
  if ((flags___0 & 4) != 0) {
#line 52
    mkd = flags___0 & 1;
#line 53
    pwd = flags___0 & 2;
#line 54
    lastSubDir = 0;
#line 55
    result = 0;
#line 57
    lp = cdlist->first;
    {
#line 57
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 57
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 57
        goto while_break___1;
      }
#line 58
      if ((unsigned long )lp->next == (unsigned long )((void *)0)) {
#line 59
        lastSubDir = 1;
      }
      {
#line 61
      tmp___5 = strcmp((char const   *)lp->line, ".");
      }
#line 61
      if (tmp___5 == 0) {
#line 62
        result = 0;
#line 63
        if (lastSubDir != 0) {
#line 63
          if (pwd != 0) {
            {
#line 64
            result = FTPGetCWD((FTPCIPtr const   )cip, newCwd, newCwdSize);
            }
          }
        }
      } else
#line 65
      if (lastSubDir != 0) {
#line 65
        if (pwd != 0) {
#line 66
          if ((int )*(lp->line) != 0) {
#line 66
            tmp___3 = (char const   *)lp->line;
          } else {
#line 66
            tmp___3 = "/";
          }
          {
#line 66
          result = FTPChdirAndGetCWD((FTPCIPtr const   )cip, (char const   */* const  */)tmp___3,
                                     newCwd, newCwdSize);
          }
        } else {
#line 65
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 68
        if ((int )*(lp->line) != 0) {
#line 68
          tmp___4 = (char const   *)lp->line;
        } else {
#line 68
          tmp___4 = "/";
        }
        {
#line 68
        result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)tmp___4);
        }
      }
#line 70
      if (result < 0) {
#line 71
        if (mkd != 0) {
#line 71
          if ((int )*(lp->line) != 0) {
            {
#line 72
            tmp___6 = FTPCmd((FTPCIPtr const   )cip, (char const   */* const  */)"MKD %s",
                             lp->line);
            }
#line 72
            if (tmp___6 == 2) {
              {
#line 73
              result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)lp->line);
              }
            } else {
#line 76
              cip->errNo = result;
            }
          } else {
#line 79
            cip->errNo = result;
          }
        } else {
#line 79
          cip->errNo = result;
        }
      }
#line 82
      if (result != 0) {
#line 83
        goto while_break___1;
      }
#line 57
      lp = lp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 85
    return (result);
  }
#line 88
  return (-139);
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Strncpy(char * const  dst , char const   * const  src , size_t const   n ) ;
#line 906 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPMkdir(FTPCIPtr const   cip , char const   * const  newDir , int const   recurse ) ;
#line 907
int FTPMkdir2(FTPCIPtr const   cip , char const   * const  newDir , int const   recurse ,
              char const   * const  curDir ) ;
#line 908
int FTPMkParentDir(FTPCIPtr const   cip , char const   * const  path , int const   recurse ,
                   char const   * const  curDir ) ;
#line 966
void StrRemoveTrailingSlashes(char *dst ) ;
#line 1109
void ( /* format attribute */  FTPLogError)(FTPCIPtr const   cip , int const   pError ,
                                            char const   * const  fmt  , ...) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_mkdir.c"
int FTPMkdir2(FTPCIPtr const   cip , char const   * const  newDir , int const   recurse ,
              char const   * const  curDir ) 
{ 
  int result ;
  int result2 ;
  char *cp ;
  char *newTreeStart ;
  char *cp2 ;
  char dir___3[512] ;
  char dir2[512] ;
  char c ;
  int tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 22
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 23
    return (-139);
  }
  {
#line 24
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 24
  if (tmp) {
#line 25
    return (-138);
  }
#line 27
  if ((unsigned long )newDir == (unsigned long )((void *)0)) {
#line 28
    cip->errNo = -122;
#line 29
    return (-122);
  } else
#line 27
  if ((int const   )*(newDir + 0) == 0) {
#line 28
    cip->errNo = -122;
#line 29
    return (-122);
  }
#line 33
  if ((unsigned long )curDir == (unsigned long )((void *)0)) {
    {
#line 40
    FTPGetCWD(cip, (char */* const  */)cip->buf, (size_t const   )cip->bufSize);
    }
  } else
#line 33
  if ((int const   )*(curDir + 0) == 0) {
    {
#line 40
    FTPGetCWD(cip, (char */* const  */)cip->buf, (size_t const   )cip->bufSize);
    }
  }
  {
#line 43
  result = FTPChdir(cip, newDir);
  }
#line 44
  if (result == 0) {
#line 48
    if ((unsigned long )curDir == (unsigned long )((void *)0)) {
#line 48
      tmp___0 = (char const   */* const  */)cip->buf;
    } else
#line 48
    if ((int const   )*(curDir + 0) == 0) {
#line 48
      tmp___0 = (char const   */* const  */)cip->buf;
    } else {
#line 48
      tmp___0 = curDir;
    }
    {
#line 48
    result2 = FTPChdir(cip, tmp___0);
    }
#line 49
    if (result2 < 0) {
#line 50
      result = -141;
#line 51
      cip->errNo = -141;
#line 52
      return (result);
    }
#line 56
    return (0);
  }
#line 59
  if (recurse == 0) {
    {
#line 60
    result = FTPCmd(cip, (char const   */* const  */)"MKD %s", newDir);
    }
#line 61
    if (result > 0) {
#line 62
      if (result != 2) {
        {
#line 63
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"MKD %s failed; [%s]\n",
                    newDir, cip->lastFTPCmdResultStr);
#line 64
        result = -140;
#line 65
        cip->errNo = -140;
        }
#line 66
        return (result);
      } else {
#line 68
        result = 0;
      }
    }
  } else {
    {
#line 72
    Strncpy((char */* const  */)(dir___3), newDir, (size_t const   )sizeof(dir___3));
#line 75
    tmp___1 = strlen((char const   *)(dir___3));
#line 75
    cp = (dir___3 + tmp___1) - 1;
    }
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if ((unsigned long )cp <= (unsigned long )(dir___3)) {
#line 78
        if ((unsigned long )newDir == (unsigned long )((void *)0)) {
#line 79
          cip->errNo = -122;
#line 80
          result = -122;
#line 81
          return (result);
        } else
#line 78
        if ((int const   )*(newDir + 0) == 0) {
#line 79
          cip->errNo = -122;
#line 80
          result = -122;
#line 81
          return (result);
        }
      }
#line 84
      if ((int )*cp != 47) {
#line 84
        if ((int )*cp != 92) {
#line 85
          *(cp + 1) = (char )'\000';
#line 86
          goto while_break;
        }
      }
#line 88
      cp --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 90
    Strncpy((char */* const  */)(dir2), (char const   */* const  */)(dir___3), (size_t const   )sizeof(dir2));
#line 92
    tmp___2 = strrchr((char const   *)(dir___3), '/');
    }
#line 92
    if ((unsigned long )tmp___2 == (unsigned long )(dir___3)) {
#line 92
      goto _L;
    } else {
      {
#line 92
      tmp___3 = strrchr((char const   *)(dir___3), '\\');
      }
#line 92
      if ((unsigned long )tmp___3 == (unsigned long )(dir___3)) {
        _L: /* CIL Label */ 
        {
#line 94
        result = FTPCmd(cip, (char const   */* const  */)"MKD %s", dir___3);
        }
#line 95
        if (result < 0) {
#line 96
          return (result);
        }
#line 98
        if (result != 2) {
          {
#line 99
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"MKD %s failed; [%s]\n",
                      dir___3, cip->lastFTPCmdResultStr);
#line 100
          result = -140;
#line 101
          cip->errNo = -140;
          }
#line 102
          return (result);
        }
#line 105
        return (0);
      }
    }
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 109
      cp = strrchr((char const   *)(dir___3), '/');
      }
#line 110
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 111
        cp = strrchr((char const   *)(dir___3), '\\');
        }
      }
#line 112
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 113
        tmp___4 = strlen((char const   *)(dir___3));
#line 113
        cp = (dir___3 + tmp___4) - 1;
        }
#line 114
        if ((int )dir___3[0] == 0) {
#line 115
          result = -140;
#line 116
          cip->errNo = -140;
#line 117
          return (result);
        }
#line 123
        cp = dir___3;
#line 124
        cp --;
#line 125
        goto while_break___0;
      }
#line 127
      if ((unsigned long )cp == (unsigned long )(dir___3)) {
#line 128
        result = -140;
#line 129
        cip->errNo = -140;
#line 130
        return (result);
      }
      {
#line 132
      *cp = (char )'\000';
#line 133
      result = FTPChdir(cip, (char const   */* const  */)(dir___3));
      }
#line 134
      if (result == 0) {
#line 135
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 140
    newTreeStart = dir2 + ((cp + 1) - dir___3);
#line 141
    cp = newTreeStart;
    {
#line 141
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 142
      cp2 = cp;
#line 143
      cp = strchr((char const   *)cp2, '/');
#line 144
      c = (char )'/';
      }
#line 145
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 146
        cp = strchr((char const   *)cp2, '\\');
        }
      }
#line 147
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 148
        c = *cp;
#line 149
        *cp = (char )'\000';
#line 150
        if ((int )*(cp + 1) == 0) {
#line 152
          goto while_break___1;
        }
      }
      {
#line 155
      result = FTPCmd(cip, (char const   */* const  */)"MKD %s", newTreeStart);
      }
#line 156
      if (result < 0) {
#line 157
        return (result);
      }
#line 159
      if (result != 2) {
        {
#line 160
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Cwd=%s; MKD %s failed; [%s]\n",
                    cip->buf, newTreeStart, cip->lastFTPCmdResultStr);
#line 161
        result = -140;
#line 162
        cip->errNo = -140;
        }
#line 163
        goto goback;
      }
#line 165
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 166
        goto while_break___1;
      }
#line 167
      tmp___5 = cp;
#line 167
      cp ++;
#line 167
      *tmp___5 = c;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 169
    result = 0;
    goback: 
#line 172
    if ((unsigned long )curDir == (unsigned long )((void *)0)) {
#line 172
      tmp___6 = (char const   */* const  */)cip->buf;
    } else
#line 172
    if ((int const   )*(curDir + 0) == 0) {
#line 172
      tmp___6 = (char const   */* const  */)cip->buf;
    } else {
#line 172
      tmp___6 = curDir;
    }
    {
#line 172
    result2 = FTPChdir(cip, tmp___6);
    }
#line 173
    if (result == 0) {
#line 173
      if (result2 < 0) {
#line 174
        result = -141;
#line 175
        cip->errNo = -141;
      }
    }
  }
#line 178
  return (result);
}
}
#line 183 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_mkdir.c"
int FTPMkdir(FTPCIPtr const   cip , char const   * const  newDir , int const   recurse ) 
{ 
  int tmp ;

  {
  {
#line 186
  tmp = FTPMkdir2(cip, newDir, recurse, (char const   */* const  */)((void *)0));
  }
#line 186
  return (tmp);
}
}
#line 192 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_mkdir.c"
int FTPMkParentDir(FTPCIPtr const   cip , char const   * const  path , int const   recurse ,
                   char const   * const  curDir ) 
{ 
  char newDir[512] ;
  char *cp ;
  int tmp ;

  {
#line 198
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 199
    cip->errNo = -122;
#line 200
    return (-122);
  } else
#line 198
  if ((int const   )*(path + 0) == 0) {
#line 199
    cip->errNo = -122;
#line 200
    return (-122);
  }
  {
#line 203
  Strncpy((char */* const  */)(newDir), path, (size_t const   )sizeof(newDir));
  }
#line 204
  if ((int )newDir[sizeof(newDir) - 2UL] != 0) {
#line 204
    if ((int const   )*(path + (sizeof(newDir) - 1UL)) != 0) {
#line 206
      cip->errNo = -122;
#line 207
      return (-122);
    }
  }
  {
#line 210
  StrRemoveTrailingSlashes(newDir);
#line 211
  cp = strrchr((char const   *)(newDir), '/');
  }
#line 212
  if ((unsigned long )cp == (unsigned long )(newDir)) {
#line 214
    return (0);
  } else
#line 215
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 219
    return (0);
  }
  {
#line 221
  *cp = (char )'\000';
#line 223
  tmp = FTPMkdir2(cip, (char const   */* const  */)(newDir), recurse, curDir);
  }
#line 223
  return (tmp);
}
}
#line 803 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 888 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPFileSize(FTPCIPtr const   cip , char const   * const  file , long long * const  size ,
                int const   type ) ;
#line 895
int FTPGetFiles3(FTPCIPtr const   cip , char const   *pattern1 , char const   * const  dstdir1 ,
                 int const   recurse , int doGlob , int const   xtype , int const   resumeflag ,
                 int appendflag , int const   deleteflag , int const   tarflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                                                           char const   **localpath ,
                                                                                                           long long localsize ,
                                                                                                           time_t localmtime ,
                                                                                                           char const   *remotepath ,
                                                                                                           long long remotesize ,
                                                                                                           time_t remotetime ,
                                                                                                           long long *startPoint ) ,
                 int reserved  __attribute__((__unused__)) ) ;
#line 916
int FTPRemoteGlob(FTPCIPtr cip , FTPLineListPtr fileList , char const   *pattern ,
                  int doGlob ) ;
#line 928
void DisposeLineListContents(FTPLineListPtr list ) ;
#line 951
char *StrDup(char const   *buf ) ;
#line 963
int MkDirs(char const   * const  newdir , int mode1 ) ;
#line 990
int FTPGetFiles(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                int const   recurse , int const   doGlob ) ;
#line 991
int FTPGetFiles2(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                 int const   recurse , int const   doGlob , int const   xtype , int const   resumeflag ,
                 int const   appendflag ) ;
#line 993
int FTPGetFilesAscii(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                     int const   recurse , int const   doGlob ) ;
#line 1037
int FTPSetTransferType(FTPCIPtr const   cip , int type ) ;
#line 1058
int FTPRemoteRecursiveFileList2(FTPCIPtr cip , char * const  rdir , FTPFileInfoListPtr files ) ;
#line 1070
void DisposeFileInfoListContents(FTPFileInfoListPtr list ) ;
#line 1082
int ComputeRNames(FTPFileInfoListPtr dst , char const   *dstdir , int pflag , int nochop ) ;
#line 1083
int ComputeLNames(FTPFileInfoListPtr dst , char const   *srcdir , char const   *dstdir ,
                  int nochop ) ;
#line 1087
int LineToFileInfoList(FTPLinePtr lp , FTPFileInfoListPtr dst ) ;
#line 93 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
void FTPCheckForRestartModeAvailability(FTPCIPtr const   cip ) ;
#line 99
int FTPGetOneF(FTPCIPtr const   cip , char const   * const  file , char const   *dstfile ,
               int xtype , int const   fdtouse , long long expectedSize , time_t mdtm ,
               int const   resumeflag , int const   appendflag , int const   deleteflag ,
               int (* const  resumeProc)(FTPCIPtr const   cip , char const   **localpath ,
                                         long long localsize , time_t localmtime ,
                                         char const   *remotepath , long long remotesize ,
                                         time_t remotetime , long long *startPoint ) ) ;
#line 127
int FTPGetOneTarF(FTPCIPtr const   cip , char const   *file , char const   * const  dstdir ) ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getfiles.c"
int FTPGetFiles3(FTPCIPtr const   cip , char const   *pattern1 , char const   * const  dstdir1 ,
                 int const   recurse , int doGlob , int const   xtype , int const   resumeflag ,
                 int appendflag , int const   deleteflag , int const   tarflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                                                           char const   **localpath ,
                                                                                                           long long localsize ,
                                                                                                           time_t localmtime ,
                                                                                                           char const   *remotepath ,
                                                                                                           long long remotesize ,
                                                                                                           time_t remotetime ,
                                                                                                           long long *startPoint ) ,
                 int reserved  __attribute__((__unused__)) ) 
{ 
  FTPLineList globList ;
  FTPLinePtr itemPtr ;
  FTPFileInfoList files ;
  FTPFileInfoPtr filePtr ;
  int batchResult ;
  int result ;
  char *ldir ;
  char *cp ;
  char const   *dstdir ;
  char const   *pattern ;
  char *pattern2 ;
  char *dstdir2 ;
  char c ;
  int recurse1 ;
  int errRc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 65
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 66
    return (-139);
  }
  {
#line 67
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 67
  if (tmp) {
#line 68
    return (-138);
  }
#line 69
  if ((unsigned long )pattern1 == (unsigned long )((void *)0)) {
#line 70
    return (-139);
  }
#line 72
  dstdir2 = (char *)((void *)0);
#line 73
  pattern2 = (char *)((void *)0);
#line 75
  if ((unsigned long )dstdir1 == (unsigned long )((void *)0)) {
#line 76
    dstdir = (char const   *)((void *)0);
  } else {
    {
#line 78
    dstdir2 = StrDup((char const   *)dstdir1);
    }
#line 79
    if ((unsigned long )dstdir2 == (unsigned long )((void *)0)) {
#line 80
      errRc = -123;
#line 81
      goto return_err;
    }
    {
#line 83
    StrRemoveTrailingSlashes(dstdir2);
#line 84
    dstdir = (char const   *)dstdir2;
    }
  }
  {
#line 87
  pattern2 = StrDup(pattern1);
  }
#line 88
  if ((unsigned long )pattern2 == (unsigned long )((void *)0)) {
#line 89
    errRc = -123;
#line 90
    goto return_err;
  }
  {
#line 92
  StrRemoveTrailingSlashes(pattern2);
#line 93
  pattern = (char const   *)pattern2;
  }
#line 95
  if ((int const   )*(pattern + 0) == 0) {
#line 96
    if (recurse == 0) {
#line 97
      errRc = -139;
#line 98
      goto return_err;
    }
#line 100
    pattern = ".";
#line 101
    doGlob = 0;
  } else {
    {
#line 102
    tmp___2 = strcmp(pattern, ".");
    }
#line 102
    if (tmp___2 == 0) {
#line 103
      if (recurse == 0) {
#line 104
        errRc = -139;
#line 105
        goto return_err;
      }
#line 107
      doGlob = 0;
    } else {
      {
#line 108
      tmp___0 = strcmp(pattern, "/");
      }
#line 108
      if (tmp___0 == 0) {
#line 108
        if ((unsigned long )dstdir == (unsigned long )((void *)0)) {
          {
#line 110
          free((void *)pattern2);
#line 111
          pattern2 = StrDup("/.");
#line 112
          pattern = (char const   *)pattern2;
          }
        } else {
          {
#line 108
          tmp___1 = strcmp(dstdir, ".");
          }
#line 108
          if (tmp___1 == 0) {
            {
#line 110
            free((void *)pattern2);
#line 111
            pattern2 = StrDup("/.");
#line 112
            pattern = (char const   *)pattern2;
            }
          } else
#line 108
          if ((int const   )*(dstdir + 0) == 0) {
            {
#line 110
            free((void *)pattern2);
#line 111
            pattern2 = StrDup("/.");
#line 112
            pattern = (char const   *)pattern2;
            }
          }
        }
      }
    }
  }
#line 118
  if (recurse == 1) {
#line 119
    appendflag = 0;
  }
  {
#line 121
  batchResult = FTPRemoteGlob((FTPCIPtr )cip, & globList, pattern, doGlob);
  }
#line 122
  if (batchResult != 0) {
#line 123
    errRc = batchResult;
#line 124
    goto return_err;
  }
#line 127
  cip->cancelXfer = 0;
#line 129
  itemPtr = globList.first;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! ((unsigned long )itemPtr != (unsigned long )((void *)0))) {
#line 129
      goto while_break;
    }
#line 130
    if (recurse == 1) {
      {
#line 130
      tmp___4 = FTPIsDir(cip, (char const   */* const  */)itemPtr->line);
      }
#line 130
      if (tmp___4 > 0) {
#line 132
        if (tarflag == 1) {
#line 132
          if (xtype == 73) {
#line 132
            if (appendflag == 0) {
#line 132
              if (deleteflag == 0) {
                {
#line 132
                tmp___3 = FTPGetOneTarF(cip, (char const   *)itemPtr->line, (char const   */* const  */)dstdir);
                }
#line 132
                if (tmp___3 == 0) {
#line 134
                  goto __Cont;
                }
              }
            }
          }
        }
        {
#line 137
        FTPRemoteRecursiveFileList2((FTPCIPtr )cip, (char */* const  */)itemPtr->line,
                                    & files);
#line 138
        ComputeLNames(& files, (char const   *)itemPtr->line, dstdir, 1);
#line 139
        recurse1 = (int )recurse;
        }
      } else {
        {
#line 141
        recurse1 = 0;
#line 142
        LineToFileInfoList(itemPtr, & files);
#line 143
        ComputeRNames(& files, ".", 0, 1);
#line 144
        ComputeLNames(& files, (char const   *)((void *)0), dstdir, 0);
        }
      }
    } else {
      {
#line 141
      recurse1 = 0;
#line 142
      LineToFileInfoList(itemPtr, & files);
#line 143
      ComputeRNames(& files, ".", 0, 1);
#line 144
      ComputeLNames(& files, (char const   *)((void *)0), dstdir, 0);
      }
    }
#line 146
    if (cip->cancelXfer > 0) {
      {
#line 147
      DisposeFileInfoListContents(& files);
      }
#line 148
      goto while_break;
    }
#line 165
    filePtr = files.first;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 165
        goto while_break___0;
      }
#line 166
      if (cip->connected == 0) {
#line 167
        if (batchResult == 0) {
#line 168
          batchResult = -158;
        }
#line 169
        goto while_break___0;
      }
#line 171
      if (filePtr->type == 100) {
        {
#line 172
        MkDirs((char const   */* const  */)filePtr->lname, 511);
        }
      } else
#line 173
      if (! (filePtr->type == 108)) {
#line 175
        if (recurse1 != 1) {
          {
#line 176
          result = FTPGetOneF(cip, (char const   */* const  */)filePtr->rname, (char const   *)filePtr->lname,
                              (int )xtype, (int const   )-1, filePtr->size, filePtr->mdtm,
                              resumeflag, (int const   )appendflag, deleteflag, resumeProc);
          }
#line 177
          if (files.nFileInfos == 1) {
#line 178
            if (result != 0) {
#line 179
              batchResult = result;
            }
          } else
#line 181
          if (result != 0) {
#line 181
            if (result != -176) {
#line 181
              if (result != -177) {
#line 181
                if (result != -178) {
#line 182
                  batchResult = result;
                }
              }
            }
          }
#line 184
          if (result == -195) {
#line 185
            cip->cancelXfer = 1;
          }
#line 186
          if (cip->cancelXfer > 0) {
#line 187
            goto while_break___0;
          }
        } else {
          {
#line 189
          ldir = filePtr->lname;
#line 190
          cp = strrchr((char const   *)ldir, '/');
          }
#line 191
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
            {
#line 192
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 192
              if (! ((unsigned long )cp >= (unsigned long )ldir)) {
#line 192
                goto while_break___1;
              }
#line 193
              if (! ((int )*cp == 47)) {
#line 194
                cp ++;
#line 195
                goto while_break___1;
              }
#line 197
              cp --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 199
            if ((unsigned long )cp > (unsigned long )ldir) {
              {
#line 200
              c = *cp;
#line 201
              *cp = (char )'\000';
#line 202
              tmp___5 = MkDirs((char const   */* const  */)ldir, 511);
              }
#line 202
              if (tmp___5 < 0) {
                {
#line 203
                FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not create local directory \"%s\"\n",
                            ldir);
#line 204
                batchResult = -1;
#line 205
                *cp = c;
                }
#line 206
                goto __Cont___0;
              }
#line 208
              *cp = c;
            }
          }
#line 211
          if (xtype == 65) {
#line 219
            if (resumeflag == 1) {
              {
#line 220
              FTPCheckForRestartModeAvailability(cip);
              }
            } else
#line 219
            if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                                        char const   **localpath ,
                                                                        long long localsize ,
                                                                        time_t localmtime ,
                                                                        char const   *remotepath ,
                                                                        long long remotesize ,
                                                                        time_t remotetime ,
                                                                        long long *startPoint ))0)) {
              {
#line 220
              FTPCheckForRestartModeAvailability(cip);
              }
            }
            {
#line 222
            result = FTPSetTransferType(cip, (int )xtype);
            }
#line 223
            if (result < 0) {
#line 224
              return (result);
            }
            {
#line 225
            FTPFileSize(cip, (char const   */* const  */)filePtr->rname, (long long */* const  */)(& filePtr->size),
                        xtype);
            }
          }
          {
#line 227
          result = FTPGetOneF(cip, (char const   */* const  */)filePtr->rname, (char const   *)filePtr->lname,
                              (int )xtype, (int const   )-1, filePtr->size, filePtr->mdtm,
                              resumeflag, (int const   )appendflag, deleteflag, resumeProc);
          }
#line 229
          if (files.nFileInfos == 1) {
#line 230
            if (result != 0) {
#line 231
              batchResult = result;
            }
          } else
#line 233
          if (result != 0) {
#line 233
            if (result != -176) {
#line 233
              if (result != -177) {
#line 233
                if (result != -178) {
#line 234
                  batchResult = result;
                }
              }
            }
          }
#line 236
          if (result == -195) {
#line 237
            cip->cancelXfer = 1;
          }
#line 238
          if (cip->cancelXfer > 0) {
#line 239
            goto while_break___0;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 165
      filePtr = filePtr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 242
    if (cip->cancelXfer > 0) {
      {
#line 243
      DisposeFileInfoListContents(& files);
      }
#line 244
      goto while_break;
    }
#line 248
    filePtr = files.first;
    {
#line 248
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 248
      if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 248
        goto while_break___2;
      }
#line 249
      if (filePtr->type == 108) {
        {
#line 250
        unlink((char const   *)filePtr->lname);
#line 251
        tmp___6 = symlink((char const   *)filePtr->rlinkto, (char const   *)filePtr->lname);
        }
#line 251
        if (tmp___6 < 0) {
          {
#line 252
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not symlink %s to %s\n",
                      filePtr->rlinkto, filePtr->lname);
          }
        }
      }
#line 248
      filePtr = filePtr->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 260
    DisposeFileInfoListContents(& files);
    }
    __Cont: /* CIL Label */ 
#line 129
    itemPtr = itemPtr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  DisposeLineListContents(& globList);
  }
#line 264
  if (batchResult < 0) {
#line 265
    cip->errNo = batchResult;
  }
#line 266
  errRc = batchResult;
  return_err: 
#line 269
  if ((unsigned long )dstdir2 != (unsigned long )((void *)0)) {
    {
#line 270
    free((void *)dstdir2);
    }
  }
#line 271
  if ((unsigned long )pattern2 != (unsigned long )((void *)0)) {
    {
#line 272
    free((void *)pattern2);
    }
  }
#line 273
  return (errRc);
}
}
#line 279 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getfiles.c"
int FTPGetFiles(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                int const   recurse , int const   doGlob ) 
{ 
  int tmp ;

  {
  {
#line 282
  tmp = FTPGetFiles3(cip, (char const   *)pattern, dstdir, recurse, (int )doGlob,
                     (int const   )'I', (int const   )0, 0, (int const   )0, (int const   )1,
                     (int (*/* const  */)(FTPCIPtr const   cip , char const   **localpath ,
                                          long long localsize , time_t localmtime ,
                                          char const   *remotepath , long long remotesize ,
                                          time_t remotetime , long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                char const   **localpath ,
                                                                                                long long localsize ,
                                                                                                time_t localmtime ,
                                                                                                char const   *remotepath ,
                                                                                                long long remotesize ,
                                                                                                time_t remotetime ,
                                                                                                long long *startPoint ))0),
                     0);
  }
#line 282
  return (tmp);
}
}
#line 288 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getfiles.c"
int FTPGetFiles2(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                 int const   recurse , int const   doGlob , int const   xtype , int const   resumeflag ,
                 int const   appendflag ) 
{ 
  int tmp ;

  {
  {
#line 291
  tmp = FTPGetFiles3(cip, (char const   *)pattern, dstdir, recurse, (int )doGlob,
                     xtype, resumeflag, (int )appendflag, (int const   )0, (int const   )1,
                     (int (*/* const  */)(FTPCIPtr const   cip , char const   **localpath ,
                                          long long localsize , time_t localmtime ,
                                          char const   *remotepath , long long remotesize ,
                                          time_t remotetime , long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                char const   **localpath ,
                                                                                                long long localsize ,
                                                                                                time_t localmtime ,
                                                                                                char const   *remotepath ,
                                                                                                long long remotesize ,
                                                                                                time_t remotetime ,
                                                                                                long long *startPoint ))0),
                     0);
  }
#line 291
  return (tmp);
}
}
#line 297 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getfiles.c"
int FTPGetFilesAscii(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                     int const   recurse , int const   doGlob ) 
{ 
  int tmp ;

  {
  {
#line 300
  tmp = FTPGetFiles3(cip, (char const   *)pattern, dstdir, recurse, (int )doGlob,
                     (int const   )'A', (int const   )0, 0, (int const   )0, (int const   )0,
                     (int (*/* const  */)(FTPCIPtr const   cip , char const   **localpath ,
                                          long long localsize , time_t localmtime ,
                                          char const   *remotepath , long long remotesize ,
                                          time_t remotetime , long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                char const   **localpath ,
                                                                                                long long localsize ,
                                                                                                time_t localmtime ,
                                                                                                char const   *remotepath ,
                                                                                                long long remotesize ,
                                                                                                time_t remotetime ,
                                                                                                long long *startPoint ))0),
                     0);
  }
#line 300
  return (tmp);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 958 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
struct tm *Gmtime(time_t t , struct tm * const  tp ) ;
#line 960
time_t GetUTCOffset(int const   mon , int const   mday ) ;
#line 961
time_t GetUTCOffset2(int const   year , int const   mon , int const   mday , int const   hour ,
                     int const   min ) ;
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getutc.c"
time_t GetUTCOffset2(int const   year , int const   mon , int const   mday , int const   hour ,
                     int const   min ) 
{ 
  struct tm local_tm ;
  struct tm utc_tm ;
  struct tm *utc_tmptr ;
  time_t local_t ;
  time_t utc_t ;
  time_t utcOffset ;

  {
  {
#line 21
  memset((void *)(& local_tm), 0, sizeof(local_tm));
#line 22
  memset((void *)(& utc_tm), 0, sizeof(utc_tm));
#line 23
  utcOffset = (time_t )0;
#line 25
  local_tm.tm_year = (int )year;
#line 26
  local_tm.tm_mon = (int )(mon - 1);
#line 27
  local_tm.tm_mday = (int )mday;
#line 28
  local_tm.tm_hour = (int )hour;
#line 29
  local_tm.tm_min = (int )min;
#line 30
  local_tm.tm_isdst = -1;
#line 31
  local_t = mktime(& local_tm);
  }
#line 33
  if (local_t != -1L) {
    {
#line 34
    utc_tmptr = Gmtime(local_t, (struct tm */* const  */)(& local_tm));
#line 35
    utc_tm.tm_year = utc_tmptr->tm_year;
#line 36
    utc_tm.tm_mon = utc_tmptr->tm_mon;
#line 37
    utc_tm.tm_mday = utc_tmptr->tm_mday;
#line 38
    utc_tm.tm_hour = utc_tmptr->tm_hour;
#line 39
    utc_tm.tm_min = utc_tmptr->tm_min;
#line 40
    utc_tm.tm_isdst = -1;
#line 41
    utc_t = mktime(& utc_tm);
    }
#line 43
    if (utc_t != -1L) {
#line 44
      utcOffset = local_t - utc_t;
    }
  }
#line 46
  return (utcOffset);
}
}
#line 55 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getutc.c"
time_t GetUTCOffset(int const   mon , int const   mday ) 
{ 
  time_t tmp ;

  {
  {
#line 58
  tmp = GetUTCOffset2((int const   )2000, mon, mday, (int const   )12, (int const   )0);
  }
#line 58
  return (tmp);
}
}
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 22 "../Strn/Strn.h"
char *Strncat(char * const  dst , char const   * const  src , size_t const   n ) ;
#line 42 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.h"
double FileSize(double size , char const   **uStr0 , double *uMult0 ) ;
#line 43
void PrSizeAndRateMeter(FTPCIPtr const   cip , int mode ) ;
#line 44
void PrStatBar(FTPCIPtr const   cip , int mode ) ;
#line 45
int ReadConfigFromBookmark(char const   * const  bmname , FTPCIPtr cip ) ;
#line 46
int ReadConfigFile(char const   *fn0 , FTPCIPtr cip ) ;
#line 47
void SetRedial(FTPCIPtr const   cip , char const   * const  argstr ) ;
#line 48
void SetTimeouts(FTPCIPtr const   cip , char const   * const  argstr ) ;
#line 50
int GetDefaultProgressMeterSetting(void) ;
#line 51
FILE *OpenPager(void) ;
#line 52
void ClosePager(FILE *fp ) ;
#line 53
int AdditionalCmd(FTPCIPtr const   cip , char const   * const  spec , char const   * const  arg ) ;
#line 95 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.h"
void AbbrevStr(char *dst , char const   *src , size_t max , int mode ) ;
#line 54 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.h"
int GetBookmark(char const   * const  bmabbr , Bookmark *bmp ) ;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty1  =    1;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty2  =    1;
#line 30
int gLoadedBm ;
#line 30
int gBookmarkMatchMode ;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
Bookmark gBm  ;
#line 33 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
double FileSize(double size , char const   **uStr0 , double *uMult0 ) 
{ 
  double uMult___10 ;
  double uTotal___4 ;
  char const   *uStr___10 ;

  {
#line 44
  if (size > 999.5 * (double )1073741824L) {
#line 45
    uStr___10 = "TB";
#line 46
    uMult___10 = (double )1073741824L * 1024.0;
  } else
#line 47
  if (size > 999.5 * (double )1048576) {
#line 48
    uStr___10 = "GB";
#line 49
    uMult___10 = (double )1073741824L;
  } else
#line 50
  if (size > 999.5 * (double )1024) {
#line 51
    uStr___10 = "MB";
#line 52
    uMult___10 = (double )1048576;
  } else
#line 53
  if (size > 999.5) {
#line 54
    uStr___10 = "kB";
#line 55
    uMult___10 = (double )1024;
  } else {
#line 57
    uStr___10 = "B";
#line 58
    uMult___10 = (double )1;
  }
#line 60
  if ((unsigned long )uStr0 != (unsigned long )((void *)0)) {
#line 61
    *uStr0 = uStr___10;
  }
#line 62
  if ((unsigned long )uMult0 != (unsigned long )((void *)0)) {
#line 63
    *uMult0 = uMult___10;
  }
#line 64
  uTotal___4 = size / uMult___10;
#line 65
  if (uTotal___4 < 0.0) {
#line 66
    uTotal___4 = 0.0;
  }
#line 67
  return (uTotal___4);
}
}
#line 78 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr  ;
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult  ;
#line 73 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
void PrSizeAndRateMeter(FTPCIPtr const   cip , int mode ) 
{ 
  double rate ;
  char const   *rStr ;
  char localName[32] ;
  char line[128] ;
  int i___0 ;
  size_t tmp ;

  {
  {
#line 85
  if (mode == 1) {
#line 85
    goto case_1;
  }
#line 104
  if (mode == 3) {
#line 104
    goto case_3;
  }
#line 104
  if (mode == 2) {
#line 104
    goto case_3;
  }
#line 84
  goto switch_break;
  case_1: /* CIL Label */ 
#line 86
  if (cip->expectedSize != -1LL) {
    {
#line 87
    cip->progress = & PrStatBar;
#line 88
    PrStatBar(cip, mode);
    }
#line 89
    return;
  }
  {
#line 91
  FileSize((double )cip->expectedSize, & uStr, & uMult);
  }
#line 93
  if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 94
    localName[0] = (char )'\000';
  } else {
    {
#line 96
    AbbrevStr(localName, cip->lname, sizeof(localName) - 2UL, 0);
#line 97
    Strncat((char */* const  */)(localName), (char const   */* const  */)":", (size_t const   )sizeof(localName));
    }
  }
  {
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-32s",
          localName);
  }
#line 101
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 105
  rate = FileSize(cip->kBytesPerSec * 1024.0, & rStr, (double *)((void *)0));
  }
#line 107
  if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 108
    localName[0] = (char )'\000';
  } else {
    {
#line 110
    AbbrevStr(localName, cip->lname, sizeof(localName) - 2UL, 0);
#line 111
    Strncat((char */* const  */)(localName), (char const   */* const  */)":", (size_t const   )sizeof(localName));
    }
  }
  {
#line 115
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%-32s  %10lld bytes  %6.2f %s/s",
          localName, cip->bytesTransferred + cip->startPoint, rate, rStr);
#line 148
  tmp = strlen((char const   *)(line));
#line 148
  i___0 = (int )tmp;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i___0 < 78)) {
#line 148
      goto while_break;
    }
#line 149
    line[i___0] = (char )' ';
#line 148
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  line[i___0] = (char )'\000';
#line 153
  if (mode != 3) {
    {
#line 154
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s",
            line);
    }
  } else {
#line 161
    if (gIsAtty1 == 0) {
      {
#line 162
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s\n",
              line);
      }
    } else
#line 161
    if (gIsAtty2 == 0) {
      {
#line 162
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s\n",
              line);
      }
    } else {
      {
#line 164
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s\r",
              line);
      }
    }
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            line);
#line 168
    fflush(stderr);
    }
  }
#line 170
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___0  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uTotal  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___0  ;
#line 177 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
void PrStatBar(FTPCIPtr const   cip , int mode ) 
{ 
  double rate ;
  double done ;
  int secLeft ;
  int minLeft ;
  char const   *rStr ;
  char const   *stall ;
  char localName[80] ;
  char line[128] ;
  int i___0 ;
  size_t tmp ;

  {
  {
#line 191
  if (mode == 1) {
#line 191
    goto case_1;
  }
#line 210
  if (mode == 2) {
#line 210
    goto case_2;
  }
#line 252
  if (mode == 3) {
#line 252
    goto case_3;
  }
#line 190
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 192
  fflush(stderr);
  }
#line 193
  if (cip->expectedSize == -1LL) {
    {
#line 194
    cip->progress = & PrSizeAndRateMeter;
#line 195
    PrSizeAndRateMeter(cip, mode);
    }
#line 196
    return;
  }
  {
#line 198
  uTotal = FileSize((double )cip->expectedSize, & uStr___0, & uMult___0);
  }
#line 200
  if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 201
    localName[0] = (char )'\000';
  } else {
    {
#line 204
    AbbrevStr(localName, cip->lname, sizeof(localName) - 2UL, 0);
#line 205
    Strncat((char */* const  */)(localName), (char const   */* const  */)":", (size_t const   )sizeof(localName));
    }
  }
  {
#line 207
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-32s",
          localName);
  }
#line 208
  goto switch_break;
  case_2: /* CIL Label */ 
#line 211
  secLeft = (int )(cip->secLeft + 0.5);
#line 212
  minLeft = secLeft / 60;
#line 213
  secLeft -= minLeft * 60;
#line 214
  if (minLeft > 999) {
#line 215
    minLeft = 999;
#line 216
    secLeft = 59;
  }
  {
#line 219
  rate = FileSize(cip->kBytesPerSec * 1024.0, & rStr, (double *)((void *)0));
#line 220
  done = (double )(cip->bytesTransferred + cip->startPoint) / uMult___0;
  }
#line 222
  if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 223
    localName[0] = (char )'\000';
  } else {
    {
#line 225
    AbbrevStr(localName, cip->lname, (size_t )31, 0);
#line 226
    Strncat((char */* const  */)(localName), (char const   */* const  */)":", (size_t const   )sizeof(localName));
    }
  }
#line 229
  if (cip->stalled < 2) {
#line 230
    stall = " ";
  } else
#line 231
  if (cip->stalled < 15) {
#line 232
    stall = "-";
  } else {
#line 234
    stall = "=";
  }
  {
#line 236
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%-32s   ETA: %3d:%02d  %6.2f/%6.2f %-2.2s  %6.2f %.2s/s %.1s",
          localName, minLeft, secLeft, done, uTotal, uStr___0, rate, rStr, stall);
#line 249
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s",
          line);
  }
#line 250
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 254
  rate = FileSize(cip->kBytesPerSec * 1024.0, & rStr, (double *)((void *)0));
#line 255
  done = (double )(cip->bytesTransferred + cip->startPoint) / uMult___0;
  }
#line 257
  if (cip->expectedSize >= cip->bytesTransferred + cip->startPoint) {
#line 258
    if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 259
      localName[0] = (char )'\000';
    } else {
      {
#line 261
      AbbrevStr(localName, cip->lname, (size_t )52, 0);
#line 262
      Strncat((char */* const  */)(localName), (char const   */* const  */)":", (size_t const   )sizeof(localName));
      }
    }
    {
#line 265
    sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%-53s  %6.2f %-2.2s  %6.2f %.2s/s  ",
            localName, uTotal, uStr___0, rate, rStr);
    }
  } else {
#line 273
    if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 274
      localName[0] = (char )'\000';
    } else {
      {
#line 276
      AbbrevStr(localName, cip->lname, (size_t )45, 0);
#line 277
      Strncat((char */* const  */)(localName), (char const   */* const  */)":", (size_t const   )sizeof(localName));
      }
    }
    {
#line 280
    sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%-46s  %6.2f/%6.2f %-2.2s  %6.2f %.2s/s  ",
            localName, done, uTotal, uStr___0, rate, rStr);
    }
  }
  {
#line 294
  tmp = strlen((char const   *)(line));
#line 294
  i___0 = (int )tmp;
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i___0 < 78)) {
#line 294
      goto while_break;
    }
#line 295
    line[i___0] = (char )' ';
#line 294
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  line[i___0] = (char )'\000';
#line 303
  if (gIsAtty1 == 0) {
    {
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s\n",
            line);
    }
  } else
#line 303
  if (gIsAtty2 == 0) {
    {
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s\n",
            line);
    }
  } else {
    {
#line 306
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%s\r",
            line);
    }
  }
  {
#line 309
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          line);
#line 310
  fflush(stderr);
  }
#line 311
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 313
  return;
}
}
#line 317 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
int ReadConfigFromBookmark(char const   * const  bmname , FTPCIPtr cip ) 
{ 
  Bookmark bm ;
  int rc ;
  int *tmp ;

  {
  {
#line 323
  gBookmarkMatchMode = 0;
#line 324
  memset((void *)(& gBm), 0, sizeof(gBm));
#line 325
  rc = GetBookmark(bmname, & bm);
  }
#line 325
  if (rc >= 0) {
    {
#line 326
    gLoadedBm = 1;
#line 327
    Strncpy((char */* const  */)(cip->host), (char const   */* const  */)(bm.name),
            (size_t const   )sizeof(cip->host));
#line 328
    Strncpy((char */* const  */)(cip->user), (char const   */* const  */)(bm.user),
            (size_t const   )sizeof(cip->user));
#line 329
    Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)(bm.pass),
            (size_t const   )sizeof(cip->pass));
#line 330
    Strncpy((char */* const  */)(cip->acct), (char const   */* const  */)(bm.acct),
            (size_t const   )sizeof(cip->acct));
#line 331
    cip->port = bm.port;
#line 332
    memcpy((void */* __restrict  */)(& gBm), (void const   */* __restrict  */)(& bm),
           sizeof(gBm));
    }
#line 333
    return (2);
  }
  {
#line 335
  tmp = __errno_location();
#line 335
  *tmp = 2;
  }
#line 336
  return (-1);
}
}
#line 342 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
int ReadConfigFile(char const   *fn0 , FTPCIPtr cip ) 
{ 
  FILE *fp ;
  char line[128] ;
  char fn[128] ;
  char *cp ;
  int goodfile ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 348
  goodfile = 0;
#line 350
  Strncpy((char */* const  */)(fn), (char const   */* const  */)fn0, (size_t const   )sizeof(fn));
  }
#line 352
  if ((int )fn[0] == 0) {
#line 353
    fp = stdin;
  } else {
    {
#line 352
    tmp___0 = strcmp((char const   *)(fn), "-");
    }
#line 352
    if (tmp___0 == 0) {
#line 353
      fp = stdin;
    } else {
      {
#line 355
      fp = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
      }
#line 356
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
#line 357
        tmp = ReadConfigFromBookmark((char const   */* const  */)(fn), cip);
        }
#line 357
        if (tmp == 2) {
#line 358
          return (2);
        }
        {
#line 361
        fp = fopen((char const   */* __restrict  */)(fn), (char const   */* __restrict  */)"r");
        }
#line 362
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 363
          return (-1);
        }
      }
    }
  }
#line 368
  line[sizeof(line) - 1UL] = (char )'\000';
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 369
    tmp___16 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL),
                     (FILE */* __restrict  */)fp);
    }
#line 369
    if (! ((unsigned long )tmp___16 != (unsigned long )((void *)0))) {
#line 369
      goto while_break;
    }
#line 370
    if ((int )line[0] == 35) {
#line 371
      goto while_continue;
    } else {
      {
#line 370
      tmp___1 = __ctype_b_loc();
      }
#line 370
      if ((int const   )*(*tmp___1 + (int )line[0]) & 8192) {
#line 371
        goto while_continue;
      }
    }
    {
#line 372
    tmp___2 = strlen((char const   *)(line));
#line 372
    cp = (line + tmp___2) - 1;
    }
#line 373
    if ((int )*cp == 10) {
#line 374
      *cp = (char )'\000';
    }
    {
#line 375
    tmp___15 = strncmp((char const   *)(line), "username", (size_t )8);
    }
#line 375
    if (tmp___15 == 0) {
      {
#line 376
      Strncpy((char */* const  */)(cip->user), (char const   */* const  */)(line + 9),
              (size_t const   )sizeof(cip->user));
#line 377
      goodfile = 1;
      }
    } else {
      {
#line 378
      tmp___14 = strncmp((char const   *)(line), "user", (size_t )4);
      }
#line 378
      if (tmp___14 == 0) {
        {
#line 379
        Strncpy((char */* const  */)(cip->user), (char const   */* const  */)(line + 5),
                (size_t const   )sizeof(cip->user));
#line 380
        goodfile = 1;
        }
      } else {
        {
#line 381
        tmp___13 = strncmp((char const   *)(line), "login", (size_t )5);
        }
#line 381
        if (tmp___13 == 0) {
          {
#line 382
          Strncpy((char */* const  */)(cip->user), (char const   */* const  */)(line + 6),
                  (size_t const   )sizeof(cip->user));
#line 383
          goodfile = 1;
          }
        } else {
          {
#line 384
          tmp___12 = strncmp((char const   *)(line), "password", (size_t )8);
          }
#line 384
          if (tmp___12 == 0) {
            {
#line 385
            Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)(line + 9),
                    (size_t const   )sizeof(cip->pass));
            }
#line 386
            if ((int )cip->pass[0] == 0) {
#line 387
              cip->passIsEmpty = 1U;
            }
#line 388
            goodfile = 1;
          } else {
            {
#line 389
            tmp___10 = strncmp((char const   *)(line), "pass", (size_t )4);
            }
#line 389
            if (tmp___10 == 0) {
              {
#line 389
              tmp___11 = __ctype_b_loc();
              }
#line 389
              if ((int const   )*(*tmp___11 + (int )line[4]) & 8192) {
                {
#line 390
                Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)(line + 5),
                        (size_t const   )sizeof(cip->pass));
                }
#line 391
                if ((int )cip->pass[0] == 0) {
#line 392
                  cip->passIsEmpty = 1U;
                }
#line 393
                goodfile = 1;
              } else {
#line 389
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 394
              tmp___9 = strncmp((char const   *)(line), "host", (size_t )4);
              }
#line 394
              if (tmp___9 == 0) {
                {
#line 395
                Strncpy((char */* const  */)(cip->host), (char const   */* const  */)(line + 5),
                        (size_t const   )sizeof(cip->host));
#line 396
                goodfile = 1;
                }
              } else {
                {
#line 397
                tmp___8 = strncmp((char const   *)(line), "machine", (size_t )7);
                }
#line 397
                if (tmp___8 == 0) {
                  {
#line 398
                  Strncpy((char */* const  */)(cip->host), (char const   */* const  */)(line + 8),
                          (size_t const   )sizeof(cip->host));
#line 399
                  goodfile = 1;
                  }
                } else {
                  {
#line 400
                  tmp___6 = strncmp((char const   *)(line), "acct", (size_t )4);
                  }
#line 400
                  if (tmp___6 == 0) {
                    {
#line 400
                    tmp___7 = __ctype_b_loc();
                    }
#line 400
                    if ((int const   )*(*tmp___7 + (int )line[4]) & 8192) {
                      {
#line 401
                      Strncpy((char */* const  */)(cip->acct), (char const   */* const  */)(line + 5),
                              (size_t const   )sizeof(cip->acct));
                      }
                    } else {
#line 400
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    {
#line 402
                    tmp___5 = strncmp((char const   *)(line), "account", (size_t )7);
                    }
#line 402
                    if (tmp___5 == 0) {
                      {
#line 403
                      Strncpy((char */* const  */)(cip->acct), (char const   */* const  */)(line + 8),
                              (size_t const   )sizeof(cip->acct));
                      }
                    } else {
                      {
#line 404
                      tmp___4 = strncmp((char const   *)(line), "port", (size_t )4);
                      }
#line 404
                      if (tmp___4 == 0) {
                        {
#line 405
                        tmp___3 = atoi((char const   *)(line + 5));
#line 405
                        cip->port = (unsigned int )tmp___3;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 408
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 408
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
#line 409
      fclose(fp);
      }
    }
  }
#line 411
  if (goodfile == 0) {
    {
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s doesn\'t contain anything useful.\n",
            fn);
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A NcFTP host configuration file should look something like this:\n");
#line 414
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"# Comment lines starting with a hash character\n# and blank lines are ignored.\n\n");
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"host Bozo.probe.net\n");
#line 416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"user gleason\n");
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pass mypasswd\n");
    }
#line 418
    return (-1);
  }
#line 421
  return (1);
}
}
#line 427 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
void SetRedial(FTPCIPtr const   cip , char const   * const  argstr ) 
{ 
  char buf[256] ;
  char *tok ;
  char *parse ;
  int nt ;
  int i___0 ;
  int tmp ;

  {
  {
#line 433
  nt = 0;
#line 436
  Strncpy((char */* const  */)(buf), argstr, (size_t const   )sizeof(buf));
#line 437
  parse = buf;
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 437
    tok = strtok((char */* __restrict  */)parse, (char const   */* __restrict  */)", \n\t\r");
    }
#line 437
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 437
      goto while_break;
    }
#line 438
    nt ++;
#line 439
    if (nt == 1) {
      {
#line 440
      tmp = strcmp((char const   *)tok, "forever");
      }
#line 440
      if (tmp == 0) {
#line 441
        cip->maxDials = -1;
      } else {
        {
#line 443
        i___0 = atoi((char const   *)tok);
        }
#line 444
        if (i___0 == 0) {
#line 445
          cip->maxDials = 1;
        } else {
#line 447
          cip->maxDials = i___0;
        }
      }
    } else
#line 449
    if (nt == 2) {
      {
#line 450
      i___0 = atoi((char const   *)tok);
      }
#line 451
      if (i___0 < 2) {
#line 452
        i___0 = 2;
      }
#line 453
      cip->redialDelay = i___0;
    }
#line 437
    parse = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  return;
}
}
#line 460 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
void SetTimeouts(FTPCIPtr const   cip , char const   * const  argstr ) 
{ 
  char buf[256] ;
  char *tok ;
  char *parse ;
  int nt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 466
  nt = 0;
#line 468
  Strncpy((char */* const  */)(buf), argstr, (size_t const   )sizeof(buf));
#line 469
  parse = buf;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 469
    tok = strtok((char */* __restrict  */)parse, (char const   */* __restrict  */)", \n\t\r");
    }
#line 469
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 469
      goto while_break;
    }
#line 470
    nt ++;
#line 471
    if (nt == 1) {
      {
#line 472
      tmp = atoi((char const   *)tok);
#line 472
      cip->xferTimeout = (unsigned int )tmp;
#line 473
      tmp___0 = atoi((char const   *)tok);
#line 473
      cip->connTimeout = (unsigned int )tmp___0;
#line 474
      tmp___1 = atoi((char const   *)tok);
#line 474
      cip->ctrlTimeout = (unsigned int )tmp___1;
      }
    } else
#line 475
    if (nt == 2) {
      {
#line 476
      tmp___2 = atoi((char const   *)tok);
#line 476
      cip->connTimeout = (unsigned int )tmp___2;
      }
    } else
#line 477
    if (nt == 3) {
      {
#line 478
      tmp___3 = atoi((char const   *)tok);
#line 478
      cip->ctrlTimeout = (unsigned int )tmp___3;
      }
    }
#line 469
    parse = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  return;
}
}
#line 485 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
int GetDefaultProgressMeterSetting(void) 
{ 
  int progmeters ;
  __pid_t tmp___0 ;

  {
  {
#line 495
  gIsAtty1 = isatty(1);
#line 496
  gIsAtty2 = isatty(2);
#line 498
  tmp___0 = getppid();
  }
#line 498
  if (tmp___0 > 1) {
#line 498
    progmeters = 1;
  } else {
#line 498
    progmeters = 0;
  }
#line 500
  return (progmeters);
}
}
#line 505 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
FILE *OpenPager(void) 
{ 
  FILE *fp ;
  char const   *cp ;
  char *tmp ;

  {
  {
#line 515
  tmp = getenv("PAGER");
#line 515
  cp = (char const   *)tmp;
  }
#line 516
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 520
    cp = "more";
  }
  {
#line 522
  fp = popen(cp, "w");
  }
#line 523
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 524
    fp = stderr;
  }
#line 526
  return (fp);
}
}
#line 531 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
void ClosePager(FILE *fp ) 
{ 


  {
#line 533
  if ((unsigned long )fp == (unsigned long )stderr) {
#line 534
    return;
  } else
#line 533
  if ((unsigned long )fp == (unsigned long )stdout) {
#line 534
    return;
  }
  {
#line 537
  pclose(fp);
  }
#line 539
  return;
}
}
#line 542 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gUsrBinFTPCommands[25]  = 
#line 542
  {      "cd ..",      "cd",      "mkdir",      "md", 
        "rmdir",      "rm",      "del",      "delete", 
        "ascii",      "binary",      "bye",      "quit", 
        "exit",      "close",      "dir",      "ls", 
        "mls",      "chmod",      "chown",      "chgrp", 
        "pwd",      "quote",      "ln -s",      "umask", 
        (char const   *)((void *)0)};
#line 570 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gValidFTPProtocolCommands[25]  = 
#line 570
  {      "CDUP",      "CWD",      "MKD",      "MKD", 
        "RMD",      "DELE",      "DELE",      "DELE", 
        "TYPE A",      "TYPE I",      "QUIT",      "QUIT", 
        "QUIT",      "QUIT",      "STAT",      "STAT", 
        "MLST",      "SITE CHMOD",      "SITE CHOWN",      "SITE CHGRP", 
        "PWD",      "",      "SITE SYMLINK",      "SITE UMASK", 
        (char const   *)((void *)0)};
#line 598 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
int AdditionalCmd(FTPCIPtr const   cip , char const   * const  spec , char const   * const  arg ) 
{ 
  int i___0 ;
  int nospace ;
  int rc ;
  size_t skip ;
  char cmd[500] ;
  char *dst ;
  char *dlim ;
  char const   *src ;
  char const   *s2 ;
  char const   *repl ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 606
  rc = 0;
#line 607
  if ((unsigned long )spec != (unsigned long )((void *)0)) {
#line 607
    if ((int const   )*(spec + 0) != 0) {
      {
#line 608
      src = (char const   *)spec;
#line 609
      memset((void *)(cmd), 0, sizeof(cmd));
#line 610
      dlim = (cmd + sizeof(cmd)) - 1;
      }
      {
#line 611
      while (1) {
        while_continue: /* CIL Label */ ;
#line 611
        if (! *src) {
#line 611
          goto while_break;
        }
#line 612
        dst = cmd;
        {
#line 613
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 613
          if ((int const   )*src != 0) {
            {
#line 613
            tmp = __ctype_b_loc();
            }
#line 613
            if (! ((int const   )*(*tmp + (int )*src) & 8192)) {
#line 613
              goto while_break___0;
            }
          } else {
#line 613
            goto while_break___0;
          }
#line 614
          src ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 615
        i___0 = 0;
#line 615
        repl = (char const   *)((void *)0);
#line 615
        skip = (size_t )0;
        {
#line 615
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 615
          if (! ((unsigned long )gUsrBinFTPCommands[i___0] != (unsigned long )((void *)0))) {
#line 615
            goto while_break___1;
          }
          {
#line 616
          tmp___0 = strlen(gUsrBinFTPCommands[i___0]);
#line 616
          tmp___1 = strncasecmp(src, gUsrBinFTPCommands[i___0], tmp___0);
          }
#line 616
          if (tmp___1 == 0) {
            {
#line 617
            repl = gValidFTPProtocolCommands[i___0];
#line 618
            skip = strlen(gUsrBinFTPCommands[i___0]);
            }
#line 619
            goto while_break___1;
          }
#line 615
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 622
        if (skip != 0UL) {
#line 623
          if ((int const   )*(src + skip) == 0) {
#line 624
            src += skip;
          } else {
            {
#line 623
            tmp___2 = __ctype_b_loc();
            }
#line 623
            if ((int const   )*(*tmp___2 + (int )*(src + skip)) & 8192) {
#line 624
              src += skip;
            } else {
#line 629
              repl = (char const   *)((void *)0);
            }
          }
        }
#line 632
        if ((unsigned long )repl != (unsigned long )((void *)0)) {
#line 633
          if ((int const   )*repl == 0) {
#line 633
            nospace = 1;
          } else {
#line 633
            nospace = 0;
          }
#line 634
          s2 = repl;
          {
#line 634
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 634
            if (! ((int const   )*s2 != 0)) {
#line 634
              goto while_break___2;
            }
#line 635
            if ((unsigned long )dst < (unsigned long )dlim) {
#line 636
              tmp___3 = dst;
#line 636
              dst ++;
#line 636
              *tmp___3 = (char )*s2;
            }
#line 634
            s2 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 638
          if ((int const   )*src != 0) {
            {
#line 638
            tmp___6 = __ctype_b_loc();
            }
#line 638
            if ((int const   )*(*tmp___6 + (int )*src) & 8192) {
#line 639
              if (nospace == 0) {
#line 639
                if ((unsigned long )dst < (unsigned long )dlim) {
#line 640
                  tmp___4 = dst;
#line 640
                  dst ++;
#line 640
                  *tmp___4 = (char )' ';
                }
              }
              {
#line 641
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 641
                if ((int const   )*src != 0) {
                  {
#line 641
                  tmp___5 = __ctype_b_loc();
                  }
#line 641
                  if (! ((int const   )*(*tmp___5 + (int )*src) & 8192)) {
#line 641
                    goto while_break___3;
                  }
                } else {
#line 641
                  goto while_break___3;
                }
#line 642
                src ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 645
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 645
          if (! ((int const   )*src != 0)) {
#line 645
            goto while_break___4;
          }
#line 646
          if ((int const   )*src == 37) {
#line 646
            if ((int const   )*(src + 1) == 115) {
#line 647
              s2 = (char const   *)arg;
              {
#line 647
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 647
                if (! ((int const   )*s2 != 0)) {
#line 647
                  goto while_break___5;
                }
#line 648
                if ((unsigned long )dst < (unsigned long )dlim) {
#line 649
                  tmp___7 = dst;
#line 649
                  dst ++;
#line 649
                  *tmp___7 = (char )*s2;
                }
#line 647
                s2 ++;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 651
              src ++;
            } else {
#line 646
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 652
          if ((int const   )*src == 10) {
#line 653
            src ++;
#line 654
            goto while_break___4;
          } else
#line 655
          if ((int const   )*src != 13) {
#line 656
            tmp___8 = dst;
#line 656
            dst ++;
#line 656
            *tmp___8 = (char )*src;
          }
#line 645
          src ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 659
        *dst = (char )'\000';
#line 661
        if ((int )cmd[0] != 0) {
          {
#line 662
          rc = FTPCmd(cip, (char const   */* const  */)"%s", cmd);
          }
#line 663
          if (rc != 2) {
#line 664
            rc = -1;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 668
  return (rc);
}
}
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/version.c"
char const   gVersion[43]  = 
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/version.c"
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )' ',      (char const   )'N',      (char const   )'c',      (char const   )'F', 
        (char const   )'T',      (char const   )'P',      (char const   )' ',      (char const   )'3', 
        (char const   )'.',      (char const   )'2',      (char const   )'.',      (char const   )'5', 
        (char const   )'/',      (char const   )'4',      (char const   )'7',      (char const   )'4', 
        (char const   )' ',      (char const   )'F',      (char const   )'e',      (char const   )'b', 
        (char const   )' ',      (char const   )'0',      (char const   )'2',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'1',      (char const   )'1', 
        (char const   )',',      (char const   )' ',      (char const   )'0',      (char const   )'5', 
        (char const   )':',      (char const   )'1',      (char const   )'3',      (char const   )' ', 
        (char const   )'P',      (char const   )'M',      (char const   )'\000'};
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/version.c"
char const   gOS[23]  = 
#line 14
  {      (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'u', 
        (char const   )'x',      (char const   )'-',      (char const   )'x',      (char const   )'8', 
        (char const   )'6',      (char const   )'_',      (char const   )'6',      (char const   )'4', 
        (char const   )'-',      (char const   )'g',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )'c',      (char const   )'2',      (char const   )'.', 
        (char const   )'1',      (char const   )'9',      (char const   )'\000'};
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/version.c"
char const   gCopyright[68]  = 
#line 25
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'c',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'2',      (char const   )'-', 
        (char const   )'2',      (char const   )'0',      (char const   )'1',      (char const   )'1', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )' ', 
        (char const   )'M',      (char const   )'i',      (char const   )'k',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'l',      (char const   )'e', 
        (char const   )'a',      (char const   )'s',      (char const   )'o',      (char const   )'n', 
        (char const   )'.',      (char const   )'\n',      (char const   )'A',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )'s', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'r',      (char const   )'v',      (char const   )'e', 
        (char const   )'d',      (char const   )'.',      (char const   )'\n',      (char const   )'\000'};
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 952 "../libncftp/ncftp.h"
char *FGets(char *str , size_t size , FILE *fp ) ;
#line 46 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.h"
void BookmarkToURL(BookmarkPtr bmp , char *url , size_t urlsize ) ;
#line 47
void SetBookmarkDefaults(BookmarkPtr bmp ) ;
#line 48
int ParseHostLine(char *line , BookmarkPtr bmp ) ;
#line 49
void CloseBookmarkFile(FILE *fp ) ;
#line 50
FILE *OpenBookmarkFile(int *numBookmarks0 ) ;
#line 51
FILE *OpenTmpBookmarkFile(int nb ) ;
#line 52
int SaveBookmarkTable(void) ;
#line 53
int GetNextBookmark(FILE *fp , Bookmark *bmp ) ;
#line 55
int PutBookmark(Bookmark *bmp , int savePassword ) ;
#line 56
int LoadBookmarkTable(void) ;
#line 57
BookmarkPtr SearchBookmarkTable(char const   *key ) ;
#line 58
void SortBookmarks(void) ;
#line 59
void DefaultBookmarkName(char *dst , size_t siz , char *src ) ;
#line 60
void DisposeBookmarkTable(void) ;
#line 61
int AddNewItemToBookmarkTable(void) ;
#line 87 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.h"
void ToBase64(void *dst0 , void const   *src0 , size_t n , int terminate ) ;
#line 88
void FromBase64(void *dst0 , void const   *src0 , size_t n , int terminate ) ;
#line 97
char *OurDirectoryPath(char * const  dst , size_t const   siz , char const   * const  fname ) ;
#line 28 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int gLoadedBm  =    0;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int gBookmarkMatchMode  =    0;
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int gNumBookmarks  =    0;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
BookmarkPtr gBookmarkTable  =    (BookmarkPtr )((void *)0);
#line 33
char gOurDirectoryPath[260] ;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
void BookmarkToURL(BookmarkPtr bmp , char *url , size_t urlsize ) 
{ 
  char pbuf[32] ;

  {
  {
#line 47
  Strncpy((char */* const  */)url, (char const   */* const  */)"ftp://", (size_t const   )urlsize);
  }
#line 48
  if ((int )bmp->user[0] != 0) {
    {
#line 49
    Strncat((char */* const  */)url, (char const   */* const  */)(bmp->user), (size_t const   )urlsize);
    }
#line 50
    if ((int )bmp->pass[0] != 0) {
      {
#line 51
      Strncat((char */* const  */)url, (char const   */* const  */)":", (size_t const   )urlsize);
#line 52
      Strncat((char */* const  */)url, (char const   */* const  */)"PASSWORD", (size_t const   )urlsize);
      }
    }
    {
#line 54
    Strncat((char */* const  */)url, (char const   */* const  */)"@", (size_t const   )urlsize);
    }
  }
  {
#line 56
  Strncat((char */* const  */)url, (char const   */* const  */)(bmp->name), (size_t const   )urlsize);
  }
#line 57
  if (bmp->port != 21U) {
    {
#line 58
    sprintf((char */* __restrict  */)(pbuf), (char const   */* __restrict  */)":%u",
            bmp->port);
#line 59
    Strncat((char */* const  */)url, (char const   */* const  */)(pbuf), (size_t const   )urlsize);
    }
  }
#line 61
  if ((int )bmp->dir[0] == 47) {
    {
#line 63
    Strncat((char */* const  */)url, (char const   */* const  */)"/%2F", (size_t const   )urlsize);
#line 64
    Strncat((char */* const  */)url, (char const   */* const  */)(bmp->dir + 1), (size_t const   )urlsize);
#line 65
    Strncat((char */* const  */)url, (char const   */* const  */)"/", (size_t const   )urlsize);
    }
  } else
#line 66
  if ((int )bmp->dir[0] != 0) {
    {
#line 67
    Strncat((char */* const  */)url, (char const   */* const  */)"/", (size_t const   )urlsize);
#line 68
    Strncat((char */* const  */)url, (char const   */* const  */)(bmp->dir), (size_t const   )urlsize);
#line 69
    Strncat((char */* const  */)url, (char const   */* const  */)"/", (size_t const   )urlsize);
    }
  }
#line 71
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
void SetBookmarkDefaults(BookmarkPtr bmp ) 
{ 


  {
  {
#line 79
  memset((void *)bmp, 0, sizeof(Bookmark ));
#line 81
  bmp->xferType = 'I';
#line 82
  bmp->xferMode = 'S';
#line 83
  bmp->hasSIZE = -1;
#line 84
  bmp->hasMDTM = -1;
#line 85
  bmp->hasUTIME = -1;
#line 86
  bmp->hasPASV = -1;
#line 87
  bmp->isUnix = 1;
#line 88
  bmp->lastCall = (time_t )0;
#line 89
  bmp->deleted = 0;
  }
#line 90
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int HexCharToNibble(int c ) 
{ 


  {
  {
#line 109
  if (c == 57) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 56) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 55) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 54) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 53) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 52) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 51) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 50) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 49) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 48) {
#line 109
    goto case_57;
  }
#line 116
  if (c == 102) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 101) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 100) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 99) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 98) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 97) {
#line 116
    goto case_102;
  }
#line 123
  if (c == 70) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 69) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 68) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 67) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 66) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 65) {
#line 123
    goto case_70;
  }
#line 99
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 110
  return (c - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 117
  return ((c - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 124
  return ((c - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
#line 127
  return (-1);
}
}
#line 137 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int ParseHostLine(char *line , BookmarkPtr bmp ) 
{ 
  char token[128] ;
  char pass[128] ;
  char *s ;
  char *d ;
  char *tokenend ;
  long L ;
  int i___0 ;
  int result ;
  int n ;
  int n1 ;
  int n2 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 149
  SetBookmarkDefaults(bmp);
#line 150
  s = line;
#line 151
  tokenend = token;
#line 152
  tokenend += sizeof(token);
#line 153
  tokenend --;
#line 154
  result = -1;
#line 155
  i___0 = 1;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if ((int )*s == 0) {
#line 157
      goto while_break;
    }
#line 163
    d = token;
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! ((int )*s != 0)) {
#line 163
        goto while_break___0;
      }
#line 164
      if ((int )*s == 92) {
#line 164
        if ((int )*(s + 1) != 0) {
#line 165
          if ((unsigned long )d < (unsigned long )tokenend) {
#line 166
            tmp = d;
#line 166
            d ++;
#line 166
            *tmp = *(s + 1);
          }
#line 167
          s += 2;
        } else {
#line 164
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 168
      if ((int )*s == 44) {
#line 169
        s ++;
#line 170
        goto while_break___0;
      } else
#line 171
      if ((int )*s == 36) {
#line 171
        if ((int )*(s + 1) != 0) {
#line 171
          if ((int )*(s + 2) != 0) {
            {
#line 172
            n1 = HexCharToNibble((int )*(s + 1));
#line 173
            n2 = HexCharToNibble((int )*(s + 2));
            }
#line 174
            if (n1 >= 0) {
#line 174
              if (n2 >= 0) {
#line 175
                n = (n1 << 4) | n2;
#line 176
                if ((unsigned long )d < (unsigned long )tokenend) {
#line 177
                  tmp___0 = d;
#line 177
                  d ++;
#line 177
                  *((unsigned char *)tmp___0) = (unsigned char )n;
                }
              }
            }
#line 179
            s += 3;
          } else {
#line 171
            goto _L___0;
          }
        } else {
#line 171
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 181
        if ((unsigned long )d < (unsigned long )tokenend) {
#line 182
          tmp___1 = d;
#line 182
          d ++;
#line 182
          *tmp___1 = *s;
        }
#line 183
        s ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    *d = (char )'\000';
    {
#line 188
    if (i___0 == 1) {
#line 188
      goto case_1;
    }
#line 189
    if (i___0 == 2) {
#line 189
      goto case_2;
    }
#line 190
    if (i___0 == 3) {
#line 190
      goto case_3;
    }
#line 191
    if (i___0 == 4) {
#line 191
      goto case_4;
    }
#line 192
    if (i___0 == 5) {
#line 192
      goto case_5;
    }
#line 193
    if (i___0 == 6) {
#line 193
      goto case_6;
    }
#line 196
    if (i___0 == 7) {
#line 196
      goto case_7;
    }
#line 200
    if (i___0 == 8) {
#line 200
      goto case_8;
    }
#line 207
    if (i___0 == 9) {
#line 207
      goto case_9;
    }
#line 211
    if (i___0 == 10) {
#line 211
      goto case_10;
    }
#line 212
    if (i___0 == 11) {
#line 212
      goto case_11;
    }
#line 213
    if (i___0 == 12) {
#line 213
      goto case_12;
    }
#line 214
    if (i___0 == 13) {
#line 214
      goto case_13;
    }
#line 217
    if (i___0 == 14) {
#line 217
      goto case_14;
    }
#line 218
    if (i___0 == 15) {
#line 218
      goto case_15;
    }
#line 222
    if (i___0 == 19) {
#line 222
      goto case_19;
    }
#line 222
    if (i___0 == 18) {
#line 222
      goto case_19;
    }
#line 222
    if (i___0 == 17) {
#line 222
      goto case_19;
    }
#line 222
    if (i___0 == 16) {
#line 222
      goto case_19;
    }
#line 224
    if (i___0 == 20) {
#line 224
      goto case_20;
    }
#line 227
    if (i___0 == 21) {
#line 227
      goto case_21;
    }
#line 229
    if (i___0 == 22) {
#line 229
      goto case_22;
    }
#line 232
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 188
    Strncpy((char */* const  */)(bmp->bookmarkName), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->bookmarkName));
    }
#line 188
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 189
    Strncpy((char */* const  */)(bmp->name), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->name));
    }
#line 189
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 190
    Strncpy((char */* const  */)(bmp->user), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->user));
    }
#line 190
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 191
    Strncpy((char */* const  */)(bmp->pass), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->pass));
    }
#line 191
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 192
    Strncpy((char */* const  */)(bmp->acct), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->acct));
    }
#line 192
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 193
    Strncpy((char */* const  */)(bmp->dir), (char const   */* const  */)(token), (size_t const   )sizeof(bmp->dir));
#line 194
    result = 0;
    }
#line 195
    goto switch_break;
    case_7: /* CIL Label */ 
#line 197
    if ((int )token[0] != 0) {
#line 198
      bmp->xferType = (int )token[0];
    }
#line 199
    goto switch_break;
    case_8: /* CIL Label */ 
#line 202
    if ((int )token[0] == 0) {
#line 203
      bmp->port = 21U;
    } else {
      {
#line 205
      tmp___2 = atoi((char const   *)(token));
#line 205
      bmp->port = (unsigned int )tmp___2;
      }
    }
#line 206
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 208
    sscanf((char const   */* __restrict  */)(token), (char const   */* __restrict  */)"%lx",
           & L);
#line 209
    bmp->lastCall = L;
    }
#line 210
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 211
    bmp->hasSIZE = atoi((char const   *)(token));
    }
#line 211
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 212
    bmp->hasMDTM = atoi((char const   *)(token));
    }
#line 212
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 213
    bmp->hasPASV = atoi((char const   *)(token));
    }
#line 213
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 214
    bmp->isUnix = atoi((char const   *)(token));
#line 215
    result = 3;
    }
#line 216
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 217
    Strncpy((char */* const  */)(bmp->lastIP), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->lastIP));
    }
#line 217
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 218
    Strncpy((char */* const  */)(bmp->comment), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->comment));
    }
#line 218
    goto switch_break;
    case_19: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 223
    goto switch_break;
    case_20: /* CIL Label */ 
#line 224
    bmp->xferMode = (int )token[0];
#line 225
    result = 7;
#line 226
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 227
    bmp->hasUTIME = atoi((char const   *)(token));
    }
#line 228
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 229
    Strncpy((char */* const  */)(bmp->ldir), (char const   */* const  */)(token),
            (size_t const   )sizeof(bmp->ldir));
#line 230
    result = 8;
    }
#line 231
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 233
    result = 99;
#line 234
    goto done;
    switch_break: /* CIL Label */ ;
    }
#line 155
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 240
  tmp___4 = strncmp((char const   *)(bmp->pass), "*encoded*", (size_t )9);
  }
#line 240
  if (tmp___4 == 0) {
    {
#line 241
    tmp___3 = strlen((char const   *)(bmp->pass + 9));
#line 241
    FromBase64((void *)(pass), (void const   *)(bmp->pass + 9), tmp___3, 1);
#line 242
    Strncpy((char */* const  */)(bmp->pass), (char const   */* const  */)(pass), (size_t const   )sizeof(bmp->pass));
    }
  }
#line 244
  return (result);
}
}
#line 250 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
void CloseBookmarkFile(FILE *fp ) 
{ 


  {
#line 253
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 254
    fclose(fp);
    }
  }
#line 255
  return;
}
}
#line 261 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int GetNextBookmark(FILE *fp , Bookmark *bmp ) 
{ 
  char line[512] ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    tmp___0 = FGets(line, sizeof(line), fp);
    }
#line 266
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 266
      goto while_break;
    }
    {
#line 267
    tmp = ParseHostLine(line, bmp);
    }
#line 267
    if (tmp >= 0) {
#line 268
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return (-1);
}
}
#line 279 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
FILE *OpenBookmarkFile(int *numBookmarks0 ) 
{ 
  char pathName[256] ;
  char path2[256] ;
  char line[256] ;
  FILE *fp ;
  int version ;
  int numBookmarks ;
  Bookmark junkbm ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 289
  if ((int )gOurDirectoryPath[0] == 0) {
#line 290
    return ((FILE *)((void *)0));
  }
  {
#line 291
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks");
#line 292
  fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
  }
#line 293
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 295
    OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2),
                     (char const   */* const  */)"hosts");
#line 296
    tmp = rename((char const   *)(path2), (char const   *)(pathName));
    }
#line 296
    if (tmp == 0) {
      {
#line 298
      fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
      }
#line 299
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 300
        return ((FILE *)((void *)0));
      }
    }
#line 302
    return ((FILE *)((void *)0));
  }
  {
#line 307
  chmod((char const   *)(pathName), (__mode_t )384);
#line 309
  tmp___0 = FGets(line, sizeof(line), fp);
  }
#line 309
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid format.\n",
            pathName);
#line 311
    fclose(fp);
    }
#line 312
    return ((FILE *)((void *)0));
  }
  {
#line 318
  version = -1;
#line 319
  sscanf((char const   */* __restrict  */)(line), (char const   */* __restrict  */)"%*s %*s %*s %d",
         & version);
  }
#line 320
  if (version < 3) {
#line 321
    if (version < 0) {
      {
#line 322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid format, or bad version.\n",
              pathName);
#line 323
      fclose(fp);
      }
#line 324
      return ((FILE *)((void *)0));
    }
    {
#line 326
    Strncpy((char */* const  */)(path2), (char const   */* const  */)(pathName), (size_t const   )sizeof(path2));
#line 327
    sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)".v%d",
            version);
#line 328
    Strncat((char */* const  */)(path2), (char const   */* const  */)(line), (size_t const   )sizeof(path2));
#line 329
    rename((char const   *)(pathName), (char const   *)(path2));
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: old version.\n",
            pathName);
#line 331
    fclose(fp);
    }
#line 332
    return ((FILE *)((void *)0));
  }
  {
#line 338
  numBookmarks = -1;
#line 343
  tmp___1 = FGets(line, sizeof(line), fp);
  }
#line 343
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 344
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid format.\n",
            pathName);
#line 345
    fclose(fp);
    }
#line 346
    return ((FILE *)((void *)0));
  }
#line 349
  if ((unsigned long )numBookmarks0 == (unsigned long )((int *)0)) {
#line 353
    return (fp);
  }
#line 359
  numBookmarks = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 360
    tmp___2 = GetNextBookmark(fp, & junkbm);
    }
#line 360
    if (tmp___2 < 0) {
#line 361
      goto while_break;
    }
#line 359
    numBookmarks ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 369
  CloseBookmarkFile(fp);
#line 370
  fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
  }
#line 371
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 372
    return ((FILE *)((void *)0));
  }
  {
#line 373
  tmp___3 = FGets(line, sizeof(line), fp);
  }
#line 373
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid format.\n",
            pathName);
#line 375
    fclose(fp);
    }
#line 376
    return ((FILE *)((void *)0));
  }
  {
#line 379
  tmp___4 = FGets(line, sizeof(line), fp);
  }
#line 379
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
#line 380
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid format.\n",
            pathName);
#line 381
    fclose(fp);
    }
#line 382
    return ((FILE *)((void *)0));
  }
#line 386
  *numBookmarks0 = numBookmarks;
#line 387
  return (fp);
}
}
#line 394 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int GetBookmark(char const   * const  bmabbr , Bookmark *bmp ) 
{ 
  FILE *fp ;
  char line[512] ;
  Bookmark byHostName ;
  Bookmark byHostAbbr ;
  Bookmark byBmAbbr ;
  size_t byBmNameFlag ;
  size_t byBmAbbrFlag ;
  size_t byHostNameFlag ;
  size_t byHostAbbrFlag ;
  int result ;
  int exactMatch ;
  size_t bmabbrLen ;
  char *cp ;
  char bmabbrtrunc[sizeof(bmp->bookmarkName)] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 402
  byBmNameFlag = (size_t )0;
#line 403
  byBmAbbrFlag = (size_t )0;
#line 404
  byHostNameFlag = (size_t )0;
#line 405
  byHostAbbrFlag = (size_t )0;
#line 406
  result = -1;
#line 407
  exactMatch = 0;
#line 412
  fp = OpenBookmarkFile((int *)((void *)0));
  }
#line 413
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 414
    return (-1);
  }
  {
#line 416
  memset((void *)(& byHostName), 0, sizeof(Bookmark ));
#line 417
  memset((void *)(& byHostAbbr), 0, sizeof(Bookmark ));
#line 418
  memset((void *)(& byBmAbbr), 0, sizeof(Bookmark ));
#line 420
  Strncpy((char */* const  */)(bmabbrtrunc), bmabbr, (size_t const   )sizeof(bmabbrtrunc));
#line 421
  bmabbrLen = strlen((char const   *)bmabbr);
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 422
    tmp___6 = FGets(line, sizeof(line), fp);
    }
#line 422
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 422
      goto while_break;
    }
    {
#line 423
    tmp = ParseHostLine(line, bmp);
    }
#line 423
    if (tmp < 0) {
#line 424
      goto while_continue;
    }
    {
#line 425
    tmp___5 = strcasecmp((char const   *)(bmp->bookmarkName), (char const   *)(bmabbrtrunc));
    }
#line 425
    if (tmp___5 == 0) {
#line 427
      byBmNameFlag = bmabbrLen;
#line 428
      exactMatch = 1;
#line 429
      goto while_break;
    } else {
      {
#line 430
      tmp___4 = strncasecmp((char const   *)(bmp->bookmarkName), (char const   *)bmabbr,
                            bmabbrLen);
      }
#line 430
      if (tmp___4 == 0) {
#line 434
        byBmAbbr = *bmp;
#line 435
        byBmAbbrFlag = bmabbrLen;
      } else {
        {
#line 436
        tmp___3 = strcasecmp((char const   *)(bmp->name), (char const   *)bmabbr);
        }
#line 436
        if (tmp___3 == 0) {
#line 440
          byHostName = *bmp;
#line 441
          byHostNameFlag = bmabbrLen;
        } else {
          {
#line 442
          cp = strchr((char const   *)(bmp->name), '.');
          }
#line 442
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
            {
#line 444
            tmp___1 = strncasecmp((char const   *)(bmp->name), "ftp", (size_t )3);
            }
#line 444
            if (tmp___1 == 0) {
#line 445
              cp ++;
            } else {
              {
#line 446
              tmp___0 = strncasecmp((char const   *)(bmp->name), "www", (size_t )3);
              }
#line 446
              if (tmp___0 == 0) {
#line 447
                cp ++;
              } else {
#line 449
                cp = bmp->name;
              }
            }
            {
#line 451
            tmp___2 = strncasecmp((char const   *)cp, (char const   *)bmabbr, bmabbrLen);
            }
#line 451
            if (tmp___2 == 0) {
#line 455
              byHostAbbr = *bmp;
#line 456
              byHostAbbrFlag = bmabbrLen;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if (gBookmarkMatchMode == 0) {
#line 465
    if (exactMatch != 0) {
#line 466
      result = 0;
    }
  } else
#line 470
  if (byBmNameFlag != 0UL) {
#line 472
    result = 0;
  } else
#line 473
  if (byBmAbbrFlag != 0UL) {
#line 474
    result = 0;
#line 475
    *bmp = byBmAbbr;
  } else
#line 476
  if (byHostNameFlag != 0UL) {
#line 477
    result = 0;
#line 478
    *bmp = byHostName;
  } else
#line 479
  if (byHostAbbrFlag != 0UL) {
#line 480
    result = 0;
#line 481
    *bmp = byHostAbbr;
  }
#line 485
  if (result != 0) {
    {
#line 486
    memset((void *)bmp, 0, sizeof(Bookmark ));
    }
  }
  {
#line 488
  CloseBookmarkFile(fp);
  }
#line 489
  return (result);
}
}
#line 495 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSortProc(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = strcasecmp((char const   *)(((Bookmark const   *)a)->bookmarkName), (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 498
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSearchProc(void const   *key , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = strcasecmp((char const   *)key, (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 506
  return (tmp);
}
}
#line 511 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
BookmarkPtr SearchBookmarkTable(char const   *key ) 
{ 
  void *tmp ;

  {
  {
#line 514
  tmp = bsearch((void const   *)key, (void const   *)gBookmarkTable, (size_t )gNumBookmarks,
                sizeof(Bookmark ), & BookmarkSearchProc);
  }
#line 514
  return ((BookmarkPtr )tmp);
}
}
#line 520 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
void SortBookmarks(void) 
{ 


  {
#line 523
  if ((unsigned long )gBookmarkTable == (unsigned long )((void *)0)) {
#line 524
    return;
  } else
#line 523
  if (gNumBookmarks < 2) {
#line 524
    return;
  }
  {
#line 532
  qsort((void *)gBookmarkTable, (size_t )gNumBookmarks, sizeof(Bookmark ), & BookmarkSortProc);
  }
#line 533
  return;
}
}
#line 537 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int LoadBookmarkTable(void) 
{ 
  int i___0 ;
  int nb ;
  FILE *infp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 543
  infp = OpenBookmarkFile(& nb);
  }
#line 544
  if ((unsigned long )infp == (unsigned long )((void *)0)) {
#line 545
    nb = 0;
  }
#line 547
  if (nb != gNumBookmarks) {
#line 547
    if ((unsigned long )gBookmarkTable != (unsigned long )((void *)0)) {
      {
#line 549
      tmp = realloc((void *)gBookmarkTable, (size_t )(nb + 1) * sizeof(Bookmark ));
#line 549
      gBookmarkTable = (Bookmark *)tmp;
#line 550
      memset((void *)gBookmarkTable, 0, (unsigned long )(nb + 1) * sizeof(Bookmark ));
      }
    } else {
      {
#line 552
      tmp___0 = calloc((size_t )(nb + 1), sizeof(Bookmark ));
#line 552
      gBookmarkTable = (BookmarkPtr )tmp___0;
      }
    }
  } else {
    {
#line 552
    tmp___0 = calloc((size_t )(nb + 1), sizeof(Bookmark ));
#line 552
    gBookmarkTable = (BookmarkPtr )tmp___0;
    }
  }
#line 555
  if ((unsigned long )gBookmarkTable == (unsigned long )((void *)0)) {
    {
#line 556
    CloseBookmarkFile(infp);
    }
#line 557
    return (-1);
  }
#line 560
  i___0 = 0;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! (i___0 < nb)) {
#line 560
      goto while_break;
    }
    {
#line 561
    tmp___1 = GetNextBookmark(infp, gBookmarkTable + i___0);
    }
#line 561
    if (tmp___1 < 0) {
#line 562
      goto while_break;
    }
#line 560
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 565
  gNumBookmarks = i___0;
#line 567
  CloseBookmarkFile(infp);
#line 568
  SortBookmarks();
  }
#line 569
  return (0);
}
}
#line 578 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static char *BmEscapeTok(char *dst , size_t dsize , char *src ) 
{ 
  char *dlim ;
  char *dst0 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 581
  dlim = (dst + dsize) - 1;
#line 582
  dst0 = dst;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    c = (int )*src;
#line 585
    if (! (c != 0)) {
#line 585
      goto while_break;
    }
#line 586
    src ++;
#line 587
    if (c == 92) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 44) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 36) {
      _L: /* CIL Label */ 
#line 589
      if ((unsigned long )(dst + 1) < (unsigned long )dlim) {
#line 590
        tmp = dst;
#line 590
        dst ++;
#line 590
        *tmp = (char )'\\';
#line 591
        tmp___0 = dst;
#line 591
        dst ++;
#line 591
        *tmp___0 = (char )c;
      }
    } else {
      {
#line 593
      tmp___2 = __ctype_b_loc();
      }
#line 593
      if ((int const   )*(*tmp___2 + c) & 16384) {
#line 600
        if ((unsigned long )dst < (unsigned long )dlim) {
#line 601
          tmp___1 = dst;
#line 601
          dst ++;
#line 601
          *tmp___1 = (char )c;
        }
      } else
#line 595
      if ((unsigned long )(dst + 2) < (unsigned long )dlim) {
        {
#line 596
        sprintf((char */* __restrict  */)dst, (char const   */* __restrict  */)"$%02x",
                c);
#line 597
        dst += 3;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *dst = (char )'\000';
#line 605
  return (dst0);
}
}
#line 614 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int WriteBmLine(Bookmark *bmp , FILE *outfp , int savePassword ) 
{ 
  char tok[256] ;
  char pass[160] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 620
  tmp = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s",
                bmp->bookmarkName);
  }
#line 620
  if (tmp < 0) {
#line 620
    return (-1);
  }
  {
#line 621
  tmp___0 = BmEscapeTok(tok, sizeof(tok), bmp->name);
#line 621
  tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___0);
  }
#line 621
  if (tmp___1 < 0) {
#line 621
    return (-1);
  }
  {
#line 622
  tmp___2 = BmEscapeTok(tok, sizeof(tok), bmp->user);
#line 622
  tmp___3 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___2);
  }
#line 622
  if (tmp___3 < 0) {
#line 622
    return (-1);
  }
#line 623
  if ((int )bmp->pass[0] != 0) {
#line 623
    if (savePassword == 1) {
      {
#line 624
      memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
             (size_t )9);
#line 625
      tmp___4 = strlen((char const   *)(bmp->pass));
#line 625
      ToBase64((void *)(pass + 9), (void const   *)(bmp->pass), tmp___4, 1);
#line 626
      tmp___5 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                        pass);
      }
#line 626
      if (tmp___5 < 0) {
#line 626
        return (-1);
      }
    } else {
#line 623
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 628
    tmp___6 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                      "");
    }
#line 628
    if (tmp___6 < 0) {
#line 628
      return (-1);
    }
  }
  {
#line 630
  tmp___7 = BmEscapeTok(tok, sizeof(tok), bmp->acct);
#line 630
  tmp___8 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___7);
  }
#line 630
  if (tmp___8 < 0) {
#line 630
    return (-1);
  }
  {
#line 631
  tmp___9 = BmEscapeTok(tok, sizeof(tok), bmp->dir);
#line 631
  tmp___10 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___9);
  }
#line 631
  if (tmp___10 < 0) {
#line 631
    return (-1);
  }
  {
#line 632
  tmp___11 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferType);
  }
#line 632
  if (tmp___11 < 0) {
#line 632
    return (-1);
  }
  {
#line 633
  tmp___12 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%u",
                     bmp->port);
  }
#line 633
  if (tmp___12 < 0) {
#line 633
    return (-1);
  }
  {
#line 634
  tmp___13 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%lu",
                     (unsigned long )bmp->lastCall);
  }
#line 634
  if (tmp___13 < 0) {
#line 634
    return (-1);
  }
  {
#line 635
  tmp___14 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasSIZE);
  }
#line 635
  if (tmp___14 < 0) {
#line 635
    return (-1);
  }
  {
#line 636
  tmp___15 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasMDTM);
  }
#line 636
  if (tmp___15 < 0) {
#line 636
    return (-1);
  }
  {
#line 637
  tmp___16 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasPASV);
  }
#line 637
  if (tmp___16 < 0) {
#line 637
    return (-1);
  }
  {
#line 638
  tmp___17 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->isUnix);
  }
#line 638
  if (tmp___17 < 0) {
#line 638
    return (-1);
  }
  {
#line 639
  tmp___18 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     bmp->lastIP);
  }
#line 639
  if (tmp___18 < 0) {
#line 639
    return (-1);
  }
  {
#line 640
  tmp___19 = BmEscapeTok(tok, sizeof(tok), bmp->comment);
#line 640
  tmp___20 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___19);
  }
#line 640
  if (tmp___20 < 0) {
#line 640
    return (-1);
  }
  {
#line 641
  tmp___21 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 641
  if (tmp___21 < 0) {
#line 641
    return (-1);
  }
  {
#line 642
  tmp___22 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 642
  if (tmp___22 < 0) {
#line 642
    return (-1);
  }
  {
#line 643
  tmp___23 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 643
  if (tmp___23 < 0) {
#line 643
    return (-1);
  }
  {
#line 644
  tmp___24 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 644
  if (tmp___24 < 0) {
#line 644
    return (-1);
  }
  {
#line 645
  tmp___25 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferMode);
  }
#line 645
  if (tmp___25 < 0) {
#line 645
    return (-1);
  }
  {
#line 646
  tmp___26 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasUTIME);
  }
#line 646
  if (tmp___26 < 0) {
#line 646
    return (-1);
  }
  {
#line 647
  tmp___27 = BmEscapeTok(tok, sizeof(tok), bmp->ldir);
#line 647
  tmp___28 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___27);
  }
#line 647
  if (tmp___28 < 0) {
#line 647
    return (-1);
  }
  {
#line 648
  tmp___29 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n");
  }
#line 648
  if (tmp___29 < 0) {
#line 648
    return (-1);
  }
  {
#line 649
  tmp___30 = fflush(outfp);
  }
#line 649
  if (tmp___30 < 0) {
#line 649
    return (-1);
  }
#line 650
  return (0);
}
}
#line 655 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int SwapBookmarkFiles(void) 
{ 
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 661
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 662
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 666
  tmp = getpid();
#line 666
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 667
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 669
  remove((char const   *)(path2));
#line 670
  tmp___0 = rename((char const   *)(pathName), (char const   *)(path2));
  }
#line 670
  if (tmp___0 < 0) {
#line 671
    return (-1);
  }
#line 673
  return (0);
}
}
#line 682 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
FILE *OpenTmpBookmarkFile(int nb ) 
{ 
  FILE *outfp ;
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 689
  if ((int )gOurDirectoryPath[0] == 0) {
#line 690
    return ((FILE *)((void *)0));
  }
  {
#line 692
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 693
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 694
  tmp = getpid();
#line 694
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 695
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 697
  outfp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"w");
  }
#line 698
  if ((unsigned long )outfp == (unsigned long )((void *)0)) {
    {
#line 699
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 700
    perror((char const   *)(pathName));
    }
#line 701
    return ((FILE *)((void *)0));
  }
  {
#line 705
  chmod((char const   *)(pathName), (__mode_t )384);
  }
#line 707
  if (nb > 0) {
    {
#line 708
    tmp___0 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"NcFTP bookmark-file version: %d\nNumber of bookmarks: %d\n",
                      8, nb);
    }
#line 708
    if (tmp___0 < 0) {
      {
#line 709
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 710
      perror((char const   *)(pathName));
#line 711
      fclose(outfp);
      }
#line 712
      return ((FILE *)((void *)0));
    }
  } else {
    {
#line 715
    tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"NcFTP bookmark-file version: %d\nNumber of bookmarks: ??\n",
                      8);
    }
#line 715
    if (tmp___1 < 0) {
      {
#line 716
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 717
      perror((char const   *)(pathName));
#line 718
      fclose(outfp);
      }
#line 719
      return ((FILE *)((void *)0));
    }
  }
#line 723
  return (outfp);
}
}
#line 729 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int SaveBookmarkTable(void) 
{ 
  int i___0 ;
  FILE *outfp ;
  int nb ;
  int tmp ;
  int tmp___0 ;

  {
#line 736
  if (gNumBookmarks < 1) {
#line 737
    return (0);
  } else
#line 736
  if ((unsigned long )gBookmarkTable == (unsigned long )((void *)0)) {
#line 737
    return (0);
  }
#line 740
  i___0 = 0;
#line 740
  nb = 0;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (i___0 < gNumBookmarks)) {
#line 740
      goto while_break;
    }
#line 741
    if ((gBookmarkTable + i___0)->deleted == 0) {
#line 742
      nb ++;
    }
#line 740
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 744
  outfp = OpenTmpBookmarkFile(nb);
  }
#line 745
  if ((unsigned long )outfp == (unsigned long )((void *)0)) {
#line 746
    return (-1);
  }
#line 749
  i___0 = 0;
  {
#line 749
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 749
    if (! (i___0 < gNumBookmarks)) {
#line 749
      goto while_break___0;
    }
#line 750
    if ((gBookmarkTable + i___0)->deleted == 0) {
      {
#line 751
      tmp = WriteBmLine(gBookmarkTable + i___0, outfp, 1);
      }
#line 751
      if (tmp < 0) {
        {
#line 752
        CloseBookmarkFile(outfp);
        }
#line 753
        return (-1);
      }
    }
#line 749
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 757
  CloseBookmarkFile(outfp);
#line 758
  tmp___0 = SwapBookmarkFiles();
  }
#line 758
  if (tmp___0 < 0) {
#line 759
    return (-1);
  }
#line 761
  return (0);
}
}
#line 767 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int PutBookmark(Bookmark *bmp , int savePassword ) 
{ 
  FILE *infp ;
  FILE *outfp ;
  char line[256] ;
  char bmAbbr[64] ;
  int replaced ;
  size_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 773
  replaced = 0;
#line 776
  outfp = OpenTmpBookmarkFile(0);
  }
#line 777
  if ((unsigned long )outfp == (unsigned long )((void *)0)) {
#line 778
    return (-1);
  }
  {
#line 780
  Strncpy((char */* const  */)(bmAbbr), (char const   */* const  */)(bmp->bookmarkName),
          (size_t const   )sizeof(bmAbbr));
#line 781
  Strncat((char */* const  */)(bmAbbr), (char const   */* const  */)",", (size_t const   )sizeof(bmAbbr));
#line 782
  len = strlen((char const   *)(bmAbbr));
#line 785
  infp = OpenBookmarkFile((int *)((void *)0));
  }
#line 786
  if ((unsigned long )infp != (unsigned long )((void *)0)) {
    {
#line 787
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 787
      tmp___2 = FGets(line, sizeof(line), infp);
      }
#line 787
      if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 787
        goto while_break;
      }
      {
#line 788
      tmp___1 = strncmp((char const   *)(line), (char const   *)(bmAbbr), len);
      }
#line 788
      if (tmp___1 == 0) {
        {
#line 790
        tmp = WriteBmLine(bmp, outfp, savePassword);
        }
#line 790
        if (tmp < 0) {
          {
#line 791
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 792
          perror("reason");
#line 793
          fclose(outfp);
          }
        }
#line 795
        replaced = 1;
      } else {
        {
#line 797
        tmp___0 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s\n",
                          line);
        }
#line 797
        if (tmp___0 < 0) {
          {
#line 798
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 799
          perror("reason");
#line 800
          fclose(outfp);
          }
#line 801
          return (-1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 805
    CloseBookmarkFile(infp);
    }
  }
#line 808
  if (replaced == 0) {
    {
#line 810
    tmp___3 = WriteBmLine(bmp, outfp, savePassword);
    }
#line 810
    if (tmp___3 < 0) {
      {
#line 811
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 812
      perror("reason");
#line 813
      fclose(outfp);
      }
#line 814
      return (-1);
    }
  }
  {
#line 818
  tmp___4 = fclose(outfp);
  }
#line 818
  if (tmp___4 < 0) {
    {
#line 819
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
#line 820
    perror("reason");
    }
#line 821
    return (-1);
  }
  {
#line 824
  tmp___5 = SwapBookmarkFiles();
  }
#line 824
  if (tmp___5 < 0) {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not rename bookmark file.\n");
#line 826
    perror("reason");
    }
#line 827
    return (-1);
  }
#line 829
  return (0);
}
}
#line 836 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
void DefaultBookmarkName(char *dst , size_t siz , char *src ) 
{ 
  char str[128] ;
  char const   *token ;
  char const   *cp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 843
  Strncpy((char */* const  */)(str), (char const   */* const  */)src, (size_t const   )sizeof(str));
#line 849
  token = (char const   *)(str);
#line 850
  tmp___2 = strtok((char */* __restrict  */)(str), (char const   */* __restrict  */)".");
#line 850
  token = (char const   *)tmp___2;
  }
#line 850
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 851
    token = (char const   *)(str);
  } else {
    {
#line 852
    tmp___0 = strncasecmp(token, "ftp", (size_t )3);
    }
#line 852
    if (tmp___0 == 0) {
#line 852
      goto _L;
    } else {
      {
#line 852
      tmp___1 = strncasecmp(token, "www", (size_t )3);
      }
#line 852
      if (tmp___1 == 0) {
        _L: /* CIL Label */ 
        {
#line 853
        tmp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)".");
#line 853
        token = (char const   *)tmp;
        }
#line 853
        if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 854
          token = "";
        }
      }
    }
  }
#line 856
  cp = token;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if ((int const   )*cp == 0) {
#line 859
      token = "";
    }
    {
#line 861
    tmp___3 = __ctype_b_loc();
    }
#line 861
    if (! ((int const   )*(*tmp___3 + (int )*cp) & 2048)) {
#line 862
      goto while_break;
    }
#line 856
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 864
  Strncpy((char */* const  */)dst, (char const   */* const  */)token, (size_t const   )siz);
  }
#line 865
  return;
}
}
#line 870 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
int AddNewItemToBookmarkTable(void) 
{ 
  int nb ;
  BookmarkPtr newTable ;
  BookmarkPtr bmp ;
  void *tmp ;

  {
#line 876
  if ((unsigned long )gBookmarkTable == (unsigned long )((void *)0)) {
#line 877
    return (-1);
  }
  {
#line 879
  nb = gNumBookmarks + 1;
#line 881
  tmp = realloc((void *)gBookmarkTable, (size_t )nb * sizeof(Bookmark ));
#line 881
  newTable = (BookmarkPtr )tmp;
  }
#line 882
  if ((unsigned long )newTable == (unsigned long )((void *)0)) {
#line 883
    return (-1);
  }
  {
#line 885
  gBookmarkTable = newTable;
#line 886
  gNumBookmarks = nb;
#line 888
  bmp = newTable + (nb - 1);
#line 889
  SetBookmarkDefaults(bmp);
  }
#line 891
  return (nb - 1);
}
}
#line 897 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
void DisposeBookmarkTable(void) 
{ 


  {
#line 900
  if ((unsigned long )gBookmarkTable != (unsigned long )((void *)0)) {
    {
#line 901
    free((void *)gBookmarkTable);
#line 902
    gBookmarkTable = (BookmarkPtr )((void *)0);
    }
  }
#line 904
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_chdir3.c"
int FTPChdir3(FTPCIPtr cip , char const   * const  cdCwd , char * const  newCwd ,
              size_t const   newCwdSize , int flags___0 ) 
{ 
  char *cp ;
  char *startcp ;
  int result ;
  int lastSubDir ;
  int mkd ;
  int pwd ;
  int one ;
  int ful ;
  int chdir_err ;
  int did_chdir ;
  int did_mkdir ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 17
  result = -139;
#line 23
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 24
    return (-139);
  }
  {
#line 25
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 25
  if (tmp) {
#line 26
    return (-138);
  }
#line 28
  if ((unsigned long )cdCwd == (unsigned long )((void *)0)) {
#line 29
    result = -122;
#line 30
    cip->errNo = -122;
#line 31
    return (result);
  }
#line 37
  if ((flags___0 & 12) == 0) {
#line 38
    flags___0 |= 8;
  }
#line 40
  mkd = flags___0 & 1;
#line 41
  pwd = flags___0 & 2;
#line 42
  one = flags___0 & 4;
#line 43
  ful = flags___0 & 8;
#line 45
  chdir_err = 0;
#line 46
  if (ful != 0) {
#line 47
    did_chdir = 0;
#line 48
    did_mkdir = 0;
#line 49
    if (pwd != 0) {
      {
#line 50
      result = FTPChdirAndGetCWD((FTPCIPtr const   )cip, cdCwd, newCwd, newCwdSize);
      }
#line 51
      if (result == 0) {
#line 52
        did_chdir = 1;
      } else {
#line 54
        chdir_err = result;
      }
    } else {
      {
#line 57
      result = FTPChdir((FTPCIPtr const   )cip, cdCwd);
      }
#line 58
      if (result == 0) {
#line 59
        did_chdir = 1;
      } else {
#line 61
        chdir_err = result;
      }
    }
#line 64
    if (did_chdir == 0) {
#line 64
      if (mkd != 0) {
        {
#line 65
        result = FTPMkdir((FTPCIPtr const   )cip, cdCwd, (int const   )1);
        }
#line 66
        if (result == 0) {
#line 67
          did_mkdir = 1;
        }
      }
    }
#line 71
    if (did_mkdir != 0) {
#line 71
      if (pwd != 0) {
        {
#line 72
        result = FTPChdirAndGetCWD((FTPCIPtr const   )cip, cdCwd, newCwd, newCwdSize);
        }
#line 73
        if (result == 0) {
#line 74
          did_chdir = 1;
        } else {
#line 76
          chdir_err = result;
        }
      } else {
#line 71
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 78
    if (did_mkdir != 0) {
      {
#line 79
      result = FTPChdir((FTPCIPtr const   )cip, cdCwd);
      }
#line 80
      if (result == 0) {
#line 81
        did_chdir = 1;
      } else {
#line 83
        chdir_err = result;
      }
    }
#line 86
    if (did_chdir != 0) {
#line 87
      return (0);
    } else
#line 88
    if (one == 0) {
#line 92
      return (chdir_err);
    }
  }
#line 96
  if (one != 0) {
#line 97
    cp = cip->buf;
#line 98
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 99
      return (-139);
    } else
#line 98
    if (cip->bufSize <= 1UL) {
#line 99
      return (-139);
    }
    {
#line 100
    *(cp + (cip->bufSize - 1UL)) = (char )'\000';
#line 101
    Strncpy((char */* const  */)cip->buf, cdCwd, (size_t const   )cip->bufSize);
    }
#line 102
    if ((int )*(cp + (cip->bufSize - 1UL)) != 0) {
#line 103
      return (-139);
    }
#line 105
    if ((int const   )*(cdCwd + 0) == 0) {
#line 105
      goto _L___0;
    } else {
      {
#line 105
      tmp___0 = strcmp((char const   *)cdCwd, ".");
      }
#line 105
      if (tmp___0 == 0) {
        _L___0: /* CIL Label */ 
#line 106
        result = 0;
#line 107
        if (pwd != 0) {
          {
#line 108
          result = FTPGetCWD((FTPCIPtr const   )cip, newCwd, newCwdSize);
          }
        }
#line 109
        return (result);
      }
    }
#line 112
    lastSubDir = 0;
    {
#line 113
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 114
      startcp = cp;
#line 115
      cp = strchr((char const   *)cp, '/');
      }
#line 116
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 122
        tmp___1 = cp;
#line 122
        cp ++;
#line 122
        *tmp___1 = (char )'\000';
      } else {
#line 124
        lastSubDir = 1;
      }
      {
#line 126
      tmp___4 = strcmp((char const   *)startcp, ".");
      }
#line 126
      if (tmp___4 == 0) {
#line 127
        result = 0;
#line 128
        if (lastSubDir != 0) {
#line 128
          if (pwd != 0) {
            {
#line 129
            result = FTPGetCWD((FTPCIPtr const   )cip, newCwd, newCwdSize);
            }
          }
        }
      } else
#line 130
      if (lastSubDir != 0) {
#line 130
        if (pwd != 0) {
#line 131
          if ((int )*startcp != 0) {
#line 131
            tmp___2 = (char const   *)startcp;
          } else {
#line 131
            tmp___2 = "/";
          }
          {
#line 131
          result = FTPChdirAndGetCWD((FTPCIPtr const   )cip, (char const   */* const  */)tmp___2,
                                     newCwd, newCwdSize);
          }
        } else {
#line 130
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 133
        if ((int )*startcp != 0) {
#line 133
          tmp___3 = (char const   *)startcp;
        } else {
#line 133
          tmp___3 = "/";
        }
        {
#line 133
        result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)tmp___3);
        }
      }
#line 135
      if (result < 0) {
#line 136
        if (mkd != 0) {
#line 136
          if ((int )*startcp != 0) {
            {
#line 137
            tmp___5 = FTPCmd((FTPCIPtr const   )cip, (char const   */* const  */)"MKD %s",
                             startcp);
            }
#line 137
            if (tmp___5 == 2) {
#line 138
              if (pwd != 0) {
                {
#line 139
                result = FTPChdirAndGetCWD((FTPCIPtr const   )cip, (char const   */* const  */)startcp,
                                           newCwd, newCwdSize);
                }
              } else {
                {
#line 141
                result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)startcp);
                }
              }
            } else {
#line 145
              cip->errNo = result;
            }
          } else {
#line 148
            cip->errNo = result;
          }
        } else {
#line 148
          cip->errNo = result;
        }
      }
#line 113
      if (! lastSubDir) {
#line 113
        if (! (result == 0)) {
#line 113
          goto while_break;
        }
      } else {
#line 113
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 154
  return (result);
}
}
#line 73 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char const   *DStrCat(DStr * const  dst , char const   * const  src ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrCat.c"
char const   *DStrCat(DStr * const  dst , char const   * const  src ) 
{ 
  size_t srcLen ;
  size_t allocSize ;
  size_t newLen ;
  size_t curLen ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 12
  if (((long )dst->s & 1L) != 0L) {
#line 13
    return ((char const   *)((void *)0));
  } else
#line 12
  if ((dst->allocSize & 4278190095UL) != 0UL) {
#line 13
    return ((char const   *)((void *)0));
  } else
#line 12
  if ((dst->len & 4278190080UL) != 0UL) {
#line 13
    return ((char const   *)((void *)0));
  }
  {
#line 15
  tmp = strlen((char const   *)src);
#line 15
  srcLen = tmp + 1UL;
#line 16
  curLen = dst->len;
#line 17
  newLen = srcLen + curLen;
  }
#line 18
  if (newLen > 16777215UL) {
#line 19
    return ((char const   *)((void *)0));
  }
#line 20
  if (dst->allocSize < newLen) {
#line 22
    allocSize = (newLen + 16UL) & 4294967280UL;
#line 23
    if ((unsigned long )dst->s == (unsigned long )((void *)0)) {
      {
#line 24
      tmp___0 = calloc(allocSize, (size_t )1);
#line 24
      cp = (char *)tmp___0;
      }
#line 25
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 26
        return ((char const   *)((void *)0));
      }
    } else {
      {
#line 28
      tmp___1 = realloc((void *)dst->s, allocSize);
#line 28
      cp = (char *)tmp___1;
      }
#line 29
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 30
        return ((char const   *)((void *)0));
      }
      {
#line 31
      memset((void *)(cp + curLen), 0, allocSize - curLen);
      }
    }
#line 33
    dst->s = cp;
#line 34
    dst->allocSize = allocSize;
  } else {
#line 36
    cp = dst->s;
  }
  {
#line 39
  srcLen --;
#line 39
  memcpy((void */* __restrict  */)(cp + curLen), (void const   */* __restrict  */)src,
         srcLen);
#line 40
  dst->len = newLen - 1UL;
#line 41
  *(cp + (newLen - 1UL)) = (char )'\000';
  }
#line 42
  return ((char const   *)cp);
}
}
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 151
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 282 "../sio/sio.h"
void InetNtoA(char *dst , struct in_addr *ia , size_t siz ) ;
#line 884 "../libncftp/ncftp.h"
int FTPDecodeURL(FTPCIPtr const   cip , char * const  url , FTPLineListPtr cdlist ,
                 char * const  fn , size_t const   fnsize , int * const  xtype , int * const  wantnlst ) ;
#line 959
struct tm *Localtime(time_t t , struct tm * const  tp ) ;
#line 982
void (*NcSignal(int signum , void (*handler)(int  ) ))(int  ) ;
#line 1080
void PathCat(char * const  dst , size_t const   dsize , char const   * const  cwd ,
             char const   * const  src , int dosCompat ) ;
#line 62 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.h"
char const   *gNcFTP_Uses_Me_To_Quiet_Variable_Unused_Warnings ;
#line 89
void OutOfMemory(void) ;
#line 92
void MyInetAddr(char *dst , size_t siz , void *src , int i___0 ) ;
#line 93
char *FileToURL(char *url , size_t urlsize , char const   * const  fn , char const   * const  rcwd ,
                char const   * const  startdir , char const   * const  user , char const   * const  pass ,
                char const   * const  hname , unsigned int const   port ) ;
#line 94
char *TolowerStr(char *dst ) ;
#line 96
char *Path(char * const  dst , size_t const   siz , char const   * const  parent ,
           char const   * const  fname ) ;
#line 98
void InitOurDirectory(void) ;
#line 99
void InitUserInfo(void) ;
#line 100
int MayUseFirewall(char const   * const  hn0 , int firewallType , char const   * const  firewallExceptionList ) ;
#line 101
int StrToBool(char const   * const  s ) ;
#line 102
void AbsoluteToRelative(char * const  dst , size_t const   dsize , char const   * const  dir___3 ,
                        char const   * const  root , size_t const   rootlen ) ;
#line 103
int MyGetHostByName(char * const volatile  dst , size_t dsize , char const   * const  hn ,
                    int t ) ;
#line 104
time_t UnDate(char *dstr ) ;
#line 105
int DecodeDirectoryURL(FTPCIPtr const   cip , char *url , FTPLineListPtr cdlist ,
                       char *fn , size_t fnsize ) ;
#line 106
char *OurInstallationPath(char * const  dst , size_t const   siz , char const   * const  fname ) ;
#line 112
int strncoll(char const   *a , char const   *b , size_t n ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
uid_t gUid  ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char gUser[32]  ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char gHome[256]  ;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char gShell[256]  ;
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char gOurDirectoryPath[260]  ;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char gOurInstallationPath[260]  ;
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char const   *gNcFTP_Uses_Me_To_Quiet_Variable_Unused_Warnings  =    (char const   *)((void *)0);
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
sigjmp_buf gGetHostByNameJmp  ;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64EncodeTable[64]  = 
#line 38
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64DecodeTable[256]  = 
#line 50
  {      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'>', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'?', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'@',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\002', 
        (unsigned char const   )'\003',      (unsigned char const   )'\004',      (unsigned char const   )'\005',      (unsigned char const   )'\006', 
        (unsigned char const   )'\a',      (unsigned char const   )'\b',      (unsigned char const   )'\t',      (unsigned char const   )'\n', 
        (unsigned char const   )'\v',      (unsigned char const   )'\f',      (unsigned char const   )'\r',      (unsigned char const   )'\016', 
        (unsigned char const   )'\017',      (unsigned char const   )'\020',      (unsigned char const   )'\021',      (unsigned char const   )'\022', 
        (unsigned char const   )'\023',      (unsigned char const   )'\024',      (unsigned char const   )'\025',      (unsigned char const   )'\026', 
        (unsigned char const   )'\027',      (unsigned char const   )'\030',      (unsigned char const   )'\031',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\032',      (unsigned char const   )'\033',      (unsigned char const   )'\034', 
        (unsigned char const   )'\035',      (unsigned char const   )'\036',      (unsigned char const   )'\037',      (unsigned char const   )' ', 
        (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#',      (unsigned char const   )'$', 
        (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )'\'',      (unsigned char const   )'(', 
        (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+',      (unsigned char const   )',', 
        (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/',      (unsigned char const   )'0', 
        (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177'};
#line 86 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void ToBase64(void *dst0 , void const   *src0 , size_t n , int terminate ) 
{ 
  unsigned char *dst ;
  unsigned char const   *src ;
  unsigned char const   *srclim ;
  unsigned int c0 ;
  unsigned int c1 ;
  unsigned int c2 ;
  unsigned int ch ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 94
  src = (unsigned char const   *)src0;
#line 95
  srclim = src + n;
#line 96
  dst = (unsigned char *)dst0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned long )src < (unsigned long )srclim)) {
#line 98
      goto while_break;
    }
#line 99
    tmp = src;
#line 99
    src ++;
#line 99
    c0 = (unsigned int )*tmp;
#line 100
    if ((unsigned long )src < (unsigned long )srclim) {
#line 101
      tmp___0 = src;
#line 101
      src ++;
#line 101
      c1 = (unsigned int )*tmp___0;
    } else {
#line 103
      c1 = 0U;
    }
#line 105
    if ((unsigned long )src < (unsigned long )srclim) {
#line 106
      tmp___1 = src;
#line 106
      src ++;
#line 106
      c2 = (unsigned int )*tmp___1;
    } else {
#line 108
      c2 = 0U;
    }
#line 111
    ch = c0 >> 2;
#line 112
    *(dst + 0) = (unsigned char )B64EncodeTable[ch & 63U];
#line 114
    ch = ((c0 << 4) & 48U) | ((c1 >> 4) & 15U);
#line 115
    *(dst + 1) = (unsigned char )B64EncodeTable[ch & 63U];
#line 117
    ch = ((c1 << 2) & 60U) | ((c2 >> 6) & 3U);
#line 118
    *(dst + 2) = (unsigned char )B64EncodeTable[ch & 63U];
#line 120
    ch = c2 & 63U;
#line 121
    *(dst + 3) = (unsigned char )B64EncodeTable[ch & 63U];
#line 123
    dst += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (terminate != 0) {
#line 126
    *dst = (unsigned char )'\000';
  }
#line 127
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void FromBase64(void *dst0 , void const   *src0 , size_t n , int terminate ) 
{ 
  unsigned char *dst ;
  unsigned char const   *src ;
  unsigned char const   *srclim ;
  unsigned int c0 ;
  unsigned int c1 ;
  unsigned int c2 ;
  unsigned int c3 ;
  unsigned int ch ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;

  {
#line 139
  src = (unsigned char const   *)src0;
#line 140
  srclim = src + n;
#line 141
  dst = (unsigned char *)dst0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((unsigned long )src < (unsigned long )srclim)) {
#line 143
      goto while_break;
    }
#line 144
    tmp = src;
#line 144
    src ++;
#line 144
    c0 = (unsigned int )*tmp;
#line 145
    if ((unsigned long )src < (unsigned long )srclim) {
#line 146
      tmp___0 = src;
#line 146
      src ++;
#line 146
      c1 = (unsigned int )*tmp___0;
    } else {
#line 148
      c1 = 0U;
    }
#line 150
    if ((unsigned long )src < (unsigned long )srclim) {
#line 151
      tmp___1 = src;
#line 151
      src ++;
#line 151
      c2 = (unsigned int )*tmp___1;
    } else {
#line 153
      c2 = 0U;
    }
#line 155
    if ((unsigned long )src < (unsigned long )srclim) {
#line 156
      tmp___2 = src;
#line 156
      src ++;
#line 156
      c3 = (unsigned int )*tmp___2;
    } else {
#line 158
      c3 = 0U;
    }
#line 161
    ch = ((unsigned int )B64DecodeTable[c0] << 2) | ((unsigned int )B64DecodeTable[c1] >> 4);
#line 162
    *(dst + 0) = (unsigned char )ch;
#line 164
    ch = ((unsigned int )B64DecodeTable[c1] << 4) | ((unsigned int )B64DecodeTable[c2] >> 2);
#line 165
    *(dst + 1) = (unsigned char )ch;
#line 167
    ch = ((unsigned int )B64DecodeTable[c2] << 6) | (unsigned int )B64DecodeTable[c3];
#line 168
    *(dst + 2) = (unsigned char )ch;
#line 170
    dst += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  if (terminate != 0) {
#line 173
    *dst = (unsigned char )'\000';
  }
#line 174
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void OutOfMemory(void) 
{ 


  {
  {
#line 182
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory!\n");
#line 183
  exit(1);
  }
}
}
#line 188 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void MyInetAddr(char *dst , size_t siz , void *src , int i___0 ) 
{ 
  struct in_addr *ia ;

  {
  {
#line 193
  Strncpy((char */* const  */)dst, (char const   */* const  */)"???", (size_t const   )siz);
  }
#line 194
  if ((unsigned long )src != (unsigned long )((void *)0)) {
    {
#line 195
    ia = *((struct in_addr **)src + i___0);
#line 196
    InetNtoA(dst, ia, siz);
    }
  }
#line 198
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char *FileToURL(char *url , size_t urlsize , char const   * const  fn , char const   * const  rcwd ,
                char const   * const  startdir , char const   * const  user , char const   * const  pass ,
                char const   * const  hname , unsigned int const   port ) 
{ 
  size_t ulen ;
  size_t dsize ;
  char *dst ;
  char pbuf[32] ;
  int isUser ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 214
  Strncpy((char */* const  */)url, (char const   */* const  */)"ftp://", (size_t const   )urlsize);
#line 215
  isUser = 0;
  }
#line 216
  if ((unsigned long )user != (unsigned long )((void *)0)) {
#line 216
    if ((int const   )*(user + 0) != 0) {
      {
#line 216
      tmp = strcmp((char const   *)user, "anonymous");
      }
#line 216
      if (tmp != 0) {
        {
#line 216
        tmp___0 = strcmp((char const   *)user, "ftp");
        }
#line 216
        if (tmp___0 != 0) {
          {
#line 217
          isUser = 1;
#line 218
          Strncat((char */* const  */)url, user, (size_t const   )urlsize);
          }
#line 219
          if ((unsigned long )pass != (unsigned long )((void *)0)) {
#line 219
            if ((int const   )*(pass + 0) != 0) {
              {
#line 220
              Strncat((char */* const  */)url, (char const   */* const  */)":", (size_t const   )urlsize);
#line 221
              Strncat((char */* const  */)url, (char const   */* const  */)"PASSWORD",
                      (size_t const   )urlsize);
              }
            }
          }
          {
#line 223
          Strncat((char */* const  */)url, (char const   */* const  */)"@", (size_t const   )urlsize);
          }
        }
      }
    }
  }
  {
#line 225
  Strncat((char */* const  */)url, hname, (size_t const   )urlsize);
  }
#line 226
  if (port != 21U) {
#line 226
    if (port != 0U) {
      {
#line 227
      sprintf((char */* __restrict  */)(pbuf), (char const   */* __restrict  */)":%u",
              (unsigned int )port);
#line 228
      Strncat((char */* const  */)url, (char const   */* const  */)(pbuf), (size_t const   )urlsize);
      }
    }
  }
  {
#line 231
  ulen = strlen((char const   *)url);
#line 232
  dst = url + ulen;
#line 233
  dsize = urlsize - ulen;
#line 234
  PathCat((char */* const  */)dst, (size_t const   )dsize, rcwd, fn, 0);
  }
#line 235
  if ((unsigned long )startdir != (unsigned long )((void *)0)) {
#line 235
    if ((int const   )*(startdir + 0) != 0) {
#line 235
      if ((int const   )*(startdir + 1) != 0) {
        {
#line 236
        tmp___5 = strlen((char const   *)startdir);
#line 236
        tmp___6 = strncmp((char const   *)dst, (char const   *)startdir, tmp___5);
        }
#line 236
        if (tmp___6 == 0) {
          {
#line 238
          tmp___1 = strlen((char const   *)dst);
#line 238
          tmp___2 = strlen((char const   *)startdir);
#line 238
          tmp___3 = strlen((char const   *)startdir);
#line 238
          memmove((void *)dst, (void const   *)(dst + tmp___3), (tmp___1 - tmp___2) + 1UL);
          }
        } else
#line 239
        if (isUser != 0) {
          {
#line 245
          *(dst + (dsize - 1UL)) = (char )'\000';
#line 246
          *(dst + (dsize - 2UL)) = (char )'\000';
#line 247
          *(dst + (dsize - 3UL)) = (char )'\000';
#line 248
          *(dst + (dsize - 4UL)) = (char )'\000';
#line 249
          tmp___4 = strlen((char const   *)(dst + 1));
#line 249
          memmove((void *)(dst + 4), (void const   *)(dst + 1), tmp___4);
#line 250
          *(dst + 0) = (char )'/';
#line 251
          *(dst + 1) = (char )'%';
#line 252
          *(dst + 2) = (char )'2';
#line 253
          *(dst + 3) = (char )'F';
          }
        }
      }
    }
  }
#line 257
  return (url);
}
}
#line 267 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void AbbrevStr(char *dst , char const   *src , size_t max , int mode ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 272
  tmp = strlen(src);
#line 272
  len = (int )tmp;
  }
#line 273
  if (len > (int )max) {
#line 274
    if (mode == 0) {
      {
#line 276
      strcpy((char */* __restrict  */)dst, (char const   */* __restrict  */)"...");
#line 277
      Strncat((char */* const  */)dst, (char const   */* const  */)(((src + len) - (int )max) + 3),
              (size_t const   )(max + 1UL));
      }
    } else {
      {
#line 280
      Strncpy((char */* const  */)dst, (char const   */* const  */)src, (size_t const   )(max + 1UL));
#line 281
      strcpy((char */* __restrict  */)((dst + max) - 3), (char const   */* __restrict  */)"...");
      }
    }
  } else {
    {
#line 284
    Strncpy((char */* const  */)dst, (char const   */* const  */)src, (size_t const   )(max + 1UL));
    }
  }
#line 286
  return;
}
}
#line 291 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char *Path(char * const  dst , size_t const   siz , char const   * const  parent ,
           char const   * const  fname ) 
{ 
  char *tmp ;

  {
  {
#line 294
  Strncpy(dst, parent, siz);
#line 295
  Strncat(dst, (char const   */* const  */)"/", siz);
#line 296
  tmp = Strncat(dst, fname, siz);
  }
#line 296
  return (tmp);
}
}
#line 302 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char *OurDirectoryPath(char * const  dst , size_t const   siz , char const   * const  fname ) 
{ 
  char *tmp ;

  {
  {
#line 305
  tmp = Path(dst, siz, (char const   */* const  */)(gOurDirectoryPath), fname);
  }
#line 305
  return (tmp);
}
}
#line 310 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char *OurInstallationPath(char * const  dst , size_t const   siz , char const   * const  fname ) 
{ 
  char *tmp ;

  {
  {
#line 313
  tmp = Path(dst, siz, (char const   */* const  */)(gOurInstallationPath), fname);
  }
#line 313
  return (tmp);
}
}
#line 322 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void InitOurDirectory(void) 
{ 
  struct stat st ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 416
  memset((void *)(gOurInstallationPath), 0, sizeof(gOurInstallationPath));
#line 419
  cp = getenv("NCFTPDIR");
  }
#line 420
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 421
    Strncpy((char */* const  */)(gOurDirectoryPath), (char const   */* const  */)cp,
            (size_t const   )sizeof(gOurDirectoryPath));
    }
  } else {
    {
#line 422
    tmp = strcmp((char const   *)(gHome), "/");
    }
#line 422
    if (tmp == 0) {
#line 430
      gOurDirectoryPath[0] = (char )'\000';
#line 431
      return;
    } else {
      {
#line 433
      Path((char */* const  */)(gOurDirectoryPath), (size_t const   )sizeof(gOurDirectoryPath),
           (char const   */* const  */)(gHome), (char const   */* const  */)".ncftp");
      }
    }
  }
  {
#line 440
  tmp___1 = stat((char const   */* __restrict  */)(gOurDirectoryPath), (struct stat */* __restrict  */)(& st));
  }
#line 440
  if (tmp___1 < 0) {
    {
#line 441
    tmp___0 = mkdir((char const   *)(gOurDirectoryPath), (__mode_t )493);
    }
#line 441
    if (tmp___0 < 0) {
#line 442
      gOurDirectoryPath[0] = (char )'\000';
    }
  }
#line 446
  return;
}
}
#line 450 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void InitUserInfo(void) 
{ 
  struct passwd *pwptr ;
  char *envp ;

  {
  {
#line 473
  gUid = geteuid();
#line 474
  pwptr = getpwuid(gUid);
  }
#line 476
  if ((unsigned long )pwptr == (unsigned long )((void *)0)) {
    {
#line 477
    envp = getenv("LOGNAME");
    }
#line 478
    if ((unsigned long )envp == (unsigned long )((void *)0)) {
      {
#line 479
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Who are you?\n");
#line 480
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have a user id number of %d, but no username associated with it.\n",
              (int )gUid);
#line 481
      Strncpy((char */* const  */)(gUser), (char const   */* const  */)"unknown",
              (size_t const   )sizeof(gUser));
      }
    } else {
      {
#line 483
      Strncpy((char */* const  */)(gUser), (char const   */* const  */)envp, (size_t const   )sizeof(gUser));
      }
    }
    {
#line 486
    envp = getenv("HOME");
    }
#line 487
    if ((unsigned long )envp == (unsigned long )((void *)0)) {
      {
#line 488
      Strncpy((char */* const  */)(gHome), (char const   */* const  */)"/", (size_t const   )sizeof(gHome));
      }
    } else {
      {
#line 490
      Strncpy((char */* const  */)(gHome), (char const   */* const  */)envp, (size_t const   )sizeof(gHome));
      }
    }
    {
#line 492
    envp = getenv("SHELL");
    }
#line 493
    if ((unsigned long )envp == (unsigned long )((void *)0)) {
      {
#line 494
      Strncpy((char */* const  */)(gShell), (char const   */* const  */)"/bin/sh",
              (size_t const   )sizeof(gShell));
      }
    } else {
      {
#line 496
      Strncpy((char */* const  */)(gShell), (char const   */* const  */)envp, (size_t const   )sizeof(gShell));
      }
    }
  } else {
    {
#line 499
    Strncpy((char */* const  */)(gHome), (char const   */* const  */)pwptr->pw_dir,
            (size_t const   )sizeof(gHome));
#line 502
    Strncpy((char */* const  */)(gUser), (char const   */* const  */)pwptr->pw_name,
            (size_t const   )sizeof(gUser));
#line 505
    Strncpy((char */* const  */)(gShell), (char const   */* const  */)pwptr->pw_shell,
            (size_t const   )sizeof(gShell));
    }
  }
  {
#line 509
  InitOurDirectory();
  }
#line 510
  return;
}
}
#line 514 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
char *TolowerStr(char *dst ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 517
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 518
    return ((char *)((void *)0));
  }
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! ((int )*dst != 0)) {
#line 520
      goto while_break;
    }
    {
#line 521
    tmp___0 = __ctype_b_loc();
    }
#line 521
    if ((int const   )*(*tmp___0 + (int )*dst) & 256) {
      {
#line 522
      tmp = tolower((int )*dst);
#line 522
      *dst = (char )tmp;
      }
    }
#line 523
    dst ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (dst);
}
}
#line 531 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
int MayUseFirewall(char const   * const  hn0 , int firewallType , char const   * const  firewallExceptionList ) 
{ 
  char buf[256] ;
  char *tok ;
  char *parse ;
  char hn[80] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 541
  Strncpy((char */* const  */)(hn), hn0, (size_t const   )sizeof(hn));
#line 542
  TolowerStr(hn);
  }
#line 544
  if (firewallType == 0) {
#line 545
    return (0);
  }
#line 547
  if ((int const   )*(firewallExceptionList + 0) == 0) {
    {
#line 548
    tmp = strchr((char const   *)(hn), '.');
    }
#line 548
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 552
      return (0);
    } else {
#line 554
      return (1);
    }
  }
  {
#line 558
  tmp___1 = strchr((char const   *)(hn), '.');
  }
#line 558
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 565
    Strncpy((char */* const  */)(buf), firewallExceptionList, (size_t const   )sizeof(buf));
#line 566
    parse = buf;
    }
    {
#line 566
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 566
      tok = strtok((char */* __restrict  */)parse, (char const   */* __restrict  */)", \n\t\r");
      }
#line 566
      if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 566
        goto while_break;
      }
      {
#line 567
      tmp___0 = strcasecmp((char const   *)tok, "localdomain");
      }
#line 567
      if (tmp___0 == 0) {
#line 568
        return (0);
      }
#line 566
      parse = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 574
  Strncpy((char */* const  */)(buf), firewallExceptionList, (size_t const   )sizeof(buf));
#line 575
  TolowerStr(buf);
#line 576
  parse = buf;
  }
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 576
    tok = strtok((char */* __restrict  */)parse, (char const   */* __restrict  */)", \n\t\r");
    }
#line 576
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 576
      goto while_break___0;
    }
    {
#line 580
    tmp___2 = strstr((char const   *)(hn), (char const   *)tok);
    }
#line 580
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 581
      return (0);
    }
#line 576
    parse = (char *)((void *)0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 584
  return (1);
}
}
#line 589 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
int StrToBool(char const   * const  s ) 
{ 
  int c ;
  int result ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 595
  c = (int )*s;
#line 596
  tmp = __ctype_b_loc();
  }
#line 596
  if ((int const   )*(*tmp + c) & 256) {
    {
#line 597
    c = tolower(c);
    }
  }
#line 598
  result = 0;
  {
#line 601
  if (c == 110) {
#line 601
    goto case_110;
  }
#line 601
  if (c == 102) {
#line 601
    goto case_110;
  }
#line 603
  if (c == 111) {
#line 603
    goto case_111;
  }
#line 612
  if (c == 121) {
#line 612
    goto case_121;
  }
#line 612
  if (c == 116) {
#line 612
    goto case_121;
  }
#line 615
  goto switch_default;
  case_110: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 602
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 604
  c = (int )*(s + 1);
#line 605
  tmp___0 = __ctype_b_loc();
  }
#line 605
  if ((int const   )*(*tmp___0 + c) & 256) {
    {
#line 606
    c = tolower(c);
    }
  }
#line 607
  if (c == 102) {
#line 608
    goto switch_break;
  }
#line 609
  result = 1;
#line 610
  goto switch_break;
  case_121: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 613
  result = 1;
#line 614
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 616
  tmp___1 = atoi((char const   *)s);
  }
#line 616
  if (tmp___1 != 0) {
#line 617
    result = 1;
  }
  switch_break: /* CIL Label */ ;
  }
#line 619
  return (result);
}
}
#line 625 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
void AbsoluteToRelative(char * const  dst , size_t const   dsize , char const   * const  dir___3 ,
                        char const   * const  root , size_t const   rootlen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 628
  *dst = (char )'\000';
#line 629
  tmp___1 = strcmp((char const   *)dir___3, (char const   *)root);
  }
#line 629
  if (tmp___1 != 0) {
    {
#line 630
    tmp___0 = strcmp((char const   *)root, "/");
    }
#line 630
    if (tmp___0 == 0) {
      {
#line 631
      Strncpy(dst, dir___3 + 1, dsize);
      }
    } else {
      {
#line 632
      tmp = strncmp((char const   *)root, (char const   *)dir___3, (size_t )rootlen);
      }
#line 632
      if (tmp == 0) {
#line 632
        if ((int const   )*(dir___3 + rootlen) == 47) {
          {
#line 633
          Strncpy(dst, (dir___3 + rootlen) + 1, dsize);
          }
        } else {
          {
#line 636
          Strncpy(dst, dir___3, dsize);
          }
        }
      } else {
        {
#line 636
        Strncpy(dst, dir___3, dsize);
        }
      }
    }
  }
#line 639
  return;
}
}
#line 648 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static void CancelGetHostByName(int sigNum ) 
{ 
  int tmp ;

  {
#line 655
  if (sigNum != 0) {
#line 655
    tmp = 1;
  } else {
#line 655
    tmp = 0;
  }
  {
#line 655
  siglongjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), tmp);
  }
}
}
#line 666 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
int MyGetHostByName(char * const volatile  dst , size_t dsize , char const   * const  hn ,
                    int t ) 
{ 
  int sj ;
  void (* volatile  osigpipe)(int  ) ;
  void (* volatile  osigint)(int  ) ;
  void (* volatile  osigalrm)(int  ) ;
  struct hostent *hp ;
  struct in_addr ina ;
  int tmp ;
  void (*tmp___0)(int  ) ;
  void (*tmp___1)(int  ) ;
  void (*tmp___2)(int  ) ;

  {
  {
#line 698
  tmp = inet_aton((char const   *)hn, & ina);
  }
#line 698
  if (tmp != 0) {
    {
#line 700
    Strncpy((char */* const  */)dst, hn, (size_t const   )dsize);
    }
#line 701
    return (0);
  }
  {
#line 712
  osigalrm = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 712
  osigint = osigalrm;
#line 712
  osigpipe = osigint;
#line 713
  sj = __sigsetjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), 1);
  }
#line 719
  if (sj != 0) {
    {
#line 721
    alarm(0U);
#line 722
    NcSignal(13, (void (*)(int  ))osigpipe);
#line 723
    NcSignal(2, (void (*)(int  ))osigint);
#line 724
    NcSignal(14, (void (*)(int  ))osigalrm);
    }
  } else {
    {
#line 729
    tmp___0 = NcSignal(13, & CancelGetHostByName);
#line 729
    osigpipe = (void (*/* volatile  */)(int  ))tmp___0;
#line 730
    tmp___1 = NcSignal(2, & CancelGetHostByName);
#line 730
    osigint = (void (*/* volatile  */)(int  ))tmp___1;
#line 731
    tmp___2 = NcSignal(14, & CancelGetHostByName);
#line 731
    osigalrm = (void (*/* volatile  */)(int  ))tmp___2;
    }
#line 732
    if (t > 0) {
      {
#line 733
      alarm((unsigned int )t);
      }
    }
    {
#line 735
    hp = gethostbyname((char const   *)hn);
    }
#line 739
    if (t > 0) {
      {
#line 740
      alarm(0U);
      }
    }
    {
#line 741
    NcSignal(13, (void (*)(int  ))osigpipe);
#line 742
    NcSignal(2, (void (*)(int  ))osigint);
#line 743
    NcSignal(14, (void (*)(int  ))osigalrm);
    }
#line 754
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
      {
#line 755
      InetNtoA((char *)dst, *((struct in_addr **)hp->h_addr_list + 0), dsize);
      }
#line 756
      return (0);
    }
  }
#line 761
  *dst = (char )'\000';
#line 762
  return (-1);
}
}
#line 769 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
time_t UnDate(char *dstr ) 
{ 
  struct tm ut ;
  time_t result ;
  int tmp ;

  {
  {
#line 775
  result = (time_t )-1;
#line 777
  Localtime((time_t )0, (struct tm */* const  */)(& ut));
#line 780
  tmp = sscanf((char const   */* __restrict  */)dstr, (char const   */* __restrict  */)"%04d%02d%02d%02d%02d%02d",
               & ut.tm_year, & ut.tm_mon, & ut.tm_mday, & ut.tm_hour, & ut.tm_min,
               & ut.tm_sec);
  }
#line 780
  if (tmp == 6) {
    {
#line 788
    (ut.tm_mon) --;
#line 789
    ut.tm_year -= 1900;
#line 790
    result = mktime(& ut);
    }
  }
#line 792
  return (result);
}
}
#line 889 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
int strncoll(char const   *a , char const   *b , size_t n ) 
{ 
  int rc ;
  char sa[512] ;
  char sb[512] ;
  char *ma ;
  char *mb ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 894
  if (n < 511UL) {
    {
#line 897
    memset((void *)(sa), 0, sizeof(sa));
#line 898
    memset((void *)(sb), 0, sizeof(sb));
#line 899
    strncpy((char */* __restrict  */)(sa), (char const   */* __restrict  */)a, n);
#line 900
    strncpy((char */* __restrict  */)(sb), (char const   */* __restrict  */)b, n);
#line 901
    rc = strcoll((char const   *)(sa), (char const   *)(sb));
    }
  } else {
    {
#line 905
    n += 5UL;
#line 906
    tmp = malloc(n);
#line 906
    ma = (char *)tmp;
    }
#line 907
    if ((unsigned long )ma == (unsigned long )((void *)0)) {
#line 908
      return (0);
    }
    {
#line 909
    tmp___0 = malloc(n);
#line 909
    mb = (char *)tmp___0;
    }
#line 910
    if ((unsigned long )mb == (unsigned long )((void *)0)) {
      {
#line 911
      free((void *)ma);
      }
#line 912
      return (0);
    }
    {
#line 914
    strncpy((char */* __restrict  */)ma, (char const   */* __restrict  */)a, n);
#line 915
    strncpy((char */* __restrict  */)mb, (char const   */* __restrict  */)b, n);
#line 916
    rc = strcoll((char const   *)ma, (char const   *)mb);
#line 917
    free((void *)ma);
#line 918
    free((void *)mb);
    }
  }
#line 920
  return (rc);
}
}
#line 927 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
int DecodeDirectoryURL(FTPCIPtr const   cip , char *url , FTPLineListPtr cdlist ,
                       char *fn , size_t fnsize ) 
{ 
  int rc ;
  char urlstr2[256] ;
  char *cp ;
  char *tmp ;

  {
  {
#line 948
  cp = strrchr((char const   *)url, '/');
  }
#line 949
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 949
    if ((int )*(cp + 1) != 0) {
      {
#line 949
      tmp = strchr((char const   *)cp, '.');
      }
#line 949
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 951
        Strncpy((char */* const  */)(urlstr2), (char const   */* const  */)url, (size_t const   )sizeof(urlstr2));
#line 952
        Strncat((char */* const  */)(urlstr2), (char const   */* const  */)"/", (size_t const   )sizeof(urlstr2));
#line 953
        url = urlstr2;
        }
      }
    }
  }
  {
#line 955
  rc = FTPDecodeURL(cip, (char */* const  */)url, cdlist, (char */* const  */)fn,
                    (size_t const   )fnsize, (int */* const  */)((void *)0), (int */* const  */)((void *)0));
  }
#line 956
  return (rc);
}
}
#line 1094 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void DoneWithResponse(FTPCIPtr const   cip , ResponsePtr rp ) ;
#line 1095
ResponsePtr InitResponse(void) ;
#line 1099
int ( /* format attribute */  RCmd)(FTPCIPtr const   cip , ResponsePtr rp , char const   *cmdspec 
                                    , ...) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_getcwd.c"
int FTPGetCWD(FTPCIPtr const   cip , char * const  newCwd , size_t const   newCwdSize ) 
{ 
  ResponsePtr rp ;
  char *l ;
  char *r ;
  int result ;
  int tmp ;

  {
#line 20
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 21
    return (-139);
  }
  {
#line 22
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 22
  if (tmp) {
#line 23
    return (-138);
  }
#line 25
  if ((unsigned long )newCwd == (unsigned long )((void *)0)) {
#line 26
    result = -122;
#line 27
    cip->errNo = -122;
  } else
#line 25
  if (newCwdSize == 0UL) {
#line 26
    result = -122;
#line 27
    cip->errNo = -122;
  } else {
    {
#line 29
    rp = InitResponse();
    }
#line 30
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 31
      result = -123;
#line 32
      cip->errNo = -123;
#line 33
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
      }
    } else {
      {
#line 35
      result = RCmd(cip, rp, "PWD");
      }
#line 36
      if (result == 2) {
        {
#line 37
        r = strrchr((char const   *)(rp->msg.first)->line, '\"');
        }
#line 37
        if ((unsigned long )r != (unsigned long )((void *)0)) {
          {
#line 41
          l = strchr((char const   *)(rp->msg.first)->line, '\"');
          }
#line 42
          if ((unsigned long )l != (unsigned long )((void *)0)) {
#line 42
            if ((unsigned long )l != (unsigned long )r) {
              {
#line 43
              *r = (char )'\000';
#line 44
              l ++;
#line 45
              Strncpy(newCwd, (char const   */* const  */)l, newCwdSize);
#line 46
              *r = (char )'\"';
              }
            }
          }
        } else {
          {
#line 52
          r = strchr((char const   *)(rp->msg.first)->line, ' ');
          }
#line 52
          if ((unsigned long )r != (unsigned long )((void *)0)) {
            {
#line 53
            *r = (char )'\000';
#line 54
            Strncpy(newCwd, (char const   */* const  */)(rp->msg.first)->line, newCwdSize);
#line 55
            *r = (char )' ';
            }
          }
        }
#line 58
        result = 0;
      } else
#line 59
      if (result > 0) {
#line 60
        result = -124;
#line 61
        cip->errNo = -124;
      }
      {
#line 63
      DoneWithResponse(cip, rp);
      }
    }
  }
#line 66
  return (result);
}
}
#line 72 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_getcwd.c"
int FTPChdirAndGetCWD(FTPCIPtr const   cip , char const   * const  cdCwd , char * const  newCwd ,
                      size_t const   newCwdSize ) 
{ 
  ResponsePtr rp ;
  char *l ;
  char *r ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 79
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 80
    return (-139);
  }
  {
#line 81
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 81
  if (tmp) {
#line 82
    return (-138);
  }
#line 84
  if ((unsigned long )newCwd == (unsigned long )((void *)0)) {
#line 85
    result = -122;
#line 86
    cip->errNo = -122;
  } else
#line 84
  if ((unsigned long )cdCwd == (unsigned long )((void *)0)) {
#line 85
    result = -122;
#line 86
    cip->errNo = -122;
  } else {
#line 88
    if ((int const   )*(cdCwd + 0) == 0) {
      {
#line 89
      result = FTPGetCWD(cip, newCwd, newCwdSize);
      }
#line 90
      return (result);
    }
    {
#line 92
    rp = InitResponse();
    }
#line 93
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 94
      result = -123;
#line 95
      cip->errNo = -123;
#line 96
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
      }
    } else {
      {
#line 98
      tmp___0 = strcmp((char const   *)cdCwd, "..");
      }
#line 98
      if (tmp___0 == 0) {
        {
#line 99
        result = RCmd(cip, rp, "CDUP");
        }
      } else {
        {
#line 101
        result = RCmd(cip, rp, "CWD %s", cdCwd);
        }
      }
#line 102
      if (result == 2) {
        {
#line 103
        l = strchr((char const   *)(rp->msg.first)->line, '\"');
        }
#line 104
        if ((unsigned long )l == (unsigned long )(rp->msg.first)->line) {
          {
#line 104
          r = strrchr((char const   *)(rp->msg.first)->line, '\"');
          }
#line 104
          if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 104
            if ((unsigned long )l != (unsigned long )r) {
              {
#line 110
              *r = (char )'\000';
#line 111
              l ++;
#line 112
              Strncpy(newCwd, (char const   */* const  */)l, newCwdSize);
#line 113
              *r = (char )'\"';
#line 114
              DoneWithResponse(cip, rp);
#line 115
              result = 0;
              }
            } else {
              {
#line 117
              DoneWithResponse(cip, rp);
#line 118
              result = FTPGetCWD(cip, newCwd, newCwdSize);
              }
            }
          } else {
            {
#line 117
            DoneWithResponse(cip, rp);
#line 118
            result = FTPGetCWD(cip, newCwd, newCwdSize);
            }
          }
        } else {
          {
#line 117
          DoneWithResponse(cip, rp);
#line 118
          result = FTPGetCWD(cip, newCwd, newCwdSize);
          }
        }
      } else
#line 120
      if (result > 0) {
        {
#line 121
        result = -125;
#line 122
        cip->errNo = -125;
#line 123
        DoneWithResponse(cip, rp);
        }
      } else {
        {
#line 125
        DoneWithResponse(cip, rp);
        }
      }
    }
  }
#line 129
  return (result);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 188 "../sio/sio.h"
int GetOurHostName(char * const  host , size_t const   siz ) ;
#line 72 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/pref.h"
void WriteDefaultFirewallPrefs(FILE *fp ) ;
#line 73
void ProcessFirewallPrefFile(FILE *fp ) ;
#line 74
void LoadFirewallPrefs(int forceReload ) ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
int gNumProgramRuns  =    0;
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
int gFirewallType  ;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
char gFirewallHost[64]  ;
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
char gFirewallUser[32]  ;
#line 23 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
char gFirewallPass[32]  ;
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
char gFirewallExceptionList[256]  ;
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
unsigned int gFirewallPort  ;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
int gFirewallPrefsLoaded  =    0;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
int gDataPortMode  ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
int gFwDataPortMode  =    -1;
#line 39 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
char gOurHostName[64]  ;
#line 40 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
int gGetOurHostNameResult  =    100;
#line 47 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
void WriteDefaultFirewallPrefs(FILE *fp ) 
{ 
  char *cp ;
  time_t now ;
  char *tmp ;

  {
#line 53
  if (gGetOurHostNameResult == 100) {
    {
#line 54
    gGetOurHostNameResult = GetOurHostName((char */* const  */)(gOurHostName), (size_t const   )sizeof(gOurHostName));
    }
  }
  {
#line 55
  cp = strchr((char const   *)(gOurHostName), '.');
#line 57
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "# NcFTP firewall preferences\n# ==========================\n#\n");
#line 63
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "# If you need to use a proxy for FTP, you can configure it below.\n# If you do not need one, leave the ``firewall-type\'\' variable set\n# to 0.  Any line that does not begin with the ``#\'\' character is\n# considered a configuration command line.\n");
#line 69
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\n# NOTE:  NcFTP does NOT support HTTP proxies that do FTP, such as \"squid\"\n#        or Netscape Proxy Server.  Why?  Because you have to communicate with\n#        them using HTTP, and this is a FTP only program.\n");
#line 75
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\n# Types of firewalls:\n# ------------------\n#\n#    type 1:  Connect to firewall host, but send \"USER user@real.host.name\"\n#\n");
#line 83
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#    type 2:  Connect to firewall, login with \"USER fwuser\" and\n#             \"PASS fwpassword\", and then \"USER user@real.host.name\"\n#\n#    type 3:  Connect to and login to firewall, and then use\n#             \"SITE real.host.name\", followed by the regular USER and PASS.\n#\n");
#line 91
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#    type 4:  Connect to and login to firewall, and then use\n#             \"OPEN real.host.name\", followed by the regular USER and PASS.\n#\n#    type 5:  Connect to firewall host, but send\n#             \"USER user@fwuser@real.host.name\" and\n#             \"PASS pass@fwpass\" to login.\n#\n");
#line 100
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#    type 6:  Connect to firewall host, but send\n#             \"USER fwuser@real.host.name\" and\n#             \"PASS fwpass\" followed by a regular\n#             \"USER user\" and\n#             \"PASS pass\" to complete the login.\n#\n");
#line 108
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#    type 7:  Connect to firewall host, but send\n#             \"USER user@real.host.name fwuser\" and\n#             \"PASS pass\" followed by\n#             \"ACCT fwpass\" to complete the login.\n#\n");
#line 115
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#    type 8:  Connect to firewall host, but send \"USER user@real.host.name:port\"\n#\n#    type 9:  Connect to firewall host, but send \"USER user@real.host.name port\"\n#\n");
#line 121
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#    type 0:  Do NOT use a firewall (most users will choose this).\n#\nfirewall-type=0\n#\n#\n#\n");
#line 129
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "# The ``firewall-host\'\' variable should be the IP address or hostname of\n# your firewall server machine.\n#\n");
  }
#line 135
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 136
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"firewall-host=firewall.domain.com\n");
    }
  } else {
    {
#line 138
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"firewall-host=firewall%s\n",
            cp);
    }
  }
  {
#line 141
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\n#\n#\n# The ``firewall-user\'\' variable tells NcFTP what to use as the user ID\n# when it logs in to the firewall before connecting to the outside world.\n#\n");
#line 149
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"firewall-user=%s\n",
          gUser);
#line 150
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\n#\n#\n# The ``firewall-password\'\' variable is the password associated with\n# the firewall-user ID.  If you set this here, be sure to change the\n# permissions on this file so that no one (except the superuser) can\n# see your password.  You may also leave this commented out, and then\n# NcFTP will prompt you each time for the password.\n");
#line 160
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\nfirewall-password=fwpass\n#\n#\n#\n# Your firewall may require you to connect to a non-standard port for\n# outside FTP services, instead of the internet standard port number (21).\n#\nfirewall-port=21\n");
#line 171
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\n#\n#\n# You probably do not want to FTP to the firewall for hosts on your own\n# domain.  You can set ``firewall-exception-list\'\' to a list of domains\n# or hosts where the firewall should not be used.  For example, if your\n# domain was ``probe.net\'\' you could set this to ``.probe.net\'\'.\n#\n");
#line 181
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "# If you leave this commented out, the default behavior is to attempt to\n# lookup the current domain, and exclude hosts for it.  Otherwise, set it\n# to a list of comma-delimited domains or hostnames.  The special token\n# ``localdomain\'\' is used for unqualified hostnames, so if you want hosts\n# without explicit domain names to avoid the firewall, be sure to include\n# that in your list.\n#\n");
  }
#line 191
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 192
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"firewall-exception-list=%s,localhost,localdomain\n",
            cp);
    }
  } else {
    {
#line 194
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"firewall-exception-list=.probe.net,localhost,foo.bar.com,localdomain\n");
    }
  }
  {
#line 197
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "#\n#\n#\n# You may also specify passive mode here.  Normally this is set in the\n# regular $HOME/.ncftp/prefs file.  This must be set to one of\n# \"on\", \"off\", or \"optional\", which mean always use PASV,\n# always use PORT, and try PASV then PORT, respectively.\n#\n#passive=on\n");
#line 208
  time(& now);
#line 209
  tmp = ctime((time_t const   *)(& now));
#line 209
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#\n#\n#\n# NOTE:  This file was created for you on %s#        by NcFTP %.5s.  Removing this file will cause the next run of NcFTP\n#        to generate a new one, possibly with more configurable options.\n",
          tmp, gVersion + 11);
#line 218
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#\n# ALSO:  A %s file, if present, is processed before this file,\n#        and a %s file, if present, is processed after.\n",
          "/usr/local/etc/ncftp.firewall", "/usr/local/etc/ncftp.firewall.fixed");
  }
#line 225
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
void ProcessFirewallPrefFile(FILE *fp ) 
{ 
  char line[256] ;
  char *tok1 ;
  char *tok2 ;
  int n ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 238
  line[sizeof(line) - 1UL] = (char )'\000';
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 239
    tmp___11 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL),
                     (FILE */* __restrict  */)fp);
    }
#line 239
    if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 239
      goto while_break;
    }
    {
#line 240
    tok1 = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)" =\t\r\n");
    }
#line 241
    if ((unsigned long )tok1 == (unsigned long )((void *)0)) {
#line 242
      goto while_continue;
    } else
#line 241
    if ((int )*(tok1 + 0) == 35) {
#line 242
      goto while_continue;
    }
    {
#line 243
    tok2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\r\n");
    }
#line 244
    if ((unsigned long )tok2 == (unsigned long )((void *)0)) {
#line 245
      goto while_continue;
    }
    {
#line 246
    tmp___10 = strcasecmp((char const   *)tok1, "firewall-type");
    }
#line 246
    if (tmp___10 == 0) {
      {
#line 247
      n = atoi((char const   *)tok2);
      }
#line 248
      if (n > 0) {
#line 248
        if (n <= 9) {
#line 249
          gFirewallType = n;
        }
      }
    } else {
      {
#line 250
      tmp___9 = strcasecmp((char const   *)tok1, "firewall-host");
      }
#line 250
      if (tmp___9 == 0) {
        {
#line 251
        Strncpy((char */* const  */)(gFirewallHost), (char const   */* const  */)tok2,
                (size_t const   )sizeof(gFirewallHost));
        }
      } else {
        {
#line 252
        tmp___8 = strcasecmp((char const   *)tok1, "firewall-port");
        }
#line 252
        if (tmp___8 == 0) {
          {
#line 253
          n = atoi((char const   *)tok2);
          }
#line 254
          if (n > 0) {
#line 255
            gFirewallPort = (unsigned int )n;
          }
        } else {
          {
#line 256
          tmp___7 = strcasecmp((char const   *)tok1, "firewall-user");
          }
#line 256
          if (tmp___7 == 0) {
            {
#line 257
            Strncpy((char */* const  */)(gFirewallUser), (char const   */* const  */)tok2,
                    (size_t const   )sizeof(gFirewallUser));
            }
          } else {
            {
#line 258
            tmp___6 = strcasecmp((char const   *)tok1, "firewall-pass");
            }
#line 258
            if (tmp___6 == 0) {
              {
#line 259
              Strncpy((char */* const  */)(gFirewallPass), (char const   */* const  */)tok2,
                      (size_t const   )sizeof(gFirewallPass));
              }
            } else {
              {
#line 260
              tmp___5 = strcasecmp((char const   *)tok1, "firewall-password");
              }
#line 260
              if (tmp___5 == 0) {
                {
#line 261
                Strncpy((char */* const  */)(gFirewallPass), (char const   */* const  */)tok2,
                        (size_t const   )sizeof(gFirewallPass));
                }
              } else {
                {
#line 262
                tmp___4 = strcasecmp((char const   *)tok1, "firewall-exception-list");
                }
#line 262
                if (tmp___4 == 0) {
                  {
#line 263
                  Strncpy((char */* const  */)(gFirewallExceptionList), (char const   */* const  */)tok2,
                          (size_t const   )sizeof(gFirewallExceptionList));
                  }
                } else {
                  {
#line 264
                  tmp___3 = strcasecmp((char const   *)tok1, "passive");
                  }
#line 264
                  if (tmp___3 == 0) {
                    {
#line 265
                    tmp___2 = strcasecmp((char const   *)tok2, "optional");
                    }
#line 265
                    if (tmp___2 == 0) {
#line 266
                      gFwDataPortMode = 2;
#line 266
                      gDataPortMode = gFwDataPortMode;
                    } else {
                      {
#line 267
                      tmp___1 = strcasecmp((char const   *)tok2, "on");
                      }
#line 267
                      if (tmp___1 == 0) {
#line 268
                        gFwDataPortMode = 1;
#line 268
                        gDataPortMode = gFwDataPortMode;
                      } else {
                        {
#line 269
                        tmp___0 = strcasecmp((char const   *)tok2, "off");
                        }
#line 269
                        if (tmp___0 == 0) {
#line 270
                          gFwDataPortMode = 0;
#line 270
                          gDataPortMode = gFwDataPortMode;
                        } else {
                          {
#line 271
                          tmp = __ctype_b_loc();
                          }
#line 271
                          if ((int )((int const   )*(*tmp + (int )*(tok2 + 0)) & 2048)) {
                            {
#line 272
                            gFwDataPortMode = atoi((char const   *)tok2);
#line 272
                            gDataPortMode = gFwDataPortMode;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/preffw.c"
void LoadFirewallPrefs(int forceReload ) 
{ 
  FILE *fp ;
  FILE *fp2 ;
  char pathName[256] ;
  char *cp ;
  int userFile ;
  int sysFile ;

  {
#line 291
  userFile = 0;
#line 292
  sysFile = 0;
#line 294
  if (gFirewallPrefsLoaded != 0) {
#line 294
    if (forceReload == 0) {
#line 295
      return;
    }
  }
  {
#line 296
  gFirewallPrefsLoaded = 1;
#line 297
  pathName[0] = (char )'\000';
#line 300
  gFirewallType = 0;
#line 301
  gFirewallPort = 0U;
#line 302
  gFirewallHost[0] = (char )'\000';
#line 303
  gFirewallUser[0] = (char )'\000';
#line 304
  gFirewallPass[0] = (char )'\000';
#line 305
  gFirewallExceptionList[0] = (char )'\000';
#line 307
  fp2 = fopen((char const   */* __restrict  */)"/usr/local/etc/ncftp.firewall", (char const   */* __restrict  */)"r");
  }
#line 308
  if ((unsigned long )fp2 != (unsigned long )((void *)0)) {
    {
#line 310
    ProcessFirewallPrefFile(fp2);
#line 311
    fclose(fp2);
#line 312
    sysFile ++;
    }
  }
#line 315
  if ((int )gOurDirectoryPath[0] != 0) {
    {
#line 316
    OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                     (char const   */* const  */)"firewall");
#line 317
    fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
    }
#line 318
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 320
      ProcessFirewallPrefFile(fp);
#line 321
      fclose(fp);
#line 322
      userFile = 1;
      }
    }
  }
  {
#line 326
  fp2 = fopen((char const   */* __restrict  */)"/usr/local/etc/ncftp.firewall.fixed",
              (char const   */* __restrict  */)"r");
  }
#line 327
  if ((unsigned long )fp2 != (unsigned long )((void *)0)) {
    {
#line 329
    ProcessFirewallPrefFile(fp2);
#line 330
    fclose(fp2);
#line 331
    sysFile ++;
    }
  }
#line 334
  if (userFile == 0) {
#line 334
    if (sysFile == 0) {
#line 334
      if ((int )pathName[0] != 0) {
        {
#line 338
        fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"w");
        }
#line 339
        if ((unsigned long )fp != (unsigned long )((void *)0)) {
          {
#line 340
          WriteDefaultFirewallPrefs(fp);
#line 341
          fclose(fp);
#line 344
          chmod((char const   *)(pathName), (__mode_t )384);
#line 346
          gNumProgramRuns = 1;
          }
        }
      }
    }
  }
#line 350
  if ((int )gFirewallExceptionList[0] == 0) {
#line 351
    if (gGetOurHostNameResult == 100) {
      {
#line 352
      gGetOurHostNameResult = GetOurHostName((char */* const  */)(gOurHostName), (size_t const   )sizeof(gOurHostName));
      }
    }
    {
#line 354
    cp = strchr((char const   *)(gOurHostName), '.');
    }
#line 356
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 357
      Strncpy((char */* const  */)(gFirewallExceptionList), (char const   */* const  */)cp,
              (size_t const   )sizeof(gFirewallExceptionList));
#line 358
      Strncat((char */* const  */)(gFirewallExceptionList), (char const   */* const  */)",localdomain",
              (size_t const   )sizeof(gFirewallExceptionList));
      }
    }
  }
#line 361
  return;
}
}
#line 885 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPDelete(FTPCIPtr const   cip , char const   * const  pattern , int const   recurse ,
              int const   doGlob ) ;
#line 135 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
int FTPRmdirRecursive(FTPCIPtr const   cip , char const   * const  dir___3 ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_delete.c"
int FTPDelete(FTPCIPtr const   cip , char const   * const  pattern , int const   recurse ,
              int const   doGlob ) 
{ 
  FTPLineList fileList ;
  FTPLinePtr filePtr ;
  char *file ;
  int onceResult ;
  int batchResult ;
  int tmp ;

  {
#line 21
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 22
    return (-139);
  }
  {
#line 23
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 23
  if (tmp) {
#line 24
    return (-138);
  }
  {
#line 26
  batchResult = FTPRemoteGlob((FTPCIPtr )cip, & fileList, (char const   *)pattern,
                              (int )doGlob);
  }
#line 27
  if (batchResult != 0) {
#line 28
    return (batchResult);
  }
#line 30
  batchResult = 0;
#line 30
  filePtr = fileList.first;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 30
      goto while_break;
    }
#line 34
    file = filePtr->line;
#line 35
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 36
      batchResult = -127;
#line 37
      cip->errNo = -127;
#line 38
      goto while_break;
    }
    {
#line 40
    onceResult = FTPCmd(cip, (char const   */* const  */)"DELE %s", file);
    }
#line 41
    if (onceResult < 0) {
#line 42
      batchResult = onceResult;
#line 43
      goto while_break;
    }
#line 45
    if (onceResult != 2) {
#line 46
      if (recurse != 1) {
#line 47
        batchResult = -144;
#line 48
        cip->errNo = -144;
      } else {
        {
#line 50
        onceResult = FTPCmd(cip, (char const   */* const  */)"RMD %s", file);
        }
#line 51
        if (onceResult < 0) {
#line 52
          batchResult = onceResult;
#line 53
          goto while_break;
        }
#line 55
        if (onceResult != 2) {
          {
#line 56
          onceResult = FTPRmdirRecursive(cip, (char const   */* const  */)file);
          }
#line 57
          if (onceResult < 0) {
#line 58
            batchResult = -126;
#line 59
            cip->errNo = -126;
          }
        }
      }
    }
#line 30
    filePtr = filePtr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  DisposeLineListContents(& fileList);
  }
#line 66
  return (batchResult);
}
}
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Strtok(char *buf , char const   *delims ) ;
#line 35
int Strntok(char *dstTokenStart , size_t tokenSize , char *buf , char const   *delims ) ;
#line 37 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
static char *p  =    (char *)((void *)0);
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
char *Strtok(char *buf , char const   *delims ) 
{ 
  char *start ;
  char *end ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 40
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 41
    p = buf;
  } else
#line 43
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 44
    return ((char *)((void *)0));
  }
#line 46
  start = p;
#line 46
  end = p;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if ((int )*end == 0) {
#line 48
      p = (char *)((void *)0);
#line 49
      goto while_break;
    }
    {
#line 51
    tmp___0 = strchr(delims, (int )*end);
    }
#line 51
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 52
      tmp = end;
#line 52
      end ++;
#line 52
      *tmp = (char )'\000';
#line 53
      p = end;
#line 54
      goto while_break;
    }
#line 46
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (start);
}
}
#line 82 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
static char *p___0  =    (char *)((void *)0);
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
int Strntok(char *dstTokenStart , size_t tokenSize , char *buf , char const   *delims ) 
{ 
  char *end ;
  char *lim ;
  char *dst ;
  int len ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 88
  dst = dstTokenStart;
#line 89
  lim = (dst + tokenSize) - 1;
#line 91
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 92
    p___0 = buf;
  } else
#line 94
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 95
    *dst = (char )'\000';
#line 96
    return (-1);
  }
#line 100
  end = p___0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if ((int )*end == 0) {
#line 102
      p___0 = (char *)((void *)0);
#line 103
      goto while_break;
    }
    {
#line 105
    tmp = strchr(delims, (int )*end);
    }
#line 105
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 106
      end ++;
#line 107
      p___0 = end;
#line 108
      goto while_break;
    }
#line 110
    if ((unsigned long )dst < (unsigned long )lim) {
#line 111
      tmp___0 = dst;
#line 111
      dst ++;
#line 111
      *tmp___0 = *end;
    }
#line 100
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  *dst = (char )'\000';
#line 114
  len = (int )(dst - dstTokenStart);
#line 118
  dst ++;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )dst <= (unsigned long )lim)) {
#line 118
      goto while_break___0;
    }
#line 119
    tmp___1 = dst;
#line 119
    dst ++;
#line 119
    *tmp___1 = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return (len);
}
}
#line 578 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 1013 "../libncftp/ncftp.h"
char *FTPGetLocalCWD(char *buf , size_t size ) ;
#line 1081
int DPathCat(char ** const  dst0 , char const   * const  cwd , char const   * const  src ,
             int dosCompat ) ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spool.h"
int MkSpoolDir(char *sdir , size_t size ) ;
#line 18
void SpoolName(char * const  sp , size_t const   size , int const   flag , int const   serial ,
               time_t when ) ;
#line 21
int SpoolX(FILE * const  ofp , char const   *sdir , char const   * const  op , char const   * const  rfile ,
           char const   * const  rdir , char const   * const  lfile , char const   * const  ldir ,
           char const   * const  host , char const   * const  ip , unsigned int const   port ,
           char const   * const  user , char const   * const  passclear , char const   * const  xacct ,
           int const   xtype , int const   recursive , int const   deleteflag , int const   passive ,
           char const   * const  preftpcmd , char const   * const  perfileftpcmd ,
           char const   * const  postftpcmd , char const   * const  preshellcmd ,
           char const   * const  postshellcmd , time_t const   when , unsigned int const   delaySinceLastFailure ,
           char const   * const  manualOverrideFeatures , char const   * const  preferredLocalAddrStr ,
           int const   reserved  __attribute__((__unused__)) ) ;
#line 49
void RunBatch(void) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
int gSpoolSerial  =    0;
#line 20
FTPLibraryInfo gLib ;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
int MkSpoolDir(char *sdir , size_t size ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
#line 33
  *sdir = (char )'\000';
#line 36
  if ((int )gOurDirectoryPath[0] != 0) {
    {
#line 37
    OurDirectoryPath((char */* const  */)sdir, (size_t const   )size, (char const   */* const  */)"spool");
#line 38
    tmp = stat((char const   */* __restrict  */)sdir, (struct stat */* __restrict  */)(& st));
    }
#line 38
    if (tmp < 0) {
      {
#line 38
      tmp___0 = MkDirs((char const   */* const  */)sdir, 448);
      }
#line 38
      if (tmp___0 < 0) {
        {
#line 39
        perror((char const   *)sdir);
        }
#line 40
        return (-1);
      } else {
#line 42
        return (0);
      }
    } else {
#line 42
      return (0);
    }
  }
#line 45
  return (-1);
}
}
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
void SpoolName(char * const  sp , size_t const   size , int const   flag , int const   serial ,
               time_t when ) 
{ 
  char dstr[32] ;
  struct tm lt ;
  struct tm *tmp ;
  __pid_t tmp___0 ;

  {
#line 56
  if (when == 0L) {
    {
#line 57
    time(& when);
    }
  } else
#line 56
  if (when == -1L) {
    {
#line 57
    time(& when);
    }
  }
  {
#line 58
  tmp = Gmtime(when, (struct tm */* const  */)(& lt));
  }
#line 58
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 60
    Strncpy((char */* const  */)(dstr), (char const   */* const  */)"20010101-000000",
            size);
    }
  } else {
    {
#line 62
    strftime((char */* __restrict  */)(dstr), sizeof(dstr), (char const   */* __restrict  */)"%Y%m%d-%H%M%S",
             (struct tm  const  */* __restrict  */)(& lt));
    }
  }
  {
#line 73
  tmp___0 = getpid();
#line 73
  snprintf((char */* __restrict  */)sp, (size_t )(size - 1UL), (char const   */* __restrict  */)"%c-%s-%06d-%d",
           flag, dstr, (unsigned int )tmp___0, serial);
  }
#line 84
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
static int WriteSpoolLine(FILE * const  ofp , char const   * const  line ) 
{ 
  int c ;
  char const   *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 95
  c = 0;
#line 96
  cp = (char const   *)line;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! *cp) {
#line 96
      goto while_break;
    }
#line 97
    c = (int )*cp;
#line 98
    if (c == 10) {
#line 98
      if ((int const   )*(cp + 1) != 0) {
        {
#line 99
        tmp = _IO_putc('\\', (_IO_FILE *)ofp);
        }
#line 99
        if (tmp == -1) {
#line 100
          return (-1);
        }
      }
    }
    {
#line 102
    tmp___0 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 102
    if (tmp___0 == -1) {
#line 103
      return (-1);
    }
#line 96
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (c != 10) {
    {
#line 106
    c = '\n';
#line 107
    tmp___1 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 107
    if (tmp___1 == -1) {
#line 108
      return (-1);
    }
  }
#line 110
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
int SpoolX(FILE * const  ofp , char const   *sdir , char const   * const  op , char const   * const  rfile ,
           char const   * const  rdir , char const   * const  lfile , char const   * const  ldir ,
           char const   * const  host , char const   * const  ip , unsigned int const   port ,
           char const   * const  user , char const   * const  passclear , char const   * const  xacct ,
           int const   xtype , int const   recursive , int const   deleteflag , int const   passive ,
           char const   * const  preftpcmd , char const   * const  perfileftpcmd ,
           char const   * const  postftpcmd , char const   * const  preshellcmd ,
           char const   * const  postshellcmd , time_t const   when , unsigned int const   delaySinceLastFailure ,
           char const   * const  manualOverrideFeatures , char const   * const  preferredLocalAddrStr ,
           int const   reserved  __attribute__((__unused__)) ) 
{ 
  char sdir2[256] ;
  char pass[160] ;
  char sname[64] ;
  char sname2[64] ;
  char spathname[256] ;
  char spathname2[256] ;
  char ldir2[256] ;
  char *ldir3 ;
  FILE *fp ;
  mode_t um ;
  int tmp ;
  FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;

  {
  {
#line 160
  gSpoolSerial ++;
#line 161
  SpoolName((char */* const  */)(sname2), (size_t const   )sizeof(sname2), (int const   )*(op + 0),
            (int const   )gSpoolSerial, (time_t )when);
  }
#line 163
  if ((unsigned long )ofp == (unsigned long )((void *)0)) {
#line 164
    if ((unsigned long )sdir == (unsigned long )((void *)0)) {
      {
#line 165
      tmp = MkSpoolDir(sdir2, sizeof(sdir2));
      }
#line 165
      if (tmp < 0) {
#line 166
        return (-1);
      }
#line 167
      sdir = (char const   *)(sdir2);
    }
    {
#line 169
    Path((char */* const  */)(spathname2), (size_t const   )sizeof(spathname2), (char const   */* const  */)sdir,
         (char const   */* const  */)(sname2));
#line 170
    Strncpy((char */* const  */)(sname), (char const   */* const  */)(sname2), (size_t const   )sizeof(sname));
#line 171
    sname[0] = (char )'z';
#line 172
    Path((char */* const  */)(spathname), (size_t const   )sizeof(spathname), (char const   */* const  */)sdir,
         (char const   */* const  */)(sname));
    }
  }
  {
#line 178
  um = umask((__mode_t )63);
  }
#line 179
  if ((unsigned long )ofp == (unsigned long )((void *)0)) {
    {
#line 179
    tmp___0 = fopen((char const   */* __restrict  */)(spathname), (char const   */* __restrict  */)"w");
#line 179
    fp = tmp___0;
    }
  } else {
#line 179
    fp = (FILE *)ofp;
  }
  {
#line 180
  umask(um);
  }
#line 182
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 183
    return (-1);
  }
  {
#line 185
  tmp___1 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# This is a NcFTP spool file entry.\n");
  }
#line 185
  if (tmp___1 < 0) {
#line 186
    goto err;
  }
#line 187
  if ((unsigned long )ofp == (unsigned long )((void *)0)) {
    {
#line 187
    tmp___2 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Run the \"ncftpbatch\" program to process the spool directory.\n#\n");
    }
#line 187
    if (tmp___2 < 0) {
#line 188
      goto err;
    }
  }
  {
#line 189
  tmp___3 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"job-name=%s\n",
                    sname2);
  }
#line 189
  if (tmp___3 < 0) {
#line 190
    goto err;
  }
  {
#line 191
  tmp___4 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"op=%s\n",
                    op);
  }
#line 191
  if (tmp___4 < 0) {
#line 192
    goto err;
  }
#line 193
  if (delaySinceLastFailure != 0U) {
    {
#line 193
    tmp___5 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"delay-since-last-failure=%u\n",
                      delaySinceLastFailure);
    }
#line 193
    if (tmp___5 < 0) {
#line 194
      goto err;
    }
  }
  {
#line 195
  tmp___6 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"hostname=%s\n",
                    host);
  }
#line 195
  if (tmp___6 < 0) {
#line 196
    goto err;
  }
#line 197
  if ((unsigned long )ip != (unsigned long )((void *)0)) {
#line 197
    if ((int const   )*(ip + 0) != 0) {
      {
#line 197
      tmp___7 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"host-ip=%s\n",
                        ip);
      }
#line 197
      if (tmp___7 < 0) {
#line 198
        goto err;
      }
    }
  }
#line 199
  if (port != 0U) {
#line 199
    if (port != 21U) {
      {
#line 199
      tmp___8 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"port=%u\n",
                        port);
      }
#line 199
      if (tmp___8 < 0) {
#line 200
        goto err;
      }
    }
  }
#line 201
  if ((unsigned long )user != (unsigned long )((void *)0)) {
#line 201
    if ((int const   )*(user + 0) != 0) {
      {
#line 201
      tmp___9 = strcmp((char const   *)user, "anonymous");
      }
#line 201
      if (tmp___9 != 0) {
        {
#line 201
        tmp___10 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"user=%s\n",
                           user);
        }
#line 201
        if (tmp___10 < 0) {
#line 202
          goto err;
        }
      }
    }
  }
  {
#line 203
  tmp___15 = strcmp((char const   *)user, "anonymous");
  }
#line 203
  if (tmp___15 != 0) {
#line 203
    if ((unsigned long )passclear != (unsigned long )((void *)0)) {
#line 203
      if ((int const   )*(passclear + 0) != 0) {
        {
#line 204
        memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
               (size_t )9);
#line 205
        tmp___11 = strlen((char const   *)passclear);
#line 205
        ToBase64((void *)(pass + 9), (void const   *)passclear, tmp___11, 1);
#line 206
        tmp___12 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pass=%s\n",
                           pass);
        }
#line 206
        if (tmp___12 < 0) {
#line 207
          goto err;
        }
      } else {
#line 203
        goto _L___0;
      }
    } else {
#line 203
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 208
    tmp___14 = strcmp((char const   *)user, "anonymous");
    }
#line 208
    if (tmp___14 == 0) {
#line 208
      if ((int )gLib.defaultAnonPassword[0] != 0) {
        {
#line 209
        tmp___13 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pass=%s\n",
                           gLib.defaultAnonPassword);
        }
#line 209
        if (tmp___13 < 0) {
#line 210
          goto err;
        }
      }
    }
  }
#line 212
  if ((unsigned long )xacct != (unsigned long )((void *)0)) {
#line 212
    if ((int const   )*(xacct + 0) != 0) {
      {
#line 212
      tmp___16 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"acct=%s\n",
                         xacct);
      }
#line 212
      if (tmp___16 < 0) {
#line 213
        goto err;
      }
    }
  }
  {
#line 214
  tmp___17 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"xtype=%c\n",
                     xtype);
  }
#line 214
  if (tmp___17 < 0) {
#line 215
    goto err;
  }
#line 216
  if (recursive != 0) {
#line 216
    if (recursive == 0) {
#line 216
      tmp___18 = "no";
    } else {
#line 216
      tmp___18 = "yes";
    }
    {
#line 216
    tmp___19 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"recursive=%s\n",
                       tmp___18);
    }
#line 216
    if (tmp___19 < 0) {
#line 217
      goto err;
    }
  }
#line 218
  if (deleteflag != 0) {
#line 218
    if (deleteflag == 0) {
#line 218
      tmp___20 = "no";
    } else {
#line 218
      tmp___20 = "yes";
    }
    {
#line 218
    tmp___21 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"delete=%s\n",
                       tmp___20);
    }
#line 218
    if (tmp___21 < 0) {
#line 219
      goto err;
    }
  }
  {
#line 220
  tmp___22 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"passive=%d\n",
                     passive);
  }
#line 220
  if (tmp___22 < 0) {
#line 221
    goto err;
  }
  {
#line 222
  tmp___23 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"remote-dir=%s\n",
                     rdir);
  }
#line 222
  if (tmp___23 < 0) {
#line 223
    goto err;
  }
#line 224
  if ((unsigned long )ldir == (unsigned long )((void *)0)) {
#line 224
    goto _L___1;
  } else
#line 224
  if ((int const   )*(ldir + 0) == 0) {
#line 224
    goto _L___1;
  } else {
    {
#line 224
    tmp___28 = strcmp((char const   *)ldir, ".");
    }
#line 224
    if (tmp___28 == 0) {
      _L___1: /* CIL Label */ 
      {
#line 226
      FTPGetLocalCWD(ldir2, sizeof(ldir2));
#line 227
      tmp___24 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"local-dir=%s\n",
                         ldir2);
      }
#line 227
      if (tmp___24 < 0) {
#line 228
        goto err;
      }
    } else
#line 238
    if ((int const   )*(ldir + 0) != 47) {
      {
#line 239
      FTPGetLocalCWD(ldir2, sizeof(ldir2));
#line 240
      tmp___26 = DPathCat((char **/* const  */)(& ldir3), (char const   */* const  */)(ldir2),
                          ldir, 0);
      }
#line 240
      if (tmp___26 == 0) {
        {
#line 241
        tmp___25 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"local-dir=%s\n",
                           ldir3);
        }
#line 241
        if (tmp___25 < 0) {
#line 242
          goto err;
        }
        {
#line 243
        free((void *)ldir3);
        }
      }
    } else {
      {
#line 247
      tmp___27 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"local-dir=%s\n",
                         ldir);
      }
#line 247
      if (tmp___27 < 0) {
#line 248
        goto err;
      }
    }
  }
  {
#line 250
  tmp___29 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"remote-file=%s\n",
                     rfile);
  }
#line 250
  if (tmp___29 < 0) {
#line 251
    goto err;
  }
  {
#line 252
  tmp___30 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"local-file=%s\n",
                     lfile);
  }
#line 252
  if (tmp___30 < 0) {
#line 253
    goto err;
  }
#line 254
  if ((unsigned long )manualOverrideFeatures != (unsigned long )((void *)0)) {
#line 254
    if ((int const   )*(manualOverrideFeatures + 0) != 0) {
      {
#line 255
      tmp___31 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"manual-override-features=");
      }
#line 255
      if (tmp___31 < 0) {
#line 256
        goto err;
      }
      {
#line 257
      tmp___32 = WriteSpoolLine((FILE */* const  */)fp, manualOverrideFeatures);
      }
#line 257
      if (tmp___32 < 0) {
#line 258
        goto err;
      }
    }
  }
#line 260
  if ((unsigned long )preferredLocalAddrStr != (unsigned long )((void *)0)) {
#line 260
    if ((int const   )*(preferredLocalAddrStr + 0) != 0) {
      {
#line 261
      tmp___33 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"source-address=");
      }
#line 261
      if (tmp___33 < 0) {
#line 262
        goto err;
      }
      {
#line 263
      tmp___34 = WriteSpoolLine((FILE */* const  */)fp, preferredLocalAddrStr);
      }
#line 263
      if (tmp___34 < 0) {
#line 264
        goto err;
      }
    }
  }
#line 266
  if ((unsigned long )preftpcmd != (unsigned long )((void *)0)) {
#line 266
    if ((int const   )*(preftpcmd + 0) != 0) {
      {
#line 267
      tmp___35 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pre-ftp-command=");
      }
#line 267
      if (tmp___35 < 0) {
#line 268
        goto err;
      }
      {
#line 269
      tmp___36 = WriteSpoolLine((FILE */* const  */)fp, preftpcmd);
      }
#line 269
      if (tmp___36 < 0) {
#line 270
        goto err;
      }
    }
  }
#line 272
  if ((unsigned long )perfileftpcmd != (unsigned long )((void *)0)) {
#line 272
    if ((int const   )*(perfileftpcmd + 0) != 0) {
      {
#line 273
      tmp___37 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"per-file-ftp-command=");
      }
#line 273
      if (tmp___37 < 0) {
#line 274
        goto err;
      }
      {
#line 275
      tmp___38 = WriteSpoolLine((FILE */* const  */)fp, perfileftpcmd);
      }
#line 275
      if (tmp___38 < 0) {
#line 276
        goto err;
      }
    }
  }
#line 278
  if ((unsigned long )postftpcmd != (unsigned long )((void *)0)) {
#line 278
    if ((int const   )*(postftpcmd + 0) != 0) {
      {
#line 279
      tmp___39 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"post-ftp-command=");
      }
#line 279
      if (tmp___39 < 0) {
#line 280
        goto err;
      }
      {
#line 281
      tmp___40 = WriteSpoolLine((FILE */* const  */)fp, postftpcmd);
      }
#line 281
      if (tmp___40 < 0) {
#line 282
        goto err;
      }
    }
  }
#line 284
  if ((unsigned long )preshellcmd != (unsigned long )((void *)0)) {
#line 284
    if ((int const   )*(preshellcmd + 0) != 0) {
      {
#line 285
      tmp___41 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pre-shell-command=");
      }
#line 285
      if (tmp___41 < 0) {
#line 286
        goto err;
      }
      {
#line 287
      tmp___42 = WriteSpoolLine((FILE */* const  */)fp, preshellcmd);
      }
#line 287
      if (tmp___42 < 0) {
#line 288
        goto err;
      }
    }
  }
#line 290
  if ((unsigned long )postshellcmd != (unsigned long )((void *)0)) {
#line 290
    if ((int const   )*(postshellcmd + 0) != 0) {
      {
#line 291
      tmp___43 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"post-shell-command=");
      }
#line 291
      if (tmp___43 < 0) {
#line 292
        goto err;
      }
      {
#line 293
      tmp___44 = WriteSpoolLine((FILE */* const  */)fp, postshellcmd);
      }
#line 293
      if (tmp___44 < 0) {
#line 294
        goto err;
      }
    }
  }
#line 297
  if ((unsigned long )fp != (unsigned long )ofp) {
    {
#line 297
    tmp___45 = fclose(fp);
    }
#line 297
    if (tmp___45 < 0) {
#line 298
      goto err2;
    }
  }
#line 301
  if ((unsigned long )fp != (unsigned long )ofp) {
    {
#line 301
    tmp___46 = rename((char const   *)(spathname), (char const   *)(spathname2));
    }
#line 301
    if (tmp___46 < 0) {
      {
#line 302
      perror("rename spoolfile failed");
      }
#line 303
      goto err3;
    }
  }
#line 308
  return (0);
  err: 
#line 311
  if ((unsigned long )fp != (unsigned long )ofp) {
    {
#line 312
    fclose(fp);
    }
  }
  err2: 
  {
#line 314
  perror("write to spool file failed");
  }
  err3: 
#line 316
  if ((unsigned long )fp != (unsigned long )ofp) {
    {
#line 317
    unlink((char const   *)(spathname));
    }
  }
#line 318
  return (-1);
}
}
#line 324 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
void RunBatch(void) 
{ 
  char *argv[8] ;
  pid_t pid ;

  {
  {
#line 356
  pid = 0;
#line 369
  pid = fork();
  }
#line 370
  if (pid < 0) {
    {
#line 371
    perror("fork");
    }
  } else
#line 372
  if (pid == 0) {
    {
#line 373
    argv[0] = strdup("ncftpbatch");
#line 374
    argv[1] = strdup("-d");
#line 375
    argv[2] = (char *)((void *)0);
#line 380
    execvp((char const   *)argv[0], (char * const  *)(argv));
#line 381
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not run %s.  Is it in your $PATH?\n",
            argv[0]);
#line 383
    perror((char const   *)argv[0]);
#line 384
    exit(1);
    }
  }
#line 387
  if (pid > 1) {
    {
#line 389
    waitpid(pid, (int *)((void *)0), 0);
    }
  }
#line 395
  return;
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_chdir.c"
int FTPChdir(FTPCIPtr const   cip , char const   * const  cdCwd ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 18
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 19
    return (-139);
  }
  {
#line 20
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 20
  if (tmp) {
#line 21
    return (-138);
  }
#line 23
  if ((unsigned long )cdCwd == (unsigned long )((void *)0)) {
#line 24
    result = -122;
#line 25
    cip->errNo = -122;
  } else {
#line 27
    if ((int const   )*(cdCwd + 0) == 0) {
#line 28
      result = 2;
    } else {
      {
#line 29
      tmp___0 = strcmp((char const   *)cdCwd, "..");
      }
#line 29
      if (tmp___0 == 0) {
        {
#line 30
        result = FTPCmd(cip, (char const   */* const  */)"CDUP");
        }
      } else {
        {
#line 32
        result = FTPCmd(cip, (char const   */* const  */)"CWD %s", cdCwd);
        }
      }
    }
#line 33
    if (result >= 0) {
#line 34
      if (result == 2) {
#line 35
        result = 0;
      } else {
#line 37
        result = -125;
#line 38
        cip->errNo = -125;
      }
    }
  }
#line 42
  return (result);
}
}
#line 886 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPFileExists(FTPCIPtr const   cip , char const   * const  file ) ;
#line 887
int FTPFileModificationTime(FTPCIPtr const   cip , char const   * const  file , time_t * const  mdtm ) ;
#line 903
int FTPListToMemory2(FTPCIPtr const   cip , char const   * const  pattern , FTPLineListPtr const   llines ,
                     char const   * const  lsflags , int const   blankLines , int * const  tryMLSD ) ;
#line 912
int FTPPutFileFromMemory(FTPCIPtr const   cip , char const   * volatile  dstfile ,
                         char const   * volatile  src , size_t const   srcLen , int const   appendflag ) ;
#line 929
void InitLineList(FTPLineListPtr list ) ;
#line 931
FTPLinePtr AddLine(FTPLineListPtr list , char const   *buf1 ) ;
#line 1063
int FTPFileExistsStat(FTPCIPtr const   cip , char const   * const  file ) ;
#line 1064
int FTPFileExistsNlst(FTPCIPtr const   cip , char const   * const  file ) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_exists.c"
int FTPFileExistsStat(FTPCIPtr const   cip , char const   * const  file ) 
{ 
  int result ;
  ResponsePtr rp ;
  FTPLineList fileList ;
  char savedCwd[512] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 26
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 27
    return (-139);
  }
  {
#line 28
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 28
  if (tmp) {
#line 29
    return (-138);
  }
#line 31
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 32
    return (-139);
  }
#line 34
  if (cip->STATfileParamWorks == 0) {
#line 35
    result = -185;
#line 35
    cip->errNo = result;
#line 36
    return (result);
  }
#line 39
  if (cip->STATfileParamWorks == -1) {
    {
#line 40
    rp = InitResponse();
    }
#line 41
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 42
      result = -123;
#line 43
      cip->errNo = -123;
#line 44
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
      }
#line 45
      return (result);
    }
    {
#line 59
    result = RCmd(cip, rp, "STAT %s", "NoSuchFile");
    }
#line 60
    if (result == 2) {
#line 60
      if (rp->msg.nLines >= 3) {
#line 60
        goto _L;
      } else
#line 60
      if (rp->msg.nLines == 1) {
        _L: /* CIL Label */ 
#line 65
        if ((unsigned long )(rp->msg.first)->next != (unsigned long )((void *)0)) {
#line 65
          if ((unsigned long )((rp->msg.first)->next)->line != (unsigned long )((void *)0)) {
            {
#line 65
            tmp___0 = strstr((char const   *)((rp->msg.first)->next)->line, "o such file");
            }
#line 65
            if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 80
              result = 0;
            } else {
              {
#line 65
              tmp___1 = strstr((char const   *)((rp->msg.first)->next)->line, "ot found");
              }
#line 65
              if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 80
                result = 0;
              } else {
                {
#line 82
                cip->STATfileParamWorks = 0;
#line 83
                result = -185;
#line 83
                cip->errNo = result;
#line 84
                DoneWithResponse(cip, rp);
                }
#line 85
                return (result);
              }
            }
          } else {
            {
#line 82
            cip->STATfileParamWorks = 0;
#line 83
            result = -185;
#line 83
            cip->errNo = result;
#line 84
            DoneWithResponse(cip, rp);
            }
#line 85
            return (result);
          }
        } else {
          {
#line 82
          cip->STATfileParamWorks = 0;
#line 83
          result = -185;
#line 83
          cip->errNo = result;
#line 84
          DoneWithResponse(cip, rp);
          }
#line 85
          return (result);
        }
      }
    }
    {
#line 88
    DoneWithResponse(cip, rp);
#line 95
    tmp___2 = FTPGetCWD(cip, (char */* const  */)(savedCwd), (size_t const   )sizeof(savedCwd));
    }
#line 95
    if (tmp___2 != 0) {
#line 99
      return (cip->errNo);
    } else {
      {
#line 95
      tmp___3 = FTPChdir(cip, (char const   */* const  */)cip->startingWorkingDirectory);
      }
#line 95
      if (tmp___3 != 0) {
#line 99
        return (cip->errNo);
      }
    }
    {
#line 113
    result = FTPListToMemory2(cip, (char const   */* const  */)"", (FTPLineListPtr const   )(& fileList),
                              (char const   */* const  */)"", (int const   )0, (int */* const  */)((int *)0));
    }
#line 113
    if (result < 0) {
#line 113
      goto _L___0;
    } else
#line 113
    if ((unsigned long )fileList.last == (unsigned long )((void *)0)) {
#line 113
      goto _L___0;
    } else
#line 113
    if ((unsigned long )(fileList.last)->line == (unsigned long )((void *)0)) {
      _L___0: /* CIL Label */ 
      {
#line 119
      cip->STATfileParamWorks = 0;
#line 120
      result = -185;
#line 120
      cip->errNo = result;
#line 121
      DisposeLineListContents(& fileList);
#line 122
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
#line 123
      return (result);
    }
    {
#line 126
    rp = InitResponse();
    }
#line 127
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 128
      result = -123;
#line 129
      cip->errNo = -123;
#line 130
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 131
      DisposeLineListContents(& fileList);
#line 132
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
#line 133
      return (result);
    }
    {
#line 137
    result = RCmd(cip, rp, "STAT %s", (fileList.last)->line);
#line 138
    DisposeLineListContents(& fileList);
    }
#line 140
    if (result != 2) {
#line 140
      goto _L___2;
    } else
#line 140
    if (rp->msg.nLines == 2) {
      _L___2: /* CIL Label */ 
      {
#line 145
      cip->STATfileParamWorks = 0;
#line 146
      result = -185;
#line 146
      cip->errNo = result;
#line 147
      DoneWithResponse(cip, rp);
#line 148
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
#line 149
      return (result);
    } else
#line 150
    if ((unsigned long )(rp->msg.first)->next != (unsigned long )((void *)0)) {
#line 150
      if ((unsigned long )((rp->msg.first)->next)->line != (unsigned long )((void *)0)) {
        {
#line 150
        tmp___4 = strstr((char const   *)((rp->msg.first)->next)->line, "o such file");
        }
#line 150
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 150
          goto _L___1;
        } else {
          {
#line 150
          tmp___5 = strstr((char const   *)((rp->msg.first)->next)->line, "ot found");
          }
#line 150
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
            {
#line 159
            cip->STATfileParamWorks = 0;
#line 160
            result = -185;
#line 160
            cip->errNo = result;
#line 161
            DoneWithResponse(cip, rp);
#line 162
            FTPChdir(cip, (char const   */* const  */)(savedCwd));
            }
#line 163
            return (result);
          }
        }
      }
    }
    {
#line 165
    DoneWithResponse(cip, rp);
#line 166
    cip->STATfileParamWorks = 1;
#line 169
    FTPChdir(cip, (char const   */* const  */)(savedCwd));
    }
  }
  {
#line 172
  rp = InitResponse();
  }
#line 173
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 174
    result = -123;
#line 175
    cip->errNo = -123;
#line 176
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
    }
#line 177
    return (result);
  }
  {
#line 180
  result = RCmd(cip, rp, "STAT %s", file);
  }
#line 181
  if (result == 2) {
#line 182
    result = 0;
#line 183
    if (rp->msg.nLines >= 3) {
#line 183
      goto _L___3;
    } else
#line 183
    if (rp->msg.nLines == 1) {
      _L___3: /* CIL Label */ 
#line 184
      if ((unsigned long )(rp->msg.first)->next != (unsigned long )((void *)0)) {
#line 184
        if ((unsigned long )((rp->msg.first)->next)->line != (unsigned long )((void *)0)) {
          {
#line 184
          tmp___6 = strstr((char const   *)((rp->msg.first)->next)->line, "o such file");
          }
#line 184
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 192
            cip->errNo = -184;
#line 193
            result = -184;
          } else {
            {
#line 184
            tmp___7 = strstr((char const   *)((rp->msg.first)->next)->line, "ot found");
            }
#line 184
            if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 192
              cip->errNo = -184;
#line 193
              result = -184;
            } else {
#line 195
              result = 0;
            }
          }
        } else {
#line 195
          result = 0;
        }
      } else {
#line 195
        result = 0;
      }
    } else
#line 197
    if (rp->msg.nLines == 2) {
#line 198
      cip->errNo = -184;
#line 199
      result = -184;
    } else {
#line 201
      result = 0;
    }
  } else {
#line 204
    cip->errNo = -184;
#line 205
    result = -184;
  }
  {
#line 207
  DoneWithResponse(cip, rp);
  }
#line 208
  return (result);
}
}
#line 219 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_exists.c"
int FTPFileExistsNlst(FTPCIPtr const   cip , char const   * const  file ) 
{ 
  int result ;
  FTPLineList fileList ;
  FTPLineList rootFileList ;
  char savedCwd[512] ;
  int createdTempFile ;
  char const   *testFileMessage ;
  char const   *testFileName ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  FTPLinePtr tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 227
  testFileMessage = "This file was created by an FTP client program using the LibNcFTP toolkit.  A temporary file needed to be created to ensure that this directory was not empty, so that the directory could be listed with the guarantee of at least one file in the listing.\r\n\r\nYou may delete this file manually if your FTP client program does not delete it for you.\r\n";
#line 229
  testFileName = "testfile.ftp";
#line 231
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 232
    return (-139);
  }
  {
#line 233
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 233
  if (tmp) {
#line 234
    return (-138);
  }
#line 236
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 237
    return (-139);
  }
#line 239
  if (cip->NLSTfileParamWorks == 0) {
#line 240
    result = -187;
#line 240
    cip->errNo = result;
#line 241
    return (result);
  }
#line 244
  if (cip->NLSTfileParamWorks == -1) {
    {
#line 255
    tmp___0 = FTPListToMemory2(cip, (char const   */* const  */)"NoSuchFile", (FTPLineListPtr const   )(& fileList),
                               (char const   */* const  */)"", (int const   )0, (int */* const  */)((int *)0));
    }
#line 255
    if (tmp___0 == 0) {
#line 255
      if (fileList.nLines >= 1) {
        {
#line 255
        tmp___1 = strstr((char const   *)(fileList.last)->line, "o such file");
        }
#line 255
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
          {
#line 255
          tmp___2 = strstr((char const   *)(fileList.last)->line, "ot found");
          }
#line 255
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
#line 255
            tmp___3 = strstr((char const   *)(fileList.last)->line, "o Such File");
            }
#line 255
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
              {
#line 255
              tmp___4 = strstr((char const   *)(fileList.last)->line, "ot Found");
              }
#line 255
              if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
                {
#line 264
                cip->NLSTfileParamWorks = 0;
#line 265
                result = -187;
#line 265
                cip->errNo = result;
#line 266
                DisposeLineListContents(& fileList);
                }
#line 267
                return (result);
              }
            }
          }
        }
      }
    }
    {
#line 269
    DisposeLineListContents(& fileList);
#line 276
    tmp___5 = FTPGetCWD(cip, (char */* const  */)(savedCwd), (size_t const   )sizeof(savedCwd));
    }
#line 276
    if (tmp___5 != 0) {
#line 280
      return (cip->errNo);
    } else {
      {
#line 276
      tmp___6 = FTPChdir(cip, (char const   */* const  */)cip->startingWorkingDirectory);
      }
#line 276
      if (tmp___6 != 0) {
#line 280
        return (cip->errNo);
      }
    }
    {
#line 294
    createdTempFile = 0;
#line 295
    result = FTPListToMemory2(cip, (char const   */* const  */)"", (FTPLineListPtr const   )(& rootFileList),
                              (char const   */* const  */)"", (int const   )0, (int */* const  */)((int *)0));
    }
#line 295
    if (result < 0) {
#line 295
      goto _L;
    } else
#line 295
    if ((unsigned long )rootFileList.last == (unsigned long )((void *)0)) {
#line 295
      goto _L;
    } else
#line 295
    if ((unsigned long )(rootFileList.last)->line == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 300
      tmp___9 = AddLine(& rootFileList, testFileName);
      }
#line 300
      if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
        {
#line 305
        tmp___7 = strlen(testFileMessage);
#line 305
        tmp___8 = FTPPutFileFromMemory(cip, (char const   */* volatile  */)testFileName,
                                       (char const   */* volatile  */)testFileMessage,
                                       (size_t const   )tmp___7, (int const   )0);
        }
#line 305
        if (tmp___8 == 0) {
#line 306
          createdTempFile = 1;
        }
      }
#line 309
      if (createdTempFile == 0) {
        {
#line 311
        cip->NLSTfileParamWorks = 0;
#line 312
        result = -187;
#line 312
        cip->errNo = result;
#line 313
        DisposeLineListContents(& rootFileList);
#line 314
        FTPChdir(cip, (char const   */* const  */)(savedCwd));
        }
#line 315
        return (result);
      }
    }
    {
#line 319
    tmp___10 = FTPListToMemory2(cip, (char const   */* const  */)(rootFileList.last)->line,
                                (FTPLineListPtr const   )(& fileList), (char const   */* const  */)"",
                                (int const   )0, (int */* const  */)((int *)0));
    }
#line 319
    if (tmp___10 == 0) {
#line 319
      if (fileList.nLines >= 1) {
        {
#line 319
        tmp___11 = strstr((char const   *)(fileList.last)->line, "o such file");
        }
#line 319
        if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
          {
#line 319
          tmp___12 = strstr((char const   *)(fileList.last)->line, "ot found");
          }
#line 319
          if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
            {
#line 319
            tmp___13 = strstr((char const   *)(fileList.last)->line, "o Such File");
            }
#line 319
            if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
              {
#line 319
              tmp___14 = strstr((char const   *)(fileList.last)->line, "ot Found");
              }
#line 319
              if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 329
                if (createdTempFile != 0) {
                  {
#line 330
                  FTPDelete(cip, (char const   */* const  */)testFileName, (int const   )0,
                            (int const   )0);
                  }
                }
                {
#line 331
                DisposeLineListContents(& fileList);
#line 332
                DisposeLineListContents(& rootFileList);
#line 333
                cip->NLSTfileParamWorks = 1;
#line 336
                FTPChdir(cip, (char const   */* const  */)(savedCwd));
                }
              } else {
#line 319
                goto _L___4;
              }
            } else {
#line 319
              goto _L___4;
            }
          } else {
#line 319
            goto _L___4;
          }
        } else {
#line 319
          goto _L___4;
        }
      } else {
#line 319
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 338
      if (createdTempFile != 0) {
        {
#line 339
        FTPDelete(cip, (char const   */* const  */)testFileName, (int const   )0,
                  (int const   )0);
        }
      }
      {
#line 340
      cip->NLSTfileParamWorks = 0;
#line 341
      result = -187;
#line 341
      cip->errNo = result;
#line 342
      DisposeLineListContents(& fileList);
#line 343
      DisposeLineListContents(& rootFileList);
#line 344
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
#line 345
      return (result);
    }
  }
  {
#line 350
  InitLineList(& fileList);
#line 351
  tmp___15 = FTPListToMemory2(cip, file, (FTPLineListPtr const   )(& fileList), (char const   */* const  */)"",
                              (int const   )0, (int */* const  */)((int *)0));
  }
#line 351
  if (tmp___15 == 0) {
#line 351
    if (fileList.nLines >= 1) {
      {
#line 351
      tmp___16 = strstr((char const   *)(fileList.last)->line, "o such file");
      }
#line 351
      if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
        {
#line 351
        tmp___17 = strstr((char const   *)(fileList.last)->line, "ot found");
        }
#line 351
        if ((unsigned long )tmp___17 == (unsigned long )((void *)0)) {
          {
#line 351
          tmp___18 = strstr((char const   *)(fileList.last)->line, "o Such File");
          }
#line 351
          if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
            {
#line 351
            tmp___19 = strstr((char const   *)(fileList.last)->line, "ot Found");
            }
#line 351
            if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
#line 361
              result = 0;
            } else {
#line 363
              cip->errNo = -186;
#line 364
              result = -186;
            }
          } else {
#line 363
            cip->errNo = -186;
#line 364
            result = -186;
          }
        } else {
#line 363
          cip->errNo = -186;
#line 364
          result = -186;
        }
      } else {
#line 363
        cip->errNo = -186;
#line 364
        result = -186;
      }
    } else {
#line 363
      cip->errNo = -186;
#line 364
      result = -186;
    }
  } else {
#line 363
    cip->errNo = -186;
#line 364
    result = -186;
  }
  {
#line 367
  DisposeLineListContents(& fileList);
  }
#line 368
  return (result);
}
}
#line 381 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_exists.c"
int FTPFileExists2(FTPCIPtr const   cip , char const   * const  file , int const   tryMDTM ,
                   int const   trySIZE , int const   tryMLST , int const   trySTAT ,
                   int const   tryNLST ) 
{ 
  int result ;
  time_t mdtm ;
  long long size ;
  MLstItem mlsInfo ;

  {
#line 389
  if (tryMDTM != 0) {
    {
#line 390
    result = FTPFileModificationTime(cip, file, (time_t */* const  */)(& mdtm));
    }
#line 391
    if (result == 0) {
#line 392
      return (0);
    }
#line 393
    if (result == -146) {
#line 394
      cip->errNo = -188;
#line 395
      return (-188);
    }
  }
#line 400
  if (trySIZE != 0) {
    {
#line 401
    result = FTPFileSize(cip, file, (long long */* const  */)(& size), (int const   )'I');
    }
#line 402
    if (result == 0) {
#line 403
      return (0);
    }
  }
#line 414
  if (tryMLST != 0) {
    {
#line 415
    result = FTPMListOneFile(cip, file, (MLstItemPtr const   )(& mlsInfo));
    }
#line 416
    if (result == 0) {
#line 417
      return (0);
    }
#line 418
    if (result == -180) {
#line 419
      cip->errNo = -188;
#line 420
      return (-188);
    }
  }
#line 425
  if (trySTAT != 0) {
    {
#line 426
    result = FTPFileExistsStat(cip, file);
    }
#line 427
    if (result == 0) {
#line 428
      return (0);
    }
#line 429
    if (result == -184) {
#line 430
      cip->errNo = -188;
#line 431
      return (-188);
    }
  }
#line 436
  if (tryNLST != 0) {
    {
#line 437
    result = FTPFileExistsNlst(cip, file);
    }
#line 438
    if (result == 0) {
#line 439
      return (0);
    }
#line 440
    if (result == -186) {
#line 441
      cip->errNo = -188;
#line 442
      return (-188);
    }
  }
#line 447
  cip->errNo = -189;
#line 448
  return (-189);
}
}
#line 454 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_exists.c"
int FTPFileExists(FTPCIPtr const   cip , char const   * const  file ) 
{ 
  int tmp ;

  {
  {
#line 457
  tmp = FTPFileExists2(cip, file, (int const   )1, (int const   )1, (int const   )1,
                       (int const   )1, (int const   )1);
  }
#line 457
  return (tmp);
}
}
#line 1089 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int UnMlsT(FTPCIPtr const   cip  __attribute__((__unused__)) , char const   * const  line0 ,
           MLstItemPtr const   mlip ) ;
#line 136 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
void FTPRequestMlsOptions(FTPCIPtr const   cip ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_mlist1.c"
void FTPRequestMlsOptions(FTPCIPtr const   cip ) 
{ 
  int f ;
  char optstr[128] ;
  size_t optstrlen ;

  {
#line 20
  if (cip->usedMLS == 0) {
#line 22
    cip->usedMLS = 1;
#line 24
    f = cip->mlsFeatures & 511;
#line 25
    optstr[0] = (char )'\000';
#line 28
    if ((f & 1) != 0) {
      {
#line 29
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"type;", (size_t const   )sizeof(optstr));
      }
    }
#line 33
    if ((f & 2) != 0) {
      {
#line 34
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"size;", (size_t const   )sizeof(optstr));
      }
    }
#line 38
    if ((f & 4) != 0) {
      {
#line 39
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"modify;",
              (size_t const   )sizeof(optstr));
      }
    }
#line 43
    if ((f & 8) != 0) {
      {
#line 44
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"UNIX.mode;",
              (size_t const   )sizeof(optstr));
      }
    }
#line 48
    if ((f & 64) != 0) {
      {
#line 49
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"perm;", (size_t const   )sizeof(optstr));
      }
    }
#line 53
    if ((f & 16) != 0) {
      {
#line 54
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"UNIX.owner;",
              (size_t const   )sizeof(optstr));
      }
    }
#line 58
    if ((f & 128) != 0) {
      {
#line 59
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"UNIX.uid;",
              (size_t const   )sizeof(optstr));
      }
    }
#line 63
    if ((f & 32) != 0) {
      {
#line 64
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"UNIX.group;",
              (size_t const   )sizeof(optstr));
      }
    }
#line 68
    if ((f & 256) != 0) {
      {
#line 69
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"UNIX.gid;",
              (size_t const   )sizeof(optstr));
      }
    }
#line 73
    if ((f & 512) != 0) {
      {
#line 74
      Strncat((char */* const  */)(optstr), (char const   */* const  */)"unique;",
              (size_t const   )sizeof(optstr));
      }
    }
    {
#line 78
    optstrlen = strlen((char const   *)(optstr));
    }
#line 79
    if (optstrlen != 0UL) {
      {
#line 80
      FTPCmd(cip, (char const   */* const  */)"OPTS MLST %s", optstr);
      }
    }
  }
#line 82
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_mlist1.c"
int FTPMListOneFile(FTPCIPtr const   cip , char const   * const  file , MLstItemPtr const   mlip ) 
{ 
  int result ;
  ResponsePtr rp ;
  int tmp ;

  {
#line 101
  if (cip->hasMLST == 0) {
#line 106
    cip->errNo = -182;
#line 107
    return (cip->errNo);
  } else
#line 101
  if (cip->serverType == 2) {
#line 101
    if (cip->ietfCompatLevel < 19981201) {
#line 106
      cip->errNo = -182;
#line 107
      return (cip->errNo);
    } else {
#line 101
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 101
  if (cip->serverType == 10) {
#line 106
    cip->errNo = -182;
#line 107
    return (cip->errNo);
  }
  {
#line 110
  rp = InitResponse();
  }
#line 111
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 112
    tmp = -123;
#line 112
    cip->errNo = tmp;
#line 112
    result = tmp;
#line 113
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
    }
  } else {
    {
#line 115
    FTPRequestMlsOptions(cip);
#line 116
    result = RCmd(cip, rp, "MLST %s", file);
    }
#line 117
    if (result == 2) {
#line 117
      if ((unsigned long )(rp->msg.first)->line != (unsigned long )((void *)0)) {
#line 117
        if ((unsigned long )(rp->msg.first)->next != (unsigned long )((void *)0)) {
#line 117
          if ((unsigned long )((rp->msg.first)->next)->line != (unsigned long )((void *)0)) {
            {
#line 123
            result = UnMlsT(cip, (char const   */* const  */)((rp->msg.first)->next)->line,
                            mlip);
            }
#line 124
            if (result < 0) {
#line 125
              result = -181;
#line 125
              cip->errNo = result;
            }
          } else {
#line 117
            goto _L___2;
          }
        } else {
#line 117
          goto _L___2;
        }
      } else {
#line 117
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 127
    if (rp->code == 500) {
#line 128
      cip->hasMLST = 0;
#line 129
      cip->errNo = -182;
#line 130
      result = -182;
    } else
#line 127
    if (rp->code == 502) {
#line 128
      cip->hasMLST = 0;
#line 129
      cip->errNo = -182;
#line 130
      result = -182;
    } else
#line 127
    if (rp->code == 504) {
#line 128
      cip->hasMLST = 0;
#line 129
      cip->errNo = -182;
#line 130
      result = -182;
    } else {
#line 132
      cip->errNo = -180;
#line 133
      result = -180;
    }
    {
#line 135
    DoneWithResponse(cip, rp);
    }
  }
#line 138
  return (result);
}
}
#line 32 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/usio.h"
int MakeSockAddrUn(struct sockaddr_un *uaddr , char const   * const  sockfile ) ;
#line 42
int USendto(int sfd , char const   * const  buf , size_t size , int fl , struct sockaddr_un  const  * const  toAddr ,
            int ualen , int tlen ) ;
#line 45
int USendtoByName(int sfd , char const   * const  buf , size_t size , int fl , char const   * const  toAddrStr ,
                  int tlen ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/USendtoByName.c"
int USendtoByName(int sfd , char const   * const  buf , size_t size , int fl , char const   * const  toAddrStr ,
                  int tlen ) 
{ 
  struct sockaddr_un toAddr ;
  int ualen ;
  int result ;
  int *tmp ;
  int tmp___0 ;

  {
#line 15
  if ((unsigned long )toAddrStr == (unsigned long )((void *)0)) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  } else
#line 15
  if ((int const   )*(toAddrStr + 0) == 0) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  } else
#line 15
  if (size == 0UL) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  } else
#line 15
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  }
  {
#line 20
  tmp___0 = MakeSockAddrUn(& toAddr, toAddrStr);
#line 20
  ualen = tmp___0;
#line 21
  result = USendto(sfd, buf, size, fl, (struct sockaddr_un  const  */* const  */)(& toAddr),
                   ualen, tlen);
  }
#line 22
  return (result);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 174 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 235 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SRecvfrom(int sfd , char * const  buf , size_t size , int fl , struct sockaddr_in * const  fromAddr ,
              int tlen ) ;
#line 291
int sio_sigpipe_ignored_already ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SRecvfrom.c"
int SRecvfrom(int sfd , char * const  buf , size_t size , int fl , struct sockaddr_in * const  fromAddr ,
              int tlen ) 
{ 
  ssize_t nread ;
  int tleft ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  time_t done ;
  time_t now ;
  socklen_t alen ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int *tmp___2 ;
  __sighandler_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 16
  sigpipe = (void (*)(int  ))0;
#line 18
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 19
    tmp = __errno_location();
#line 19
    *tmp = 22;
    }
#line 20
    return (-1);
  } else
#line 18
  if (size == 0UL) {
    {
#line 19
    tmp = __errno_location();
#line 19
    *tmp = 22;
    }
#line 20
    return (-1);
  } else
#line 18
  if ((unsigned long )fromAddr == (unsigned long )((void *)0)) {
    {
#line 19
    tmp = __errno_location();
#line 19
    *tmp = 22;
    }
#line 20
    return (-1);
  } else
#line 18
  if (tlen <= 0) {
    {
#line 19
    tmp = __errno_location();
#line 19
    *tmp = 22;
    }
#line 20
    return (-1);
  }
  {
#line 23
  time(& now);
#line 24
  done = now + (time_t )tlen;
  }
#line 25
  if (done > now) {
#line 25
    tleft = (int )(done - now);
  } else {
#line 25
    tleft = 0;
  }
#line 26
  nread = (ssize_t )0;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    alen = (socklen_t )sizeof(struct sockaddr_in );
    {
#line 30
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 31
      tmp___0 = __errno_location();
#line 31
      *tmp___0 = 0;
      }
      {
#line 32
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 32
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 32
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 37
      ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 41
      tv.tv_sec = (__time_t )((long long )tleft);
#line 42
      tv.tv_usec = (__suseconds_t )0;
#line 43
      result = select(sfd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 44
      if (result >= 1) {
#line 46
        goto while_break___0;
      } else
#line 47
      if (result == 0) {
        {
#line 49
        tmp___1 = __errno_location();
#line 49
        *tmp___1 = 110;
        }
#line 51
        return (-2);
      } else {
        {
#line 52
        tmp___2 = __errno_location();
        }
#line 52
        if (*tmp___2 != 4) {
#line 53
          return (-1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 57
    if (sio_sigpipe_ignored_already) {
#line 57
      sigpipe = (void (*)(int  ))0;
    } else {
      {
#line 57
      tmp___3 = signal(13, (void (*)(int  ))1);
#line 57
      sigpipe = tmp___3;
      }
    }
    {
#line 58
    nread = recvfrom(sfd, (void */* __restrict  */)buf, size, fl, (struct sockaddr */* __restrict  */)((struct sockaddr *)fromAddr),
                     (socklen_t */* __restrict  */)(& alen));
    }
#line 60
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 60
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
        {
#line 60
        signal(13, sigpipe);
        }
      }
    }
#line 62
    if (nread >= 0L) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___4 = __errno_location();
    }
#line 64
    if (*tmp___4 != 4) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp___5 = __errno_location();
#line 66
    *tmp___5 = 0;
#line 67
    time(& now);
    }
#line 68
    if (done > now) {
#line 68
      tleft = (int )(done - now);
    } else {
#line 68
      tleft = 0;
    }
#line 69
    if (tleft < 1) {
      {
#line 70
      nread = (ssize_t )-2;
#line 71
      tmp___6 = __errno_location();
#line 71
      *tmp___6 = 110;
      }
#line 73
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return ((int )nread);
}
}
#line 876 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPChmod(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  mode ,
             int const   doGlob ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_chmod.c"
int FTPChmod(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  mode ,
             int const   doGlob ) 
{ 
  FTPLineList fileList ;
  FTPLinePtr filePtr ;
  char *file ;
  int onceResult ;
  int batchResult ;
  int tmp ;

  {
#line 21
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 22
    return (-139);
  }
  {
#line 23
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 23
  if (tmp) {
#line 24
    return (-138);
  }
  {
#line 26
  batchResult = FTPRemoteGlob((FTPCIPtr )cip, & fileList, (char const   *)pattern,
                              (int )doGlob);
  }
#line 27
  if (batchResult != 0) {
#line 28
    return (batchResult);
  }
#line 30
  batchResult = 0;
#line 30
  filePtr = fileList.first;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 30
      goto while_break;
    }
#line 34
    file = filePtr->line;
#line 35
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 36
      batchResult = -127;
#line 37
      cip->errNo = -127;
#line 38
      goto while_break;
    }
    {
#line 40
    onceResult = FTPCmd(cip, (char const   */* const  */)"SITE CHMOD %s %s", mode,
                        file);
    }
#line 41
    if (onceResult < 0) {
#line 42
      batchResult = onceResult;
#line 43
      goto while_break;
    }
#line 45
    if (onceResult != 2) {
#line 46
      batchResult = -142;
#line 47
      cip->errNo = -142;
    }
#line 30
    filePtr = filePtr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  DisposeLineListContents(& fileList);
  }
#line 51
  return (batchResult);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 261 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 229 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SReadline(SReadlineInfo *srl , char * const  linebuf , size_t linebufsize ) ;
#line 259
int SWaitUntilReadyForReading(int const   sfd , int const   tlen ) ;
#line 263
int SWrite(int sfd , char const   * const  buf0 , size_t size , int tlen , int swopts ) ;
#line 271
int SetSocketLinger(int const   fd , int const   l_onoff , int const   l_linger ) ;
#line 871 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void FTPAbortDataTransfer(FTPCIPtr const   cip ) ;
#line 919
void FTPShutdownHost(FTPCIPtr const   cip ) ;
#line 1005
int FTPSetStartOffset(FTPCIPtr const   cip , long long restartPt ) ;
#line 1007
int FTPSendCommandStr(FTPCIPtr const   cip , char * const  command , size_t const   siz ) ;
#line 1008
int ( /* format attribute */  FTPSendCommand)(FTPCIPtr const   cip , char const   * const  cmdspec ,
                                              va_list ap ) ;
#line 1019
int ( /* format attribute */  FTPStartDataCmd)(FTPCIPtr const   cip , int const   netMode ,
                                               int const   type , long long const   startPoint ,
                                               char const   * const  cmdspec  , ...) ;
#line 1024
int ( /* format attribute */  FTPStartDataCmd2)(FTPCIPtr const   cip , int const   netMode ,
                                                int const   type , long long const   startPoint ,
                                                char * const  cmdstr , size_t const   cmdstrSize ,
                                                char const   *variableCommandSpec 
                                                , ...) ;
#line 1029
int ( /* format attribute */  FTPStartDataCmd3)(FTPCIPtr const   cip , int const   netMode ,
                                                int const   type , long long const   startPoint0 ,
                                                char * const  cmdstr , size_t const   cmdstrSize ,
                                                char const   * const  variableCommandSpec ,
                                                va_list ap ) ;
#line 1036
void FTPUpdateIOTimer(FTPCIPtr const   cip ) ;
#line 1038
int FTPEndDataCmd(FTPCIPtr const   cip , int didXfer ) ;
#line 1040
int ( /* format attribute */  FTPCmdNoResponse)(FTPCIPtr const   cip , char const   * const  cmdspec 
                                                , ...) ;
#line 1046
int WaitResponse(FTPCIPtr const   cip , unsigned int sec ) ;
#line 1069
int BufferGets(char *buf , size_t bufsize , int inStream , char *secondaryBuf , char **secBufPtr ,
               char **secBufLimit , size_t secBufSize ) ;
#line 1092
void TraceResponse(FTPCIPtr const   cip , ResponsePtr rp ) ;
#line 1093
void PrintResponse(FTPCIPtr const   cip , FTPLineListPtr llp ) ;
#line 1096
void ReInitResponse(FTPCIPtr const   cip , ResponsePtr rp ) ;
#line 1098
int GetResponse(FTPCIPtr const   cip , ResponsePtr rp ) ;
#line 1104
void ( /* format attribute */  PrintF)(FTPCIPtr const   cip , char const   * const  fmt 
                                       , ...) ;
#line 12 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.h"
void CloseDataConnection(FTPCIPtr const   cip ) ;
#line 14
int OpenDataConnection(FTPCIPtr const   cip , int mode ) ;
#line 15
int AcceptDataConnection(FTPCIPtr const   cip ) ;
#line 17
void SendTelnetInterrupt(FTPCIPtr const   cip ) ;
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
ResponsePtr InitResponse(void) 
{ 
  ResponsePtr rp ;
  void *tmp ;

  {
  {
#line 27
  tmp = calloc((size_t )1, sizeof(Response ));
#line 27
  rp = (ResponsePtr )tmp;
  }
#line 28
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
    {
#line 29
    InitLineList(& rp->msg);
    }
  }
#line 30
  return (rp);
}
}
#line 39 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
void TraceResponse(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 
  FTPLinePtr lp ;

  {
#line 44
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 45
    lp = rp->msg.first;
#line 46
    if ((unsigned long )lp != (unsigned long )((void *)0)) {
      {
#line 47
      PrintF(cip, (char const   */* const  */)"%3d: %s\n", rp->code, lp->line);
#line 48
      lp = lp->next;
      }
      {
#line 48
      while (1) {
        while_continue: /* CIL Label */ ;
#line 48
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 48
          goto while_break;
        }
        {
#line 49
        PrintF(cip, (char const   */* const  */)"     %s\n", lp->line);
#line 48
        lp = lp->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 52
  return;
}
}
#line 58 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
void PrintResponse(FTPCIPtr const   cip , FTPLineListPtr llp ) 
{ 
  FTPLinePtr lp ;

  {
#line 63
  if ((unsigned long )llp != (unsigned long )((void *)0)) {
#line 64
    lp = llp->first;
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 64
        goto while_break;
      }
      {
#line 65
      PrintF(cip, (char const   */* const  */)"%s\n", lp->line);
#line 64
      lp = lp->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 67
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
static void SaveLastResponse(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 


  {
#line 76
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 77
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 78
    cip->lastFTPCmdResultNum = -1;
#line 79
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else
#line 80
  if ((unsigned long )rp->msg.first == (unsigned long )((void *)0)) {
    {
#line 81
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 82
    cip->lastFTPCmdResultNum = rp->code;
#line 83
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else
#line 80
  if ((unsigned long )(rp->msg.first)->line == (unsigned long )((void *)0)) {
    {
#line 81
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 82
    cip->lastFTPCmdResultNum = rp->code;
#line 83
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else {
    {
#line 85
    Strncpy((char */* const  */)(cip->lastFTPCmdResultStr), (char const   */* const  */)(rp->msg.first)->line,
            (size_t const   )sizeof(cip->lastFTPCmdResultStr));
#line 86
    cip->lastFTPCmdResultNum = rp->code;
#line 89
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
#line 92
    cip->lastFTPCmdResultLL = rp->msg;
    }
  }
#line 94
  return;
}
}
#line 98 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
void DoneWithResponse(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 


  {
#line 105
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
    {
#line 106
    TraceResponse(cip, rp);
    }
#line 107
    if ((unsigned long )cip->printResponseProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                             ResponsePtr  ))0)) {
#line 108
      if ((rp->printMode & 2) == 0) {
        {
#line 109
        (*(cip->printResponseProc))(cip, rp);
        }
      }
    }
#line 111
    if ((rp->printMode & 2) == 0) {
      {
#line 112
      SaveLastResponse(cip, rp);
      }
    } else {
      {
#line 114
      DisposeLineListContents(& rp->msg);
      }
    }
    {
#line 115
    memset((void *)rp, 0, sizeof(Response ));
#line 116
    free((void *)rp);
    }
  }
#line 118
  return;
}
}
#line 126 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
void ReInitResponse(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 


  {
#line 129
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
    {
#line 130
    TraceResponse(cip, rp);
    }
#line 131
    if ((unsigned long )cip->printResponseProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                             ResponsePtr  ))0)) {
#line 132
      if ((rp->printMode & 2) == 0) {
        {
#line 133
        (*(cip->printResponseProc))(cip, rp);
        }
      }
    }
#line 135
    if ((rp->printMode & 2) == 0) {
      {
#line 136
      SaveLastResponse(cip, rp);
      }
    } else {
      {
#line 138
      DisposeLineListContents(& rp->msg);
      }
    }
    {
#line 139
    memset((void *)rp, 0, sizeof(Response ));
    }
  }
#line 141
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int GetResponse(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 
  longstring str ;
  int eofError ;
  str16 code ;
  char *cp ;
  int continuation ;
  FTPCIPtr volatile   vcip ;
  int result ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 173
  vcip = (FTPCIPtr volatile   )cip;
#line 175
  cp = str;
#line 176
  eofError = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (cip->dataTimedOut > 0) {
      {
#line 183
      tmp = SWaitUntilReadyForReading((int const   )cip->ctrlSocketR, (int const   )0);
      }
#line 183
      if (tmp == 0) {
        {
#line 185
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not read reply from control connection -- timed out.\n");
#line 186
        FTPShutdownHost((FTPCIPtr const   )vcip);
#line 187
        cip->errNo = -193;
        }
#line 188
        return (cip->errNo);
      }
    }
    {
#line 191
    result = SReadline(& cip->ctrlSrl, (char */* const  */)(str), sizeof(str) - 1UL);
    }
#line 192
    if (result == -2) {
      {
#line 194
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not read reply from control connection -- timed out.\n");
#line 195
      FTPShutdownHost((FTPCIPtr const   )vcip);
#line 196
      cip->errNo = -193;
      }
#line 197
      return (cip->errNo);
    } else
#line 198
    if (result == 0) {
#line 200
      eofError = 1;
#line 201
      rp->hadEof = 1;
#line 202
      if (rp->eofOkay == 0) {
        {
#line 203
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote host has closed the connection.\n");
        }
      }
      {
#line 204
      FTPShutdownHost((FTPCIPtr const   )vcip);
#line 205
      cip->errNo = -158;
      }
#line 206
      return (cip->errNo);
    } else
#line 207
    if (result < 0) {
      {
#line 209
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not read reply from control connection");
#line 210
      FTPShutdownHost((FTPCIPtr const   )vcip);
#line 211
      cip->errNo = -157;
      }
#line 212
      return (cip->errNo);
    }
#line 215
    if ((int )str[0] == 10) {
      {
#line 219
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Protocol violation by server: blank line on control.\n");
      }
#line 220
      goto __Cont;
    } else
#line 215
    if ((int )str[0] == 0) {
      {
#line 219
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Protocol violation by server: blank line on control.\n");
      }
#line 220
      goto __Cont;
    }
#line 222
    if ((int )str[result - 1] == 10) {
#line 223
      str[result - 1] = (char )'\000';
    } else {
      {
#line 225
      PrintF(cip, (char const   */* const  */)"Warning: Remote line was too long: [%s]\n",
             str);
      }
    }
#line 226
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  tmp___0 = __ctype_b_loc();
  }
#line 229
  if (! ((int const   )*(*tmp___0 + (int )*cp) & 2048)) {
    {
#line 230
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Invalid reply: \"%s\"\n",
                cp);
#line 231
    cip->errNo = -157;
    }
#line 232
    return (cip->errNo);
  }
  {
#line 235
  rp->codeType = (int )*cp - 48;
#line 236
  cp += 3;
#line 237
  continuation = (int )*cp == 45;
#line 238
  tmp___1 = cp;
#line 238
  cp ++;
#line 238
  *tmp___1 = (char )'\000';
#line 239
  Strncpy((char */* const  */)(code), (char const   */* const  */)(str), (size_t const   )sizeof(code));
#line 240
  rp->code = atoi((char const   *)(code));
#line 241
  AddLine(& rp->msg, (char const   *)cp);
  }
#line 242
  if (eofError < 0) {
#line 244
    rp->hadEof = 1;
  }
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 247
    if (! continuation) {
#line 247
      goto while_break___0;
    }
    {
#line 248
    result = SReadline(& cip->ctrlSrl, (char */* const  */)(str), sizeof(str) - 1UL);
    }
#line 249
    if (result == -2) {
      {
#line 251
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not read reply from control connection -- timed out.\n");
#line 252
      FTPShutdownHost((FTPCIPtr const   )vcip);
#line 253
      cip->errNo = -193;
      }
#line 254
      return (cip->errNo);
    } else
#line 255
    if (result == 0) {
#line 257
      eofError = 1;
#line 258
      rp->hadEof = 1;
#line 259
      if (rp->eofOkay == 0) {
        {
#line 260
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote host has closed the connection.\n");
        }
      }
      {
#line 261
      FTPShutdownHost((FTPCIPtr const   )vcip);
#line 262
      cip->errNo = -158;
      }
#line 263
      return (cip->errNo);
    } else
#line 264
    if (result < 0) {
      {
#line 266
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not read reply from control connection");
#line 267
      FTPShutdownHost((FTPCIPtr const   )vcip);
#line 268
      cip->errNo = -157;
      }
#line 269
      return (cip->errNo);
    }
#line 272
    if ((int )str[result - 1] == 10) {
#line 273
      str[result - 1] = (char )'\000';
    }
    {
#line 274
    cp = str;
#line 275
    tmp___2 = strncmp((char const   *)(code), (char const   *)cp, (size_t )3);
    }
#line 275
    if (tmp___2 == 0) {
#line 276
      cp += 3;
#line 277
      if ((int )*cp != 45) {
#line 278
        continuation = 0;
      }
#line 279
      cp ++;
    }
    {
#line 281
    AddLine(& rp->msg, (char const   *)cp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 284
  if (rp->code == 421) {
#line 290
    if (rp->eofOkay == 0) {
      {
#line 291
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote host has closed the connection.\n");
      }
    }
    {
#line 292
    FTPShutdownHost((FTPCIPtr const   )vcip);
#line 293
    cip->errNo = -158;
    }
#line 294
    return (cip->errNo);
  }
  {
#line 297
  gettimeofday((struct timeval */* __restrict  */)(& cip->lastCmdFinish), (__timezone_ptr_t )((void *)0));
  }
#line 298
  return (0);
}
}
#line 308 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int FTPSendCommandStr(FTPCIPtr const   cip , char * const  command , size_t const   siz ) 
{ 
  int result ;
  size_t clen ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 315
  if (cip->ctrlSocketW == -1) {
#line 316
    cip->errNo = -159;
#line 317
    return (-159);
  }
  {
#line 320
  clen = strlen((char const   *)command);
  }
#line 321
  if (clen == 0UL) {
#line 322
    return (-139);
  }
#line 324
  cp = (char *)((command + clen) - 1);
#line 325
  if ((int )*cp == 10) {
#line 326
    *cp = (char )'\000';
#line 327
    if (clen <= 2UL) {
#line 328
      return (-139);
    }
#line 329
    cp --;
#line 329
    if ((int )*cp == 13) {
#line 330
      *cp = (char )'\000';
    } else {
#line 335
      cp ++;
    }
  } else {
#line 338
    cp ++;
  }
  {
#line 341
  tmp = strncmp((char const   *)command, "PASS", (size_t )4);
  }
#line 341
  if (tmp != 0) {
    {
#line 342
    PrintF(cip, (char const   */* const  */)"Cmd: %s\n", command);
    }
  } else {
    {
#line 341
    tmp___0 = strcmp((char const   *)(cip->user), "anonymous");
    }
#line 341
    if (tmp___0 == 0) {
#line 341
      if (cip->firewallType == 0) {
        {
#line 342
        PrintF(cip, (char const   */* const  */)"Cmd: %s\n", command);
        }
      } else {
        {
#line 344
        PrintF(cip, (char const   */* const  */)"Cmd: %s\n", "PASS xxxxxxxx");
        }
      }
    } else {
      {
#line 344
      PrintF(cip, (char const   */* const  */)"Cmd: %s\n", "PASS xxxxxxxx");
      }
    }
  }
#line 346
  if ((unsigned long )(cp + 2) >= (unsigned long )((command + siz) - 1)) {
#line 348
    return (-139);
  }
  {
#line 351
  tmp___1 = cp;
#line 351
  cp ++;
#line 351
  *tmp___1 = (char )'\r';
#line 352
  tmp___2 = cp;
#line 352
  cp ++;
#line 352
  *tmp___2 = (char )'\n';
#line 353
  *cp = (char )'\000';
#line 355
  cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 356
  cip->lastFTPCmdResultNum = -1;
#line 358
  tmp___3 = strlen((char const   *)command);
#line 358
  result = SWrite(cip->ctrlSocketW, (char const   */* const  */)command, tmp___3,
                  (int )cip->ctrlTimeout, 0);
  }
#line 360
  if (result < 0) {
    {
#line 361
    cip->errNo = -135;
#line 362
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not write to control stream.\n");
    }
#line 363
    return (cip->errNo);
  }
#line 365
  return (0);
}
}
#line 371 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  FTPSendCommand)(FTPCIPtr const   cip , char const   * const  cmdspec ,
                                              va_list ap ) 
{ 
  longstring command ;
  int tmp ;

  {
  {
#line 377
  vsnprintf((char */* __restrict  */)(command), sizeof(command) - 1UL, (char const   */* __restrict  */)cmdspec,
            ap);
#line 378
  command[sizeof(command) - 1UL] = (char )'\000';
#line 382
  tmp = FTPSendCommandStr(cip, (char */* const  */)(command), (size_t const   )sizeof(command));
  }
#line 382
  return (tmp);
}
}
#line 393 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  FTPCmd)(FTPCIPtr const   cip , char const   * const  cmdspec 
                                      , ...) 
{ 
  va_list ap ;
  int result ;
  ResponsePtr rp ;
  int tmp ;

  {
#line 400
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 401
    return (-139);
  }
  {
#line 402
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 402
  if (tmp) {
#line 403
    return (-138);
  }
  {
#line 405
  rp = InitResponse();
  }
#line 406
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 407
    result = -123;
#line 408
    cip->errNo = -123;
#line 409
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
    }
#line 410
    return (cip->errNo);
  }
  {
#line 413
  __builtin_va_start(ap, cmdspec);
#line 414
  result = FTPSendCommand(cip, cmdspec, ap);
#line 415
  __builtin_va_end(ap);
  }
#line 416
  if (result < 0) {
#line 417
    return (result);
  }
  {
#line 421
  result = GetResponse(cip, rp);
  }
#line 423
  if (result == 0) {
#line 424
    result = rp->codeType;
  }
  {
#line 426
  DoneWithResponse(cip, rp);
  }
#line 427
  return (result);
}
}
#line 435 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  FTPCmdNoResponse)(FTPCIPtr const   cip , char const   * const  cmdspec 
                                                , ...) 
{ 
  va_list ap ;
  int tmp ;

  {
#line 440
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 441
    return (-139);
  }
  {
#line 442
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 442
  if (tmp) {
#line 443
    return (-138);
  }
  {
#line 445
  __builtin_va_start(ap, cmdspec);
#line 446
  FTPSendCommand(cip, cmdspec, ap);
#line 447
  __builtin_va_end(ap);
  }
#line 449
  return (0);
}
}
#line 455 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int WaitResponse(FTPCIPtr const   cip , unsigned int sec ) 
{ 
  int result ;
  fd_set ss ;
  struct timeval tv ;
  int fd ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 463
  fd = cip->ctrlSocketR;
#line 464
  if (fd < 0) {
#line 465
    return (-1);
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ss.__fds_bits[0]): "memory");
#line 466
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  ss.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 475
  tv.tv_sec = (__time_t )((long long )sec);
#line 476
  tv.tv_usec = (__suseconds_t )0;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 478
    tmp = __errno_location();
#line 478
    *tmp = 0;
#line 479
    result = select(fd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 477
    if (result < 0) {
      {
#line 477
      tmp___0 = __errno_location();
      }
#line 477
      if (! (*tmp___0 == 4)) {
#line 477
        goto while_break___0;
      }
    } else {
#line 477
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 481
  return (result);
}
}
#line 493 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  RCmd)(FTPCIPtr const   cip , ResponsePtr rp , char const   *cmdspec 
                                    , ...) 
{ 
  va_list ap ;
  int result ;
  int tmp ;

  {
#line 499
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 500
    return (-139);
  }
  {
#line 501
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 501
  if (tmp) {
#line 502
    return (-138);
  }
  {
#line 504
  __builtin_va_start(ap, cmdspec);
#line 505
  result = FTPSendCommand(cip, (char const   */* const  */)cmdspec, ap);
#line 506
  __builtin_va_end(ap);
  }
#line 507
  if (result < 0) {
#line 508
    return (result);
  }
  {
#line 512
  result = GetResponse(cip, rp);
  }
#line 514
  if (result == 0) {
#line 515
    result = rp->codeType;
  }
#line 517
  return (result);
}
}
#line 529 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  FTPStartDataCmd3)(FTPCIPtr const   cip , int const   netMode ,
                                                int const   type , long long const   startPoint0 ,
                                                char * const  cmdstr , size_t const   cmdstrSize ,
                                                char const   * const  variableCommandSpec ,
                                                va_list ap ) 
{ 
  int result ;
  int respCode ;
  ResponsePtr rp ;
  long long startPoint ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 535
  startPoint = (long long )startPoint0;
#line 537
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 538
    return (-139);
  }
  {
#line 539
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 539
  if (tmp) {
#line 540
    return (-138);
  }
  {
#line 542
  result = FTPSetTransferType(cip, (int )type);
  }
#line 543
  if (result < 0) {
#line 544
    return (result);
  }
  {
#line 547
  cip->cancelXfer = 0;
#line 548
  cip->canceled = 0;
#line 549
  cip->dataSocketConnected = 0;
#line 562
  result = OpenDataConnection(cip, cip->dataPortMode);
  }
#line 562
  if (result < 0) {
#line 563
    goto done;
  }
#line 566
  if (startPoint != 0LL) {
#line 567
    if (startPoint == -1LL) {
#line 568
      startPoint = 0LL;
    } else {
      {
#line 569
      tmp___1 = FTPSetStartOffset(cip, startPoint);
      }
#line 569
      if (tmp___1 != 0) {
#line 571
        if ((unsigned long )cmdstr != (unsigned long )((void *)0)) {
          {
#line 571
          tmp___0 = strncasecmp((char const   *)cmdstr, "STOR ", (size_t )5);
          }
#line 571
          if (tmp___0 == 0) {
            {
#line 572
            memcpy((void */* __restrict  */)cmdstr, (void const   */* __restrict  */)"APPE ",
                   (size_t )5);
            }
          } else {
#line 574
            startPoint = 0LL;
          }
        } else {
#line 574
          startPoint = 0LL;
        }
      }
    }
  }
#line 578
  cip->startPoint = startPoint;
#line 584
  if ((unsigned long )cmdstr != (unsigned long )((void *)0)) {
#line 584
    if ((int )*(cmdstr + 0) != 0) {
      {
#line 585
      result = FTPSendCommandStr(cip, cmdstr, cmdstrSize);
      }
    } else {
#line 584
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 586
  if ((unsigned long )variableCommandSpec != (unsigned long )((void *)0)) {
#line 586
    if ((int const   )*(variableCommandSpec + 0) != 0) {
      {
#line 587
      result = FTPSendCommand(cip, variableCommandSpec, ap);
      }
    } else {
#line 589
      result = -139;
    }
  } else {
#line 589
    result = -139;
  }
#line 591
  if (result < 0) {
#line 592
    goto done;
  }
  {
#line 602
  rp = InitResponse();
  }
#line 603
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 604
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 605
    cip->errNo = -123;
#line 606
    result = cip->errNo;
    }
#line 607
    goto done;
  }
  {
#line 610
  result = GetResponse(cip, rp);
  }
#line 611
  if (result < 0) {
#line 612
    goto done;
  }
  {
#line 614
  respCode = rp->codeType;
#line 615
  DoneWithResponse(cip, rp);
  }
#line 617
  if (respCode > 2) {
#line 617
    if ((unsigned long )cmdstr != (unsigned long )((void *)0)) {
      {
#line 617
      tmp___2 = strncasecmp((char const   *)cmdstr, "STOR ", (size_t )5);
      }
#line 617
      if (tmp___2 == 0) {
#line 617
        if (startPoint != 0LL) {
          {
#line 619
          FTPCmd(cip, (char const   */* const  */)"REST 0");
#line 620
          memcpy((void */* __restrict  */)cmdstr, (void const   */* __restrict  */)"APPE ",
                 (size_t )5);
#line 621
          result = FTPSendCommandStr(cip, cmdstr, cmdstrSize);
#line 623
          rp = InitResponse();
          }
#line 624
          if ((unsigned long )rp == (unsigned long )((void *)0)) {
            {
#line 625
            FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 626
            cip->errNo = -123;
#line 627
            result = cip->errNo;
            }
#line 628
            goto done;
          }
          {
#line 631
          result = GetResponse(cip, rp);
          }
#line 632
          if (result < 0) {
#line 633
            goto done;
          }
          {
#line 635
          respCode = rp->codeType;
#line 636
          DoneWithResponse(cip, rp);
          }
        }
      }
    }
  }
#line 639
  if (respCode > 2) {
#line 640
    cip->errNo = -160;
#line 641
    result = cip->errNo;
#line 642
    goto done;
  }
  {
#line 648
  cip->netMode = (int )netMode;
#line 649
  result = AcceptDataConnection(cip);
  }
#line 649
  if (result < 0) {
#line 650
    goto done;
  }
#line 652
  cip->dataSocketConnected = 1;
#line 655
  if (cip->shutdownUnusedSideOfSockets != 0) {
#line 656
    if (netMode == 65) {
#line 656
      tmp___3 = 1;
    } else {
#line 656
      tmp___3 = 0;
    }
    {
#line 656
    shutdown(cip->dataSocket, tmp___3);
    }
  }
#line 658
  return (0);
  done: 
  {
#line 661
  FTPEndDataCmd(cip, 0);
  }
#line 662
  return (result);
}
}
#line 668 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  FTPStartDataCmd2)(FTPCIPtr const   cip , int const   netMode ,
                                                int const   type , long long const   startPoint ,
                                                char * const  cmdstr , size_t const   cmdstrSize ,
                                                char const   *variableCommandSpec 
                                                , ...) 
{ 
  int result ;
  va_list ap ;

  {
#line 674
  if ((unsigned long )cmdstr != (unsigned long )((void *)0)) {
#line 674
    if ((int )*(cmdstr + 0) != 0) {
      {
#line 675
      memset((void *)(& ap), 0, sizeof(ap));
#line 676
      result = FTPStartDataCmd3(cip, netMode, type, startPoint, cmdstr, cmdstrSize,
                                (char const   */* const  */)"(not used)", ap);
      }
    } else {
#line 674
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 677
  if ((unsigned long )variableCommandSpec != (unsigned long )((void *)0)) {
#line 677
    if ((int const   )*(variableCommandSpec + 0) != 0) {
      {
#line 678
      __builtin_va_start(ap, variableCommandSpec);
#line 679
      result = FTPStartDataCmd3(cip, netMode, type, startPoint, (char */* const  */)((void *)0),
                                (size_t const   )0, (char const   */* const  */)variableCommandSpec,
                                ap);
#line 680
      __builtin_va_end(ap);
      }
    } else {
#line 682
      result = -139;
    }
  } else {
#line 682
    result = -139;
  }
#line 685
  return (result);
}
}
#line 692 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int ( /* format attribute */  FTPStartDataCmd)(FTPCIPtr const   cip , int const   netMode ,
                                               int const   type , long long const   startPoint ,
                                               char const   * const  cmdspec  , ...) 
{ 
  va_list ap ;
  int rc ;

  {
  {
#line 698
  __builtin_va_start(ap, cmdspec);
#line 699
  rc = FTPStartDataCmd3(cip, netMode, type, startPoint, (char */* const  */)((void *)0),
                        (size_t const   )0, cmdspec, ap);
#line 700
  __builtin_va_end(ap);
  }
#line 701
  return (rc);
}
}
#line 707 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
void FTPAbortDataTransfer(FTPCIPtr const   cip ) 
{ 
  ResponsePtr rp ;
  int result ;
  unsigned int abto1 ;
  unsigned int abto2 ;
  int closed ;

  {
#line 713
  closed = 0;
#line 715
  if (cip->dataSocket != -1) {
    {
#line 716
    PrintF(cip, (char const   */* const  */)"Starting abort sequence.\n");
#line 717
    cip->canceling = 1;
#line 718
    FTPUpdateIOTimer(cip);
#line 719
    SendTelnetInterrupt(cip);
#line 721
    result = FTPCmdNoResponse(cip, (char const   */* const  */)"ABOR");
    }
#line 722
    if (result != 0) {
      {
#line 724
      SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
#line 725
      CloseDataConnection(cip);
#line 726
      PrintF(cip, (char const   */* const  */)"Could not send abort command.\n");
#line 727
      cip->canceling = 0;
      }
#line 728
      return;
    }
#line 731
    if (cip->abortTimeout != 0U) {
#line 732
      if (cip->abortTimeout < 4U) {
#line 733
        abto1 = 1U;
      } else
#line 734
      if (cip->abortTimeout < 6U) {
#line 735
        abto1 = 3U;
      } else {
#line 737
        abto1 = 5U;
      }
#line 739
      abto2 = cip->abortTimeout - abto1;
#line 740
      if (abto2 == 0U) {
#line 741
        abto2 = 1U;
      }
      {
#line 742
      result = WaitResponse(cip, abto1);
      }
#line 743
      if (result < 0) {
        {
#line 745
        SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
#line 746
        CloseDataConnection(cip);
#line 747
        PrintF(cip, (char const   */* const  */)"Error occurred while waiting for abort reply.\n");
#line 748
        cip->canceling = 0;
        }
#line 749
        return;
      }
#line 751
      if (result == 0) {
        {
#line 752
        SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
#line 753
        PrintF(cip, (char const   */* const  */)"No response received to abort request yet; closing data connection.\n");
#line 756
        CloseDataConnection(cip);
#line 757
        closed = 1;
#line 759
        result = WaitResponse(cip, abto2);
        }
#line 760
        if (result <= 0) {
          {
#line 762
          PrintF(cip, (char const   */* const  */)"No response received to abort request yet; giving up.\n");
#line 763
          cip->canceling = 0;
          }
#line 764
          return;
        }
      }
    }
    {
#line 769
    rp = InitResponse();
    }
#line 770
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 771
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 772
      cip->errNo = -123;
#line 773
      cip->canceling = 0;
      }
#line 774
      return;
    }
    {
#line 782
    result = GetResponse(cip, rp);
    }
#line 783
    if (result < 0) {
#line 785
      if (closed == 0) {
        {
#line 786
        SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
#line 787
        CloseDataConnection(cip);
        }
      }
      {
#line 789
      PrintF(cip, (char const   */* const  */)"Invalid response to abort request.\n");
#line 790
      DoneWithResponse(cip, rp);
#line 791
      cip->canceling = 0;
      }
#line 792
      return;
    }
#line 803
    if (rp->codeType == 4) {
      {
#line 804
      ReInitResponse(cip, rp);
#line 805
      result = GetResponse(cip, rp);
      }
#line 806
      if (result < 0) {
#line 807
        if (closed == 0) {
          {
#line 808
          SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
#line 809
          CloseDataConnection(cip);
          }
        }
        {
#line 811
        PrintF(cip, (char const   */* const  */)"Invalid second abort reply.\n");
#line 812
        DoneWithResponse(cip, rp);
#line 813
        cip->canceling = 0;
        }
#line 814
        return;
      }
    }
    {
#line 817
    DoneWithResponse(cip, rp);
#line 818
    cip->canceled = 1;
    }
#line 825
    if (closed == 0) {
      {
#line 826
      SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
#line 827
      CloseDataConnection(cip);
      }
    }
    {
#line 829
    PrintF(cip, (char const   */* const  */)"Aborted successfully.\n");
    }
  }
#line 831
  cip->canceling = 0;
#line 832
  return;
}
}
#line 837 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int FTPEndDataCmd(FTPCIPtr const   cip , int didXfer ) 
{ 
  int result ;
  int respCode ;
  ResponsePtr rp ;
  int tmp ;

  {
#line 844
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 845
    return (-139);
  }
  {
#line 846
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 846
  if (tmp) {
#line 847
    return (-138);
  }
#line 849
  if (cip->canceled == 1) {
#line 851
    return (0);
  }
  {
#line 854
  CloseDataConnection(cip);
#line 855
  result = 0;
  }
#line 856
  if (didXfer) {
    {
#line 862
    rp = InitResponse();
    }
#line 863
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 864
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 865
      cip->errNo = -123;
#line 866
      result = cip->errNo;
      }
#line 867
      return (result);
    }
    {
#line 869
    result = GetResponse(cip, rp);
    }
#line 870
    if (result < 0) {
#line 871
      return (result);
    }
    {
#line 872
    respCode = rp->codeType;
#line 873
    DoneWithResponse(cip, rp);
    }
#line 874
    if (respCode != 2) {
#line 875
      cip->errNo = -161;
#line 876
      result = cip->errNo;
    } else {
#line 878
      result = 0;
    }
  }
#line 881
  return (result);
}
}
#line 887 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
int BufferGets(char *buf , size_t bufsize , int inStream , char *secondaryBuf , char **secBufPtr ,
               char **secBufLimit , size_t secBufSize ) 
{ 
  int err ;
  char *src ;
  char *dst ;
  char *dstlim ;
  int len ;
  int nr ;
  int haveEof ;
  ssize_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 896
  haveEof = 0;
#line 898
  err = 0;
#line 899
  dst = buf;
#line 900
  dstlim = (dst + bufsize) - 1;
#line 901
  src = *secBufPtr;
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 902
    if (! ((unsigned long )dst < (unsigned long )dstlim)) {
#line 902
      goto while_break;
    }
#line 903
    if ((unsigned long )src >= (unsigned long )*secBufLimit) {
      {
#line 910
      tmp = read(inStream, (void *)secondaryBuf, secBufSize);
#line 910
      nr = (int )tmp;
      }
#line 911
      if (nr == 0) {
#line 913
        haveEof = 1;
#line 914
        goto done;
      } else
#line 915
      if (nr < 0) {
#line 917
        err = -1;
#line 918
        goto done;
      }
#line 920
      *secBufPtr = secondaryBuf;
#line 921
      *secBufLimit = secondaryBuf + nr;
#line 922
      src = *secBufPtr;
#line 923
      if (nr < (int )secBufSize) {
#line 924
        *(src + nr) = (char )'\000';
      }
    }
#line 926
    if ((int )*src == 13) {
#line 927
      src ++;
    } else {
#line 929
      if ((int )*src == 10) {
#line 930
        src ++;
#line 931
        goto done;
      }
#line 933
      tmp___0 = dst;
#line 933
      dst ++;
#line 933
      tmp___1 = src;
#line 933
      src ++;
#line 933
      *tmp___0 = *tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 938
  *secBufPtr = src;
#line 939
  *dst = (char )'\000';
#line 940
  len = (int )(dst - buf);
#line 941
  if (err < 0) {
#line 942
    return (err);
  }
#line 943
  if (len == 0) {
#line 943
    if (haveEof == 1) {
#line 944
      return (-1);
    }
  }
#line 945
  return (len);
}
}
#line 612 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 183
extern int ( __attribute__((__nonnull__(1,2,3))) readdir_r)(DIR * __restrict  __dirp ,
                                                            struct dirent * __restrict  __entry ,
                                                            struct dirent ** __restrict  __result ) ;
#line 934 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void FtwInit(FtwInfo * const  ftwip ) ;
#line 935
void FtwDispose(FtwInfo * const  ftwip ) ;
#line 936
int Ftw(struct FtwInfo * const  ftwip , char const   * const  path , int (*proc)(FtwInfoPtr const   ftwip ) ) ;
#line 937
void FtwSetBuf(struct FtwInfo * const  ftwip , char * const  buf , size_t const   bufsize ,
               int autogrow ) ;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
struct dirent *Readdir(DIR * const  dir___3 , struct dirent * const  dp , size_t const   sz ) ;
#line 103 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
struct dirent *Readdir(DIR * const  dir___3 , struct dirent * const  dp , size_t const   sz ) 
{ 
  struct dirent *p___5 ;
  int tmp ;

  {
  {
#line 124
  p___5 = (struct dirent *)((void *)0);
#line 125
  tmp = readdir_r((DIR */* __restrict  */)dir___3, (struct dirent */* __restrict  */)dp,
                  (struct dirent **/* __restrict  */)(& p___5));
  }
#line 125
  if (tmp == 0) {
#line 125
    if ((unsigned long )p___5 != (unsigned long )((void *)0)) {
#line 126
      return ((struct dirent *)dp);
    }
  }
  {
#line 141
  memset((void *)dp, 0, (size_t )sz);
  }
#line 142
  return ((struct dirent *)((void *)0));
}
}
#line 147 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
void FtwInit(FtwInfo * const  ftwip ) 
{ 


  {
  {
#line 150
  memset((void *)ftwip, 0, sizeof(FtwInfo ));
#line 155
  ftwip->dirSeparator = '/';
#line 156
  ftwip->rootDir[0] = (char )'/';
#line 158
  ftwip->init = 4063516287U;
  }
#line 159
  return;
}
}
#line 163 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
void FtwDispose(FtwInfo * const  ftwip ) 
{ 


  {
#line 166
  if (ftwip->init != 4063516287U) {
#line 167
    return;
  }
#line 168
  if (ftwip->noAutoMallocAndFree == 0) {
#line 168
    if ((unsigned long )ftwip->curPath != (unsigned long )((void *)0)) {
      {
#line 169
      free((void *)ftwip->curPath);
      }
    }
  }
  {
#line 170
  memset((void *)ftwip, 0, sizeof(FtwInfo ));
  }
#line 171
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
static int FtwTraverse(FtwInfoPtr const   ftwip , size_t dirPathLen , int depth ) 
{ 
  DIR *DIRp ;
  char *cp ;
  size_t fnLen ;
  struct dirent *dentp ;
  mode_t m ;
  char *filename ;
  char *newBuf ;
  char *path ;
  int nSubdirs ;
  FtwSubDirListPtr head ;
  FtwSubDirListPtr tail ;
  FtwSubDirListPtr sdp ;
  FtwSubDirListPtr nextsdp ;
  int rc ;
  int isRootDir ;
  char const   *tmp ;
  char *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 184
  path = ftwip->curPath;
#line 186
  head = (FtwSubDirListPtr )((void *)0);
#line 186
  tail = (FtwSubDirListPtr )((void *)0);
#line 187
  rc = -1;
#line 190
  if (dirPathLen == 1UL) {
#line 190
    if ((int )*(path + 0) == 47) {
#line 190
      isRootDir = 1;
    } else {
#line 190
      isRootDir = 0;
    }
  } else {
#line 190
    isRootDir = 0;
  }
#line 191
  if (dirPathLen) {
#line 191
    tmp = (char const   *)path;
  } else {
#line 191
    tmp = ".";
  }
  {
#line 191
  DIRp = opendir(tmp);
  }
#line 191
  if ((unsigned long )DIRp == (unsigned long )((void *)0)) {
#line 193
    return (0);
  }
#line 196
  nSubdirs = 0;
#line 197
  (ftwip->numDirs) ++;
#line 198
  ftwip->depth = (size_t )depth;
#line 199
  if (ftwip->maxDepth < ftwip->depth) {
#line 200
    ftwip->maxDepth = ftwip->depth;
  }
#line 202
  filename = path + dirPathLen;
#line 203
  if (isRootDir == 0) {
#line 204
    tmp___0 = filename;
#line 204
    filename ++;
#line 204
    *tmp___0 = (char )ftwip->dirSeparator;
#line 205
    dirPathLen ++;
  }
#line 207
  *filename = (char )'\000';
#line 210
  dentp = (struct dirent *)ftwip->direntbuf;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    tmp___1 = Readdir((DIR */* const  */)DIRp, (struct dirent */* const  */)dentp,
                      (size_t const   )ftwip->direntbufSize);
    }
#line 212
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 213
      goto while_break;
    }
#line 214
    cp = dentp->d_name;
#line 215
    if ((int )*(cp + 0) == 46) {
#line 215
      if ((int )*(cp + 1) == 0) {
#line 216
        goto __Cont;
      } else
#line 215
      if ((int )*(cp + 1) == 46) {
#line 215
        if ((int )*(cp + 2) == 0) {
#line 216
          goto __Cont;
        }
      }
    }
    {
#line 218
    *filename = (char )'\000';
#line 219
    tmp___2 = strlen((char const   *)cp);
#line 219
    fnLen = tmp___2 + 1UL;
    }
#line 220
    if (fnLen + dirPathLen > ftwip->curPathAllocSize) {
#line 221
      if (ftwip->autoGrow == 0) {
#line 222
        goto panic;
      } else
#line 223
      if (ftwip->autoGrow == -1) {
#line 224
        goto __Cont;
      }
      {
#line 226
      tmp___3 = realloc((void *)ftwip->curPath, ((fnLen + dirPathLen) + 30UL) + 2UL);
#line 226
      newBuf = (char *)tmp___3;
      }
#line 227
      if ((unsigned long )newBuf == (unsigned long )((void *)0)) {
#line 228
        goto panic;
      }
#line 229
      ftwip->curPath = newBuf;
#line 230
      ftwip->curPathAllocSize = (fnLen + dirPathLen) + 30UL;
#line 231
      path = ftwip->curPath;
#line 232
      filename = path + dirPathLen;
#line 233
      if (isRootDir == 0) {
#line 234
        tmp___4 = filename;
#line 234
        filename ++;
#line 234
        *tmp___4 = (char )ftwip->dirSeparator;
      }
#line 235
      *filename = (char )'\000';
    }
    {
#line 237
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)cp,
           fnLen);
#line 238
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 239
    ftwip->curFile = filename;
#line 240
    ftwip->curFileLen = fnLen - 1UL;
#line 241
    tmp___8 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& ftwip->curStat));
    }
#line 241
    if (tmp___8 == 0) {
#line 242
      m = ftwip->curStat.st_mode;
#line 243
      if ((m & 61440U) == 32768U) {
        {
#line 244
        (ftwip->numFiles) ++;
#line 245
        ftwip->curType = '-';
#line 246
        tmp___5 = (*(ftwip->proc))(ftwip);
        }
#line 246
        if (tmp___5 < 0) {
#line 247
          goto panic;
        }
      } else
#line 250
      if ((m & 61440U) == 40960U) {
        {
#line 251
        ftwip->curType = 'l';
#line 252
        (ftwip->numLinks) ++;
#line 253
        tmp___6 = (*(ftwip->proc))(ftwip);
        }
#line 253
        if (tmp___6 < 0) {
#line 254
          goto panic;
        }
      } else
#line 257
      if ((m & 61440U) == 16384U) {
        {
#line 264
        tmp___7 = malloc(sizeof(FtwSubDirList ) + fnLen);
#line 264
        sdp = (FtwSubDirListPtr )tmp___7;
        }
#line 265
        if ((unsigned long )sdp == (unsigned long )((void *)0)) {
#line 266
          goto panic;
        }
        {
#line 267
        memcpy((void */* __restrict  */)(& sdp->st), (void const   */* __restrict  */)(& ftwip->curStat),
               sizeof(sdp->st));
#line 268
        memcpy((void */* __restrict  */)(sdp->name), (void const   */* __restrict  */)cp,
               fnLen);
#line 269
        sdp->fnLen = fnLen;
#line 270
        sdp->next = (FtwSubDirListPtr )((void *)0);
        }
#line 271
        if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 272
          tail = sdp;
#line 272
          head = tail;
        } else {
#line 274
          tail->next = sdp;
#line 275
          tail = sdp;
        }
#line 277
        nSubdirs ++;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  closedir(DIRp);
#line 282
  DIRp = (DIR *)((void *)0);
#line 285
  sdp = head;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 285
      goto while_break___0;
    }
    {
#line 286
    nextsdp = sdp->next;
#line 287
    memcpy((void */* __restrict  */)(& ftwip->curStat), (void const   */* __restrict  */)(& sdp->st),
           sizeof(ftwip->curStat));
#line 288
    fnLen = sdp->fnLen;
#line 289
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)(sdp->name),
           fnLen);
#line 290
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 291
    ftwip->curFile = filename;
#line 292
    ftwip->curFileLen = fnLen - 1UL;
#line 293
    head = nextsdp;
#line 294
    free((void *)sdp);
#line 296
    ftwip->curType = 'd';
#line 297
    tmp___9 = (*(ftwip->proc))(ftwip);
    }
#line 297
    if (tmp___9 < 0) {
#line 298
      goto panic;
    }
    {
#line 300
    tmp___10 = FtwTraverse(ftwip, (dirPathLen + fnLen) - 1UL, depth + 1);
    }
#line 300
    if (tmp___10 < 0) {
#line 301
      goto panic;
    }
#line 306
    path = ftwip->curPath;
#line 307
    filename = path + dirPathLen;
#line 308
    *filename = (char )'\000';
#line 285
    sdp = nextsdp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  head = (FtwSubDirListPtr )((void *)0);
#line 311
  rc = 0;
  panic: 
#line 314
  if ((unsigned long )DIRp != (unsigned long )((void *)0)) {
    {
#line 315
    closedir(DIRp);
    }
  }
#line 317
  sdp = head;
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 317
      goto while_break___1;
    }
    {
#line 318
    nextsdp = sdp->next;
#line 319
    free((void *)sdp);
#line 317
    sdp = nextsdp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (rc);
}
}
#line 328 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
int Ftw(struct FtwInfo * const  ftwip , char const   * const  path , int (*proc)(FtwInfoPtr const   ftwip ) ) 
{ 
  size_t len ;
  size_t alen ;
  int rc ;
  char *cp ;
  char *endp ;
  size_t debufsize ;
  long nmx ;
  int *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
#line 334
  debufsize = (size_t )256;
#line 339
  if (ftwip->init != 4063516287U) {
    {
#line 340
    tmp = __errno_location();
#line 340
    *tmp = 22;
    }
#line 341
    return (-1);
  } else
#line 339
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 340
    tmp = __errno_location();
#line 340
    *tmp = 22;
    }
#line 341
    return (-1);
  } else
#line 339
  if ((int const   )*(path + 0) == 0) {
    {
#line 340
    tmp = __errno_location();
#line 340
    *tmp = 22;
    }
#line 341
    return (-1);
  } else
#line 339
  if ((unsigned long )proc == (unsigned long )((int (*)(FtwInfoPtr const   ftwip ))0)) {
    {
#line 340
    tmp = __errno_location();
#line 340
    *tmp = 22;
    }
#line 341
    return (-1);
  }
  {
#line 344
  ftwip->rlinkto = (char const   *)((void *)0);
#line 345
  ftwip->startPathLen = (size_t )0;
#line 346
  len = strlen((char const   *)path);
  }
#line 347
  if ((unsigned long )ftwip->curPath == (unsigned long )((void *)0)) {
#line 352
    ftwip->autoGrow = 1;
#line 353
    alen = (len + 30UL) + 2UL;
#line 354
    if (alen < 256UL) {
#line 355
      alen = (size_t )256;
    }
    {
#line 356
    tmp___0 = malloc(alen);
#line 356
    ftwip->curPath = (char *)tmp___0;
    }
#line 357
    if ((unsigned long )ftwip->curPath == (unsigned long )((void *)0)) {
#line 358
      return (-1);
    }
#line 359
    ftwip->curPathAllocSize = alen - 2UL;
  }
  {
#line 362
  ftwip->curType = 'd';
#line 363
  memset((void *)ftwip->curPath, 0, ftwip->curPathAllocSize);
#line 364
  memcpy((void */* __restrict  */)ftwip->curPath, (void const   */* __restrict  */)path,
         len + 1UL);
#line 365
  tmp___1 = strlen((char const   *)ftwip->curPath);
#line 365
  cp = ftwip->curPath + tmp___1;
#line 366
  cp --;
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if ((unsigned long )cp > (unsigned long )ftwip->curPath) {
#line 367
      if (! ((int )*cp == 47)) {
#line 367
        goto while_break;
      }
    } else {
#line 367
      goto while_break;
    }
#line 368
    tmp___2 = cp;
#line 368
    cp --;
#line 368
    *tmp___2 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  endp = cp + 1;
#line 370
  len = (size_t )(endp - ftwip->curPath);
#line 370
  tmp___3 = len;
#line 370
  ftwip->startPathLen = tmp___3;
#line 370
  ftwip->curPathLen = tmp___3;
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    if (! ((unsigned long )cp >= (unsigned long )ftwip->curPath)) {
#line 371
      goto while_break___0;
    }
#line 372
    if ((int )*cp == 47) {
#line 373
      goto while_break___0;
    }
#line 374
    cp --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 376
  cp ++;
#line 376
  ftwip->curFile = cp;
#line 377
  ftwip->curFileLen = (size_t )(endp - cp);
#line 383
  memset((void *)(& ftwip->curStat), 0, sizeof(ftwip->curStat));
#line 384
  tmp___5 = stat((char const   */* __restrict  */)ftwip->curPath, (struct stat */* __restrict  */)(& ftwip->curStat));
  }
#line 384
  if (tmp___5 < 0) {
#line 385
    return (-1);
  } else
#line 386
  if (! ((ftwip->curStat.st_mode & 61440U) == 16384U)) {
    {
#line 387
    tmp___4 = __errno_location();
#line 387
    *tmp___4 = 20;
    }
#line 388
    return (-1);
  }
  {
#line 392
  nmx = pathconf((char const   *)ftwip->curPath, 3);
  }
#line 393
  if (nmx >= 256L) {
#line 394
    debufsize = (size_t )nmx;
  }
  {
#line 396
  debufsize += sizeof(struct dirent ) + 8UL;
#line 397
  ftwip->direntbuf = calloc(debufsize, (size_t )1);
  }
#line 398
  if ((unsigned long )ftwip->direntbuf == (unsigned long )((void *)0)) {
#line 399
    return (-1);
  }
  {
#line 401
  ftwip->direntbufSize = debufsize;
#line 403
  ftwip->proc = proc;
#line 404
  tmp___6 = (*proc)(ftwip);
  }
#line 404
  if (tmp___6 < 0) {
    {
#line 405
    free(ftwip->direntbuf);
#line 406
    ftwip->direntbuf = (void *)0;
    }
#line 407
    return (-1);
  }
  {
#line 410
  tmp___10 = (size_t )0;
#line 410
  ftwip->numLinks = tmp___10;
#line 410
  tmp___9 = tmp___10;
#line 410
  ftwip->numFiles = tmp___9;
#line 410
  tmp___8 = tmp___9;
#line 410
  ftwip->numDirs = tmp___8;
#line 410
  tmp___7 = tmp___8;
#line 410
  ftwip->maxDepth = tmp___7;
#line 410
  ftwip->depth = tmp___7;
#line 411
  rc = FtwTraverse(ftwip, len, 1);
#line 414
  memset((void *)(ftwip->curPath + ftwip->startPathLen), 0, ftwip->curPathAllocSize - ftwip->startPathLen);
#line 415
  ftwip->curPathLen = ftwip->startPathLen;
#line 420
  memset((void *)(& ftwip->curStat), 0, sizeof(ftwip->curStat));
#line 421
  ftwip->proc = (int (*)(FtwInfoPtr const   ftwip ))0;
#line 422
  ftwip->curFile = ftwip->curPath;
#line 423
  ftwip->curFileLen = (size_t )0;
#line 424
  ftwip->cip = (void *)0;
#line 425
  ftwip->rlinkto = (char const   *)((void *)0);
#line 426
  free(ftwip->direntbuf);
#line 427
  ftwip->direntbuf = (void *)0;
  }
#line 429
  return (rc);
}
}
#line 435 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
void FtwSetBuf(struct FtwInfo * const  ftwip , char * const  buf , size_t const   bufsize ,
               int autogrow ) 
{ 
  void *tmp ;

  {
#line 438
  if (ftwip->init != 4063516287U) {
#line 439
    return;
  }
#line 440
  if (ftwip->noAutoMallocAndFree == 0) {
#line 440
    if ((unsigned long )ftwip->curPath != (unsigned long )((void *)0)) {
      {
#line 441
      free((void *)ftwip->curPath);
      }
    }
  }
#line 443
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 445
    ftwip->noAutoMallocAndFree = 0;
#line 446
    tmp = malloc((size_t )bufsize);
#line 446
    ftwip->curPath = (char *)tmp;
    }
#line 447
    if ((unsigned long )ftwip->curPath != (unsigned long )((void *)0)) {
#line 447
      ftwip->curPathAllocSize = (size_t )bufsize;
    } else {
#line 447
      ftwip->curPathAllocSize = (size_t )0;
    }
#line 448
    ftwip->autoGrow = autogrow;
  } else {
#line 453
    ftwip->noAutoMallocAndFree = 1;
#line 454
    ftwip->curPath = (char *)buf;
#line 455
    ftwip->curPathAllocSize = (size_t )bufsize;
#line 456
    if (autogrow == 1) {
#line 456
      ftwip->autoGrow = 0;
    } else {
#line 456
      ftwip->autoGrow = autogrow;
    }
  }
#line 458
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/usio.h"
int URecvfrom(int sfd , char * const  buf , size_t size , int fl , struct sockaddr_un * const  fromAddr ,
              int *ualen , int tlen ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/URecvfrom.c"
int URecvfrom(int sfd , char * const  buf , size_t size , int fl , struct sockaddr_un * const  fromAddr ,
              int *ualen , int tlen ) 
{ 
  ssize_t nread ;
  int tleft ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  time_t done ;
  time_t now ;
  socklen_t alen ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int *tmp___2 ;
  __sighandler_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 18
  sigpipe = (void (*)(int  ))0;
#line 20
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 21
    tmp = __errno_location();
#line 21
    *tmp = 22;
    }
#line 22
    return (-1);
  } else
#line 20
  if (size == 0UL) {
    {
#line 21
    tmp = __errno_location();
#line 21
    *tmp = 22;
    }
#line 22
    return (-1);
  } else
#line 20
  if ((unsigned long )fromAddr == (unsigned long )((void *)0)) {
    {
#line 21
    tmp = __errno_location();
#line 21
    *tmp = 22;
    }
#line 22
    return (-1);
  } else
#line 20
  if (tlen <= 0) {
    {
#line 21
    tmp = __errno_location();
#line 21
    *tmp = 22;
    }
#line 22
    return (-1);
  }
  {
#line 25
  time(& now);
#line 26
  done = now + (time_t )tlen;
  }
#line 27
  if (done > now) {
#line 27
    tleft = (int )(done - now);
  } else {
#line 27
    tleft = 0;
  }
#line 28
  nread = (ssize_t )0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    alen = (socklen_t )sizeof(struct sockaddr_un );
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 33
      tmp___0 = __errno_location();
#line 33
      *tmp___0 = 0;
      }
      {
#line 34
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 34
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 34
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 39
      ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 43
      tv.tv_sec = (__time_t )((long long )tleft);
#line 44
      tv.tv_usec = (__suseconds_t )0;
#line 45
      result = select(sfd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 46
      if (result >= 1) {
#line 48
        goto while_break___0;
      } else
#line 49
      if (result == 0) {
        {
#line 51
        tmp___1 = __errno_location();
#line 51
        *tmp___1 = 110;
        }
#line 53
        return (-2);
      } else {
        {
#line 54
        tmp___2 = __errno_location();
        }
#line 54
        if (*tmp___2 != 4) {
#line 55
          return (-1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 59
    if (sio_sigpipe_ignored_already) {
#line 59
      sigpipe = (void (*)(int  ))0;
    } else {
      {
#line 59
      tmp___3 = signal(13, (void (*)(int  ))1);
#line 59
      sigpipe = tmp___3;
      }
    }
    {
#line 60
    nread = recvfrom(sfd, (void */* __restrict  */)buf, size, fl, (struct sockaddr */* __restrict  */)((struct sockaddr *)fromAddr),
                     (socklen_t */* __restrict  */)(& alen));
    }
#line 62
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 62
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
        {
#line 62
        signal(13, sigpipe);
        }
      }
    }
#line 63
    if ((unsigned long )ualen != (unsigned long )((void *)0)) {
#line 64
      *ualen = (int )alen;
    }
#line 66
    if (nread >= 0L) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp___4 = __errno_location();
    }
#line 68
    if (*tmp___4 != 4) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp___5 = __errno_location();
#line 70
    *tmp___5 = 0;
#line 71
    time(& now);
    }
#line 72
    if (done > now) {
#line 72
      tleft = (int )(done - now);
    } else {
#line 72
      tleft = 0;
    }
#line 73
    if (tleft < 1) {
      {
#line 74
      nread = (ssize_t )-2;
#line 75
      tmp___6 = __errno_location();
#line 75
      *tmp___6 = 110;
      }
#line 77
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return ((int )nread);
}
}
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64EncodeTable___0[64]  = 
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64DecodeTable___0[256]  = 
#line 50
  {      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'>', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'?', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'@',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\002', 
        (unsigned char const   )'\003',      (unsigned char const   )'\004',      (unsigned char const   )'\005',      (unsigned char const   )'\006', 
        (unsigned char const   )'\a',      (unsigned char const   )'\b',      (unsigned char const   )'\t',      (unsigned char const   )'\n', 
        (unsigned char const   )'\v',      (unsigned char const   )'\f',      (unsigned char const   )'\r',      (unsigned char const   )'\016', 
        (unsigned char const   )'\017',      (unsigned char const   )'\020',      (unsigned char const   )'\021',      (unsigned char const   )'\022', 
        (unsigned char const   )'\023',      (unsigned char const   )'\024',      (unsigned char const   )'\025',      (unsigned char const   )'\026', 
        (unsigned char const   )'\027',      (unsigned char const   )'\030',      (unsigned char const   )'\031',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\032',      (unsigned char const   )'\033',      (unsigned char const   )'\034', 
        (unsigned char const   )'\035',      (unsigned char const   )'\036',      (unsigned char const   )'\037',      (unsigned char const   )' ', 
        (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#',      (unsigned char const   )'$', 
        (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )'\'',      (unsigned char const   )'(', 
        (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+',      (unsigned char const   )',', 
        (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/',      (unsigned char const   )'0', 
        (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177'};
#line 648 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static void CancelGetHostByName___0(int sigNum ) 
{ 
  int tmp ;

  {
#line 655
  if (sigNum != 0) {
#line 655
    tmp = 1;
  } else {
#line 655
    tmp = 0;
  }
  {
#line 655
  siglongjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), tmp);
  }
}
}
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Strnpcpy(char * const  dst , char const   * const  src , size_t n ) ;
#line 12 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strnpcpy.c"
char *Strnpcpy(char * const  dst , char const   * const  src , size_t n ) 
{ 
  register char *d ;
  register char const   *s ;
  register char c ;
  char *ret ;
  register size_t i___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 21
  d = (char *)dst;
#line 22
  if (n != 0UL) {
#line 23
    s = (char const   *)src;
#line 30
    i___0 = (size_t )1;
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;
#line 30
      if (! (i___0 < n)) {
#line 30
        goto while_break;
      }
#line 31
      tmp = s;
#line 31
      s ++;
#line 31
      c = (char )*tmp;
#line 32
      if ((int )c == 0) {
#line 33
        ret = d;
#line 34
        tmp___0 = d;
#line 34
        d ++;
#line 34
        *tmp___0 = c;
#line 40
        return (ret);
      }
#line 42
      tmp___1 = d;
#line 42
      d ++;
#line 42
      *tmp___1 = c;
#line 30
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    *d = (char )'\000';
#line 48
    return (d);
  } else {
#line 50
    *d = (char)0;
  }
#line 52
  return (d);
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int HexCharToNibble___0(int c ) 
{ 


  {
  {
#line 109
  if (c == 57) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 56) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 55) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 54) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 53) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 52) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 51) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 50) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 49) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 48) {
#line 109
    goto case_57;
  }
#line 116
  if (c == 102) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 101) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 100) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 99) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 98) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 97) {
#line 116
    goto case_102;
  }
#line 123
  if (c == 70) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 69) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 68) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 67) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 66) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 65) {
#line 123
    goto case_70;
  }
#line 99
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 110
  return (c - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 117
  return ((c - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 124
  return ((c - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
#line 127
  return (-1);
}
}
#line 495 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSortProc___0(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = strcasecmp((char const   *)(((Bookmark const   *)a)->bookmarkName), (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 498
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSearchProc___0(void const   *key , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = strcasecmp((char const   *)key, (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 506
  return (tmp);
}
}
#line 578 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static char *BmEscapeTok___0(char *dst , size_t dsize , char *src ) 
{ 
  char *dlim ;
  char *dst0 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 581
  dlim = (dst + dsize) - 1;
#line 582
  dst0 = dst;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    c = (int )*src;
#line 585
    if (! (c != 0)) {
#line 585
      goto while_break;
    }
#line 586
    src ++;
#line 587
    if (c == 92) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 44) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 36) {
      _L: /* CIL Label */ 
#line 589
      if ((unsigned long )(dst + 1) < (unsigned long )dlim) {
#line 590
        tmp = dst;
#line 590
        dst ++;
#line 590
        *tmp = (char )'\\';
#line 591
        tmp___0 = dst;
#line 591
        dst ++;
#line 591
        *tmp___0 = (char )c;
      }
    } else {
      {
#line 593
      tmp___2 = __ctype_b_loc();
      }
#line 593
      if ((int const   )*(*tmp___2 + c) & 16384) {
#line 600
        if ((unsigned long )dst < (unsigned long )dlim) {
#line 601
          tmp___1 = dst;
#line 601
          dst ++;
#line 601
          *tmp___1 = (char )c;
        }
      } else
#line 595
      if ((unsigned long )(dst + 2) < (unsigned long )dlim) {
        {
#line 596
        sprintf((char */* __restrict  */)dst, (char const   */* __restrict  */)"$%02x",
                c);
#line 597
        dst += 3;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *dst = (char )'\000';
#line 605
  return (dst0);
}
}
#line 614 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int WriteBmLine___0(Bookmark *bmp , FILE *outfp , int savePassword ) 
{ 
  char tok[256] ;
  char pass[160] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 620
  tmp = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s",
                bmp->bookmarkName);
  }
#line 620
  if (tmp < 0) {
#line 620
    return (-1);
  }
  {
#line 621
  tmp___0 = BmEscapeTok___0(tok, sizeof(tok), bmp->name);
#line 621
  tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___0);
  }
#line 621
  if (tmp___1 < 0) {
#line 621
    return (-1);
  }
  {
#line 622
  tmp___2 = BmEscapeTok___0(tok, sizeof(tok), bmp->user);
#line 622
  tmp___3 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___2);
  }
#line 622
  if (tmp___3 < 0) {
#line 622
    return (-1);
  }
#line 623
  if ((int )bmp->pass[0] != 0) {
#line 623
    if (savePassword == 1) {
      {
#line 624
      memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
             (size_t )9);
#line 625
      tmp___4 = strlen((char const   *)(bmp->pass));
#line 625
      ToBase64((void *)(pass + 9), (void const   *)(bmp->pass), tmp___4, 1);
#line 626
      tmp___5 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                        pass);
      }
#line 626
      if (tmp___5 < 0) {
#line 626
        return (-1);
      }
    } else {
#line 623
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 628
    tmp___6 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                      "");
    }
#line 628
    if (tmp___6 < 0) {
#line 628
      return (-1);
    }
  }
  {
#line 630
  tmp___7 = BmEscapeTok___0(tok, sizeof(tok), bmp->acct);
#line 630
  tmp___8 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___7);
  }
#line 630
  if (tmp___8 < 0) {
#line 630
    return (-1);
  }
  {
#line 631
  tmp___9 = BmEscapeTok___0(tok, sizeof(tok), bmp->dir);
#line 631
  tmp___10 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___9);
  }
#line 631
  if (tmp___10 < 0) {
#line 631
    return (-1);
  }
  {
#line 632
  tmp___11 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferType);
  }
#line 632
  if (tmp___11 < 0) {
#line 632
    return (-1);
  }
  {
#line 633
  tmp___12 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%u",
                     bmp->port);
  }
#line 633
  if (tmp___12 < 0) {
#line 633
    return (-1);
  }
  {
#line 634
  tmp___13 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%lu",
                     (unsigned long )bmp->lastCall);
  }
#line 634
  if (tmp___13 < 0) {
#line 634
    return (-1);
  }
  {
#line 635
  tmp___14 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasSIZE);
  }
#line 635
  if (tmp___14 < 0) {
#line 635
    return (-1);
  }
  {
#line 636
  tmp___15 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasMDTM);
  }
#line 636
  if (tmp___15 < 0) {
#line 636
    return (-1);
  }
  {
#line 637
  tmp___16 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasPASV);
  }
#line 637
  if (tmp___16 < 0) {
#line 637
    return (-1);
  }
  {
#line 638
  tmp___17 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->isUnix);
  }
#line 638
  if (tmp___17 < 0) {
#line 638
    return (-1);
  }
  {
#line 639
  tmp___18 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     bmp->lastIP);
  }
#line 639
  if (tmp___18 < 0) {
#line 639
    return (-1);
  }
  {
#line 640
  tmp___19 = BmEscapeTok___0(tok, sizeof(tok), bmp->comment);
#line 640
  tmp___20 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___19);
  }
#line 640
  if (tmp___20 < 0) {
#line 640
    return (-1);
  }
  {
#line 641
  tmp___21 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 641
  if (tmp___21 < 0) {
#line 641
    return (-1);
  }
  {
#line 642
  tmp___22 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 642
  if (tmp___22 < 0) {
#line 642
    return (-1);
  }
  {
#line 643
  tmp___23 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 643
  if (tmp___23 < 0) {
#line 643
    return (-1);
  }
  {
#line 644
  tmp___24 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 644
  if (tmp___24 < 0) {
#line 644
    return (-1);
  }
  {
#line 645
  tmp___25 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferMode);
  }
#line 645
  if (tmp___25 < 0) {
#line 645
    return (-1);
  }
  {
#line 646
  tmp___26 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasUTIME);
  }
#line 646
  if (tmp___26 < 0) {
#line 646
    return (-1);
  }
  {
#line 647
  tmp___27 = BmEscapeTok___0(tok, sizeof(tok), bmp->ldir);
#line 647
  tmp___28 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___27);
  }
#line 647
  if (tmp___28 < 0) {
#line 647
    return (-1);
  }
  {
#line 648
  tmp___29 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n");
  }
#line 648
  if (tmp___29 < 0) {
#line 648
    return (-1);
  }
  {
#line 649
  tmp___30 = fflush(outfp);
  }
#line 649
  if (tmp___30 < 0) {
#line 649
    return (-1);
  }
#line 650
  return (0);
}
}
#line 655 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int SwapBookmarkFiles___0(void) 
{ 
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 661
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 662
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 666
  tmp = getpid();
#line 666
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 667
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 669
  remove((char const   *)(path2));
#line 670
  tmp___0 = rename((char const   *)(pathName), (char const   *)(path2));
  }
#line 670
  if (tmp___0 < 0) {
#line 671
    return (-1);
  }
#line 673
  return (0);
}
}
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty1___0  =    1;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty2___0  =    1;
#line 78 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___1  ;
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___1  ;
#line 183 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___2  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uTotal___0  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___2  ;
#line 542 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gUsrBinFTPCommands___0[25]  = 
#line 542
  {      "cd ..",      "cd",      "mkdir",      "md", 
        "rmdir",      "rm",      "del",      "delete", 
        "ascii",      "binary",      "bye",      "quit", 
        "exit",      "close",      "dir",      "ls", 
        "mls",      "chmod",      "chown",      "chgrp", 
        "pwd",      "quote",      "ln -s",      "umask", 
        (char const   *)((void *)0)};
#line 570 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gValidFTPProtocolCommands___0[25]  = 
#line 570
  {      "CDUP",      "CWD",      "MKD",      "MKD", 
        "RMD",      "DELE",      "DELE",      "DELE", 
        "TYPE A",      "TYPE I",      "QUIT",      "QUIT", 
        "QUIT",      "QUIT",      "STAT",      "STAT", 
        "MLST",      "SITE CHMOD",      "SITE CHOWN",      "SITE CHGRP", 
        "PWD",      "",      "SITE SYMLINK",      "SITE UMASK", 
        (char const   *)((void *)0)};
#line 89 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
static int WriteSpoolLine___0(FILE * const  ofp , char const   * const  line ) 
{ 
  int c ;
  char const   *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 95
  c = 0;
#line 96
  cp = (char const   *)line;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! *cp) {
#line 96
      goto while_break;
    }
#line 97
    c = (int )*cp;
#line 98
    if (c == 10) {
#line 98
      if ((int const   )*(cp + 1) != 0) {
        {
#line 99
        tmp = _IO_putc('\\', (_IO_FILE *)ofp);
        }
#line 99
        if (tmp == -1) {
#line 100
          return (-1);
        }
      }
    }
    {
#line 102
    tmp___0 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 102
    if (tmp___0 == -1) {
#line 103
      return (-1);
    }
#line 96
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (c != 10) {
    {
#line 106
    c = '\n';
#line 107
    tmp___1 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 107
    if (tmp___1 == -1) {
#line 108
      return (-1);
    }
  }
#line 110
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 74 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char const   *DStrCatList(DStr * const  dst  , ...) ;
#line 7 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrCatList.c"
char const   *DStrCatList(DStr * const  dst  , ...) 
{ 
  size_t catLen ;
  size_t allocSize ;
  size_t newLen ;
  size_t curLen ;
  size_t srcLen ;
  char *dcp ;
  char *cp ;
  char *osrc ;
  char const   *src ;
  char *recursive ;
  va_list ap ;
  char const   *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 16
  if (((long )dst->s & 1L) != 0L) {
#line 17
    return ((char const   *)((void *)0));
  } else
#line 16
  if ((dst->allocSize & 4278190095UL) != 0UL) {
#line 17
    return ((char const   *)((void *)0));
  } else
#line 16
  if ((dst->len & 4278190080UL) != 0UL) {
#line 17
    return ((char const   *)((void *)0));
  }
  {
#line 19
  osrc = dst->s;
#line 20
  recursive = (char *)((void *)0);
#line 21
  catLen = (size_t )0;
#line 22
  __builtin_va_start(ap, dst);
#line 23
  tmp = __builtin_va_arg(ap, char *);
#line 23
  src = tmp;
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 24
      goto while_break;
    }
#line 25
    if ((unsigned long )src == (unsigned long )osrc) {
#line 26
      if ((unsigned long )recursive == (unsigned long )((void *)0)) {
        {
#line 27
        recursive = strdup(src);
        }
      }
    }
    {
#line 29
    tmp___0 = strlen(src);
#line 29
    catLen += tmp___0;
#line 30
    tmp___1 = __builtin_va_arg(ap, char *);
#line 30
    src = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  __builtin_va_end(ap);
#line 34
  catLen ++;
#line 35
  curLen = dst->len;
#line 36
  newLen = catLen + curLen;
  }
#line 37
  if (newLen > 16777215UL) {
#line 38
    if ((unsigned long )recursive != (unsigned long )((void *)0)) {
      {
#line 39
      free((void *)recursive);
      }
    }
#line 40
    return ((char const   *)((void *)0));
  }
#line 42
  if (dst->allocSize < newLen) {
#line 44
    allocSize = (newLen + 16UL) & 4294967280UL;
#line 45
    if ((unsigned long )dst->s == (unsigned long )((void *)0)) {
      {
#line 46
      tmp___2 = calloc(allocSize, (size_t )1);
#line 46
      cp = (char *)tmp___2;
      }
#line 47
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 48
        if ((unsigned long )recursive != (unsigned long )((void *)0)) {
          {
#line 49
          free((void *)recursive);
          }
        }
#line 50
        return ((char const   *)((void *)0));
      }
    } else {
      {
#line 53
      tmp___3 = realloc((void *)dst->s, allocSize);
#line 53
      cp = (char *)tmp___3;
      }
#line 54
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 55
        if ((unsigned long )recursive != (unsigned long )((void *)0)) {
          {
#line 56
          free((void *)recursive);
          }
        }
#line 57
        return ((char const   *)((void *)0));
      }
      {
#line 59
      memset((void *)(cp + curLen), 0, allocSize - curLen);
      }
    }
#line 61
    dst->s = cp;
#line 62
    dst->allocSize = allocSize;
  } else {
#line 64
    cp = dst->s;
  }
  {
#line 67
  dcp = cp + curLen;
#line 68
  __builtin_va_start(ap, dst);
#line 69
  tmp___4 = __builtin_va_arg(ap, char *);
#line 69
  src = tmp___4;
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 70
      goto while_break___0;
    }
#line 71
    if ((unsigned long )src == (unsigned long )osrc) {
#line 72
      src = (char const   *)recursive;
    }
    {
#line 73
    srcLen = strlen(src);
#line 74
    memcpy((void */* __restrict  */)dcp, (void const   */* __restrict  */)src, srcLen);
#line 75
    dcp += srcLen;
#line 76
    tmp___5 = __builtin_va_arg(ap, char *);
#line 76
    src = tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 78
  __builtin_va_end(ap);
#line 79
  *dcp = (char )'\000';
#line 81
  dst->len = newLen - 1UL;
  }
#line 82
  if ((unsigned long )recursive != (unsigned long )((void *)0)) {
    {
#line 83
    free((void *)recursive);
    }
  }
#line 84
  return ((char const   *)cp);
}
}
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char const   copyright[59]  = 
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
  {      (char const   )'g',      (char const   )'l',      (char const   )'_',      (char const   )'g', 
        (char const   )'e',      (char const   )'t',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'1',      (char const   )',', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'2',      (char const   )',',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'3',      (char const   )',', 
        (char const   )' ',      (char const   )'C',      (char const   )'h',      (char const   )'r', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'e',      (char const   )'w',      (char const   )'a', 
        (char const   )'l',      (char const   )'t',      (char const   )'\000'};
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 849
extern char *getlogin(void) ;
#line 162 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 122 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
struct termios new_termios  ;
#line 122 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
struct termios old_termios  ;
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 45 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.h"
char *gl_getline(char *prompt ) ;
#line 46
void gl_dispose(void) ;
#line 47
void gl_setwidth(int w ) ;
#line 48
void gl_setheight(int w ) ;
#line 49
void gl_histadd(char const   * const  buf ) ;
#line 50
void gl_tab_completion(char *(*proc)(char const   * , int  ) ) ;
#line 51
char *gl_local_filename_completion_proc(char const   *start , int idx ) ;
#line 52
void gl_set_home_dir(char const   *homedir ) ;
#line 53
void gl_histsavefile(char const   * const  path ) ;
#line 54
void gl_histloadfile(char const   * const  path ) ;
#line 55
char *gl_getpass(char const   * const  prompt , char * const  pass , int dsize ) ;
#line 56
int gl_get_result(void) ;
#line 167 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_tab(char *buf , int offset , int *loc , size_t bufsize ) ;
#line 171 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int (*gl_in_hook)(char * )  =    (int (*)(char * ))0;
#line 172 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int (*gl_out_hook)(char * )  =    (int (*)(char * ))0;
#line 173 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int (*gl_tab_hook)(char * , int  , int * , size_t  )  =    & gl_tab;
#line 174 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
size_t (*gl_strlen)(char const   * )  =    (size_t (*)(char const   * ))(& strlen);
#line 175 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
char *(*gl_completion_proc)(char const   * , int  )  =    (char *(*)(char const   * , int  ))0;
#line 176 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int gl_filename_quoting_desired  =    -1;
#line 177 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
char const   *gl_filename_quote_characters  =    " \t*?<>|;&()[]$`";
#line 178 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int gl_ellipses_during_completion  =    1;
#line 179 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int gl_completion_exact_match_extra_char  ;
#line 180 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
char gl_buf[2048]  ;
#line 185 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_killbuf[256]  ;
#line 186 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_init_done  =    -1;
#line 187 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_termw  =    80;
#line 188 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_termh  =    24;
#line 189 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_scroll  =    27;
#line 190 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_width  =    0;
#line 191 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_extent  =    0;
#line 192 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_overwrite  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_pos  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_cnt  =    0;
#line 194 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char const   *gl_prompt  ;
#line 195 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_intrc  =    (char)0;
#line 196 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_quitc  =    (char)0;
#line 197 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_suspc  =    (char)0;
#line 198 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_dsuspc  =    (char)0;
#line 199 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_search_mode  =    0;
#line 200 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char **gl_matchlist  =    (char **)0;
#line 201 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *gl_home_dir  =    (char *)((void *)0);
#line 202 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_vi_preferred  =    -1;
#line 203 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_vi_mode  =    0;
#line 204 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_result  =    0;
#line 206
static void gl_init(void) ;
#line 207
static void gl_cleanup(void) ;
#line 208
static void gl_char_init(void) ;
#line 209
static void gl_char_cleanup(void) ;
#line 212
static void gl_addchar(int c ) ;
#line 213
static void gl_del(int loc , int killsave ) ;
#line 214
static void gl_error(char const   * const  buf ) ;
#line 215
static void gl_fixup(char const   *prompt , int change , int cursor ) ;
#line 216
static int gl_getc(void) ;
#line 217
static int gl_getcx(int tlen ) ;
#line 218
static void gl_kill(int pos ) ;
#line 219
static void gl_newline(void) ;
#line 220
static void gl_putc(int c ) ;
#line 221
static void gl_puts(char const   *buf ) ;
#line 222
static void gl_redraw(void) ;
#line 223
static void gl_transpose(void) ;
#line 224
static void gl_yank(void) ;
#line 225
static void gl_word(int direction ) ;
#line 226
static void gl_killword(int direction ) ;
#line 228
static void hist_init(void) ;
#line 229
static void hist_dispose(void) ;
#line 230
static char *hist_next(void) ;
#line 231
static char *hist_prev(void) ;
#line 232
static char *hist_save(char const   * const  p___5 ) ;
#line 234
static void search_addchar(int c ) ;
#line 235
static void search_term(void) ;
#line 236
static void search_back(int new_search ) ;
#line 237
static void search_forw(int new_search ) ;
#line 238
static void gl_beep(void) ;
#line 240
static int gl_do_tab_completion(char *buf , int *loc , size_t bufsize , int tabtab ) ;
#line 248 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_char_init(void) 
{ 
  int tmp ;

  {
  {
#line 253
  tmp = tcgetattr(0, & old_termios);
  }
#line 253
  if (tmp == 0) {
#line 254
    gl_intrc = (char )old_termios.c_cc[0];
#line 255
    gl_quitc = (char )old_termios.c_cc[1];
#line 257
    gl_suspc = (char )old_termios.c_cc[10];
  }
  {
#line 263
  new_termios = old_termios;
#line 264
  new_termios.c_iflag &= 4294962141U;
#line 265
  new_termios.c_iflag |= 5U;
#line 266
  new_termios.c_lflag &= 4294934516U;
#line 267
  new_termios.c_cc[6] = (cc_t )1;
#line 268
  new_termios.c_cc[5] = (cc_t )0;
#line 269
  tcsetattr(0, 0, (struct termios  const  *)(& new_termios));
  }
#line 297
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_char_cleanup(void) 
{ 


  {
  {
#line 304
  tcsetattr(0, 0, (struct termios  const  *)(& old_termios));
  }
#line 311
  return;
}
}
#line 315 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
int gl_get_result(void) 
{ 


  {
#line 318
  return (gl_result);
}
}
#line 373 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_getc(void) 
{ 
  int c ;
  unsigned char ch ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 383
  ch = (unsigned char )'\000';
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 384
    tmp___0 = read(0, (void *)(& ch), (size_t )1);
#line 384
    c = (int )tmp___0;
    }
#line 384
    if (! (c == -1)) {
#line 384
      goto while_break;
    }
    {
#line 385
    tmp = __errno_location();
    }
#line 385
    if (*tmp != 4) {
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  if (c != -1) {
#line 389
    c = (int )ch;
  }
#line 412
  return (c);
}
}
#line 419 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_getcx(int tlen ) 
{ 
  int c ;
  int result ;
  char ch ;
  fd_set ss ;
  struct timeval tv ;
  int *tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 430
  tmp = __errno_location();
#line 430
  *tmp = 0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 431
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 436
    ss.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 440
    tv.tv_sec = (__time_t )((long long )(tlen / 10));
#line 441
    tv.tv_usec = (__suseconds_t )((long long )((tlen % 10) * 100000));
#line 442
    result = select(1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 443
    if (result == 1) {
#line 445
      goto while_break;
    } else
#line 446
    if (result == 0) {
      {
#line 447
      tmp___0 = __errno_location();
#line 447
      *tmp___0 = 110;
      }
#line 448
      return (-2);
    } else {
      {
#line 449
      tmp___1 = __errno_location();
      }
#line 449
      if (*tmp___1 != 4) {
#line 450
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp___2 = __errno_location();
#line 454
  *tmp___2 = 0;
  }
  {
#line 454
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 455
    tmp___3 = read(0, (void *)(& ch), (size_t )1);
#line 455
    c = (int )tmp___3;
    }
#line 456
    if (c == 1) {
#line 457
      return ((int )ch);
    }
    {
#line 458
    tmp___4 = __errno_location();
    }
#line 458
    if (*tmp___4 != 4) {
#line 459
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 462
  return (-1);
}
}
#line 501 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_putc(int c ) 
{ 
  char ch ;

  {
  {
#line 504
  ch = (char )((unsigned char )c);
#line 506
  write(1, (void const   *)(& ch), (size_t )1);
  }
#line 507
  if ((int )ch == 10) {
    {
#line 508
    ch = (char )'\r';
#line 509
    write(1, (void const   *)(& ch), (size_t )1);
    }
  }
#line 511
  return;
}
}
#line 515 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_puts(char const   *buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
#line 554
  if (buf) {
    {
#line 555
    tmp = strlen(buf);
#line 555
    len = tmp;
#line 556
    write(1, (void const   *)buf, len);
    }
  }
#line 559
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_error(char const   * const  buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 564
  tmp = strlen((char const   *)buf);
#line 564
  len = tmp;
#line 566
  gl_cleanup();
#line 567
  write(2, (void const   *)buf, len);
#line 568
  exit(1);
  }
}
}
#line 571 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_init(void) 
{ 
  char const   *cp ;
  int w ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 579
  tmp = strncmp(copyright, "gl_getline", (size_t )7);
  }
#line 579
  if (tmp != 0) {
    {
#line 580
    exit(1);
    }
  }
#line 582
  if (gl_init_done < 0) {
    {
#line 583
    tmp___0 = getenv("COLUMNS");
#line 583
    cp = (char const   *)tmp___0;
    }
#line 584
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 585
      w = atoi(cp);
      }
#line 586
      if (w > 20) {
        {
#line 587
        gl_setwidth(w);
        }
      }
    }
    {
#line 589
    tmp___1 = getenv("ROWS");
#line 589
    cp = (char const   *)tmp___1;
    }
#line 590
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 591
      w = atoi(cp);
      }
#line 592
      if (w > 10) {
        {
#line 593
        gl_setheight(w);
        }
      }
    }
    {
#line 595
    hist_init();
    }
  }
  {
#line 597
  tmp___2 = isatty(0);
  }
#line 597
  if (tmp___2 == 0) {
    {
#line 598
    gl_error((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
    }
  } else {
    {
#line 597
    tmp___3 = isatty(1);
    }
#line 597
    if (tmp___3 == 0) {
      {
#line 598
      gl_error((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
      }
    }
  }
  {
#line 599
  gl_char_init();
#line 600
  gl_init_done = 1;
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_cleanup(void) 
{ 


  {
#line 607
  if (gl_init_done > 0) {
    {
#line 608
    gl_char_cleanup();
    }
  }
#line 609
  gl_init_done = 0;
#line 614
  return;
}
}
#line 616 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_dispose(void) 
{ 


  {
  {
#line 619
  gl_cleanup();
#line 620
  hist_dispose();
  }
#line 627
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_check_inputrc_for_vi(void) 
{ 
  FILE *fp ;
  char path[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 644
  gl_set_home_dir((char const   *)((void *)0));
  }
#line 645
  if ((unsigned long )gl_home_dir == (unsigned long )((void *)0)) {
#line 646
    return;
  }
  {
#line 649
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s",
           gl_home_dir, ".inputrc");
#line 657
  fp = fopen((char const   */* __restrict  */)(path), (char const   */* __restrict  */)"r");
  }
#line 666
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 667
    return;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 669
    tmp___1 = fgets((char */* __restrict  */)(path), (int )(sizeof(path) - 1UL), (FILE */* __restrict  */)fp);
    }
#line 669
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 669
      goto while_break;
    }
    {
#line 670
    tmp = strstr((char const   *)(path), "editing-mode");
    }
#line 670
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 670
      tmp___0 = strstr((char const   *)(path), "vi");
      }
#line 670
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 671
        gl_vi_preferred = 1;
#line 672
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  fclose(fp);
  }
#line 677
  return;
}
}
#line 681 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_setwidth(int w ) 
{ 


  {
#line 684
  if (w > 250) {
#line 685
    w = 250;
  }
#line 686
  if (w > 20) {
#line 687
    gl_termw = w;
#line 689
    gl_scroll = 1;
  } else {
    {
#line 691
    gl_error((char const   */* const  */)"\n*** Error: minimum screen width is 21\n");
    }
  }
#line 693
  return;
}
}
#line 697 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_setheight(int w ) 
{ 


  {
#line 700
  if (w > 10) {
#line 701
    gl_termh = w;
  } else {
    {
#line 703
    gl_error((char const   */* const  */)"\n*** Error: minimum screen height is 10\n");
    }
  }
#line 705
  return;
}
}
#line 720 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
char *gl_getline(char *prompt ) 
{ 
  int c ;
  int loc ;
  int tmp ;
  int lastch ;
  int vi_count ;
  int count ;
  int vi_delete ;
  char vi_countbuf[32] ;
  char *cp ;
  int sig ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
#line 734
  gl_result = 0;
#line 740
  gl_vi_mode = 0;
#line 741
  vi_count = 0;
#line 742
  vi_delete = 0;
#line 743
  if (gl_vi_preferred < 0) {
    {
#line 744
    gl_vi_preferred = 0;
#line 745
    tmp___0 = getenv("EDITOR");
#line 745
    cp = tmp___0;
    }
#line 746
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 747
      tmp___1 = strstr((char const   *)cp, "vi");
#line 747
      gl_vi_preferred = (unsigned long )tmp___1 != (unsigned long )((void *)0);
      }
    }
#line 748
    if (gl_vi_preferred == 0) {
      {
#line 749
      gl_check_inputrc_for_vi();
      }
    }
  }
  {
#line 752
  gl_init();
  }
#line 753
  if (prompt) {
#line 753
    gl_prompt = (char const   *)prompt;
  } else {
#line 753
    gl_prompt = "";
  }
#line 754
  gl_buf[0] = (char)0;
#line 755
  gl_killbuf[0] = (char)0;
#line 756
  if (gl_in_hook) {
    {
#line 757
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 758
  gl_fixup(gl_prompt, -2, 2048);
#line 759
  lastch = 0;
  }
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 765
    c = gl_getc();
    }
#line 765
    if (! (c != -1)) {
#line 765
      goto while_break;
    }
#line 766
    gl_extent = 0;
#line 768
    if (c != 9) {
      {
#line 768
      tmp___14 = __ctype_b_loc();
      }
#line 768
      if (((int const   )*(*tmp___14 + c) & 16384) != 0) {
#line 768
        goto _L___4;
      } else
#line 768
      if ((c & 128) != 0) {
        _L___4: /* CIL Label */ 
#line 769
        if (gl_vi_mode > 0) {
          vi: 
#line 774
          count = 0;
          {
#line 774
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 775
            tmp___3 = __ctype_b_loc();
            }
#line 775
            if ((int const   )*(*tmp___3 + c) & 2048) {
#line 776
              if ((int )vi_countbuf[sizeof(vi_countbuf) - 2UL] == 0) {
                {
#line 777
                tmp___2 = strlen((char const   *)(vi_countbuf));
#line 777
                vi_countbuf[tmp___2] = (char )c;
                }
              }
            } else
#line 778
            if ((int )vi_countbuf[0] != 0) {
              {
#line 779
              vi_count = atoi((char const   *)(vi_countbuf));
#line 780
              memset((void *)(vi_countbuf), 0, sizeof(vi_countbuf));
              }
            }
            {
#line 783
            if (c == 98) {
#line 783
              goto case_98;
            }
#line 786
            if (c == 119) {
#line 786
              goto case_119;
            }
#line 793
            if (c == 104) {
#line 793
              goto case_104;
            }
#line 804
            if (c == 108) {
#line 804
              goto case_108;
            }
#line 804
            if (c == 32) {
#line 804
              goto case_108;
            }
#line 811
            if (c == 107) {
#line 811
              goto case_107;
            }
#line 817
            if (c == 106) {
#line 817
              goto case_106;
            }
#line 823
            if (c == 100) {
#line 823
              goto case_100;
            }
#line 833
            if (c == 94) {
#line 833
              goto case_94;
            }
#line 847
            if (c == 36) {
#line 847
              goto case_36;
            }
#line 857
            if (c == 112) {
#line 857
              goto case_112;
            }
#line 861
            if (c == 80) {
#line 861
              goto case_80;
            }
#line 864
            if (c == 114) {
#line 864
              goto case_114;
            }
#line 869
            if (c == 82) {
#line 869
              goto case_82;
            }
#line 874
            if (c == 73) {
#line 874
              goto case_73;
            }
#line 874
            if (c == 105) {
#line 874
              goto case_73;
            }
#line 881
            if (c == 65) {
#line 881
              goto case_65;
            }
#line 881
            if (c == 97) {
#line 881
              goto case_65;
            }
#line 881
            if (c == 79) {
#line 881
              goto case_65;
            }
#line 881
            if (c == 111) {
#line 881
              goto case_65;
            }
#line 782
            goto switch_break;
            case_98: /* CIL Label */ 
            {
#line 784
            gl_word(-1);
            }
#line 785
            goto switch_break;
            case_119: /* CIL Label */ 
#line 787
            if (vi_delete) {
              {
#line 788
              gl_killword(1);
              }
            } else {
              {
#line 790
              gl_word(1);
              }
            }
#line 792
            goto switch_break;
            case_104: /* CIL Label */ 
#line 794
            if (vi_delete) {
#line 795
              if (gl_pos > 0) {
                {
#line 796
                gl_fixup(gl_prompt, -1, gl_pos - 1);
#line 797
                gl_del(0, 1);
                }
              }
            } else {
              {
#line 800
              gl_fixup(gl_prompt, -1, gl_pos - 1);
              }
            }
#line 802
            goto switch_break;
            case_108: /* CIL Label */ 
            case_32: /* CIL Label */ 
#line 805
            if (vi_delete) {
              {
#line 806
              gl_del(0, 1);
              }
            } else {
              {
#line 808
              gl_fixup(gl_prompt, -1, gl_pos + 1);
              }
            }
#line 810
            goto switch_break;
            case_107: /* CIL Label */ 
            {
#line 812
            tmp___4 = hist_prev();
#line 812
            strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___4);
            }
#line 813
            if (gl_in_hook) {
              {
#line 814
              (*gl_in_hook)(gl_buf);
              }
            }
            {
#line 815
            gl_fixup(gl_prompt, 0, 2048);
            }
#line 816
            goto switch_break;
            case_106: /* CIL Label */ 
            {
#line 818
            tmp___5 = hist_next();
#line 818
            strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___5);
            }
#line 819
            if (gl_in_hook) {
              {
#line 820
              (*gl_in_hook)(gl_buf);
              }
            }
            {
#line 821
            gl_fixup(gl_prompt, 0, 2048);
            }
#line 822
            goto switch_break;
            case_100: /* CIL Label */ 
#line 824
            if (vi_delete == 1) {
              {
#line 825
              gl_kill(0);
#line 826
              vi_count = 1;
#line 827
              vi_delete = 0;
#line 828
              gl_vi_mode = 0;
              }
#line 829
              goto vi_break;
            }
#line 831
            vi_delete = 1;
#line 832
            goto vi_break;
            case_94: /* CIL Label */ 
#line 834
            if (vi_delete) {
              {
#line 835
              vi_count = gl_pos;
#line 836
              gl_fixup(gl_prompt, -1, 0);
#line 837
              c = 0;
              }
              {
#line 837
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 837
                if (! (c < vi_count)) {
#line 837
                  goto while_break___1;
                }
#line 838
                if (gl_cnt > 0) {
                  {
#line 839
                  gl_del(0, 0);
                  }
                }
#line 837
                c ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 841
              vi_count = 1;
#line 842
              vi_delete = 0;
            } else {
              {
#line 844
              gl_fixup(gl_prompt, -1, 0);
              }
            }
#line 846
            goto switch_break;
            case_36: /* CIL Label */ 
#line 848
            if (vi_delete) {
              {
#line 849
              gl_kill(gl_pos);
              }
            } else {
              {
#line 851
              tmp___6 = strlen((char const   *)(gl_buf));
#line 851
              loc = (int )tmp___6;
              }
#line 852
              if (loc > 1) {
#line 853
                loc --;
              }
              {
#line 854
              gl_fixup(gl_prompt, -1, loc);
              }
            }
#line 856
            goto switch_break;
            case_112: /* CIL Label */ 
            {
#line 858
            gl_fixup(gl_prompt, -1, gl_pos + 1);
#line 859
            gl_yank();
            }
#line 860
            goto switch_break;
            case_80: /* CIL Label */ 
            {
#line 862
            gl_yank();
            }
#line 863
            goto switch_break;
            case_114: /* CIL Label */ 
            {
#line 865
            tmp___7 = gl_getc();
#line 865
            gl_buf[gl_pos] = (char )tmp___7;
#line 866
            gl_fixup(gl_prompt, gl_pos, gl_pos);
#line 867
            vi_count = 1;
            }
#line 868
            goto switch_break;
            case_82: /* CIL Label */ 
#line 870
            gl_overwrite = 1;
#line 871
            gl_vi_mode = 0;
#line 872
            goto switch_break;
            case_73: /* CIL Label */ 
            case_105: /* CIL Label */ 
#line 875
            gl_overwrite = 0;
#line 876
            gl_vi_mode = 0;
#line 877
            goto switch_break;
            case_65: /* CIL Label */ 
            case_97: /* CIL Label */ 
            case_79: /* CIL Label */ 
            case_111: /* CIL Label */ 
            {
#line 882
            gl_overwrite = 0;
#line 883
            gl_fixup(gl_prompt, -1, gl_pos + 1);
#line 884
            gl_vi_mode = 0;
            }
#line 885
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 887
            count ++;
#line 888
            if (count >= vi_count) {
#line 889
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 891
          vi_count = 1;
#line 892
          vi_delete = 0;
          vi_break: 
#line 894
          goto while_continue;
        } else
#line 895
        if (gl_search_mode) {
          {
#line 896
          search_addchar(c);
          }
        } else {
          {
#line 898
          gl_addchar(c);
          }
        }
      } else {
#line 768
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 901
      if (gl_search_mode) {
#line 902
        if (c == 27) {
          {
#line 903
          search_term();
#line 904
          c = 0;
          }
        } else
#line 902
        if (c == 14) {
          {
#line 903
          search_term();
#line 904
          c = 0;
          }
        } else
#line 902
        if (c == 16) {
          {
#line 903
          search_term();
#line 904
          c = 0;
          }
        } else
#line 905
        if (c == 8) {
          {
#line 906
          search_addchar(-1);
#line 907
          c = 0;
          }
        } else
#line 905
        if (c == 127) {
          {
#line 906
          search_addchar(-1);
#line 907
          c = 0;
          }
        } else
#line 908
        if (c != 18) {
#line 908
          if (c != 19) {
            {
#line 909
            search_term();
            }
          }
        }
      }
      {
#line 913
      if (c == 13) {
#line 913
        goto case_13;
      }
#line 913
      if (c == 10) {
#line 913
        goto case_13;
      }
#line 918
      if (c == 1) {
#line 918
        goto case_1;
      }
#line 920
      if (c == 2) {
#line 920
        goto case_2;
      }
#line 923
      if (c == 4) {
#line 923
        goto case_4;
      }
#line 923
      if (c == 0) {
#line 923
        goto case_4;
      }
#line 934
      if (c == 5) {
#line 934
        goto case_5;
      }
#line 936
      if (c == 6) {
#line 936
        goto case_6;
      }
#line 938
      if (c == 127) {
#line 938
        goto case_127;
      }
#line 938
      if (c == 8) {
#line 938
        goto case_127;
      }
#line 940
      if (c == 9) {
#line 940
        goto case_9;
      }
#line 961
      if (c == 11) {
#line 961
        goto case_11;
      }
#line 963
      if (c == 12) {
#line 963
        goto case_12;
      }
#line 965
      if (c == 14) {
#line 965
        goto case_14;
      }
#line 971
      if (c == 15) {
#line 971
        goto case_15;
      }
#line 973
      if (c == 16) {
#line 973
        goto case_16;
      }
#line 979
      if (c == 18) {
#line 979
        goto case_18;
      }
#line 981
      if (c == 19) {
#line 981
        goto case_19;
      }
#line 983
      if (c == 20) {
#line 983
        goto case_20;
      }
#line 985
      if (c == 21) {
#line 985
        goto case_21;
      }
#line 987
      if (c == 23) {
#line 987
        goto case_23;
      }
#line 989
      if (c == 25) {
#line 989
        goto case_25;
      }
#line 991
      if (c == 27) {
#line 991
        goto case_27;
      }
#line 1065
      goto switch_default___0;
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
      {
#line 914
      gl_newline();
#line 915
      gl_cleanup();
#line 916
      gl_result = 0;
      }
#line 917
      return (gl_buf);
      case_1: /* CIL Label */ 
      {
#line 918
      gl_fixup(gl_prompt, -1, 0);
      }
#line 919
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 920
      gl_fixup(gl_prompt, -1, gl_pos - 1);
      }
#line 921
      goto switch_break___0;
      case_4: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 924
      if (gl_cnt == 0) {
        {
#line 925
        gl_buf[0] = (char)0;
#line 926
        gl_cleanup();
#line 927
        gl_putc('\n');
#line 928
        gl_result = -1;
        }
#line 929
        return ((char *)((void *)0));
      } else {
        {
#line 931
        gl_del(0, 1);
        }
      }
#line 933
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 934
      gl_fixup(gl_prompt, -1, gl_cnt);
      }
#line 935
      goto switch_break___0;
      case_6: /* CIL Label */ 
      {
#line 936
      gl_fixup(gl_prompt, -1, gl_pos + 1);
      }
#line 937
      goto switch_break___0;
      case_127: /* CIL Label */ 
      case_8: /* CIL Label */ 
      {
#line 938
      gl_del(-1, 0);
      }
#line 939
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 941
      if (gl_completion_proc) {
        {
#line 942
        tmp = gl_pos;
#line 943
        gl_buf[sizeof(gl_buf) - 1UL] = (char )'\000';
#line 944
        loc = gl_do_tab_completion(gl_buf, & tmp, sizeof(gl_buf), lastch == 9);
#line 945
        gl_buf[sizeof(gl_buf) - 1UL] = (char )'\000';
        }
#line 946
        if (loc >= 0) {
          {
#line 947
          gl_fixup(gl_prompt, -2, tmp);
          }
        } else
#line 946
        if (tmp != gl_pos) {
          {
#line 947
          gl_fixup(gl_prompt, -2, tmp);
          }
        }
#line 948
        if (lastch == 9) {
#line 949
          c = 0;
#line 950
          lastch = 0;
        }
      } else
#line 952
      if (gl_tab_hook) {
        {
#line 953
        tmp = gl_pos;
#line 954
        gl_buf[sizeof(gl_buf) - 1UL] = (char )'\000';
#line 955
        tmp___8 = (*gl_strlen)(gl_prompt);
#line 955
        loc = (*gl_tab_hook)(gl_buf, (int )tmp___8, & tmp, sizeof(gl_buf));
#line 956
        gl_buf[sizeof(gl_buf) - 1UL] = (char )'\000';
        }
#line 957
        if (loc >= 0) {
          {
#line 958
          gl_fixup(gl_prompt, loc, tmp);
          }
        } else
#line 957
        if (tmp != gl_pos) {
          {
#line 958
          gl_fixup(gl_prompt, loc, tmp);
          }
        }
      }
#line 960
      goto switch_break___0;
      case_11: /* CIL Label */ 
      {
#line 961
      gl_kill(gl_pos);
      }
#line 962
      goto switch_break___0;
      case_12: /* CIL Label */ 
      {
#line 963
      gl_redraw();
      }
#line 964
      goto switch_break___0;
      case_14: /* CIL Label */ 
      {
#line 966
      tmp___9 = hist_next();
#line 966
      strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___9);
      }
#line 967
      if (gl_in_hook) {
        {
#line 968
        (*gl_in_hook)(gl_buf);
        }
      }
      {
#line 969
      gl_fixup(gl_prompt, 0, 2048);
      }
#line 970
      goto switch_break___0;
      case_15: /* CIL Label */ 
#line 971
      gl_overwrite = ! gl_overwrite;
#line 972
      goto switch_break___0;
      case_16: /* CIL Label */ 
      {
#line 974
      tmp___10 = hist_prev();
#line 974
      strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___10);
      }
#line 975
      if (gl_in_hook) {
        {
#line 976
        (*gl_in_hook)(gl_buf);
        }
      }
      {
#line 977
      gl_fixup(gl_prompt, 0, 2048);
      }
#line 978
      goto switch_break___0;
      case_18: /* CIL Label */ 
      {
#line 979
      search_back(1);
      }
#line 980
      goto switch_break___0;
      case_19: /* CIL Label */ 
      {
#line 981
      search_forw(1);
      }
#line 982
      goto switch_break___0;
      case_20: /* CIL Label */ 
      {
#line 983
      gl_transpose();
      }
#line 984
      goto switch_break___0;
      case_21: /* CIL Label */ 
      {
#line 985
      gl_kill(0);
      }
#line 986
      goto switch_break___0;
      case_23: /* CIL Label */ 
      {
#line 987
      gl_killword(-1);
      }
#line 988
      goto switch_break___0;
      case_25: /* CIL Label */ 
      {
#line 989
      gl_yank();
      }
#line 990
      goto switch_break___0;
      case_27: /* CIL Label */ 
      {
#line 992
      c = gl_getcx(3);
      }
#line 993
      if (c == 91) {
#line 993
        goto ansi;
      } else
#line 993
      if (c == 79) {
        ansi: 
        {
#line 995
        c = gl_getc();
        }
        {
#line 996
        if (c == 65) {
#line 996
          goto case_65___0;
        }
#line 1002
        if (c == 66) {
#line 1002
          goto case_66;
        }
#line 1008
        if (c == 67) {
#line 1008
          goto case_67;
        }
#line 1011
        if (c == 68) {
#line 1011
          goto case_68;
        }
#line 1014
        if (c == 72) {
#line 1014
          goto case_72;
        }
#line 1017
        if (c == 70) {
#line 1017
          goto case_70;
        }
#line 1020
        if (c == 51) {
#line 1020
          goto case_51;
        }
#line 1025
        if (c == 49) {
#line 1025
          goto case_49;
        }
#line 1025
        if (c == 48) {
#line 1025
          goto case_49;
        }
#line 1027
        goto switch_default;
        case_65___0: /* CIL Label */ 
        {
#line 997
        tmp___11 = hist_prev();
#line 997
        strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___11);
        }
#line 998
        if (gl_in_hook) {
          {
#line 999
          (*gl_in_hook)(gl_buf);
          }
        }
        {
#line 1000
        gl_fixup(gl_prompt, 0, 2048);
        }
#line 1001
        goto switch_break___1;
        case_66: /* CIL Label */ 
        {
#line 1003
        tmp___12 = hist_next();
#line 1003
        strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)tmp___12);
        }
#line 1004
        if (gl_in_hook) {
          {
#line 1005
          (*gl_in_hook)(gl_buf);
          }
        }
        {
#line 1006
        gl_fixup(gl_prompt, 0, 2048);
        }
#line 1007
        goto switch_break___1;
        case_67: /* CIL Label */ 
        {
#line 1009
        gl_fixup(gl_prompt, -1, gl_pos + 1);
        }
#line 1010
        goto switch_break___1;
        case_68: /* CIL Label */ 
        {
#line 1012
        gl_fixup(gl_prompt, -1, gl_pos - 1);
        }
#line 1013
        goto switch_break___1;
        case_72: /* CIL Label */ 
        {
#line 1015
        gl_fixup(gl_prompt, -1, 0);
        }
#line 1016
        goto switch_break___1;
        case_70: /* CIL Label */ 
        {
#line 1018
        gl_fixup(gl_prompt, -1, gl_cnt);
        }
#line 1019
        goto switch_break___1;
        case_51: /* CIL Label */ 
        {
#line 1021
        tmp___13 = gl_getc();
        }
#line 1021
        if (tmp___13 == 126) {
          {
#line 1022
          gl_del(0, -1);
          }
        }
#line 1023
        goto switch_break___1;
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1026
        goto ansi;
        switch_default: /* CIL Label */ 
        {
#line 1027
        gl_beep();
        }
#line 1028
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      } else
#line 1030
      if (gl_vi_preferred == 0) {
#line 1030
        if (c == 102) {
          {
#line 1031
          gl_word(1);
          }
        } else
#line 1030
        if (c == 70) {
          {
#line 1031
          gl_word(1);
          }
        } else {
#line 1030
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1032
      if (gl_vi_preferred == 0) {
#line 1032
        if (c == 98) {
          {
#line 1033
          gl_word(-1);
          }
        } else
#line 1032
        if (c == 66) {
          {
#line 1033
          gl_word(-1);
          }
        } else {
#line 1032
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1034
      if (c != -1) {
#line 1045
        if (gl_vi_mode == 0) {
          {
#line 1046
          gl_vi_mode = 1;
#line 1047
          vi_count = 1;
#line 1048
          vi_delete = 0;
#line 1049
          memset((void *)(vi_countbuf), 0, sizeof(vi_countbuf));
          }
#line 1050
          if (gl_pos > 0) {
            {
#line 1051
            gl_fixup(gl_prompt, -2, gl_pos - 1);
            }
          }
#line 1055
          if (gl_cnt > 0) {
#line 1057
            goto vi;
          } else
#line 1055
          if (gl_vi_preferred == 1) {
#line 1057
            goto vi;
          }
#line 1059
          gl_vi_mode = 0;
        } else {
          {
#line 1061
          gl_beep();
          }
        }
      }
#line 1064
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1066
      if (c > 0) {
#line 1067
        if (c == (int )gl_intrc) {
          {
#line 1068
          gl_result = -2;
#line 1069
          gl_buf[0] = (char)0;
#line 1070
          gl_cleanup();
#line 1072
          raise(2);
#line 1073
          gl_init();
#line 1074
          gl_redraw();
          }
#line 1076
          return (gl_buf);
        }
#line 1079
        if (c == (int )gl_quitc) {
          {
#line 1080
          gl_result = -2;
#line 1081
          gl_buf[0] = (char)0;
#line 1082
          gl_cleanup();
#line 1084
          raise(3);
#line 1085
          gl_init();
#line 1086
          gl_redraw();
          }
#line 1088
          return (gl_buf);
        }
#line 1092
        if (c == (int )gl_suspc) {
#line 1092
          goto _L___2;
        } else
#line 1092
        if (c == (int )gl_dsuspc) {
          _L___2: /* CIL Label */ 
          {
#line 1094
          gl_result = -3;
#line 1095
          gl_buf[0] = (char)0;
#line 1096
          gl_cleanup();
#line 1097
          sig = 20;
#line 1098
          kill(0, sig);
#line 1099
          gl_init();
#line 1100
          gl_redraw();
          }
#line 1101
          return (gl_buf);
        }
      }
#line 1106
      if (c > 0) {
        {
#line 1107
        gl_beep();
        }
      }
#line 1108
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1111
    if (c > 0) {
#line 1112
      lastch = c;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1114
  gl_result = -1;
#line 1115
  gl_buf[0] = (char)0;
#line 1116
  gl_cleanup();
  }
#line 1117
  return ((char *)((void *)0));
}
}
#line 1122 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_addchar(int c ) 
{ 
  int i___0 ;

  {
#line 1128
  if (gl_cnt >= 2047) {
    {
#line 1129
    gl_error((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1130
  if (gl_overwrite == 0) {
#line 1130
    goto _L;
  } else
#line 1130
  if (gl_pos == gl_cnt) {
    _L: /* CIL Label */ 
#line 1131
    i___0 = gl_cnt;
    {
#line 1131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1131
      if (! (i___0 >= gl_pos)) {
#line 1131
        goto while_break;
      }
#line 1132
      gl_buf[i___0 + 1] = gl_buf[i___0];
#line 1131
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1133
    gl_buf[gl_pos] = (char )c;
#line 1134
    gl_fixup(gl_prompt, gl_pos, gl_pos + 1);
    }
  } else {
    {
#line 1136
    gl_buf[gl_pos] = (char )c;
#line 1137
    gl_extent = 1;
#line 1138
    gl_fixup(gl_prompt, gl_pos, gl_pos + 1);
    }
  }
#line 1140
  return;
}
}
#line 1142 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_yank(void) 
{ 
  int i___0 ;
  int len ;
  size_t tmp ;

  {
  {
#line 1148
  tmp = strlen((char const   *)(gl_killbuf));
#line 1148
  len = (int )tmp;
  }
#line 1149
  if (len > 0) {
#line 1150
    if (gl_overwrite == 0) {
#line 1151
      if (gl_cnt + len >= 2047) {
        {
#line 1152
        gl_error((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
        }
      }
#line 1153
      i___0 = gl_cnt;
      {
#line 1153
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1153
        if (! (i___0 >= gl_pos)) {
#line 1153
          goto while_break;
        }
#line 1154
        gl_buf[i___0 + len] = gl_buf[i___0];
#line 1153
        i___0 --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1155
      i___0 = 0;
      {
#line 1155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1155
        if (! (i___0 < len)) {
#line 1155
          goto while_break___0;
        }
#line 1156
        gl_buf[gl_pos + i___0] = gl_killbuf[i___0];
#line 1155
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1157
      gl_fixup(gl_prompt, gl_pos, gl_pos + len);
      }
    } else {
#line 1159
      if (gl_pos + len > gl_cnt) {
#line 1160
        if (gl_pos + len >= 2047) {
          {
#line 1161
          gl_error((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
          }
        }
#line 1162
        gl_buf[gl_pos + len] = (char)0;
      }
#line 1164
      i___0 = 0;
      {
#line 1164
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1164
        if (! (i___0 < len)) {
#line 1164
          goto while_break___1;
        }
#line 1165
        gl_buf[gl_pos + i___0] = gl_killbuf[i___0];
#line 1164
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1166
      gl_extent = len;
#line 1167
      gl_fixup(gl_prompt, gl_pos, gl_pos + len);
      }
    }
  } else {
    {
#line 1170
    gl_beep();
    }
  }
#line 1171
  return;
}
}
#line 1173 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_transpose(void) 
{ 
  int c ;

  {
#line 1179
  if (gl_pos > 0) {
#line 1179
    if (gl_cnt > gl_pos) {
      {
#line 1180
      c = (int )gl_buf[gl_pos - 1];
#line 1181
      gl_buf[gl_pos - 1] = gl_buf[gl_pos];
#line 1182
      gl_buf[gl_pos] = (char )c;
#line 1183
      gl_extent = 2;
#line 1184
      gl_fixup(gl_prompt, gl_pos - 1, gl_pos);
      }
    } else {
      {
#line 1186
      gl_beep();
      }
    }
  } else {
    {
#line 1186
    gl_beep();
    }
  }
#line 1187
  return;
}
}
#line 1189 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_newline(void) 
{ 
  int change ;
  int len ;
  int loc ;
  size_t tmp ;

  {
#line 1196
  change = gl_cnt;
#line 1197
  len = gl_cnt;
#line 1198
  loc = gl_width - 5;
#line 1200
  if (gl_cnt >= 2047) {
    {
#line 1201
    gl_error((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1202
  if (gl_out_hook) {
    {
#line 1203
    change = (*gl_out_hook)(gl_buf);
#line 1204
    tmp = strlen((char const   *)(gl_buf));
#line 1204
    len = (int )tmp;
    }
  }
#line 1206
  if (loc > len) {
#line 1207
    loc = len;
  }
  {
#line 1208
  gl_fixup(gl_prompt, change, loc);
#line 1209
  gl_buf[len] = (char )'\n';
#line 1210
  gl_buf[len + 1] = (char )'\000';
#line 1211
  gl_putc('\n');
  }
#line 1212
  return;
}
}
#line 1214 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_del(int loc , int killsave ) 
{ 
  int i___0 ;
  int j ;

  {
#line 1225
  if (loc == -1) {
#line 1225
    if (gl_pos > 0) {
#line 1225
      goto _L;
    } else {
#line 1225
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1225
  if (loc == 0) {
#line 1225
    if (gl_pos < gl_cnt) {
      _L: /* CIL Label */ 
#line 1226
      j = 0;
#line 1226
      i___0 = gl_pos + loc;
      {
#line 1226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1226
        if (! (i___0 < gl_cnt)) {
#line 1226
          goto while_break;
        }
#line 1227
        if (j == 0) {
#line 1227
          if (killsave != 0) {
#line 1227
            if (gl_vi_mode != 0) {
#line 1228
              gl_killbuf[0] = gl_buf[i___0];
#line 1229
              gl_killbuf[1] = (char )'\000';
#line 1230
              j = 1;
            }
          }
        }
#line 1232
        gl_buf[i___0] = gl_buf[i___0 + 1];
#line 1226
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1234
      gl_fixup(gl_prompt, gl_pos + loc, gl_pos + loc);
      }
    } else {
      {
#line 1236
      gl_beep();
      }
    }
  } else {
    {
#line 1236
    gl_beep();
    }
  }
#line 1237
  return;
}
}
#line 1239 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_kill(int pos ) 
{ 
  size_t tmp ;

  {
#line 1244
  if (pos < gl_cnt) {
    {
#line 1244
    tmp = strlen((char const   *)(gl_buf + pos));
    }
#line 1244
    if (tmp < sizeof(gl_killbuf)) {
      {
#line 1245
      strcpy((char */* __restrict  */)(gl_killbuf), (char const   */* __restrict  */)(gl_buf + pos));
#line 1246
      gl_buf[pos] = (char )'\000';
#line 1247
      gl_fixup(gl_prompt, pos, pos);
      }
    } else {
      {
#line 1249
      gl_beep();
      }
    }
  } else {
    {
#line 1249
    gl_beep();
    }
  }
#line 1250
  return;
}
}
#line 1252 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_killword(int direction ) 
{ 
  int pos ;
  int startpos ;
  int tmp ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1255
  pos = gl_pos;
#line 1256
  startpos = gl_pos;
#line 1260
  if (direction > 0) {
    {
#line 1261
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1261
      tmp___0 = __ctype_b_loc();
      }
#line 1261
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1261
        goto while_break;
      } else
#line 1261
      if (! (pos < gl_cnt)) {
#line 1261
        goto while_break;
      }
#line 1262
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1263
      tmp___1 = __ctype_b_loc();
      }
#line 1263
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1263
        if (! (pos < gl_cnt)) {
#line 1263
          goto while_break___0;
        }
      } else {
#line 1263
        goto while_break___0;
      }
#line 1264
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1266
    if (pos > 0) {
#line 1267
      pos --;
    }
    {
#line 1268
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1268
      tmp___2 = __ctype_b_loc();
      }
#line 1268
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1268
        if (! (pos > 0)) {
#line 1268
          goto while_break___1;
        }
      } else {
#line 1268
        goto while_break___1;
      }
#line 1269
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1270
      tmp___3 = __ctype_b_loc();
      }
#line 1270
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1270
        goto while_break___2;
      } else
#line 1270
      if (! (pos > 0)) {
#line 1270
        goto while_break___2;
      }
#line 1271
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1272
    if (pos < gl_cnt) {
      {
#line 1272
      tmp___4 = __ctype_b_loc();
      }
#line 1272
      if ((int const   )*(*tmp___4 + (int )gl_buf[pos]) & 8192) {
#line 1273
        pos ++;
      }
    }
  }
#line 1275
  if (pos < startpos) {
#line 1276
    tmp = pos;
#line 1277
    pos = startpos;
#line 1278
    startpos = tmp;
  }
#line 1280
  if ((size_t )(pos - startpos) >= sizeof(gl_killbuf)) {
    {
#line 1281
    gl_beep();
    }
#line 1282
    return;
  }
  {
#line 1284
  memcpy((void */* __restrict  */)(gl_killbuf), (void const   */* __restrict  */)(gl_buf + startpos),
         (size_t )(pos - startpos));
#line 1285
  gl_killbuf[pos - startpos] = (char )'\000';
#line 1286
  tmp___5 = __ctype_b_loc();
  }
#line 1286
  if ((int const   )*(*tmp___5 + (int )gl_killbuf[(pos - startpos) - 1]) & 8192) {
#line 1287
    gl_killbuf[(pos - startpos) - 1] = (char )'\000';
  }
  {
#line 1288
  gl_fixup(gl_prompt, -1, startpos);
#line 1289
  i___0 = 0;
#line 1289
  tmp = pos - startpos;
  }
  {
#line 1289
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1289
    if (! (i___0 < tmp)) {
#line 1289
      goto while_break___3;
    }
    {
#line 1290
    gl_del(0, 0);
#line 1289
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1291
  return;
}
}
#line 1293 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_word(int direction ) 
{ 
  int pos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1298
  pos = gl_pos;
#line 1300
  if (direction > 0) {
    {
#line 1301
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1301
      tmp = __ctype_b_loc();
      }
#line 1301
      if ((int const   )*(*tmp + (int )gl_buf[pos]) & 8192) {
#line 1301
        goto while_break;
      } else
#line 1301
      if (! (pos < gl_cnt)) {
#line 1301
        goto while_break;
      }
#line 1302
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1303
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1303
      tmp___0 = __ctype_b_loc();
      }
#line 1303
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1303
        if (! (pos < gl_cnt)) {
#line 1303
          goto while_break___0;
        }
      } else {
#line 1303
        goto while_break___0;
      }
#line 1304
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1306
    if (pos > 0) {
#line 1307
      pos --;
    }
    {
#line 1308
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1308
      tmp___1 = __ctype_b_loc();
      }
#line 1308
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1308
        if (! (pos > 0)) {
#line 1308
          goto while_break___1;
        }
      } else {
#line 1308
        goto while_break___1;
      }
#line 1309
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1310
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1310
      tmp___2 = __ctype_b_loc();
      }
#line 1310
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1310
        goto while_break___2;
      } else
#line 1310
      if (! (pos > 0)) {
#line 1310
        goto while_break___2;
      }
#line 1311
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1312
    if (pos < gl_cnt) {
      {
#line 1312
      tmp___3 = __ctype_b_loc();
      }
#line 1312
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1313
        pos ++;
      }
    }
  }
  {
#line 1315
  gl_fixup(gl_prompt, -1, pos);
  }
#line 1316
  return;
}
}
#line 1318 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_redraw(void) 
{ 


  {
#line 1322
  if (gl_init_done > 0) {
    {
#line 1323
    gl_putc('\n');
#line 1324
    gl_fixup(gl_prompt, -2, gl_pos);
    }
  }
#line 1326
  return;
}
}
#line 1344 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_shift  ;
#line 1345 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int off_right  ;
#line 1346 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int off_left  ;
#line 1347 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char last_prompt[80]  = {      (char )'\000'};
#line 1328 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_fixup(char const   *prompt , int change , int cursor ) 
{ 
  int left ;
  int right ;
  int pad ;
  int backup ;
  int new_shift ;
  int extra ;
  int i___0 ;
  int new_right ;
  int l1 ;
  int l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1348
  left = 0;
#line 1348
  right = -1;
#line 1354
  new_right = -1;
#line 1357
  if (change == -2) {
    {
#line 1358
    off_left = 0;
#line 1358
    off_right = off_left;
#line 1358
    gl_shift = off_right;
#line 1358
    gl_cnt = gl_shift;
#line 1358
    gl_pos = gl_cnt;
#line 1359
    gl_putc('\r');
#line 1360
    gl_puts(prompt);
#line 1361
    strncpy((char */* __restrict  */)(last_prompt), (char const   */* __restrict  */)prompt,
            sizeof(last_prompt) - 1UL);
#line 1362
    last_prompt[sizeof(last_prompt) - 1UL] = (char )'\000';
#line 1363
    change = 0;
#line 1364
    tmp = (*gl_strlen)(prompt);
#line 1364
    l2 = (int )tmp;
#line 1365
    gl_width = gl_termw - l2;
    }
  } else {
    {
#line 1366
    tmp___2 = strcmp(prompt, (char const   *)(last_prompt));
    }
#line 1366
    if (tmp___2 != 0) {
      {
#line 1367
      tmp___0 = (*gl_strlen)((char const   *)(last_prompt));
#line 1367
      l1 = (int )tmp___0;
#line 1368
      tmp___1 = (*gl_strlen)(prompt);
#line 1368
      l2 = (int )tmp___1;
#line 1369
      gl_cnt = (gl_cnt + l1) - l2;
#line 1370
      strcpy((char */* __restrict  */)(last_prompt), (char const   */* __restrict  */)prompt);
#line 1371
      gl_putc('\r');
#line 1372
      gl_puts(prompt);
#line 1373
      gl_pos = gl_shift;
#line 1374
      gl_width = gl_termw - l2;
#line 1375
      change = 0;
      }
    }
  }
#line 1377
  if (off_right) {
#line 1377
    pad = gl_width - 1;
  } else {
#line 1377
    pad = gl_cnt - gl_shift;
  }
#line 1378
  backup = gl_pos - gl_shift;
#line 1379
  if (change >= 0) {
    {
#line 1380
    tmp___3 = strlen((char const   *)(gl_buf));
#line 1380
    gl_cnt = (int )tmp___3;
    }
#line 1381
    if (change > gl_cnt) {
#line 1382
      change = gl_cnt;
    }
  }
#line 1384
  if (cursor > gl_cnt) {
#line 1385
    if (cursor != 2048) {
#line 1386
      if (gl_ellipses_during_completion == 0) {
        {
#line 1387
        gl_beep();
        }
      }
    }
#line 1390
    cursor = gl_cnt;
  }
#line 1392
  if (cursor < 0) {
    {
#line 1393
    gl_beep();
#line 1394
    cursor = 0;
    }
  }
#line 1396
  if (off_right) {
#line 1397
    extra = 2;
  } else
#line 1396
  if (off_left) {
#line 1396
    if (cursor < (gl_shift + gl_width) - gl_scroll / 2) {
#line 1397
      extra = 2;
    } else {
#line 1399
      extra = 0;
    }
  } else {
#line 1399
    extra = 0;
  }
#line 1400
  new_shift = ((cursor + extra) + gl_scroll) - gl_width;
#line 1401
  if (new_shift > 0) {
#line 1402
    new_shift /= gl_scroll;
#line 1403
    new_shift *= gl_scroll;
  } else {
#line 1405
    new_shift = 0;
  }
#line 1406
  if (new_shift != gl_shift) {
#line 1407
    gl_shift = new_shift;
#line 1408
    if (gl_shift) {
#line 1408
      off_left = 1;
    } else {
#line 1408
      off_left = 0;
    }
#line 1409
    if (gl_cnt > (gl_shift + gl_width) - 1) {
#line 1409
      off_right = 1;
    } else {
#line 1409
      off_right = 0;
    }
#line 1410
    left = gl_shift;
#line 1411
    if (off_right) {
#line 1411
      right = (gl_shift + gl_width) - 2;
    } else {
#line 1411
      right = gl_cnt;
    }
#line 1411
    new_right = right;
  } else
#line 1412
  if (change >= 0) {
#line 1413
    if (change < gl_shift + off_left) {
#line 1414
      left = gl_shift;
    } else {
#line 1416
      left = change;
#line 1417
      backup = gl_pos - change;
    }
#line 1419
    if (gl_cnt > (gl_shift + gl_width) - 1) {
#line 1419
      off_right = 1;
    } else {
#line 1419
      off_right = 0;
    }
#line 1420
    if (off_right) {
#line 1420
      right = (gl_shift + gl_width) - 2;
    } else {
#line 1420
      right = gl_cnt;
    }
#line 1421
    if (gl_extent) {
#line 1421
      if (right > left + gl_extent) {
#line 1421
        new_right = left + gl_extent;
      } else {
#line 1421
        new_right = right;
      }
    } else {
#line 1421
      new_right = right;
    }
  }
#line 1424
  if (off_right) {
#line 1424
    tmp___4 = gl_width - 1;
  } else {
#line 1424
    tmp___4 = gl_cnt - gl_shift;
  }
#line 1424
  pad -= tmp___4;
#line 1425
  if (pad < 0) {
#line 1425
    pad = 0;
  } else {
#line 1425
    pad = pad;
  }
#line 1426
  if (left <= right) {
#line 1427
    i___0 = 0;
    {
#line 1427
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1427
      if (! (i___0 < backup)) {
#line 1427
        goto while_break;
      }
      {
#line 1428
      gl_putc('\b');
#line 1427
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1429
    if (left == gl_shift) {
#line 1429
      if (off_left) {
        {
#line 1430
        gl_putc('$');
#line 1431
        left ++;
        }
      }
    }
#line 1433
    i___0 = left;
    {
#line 1433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1433
      if (! (i___0 < new_right)) {
#line 1433
        goto while_break___0;
      }
      {
#line 1434
      gl_putc((int )gl_buf[i___0]);
#line 1433
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1435
    gl_pos = new_right;
#line 1436
    if (off_right) {
#line 1436
      if (new_right == right) {
        {
#line 1437
        gl_putc('$');
#line 1438
        gl_pos ++;
        }
      } else {
#line 1436
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1440
      i___0 = 0;
      {
#line 1440
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1440
        if (! (i___0 < pad)) {
#line 1440
          goto while_break___1;
        }
        {
#line 1441
        gl_putc(' ');
#line 1440
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1442
      gl_pos += pad;
    }
  }
#line 1445
  i___0 = gl_pos - cursor;
#line 1446
  if (i___0 > 0) {
    {
#line 1447
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1447
      tmp___5 = i___0;
#line 1447
      i___0 --;
#line 1447
      if (! tmp___5) {
#line 1447
        goto while_break___2;
      }
      {
#line 1448
      gl_putc('\b');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1450
    i___0 = gl_pos;
    {
#line 1450
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1450
      if (! (i___0 < cursor)) {
#line 1450
        goto while_break___3;
      }
      {
#line 1451
      gl_putc((int )gl_buf[i___0]);
#line 1450
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1453
  gl_pos = cursor;
#line 1454
  return;
}
}
#line 1456 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_tab(char *buf , int offset , int *loc , size_t bufsize ) 
{ 
  int i___0 ;
  int count ;
  int len ;
  size_t tmp ;

  {
  {
#line 1462
  tmp = strlen((char const   *)buf);
#line 1462
  len = (int )tmp;
#line 1463
  count = 8 - (offset + *loc) % 8;
#line 1464
  i___0 = len;
  }
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    if (! (i___0 >= *loc)) {
#line 1464
      goto while_break;
    }
#line 1465
    if (i___0 + count < (int )bufsize) {
#line 1466
      *(buf + (i___0 + count)) = *(buf + i___0);
    }
#line 1464
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1467
  i___0 = 0;
  {
#line 1467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1467
    if (! (i___0 < count)) {
#line 1467
      goto while_break___0;
    }
#line 1468
    if (*loc + i___0 < (int )bufsize) {
#line 1469
      *(buf + (*loc + i___0)) = (char )' ';
    }
#line 1467
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1470
  i___0 = *loc;
#line 1471
  *loc = i___0 + count;
#line 1472
  return (i___0);
}
}
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int hist_pos  =    0;
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int hist_last  =    0;
#line 1482 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_buf[100]  ;
#line 1483 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char hist_empty_elem[2]  = {      (char )'\000'};
#line 1485 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void hist_init(void) 
{ 
  int i___0 ;

  {
#line 1490
  hist_buf[0] = hist_empty_elem;
#line 1491
  i___0 = 1;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if (! (i___0 < 100)) {
#line 1491
      goto while_break;
    }
#line 1492
    hist_buf[i___0] = (char *)0;
#line 1491
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1493
  hist_last = 0;
#line 1493
  hist_pos = hist_last;
#line 1494
  return;
}
}
#line 1496 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void hist_dispose(void) 
{ 
  int i___0 ;

  {
#line 1501
  i___0 = 0;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! (i___0 < 100)) {
#line 1501
      goto while_break;
    }
#line 1502
    if ((unsigned long )hist_buf[i___0] != (unsigned long )(hist_empty_elem)) {
#line 1502
      if ((unsigned long )hist_buf[i___0] != (unsigned long )((char *)0)) {
        {
#line 1503
        free((void *)hist_buf[i___0]);
#line 1504
        hist_buf[i___0] = (char *)0;
        }
      }
    }
#line 1501
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1509
  hist_buf[0] = hist_empty_elem;
#line 1510
  hist_last = 0;
#line 1510
  hist_pos = hist_last;
#line 1511
  return;
}
}
#line 1516 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *prev  =    (char *)0;
#line 1513 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_histadd(char const   * const  buf ) 
{ 
  char const   *p___5 ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 1517
  p___5 = (char const   *)buf;
#line 1521
  if (gl_init_done < 0) {
    {
#line 1522
    hist_init();
#line 1523
    gl_init_done = 0;
    }
  }
  {
#line 1525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1525
    if (! ((int const   )*p___5 == 32)) {
#line 1525
      if (! ((int const   )*p___5 == 9)) {
#line 1525
        if (! ((int const   )*p___5 == 10)) {
#line 1525
          goto while_break;
        }
      }
    }
#line 1526
    p___5 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1527
  if (*p___5) {
    {
#line 1528
    tmp = strlen((char const   *)buf);
#line 1528
    len = (int )tmp;
#line 1529
    tmp___0 = strchr(p___5, '\n');
    }
#line 1529
    if (tmp___0) {
#line 1530
      len --;
    }
#line 1531
    if ((unsigned long )prev == (unsigned long )((char *)0)) {
#line 1531
      goto _L;
    } else {
      {
#line 1531
      tmp___1 = strlen((char const   *)prev);
      }
#line 1531
      if ((int )tmp___1 != len) {
#line 1531
        goto _L;
      } else {
        {
#line 1531
        tmp___2 = strncmp((char const   *)prev, (char const   *)buf, (size_t )len);
        }
#line 1531
        if (tmp___2 != 0) {
          _L: /* CIL Label */ 
          {
#line 1533
          hist_buf[hist_last] = hist_save(buf);
#line 1534
          prev = hist_buf[hist_last];
#line 1535
          hist_last = (hist_last + 1) % 100;
          }
#line 1536
          if (hist_buf[hist_last]) {
#line 1536
            if (*(hist_buf[hist_last])) {
              {
#line 1537
              free((void *)hist_buf[hist_last]);
              }
            }
          }
#line 1539
          hist_buf[hist_last] = hist_empty_elem;
        }
      }
    }
  }
#line 1542
  hist_pos = hist_last;
#line 1543
  return;
}
}
#line 1545 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_prev(void) 
{ 
  char *p___5 ;
  int next ;

  {
#line 1549
  p___5 = (char *)0;
#line 1550
  next = ((hist_pos - 1) + 100) % 100;
#line 1552
  if ((unsigned long )hist_buf[hist_pos] != (unsigned long )((char *)0)) {
#line 1552
    if (next != hist_last) {
#line 1553
      hist_pos = next;
#line 1554
      p___5 = hist_buf[hist_pos];
    }
  }
#line 1556
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1557
    p___5 = hist_empty_elem;
#line 1558
    gl_beep();
    }
  }
#line 1560
  return (p___5);
}
}
#line 1563 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_next(void) 
{ 
  char *p___5 ;

  {
#line 1567
  p___5 = (char *)0;
#line 1569
  if (hist_pos != hist_last) {
#line 1570
    hist_pos = (hist_pos + 1) % 100;
#line 1571
    p___5 = hist_buf[hist_pos];
  }
#line 1573
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1574
    p___5 = hist_empty_elem;
#line 1575
    gl_beep();
    }
  }
#line 1577
  return (p___5);
}
}
#line 1580 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_save(char const   * const  p___5 ) 
{ 
  char *s ;
  size_t len ;
  size_t tmp ;
  char *nl___0 ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1584
  s = (char *)0;
#line 1585
  tmp = strlen((char const   *)p___5);
#line 1585
  len = tmp;
#line 1586
  tmp___0 = strpbrk((char const   *)p___5, "\n\r");
#line 1586
  nl___0 = tmp___0;
  }
#line 1588
  if (nl___0) {
    {
#line 1589
    tmp___1 = malloc(len);
#line 1589
    s = (char *)tmp___1;
    }
#line 1589
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1590
      strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5,
              len - 1UL);
#line 1591
      *(s + (len - 1UL)) = (char)0;
      }
    }
  } else {
    {
#line 1594
    tmp___2 = malloc(len + 1UL);
#line 1594
    s = (char *)tmp___2;
    }
#line 1594
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1595
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5);
      }
    }
  }
#line 1598
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 1599
    gl_error((char const   */* const  */)"\n*** Error: hist_save() failed on malloc\n");
    }
  }
#line 1600
  return (s);
}
}
#line 1606 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_histsavefile(char const   * const  path ) 
{ 
  FILE *fp ;
  char const   *p___5 ;
  int i___0 ;
  int j ;

  {
  {
#line 1613
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w");
  }
#line 1620
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 1621
    i___0 = 2;
    {
#line 1621
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1621
      if (! (i___0 < 100)) {
#line 1621
        goto while_break;
      }
#line 1622
      j = (hist_pos + i___0) % 100;
#line 1623
      p___5 = (char const   *)hist_buf[j];
#line 1624
      if ((unsigned long )p___5 == (unsigned long )((void *)0)) {
#line 1625
        goto __Cont;
      } else
#line 1624
      if ((int const   )*p___5 == 0) {
#line 1625
        goto __Cont;
      }
      {
#line 1626
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
              p___5);
      }
      __Cont: /* CIL Label */ 
#line 1621
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1628
    fclose(fp);
    }
  }
#line 1630
  return;
}
}
#line 1635 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_histloadfile(char const   * const  path ) 
{ 
  FILE *fp ;
  char line[256] ;
  char *tmp ;

  {
  {
#line 1641
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 1648
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1649
    memset((void *)(line), 0, sizeof(line));
    }
    {
#line 1650
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1650
      tmp = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 2UL), (FILE */* __restrict  */)fp);
      }
#line 1650
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1650
        goto while_break;
      }
      {
#line 1651
      gl_histadd((char const   */* const  */)(line));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1653
    fclose(fp);
    }
  }
#line 1655
  return;
}
}
#line 1662 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char search_prompt[101]  ;
#line 1663 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char search_string[100]  ;
#line 1664 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_pos  =    0;
#line 1665 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_forw_flg  =    0;
#line 1666 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_last  =    0;
#line 1668 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_update(int c ) 
{ 


  {
#line 1671
  if (c == 0) {
#line 1672
    search_pos = 0;
#line 1673
    search_string[0] = (char)0;
#line 1674
    search_prompt[0] = (char )'?';
#line 1675
    search_prompt[1] = (char )' ';
#line 1676
    search_prompt[2] = (char)0;
  } else
#line 1677
  if (c > 0) {
#line 1678
    search_string[search_pos] = (char )c;
#line 1679
    search_string[search_pos + 1] = (char)0;
#line 1680
    search_prompt[search_pos] = (char )c;
#line 1681
    search_prompt[search_pos + 1] = (char )'?';
#line 1682
    search_prompt[search_pos + 2] = (char )' ';
#line 1683
    search_prompt[search_pos + 3] = (char)0;
#line 1684
    search_pos ++;
  } else
#line 1686
  if (search_pos > 0) {
#line 1687
    search_pos --;
#line 1688
    search_string[search_pos] = (char)0;
#line 1689
    search_prompt[search_pos] = (char )'?';
#line 1690
    search_prompt[search_pos + 1] = (char )' ';
#line 1691
    search_prompt[search_pos + 2] = (char)0;
  } else {
    {
#line 1693
    gl_beep();
#line 1694
    hist_pos = hist_last;
    }
  }
#line 1697
  return;
}
}
#line 1699 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_addchar(int c ) 
{ 
  char *loc ;

  {
  {
#line 1704
  search_update(c);
  }
#line 1705
  if (c < 0) {
#line 1706
    if (search_pos > 0) {
#line 1707
      hist_pos = search_last;
    } else {
#line 1709
      gl_buf[0] = (char)0;
#line 1710
      hist_pos = hist_last;
    }
    {
#line 1712
    strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)hist_buf[hist_pos]);
    }
  }
  {
#line 1714
  loc = strstr((char const   *)(gl_buf), (char const   *)(search_string));
  }
#line 1714
  if ((unsigned long )loc != (unsigned long )((char *)0)) {
    {
#line 1715
    gl_fixup((char const   *)(search_prompt), 0, (int )(loc - gl_buf));
    }
  } else
#line 1716
  if (search_pos > 0) {
#line 1717
    if (search_forw_flg) {
      {
#line 1718
      search_forw(0);
      }
    } else {
      {
#line 1720
      search_back(0);
      }
    }
  } else {
    {
#line 1723
    gl_fixup((char const   *)(search_prompt), 0, 0);
    }
  }
#line 1725
  return;
}
}
#line 1727 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_term(void) 
{ 


  {
#line 1730
  gl_search_mode = 0;
#line 1731
  if ((int )gl_buf[0] == 0) {
#line 1732
    hist_pos = hist_last;
  }
#line 1733
  if (gl_in_hook) {
    {
#line 1734
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 1735
  gl_fixup(gl_prompt, 0, gl_pos);
  }
#line 1736
  return;
}
}
#line 1738 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_back(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1741
  found = 0;
#line 1744
  search_forw_flg = 0;
#line 1745
  if (gl_search_mode == 0) {
    {
#line 1746
    hist_pos = hist_last;
#line 1746
    search_last = hist_pos;
#line 1747
    search_update(0);
#line 1748
    gl_search_mode = 1;
#line 1749
    gl_buf[0] = (char)0;
#line 1750
    gl_fixup((char const   *)(search_prompt), 0, 0);
    }
  } else
#line 1751
  if (search_pos > 0) {
    {
#line 1752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1752
      if (! (! found)) {
#line 1752
        goto while_break;
      }
      {
#line 1753
      p___5 = hist_prev();
      }
#line 1754
      if ((int )*p___5 == 0) {
        {
#line 1755
        gl_buf[0] = (char)0;
#line 1756
        gl_fixup((char const   *)(search_prompt), 0, 0);
#line 1757
        found = 1;
        }
      } else {
        {
#line 1758
        loc = strstr((char const   *)p___5, (char const   *)(search_string));
        }
#line 1758
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1759
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1760
          gl_fixup((char const   *)(search_prompt), 0, (int )(loc - p___5));
          }
#line 1761
          if (new_search) {
#line 1762
            search_last = hist_pos;
          }
#line 1763
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1768
    gl_beep();
    }
  }
#line 1770
  return;
}
}
#line 1772 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_forw(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1775
  found = 0;
#line 1778
  search_forw_flg = 1;
#line 1779
  if (gl_search_mode == 0) {
    {
#line 1780
    hist_pos = hist_last;
#line 1780
    search_last = hist_pos;
#line 1781
    search_update(0);
#line 1782
    gl_search_mode = 1;
#line 1783
    gl_buf[0] = (char)0;
#line 1784
    gl_fixup((char const   *)(search_prompt), 0, 0);
    }
  } else
#line 1785
  if (search_pos > 0) {
    {
#line 1786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1786
      if (! (! found)) {
#line 1786
        goto while_break;
      }
      {
#line 1787
      p___5 = hist_next();
      }
#line 1788
      if ((int )*p___5 == 0) {
        {
#line 1789
        gl_buf[0] = (char)0;
#line 1790
        gl_fixup((char const   *)(search_prompt), 0, 0);
#line 1791
        found = 1;
        }
      } else {
        {
#line 1792
        loc = strstr((char const   *)p___5, (char const   *)(search_string));
        }
#line 1792
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1793
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1794
          gl_fixup((char const   *)(search_prompt), 0, (int )(loc - p___5));
          }
#line 1795
          if (new_search) {
#line 1796
            search_last = hist_pos;
          }
#line 1797
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1801
    gl_beep();
    }
  }
#line 1803
  return;
}
}
#line 1806 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_beep(void) 
{ 


  {
  {
#line 1812
  gl_putc('\a');
  }
#line 1814
  return;
}
}
#line 1818 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_display_matches_sort_proc(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 1821
  tmp = strcasecmp((char const   *)*((char const   * const  *)a), (char const   *)*((char const   * const  *)b));
  }
#line 1821
  return (tmp);
}
}
#line 1829 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_display_matches(int nused ) 
{ 
  char buf[256] ;
  char buf2[256] ;
  size_t ilen ;
  size_t imaxlen ;
  int i___0 ;
  int j ;
  int k ;
  int l ;
  int glen ;
  int allmatch ;
  int nmax ;
  int ncol ;
  int colw ;
  int nrow ;
  char *cp1 ;
  char *cp2 ;
  char *lim ;
  char *itemp ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1840
  gl_putc('\n');
  }
#line 1841
  if (nused == 0) {
    {
#line 1842
    gl_beep();
#line 1843
    gl_puts("    (no matches)");
#line 1844
    gl_putc('\n');
    }
  } else {
    {
#line 1846
    qsort((void *)gl_matchlist, (size_t )nused, sizeof(char *), & gl_display_matches_sort_proc);
#line 1849
    glen = 0;
    }
    {
#line 1849
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1850
      allmatch = 1;
#line 1851
      if ((int )*(*(gl_matchlist + 0) + glen) == 0) {
        {
#line 1852
        gl_beep();
#line 1853
        gl_putc('\n');
        }
#line 1854
        return;
      }
#line 1856
      i___0 = 1;
      {
#line 1856
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1856
        if (! (i___0 < nused)) {
#line 1856
          goto while_break___0;
        }
#line 1857
        if ((int )*(*(gl_matchlist + 0) + glen) != (int )*(*(gl_matchlist + i___0) + glen)) {
#line 1858
          allmatch = 0;
#line 1859
          goto while_break___0;
        }
#line 1856
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1862
      if (allmatch == 0) {
#line 1863
        goto while_break;
      }
#line 1849
      glen ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1866
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1866
      if (! (glen > 0)) {
#line 1866
        goto while_break___1;
      }
      {
#line 1867
      tmp = __ctype_b_loc();
      }
#line 1867
      if (! ((int const   )*(*tmp + (int )*(*(gl_matchlist + 0) + (glen - 1))) & 8)) {
#line 1868
        goto while_break___1;
      }
#line 1869
      glen --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1872
    nmax = nused;
#line 1873
    imaxlen = strlen((char const   *)*(gl_matchlist + 0));
#line 1874
    i___0 = 1;
    }
    {
#line 1874
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1874
      if (! (i___0 < nused)) {
#line 1874
        goto while_break___2;
      }
      {
#line 1875
      ilen = strlen((char const   *)*(gl_matchlist + i___0));
      }
#line 1876
      if (ilen > imaxlen) {
#line 1877
        imaxlen = ilen;
      }
#line 1874
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1881
    if (imaxlen == (size_t )((unsigned int )glen)) {
      {
#line 1882
      gl_beep();
#line 1883
      gl_putc('\n');
      }
#line 1884
      return;
    }
#line 1886
    imaxlen -= (size_t )glen;
#line 1888
    ncol = (gl_termw - 8) / ((int )imaxlen + 2);
#line 1889
    if (ncol < 1) {
#line 1890
      ncol = 1;
    }
#line 1892
    colw = (gl_termw - 8) / ncol;
#line 1893
    nrow = nmax / ncol;
#line 1894
    if (nused % ncol != 0) {
#line 1895
      nrow ++;
    }
#line 1897
    if (nrow > gl_termh - 4) {
#line 1898
      nrow = gl_termh - 4;
#line 1899
      nmax = ncol * nrow;
    }
#line 1902
    i___0 = 0;
    {
#line 1902
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1902
      if (! (i___0 < (int )sizeof(buf2))) {
#line 1902
        goto while_break___3;
      }
#line 1903
      buf2[i___0] = (char )' ';
#line 1902
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1905
    j = 0;
    {
#line 1905
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1905
      if (! (j < nrow)) {
#line 1905
        goto while_break___4;
      }
      {
#line 1906
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(buf2),
             sizeof(buf));
#line 1907
      i___0 = 0;
#line 1907
      k = j;
#line 1907
      l = 4;
      }
      {
#line 1907
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1907
        if (! (i___0 < ncol)) {
#line 1907
          goto while_break___5;
        }
#line 1908
        if (k >= nmax) {
#line 1909
          goto __Cont;
        }
        {
#line 1910
        itemp = *(gl_matchlist + k) + glen;
#line 1911
        cp1 = buf + l;
#line 1912
        tmp___0 = strlen((char const   *)itemp);
#line 1912
        lim = cp1 + (int )tmp___0;
        }
#line 1913
        if ((unsigned long )lim >= (unsigned long )(buf + sizeof(buf))) {
#line 1914
          goto __Cont;
        }
#line 1915
        cp2 = itemp;
        {
#line 1916
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1916
          if (! ((unsigned long )cp1 < (unsigned long )lim)) {
#line 1916
            goto while_break___6;
          }
#line 1917
          tmp___1 = cp1;
#line 1917
          cp1 ++;
#line 1917
          tmp___2 = cp2;
#line 1917
          cp2 ++;
#line 1917
          *tmp___1 = *tmp___2;
        }
        while_break___6: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 1907
        i___0 ++;
#line 1907
        k += nrow;
#line 1907
        l += colw;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1919
      cp1 = buf;
#line 1920
      cp1 += sizeof(buf);
#line 1921
      cp1 --;
      {
#line 1922
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1922
        if (! ((int )*cp1 == 32)) {
#line 1922
          goto while_break___7;
        }
#line 1923
        cp1 --;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1924
      cp1 ++;
#line 1925
      *cp1 = (char )'\000';
#line 1926
      gl_puts((char const   *)(buf));
#line 1927
      gl_putc('\n');
#line 1905
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1930
    if (nused > nmax) {
      {
#line 1931
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"    ... %d others omitted ...",
              nused - nmax);
#line 1932
      gl_puts((char const   *)(buf));
#line 1933
      gl_putc('\n');
      }
    }
  }
  {
#line 1936
  gl_fixup(gl_prompt, -2, 2048);
  }
#line 1937
  return;
}
}
#line 1942 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_do_tab_completion(char *buf , int *loc , size_t bufsize , int tabtab ) 
{ 
  char *startp ;
  size_t startoff ;
  size_t amt ;
  int c ;
  int qmode ;
  char *qstart ;
  char *lastspacestart ;
  char *cp ;
  int ntoalloc ;
  int nused ;
  int nprocused ;
  int nalloced ;
  int i___0 ;
  char **newgl_matchlist ;
  char *strtoadd ;
  char *strtoadd1 ;
  int addquotes ;
  size_t llen ;
  size_t mlen ;
  size_t glen ;
  int allmatch ;
  char *curposp ;
  size_t lenaftercursor ;
  char *matchpfx ;
  int wasateol ;
  char ellipsessave[4] ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
  {
#line 1967
  llen = strlen((char const   *)buf);
#line 1968
  memset((void *)(buf + llen), 0, bufsize - llen);
#line 1969
  bufsize -= 4UL;
#line 1970
  curposp = buf + *loc;
#line 1971
  wasateol = (int )*curposp == 0;
#line 1972
  lenaftercursor = llen - (size_t )(curposp - buf);
  }
#line 1973
  if (gl_ellipses_during_completion != 0) {
    {
#line 1974
    memcpy((void */* __restrict  */)(ellipsessave), (void const   */* __restrict  */)curposp,
           (size_t )4);
#line 1975
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)"... ",
           (size_t )4);
#line 1976
    gl_fixup(gl_prompt, gl_pos, gl_pos + 3);
#line 1977
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)(ellipsessave),
           (size_t )4);
    }
  }
#line 1980
  qmode = 0;
#line 1981
  qstart = (char *)((void *)0);
#line 1982
  lastspacestart = (char *)((void *)0);
#line 1983
  matchpfx = (char *)((void *)0);
#line 1985
  cp = buf;
  {
#line 1986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1986
    if (! ((unsigned long )cp < (unsigned long )curposp)) {
#line 1986
      goto while_break;
    }
#line 1987
    tmp = cp;
#line 1987
    cp ++;
#line 1987
    c = (int )*tmp;
#line 1988
    if (c == 0) {
#line 1989
      goto while_break;
    }
#line 1990
    if (c == 34) {
#line 1990
      goto _L;
    } else
#line 1990
    if (c == 39) {
      _L: /* CIL Label */ 
#line 1991
      if (qmode == c) {
#line 1993
        qstart = (char *)((void *)0);
#line 1994
        qmode = 0;
      } else
#line 1995
      if (! (qmode != 0)) {
#line 1999
        qmode = c;
#line 2000
        qstart = cp - 1;
      }
    } else {
      {
#line 2002
      tmp___0 = __ctype_b_loc();
      }
#line 2002
      if ((int const   )*(*tmp___0 + c) & 8192) {
#line 2002
        if (qmode == 0) {
#line 2004
          lastspacestart = cp - 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  if ((unsigned long )qstart != (unsigned long )((void *)0)) {
#line 2011
    startp = qstart + 1;
  } else
#line 2012
  if ((unsigned long )lastspacestart != (unsigned long )((void *)0)) {
#line 2013
    startp = lastspacestart + 1;
  } else {
#line 2015
    startp = buf;
  }
  {
#line 2017
  cp = startp;
#line 2018
  mlen = (size_t )(curposp - cp);
#line 2020
  tmp___1 = malloc(mlen + 1UL);
#line 2020
  matchpfx = (char *)tmp___1;
#line 2021
  memcpy((void */* __restrict  */)matchpfx, (void const   */* __restrict  */)cp, mlen);
#line 2022
  *(matchpfx + mlen) = (char )'\000';
#line 2026
  nused = 0;
#line 2027
  ntoalloc = 64;
#line 2028
  tmp___2 = malloc(sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2028
  newgl_matchlist = (char **)tmp___2;
  }
#line 2029
  if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
    {
#line 2030
    free((void *)matchpfx);
#line 2031
    gl_beep();
    }
#line 2032
    return (0);
  }
#line 2034
  gl_matchlist = newgl_matchlist;
#line 2035
  nalloced = ntoalloc;
#line 2036
  i___0 = nused;
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i___0 <= nalloced)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(gl_matchlist + i___0) = (char *)((void *)0);
#line 2036
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2039
  gl_completion_exact_match_extra_char = ' ';
#line 2040
  nprocused = 0;
  {
#line 2040
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2041
    if (nused == nalloced) {
      {
#line 2042
      ntoalloc += 64;
#line 2043
      tmp___3 = realloc((void *)((char *)gl_matchlist), sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2043
      newgl_matchlist = (char **)tmp___3;
      }
#line 2044
      if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
#line 2046
        i___0 = 0;
        {
#line 2046
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2046
          if (! (i___0 < nused)) {
#line 2046
            goto while_break___2;
          }
          {
#line 2047
          free((void *)*(gl_matchlist + i___0));
#line 2046
          i___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2048
        free((void *)gl_matchlist);
#line 2049
        gl_matchlist = (char **)((void *)0);
#line 2050
        gl_beep();
#line 2051
        free((void *)matchpfx);
        }
#line 2052
        return (0);
      }
#line 2054
      gl_matchlist = newgl_matchlist;
#line 2055
      nalloced = ntoalloc;
#line 2056
      i___0 = nused;
      {
#line 2056
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2056
        if (! (i___0 <= nalloced)) {
#line 2056
          goto while_break___3;
        }
#line 2057
        *(gl_matchlist + i___0) = (char *)((void *)0);
#line 2056
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2059
    cp = (*gl_completion_proc)((char const   *)matchpfx, nprocused);
    }
#line 2060
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2061
      goto while_break___1;
    }
#line 2062
    if ((int )*(cp + 0) == 46) {
#line 2062
      if ((int )*(cp + 1) == 0) {
#line 2063
        goto __Cont;
      } else
#line 2062
      if ((int )*(cp + 1) == 46) {
#line 2062
        if ((int )*(cp + 2) == 0) {
#line 2063
          goto __Cont;
        }
      }
    }
#line 2064
    tmp___4 = nused;
#line 2064
    nused ++;
#line 2064
    *(gl_matchlist + tmp___4) = cp;
    __Cont: /* CIL Label */ 
#line 2040
    nprocused ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2067
  if (gl_ellipses_during_completion != 0) {
    {
#line 2068
    gl_fixup(gl_prompt, gl_pos, gl_pos);
#line 2069
    gl_puts("    ");
    }
  }
#line 2073
  strtoadd = (char *)((void *)0);
#line 2074
  strtoadd1 = (char *)((void *)0);
#line 2075
  amt = (size_t )0;
#line 2077
  if (gl_filename_quoting_desired > 0) {
#line 2077
    tmp___5 = 1;
  } else
#line 2077
  if (gl_filename_quoting_desired < 0) {
#line 2077
    if ((unsigned long )gl_completion_proc == (unsigned long )(& gl_local_filename_completion_proc)) {
#line 2077
      tmp___5 = 1;
    } else {
#line 2077
      tmp___5 = 0;
    }
  } else {
#line 2077
    tmp___5 = 0;
  }
#line 2077
  addquotes = tmp___5;
#line 2079
  if (nused == 1) {
#line 2081
    strtoadd = *(gl_matchlist + 0);
  } else
#line 2082
  if (tabtab != 0) {
    {
#line 2084
    gl_display_matches(nused);
    }
  } else
#line 2085
  if (nused > 1) {
#line 2085
    if (mlen != 0UL) {
      {
#line 2087
      glen = strlen((char const   *)matchpfx);
      }
      {
#line 2087
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2088
        allmatch = 1;
#line 2089
        i___0 = 1;
        {
#line 2089
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2089
          if (! (i___0 < nused)) {
#line 2089
            goto while_break___5;
          }
#line 2090
          if ((int )*(*(gl_matchlist + 0) + glen) != (int )*(*(gl_matchlist + i___0) + glen)) {
#line 2091
            allmatch = 0;
#line 2092
            goto while_break___5;
          }
#line 2089
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2095
        if (allmatch == 0) {
#line 2096
          goto while_break___4;
        }
#line 2087
        glen ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2098
      tmp___6 = malloc(glen + 1UL);
#line 2098
      strtoadd1 = (char *)tmp___6;
      }
#line 2099
      if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
        {
#line 2100
        memcpy((void */* __restrict  */)strtoadd1, (void const   */* __restrict  */)*(gl_matchlist + 0),
               glen);
#line 2101
        *(strtoadd1 + glen) = (char )'\000';
#line 2102
        strtoadd = strtoadd1;
        }
      }
    }
  }
#line 2106
  if ((unsigned long )strtoadd != (unsigned long )((void *)0)) {
#line 2107
    if (qmode == 0) {
#line 2107
      if (addquotes != 0) {
        {
#line 2108
        tmp___10 = strpbrk((char const   *)strtoadd, gl_filename_quote_characters);
        }
#line 2108
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          {
#line 2109
          tmp___8 = strchr((char const   *)strtoadd, '\"');
          }
#line 2109
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 2109
            qmode = '\"';
          } else {
#line 2109
            qmode = '\'';
          }
          {
#line 2110
          memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2111
          curposp ++;
#line 2112
          tmp___9 = startp;
#line 2112
          startp ++;
#line 2112
          *tmp___9 = (char )qmode;
          }
        }
      }
    }
    {
#line 2115
    startoff = (size_t )(startp - buf);
#line 2116
    amt = strlen((char const   *)strtoadd);
    }
#line 2117
    if ((amt + startoff) + lenaftercursor >= bufsize) {
#line 2118
      amt = bufsize - ((amt + startoff) + lenaftercursor);
    }
    {
#line 2119
    memmove((void *)((curposp + amt) - mlen), (void const   *)curposp, lenaftercursor + 1UL);
#line 2120
    curposp += amt - mlen;
#line 2121
    memcpy((void */* __restrict  */)startp, (void const   */* __restrict  */)strtoadd,
           amt);
    }
#line 2122
    if (nused == 1) {
#line 2124
      if (qmode != 0) {
        {
#line 2126
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2127
        curposp ++;
#line 2128
        *(buf + (amt + startoff)) = (char )qmode;
#line 2129
        amt ++;
        }
      }
      {
#line 2131
      memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2132
      curposp ++;
#line 2133
      *(buf + (amt + startoff)) = (char )gl_completion_exact_match_extra_char;
#line 2134
      amt ++;
      }
    } else
#line 2135
    if (! wasateol) {
      {
#line 2135
      tmp___11 = __ctype_b_loc();
      }
#line 2135
      if (! ((int const   )*(*tmp___11 + (int )*curposp) & 8192)) {
        {
#line 2139
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2140
        curposp ++;
#line 2141
        *(buf + (amt + startoff)) = (char )' ';
        }
      }
    }
#line 2143
    *loc = (int )(startoff + amt);
#line 2145
    if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
      {
#line 2146
      free((void *)strtoadd1);
      }
    }
  }
#line 2150
  i___0 = 0;
  {
#line 2150
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2150
    if (! (i___0 < nused)) {
#line 2150
      goto while_break___6;
    }
    {
#line 2151
    free((void *)*(gl_matchlist + i___0));
#line 2150
    i___0 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2152
  free((void *)gl_matchlist);
#line 2153
  gl_matchlist = (char **)((void *)0);
#line 2154
  free((void *)matchpfx);
  }
#line 2156
  return (0);
}
}
#line 2162 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_tab_completion(char *(*proc)(char const   * , int  ) ) 
{ 


  {
#line 2165
  if ((unsigned long )proc == (unsigned long )((void *)0)) {
#line 2166
    proc = & gl_local_filename_completion_proc;
  }
#line 2167
  gl_completion_proc = proc;
#line 2168
  return;
}
}
#line 2196 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
void gl_set_home_dir(char const   *homedir ) 
{ 
  size_t len ;
  struct passwd *pw ;
  char *cp ;
  __uid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 2208
  if ((unsigned long )gl_home_dir != (unsigned long )((void *)0)) {
    {
#line 2209
    free((void *)gl_home_dir);
#line 2210
    gl_home_dir = (char *)((void *)0);
    }
  }
#line 2213
  if ((unsigned long )homedir == (unsigned long )((void *)0)) {
    {
#line 2245
    tmp = getuid();
#line 2245
    pw = getpwuid(tmp);
    }
#line 2246
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 2247
      tmp___0 = getenv("LOGNAME");
#line 2247
      cp = tmp___0;
      }
#line 2248
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 2249
        tmp___1 = getenv("USER");
#line 2249
        cp = tmp___1;
        }
      }
#line 2250
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 2251
        tmp___2 = getlogin();
#line 2251
        cp = tmp___2;
        }
      }
#line 2252
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 2253
        pw = getpwnam((char const   *)cp);
        }
      }
#line 2254
      if ((unsigned long )pw == (unsigned long )((void *)0)) {
#line 2255
        return;
      }
    }
#line 2257
    homedir = (char const   *)pw->pw_dir;
  }
  {
#line 2261
  tmp___3 = strlen(homedir);
#line 2261
  len = tmp___3 + 1UL;
#line 2262
  tmp___4 = malloc(len);
#line 2262
  gl_home_dir = (char *)tmp___4;
  }
#line 2263
  if ((unsigned long )gl_home_dir != (unsigned long )((void *)0)) {
    {
#line 2264
    memcpy((void */* __restrict  */)gl_home_dir, (void const   */* __restrict  */)homedir,
           len);
    }
  }
#line 2266
  return;
}
}
#line 2271 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
char *gl_getpass(char const   * const  prompt , char * const  pass , int dsize ) 
{ 
  char *cp ;
  int c ;
  char *tmp ;

  {
  {
#line 2277
  memset((void *)pass, 0, sizeof(dsize));
#line 2278
  dsize --;
#line 2279
  gl_init();
  }
#line 2282
  if ((unsigned long )prompt != (unsigned long )((void *)0)) {
#line 2282
    if ((int const   )*(prompt + 0) != 0) {
      {
#line 2283
      gl_puts((char const   *)prompt);
      }
    }
  }
#line 2285
  cp = (char *)pass;
  {
#line 2286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2286
    c = gl_getc();
    }
#line 2286
    if (! (c != -1)) {
#line 2286
      goto while_break;
    }
#line 2287
    if (c == 13) {
#line 2288
      goto while_break;
    } else
#line 2287
    if (c == 10) {
#line 2288
      goto while_break;
    }
#line 2289
    if (c == 8) {
#line 2289
      goto _L;
    } else
#line 2289
    if (c == 127) {
      _L: /* CIL Label */ 
#line 2291
      if ((unsigned long )cp > (unsigned long )pass) {
        {
#line 2292
        cp --;
#line 2292
        *cp = (char )'\000';
#line 2293
        gl_putc('\b');
#line 2294
        gl_putc(' ');
#line 2295
        gl_putc('\b');
        }
      }
    } else
#line 2297
    if ((unsigned long )cp < (unsigned long )(pass + dsize)) {
      {
#line 2298
      gl_putc('*');
#line 2299
      tmp = cp;
#line 2299
      cp ++;
#line 2299
      *tmp = (char )c;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2302
  *cp = (char )'\000';
#line 2303
  gl_putc('\n');
#line 2304
  gl_cleanup();
  }
#line 2305
  return ((char *)pass);
}
}
#line 2354 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static DIR *dir  =    (DIR *)((void *)0);
#line 2355 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int filepfxoffset  ;
#line 2356 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static size_t filepfxlen  ;
#line 2351 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
char *gl_local_filename_completion_proc(char const   *start , int idx ) 
{ 
  char const   *filepfx ;
  struct dirent *dent ;
  char *cp ;
  char const   *dirtoopen ;
  char const   *name ;
  char *dirtoopen1 ;
  size_t len ;
  size_t len2 ;
  struct stat st ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 2366
  if (idx == 0) {
#line 2367
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
      {
#line 2369
      closedir(dir);
#line 2370
      dir = (DIR *)((void *)0);
      }
    }
  }
#line 2374
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 2375
    dirtoopen1 = (char *)((void *)0);
#line 2376
    cp = strrchr(start, '/');
    }
#line 2377
    if ((unsigned long )cp == (unsigned long )start) {
#line 2378
      dirtoopen = "/";
#line 2379
      filepfxoffset = 1;
    } else
#line 2380
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2381
      dirtoopen = ".";
#line 2382
      filepfxoffset = 0;
    } else {
      {
#line 2384
      tmp = strlen(start);
#line 2384
      len = tmp + 1UL;
#line 2385
      tmp___0 = malloc(len);
#line 2385
      dirtoopen1 = (char *)tmp___0;
      }
#line 2386
      if ((unsigned long )dirtoopen1 == (unsigned long )((void *)0)) {
#line 2387
        return ((char *)((void *)0));
      }
      {
#line 2388
      memcpy((void */* __restrict  */)dirtoopen1, (void const   */* __restrict  */)start,
             len);
#line 2389
      len = (size_t )(cp - (char *)start);
#line 2390
      *(dirtoopen1 + len) = (char )'\000';
#line 2391
      dirtoopen = (char const   *)dirtoopen1;
#line 2392
      filepfxoffset = (int )((cp + 1) - (char *)start);
      }
    }
    {
#line 2395
    tmp___1 = strcmp(dirtoopen, "~");
    }
#line 2395
    if (tmp___1 == 0) {
#line 2396
      if ((unsigned long )gl_home_dir == (unsigned long )((void *)0)) {
        {
#line 2397
        gl_set_home_dir((char const   *)((void *)0));
        }
      }
#line 2398
      if ((unsigned long )gl_home_dir == (unsigned long )((void *)0)) {
#line 2399
        return ((char *)((void *)0));
      }
#line 2400
      dirtoopen = (char const   *)gl_home_dir;
    }
    {
#line 2403
    dir = opendir(dirtoopen);
    }
#line 2404
    if ((unsigned long )dirtoopen1 != (unsigned long )((void *)0)) {
      {
#line 2405
      free((void *)dirtoopen1);
      }
    }
    {
#line 2407
    filepfx = start + filepfxoffset;
#line 2408
    filepfxlen = strlen(filepfx);
    }
  }
#line 2411
  if ((unsigned long )dir != (unsigned long )((void *)0)) {
#line 2413
    filepfx = start + filepfxoffset;
    {
#line 2415
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2416
      dent = readdir(dir);
      }
#line 2417
      if ((unsigned long )dent == (unsigned long )((void *)0)) {
        {
#line 2419
        closedir(dir);
#line 2420
        dir = (DIR *)((void *)0);
        }
#line 2422
        if (idx == 1) {
#line 2428
          cp = *(gl_matchlist + 0);
#line 2429
          if ((int )*(cp + 0) == 126) {
#line 2429
            if ((int )*(cp + 1) == 0) {
#line 2429
              goto _L;
            } else
#line 2429
            if ((int )*(cp + 1) == 47) {
              _L: /* CIL Label */ 
              {
#line 2430
              tmp___2 = strlen((char const   *)(cp + 1));
#line 2430
              len = tmp___2 + 1UL;
#line 2431
              len2 = strlen((char const   *)gl_home_dir);
              }
#line 2432
              if ((int )*(gl_home_dir + (len2 - 1UL)) == 47) {
#line 2433
                len2 --;
              }
              {
#line 2434
              tmp___3 = realloc((void *)*(gl_matchlist + 0), len + len2);
#line 2434
              cp = (char *)tmp___3;
              }
#line 2435
              if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2436
                cp = *(gl_matchlist + 0);
              } else {
                {
#line 2438
                memmove((void *)(cp + len2), (void const   *)(cp + 1), len);
#line 2439
                memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)gl_home_dir,
                       len2);
#line 2440
                *(gl_matchlist + 0) = cp;
                }
              }
            }
          }
          {
#line 2443
          tmp___4 = lstat((char const   */* __restrict  */)cp, (struct stat */* __restrict  */)(& st));
          }
#line 2443
          if (tmp___4 == 0) {
#line 2443
            if ((st.st_mode & 61440U) == 16384U) {
#line 2444
              gl_completion_exact_match_extra_char = '/';
            }
          }
        }
#line 2446
        return ((char *)((void *)0));
      }
#line 2449
      name = (char const   *)(dent->d_name);
#line 2450
      if ((int const   )*(name + 0) == 46) {
#line 2450
        if ((int const   )*(name + 1) == 0) {
#line 2451
          goto __Cont;
        } else
#line 2450
        if ((int const   )*(name + 1) == 46) {
#line 2450
          if ((int const   )*(name + 2) == 0) {
#line 2451
            goto __Cont;
          }
        }
      }
#line 2453
      if (filepfxlen == 0UL) {
#line 2453
        goto _L___0;
      } else {
        {
#line 2453
        tmp___6 = strncmp(name, filepfx, filepfxlen);
        }
#line 2453
        if (tmp___6 == 0) {
          _L___0: /* CIL Label */ 
          {
#line 2455
          len = strlen(name);
#line 2456
          tmp___5 = malloc((((size_t )filepfxoffset + len) + 1UL) + 1UL);
#line 2456
          cp = (char *)tmp___5;
#line 2457
          *cp = (char )'\000';
          }
#line 2458
          if (filepfxoffset > 0) {
            {
#line 2459
            memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)start,
                   (size_t )filepfxoffset);
            }
          }
          {
#line 2460
          memcpy((void */* __restrict  */)(cp + filepfxoffset), (void const   */* __restrict  */)name,
                 len + 1UL);
          }
#line 2461
          return (cp);
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2466
  return ((char *)((void *)0));
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 27 "/usr/include/x86_64-linux-gnu/gnu/libc-version.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gnu_get_libc_release)(void) ;
#line 30
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gnu_get_libc_version)(void) ;
#line 228 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
void DisposeSReadlineInfo(SReadlineInfo *srl ) ;
#line 280
unsigned int ServiceNameToPortNumber(char const   * const  s , int const   proto ) ;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *strtokc(char *parsestr , char const   *delims , char **context ) ;
#line 845 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
char const   gLibNcFTPVersion[39] ;
#line 877
int FTPCloseHost(FTPCIPtr const   cip ) ;
#line 897
int FTPInitConnectionInfo(FTPLIPtr const   lip , FTPCIPtr const   cip , size_t bufSize ) ;
#line 898
int FTPInitLibrary(FTPLIPtr const   lip ) ;
#line 905
int FTPLoginHost(FTPCIPtr const   cip ) ;
#line 909
int FTPOpenHost(FTPCIPtr const   cip ) ;
#line 1002
int FTPInitConnectionInfo2(FTPLIPtr const   lip , FTPCIPtr const   cip , char * const  buf ,
                           size_t bufSize ) ;
#line 1006
void FTPCloseControlConnection(FTPCIPtr const   cip ) ;
#line 1014
int FTPQueryFeatures(FTPCIPtr const   cip ) ;
#line 1015
void FTPManualOverrideFeatures(FTPCIPtr const   cip ) ;
#line 1017
void FTPInitializeAnonPassword(FTPLIPtr const   lip ) ;
#line 1045
void FTPInitialLogEntry(FTPCIPtr const   cip ) ;
#line 130 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
void FTPResetStatusVariables(FTPCIPtr const   cip ) ;
#line 131
void FTPDeallocateHost(FTPCIPtr const   cip ) ;
#line 132
int FTPAllocateHost(FTPCIPtr const   cip ) ;
#line 11 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.h"
int OpenControlConnection(FTPCIPtr const   cip , char *host , unsigned int port ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
void FTPResetStatusVariables(FTPCIPtr const   cip ) 
{ 


  {
  {
#line 16
  cip->errNo = 0;
#line 17
  memset((void *)(& cip->lastFTPCmdResultStr), 0, sizeof(cip->lastFTPCmdResultStr));
#line 18
  cip->lastFTPCmdResultNum = 0;
#line 19
  cip->sec = (double )0;
#line 20
  cip->secLeft = (double )0;
#line 21
  cip->kBytesPerSec = (double )0;
#line 22
  cip->percentCompleted = (double )0;
#line 23
  cip->expectedSize = 0LL;
#line 24
  cip->mdtm = (time_t )0;
#line 25
  cip->nextProgressUpdate = (time_t )0;
#line 26
  cip->stalled = 0;
#line 27
  cip->dataTimedOut = 0;
#line 28
  cip->cancelXfer = 0;
#line 29
  cip->canceling = 0;
#line 30
  cip->canceled = 0;
#line 31
  cip->connected = 0;
#line 32
  cip->loggedIn = 0;
#line 33
  cip->bytesTransferred = 0LL;
#line 34
  cip->curTransferType = 0;
#line 35
  cip->startPoint = 0LL;
#line 36
  cip->dataSocketConnected = 0;
#line 37
  cip->totalDials = 0;
#line 38
  memset((void *)(& cip->connectTime), 0, sizeof(cip->connectTime));
#line 39
  memset((void *)(& cip->loginTime), 0, sizeof(cip->loginTime));
#line 40
  memset((void *)(& cip->disconnectTime), 0, sizeof(cip->disconnectTime));
#line 41
  memset((void *)(& cip->lastCmdStart), 0, sizeof(cip->lastCmdStart));
#line 42
  memset((void *)(& cip->lastCmdFinish), 0, sizeof(cip->lastCmdFinish));
#line 43
  cip->numDownloads = 0;
#line 44
  cip->numUploads = 0;
#line 45
  cip->numListings = 0;
  }
#line 46
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
void FTPDeallocateHost(FTPCIPtr const   cip ) 
{ 


  {
#line 58
  if ((unsigned long )cip->buf != (unsigned long )((void *)0)) {
    {
#line 59
    memset((void *)cip->buf, 0, cip->bufSize);
    }
#line 60
    if (cip->doAllocBuf != 0) {
      {
#line 61
      free((void *)cip->buf);
#line 62
      cip->buf = (char *)((void *)0);
      }
    }
  }
#line 66
  if ((unsigned long )cip->startingWorkingDirectory != (unsigned long )((void *)0)) {
    {
#line 67
    free((void *)cip->startingWorkingDirectory);
#line 68
    cip->startingWorkingDirectory = (char *)((void *)0);
    }
  }
  {
#line 72
  DisposeSReadlineInfo(& cip->ctrlSrl);
#line 74
  DisposeLineListContents(& cip->lastFTPCmdResultLL);
  }
#line 76
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPAllocateHost(FTPCIPtr const   cip ) 
{ 
  char *buf ;
  void *tmp ;

  {
#line 90
  if ((unsigned long )cip->buf == (unsigned long )((void *)0)) {
#line 91
    if (cip->doAllocBuf == 0) {
#line 93
      cip->errNo = -139;
#line 94
      return (-139);
    } else {
      {
#line 96
      tmp = calloc((size_t )1, cip->bufSize);
#line 96
      buf = (char *)tmp;
      }
#line 97
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 98
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 99
        cip->errNo = -123;
        }
#line 100
        return (-123);
      }
#line 102
      cip->buf = buf;
    }
  } else {
    {
#line 105
    memset((void *)cip->buf, 0, cip->bufSize);
    }
  }
#line 107
  return (0);
}
}
#line 113 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
void FTPInitializeAnonPassword(FTPLIPtr const   lip ) 
{ 
  int tmp ;

  {
#line 116
  if ((unsigned long )lip == (unsigned long )((void *)0)) {
#line 117
    return;
  }
  {
#line 118
  tmp = strcmp((char const   *)(lip->magic), "LibNcFTP 3.2.5");
  }
#line 118
  if (tmp) {
#line 119
    return;
  }
#line 121
  if ((int )lip->defaultAnonPassword[0] == 0) {
    {
#line 122
    Strncpy((char */* const  */)(lip->defaultAnonPassword), (char const   */* const  */)"NcFTP@",
            (size_t const   )sizeof(lip->defaultAnonPassword));
    }
  }
#line 123
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPLoginHost(FTPCIPtr const   cip ) 
{ 
  ResponsePtr rp ;
  int result ;
  int anonLogin ;
  int sentpass ;
  int fwsentpass ;
  int fwloggedin ;
  int firstTime ;
  char cwd[512] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 132
  result = -156;
#line 134
  sentpass = 0;
#line 134
  fwsentpass = 0;
#line 139
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 140
    return (-139);
  }
#line 141
  if (cip->firewallType < 0) {
#line 142
    return (-139);
  } else
#line 141
  if (cip->firewallType > 9) {
#line 142
    return (-139);
  }
  {
#line 144
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 144
  if (tmp) {
#line 145
    return (-138);
  }
#line 147
  anonLogin = 0;
#line 148
  if ((int )cip->user[0] == 0) {
    {
#line 149
    Strncpy((char */* const  */)(cip->user), (char const   */* const  */)"anonymous",
            (size_t const   )sizeof(cip->user));
    }
  }
  {
#line 150
  tmp___0 = strcmp((char const   *)(cip->user), "anonymous");
  }
#line 150
  if (tmp___0 == 0) {
#line 150
    goto _L;
  } else {
    {
#line 150
    tmp___1 = strcmp((char const   *)(cip->user), "ftp");
    }
#line 150
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
#line 151
      anonLogin = 1;
#line 155
      if ((int )cip->pass[0] == 0) {
#line 155
        if (cip->passIsEmpty == 0U) {
          {
#line 156
          FTPInitializeAnonPassword((FTPLIPtr const   )cip->lip);
#line 157
          Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)((cip->lip)->defaultAnonPassword),
                  (size_t const   )sizeof(cip->pass));
          }
        }
      }
    }
  }
  {
#line 161
  rp = InitResponse();
  }
#line 162
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 163
    result = -123;
#line 164
    cip->errNo = -123;
#line 165
    goto done2;
  }
#line 168
  firstTime = 1;
#line 168
  fwloggedin = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (firstTime != 0) {
#line 178
      rp->code = 220;
#line 179
      firstTime = 0;
    } else
#line 180
    if (result < 0) {
#line 181
      goto done;
    }
    {
#line 185
    if (rp->code == 220) {
#line 185
      goto case_220;
    }
#line 218
    if (rp->code == 202) {
#line 218
      goto case_202;
    }
#line 218
    if (rp->code == 231) {
#line 218
      goto case_202;
    }
#line 218
    if (rp->code == 230) {
#line 218
      goto case_202;
    }
#line 245
    if (rp->code == 421) {
#line 245
      goto case_421;
    }
#line 249
    if (rp->code == 331) {
#line 249
      goto case_331;
    }
#line 283
    if (rp->code == 532) {
#line 283
      goto case_532;
    }
#line 283
    if (rp->code == 332) {
#line 283
      goto case_532;
    }
#line 288
    if (rp->code == 530) {
#line 288
      goto case_530;
    }
#line 294
    if (rp->code == 550) {
#line 294
      goto case_550;
    }
#line 294
    if (rp->code == 503) {
#line 294
      goto case_550;
    }
#line 294
    if (rp->code == 501) {
#line 294
      goto case_550;
    }
#line 297
    goto unknown;
    case_220: /* CIL Label */ 
#line 186
    if (cip->firewallType == 0) {
      {
#line 187
      ReInitResponse(cip, rp);
#line 188
      result = RCmd(cip, rp, "USER %s", cip->user);
      }
    } else
#line 186
    if (fwloggedin != 0) {
      {
#line 187
      ReInitResponse(cip, rp);
#line 188
      result = RCmd(cip, rp, "USER %s", cip->user);
      }
    } else
#line 186
    if (fwsentpass != 0) {
      {
#line 187
      ReInitResponse(cip, rp);
#line 188
      result = RCmd(cip, rp, "USER %s", cip->user);
      }
    } else
#line 189
    if (cip->firewallType == 1) {
      {
#line 190
      ReInitResponse(cip, rp);
#line 191
      result = RCmd(cip, rp, "USER %s@%s", cip->user, cip->host);
      }
    } else
#line 192
    if (cip->firewallType == 8) {
      {
#line 193
      ReInitResponse(cip, rp);
#line 194
      result = RCmd(cip, rp, "USER %s@%s:%u", cip->user, cip->host, cip->port);
      }
    } else
#line 195
    if (cip->firewallType == 9) {
      {
#line 196
      ReInitResponse(cip, rp);
#line 197
      result = RCmd(cip, rp, "USER %s@%s %u", cip->user, cip->host, cip->port);
      }
    } else
#line 198
    if (cip->firewallType == 5) {
      {
#line 199
      ReInitResponse(cip, rp);
#line 200
      result = RCmd(cip, rp, "USER %s@%s@%s", cip->user, cip->firewallUser, cip->host);
      }
    } else
#line 201
    if (cip->firewallType == 7) {
      {
#line 202
      ReInitResponse(cip, rp);
#line 203
      result = RCmd(cip, rp, "USER %s@%s %s", cip->user, cip->host, cip->firewallUser);
      }
    } else
#line 204
    if (cip->firewallType == 6) {
      {
#line 206
      ReInitResponse(cip, rp);
#line 207
      result = RCmd(cip, rp, "USER %s@%s", cip->firewallUser, cip->host);
      }
    } else
#line 208
    if (cip->firewallType > 0) {
      {
#line 209
      ReInitResponse(cip, rp);
#line 210
      result = RCmd(cip, rp, "USER %s", cip->firewallUser);
      }
    } else {
#line 212
      goto unknown;
    }
#line 214
    goto switch_break;
    case_202: /* CIL Label */ 
    case_231: /* CIL Label */ 
    case_230: /* CIL Label */ 
#line 219
    if (cip->firewallType == 0) {
#line 220
      goto okay;
    } else
#line 219
    if (fwloggedin != 0) {
#line 220
      goto okay;
    }
#line 223
    fwloggedin ++;
#line 225
    if (cip->firewallType == 2) {
      {
#line 226
      ReInitResponse(cip, rp);
#line 227
      result = RCmd(cip, rp, "USER %s@%s", cip->user, cip->host);
      }
    } else
#line 228
    if (cip->firewallType == 5) {
#line 229
      goto okay;
    } else
#line 230
    if (cip->firewallType == 4) {
      {
#line 231
      ReInitResponse(cip, rp);
#line 232
      result = RCmd(cip, rp, "OPEN %s", cip->host);
      }
    } else
#line 233
    if (cip->firewallType == 3) {
      {
#line 234
      ReInitResponse(cip, rp);
#line 235
      result = RCmd(cip, rp, "SITE %s", cip->host);
      }
    } else
#line 236
    if (cip->firewallType == 6) {
      {
#line 238
      ReInitResponse(cip, rp);
#line 239
      result = RCmd(cip, rp, "USER %s", cip->user);
      }
    } else {
#line 241
      goto okay;
    }
#line 243
    goto switch_break;
    case_421: /* CIL Label */ 
#line 246
    result = -153;
#line 247
    goto done;
    case_331: /* CIL Label */ 
#line 250
    if (cip->firewallType == 0) {
#line 250
      goto _L___0;
    } else
#line 250
    if (fwloggedin != 0) {
#line 250
      goto _L___0;
    } else
#line 250
    if (fwsentpass != 0) {
      _L___0: /* CIL Label */ 
#line 251
      if ((int )cip->pass[0] == 0) {
#line 251
        if (cip->passIsEmpty == 0U) {
#line 251
          if ((unsigned long )cip->passphraseProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                                FTPLineListPtr pwPrompt ,
                                                                                char *pass ,
                                                                                size_t dsize ))0)) {
            {
#line 252
            (*(cip->passphraseProc))(cip, & rp->msg, cip->pass, sizeof(cip->pass));
            }
          }
        }
      }
      {
#line 253
      ReInitResponse(cip, rp);
#line 254
      result = RCmd(cip, rp, "PASS %s", cip->pass);
#line 255
      sentpass ++;
      }
    } else
#line 256
    if (cip->firewallType == 1) {
      {
#line 257
      ReInitResponse(cip, rp);
#line 258
      result = RCmd(cip, rp, "PASS %s", cip->pass);
#line 259
      sentpass ++;
      }
    } else
#line 256
    if (cip->firewallType == 8) {
      {
#line 257
      ReInitResponse(cip, rp);
#line 258
      result = RCmd(cip, rp, "PASS %s", cip->pass);
#line 259
      sentpass ++;
      }
    } else
#line 256
    if (cip->firewallType == 9) {
      {
#line 257
      ReInitResponse(cip, rp);
#line 258
      result = RCmd(cip, rp, "PASS %s", cip->pass);
#line 259
      sentpass ++;
      }
    } else
#line 260
    if (cip->firewallType == 5) {
      {
#line 261
      ReInitResponse(cip, rp);
#line 262
      result = RCmd(cip, rp, "PASS %s@%s", cip->pass, cip->firewallPass);
#line 263
      fwsentpass ++;
      }
    } else
#line 264
    if (cip->firewallType == 7) {
      {
#line 265
      ReInitResponse(cip, rp);
#line 266
      result = RCmd(cip, rp, "PASS %s", cip->pass);
#line 267
      sentpass ++;
      }
    } else
#line 268
    if (cip->firewallType == 6) {
      {
#line 270
      ReInitResponse(cip, rp);
#line 271
      result = RCmd(cip, rp, "PASS %s", cip->firewallPass);
#line 272
      fwsentpass ++;
      }
    } else
#line 273
    if (cip->firewallType > 0) {
      {
#line 274
      ReInitResponse(cip, rp);
#line 275
      result = RCmd(cip, rp, "PASS %s", cip->firewallPass);
#line 276
      fwsentpass ++;
      }
    } else {
#line 278
      goto unknown;
    }
#line 280
    goto switch_break;
    case_532: /* CIL Label */ 
    case_332: /* CIL Label */ 
    {
#line 284
    ReInitResponse(cip, rp);
    }
#line 285
    if ((int )cip->acct[0] != 0) {
#line 285
      tmp___2 = cip->acct;
    } else {
#line 285
      tmp___2 = cip->firewallPass;
    }
    {
#line 285
    result = RCmd(cip, rp, "ACCT %s", tmp___2);
    }
#line 286
    goto switch_break;
    case_530: /* CIL Label */ 
#line 289
    if (sentpass != 0) {
#line 289
      result = -155;
    } else {
#line 289
      result = -154;
    }
#line 290
    goto done;
    case_550: /* CIL Label */ 
    case_503: /* CIL Label */ 
    case_501: /* CIL Label */ 
#line 295
    goto done;
    unknown: 
    switch_default: /* CIL Label */ 
#line 299
    if ((unsigned long )rp->msg.first == (unsigned long )((void *)0)) {
      {
#line 300
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Lost connection during login.\n");
      }
    } else {
      {
#line 302
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Unexpected response: %s\n",
                  (rp->msg.first)->line);
      }
    }
#line 306
    goto done;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  okay: 
#line 312
  if ((unsigned long )cip->onLoginMsgProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                        ResponsePtr  ))0)) {
    {
#line 313
    (*(cip->onLoginMsgProc))(cip, rp);
    }
  }
  {
#line 314
  DoneWithResponse(cip, rp);
#line 315
  result = 0;
#line 316
  cip->loggedIn = 1;
  }
#line 322
  if ((unsigned long )cip->startingWorkingDirectory != (unsigned long )((void *)0)) {
    {
#line 323
    free((void *)cip->startingWorkingDirectory);
#line 324
    cip->startingWorkingDirectory = (char *)((void *)0);
    }
  }
#line 326
  if (cip->doNotGetStartingWorkingDirectory == 0) {
    {
#line 326
    tmp___3 = FTPGetCWD(cip, (char */* const  */)(cwd), (size_t const   )sizeof(cwd));
    }
#line 326
    if (tmp___3 == 0) {
      {
#line 329
      cip->startingWorkingDirectory = StrDup((char const   *)(cwd));
      }
    }
  }
  {
#line 333
  cip->curTransferType = 'A';
#line 334
  PrintF(cip, (char const   */* const  */)"Logged in to %s as %s.\n", cip->host, cip->user);
  }
#line 339
  if (anonLogin == 0) {
#line 339
    if (cip->leavePass == 0) {
      {
#line 340
      memset((void *)(cip->pass), '*', sizeof(cip->pass) - 1UL);
      }
    }
  }
  {
#line 342
  gettimeofday((struct timeval */* __restrict  */)(& cip->loginTime), (__timezone_ptr_t )((void *)0));
  }
#line 343
  return (result);
  done: 
  {
#line 346
  DoneWithResponse(cip, rp);
  }
  done2: 
#line 349
  if (anonLogin == 0) {
#line 349
    if (cip->leavePass == 0) {
      {
#line 354
      if (result == -153) {
#line 354
        goto case_neg_153;
      }
#line 354
      if (result == -158) {
#line 354
        goto case_neg_153;
      }
#line 354
      if (result == -120) {
#line 354
        goto case_neg_153;
      }
#line 354
      if (result == -119) {
#line 354
        goto case_neg_153;
      }
#line 356
      goto switch_default___0;
      case_neg_153: /* CIL Label */ 
      case_neg_158: /* CIL Label */ 
      case_neg_120: /* CIL Label */ 
      case_neg_119: /* CIL Label */ 
#line 355
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 360
      memset((void *)(cip->pass), '*', sizeof(cip->pass) - 1UL);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 363
  if (result > 0) {
#line 364
    tmp___4 = -203;
#line 364
    cip->errNo = tmp___4;
#line 364
    result = tmp___4;
  }
#line 366
  if (result < 0) {
#line 367
    cip->errNo = result;
  } else {
    {
#line 369
    gettimeofday((struct timeval */* __restrict  */)(& cip->loginTime), (__timezone_ptr_t )((void *)0));
    }
  }
#line 371
  return (result);
}
}
#line 377 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
static void FTPExamineMlstFeatures(FTPCIPtr const   cip , char const   *features ) 
{ 
  char buf[256] ;
  char *feat ;
  int flags___0 ;
  char *ctext ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 384
  flags___0 = 0;
#line 385
  Strncpy((char */* const  */)(buf), (char const   */* const  */)features, (size_t const   )sizeof(buf));
#line 386
  ctext = (char *)((void *)0);
#line 387
  feat = strtokc(buf, ";*", & ctext);
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )feat != (unsigned long )((void *)0))) {
#line 388
      goto while_break;
    }
    {
#line 389
    tmp = strncasecmp((char const   *)feat, "OS.", (size_t )3);
    }
#line 389
    if (tmp == 0) {
#line 390
      feat += 3;
    }
    {
#line 391
    tmp___9 = strcasecmp((char const   *)feat, "type");
    }
#line 391
    if (tmp___9 == 0) {
#line 392
      flags___0 |= 1;
    } else {
      {
#line 393
      tmp___8 = strcasecmp((char const   *)feat, "size");
      }
#line 393
      if (tmp___8 == 0) {
#line 394
        flags___0 |= 2;
      } else {
        {
#line 395
        tmp___7 = strcasecmp((char const   *)feat, "modify");
        }
#line 395
        if (tmp___7 == 0) {
#line 396
          flags___0 |= 4;
        } else {
          {
#line 397
          tmp___6 = strcasecmp((char const   *)feat, "UNIX.mode");
          }
#line 397
          if (tmp___6 == 0) {
#line 398
            flags___0 |= 8;
          } else {
            {
#line 399
            tmp___5 = strcasecmp((char const   *)feat, "UNIX.owner");
            }
#line 399
            if (tmp___5 == 0) {
#line 400
              flags___0 |= 16;
            } else {
              {
#line 401
              tmp___4 = strcasecmp((char const   *)feat, "UNIX.group");
              }
#line 401
              if (tmp___4 == 0) {
#line 402
                flags___0 |= 32;
              } else {
                {
#line 403
                tmp___3 = strcasecmp((char const   *)feat, "perm");
                }
#line 403
                if (tmp___3 == 0) {
#line 404
                  flags___0 |= 64;
                } else {
                  {
#line 405
                  tmp___2 = strcasecmp((char const   *)feat, "UNIX.uid");
                  }
#line 405
                  if (tmp___2 == 0) {
#line 406
                    flags___0 |= 128;
                  } else {
                    {
#line 407
                    tmp___1 = strcasecmp((char const   *)feat, "UNIX.gid");
                    }
#line 407
                    if (tmp___1 == 0) {
#line 408
                      flags___0 |= 256;
                    } else {
                      {
#line 409
                      tmp___0 = strcasecmp((char const   *)feat, "UNIX.gid");
                      }
#line 409
                      if (tmp___0 == 0) {
#line 410
                        flags___0 |= 512;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 412
    feat = strtokc((char *)((void *)0), ";*", & ctext);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  cip->mlsFeatures = flags___0;
#line 416
  return;
}
}
#line 421 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPQueryFeatures(FTPCIPtr const   cip ) 
{ 
  ResponsePtr rp ;
  int result ;
  FTPLinePtr lp ;
  char *cp ;
  char *p___5 ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 429
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 430
    return (-139);
  }
  {
#line 431
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 431
  if (tmp) {
#line 432
    return (-138);
  }
#line 434
  if (cip->serverType == 4) {
#line 435
    cip->hasNLST_a = 0;
#line 436
    cip->hasNLST_d = 0;
#line 437
    cip->hasSITE_UTIME = 0;
#line 438
    cip->hasRETR_tar = 0;
  }
#line 441
  if (cip->serverType == 11) {
#line 446
    cip->hasPASV = 1;
#line 447
    cip->hasSIZE = 0;
#line 448
    cip->hasMDTM = 0;
#line 449
    cip->hasMDTM_set = 0;
#line 450
    cip->hasREST = 0;
#line 451
    cip->NLSTfileParamWorks = 1;
#line 452
    cip->hasCLNT = 0;
#line 453
    cip->hasMLST = 0;
#line 454
    cip->hasMLSD = 0;
#line 455
    cip->hasSITE_UTIME = 0;
#line 456
    cip->hasHELP_SITE = 0;
#line 457
    cip->hasRETR_tar = 0;
#line 458
    return (0);
  }
#line 461
  if (cip->serverType == 3) {
#line 463
    cip->hasNLST_a = 0;
  }
#line 467
  if (cip->serverType == 13) {
#line 467
    goto _L;
  } else
#line 467
  if (cip->serverType == 15) {
#line 467
    goto _L;
  } else
#line 467
  if (cip->serverType == 14) {
    _L: /* CIL Label */ 
#line 471
    cip->hasCLNT = 0;
#line 472
    cip->hasMLST = 0;
#line 473
    cip->hasMLSD = 0;
#line 474
    cip->hasSITE_UTIME = 0;
#line 475
    cip->hasHELP_SITE = 0;
#line 476
    cip->hasMFMT = 0;
#line 477
    cip->hasMFF = 0;
#line 478
    cip->hasRETR_tar = 0;
  }
#line 486
  if (cip->serverType == 1) {
#line 487
    cip->hasPASV = 1;
#line 488
    cip->hasSIZE = 1;
#line 489
    cip->hasMDTM = 1;
#line 490
    cip->hasMDTM_set = 1;
#line 491
    cip->hasREST = 1;
#line 492
    cip->NLSTfileParamWorks = 1;
  } else
#line 493
  if (cip->serverType == 2) {
#line 494
    cip->hasPASV = 1;
#line 495
    cip->hasSIZE = 1;
#line 496
    cip->hasMDTM = 1;
#line 497
    cip->hasREST = 1;
#line 498
    cip->NLSTfileParamWorks = 1;
  }
#line 501
  if (cip->hasFEAT == 0) {
#line 502
    return (0);
  }
  {
#line 505
  rp = InitResponse();
  }
#line 506
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 507
    cip->errNo = -123;
#line 508
    result = cip->errNo;
#line 509
    return (result);
  }
  {
#line 512
  rp->printMode = 3;
#line 513
  result = RCmd(cip, rp, "FEAT");
  }
#line 514
  if (result < 0) {
    {
#line 515
    DoneWithResponse(cip, rp);
    }
#line 516
    return (result);
  } else
#line 517
  if (result != 2) {
#line 522
    cip->hasMLST = 0;
#line 523
    cip->hasMLSD = 0;
#line 524
    cip->hasMFMT = 0;
#line 525
    cip->hasMFF = 0;
  } else {
#line 527
    cip->hasFEAT = 1;
#line 529
    lp = rp->msg.first;
    {
#line 529
    while (1) {
      while_continue: /* CIL Label */ ;
#line 529
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 529
        goto while_break;
      }
#line 537
      cp = lp->line;
      {
#line 538
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 538
        if ((int )*cp != 0) {
          {
#line 538
          tmp___0 = __ctype_b_loc();
          }
#line 538
          if (! ((int const   )*(*tmp___0 + (int )*cp) & 8192)) {
#line 538
            goto while_break___0;
          }
        } else {
#line 538
          goto while_break___0;
        }
#line 539
        cp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 540
      if ((int )*cp == 0) {
#line 541
        goto __Cont;
      }
      {
#line 542
      tmp___10 = strncasecmp((char const   *)cp, "PASV", (size_t )4);
      }
#line 542
      if (tmp___10 == 0) {
#line 543
        cip->hasPASV = 1;
      } else {
        {
#line 544
        tmp___9 = strncasecmp((char const   *)cp, "SIZE", (size_t )4);
        }
#line 544
        if (tmp___9 == 0) {
#line 545
          cip->hasSIZE = 1;
        } else {
          {
#line 546
          tmp___8 = strncasecmp((char const   *)cp, "MDTM", (size_t )4);
          }
#line 546
          if (tmp___8 == 0) {
#line 547
            cip->hasMDTM = 1;
          } else {
            {
#line 548
            tmp___7 = strncasecmp((char const   *)cp, "MFMT", (size_t )4);
            }
#line 548
            if (tmp___7 == 0) {
#line 549
              cip->hasMFMT = 1;
            } else {
              {
#line 550
              tmp___6 = strncasecmp((char const   *)cp, "MFF", (size_t )3);
              }
#line 550
              if (tmp___6 == 0) {
#line 551
                cip->hasMFF = 1;
              } else {
                {
#line 552
                tmp___5 = strncasecmp((char const   *)cp, "REST", (size_t )4);
                }
#line 552
                if (tmp___5 == 0) {
#line 553
                  cip->hasREST = 1;
                } else {
                  {
#line 554
                  tmp___4 = strncasecmp((char const   *)cp, "UTIME", (size_t )5);
                  }
#line 554
                  if (tmp___4 == 0) {
#line 555
                    cip->hasSITE_UTIME = 1;
                  } else {
                    {
#line 556
                    tmp___3 = strncasecmp((char const   *)cp, "MLST", (size_t )4);
                    }
#line 556
                    if (tmp___3 == 0) {
                      {
#line 557
                      cip->hasMLST = 1;
#line 558
                      cip->hasMLSD = 1;
#line 559
                      FTPExamineMlstFeatures(cip, (char const   *)(cp + 5));
                      }
                    } else {
                      {
#line 560
                      tmp___2 = strncasecmp((char const   *)cp, "CLNT", (size_t )4);
                      }
#line 560
                      if (tmp___2 == 0) {
#line 561
                        cip->hasCLNT = 1;
                      } else {
                        {
#line 562
                        tmp___1 = strncasecmp((char const   *)cp, "Compliance Level: ",
                                              (size_t )18);
                        }
#line 562
                        if (tmp___1 == 0) {
                          {
#line 568
                          cip->ietfCompatLevel = atoi((char const   *)(cp + 18));
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 529
      lp = lp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 577
  ReInitResponse(cip, rp);
  }
#line 578
  if (cip->hasHELP_SITE == 0) {
#line 578
    result = -1;
  } else {
    {
#line 578
    tmp___11 = RCmd(cip, rp, "HELP SITE");
#line 578
    result = tmp___11;
    }
  }
#line 579
  if (result == 2) {
#line 580
    cip->hasHELP_SITE = 1;
#line 581
    lp = rp->msg.first;
    {
#line 581
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 581
        goto while_break___1;
      }
      {
#line 582
      cp = lp->line;
#line 583
      tmp___12 = strstr((char const   *)cp, "RETRBUFSIZE");
      }
#line 583
      if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 584
        cip->hasSITE_RETRBUFSIZE = 1;
      }
      {
#line 585
      tmp___13 = strstr((char const   *)cp, "RBUFSZ");
      }
#line 585
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 586
        cip->hasSITE_RBUFSZ = 1;
      }
      {
#line 588
      p___5 = strstr((char const   *)cp, "RBUFSIZ");
      }
#line 588
      if ((unsigned long )p___5 != (unsigned long )((void *)0)) {
#line 588
        if ((unsigned long )p___5 == (unsigned long )cp) {
#line 595
          cip->hasSITE_RBUFSIZ = 1;
        } else
#line 588
        if ((unsigned long )p___5 > (unsigned long )cp) {
          {
#line 588
          tmp___14 = __ctype_b_loc();
          }
#line 588
          if (! ((int const   )*(*tmp___14 + (int )*(p___5 + -1)) & 256)) {
#line 595
            cip->hasSITE_RBUFSIZ = 1;
          }
        }
      }
      {
#line 596
      tmp___15 = strstr((char const   *)cp, "STORBUFSIZE");
      }
#line 596
      if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 597
        cip->hasSITE_STORBUFSIZE = 1;
      }
      {
#line 598
      tmp___16 = strstr((char const   *)cp, "SBUFSIZ");
      }
#line 598
      if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
#line 599
        cip->hasSITE_SBUFSIZ = 1;
      }
      {
#line 600
      tmp___17 = strstr((char const   *)cp, "SBUFSZ");
      }
#line 600
      if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 601
        cip->hasSITE_SBUFSZ = 1;
      }
      {
#line 602
      tmp___18 = strstr((char const   *)cp, "BUFSIZE");
      }
#line 602
      if ((unsigned long )tmp___18 != (unsigned long )((void *)0)) {
#line 603
        cip->hasSITE_BUFSIZE = 1;
      }
#line 581
      lp = lp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 606
  DoneWithResponse(cip, rp);
  }
#line 608
  return (0);
}
}
#line 613 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPCloseHost(FTPCIPtr const   cip ) 
{ 
  ResponsePtr rp ;
  int result ;
  int tmp ;

  {
#line 619
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 620
    return (-139);
  }
  {
#line 621
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 621
  if (tmp) {
#line 622
    return (-138);
  }
#line 625
  if (cip->dataSocket != -1) {
    {
#line 626
    FTPAbortDataTransfer(cip);
    }
  }
#line 628
  result = 0;
#line 629
  if (cip->connected != 0) {
    {
#line 630
    rp = InitResponse();
    }
#line 631
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 632
      cip->errNo = -123;
#line 633
      result = cip->errNo;
    } else {
      {
#line 635
      rp->eofOkay = 1;
#line 636
      cip->eofOkay = 1;
#line 637
      RCmd(cip, rp, "QUIT");
#line 638
      DoneWithResponse(cip, rp);
      }
    }
  }
  {
#line 642
  FTPCloseControlConnection(cip);
#line 647
  FTPDeallocateHost(cip);
  }
#line 649
  if (cip->disconnectTime.tv_sec == 0L) {
    {
#line 650
    gettimeofday((struct timeval */* __restrict  */)(& cip->disconnectTime), (__timezone_ptr_t )((void *)0));
    }
  }
#line 651
  return (result);
}
}
#line 657 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
void FTPInitialLogEntry(FTPCIPtr const   cip ) 
{ 
  struct utsname u ;
  int tmp ;
  FILE *etc_fp ;
  char const   **etc_fn ;
  char etc_line[256] ;
  char *etc_cp ;
  char const   *etc_fnames[13] ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 664
  if (cip->startTime.tv_sec == 0L) {
    {
#line 665
    gettimeofday((struct timeval */* __restrict  */)(& cip->startTime), (__timezone_ptr_t )((void *)0));
#line 673
    PrintF(cip, (char const   */* const  */)"%s compiled for %s\n", gLibNcFTPVersion + 5,
           "linux-x86_64-glibc2.19");
#line 687
    memset((void *)(& u), 0, sizeof(u));
#line 688
    tmp = uname(& u);
    }
#line 688
    if (tmp == 0) {
      {
#line 689
      PrintF(cip, (char const   */* const  */)"Uname: %s|%s|%s|%s|%s\n", u.sysname,
             u.nodename, u.release, u.version, u.machine);
      }
    }
#line 756
    etc_fnames[0] = "/etc/yellowdog-release";
#line 756
    etc_fnames[1] = "/etc/gentoo-release";
#line 756
    etc_fnames[2] = "/etc/turbolinux-release";
#line 756
    etc_fnames[3] = "/etc/slackware-release";
#line 756
    etc_fnames[4] = "/etc/slackware-version";
#line 756
    etc_fnames[5] = "/etc/mandrake-release";
#line 756
    etc_fnames[6] = "/etc/debian_version";
#line 756
    etc_fnames[7] = "/etc/conectiva-release";
#line 756
    etc_fnames[8] = "/etc/SuSE-release";
#line 756
    etc_fnames[9] = "/etc/fedora-release";
#line 756
    etc_fnames[10] = "/etc/redhat-release";
#line 756
    etc_fnames[11] = "/etc/issue";
#line 756
    etc_fnames[12] = (char const   *)((void *)0);
#line 772
    etc_fn = etc_fnames;
    {
#line 772
    while (1) {
      while_continue: /* CIL Label */ ;
#line 772
      if (! ((unsigned long )*etc_fn != (unsigned long )((void *)0))) {
#line 772
        goto while_break;
      }
      {
#line 773
      etc_fp = fopen((char const   */* __restrict  */)*etc_fn, (char const   */* __restrict  */)"r");
      }
#line 774
      if ((unsigned long )etc_fp != (unsigned long )((void *)0)) {
        {
#line 775
        PrintF(cip, (char const   */* const  */)"Contents of %.127s:\n", *etc_fn);
#line 776
        memset((void *)(etc_line), 0, sizeof(etc_line));
        }
        {
#line 777
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 777
          tmp___2 = fgets((char */* __restrict  */)(etc_line), (int )(sizeof(etc_line) - 1UL),
                          (FILE */* __restrict  */)etc_fp);
          }
#line 777
          if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 777
            goto while_break___0;
          }
          {
#line 778
          tmp___0 = strlen((char const   *)(etc_line));
#line 778
          etc_cp = (etc_line + tmp___0) - 1;
          }
          {
#line 779
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 779
            if ((unsigned long )etc_cp >= (unsigned long )(etc_line)) {
              {
#line 779
              tmp___1 = __ctype_b_loc();
              }
#line 779
              if (! ((int const   )*(*tmp___1 + (int )*etc_cp) & 8192)) {
#line 779
                goto while_break___1;
              }
            } else {
#line 779
              goto while_break___1;
            }
#line 780
            etc_cp --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 781
          etc_cp ++;
#line 782
          *etc_cp = (char )'\000';
#line 783
          if ((int )etc_line[0] != 0) {
            {
#line 784
            PrintF(cip, (char const   */* const  */)"  %.127s\n", etc_line);
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 787
        fclose(etc_fp);
        }
      }
#line 772
      etc_fn ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 794
    tmp___3 = gnu_get_libc_release();
#line 794
    tmp___4 = gnu_get_libc_version();
#line 794
    PrintF(cip, (char const   */* const  */)"Glibc: %s (%s)\n", tmp___4, tmp___3);
    }
  } else {
    {
#line 863
    gettimeofday((struct timeval */* __restrict  */)(& cip->startTime), (__timezone_ptr_t )((void *)0));
    }
  }
#line 865
  return;
}
}
#line 869 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPOpenHost(FTPCIPtr const   cip ) 
{ 
  int result ;
  time_t t0 ;
  time_t t1 ;
  int elapsed ;
  int tmp ;
  int tmp___0 ;

  {
#line 876
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 877
    return (-139);
  }
  {
#line 878
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 878
  if (tmp) {
#line 879
    return (-138);
  }
#line 881
  if ((int )cip->host[0] == 0) {
#line 882
    cip->errNo = -196;
#line 883
    return (-196);
  }
  {
#line 886
  FTPResetStatusVariables(cip);
#line 887
  FTPManualOverrideFeatures(cip);
#line 888
  FTPInitialLogEntry(cip);
#line 890
  result = -118;
#line 890
  cip->numDials = 0;
  }
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (! (cip->maxDials < 0)) {
#line 890
      if (! (cip->numDials < cip->maxDials)) {
#line 890
        goto while_break;
      }
    }
    {
#line 897
    result = FTPAllocateHost(cip);
    }
#line 898
    if (result < 0) {
#line 899
      return (result);
    }
    {
#line 901
    memset((void *)(& cip->connectTime), 0, sizeof(cip->connectTime));
#line 902
    memset((void *)(& cip->loginTime), 0, sizeof(cip->loginTime));
#line 903
    memset((void *)(& cip->disconnectTime), 0, sizeof(cip->disconnectTime));
#line 905
    (cip->totalDials) ++;
#line 906
    (cip->numDials) ++;
    }
#line 907
    if (cip->numDials > 1) {
      {
#line 908
      PrintF(cip, (char const   */* const  */)"Retry Number: %d\n", cip->numDials - 1);
      }
    }
#line 909
    if ((unsigned long )cip->redialStatusProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                            int  ,
                                                                            int  ))0)) {
      {
#line 910
      (*(cip->redialStatusProc))(cip, 0, cip->numDials - 1);
      }
    }
    {
#line 911
    time(& t0);
#line 912
    result = OpenControlConnection(cip, cip->host, cip->port);
#line 913
    time(& t1);
    }
#line 914
    if (result == 0) {
      {
#line 916
      gettimeofday((struct timeval */* __restrict  */)(& cip->connectTime), (__timezone_ptr_t )((void *)0));
#line 917
      PrintF(cip, (char const   */* const  */)"Connected to %s.\n", cip->host);
#line 919
      result = FTPLoginHost(cip);
      }
#line 920
      if (result == 0) {
        {
#line 921
        FTPQueryFeatures(cip);
#line 926
        FTPManualOverrideFeatures(cip);
        }
#line 927
        goto while_break;
      }
      {
#line 931
      FTPCloseHost(cip);
      }
#line 938
      if (result == -155) {
        {
#line 939
        tmp___0 = strcmp((char const   *)(cip->user), "anonymous");
        }
#line 939
        if (tmp___0 != 0) {
#line 943
          goto while_break;
        }
      }
    } else
#line 946
    if (result != -119) {
#line 946
      if (result != -120) {
#line 946
        if (result != -158) {
#line 946
          if (result != -153) {
            {
#line 951
            PrintF(cip, (char const   */* const  */)"Cannot recover from miscellaneous open error %d.\n",
                   result);
            }
#line 952
            if (result > 0) {
#line 953
              result = -202;
            }
            {
#line 954
            FTPDeallocateHost(cip);
            }
#line 955
            return (result);
          }
        }
      }
    }
#line 959
    if (cip->redialDelay > 0) {
#line 961
      if (cip->maxDials < 0) {
#line 961
        goto _L;
      } else
#line 961
      if (cip->numDials < cip->maxDials) {
        _L: /* CIL Label */ 
#line 962
        elapsed = (int )(t1 - t0);
#line 963
        if (elapsed < cip->redialDelay) {
          {
#line 964
          PrintF(cip, (char const   */* const  */)"Sleeping %u seconds.\n", (unsigned int )cip->redialDelay - (unsigned int )elapsed);
          }
#line 966
          if ((unsigned long )cip->redialStatusProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                                  int  ,
                                                                                  int  ))0)) {
            {
#line 967
            (*(cip->redialStatusProc))(cip, 1, cip->redialDelay - elapsed);
            }
          }
          {
#line 968
          sleep((unsigned int )cip->redialDelay - (unsigned int )elapsed);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  if (result > 0) {
#line 974
    result = -202;
  }
#line 975
  if (result != 0) {
    {
#line 976
    FTPDeallocateHost(cip);
    }
  }
#line 977
  return (result);
}
}
#line 983 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPInitConnectionInfo2(FTPLIPtr const   lip , FTPCIPtr const   cip , char * const  buf ,
                           size_t bufSize ) 
{ 
  size_t siz ;
  int tmp ;

  {
#line 988
  if ((unsigned long )lip == (unsigned long )((void *)0)) {
#line 989
    return (-139);
  } else
#line 988
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 989
    return (-139);
  } else
#line 988
  if (bufSize == 0UL) {
#line 989
    return (-139);
  }
  {
#line 991
  siz = sizeof(FTPConnectionInfo );
#line 992
  memset((void *)cip, 0, siz);
#line 994
  tmp = strcmp((char const   *)(lip->magic), "LibNcFTP 3.2.5");
  }
#line 994
  if (tmp) {
#line 995
    return (-138);
  }
#line 997
  cip->bufSize = bufSize;
#line 998
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1000
    cip->buf = (char *)((void *)0);
#line 1001
    cip->doAllocBuf = 1;
  } else {
#line 1004
    cip->buf = (char *)buf;
#line 1005
    cip->doAllocBuf = 0;
  }
  {
#line 1007
  cip->port = lip->defaultPort;
#line 1008
  cip->firewallPort = lip->defaultPort;
#line 1009
  cip->maxDials = 3;
#line 1010
  cip->redialDelay = 20;
#line 1011
  cip->xferTimeout = 600U;
#line 1012
  cip->connTimeout = 10U;
#line 1013
  cip->ctrlTimeout = 135U;
#line 1014
  cip->abortTimeout = 10U;
#line 1015
  cip->ctrlSocketR = -1;
#line 1016
  cip->ctrlSocketW = -1;
#line 1017
  cip->dataPortMode = 2;
#line 1018
  cip->maxNumberOfSuccessivePASVAttempts = 3;
#line 1019
  cip->dataSocket = -1;
#line 1020
  cip->lip = (FTPLIPtr )lip;
#line 1021
  cip->hasPASV = -1;
#line 1022
  cip->hasSIZE = -1;
#line 1023
  cip->hasMDTM = -1;
#line 1024
  cip->hasMDTM_set = -1;
#line 1025
  cip->hasMFMT = -1;
#line 1026
  cip->hasMFF = -1;
#line 1027
  cip->hasREST = -1;
#line 1028
  cip->hasNLST_a = -1;
#line 1029
  cip->hasNLST_d = -1;
#line 1030
  cip->hasFEAT = -1;
#line 1031
  cip->hasMLSD = -1;
#line 1032
  cip->hasMLST = -1;
#line 1033
  cip->hasCLNT = -1;
#line 1034
  cip->hasHELP_SITE = -1;
#line 1035
  cip->hasSITE_UTIME = -1;
#line 1036
  cip->hasSITE_RETRBUFSIZE = -1;
#line 1037
  cip->hasSITE_RBUFSIZ = -1;
#line 1038
  cip->hasSITE_RBUFSZ = -1;
#line 1039
  cip->hasSITE_STORBUFSIZE = -1;
#line 1040
  cip->hasSITE_SBUFSIZ = -1;
#line 1041
  cip->hasSITE_SBUFSZ = -1;
#line 1042
  cip->STATfileParamWorks = -1;
#line 1043
  cip->NLSTfileParamWorks = -1;
#line 1044
  cip->hasRETR_tar = -1;
#line 1045
  cip->firewallType = 0;
#line 1046
  cip->startingWorkingDirectory = (char *)((void *)0);
#line 1047
  cip->shutdownUnusedSideOfSockets = 0;
#line 1048
  cip->asciiTranslationMode = 0;
#line 1057
  cip->textEOLN[0] = (char )'\n';
#line 1060
  InitLineList(& cip->lastFTPCmdResultLL);
#line 1061
  Strncpy((char */* const  */)(cip->magic), (char const   */* const  */)"LibNcFTP 3.2.5",
          (size_t const   )sizeof(cip->magic));
#line 1062
  Strncpy((char */* const  */)(cip->user), (char const   */* const  */)"anonymous",
          (size_t const   )sizeof(cip->user));
#line 1063
  gettimeofday((struct timeval */* __restrict  */)(& cip->initTime), (__timezone_ptr_t )((void *)0));
  }
#line 1064
  return (0);
}
}
#line 1070 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPInitConnectionInfo(FTPLIPtr const   lip , FTPCIPtr const   cip , size_t bufSize ) 
{ 
  int tmp ;

  {
  {
#line 1073
  tmp = FTPInitConnectionInfo2(lip, cip, (char */* const  */)((void *)0), bufSize);
  }
#line 1073
  return (tmp);
}
}
#line 1079 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
int FTPInitLibrary(FTPLIPtr const   lip ) 
{ 


  {
#line 1082
  if ((unsigned long )lip == (unsigned long )((void *)0)) {
#line 1083
    return (-139);
  }
  {
#line 1085
  memset((void *)lip, 0, sizeof(FTPLibraryInfo ));
#line 1087
  lip->defaultPort = ServiceNameToPortNumber((char const   */* const  */)"ftp", (int const   )'t');
  }
#line 1088
  if (lip->defaultPort == 0U) {
#line 1089
    lip->defaultPort = 21U;
  }
  {
#line 1091
  lip->init = 1;
#line 1092
  Strncpy((char */* const  */)(lip->magic), (char const   */* const  */)"LibNcFTP 3.2.5",
          (size_t const   )sizeof(lip->magic));
  }
#line 1102
  return (0);
}
}
#line 955 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void GetUsrName(char *dst , size_t size ) ;
#line 82 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
int GetMyPwEnt(struct passwd *pwp , char * const  pwbuf , size_t pwbufsize ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getusr.c"
void GetUsrName(char *dst , size_t size ) 
{ 
  struct passwd pw ;
  char pwbuf[256] ;
  int tmp ;

  {
  {
#line 29
  tmp = GetMyPwEnt(& pw, (char */* const  */)(pwbuf), sizeof(pwbuf));
  }
#line 29
  if (tmp == 0) {
    {
#line 30
    Strncpy((char */* const  */)dst, (char const   */* const  */)pw.pw_name, (size_t const   )size);
    }
  } else {
    {
#line 32
    Strncpy((char */* const  */)dst, (char const   */* const  */)"UNKNOWN", (size_t const   )size);
    }
  }
#line 35
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SRead(int sfd , char * const  buf0 , size_t size , int tlen , int retry ) ;
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SRead.c"
int SRead(int sfd , char * const  buf0 , size_t size , int tlen , int retry ) 
{ 
  ssize_t nread ;
  size_t nleft ;
  char *buf ;
  int tleft ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  int firstRead ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0 ;
  int __d1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 29
  buf = (char *)buf0;
#line 35
  sigpipe = (void (*)(int  ))0;
#line 37
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 22;
    }
#line 39
    return (-1);
  } else
#line 37
  if (size == 0UL) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 22;
    }
#line 39
    return (-1);
  } else
#line 37
  if (tlen <= 0) {
    {
#line 38
    tmp = __errno_location();
#line 38
    *tmp = 22;
    }
#line 39
    return (-1);
  }
#line 42
  if (sio_sigpipe_ignored_already) {
#line 42
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 42
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 42
    sigpipe = tmp___0;
    }
  }
  {
#line 43
  tmp___1 = __errno_location();
#line 43
  *tmp___1 = 0;
#line 45
  nleft = size;
#line 46
  time(& now);
#line 47
  done = now + (time_t )tlen;
#line 48
  firstRead = 1;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (done > now) {
#line 51
      tleft = (int )(done - now);
    } else {
#line 51
      tleft = 0;
    }
#line 52
    if (tleft < 1) {
#line 53
      nread = (ssize_t )size - (ssize_t )nleft;
#line 54
      if (nread == 0L) {
        {
#line 55
        nread = (ssize_t )-2;
#line 56
        tmp___2 = __errno_location();
#line 56
        *tmp___2 = 110;
        }
      } else
#line 54
      if ((retry & 3) != 0) {
        {
#line 55
        nread = (ssize_t )-2;
#line 56
        tmp___2 = __errno_location();
#line 56
        *tmp___2 = 110;
        }
      }
#line 59
      goto done;
    }
#line 62
    if (! firstRead) {
#line 62
      goto _L;
    } else
#line 62
    if ((retry & 8) == 0) {
      _L: /* CIL Label */ 
      {
#line 63
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 64
        tmp___3 = __errno_location();
#line 64
        *tmp___3 = 0;
        }
        {
#line 65
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 65
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& ss.__fds_bits[0]): "memory");
#line 65
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 70
        ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 74
        tv.tv_sec = (__time_t )((long long )tleft);
#line 75
        tv.tv_usec = (__suseconds_t )0;
#line 76
        result = select(sfd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 77
        if (result >= 1) {
#line 79
          goto while_break___0;
        } else
#line 80
        if (result == 0) {
#line 82
          nread = (ssize_t )size - (ssize_t )nleft;
#line 83
          if (nread > 0L) {
#line 83
            if ((retry & 3) == 0) {
#line 84
              if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 84
                if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
                  {
#line 84
                  signal(13, sigpipe);
                  }
                }
              }
#line 85
              return ((int )nread);
            }
          }
          {
#line 87
          tmp___4 = __errno_location();
#line 87
          *tmp___4 = 110;
          }
#line 89
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 89
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 89
              signal(13, sigpipe);
              }
            }
          }
#line 90
          return (-2);
        } else {
          {
#line 91
          tmp___5 = __errno_location();
          }
#line 91
          if (*tmp___5 != 4) {
#line 92
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 92
              if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
                {
#line 92
                signal(13, sigpipe);
                }
              }
            }
#line 93
            return (-1);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 96
      firstRead = 0;
    }
    {
#line 102
    nread = read(sfd, (void *)buf, nleft);
    }
#line 105
    if (nread <= 0L) {
#line 106
      if (nread == 0L) {
#line 108
        if (retry == ((retry & 2) != 0)) {
#line 109
          nread = (ssize_t )size - (ssize_t )nleft;
        }
#line 110
        goto done;
      } else {
        {
#line 111
        tmp___7 = __errno_location();
        }
#line 111
        if (*tmp___7 != 4) {
#line 112
          nread = (ssize_t )size - (ssize_t )nleft;
#line 113
          if (nread == 0L) {
#line 114
            nread = (ssize_t )-1;
          }
#line 115
          goto done;
        } else {
          {
#line 117
          tmp___6 = __errno_location();
#line 117
          *tmp___6 = 0;
#line 118
          nread = (ssize_t )0;
          }
        }
      }
    }
#line 126
    nleft -= (size_t )nread;
#line 127
    if (nleft == 0UL) {
#line 128
      goto while_break;
    } else
#line 127
    if ((retry & 3) == 0) {
#line 127
      if (nleft != size) {
#line 128
        goto while_break;
      }
    }
    {
#line 129
    buf += nread;
#line 130
    time(& now);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  nread = (ssize_t )size - (ssize_t )nleft;
  done: 
#line 135
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 135
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 135
      signal(13, sigpipe);
      }
    }
  }
#line 136
  return ((int )nread);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 187 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int GetHostEntry(struct hostent * const  hp , char const   * const  host , struct in_addr * const  ip_address ,
                 char * const  hpbuf , size_t hpbufsize ) ;
#line 200
int SAccept(int sfd , struct sockaddr_in * const  addr , int tlen ) ;
#line 208
int SClose(int sfd , int tlen ) ;
#line 211
int SConnect(int sfd , struct sockaddr_in  const  * const  addr , int tlen ) ;
#line 227
int InitSReadlineInfo(SReadlineInfo *srl , int fd , char *buf , size_t bsize , int tlen ,
                      int requireEOLN ) ;
#line 266
int GetSocketBufSize(int const   sockfd , size_t * const  rsize , size_t * const  ssize ) ;
#line 267
int SetSocketBufSize(int const   sockfd , size_t const   rsize , size_t const   ssize ) ;
#line 273
int SetSocketKeepAlive(int const   fd , int const   onoff ) ;
#line 275
int SetSocketTypeOfService(int const   fd , int const   tosType ) ;
#line 277
int SetSocketInlineOutOfBandData(int const   fd , int const   onoff ) ;
#line 284
char *AddrToAddrStr(char * const  dst , size_t dsize , struct sockaddr_in * const  saddrp ,
                    int dns , char const   *fmt ) ;
#line 968 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPFixPrivateAddr(struct sockaddr_in *maybePrivateAddr , struct sockaddr_in *knownNonPrivateAddrToUseIfNeeded ) ;
#line 1003
int FTPSendPort(FTPCIPtr const   cip , struct sockaddr_in *saddr ) ;
#line 1004
int FTPSendPassive(FTPCIPtr const   cip , struct sockaddr_in *saddr , int *weird ) ;
#line 1068
int BindToEphemeralPortNumber(int const   sockfd , struct sockaddr_in * const  addrp ,
                              int const   ephemLo , int const   ephemHi ) ;
#line 86 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
void CloseFile(FILE **f ) ;
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.h"
void FTPFixServerDataAddr(FTPCIPtr const   cip ) ;
#line 10
void FTPFixClientDataAddr(FTPCIPtr const   cip ) ;
#line 16
void HangupOnServer(FTPCIPtr const   cip ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
char const   gLibNcFTPVersion[39]  = 
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'b', 
        (char const   )'N',      (char const   )'c',      (char const   )'F',      (char const   )'T', 
        (char const   )'P',      (char const   )' ',      (char const   )'3',      (char const   )'.', 
        (char const   )'2',      (char const   )'.',      (char const   )'5',      (char const   )' ', 
        (char const   )'(',      (char const   )'J',      (char const   )'a',      (char const   )'n', 
        (char const   )'u',      (char const   )'a',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'1',      (char const   )'7',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'1', 
        (char const   )'1',      (char const   )')',      (char const   )'\000'};
#line 32 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
static char const   gCopyright___0[74]  = 
#line 32
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'b', 
        (char const   )'N',      (char const   )'c',      (char const   )'F',      (char const   )'T', 
        (char const   )'P',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'5', 
        (char const   )'-',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'1',      (char const   )',',      (char const   )' ',      (char const   )'b', 
        (char const   )'y',      (char const   )' ',      (char const   )'M',      (char const   )'i', 
        (char const   )'k',      (char const   )'e',      (char const   )' ',      (char const   )'G', 
        (char const   )'l',      (char const   )'e',      (char const   )'a',      (char const   )'s', 
        (char const   )'o',      (char const   )'n',      (char const   )'.',      (char const   )' ', 
        (char const   )' ',      (char const   )'A',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )'v',      (char const   )'e',      (char const   )'d', 
        (char const   )'.',      (char const   )'\000'};
#line 53 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
static char const   *gPrivateNetworks[19]  = 
#line 53
  {      "192.168.",      "10.",      "172.16.",      "172.17.", 
        "172.18.",      "172.19.",      "172.20.",      "172.21.", 
        "172.22.",      "172.23.",      "172.24.",      "172.25.", 
        "172.26.",      "172.27.",      "172.28.",      "172.29.", 
        "172.30.",      "172.31.",      (char const   *)((void *)0)};
#line 78 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
void FTPCloseControlConnection(FTPCIPtr const   cip ) 
{ 


  {
  {
#line 83
  SClose(cip->ctrlSocketR, 3);
#line 84
  cip->ctrlSocketR = -1;
#line 85
  cip->ctrlSocketW = -1;
#line 86
  DisposeSReadlineInfo(& cip->ctrlSrl);
#line 97
  cip->connected = 0;
#line 98
  cip->loggedIn = 0;
  }
#line 99
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
static int GetSocketAddress(FTPCIPtr const   cip , int sockfd , struct sockaddr_in *saddr ) 
{ 
  socklen_t len ;
  int result ;
  int tmp ;

  {
  {
#line 106
  len = (socklen_t )sizeof(struct sockaddr_in );
#line 107
  result = 0;
#line 109
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)saddr),
                    (socklen_t */* __restrict  */)(& len));
  }
#line 109
  if (tmp < 0) {
    {
#line 110
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not get socket name.\n");
#line 111
    cip->errNo = -110;
#line 112
    result = -110;
    }
  }
#line 114
  return (result);
}
}
#line 137 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int OpenControlConnection(FTPCIPtr const   cip , char *host , unsigned int port ) 
{ 
  struct sockaddr_in localAddr ;
  struct in_addr ip_address ;
  int err ;
  int result ;
  int oerrno ;
  int volatile   sockfd ;
  int volatile   sock2fd ;
  ResponsePtr rp ;
  char ** volatile  curaddr ;
  int hpok ;
  int hprc ;
  struct hostent hp ;
  char * volatile  fhost ;
  unsigned int fport ;
  char const   *firstLine ;
  char const   *secondLine ;
  char const   *srvr ;
  uint16_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;

  {
#line 142
  err = 0;
#line 145
  sockfd = (int volatile   )-1;
#line 146
  sock2fd = (int volatile   )-1;
#line 147
  rp = (ResponsePtr )((void *)0);
#line 167
  if (cip->firewallType == 0) {
#line 168
    fhost = (char */* volatile  */)host;
#line 169
    fport = port;
  } else {
#line 171
    fhost = (char */* volatile  */)(cip->firewallHost);
#line 172
    fport = cip->firewallPort;
  }
#line 174
  if (fport == 0U) {
#line 175
    fport = (cip->lip)->defaultPort;
  }
  {
#line 180
  memset((void *)(& cip->servCtlAddr), 0, sizeof(cip->servCtlAddr));
#line 181
  cip->cin = (FILE *)((void *)0);
#line 182
  cip->cout = (FILE *)((void *)0);
#line 185
  tmp = htons((unsigned short )fport);
#line 185
  fport = (unsigned int )tmp;
#line 187
  cip->servCtlAddr.sin_port = (unsigned short )fport;
#line 189
  hprc = GetHostEntry((struct hostent */* const  */)(& hp), (char const   */* const  */)fhost,
                      (struct in_addr */* const  */)(& ip_address), (char */* const  */)cip->buf,
                      cip->bufSize);
  }
#line 190
  if (hprc != 0) {
#line 191
    hpok = 0;
#line 202
    if (ip_address.s_addr == 4294967295U) {
      {
#line 203
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: unknown host.\n",
                  fhost);
#line 204
      cip->errNo = -105;
      }
#line 205
      return (-105);
    }
#line 207
    cip->servCtlAddr.sin_family = (sa_family_t )2;
#line 208
    cip->servCtlAddr.sin_addr.s_addr = ip_address.s_addr;
  } else {
#line 210
    hpok = 1;
#line 211
    cip->servCtlAddr.sin_family = (sa_family_t )hp.h_addrtype;
  }
#line 221
  if (hpok == 0) {
    {
#line 227
    tmp___0 = socket((int )cip->servCtlAddr.sin_family, 1, 0);
#line 227
    sockfd = (int volatile   )tmp___0;
    }
#line 227
    if (sockfd < (int volatile   )0) {
      {
#line 228
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not get a socket.\n");
#line 229
      cip->errNo = -106;
      }
#line 230
      return (-106);
    }
#line 234
    if ((int )cip->preferredLocalAddr.sin_family != 0) {
      {
#line 235
      localAddr = cip->preferredLocalAddr;
#line 236
      localAddr.sin_port = (in_port_t )0;
#line 237
      tmp___1 = BindToEphemeralPortNumber((int const   )sockfd, (struct sockaddr_in */* const  */)(& localAddr),
                                          (int const   )((int )cip->ephemLo), (int const   )((int )cip->ephemHi));
      }
#line 237
      if (tmp___1 < 0) {
        {
#line 238
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not bind the control socket");
#line 239
        result = -206;
#line 240
        cip->errNo = -206;
#line 241
        SClose((int )sockfd, 3);
        }
#line 242
        return (-206);
      }
    }
    {
#line 251
    SetSocketBufSize((int const   )sockfd, (size_t const   )cip->ctrlSocketRBufSize,
                     (size_t const   )cip->ctrlSocketSBufSize);
#line 254
    err = SConnect((int )sockfd, (struct sockaddr_in  const  */* const  */)(& cip->servCtlAddr),
                   (int )cip->connTimeout);
    }
#line 256
    if (err < 0) {
      {
#line 257
      tmp___2 = __errno_location();
#line 257
      oerrno = *tmp___2;
#line 258
      SClose((int )sockfd, 3);
#line 259
      tmp___3 = __errno_location();
#line 259
      *tmp___3 = oerrno;
#line 260
      sockfd = (int volatile   )-1;
      }
    }
  } else {
#line 319
    curaddr = (char **/* volatile  */)hp.h_addr_list;
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;
#line 319
      if (! ((unsigned long )*curaddr != (unsigned long )((void *)0))) {
#line 319
        goto while_break;
      }
      {
#line 320
      tmp___4 = socket((int )cip->servCtlAddr.sin_family, 1, 0);
#line 320
      sockfd = (int volatile   )tmp___4;
      }
#line 320
      if (sockfd < (int volatile   )0) {
        {
#line 321
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not get a socket.\n");
#line 322
        cip->errNo = -106;
        }
#line 323
        return (-106);
      }
      {
#line 329
      memcpy((void */* __restrict  */)(& cip->servCtlAddr.sin_addr), (void const   */* __restrict  */)*curaddr,
             (size_t )hp.h_length);
      }
#line 332
      if ((int )cip->preferredLocalAddr.sin_family != 0) {
        {
#line 333
        localAddr = cip->preferredLocalAddr;
#line 334
        localAddr.sin_port = (in_port_t )0;
#line 335
        tmp___5 = BindToEphemeralPortNumber((int const   )sockfd, (struct sockaddr_in */* const  */)(& localAddr),
                                            (int const   )((int )cip->ephemLo), (int const   )((int )cip->ephemHi));
        }
#line 335
        if (tmp___5 < 0) {
          {
#line 336
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not bind the control socket");
#line 337
          result = -206;
#line 338
          cip->errNo = -206;
#line 339
          SClose((int )sockfd, 3);
          }
#line 340
          return (-206);
        }
      }
      {
#line 349
      SetSocketBufSize((int const   )sockfd, (size_t const   )cip->ctrlSocketRBufSize,
                       (size_t const   )cip->ctrlSocketSBufSize);
#line 352
      err = SConnect((int )sockfd, (struct sockaddr_in  const  */* const  */)(& cip->servCtlAddr),
                     (int )cip->connTimeout);
      }
#line 354
      if (err == 0) {
#line 355
        goto while_break;
      }
      {
#line 356
      tmp___6 = __errno_location();
#line 356
      oerrno = *tmp___6;
#line 357
      SClose((int )sockfd, 3);
#line 358
      tmp___7 = __errno_location();
#line 358
      *tmp___7 = oerrno;
#line 359
      sockfd = (int volatile   )-1;
#line 319
      curaddr ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 416
  if (err < 0) {
    {
#line 422
    tmp___8 = __errno_location();
    }
    {
#line 449
    if (*tmp___8 == 104) {
#line 449
      goto case_104;
    }
#line 449
    if (*tmp___8 == 112) {
#line 449
      goto case_104;
    }
#line 449
    if (*tmp___8 == 110) {
#line 449
      goto case_104;
    }
#line 449
    if (*tmp___8 == 103) {
#line 449
      goto case_104;
    }
#line 449
    if (*tmp___8 == 101) {
#line 449
      goto case_104;
    }
#line 449
    if (*tmp___8 == 100) {
#line 449
      goto case_104;
    }
#line 457
    if (*tmp___8 == 111) {
#line 457
      goto case_111;
    }
#line 464
    goto switch_default;
    case_104: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 453
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not connect to %s -- try again later.\n",
                fhost);
#line 454
    tmp___9 = -119;
#line 454
    cip->errNo = tmp___9;
#line 454
    result = tmp___9;
    }
#line 455
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 461
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not connect to %s.\n",
                fhost);
#line 462
    tmp___10 = -120;
#line 462
    cip->errNo = tmp___10;
#line 462
    result = tmp___10;
    }
#line 463
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 465
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not connect to %s.\n",
                fhost);
#line 466
    tmp___11 = -118;
#line 466
    cip->errNo = tmp___11;
#line 466
    result = tmp___11;
    }
    switch_break: /* CIL Label */ ;
    }
#line 468
    goto fatal;
  }
  {
#line 472
  result = GetSocketAddress(cip, (int )sockfd, & cip->ourCtlAddr);
  }
#line 472
  if (result < 0) {
#line 473
    goto fatal;
  }
  {
#line 478
  SetSocketInlineOutOfBandData((int const   )sockfd, (int const   )1);
#line 479
  SetSocketKeepAlive((int const   )sockfd, (int const   )1);
#line 480
  SetSocketLinger((int const   )sockfd, (int const   )0, (int const   )0);
#line 485
  SetSocketTypeOfService((int const   )sockfd, (int const   )16);
#line 488
  cip->ctrlSocketR = (int )sockfd;
#line 489
  cip->ctrlSocketW = (int )sockfd;
#line 490
  cip->cout = (FILE *)((void *)0);
#line 491
  cip->cin = (FILE *)((void *)0);
#line 492
  sock2fd = (int volatile   )-1;
#line 494
  tmp___12 = InitSReadlineInfo(& cip->ctrlSrl, (int )sockfd, cip->srlBuf, sizeof(cip->srlBuf),
                               (int )cip->ctrlTimeout, 1);
  }
#line 494
  if (tmp___12 < 0) {
    {
#line 495
    result = -109;
#line 496
    cip->errNo = -109;
#line 497
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not fdopen.\n");
    }
#line 498
    goto fatal;
  }
  {
#line 543
  InetNtoA(cip->ip, & cip->servCtlAddr.sin_addr, sizeof(cip->ip));
  }
#line 544
  if (hpok == 0) {
    {
#line 545
    Strncpy((char */* const  */)(cip->actualHost), (char const   */* const  */)fhost,
            (size_t const   )sizeof(cip->actualHost));
    }
  } else
#line 544
  if ((unsigned long )hp.h_name == (unsigned long )((void *)0)) {
    {
#line 545
    Strncpy((char */* const  */)(cip->actualHost), (char const   */* const  */)fhost,
            (size_t const   )sizeof(cip->actualHost));
    }
  } else {
    {
#line 547
    Strncpy((char */* const  */)(cip->actualHost), (char const   */* const  */)hp.h_name,
            (size_t const   )sizeof(cip->actualHost));
    }
  }
  {
#line 550
  rp = InitResponse();
  }
#line 551
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 552
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 553
    cip->errNo = -123;
#line 554
    result = cip->errNo;
    }
#line 555
    goto fatal;
  }
  {
#line 558
  result = GetResponse(cip, rp);
  }
#line 559
  if (result < 0) {
#line 559
    if ((unsigned long )rp->msg.first == (unsigned long )((void *)0)) {
#line 560
      goto fatal;
    }
  }
#line 562
  if ((unsigned long )rp->msg.first != (unsigned long )((void *)0)) {
#line 563
    cip->serverType = 0;
#line 564
    srvr = (char const   *)((void *)0);
#line 565
    firstLine = (char const   *)(rp->msg.first)->line;
#line 566
    secondLine = (char const   *)((void *)0);
#line 567
    if ((unsigned long )(rp->msg.first)->next != (unsigned long )((void *)0)) {
#line 568
      secondLine = (char const   *)((rp->msg.first)->next)->line;
    }
    {
#line 570
    tmp___27 = strstr(firstLine, "Version wu-");
    }
#line 570
    if ((unsigned long )tmp___27 != (unsigned long )((void *)0)) {
#line 571
      cip->serverType = 1;
#line 572
      srvr = "wu-ftpd";
    } else {
      {
#line 573
      tmp___26 = strstr(firstLine, "NcFTPd");
      }
#line 573
      if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
#line 574
        cip->serverType = 2;
#line 575
        srvr = "NcFTPd Server";
      } else {
        {
#line 576
        tmp___25 = strncmp("ProFTPD", firstLine, (size_t )7);
        }
#line 576
        if (tmp___25 == 0) {
#line 577
          cip->serverType = 3;
#line 578
          srvr = "ProFTPD";
        } else {
          {
#line 579
          tmp___24 = strstr(firstLine, "Microsoft FTP Service");
          }
#line 579
          if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
#line 580
            cip->serverType = 4;
#line 581
            srvr = "Microsoft FTP Service";
          } else {
            {
#line 582
            tmp___23 = strstr(firstLine, "(NetWare ");
            }
#line 582
            if ((unsigned long )tmp___23 != (unsigned long )((void *)0)) {
#line 583
              cip->serverType = 11;
#line 584
              srvr = "NetWare FTP Service";
            } else {
              {
#line 585
              tmp___22 = strstr(firstLine, "(DG/UX ");
              }
#line 585
              if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
#line 586
                cip->serverType = 13;
#line 587
                srvr = "DG/UX FTP Service";
              } else {
                {
#line 588
                tmp___21 = strstr(firstLine, "IBM FTP CS ");
                }
#line 588
                if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
#line 589
                  cip->serverType = 14;
#line 590
                  srvr = "IBM FTP CS Server";
                } else {
                  {
#line 591
                  tmp___20 = strstr(firstLine, "DC/OSx");
                  }
#line 591
                  if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 592
                    cip->serverType = 15;
#line 593
                    srvr = "Pyramid DC/OSx FTP Service";
                  } else {
                    {
#line 594
                    tmp___19 = strncmp("WFTPD", firstLine, (size_t )5);
                    }
#line 594
                    if (tmp___19 == 0) {
#line 595
                      cip->serverType = 7;
#line 596
                      srvr = "WFTPD";
                    } else {
                      {
#line 597
                      tmp___18 = strncmp("Serv-U FTP", firstLine, (size_t )10);
                      }
#line 597
                      if (tmp___18 == 0) {
#line 598
                        cip->serverType = 6;
#line 599
                        srvr = "Serv-U FTP-Server";
                      } else {
                        {
#line 600
                        tmp___17 = strstr(firstLine, "VFTPD");
                        }
#line 600
                        if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 601
                          cip->serverType = 8;
#line 602
                          srvr = "VFTPD";
                        } else {
                          {
#line 603
                          tmp___16 = strncmp("FTP-Max", firstLine, (size_t )7);
                          }
#line 603
                          if (tmp___16 == 0) {
#line 604
                            cip->serverType = 9;
#line 605
                            srvr = "FTP-Max";
                          } else {
                            {
#line 606
                            tmp___15 = strstr(firstLine, "Roxen");
                            }
#line 606
                            if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 607
                              cip->serverType = 10;
#line 608
                              srvr = "Roxen";
                            } else {
                              {
#line 609
                              tmp___14 = strstr(firstLine, "WS_FTP");
                              }
#line 609
                              if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 610
                                cip->serverType = 12;
#line 611
                                srvr = "WS_FTP Server";
                              } else
#line 612
                              if ((unsigned long )secondLine != (unsigned long )((void *)0)) {
                                {
#line 612
                                tmp___13 = strstr(secondLine, "WarFTP");
                                }
#line 612
                                if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 613
                                  cip->serverType = 5;
#line 614
                                  srvr = "WarFTPd";
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 617
    if ((unsigned long )srvr != (unsigned long )((void *)0)) {
      {
#line 618
      PrintF(cip, (char const   */* const  */)"Remote server is running %s.\n", srvr);
      }
    }
#line 621
    if ((unsigned long )cip->onConnectMsgProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                            ResponsePtr  ))0)) {
#line 621
      if (rp->codeType < 4) {
        {
#line 622
        (*(cip->onConnectMsgProc))(cip, rp);
        }
      }
    }
  }
#line 625
  if (rp->codeType >= 4) {
    {
#line 630
    tmp___28 = -119;
#line 630
    cip->errNo = tmp___28;
#line 630
    result = tmp___28;
#line 631
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Server hungup immediately after connect.\n");
    }
#line 632
    goto fatal;
  }
#line 634
  if (result < 0) {
#line 635
    goto fatal;
  }
  {
#line 636
  cip->connected = 1;
#line 637
  DoneWithResponse(cip, rp);
  }
#line 638
  return (0);
  fatal: 
#line 641
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
    {
#line 642
    DoneWithResponse(cip, rp);
    }
  }
#line 643
  if (sockfd > (int volatile   )0) {
    {
#line 644
    close((int )sockfd);
    }
  }
#line 645
  if (sock2fd > (int volatile   )0) {
    {
#line 646
    close((int )sock2fd);
    }
  }
  {
#line 647
  CloseFile(& cip->cin);
#line 648
  CloseFile(& cip->cout);
#line 649
  cip->ctrlSocketR = -1;
#line 650
  cip->ctrlSocketW = -1;
  }
#line 651
  return (result);
}
}
#line 657 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
void CloseDataConnection(FTPCIPtr const   cip ) 
{ 


  {
#line 660
  if (cip->dataSocket != -1) {
    {
#line 675
    close(cip->dataSocket);
#line 684
    cip->dataSocket = -1;
    }
  }
  {
#line 686
  cip->dataSocketConnected = 0;
#line 687
  memset((void *)(& cip->ourDataAddr), 0, sizeof(cip->ourDataAddr));
#line 688
  memset((void *)(& cip->servDataAddr), 0, sizeof(cip->servDataAddr));
  }
#line 689
  return;
}
}
#line 695 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int FTPSetStartOffset(FTPCIPtr const   cip , long long restartPt ) 
{ 
  ResponsePtr rp ;
  int result ;

  {
#line 701
  if (restartPt != 0LL) {
    {
#line 702
    rp = InitResponse();
    }
#line 703
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 704
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 705
      cip->errNo = -123;
      }
#line 706
      return (cip->errNo);
    }
#line 710
    if (restartPt == -1LL) {
#line 711
      restartPt = 0LL;
    }
    {
#line 713
    result = RCmd(cip, rp, "REST %lld", restartPt);
    }
#line 720
    if (result < 0) {
      {
#line 721
      DoneWithResponse(cip, rp);
      }
#line 722
      return (result);
    } else
#line 723
    if (result <= 3) {
#line 725
      cip->hasREST = 1;
    } else
#line 726
    if (rp->code == 500) {
      {
#line 727
      cip->hasREST = 0;
#line 728
      DoneWithResponse(cip, rp);
#line 729
      cip->errNo = -117;
      }
#line 730
      return (-117);
    } else
#line 726
    if (rp->code == 502) {
      {
#line 727
      cip->hasREST = 0;
#line 728
      DoneWithResponse(cip, rp);
#line 729
      cip->errNo = -117;
      }
#line 730
      return (-117);
    } else
#line 726
    if (rp->code == 504) {
      {
#line 727
      cip->hasREST = 0;
#line 728
      DoneWithResponse(cip, rp);
#line 729
      cip->errNo = -117;
      }
#line 730
      return (-117);
    } else {
      {
#line 732
      DoneWithResponse(cip, rp);
#line 733
      cip->errNo = -117;
      }
#line 734
      return (-117);
    }
    {
#line 736
    DoneWithResponse(cip, rp);
    }
  }
#line 738
  return (0);
}
}
#line 743 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int FTPSendPort(FTPCIPtr const   cip , struct sockaddr_in *saddr ) 
{ 
  char *a ;
  char *p___5 ;
  int result ;
  ResponsePtr rp ;

  {
  {
#line 750
  rp = InitResponse();
  }
#line 751
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 752
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 753
    cip->errNo = -123;
    }
#line 754
    return (cip->errNo);
  }
  {
#line 758
  a = (char *)(& saddr->sin_addr);
#line 759
  p___5 = (char *)(& saddr->sin_port);
#line 765
  result = RCmd(cip, rp, "PORT %d,%d,%d,%d,%d,%d", (int )*(a + 0) & 255, (int )*(a + 1) & 255,
                (int )*(a + 2) & 255, (int )*(a + 3) & 255, (int )*(p___5 + 0) & 255,
                (int )*(p___5 + 1) & 255);
#line 768
  DoneWithResponse(cip, rp);
  }
#line 769
  if (result < 0) {
#line 770
    return (result);
  } else
#line 771
  if (result != 2) {
#line 773
    cip->errNo = -162;
#line 774
    return (cip->errNo);
  }
#line 776
  return (0);
}
}
#line 782 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int FTPSendPassive(FTPCIPtr const   cip , struct sockaddr_in *saddr , int *weird ) 
{ 
  ResponsePtr rp ;
  int i___0[6] ;
  int j ;
  unsigned char n[6] ;
  char *cp ;
  int result ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 791
  rp = InitResponse();
  }
#line 792
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 793
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
#line 794
    cip->errNo = -123;
    }
#line 795
    return (cip->errNo);
  }
  {
#line 798
  result = RCmd(cip, rp, "PASV");
  }
#line 799
  if (result < 0) {
#line 800
    goto done;
  }
#line 802
  if (rp->codeType != 2) {
#line 804
    result = -163;
#line 804
    cip->errNo = result;
#line 805
    goto done;
  }
#line 817
  cp = (rp->msg.first)->line;
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if ((int )*cp == 0) {
      {
#line 819
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Cannot parse PASV response: %s\n",
                  (rp->msg.first)->line);
      }
#line 820
      goto done;
    }
    {
#line 822
    tmp = __ctype_b_loc();
    }
#line 822
    if ((int const   )*(*tmp + (int )*cp) & 2048) {
#line 823
      goto while_break;
    }
#line 817
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  tmp___0 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d",
                   & i___0[0], & i___0[1], & i___0[2], & i___0[3], & i___0[4], & i___0[5]);
  }
#line 826
  if (tmp___0 != 6) {
    {
#line 828
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Cannot parse PASV response: %s\n",
                (rp->msg.first)->line);
    }
#line 829
    goto done;
  }
#line 832
  if ((unsigned long )weird != (unsigned long )((int *)0)) {
#line 833
    *weird = 0;
  }
#line 835
  j = 0;
  {
#line 835
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 835
    if (! (j < 6)) {
#line 835
      goto while_break___0;
    }
#line 840
    if (i___0[j] < 0) {
#line 840
      goto _L;
    } else
#line 840
    if (i___0[j] > 255) {
      _L: /* CIL Label */ 
#line 840
      if ((unsigned long )weird != (unsigned long )((int *)0)) {
#line 841
        (*weird) ++;
      }
    }
#line 842
    n[j] = (unsigned char )(i___0[j] & 255);
#line 835
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 845
  memcpy((void */* __restrict  */)(& saddr->sin_addr), (void const   */* __restrict  */)(& n[0]),
         (size_t )4);
#line 846
  memcpy((void */* __restrict  */)(& saddr->sin_port), (void const   */* __restrict  */)(& n[4]),
         (size_t )2);
#line 848
  result = 0;
  }
  done: 
  {
#line 850
  DoneWithResponse(cip, rp);
  }
#line 851
  return (result);
}
}
#line 857 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int FTPFixPrivateAddr(struct sockaddr_in *maybePrivateAddr , struct sockaddr_in *knownNonPrivateAddrToUseIfNeeded ) 
{ 
  int i___0 ;
  char maybePrivateAddrStr[64] ;
  char knownNonPrivateAddrToUseIfNeededStr[64] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 864
  AddrToAddrStr((char */* const  */)(maybePrivateAddrStr), sizeof(maybePrivateAddrStr),
                (struct sockaddr_in */* const  */)maybePrivateAddr, 0, "%h");
#line 865
  AddrToAddrStr((char */* const  */)(knownNonPrivateAddrToUseIfNeededStr), sizeof(knownNonPrivateAddrToUseIfNeededStr),
                (struct sockaddr_in */* const  */)knownNonPrivateAddrToUseIfNeeded,
                0, "%h");
#line 867
  tmp = strcmp((char const   *)(maybePrivateAddrStr), (char const   *)(knownNonPrivateAddrToUseIfNeededStr));
  }
#line 867
  if (tmp == 0) {
#line 868
    return (0);
  }
#line 870
  i___0 = 0;
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! ((unsigned long )gPrivateNetworks[i___0] != (unsigned long )((void *)0))) {
#line 870
      goto while_break;
    }
    {
#line 871
    tmp___0 = strlen(gPrivateNetworks[i___0]);
#line 871
    tmp___1 = strncmp((char const   *)(maybePrivateAddrStr), gPrivateNetworks[i___0],
                      tmp___0);
    }
#line 871
    if (tmp___1 == 0) {
#line 872
      goto while_break;
    }
#line 870
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if ((unsigned long )gPrivateNetworks[i___0] == (unsigned long )((void *)0)) {
#line 876
    return (0);
  }
  {
#line 878
  tmp___2 = strlen(gPrivateNetworks[i___0]);
#line 878
  tmp___3 = strncmp((char const   *)(knownNonPrivateAddrToUseIfNeededStr), gPrivateNetworks[i___0],
                    tmp___2);
  }
#line 878
  if (tmp___3 == 0) {
#line 879
    return (0);
  }
  {
#line 881
  memcpy((void */* __restrict  */)(& maybePrivateAddr->sin_addr), (void const   */* __restrict  */)(& knownNonPrivateAddrToUseIfNeeded->sin_addr),
         sizeof(maybePrivateAddr->sin_addr));
  }
#line 882
  return (1);
}
}
#line 888 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
void FTPFixServerDataAddr(FTPCIPtr const   cip ) 
{ 
  struct sockaddr_in oldServDataAddr ;
  char servDataAddrStr[64] ;
  char newDataAddrStr[64] ;
  int tmp ;

  {
  {
#line 895
  memcpy((void */* __restrict  */)(& oldServDataAddr), (void const   */* __restrict  */)(& cip->servDataAddr),
         sizeof(oldServDataAddr));
#line 896
  tmp = FTPFixPrivateAddr(& cip->servDataAddr, & cip->servCtlAddr);
  }
#line 896
  if (tmp) {
    {
#line 897
    AddrToAddrStr((char */* const  */)(servDataAddrStr), sizeof(servDataAddrStr),
                  (struct sockaddr_in */* const  */)(& oldServDataAddr), 0, (char const   *)((void *)0));
#line 898
    AddrToAddrStr((char */* const  */)(newDataAddrStr), sizeof(newDataAddrStr), (struct sockaddr_in */* const  */)(& cip->servDataAddr),
                  0, (char const   *)((void *)0));
#line 899
    PrintF(cip, (char const   */* const  */)"Fixing bogus PASV data address from %s to %s.\n",
           servDataAddrStr, newDataAddrStr);
    }
  }
#line 901
  return;
}
}
#line 906 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
void FTPFixClientDataAddr(FTPCIPtr const   cip ) 
{ 
  struct sockaddr_in oldClientDataAddr ;
  struct sockaddr_in newClientDataAddr ;
  char ourDataAddrStr[64] ;
  char newDataAddrStr[64] ;
  int tmp ;

  {
#line 913
  if ((int )cip->clientKnownExternalAddr.sin_family == 0) {
#line 914
    return;
  }
  {
#line 916
  memcpy((void */* __restrict  */)(& oldClientDataAddr), (void const   */* __restrict  */)(& cip->ourDataAddr),
         sizeof(oldClientDataAddr));
#line 917
  tmp = FTPFixPrivateAddr(& cip->ourDataAddr, & cip->clientKnownExternalAddr);
  }
#line 917
  if (tmp) {
    {
#line 918
    memcpy((void */* __restrict  */)(& newClientDataAddr), (void const   */* __restrict  */)(& cip->clientKnownExternalAddr),
           sizeof(newClientDataAddr));
#line 919
    newClientDataAddr.sin_port = cip->ourDataAddr.sin_port;
#line 920
    AddrToAddrStr((char */* const  */)(ourDataAddrStr), sizeof(ourDataAddrStr), (struct sockaddr_in */* const  */)(& oldClientDataAddr),
                  0, (char const   *)((void *)0));
#line 921
    AddrToAddrStr((char */* const  */)(newDataAddrStr), sizeof(newDataAddrStr), (struct sockaddr_in */* const  */)(& newClientDataAddr),
                  0, (char const   *)((void *)0));
#line 922
    PrintF(cip, (char const   */* const  */)"Fixing what would have been a bogus PORT data address from %s to %s.\n",
           ourDataAddrStr, newDataAddrStr);
    }
  }
#line 924
  return;
}
}
#line 929 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int BindToEphemeralPortNumber(int const   sockfd , struct sockaddr_in * const  addrp ,
                              int const   ephemLo , int const   ephemHi ) 
{ 
  int i___0 ;
  int result ;
  int rangesize ;
  unsigned short port ;
  int tmp ;
  int *tmp___0 ;

  {
#line 937
  addrp->sin_family = (sa_family_t )2;
#line 938
  if ((int )ephemLo == 0) {
    {
#line 943
    addrp->sin_port = (in_port_t )0;
#line 945
    result = bind((int )sockfd, (struct sockaddr  const  *)((struct sockaddr *)addrp),
                  (socklen_t )sizeof(struct sockaddr_in ));
    }
  } else
#line 938
  if ((int )ephemLo >= (int )ephemHi) {
    {
#line 943
    addrp->sin_port = (in_port_t )0;
#line 945
    result = bind((int )sockfd, (struct sockaddr  const  *)((struct sockaddr *)addrp),
                  (socklen_t )sizeof(struct sockaddr_in ));
    }
  } else {
#line 947
    rangesize = (int )ephemHi - (int )ephemLo;
#line 948
    result = 0;
#line 949
    i___0 = 0;
    {
#line 949
    while (1) {
      while_continue: /* CIL Label */ ;
#line 949
      if (! (i___0 < 10)) {
#line 949
        goto while_break;
      }
      {
#line 950
      tmp = rand();
#line 950
      port = (unsigned short )(tmp % rangesize + (int )ephemLo);
#line 951
      addrp->sin_port = htons(port);
#line 953
      result = bind((int )sockfd, (struct sockaddr  const  *)((struct sockaddr *)addrp),
                    (socklen_t )sizeof(struct sockaddr_in ));
      }
#line 954
      if (result == 0) {
#line 955
        goto while_break;
      }
      {
#line 956
      sleep(1U);
#line 957
      tmp___0 = __errno_location();
      }
#line 957
      if (*tmp___0 == 999) {
#line 957
        if ((int const   )gCopyright___0[0] != 0) {
#line 963
          goto while_break;
        }
      }
#line 949
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 966
  return (result);
}
}
#line 972 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int OpenDataConnection(FTPCIPtr const   cip , int mode ) 
{ 
  int dataSocket ;
  int weirdPort ;
  int result ;
  int setsbufs ;
  size_t rbs ;
  size_t sbs ;
  int passiveAttemptsRemaining ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 980
  passiveAttemptsRemaining = cip->maxNumberOfSuccessivePASVAttempts;
  tryPort2: 
  {
#line 988
  weirdPort = 0;
#line 989
  result = 0;
#line 990
  CloseDataConnection(cip);
#line 992
  dataSocket = socket(2, 1, 0);
  }
#line 993
  if (dataSocket < 0) {
    {
#line 994
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not get a data socket.\n");
#line 995
    result = -106;
#line 996
    cip->errNo = -106;
    }
#line 997
    return (result);
  }
#line 1000
  if (cip->dataSocketRBufSize != 0UL) {
    {
#line 1001
    SetSocketBufSize((int const   )dataSocket, (size_t const   )cip->dataSocketRBufSize,
                     (size_t const   )cip->dataSocketSBufSize);
    }
  } else
#line 1000
  if (cip->dataSocketSBufSize != 0UL) {
    {
#line 1001
    SetSocketBufSize((int const   )dataSocket, (size_t const   )cip->dataSocketRBufSize,
                     (size_t const   )cip->dataSocketSBufSize);
    }
  } else {
    {
#line 1002
    tmp = GetSocketBufSize((int const   )dataSocket, (size_t */* const  */)(& rbs),
                           (size_t */* const  */)(& sbs));
    }
#line 1002
    if (tmp == 0) {
#line 1006
      setsbufs = 0;
#line 1007
      if (rbs < 65536UL) {
#line 1008
        rbs = (size_t )65536;
#line 1009
        setsbufs ++;
      }
#line 1011
      if (sbs < 65536UL) {
#line 1012
        sbs = (size_t )65536;
#line 1013
        setsbufs ++;
      }
#line 1015
      if (setsbufs > 0) {
        {
#line 1016
        SetSocketBufSize((int const   )dataSocket, (size_t const   )rbs, (size_t const   )sbs);
        }
      }
    }
  }
#line 1020
  if (cip->hasPASV == 0) {
#line 1020
    goto tryPort;
  } else
#line 1020
  if (mode == 0) {
    tryPort: 
    {
#line 1025
    cip->ourDataAddr = cip->ourCtlAddr;
#line 1026
    cip->ourDataAddr.sin_family = (sa_family_t )2;
#line 1034
    tmp___0 = BindToEphemeralPortNumber((int const   )dataSocket, (struct sockaddr_in */* const  */)(& cip->ourDataAddr),
                                        (int const   )((int )cip->ephemLo), (int const   )((int )cip->ephemHi));
    }
#line 1034
    if (tmp___0 < 0) {
      {
#line 1037
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not bind the data socket");
#line 1038
      result = -111;
#line 1039
      cip->errNo = -111;
      }
#line 1040
      goto bad;
    }
    {
#line 1046
    result = GetSocketAddress(cip, dataSocket, & cip->ourDataAddr);
    }
#line 1046
    if (result < 0) {
#line 1047
      goto bad;
    }
    {
#line 1049
    tmp___1 = listen(dataSocket, 1);
    }
#line 1049
    if (tmp___1 < 0) {
      {
#line 1050
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"listen failed");
#line 1051
      result = -112;
#line 1052
      cip->errNo = -112;
      }
#line 1053
      goto bad;
    }
    {
#line 1056
    FTPFixClientDataAddr(cip);
#line 1057
    result = FTPSendPort(cip, & cip->ourDataAddr);
    }
#line 1057
    if (result < 0) {
#line 1058
      goto bad;
    }
#line 1060
    cip->dataPortMode = 0;
  } else {
    {
#line 1064
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1064
      passiveAttemptsRemaining --;
#line 1064
      if (! (passiveAttemptsRemaining >= 0)) {
#line 1064
        goto while_break;
      }
      {
#line 1065
      cip->servDataAddr = cip->servCtlAddr;
#line 1066
      cip->servDataAddr.sin_family = (sa_family_t )2;
#line 1067
      cip->ourDataAddr = cip->ourCtlAddr;
#line 1068
      cip->ourDataAddr.sin_family = (sa_family_t )2;
#line 1070
      tmp___2 = FTPSendPassive(cip, & cip->servDataAddr, & weirdPort);
      }
#line 1070
      if (tmp___2 < 0) {
        {
#line 1071
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Passive mode refused.\n");
#line 1072
        cip->hasPASV = 0;
        }
#line 1081
        if (mode == 2) {
#line 1082
          goto tryPort;
        }
#line 1083
        result = -113;
#line 1084
        cip->errNo = -113;
#line 1085
        goto bad;
      }
      {
#line 1087
      FTPFixServerDataAddr(cip);
#line 1095
      tmp___3 = BindToEphemeralPortNumber((int const   )dataSocket, (struct sockaddr_in */* const  */)(& cip->ourDataAddr),
                                          (int const   )((int )cip->ephemLo), (int const   )((int )cip->ephemHi));
      }
#line 1095
      if (tmp___3 < 0) {
        {
#line 1098
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not bind the data socket");
#line 1099
        result = -111;
#line 1100
        cip->errNo = -111;
        }
#line 1101
        goto bad;
      }
      {
#line 1104
      result = SConnect(dataSocket, (struct sockaddr_in  const  */* const  */)(& cip->servDataAddr),
                        (int )cip->connTimeout);
      }
#line 1106
      if (result == -2) {
#line 1107
        if (mode == 2) {
          {
#line 1108
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"Data connection timed out.\n");
          }
#line 1109
          if (passiveAttemptsRemaining == 0) {
            {
#line 1110
            FTPLogError(cip, (int const   )0, (char const   */* const  */)"Falling back to PORT instead of PASV mode.\n");
#line 1111
            close(dataSocket);
#line 1112
            dataSocket = -1;
            }
#line 1113
            if (cip->hasPASV == -1) {
#line 1114
              cip->hasPASV = 0;
            }
#line 1115
            goto tryPort2;
          }
        } else {
          {
#line 1118
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"Data connection timed out.\n");
          }
        }
#line 1120
        result = -115;
#line 1121
        cip->errNo = -115;
#line 1122
        if (passiveAttemptsRemaining == 0) {
#line 1123
          goto bad;
        }
      } else
#line 1124
      if (result < 0) {
#line 1126
        if (weirdPort > 0) {
          {
#line 1126
          tmp___4 = __errno_location();
          }
#line 1126
          if (*tmp___4 == 111) {
#line 1131
            if (mode == 2) {
#line 1132
              if (passiveAttemptsRemaining == 0) {
#line 1133
                if (cip->hasPASV == -1) {
#line 1134
                  cip->hasPASV = 0;
                }
                {
#line 1135
                FTPLogError(cip, (int const   )0, (char const   */* const  */)"Server sent back a bogus port number.\nI will fall back to PORT instead of PASV mode.\n");
#line 1136
                close(dataSocket);
#line 1137
                dataSocket = -1;
                }
#line 1138
                goto tryPort2;
              }
            }
            {
#line 1141
            FTPLogError(cip, (int const   )0, (char const   */* const  */)"Server sent back a bogus port number.\n");
#line 1142
            result = -114;
#line 1143
            cip->errNo = -114;
            }
#line 1144
            if (passiveAttemptsRemaining == 0) {
#line 1145
              goto bad;
            }
          }
        }
#line 1147
        if (mode == 2) {
#line 1147
          if (passiveAttemptsRemaining == 0) {
            {
#line 1148
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"connect failed.\n");
#line 1149
            FTPLogError(cip, (int const   )0, (char const   */* const  */)"Falling back to PORT instead of PASV mode.\n");
#line 1150
            close(dataSocket);
#line 1151
            dataSocket = -1;
            }
#line 1152
            if (cip->hasPASV == -1) {
#line 1153
              cip->hasPASV = 0;
            }
#line 1154
            goto tryPort2;
          }
        }
        {
#line 1156
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"connect failed.\n");
#line 1157
        result = -115;
#line 1158
        cip->errNo = -115;
        }
      } else {
#line 1161
        goto while_break;
      }
#line 1164
      if (dataSocket != -1) {
        {
#line 1165
        close(dataSocket);
        }
      }
      {
#line 1167
      dataSocket = socket(2, 1, 0);
      }
#line 1168
      if (dataSocket < 0) {
        {
#line 1169
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not get a data socket.\n");
#line 1170
        result = -106;
#line 1171
        cip->errNo = -106;
        }
#line 1172
        return (result);
      }
#line 1174
      if (passiveAttemptsRemaining == 1) {
#line 1174
        tmp___5 = "try";
      } else {
#line 1174
        tmp___5 = "tries";
      }
      {
#line 1174
      PrintF(cip, (char const   */* const  */)"Retrying PASV mode (%d %s left).\n",
             passiveAttemptsRemaining, tmp___5);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1177
    if (result != 0) {
#line 1178
      goto bad;
    }
    {
#line 1183
    result = GetSocketAddress(cip, dataSocket, & cip->ourDataAddr);
    }
#line 1183
    if (result < 0) {
#line 1184
      goto bad;
    }
#line 1186
    cip->hasPASV = 1;
  }
  {
#line 1189
  SetSocketKeepAlive((int const   )dataSocket, (int const   )1);
#line 1195
  SetSocketTypeOfService((int const   )dataSocket, (int const   )8);
#line 1197
  cip->dataSocket = dataSocket;
  }
#line 1198
  return (0);
  bad: 
  {
#line 1200
  close(dataSocket);
  }
#line 1201
  return (result);
}
}
#line 1207 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
int AcceptDataConnection(FTPCIPtr const   cip ) 
{ 
  int newSocket ;
  unsigned short remoteDataPort ;
  unsigned short remoteCtrlPort ;
  char ctrlAddrStr[64] ;
  char dataAddrStr[64] ;
  int tmp ;

  {
#line 1221
  if (cip->dataPortMode == 0) {
    {
#line 1225
    memset((void *)(& cip->servDataAddr), 0, sizeof(cip->servDataAddr));
#line 1228
    newSocket = SAccept(cip->dataSocket, (struct sockaddr_in */* const  */)(& cip->servDataAddr),
                        (int )cip->connTimeout);
#line 1238
    close(cip->dataSocket);
    }
#line 1239
    if (newSocket < 0) {
      {
#line 1240
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not accept a data connection.\n");
#line 1241
      cip->dataSocket = -1;
#line 1242
      cip->errNo = -116;
      }
#line 1243
      return (-116);
    }
#line 1246
    if (cip->allowProxyForPORT == 0) {
      {
#line 1247
      tmp = memcmp((void const   *)(& cip->servDataAddr.sin_addr.s_addr), (void const   *)(& cip->servCtlAddr.sin_addr.s_addr),
                   sizeof(cip->servDataAddr.sin_addr.s_addr));
      }
#line 1247
      if (tmp != 0) {
        {
#line 1248
        AddrToAddrStr((char */* const  */)(ctrlAddrStr), sizeof(ctrlAddrStr), (struct sockaddr_in */* const  */)(& cip->servCtlAddr),
                      0, (char const   *)((void *)0));
#line 1249
        AddrToAddrStr((char */* const  */)(dataAddrStr), sizeof(dataAddrStr), (struct sockaddr_in */* const  */)(& cip->servDataAddr),
                      0, (char const   *)((void *)0));
#line 1250
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Data connection from %s did not originate from remote server %s!\n",
                    dataAddrStr, ctrlAddrStr);
#line 1251
        close(newSocket);
#line 1252
        cip->dataSocket = -1;
#line 1253
        cip->errNo = -198;
        }
#line 1254
        return (-198);
      }
    }
#line 1258
    if (cip->require20 != 0) {
      {
#line 1259
      remoteDataPort = ntohs(cip->servDataAddr.sin_port);
#line 1260
      remoteCtrlPort = ntohs(cip->servCtlAddr.sin_port);
      }
#line 1261
      if ((int )remoteDataPort != (int )remoteCtrlPort - 1) {
        {
#line 1262
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Data connection did not originate on correct port (expecting %d, got %d)!\n",
                    (int )remoteCtrlPort - 1, (int )remoteDataPort);
#line 1263
        close(newSocket);
#line 1264
        cip->dataSocket = -1;
#line 1265
        cip->errNo = -199;
        }
#line 1266
        return (-199);
      }
    }
#line 1269
    cip->dataSocket = newSocket;
  }
#line 1272
  return (0);
}
}
#line 1278 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
void HangupOnServer(FTPCIPtr const   cip ) 
{ 


  {
  {
#line 1285
  FTPCloseControlConnection(cip);
#line 1286
  CloseDataConnection(cip);
  }
#line 1287
  return;
}
}
#line 1292 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
void SendTelnetInterrupt(FTPCIPtr const   cip ) 
{ 
  unsigned char msg[4] ;
  ssize_t tmp ;

  {
#line 1301
  if ((unsigned long )cip->cout != (unsigned long )((void *)0)) {
    {
#line 1302
    fflush(cip->cout);
    }
  }
  {
#line 1304
  msg[0] = (unsigned char)255;
#line 1305
  msg[1] = (unsigned char)244;
#line 1309
  send(cip->ctrlSocketW, (void const   *)((char const   *)(msg)), (size_t )2, 0);
#line 1312
  msg[0] = (unsigned char)255;
#line 1313
  msg[1] = (unsigned char)242;
#line 1317
  tmp = send(cip->ctrlSocketW, (void const   *)((char const   *)(msg)), (size_t )2,
             1);
  }
#line 1317
  if (tmp != 2L) {
    {
#line 1319
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not send an urgent message.\n");
    }
  }
#line 1320
  return;
}
}
#line 857 "/usr/include/unistd.h"
extern int ( __attribute__((__nonnull__(1))) getlogin_r)(char *__name , size_t __name_len ) ;
#line 144 "/usr/include/pwd.h"
extern int getpwuid_r(__uid_t __uid , struct passwd * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 149
extern int getpwnam_r(char const   * __restrict  __name , struct passwd * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 83 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
int GetPwUid(struct passwd *pwp , uid_t const   uid , char * const  pwbuf , size_t pwbufsize ) ;
#line 84
int GetPwNam(struct passwd *pwp , char const   * const  nam , char * const  pwbuf ,
             size_t pwbufsize ) ;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getpw.c"
int GetPwUid(struct passwd *pwp , uid_t const   uid , char * const  pwbuf , size_t pwbufsize ) 
{ 
  struct passwd *p___5 ;
  int tmp ;

  {
  {
#line 59
  memset((void *)pwbuf, 0, pwbufsize);
#line 60
  p___5 = (struct passwd *)((void *)0);
#line 61
  tmp = getpwuid_r((__uid_t )uid, (struct passwd */* __restrict  */)pwp, (char */* __restrict  */)pwbuf,
                   pwbufsize, (struct passwd **/* __restrict  */)(& p___5));
  }
#line 61
  if (tmp == 0) {
#line 61
    if ((unsigned long )p___5 != (unsigned long )((void *)0)) {
#line 62
      return (0);
    }
  }
#line 75
  return (-1);
}
}
#line 81 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getpw.c"
int GetPwNam(struct passwd *pwp , char const   * const  nam , char * const  pwbuf ,
             size_t pwbufsize ) 
{ 
  struct passwd *p___5 ;
  int tmp ;

  {
  {
#line 103
  memset((void *)pwbuf, 0, pwbufsize);
#line 104
  p___5 = (struct passwd *)((void *)0);
#line 105
  tmp = getpwnam_r((char const   */* __restrict  */)nam, (struct passwd */* __restrict  */)pwp,
                   (char */* __restrict  */)pwbuf, pwbufsize, (struct passwd **/* __restrict  */)(& p___5));
  }
#line 105
  if (tmp == 0) {
#line 105
    if ((unsigned long )p___5 != (unsigned long )((void *)0)) {
#line 106
      return (0);
    }
  }
#line 119
  return (-1);
}
}
#line 128 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getpw.c"
int GetMyPwEnt(struct passwd *pwp , char * const  pwbuf , size_t pwbufsize ) 
{ 
  char *cp ;
  int rc ;
  char logname[128] ;
  __uid_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 136
  tmp = getuid();
#line 136
  rc = GetPwUid(pwp, (uid_t const   )tmp, pwbuf, pwbufsize);
  }
#line 137
  if (rc == 0) {
#line 138
    return (rc);
  }
  {
#line 140
  tmp___0 = getenv("LOGNAME");
#line 140
  cp = tmp___0;
  }
#line 141
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 142
    tmp___1 = getenv("USER");
#line 142
    cp = tmp___1;
    }
  }
#line 144
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 149
    memset((void *)(logname), 0, sizeof(logname));
#line 150
    getlogin_r(logname, sizeof(logname) - 1UL);
    }
#line 151
    if ((int )logname[0] == 0) {
#line 151
      cp = (char *)((void *)0);
    } else {
#line 151
      cp = logname;
    }
  }
#line 157
  rc = -1;
#line 158
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 158
    if ((int )*(cp + 0) != 0) {
      {
#line 159
      rc = GetPwNam(pwp, (char const   */* const  */)cp, pwbuf, pwbufsize);
      }
    }
  }
#line 160
  return (rc);
}
}
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/usio.h"
int UBind(int sockfd , char const   * const  astr , int const   nTries , int const   reuseFlag ) ;
#line 23
int UListen(int sfd , int backlog ) ;
#line 33
int UNewStreamClient(void) ;
#line 34
int UNewDatagramClient(void) ;
#line 35
int UNewStreamServer(char const   * const  astr , int const   nTries , int const   reuseFlag ,
                     int listenQueueSize ) ;
#line 36
int UNewDatagramServer(char const   * const  astr , int const   nTries , int const   reuseFlag ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UNew.c"
int MakeSockAddrUn(struct sockaddr_un *uaddr , char const   * const  sockfile ) 
{ 
  int ualen ;
  int *tmp ;
  size_t tmp___0 ;

  {
#line 13
  if ((unsigned long )uaddr == (unsigned long )((void *)0)) {
    {
#line 14
    tmp = __errno_location();
#line 14
    *tmp = 22;
    }
#line 15
    return (-1);
  } else
#line 13
  if ((unsigned long )sockfile == (unsigned long )((void *)0)) {
    {
#line 14
    tmp = __errno_location();
#line 14
    *tmp = 22;
    }
#line 15
    return (-1);
  }
  {
#line 18
  memset((void *)uaddr, 0, sizeof(struct sockaddr_un ));
#line 19
  uaddr->sun_family = (sa_family_t )1;
#line 20
  strncpy((char */* __restrict  */)(uaddr->sun_path), (char const   */* __restrict  */)sockfile,
          sizeof(uaddr->sun_path) - 1UL);
#line 26
  tmp___0 = strlen((char const   *)(uaddr->sun_path));
#line 26
  ualen = ((int )sizeof(uaddr->sun_family) + (int )tmp___0) + 1;
  }
#line 28
  return (ualen);
}
}
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UNew.c"
int UNewStreamClient(void) 
{ 
  int sfd ;

  {
  {
#line 39
  sfd = socket(1, 1, 0);
  }
#line 40
  if (sfd < 0) {
#line 41
    return (-9);
  }
#line 43
  return (sfd);
}
}
#line 49 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UNew.c"
int UNewDatagramClient(void) 
{ 
  int sfd ;

  {
  {
#line 54
  sfd = socket(1, 2, 0);
  }
#line 55
  if (sfd < 0) {
#line 56
    return (-9);
  }
#line 58
  return (sfd);
}
}
#line 64 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UNew.c"
int UNewStreamServer(char const   * const  astr , int const   nTries , int const   reuseFlag ,
                     int listenQueueSize ) 
{ 
  int oerrno ;
  int sfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 70
  if ((unsigned long )astr == (unsigned long )((void *)0)) {
    {
#line 71
    tmp = __errno_location();
#line 71
    *tmp = 22;
    }
#line 72
    return (-1);
  } else
#line 70
  if ((int const   )*(astr + 0) == 0) {
    {
#line 71
    tmp = __errno_location();
#line 71
    *tmp = 22;
    }
#line 72
    return (-1);
  }
  {
#line 75
  sfd = socket(1, 1, 0);
  }
#line 76
  if (sfd < 0) {
#line 77
    return (-9);
  }
  {
#line 79
  tmp___2 = UBind(sfd, astr, nTries, reuseFlag);
  }
#line 79
  if (tmp___2 < 0) {
    {
#line 80
    tmp___0 = __errno_location();
#line 80
    oerrno = *tmp___0;
#line 81
    close(sfd);
#line 82
    tmp___1 = __errno_location();
#line 82
    *tmp___1 = oerrno;
    }
#line 83
    return (-10);
  }
  {
#line 86
  tmp___5 = UListen(sfd, listenQueueSize);
  }
#line 86
  if (tmp___5 < 0) {
    {
#line 87
    tmp___3 = __errno_location();
#line 87
    oerrno = *tmp___3;
#line 88
    close(sfd);
#line 89
    tmp___4 = __errno_location();
#line 89
    *tmp___4 = oerrno;
    }
#line 90
    return (-11);
  }
#line 93
  return (sfd);
}
}
#line 99 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UNew.c"
int UNewDatagramServer(char const   * const  astr , int const   nTries , int const   reuseFlag ) 
{ 
  int oerrno ;
  int sfd ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 105
  if ((unsigned long )astr == (unsigned long )((void *)0)) {
    {
#line 106
    tmp = __errno_location();
#line 106
    *tmp = 22;
    }
#line 107
    return (-1);
  } else
#line 105
  if ((int const   )*(astr + 0) == 0) {
    {
#line 106
    tmp = __errno_location();
#line 106
    *tmp = 22;
    }
#line 107
    return (-1);
  }
  {
#line 110
  sfd = socket(1, 2, 0);
  }
#line 111
  if (sfd < 0) {
#line 112
    return (-9);
  }
  {
#line 114
  tmp___2 = UBind(sfd, astr, nTries, reuseFlag);
  }
#line 114
  if (tmp___2 < 0) {
    {
#line 115
    tmp___0 = __errno_location();
#line 115
    oerrno = *tmp___0;
#line 116
    close(sfd);
#line 117
    tmp___1 = __errno_location();
#line 117
    *tmp___1 = oerrno;
    }
#line 118
    return (-10);
  }
#line 121
  return (sfd);
}
}
#line 28 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Strnpcat(char * const  dst , char const   * const  src , size_t n ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strnpcat.c"
char *Strnpcat(char * const  dst , char const   * const  src , size_t n ) 
{ 
  register size_t i___0 ;
  register char *d ;
  register char const   *s ;
  register char c ;
  char *ret ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 25
  if (n != 0UL) {
    {
#line 25
    i___0 = strlen((char const   *)dst);
    }
#line 25
    if (i___0 < n - 1UL) {
#line 26
      d = (char *)(dst + i___0);
#line 27
      s = (char const   *)src;
#line 34
      i___0 ++;
      {
#line 34
      while (1) {
        while_continue: /* CIL Label */ ;
#line 34
        if (! (i___0 < n)) {
#line 34
          goto while_break;
        }
#line 35
        tmp = s;
#line 35
        s ++;
#line 35
        c = (char )*tmp;
#line 36
        if ((int )c == 0) {
#line 37
          ret = d;
#line 38
          tmp___0 = d;
#line 38
          d ++;
#line 38
          *tmp___0 = c;
#line 44
          return (ret);
        }
#line 46
        tmp___1 = d;
#line 46
        d ++;
#line 46
        *tmp___1 = c;
#line 34
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 51
      *d = (char)0;
#line 52
      return (d);
    }
  }
#line 54
  return ((char *)dst);
}
}
#line 42 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Dynscat(char **dst  , ...) ;
#line 927 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int CopyLineList(FTPLineListPtr dst , FTPLineListPtr src ) ;
#line 930
FTPLinePtr RemoveLine(FTPLineListPtr list , FTPLinePtr killMe ) ;
#line 1071
void InitFileInfoList(FTPFileInfoListPtr list ) ;
#line 1072
void InitFileInfo(FTPFileInfoPtr fip ) ;
#line 1073
FTPFileInfoPtr RemoveFileInfo(FTPFileInfoListPtr list , FTPFileInfoPtr killMe ) ;
#line 1074
FTPFileInfoPtr AddFileInfo(FTPFileInfoListPtr list , FTPFileInfoPtr src ) ;
#line 1075
void SortFileInfoList(FTPFileInfoListPtr list , int sortKey , int sortOrder ) ;
#line 1076
void VectorizeFileInfoList(FTPFileInfoListPtr list ) ;
#line 1077
void UnvectorizeFileInfoList(FTPFileInfoListPtr list ) ;
#line 1084
int ConcatFileInfoList(FTPFileInfoListPtr dst , FTPFileInfoListPtr src ) ;
#line 1085
int ConcatFileToFileInfoList(FTPFileInfoListPtr dst , char *rfile ) ;
#line 1086
int LineListToFileInfoList(FTPLineListPtr src , FTPFileInfoListPtr dst ) ;
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
char *StrDup(char const   *buf ) 
{ 
  char *cp ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 20
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 21
    return ((char *)((void *)0));
  }
  {
#line 23
  tmp = strlen(buf);
#line 23
  len = tmp + 1UL;
#line 24
  tmp___0 = malloc(len);
#line 24
  cp = (char *)tmp___0;
  }
#line 25
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 26
    memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)buf, len);
    }
  }
#line 27
  return (cp);
}
}
#line 35 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void DisposeLineListContents(FTPLineListPtr list ) 
{ 
  FTPLinePtr lp ;
  FTPLinePtr lp2 ;

  {
#line 40
  lp = list->first;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 40
      goto while_break;
    }
#line 41
    lp2 = lp;
#line 42
    lp = lp->next;
#line 43
    if ((unsigned long )lp2->line != (unsigned long )((void *)0)) {
      {
#line 44
      *(lp2->line + 0) = (char )'\000';
#line 45
      free((void *)lp2->line);
      }
    }
    {
#line 47
    free((void *)lp2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  InitLineList(list);
  }
#line 50
  return;
}
}
#line 55 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void InitLineList(FTPLineListPtr list ) 
{ 
  FTPLinePtr tmp ;

  {
#line 58
  list->nLines = 0;
#line 59
  tmp = (FTPLinePtr )((void *)0);
#line 59
  list->last = tmp;
#line 59
  list->first = tmp;
#line 60
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
FTPLinePtr RemoveLine(FTPLineListPtr list , FTPLinePtr killMe ) 
{ 
  FTPLinePtr nextLine ;
  FTPLinePtr prevLine ;

  {
#line 70
  nextLine = killMe->next;
#line 71
  prevLine = killMe->prev;
#line 72
  if ((unsigned long )killMe->line != (unsigned long )((void *)0)) {
    {
#line 73
    *(killMe->line + 0) = (char )'\000';
#line 74
    free((void *)killMe->line);
    }
  }
#line 77
  if ((unsigned long )list->first == (unsigned long )killMe) {
#line 78
    list->first = nextLine;
  }
#line 79
  if ((unsigned long )list->last == (unsigned long )killMe) {
#line 80
    list->last = prevLine;
  }
#line 82
  if ((unsigned long )nextLine != (unsigned long )((void *)0)) {
#line 83
    nextLine->prev = prevLine;
  }
#line 84
  if ((unsigned long )prevLine != (unsigned long )((void *)0)) {
#line 85
    prevLine->next = nextLine;
  }
  {
#line 87
  free((void *)killMe);
#line 88
  (list->nLines) --;
  }
#line 89
  return (nextLine);
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
FTPLinePtr AddLine(FTPLineListPtr list , char const   *buf1 ) 
{ 
  FTPLinePtr lp ;
  char *buf ;
  void *tmp ;
  FTPLinePtr tmp___0 ;

  {
  {
#line 102
  tmp = malloc(sizeof(FTPLine ));
#line 102
  lp = (FTPLinePtr )tmp;
  }
#line 103
  if ((unsigned long )lp != (unsigned long )((void *)0)) {
    {
#line 104
    buf = StrDup(buf1);
    }
#line 105
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 106
      free((void *)lp);
#line 107
      lp = (FTPLinePtr )((void *)0);
      }
    } else {
#line 109
      lp->line = buf;
#line 110
      lp->next = (FTPLinePtr )((void *)0);
#line 111
      if ((unsigned long )list->first == (unsigned long )((void *)0)) {
#line 112
        tmp___0 = lp;
#line 112
        list->last = tmp___0;
#line 112
        list->first = tmp___0;
#line 113
        lp->prev = (FTPLinePtr )((void *)0);
#line 114
        list->nLines = 1;
      } else {
#line 116
        lp->prev = list->last;
#line 117
        (list->last)->next = lp;
#line 118
        list->last = lp;
#line 119
        (list->nLines) ++;
      }
    }
  }
#line 123
  return (lp);
}
}
#line 129 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int CopyLineList(FTPLineListPtr dst , FTPLineListPtr src ) 
{ 
  FTPLinePtr lp ;
  FTPLinePtr lp2 ;
  FTPLinePtr tmp ;

  {
  {
#line 134
  InitLineList(dst);
#line 135
  lp = src->first;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 135
      goto while_break;
    }
#line 136
    lp2 = lp;
#line 137
    lp = lp->next;
#line 138
    if ((unsigned long )lp2->line != (unsigned long )((void *)0)) {
      {
#line 139
      tmp = AddLine(dst, (char const   *)lp2->line);
      }
#line 139
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 140
        DisposeLineListContents(dst);
        }
#line 141
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (0);
}
}
#line 154 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void DisposeFileInfoListContents(FTPFileInfoListPtr list ) 
{ 
  FTPFileInfoPtr lp ;
  FTPFileInfoPtr lp2 ;

  {
#line 159
  lp = list->first;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 159
      goto while_break;
    }
#line 160
    lp2 = lp;
#line 161
    lp = lp->next;
#line 162
    if ((unsigned long )lp2->relname != (unsigned long )((void *)0)) {
      {
#line 163
      *(lp2->relname + 0) = (char )'\000';
#line 164
      free((void *)lp2->relname);
      }
    }
#line 166
    if ((unsigned long )lp2->lname != (unsigned long )((void *)0)) {
      {
#line 167
      *(lp2->lname + 0) = (char )'\000';
#line 168
      free((void *)lp2->lname);
      }
    }
#line 170
    if ((unsigned long )lp2->rname != (unsigned long )((void *)0)) {
      {
#line 171
      *(lp2->rname + 0) = (char )'\000';
#line 172
      free((void *)lp2->rname);
      }
    }
#line 174
    if ((unsigned long )lp2->rlinkto != (unsigned long )((void *)0)) {
      {
#line 175
      *(lp2->rlinkto + 0) = (char )'\000';
#line 176
      free((void *)lp2->rlinkto);
      }
    }
#line 178
    if ((unsigned long )lp2->plug != (unsigned long )((void *)0)) {
      {
#line 179
      *(lp2->plug + 0) = (char )'\000';
#line 180
      free((void *)lp2->plug);
      }
    }
    {
#line 182
    free((void *)lp2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if ((unsigned long )list->vec != (unsigned long )((void *)0)) {
    {
#line 186
    free((void *)list->vec);
    }
  }
  {
#line 188
  InitFileInfoList(list);
  }
#line 189
  return;
}
}
#line 194 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void InitFileInfoList(FTPFileInfoListPtr list ) 
{ 
  FTPFileInfoPtr tmp ;

  {
  {
#line 197
  memset((void *)list, 0, sizeof(FTPFileInfoList ));
#line 200
  tmp = (FTPFileInfoPtr )((void *)0);
#line 200
  list->last = tmp;
#line 200
  list->first = tmp;
#line 201
  list->vec = (FTPFileInfoVec )0;
  }
#line 202
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int TimeCmp(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 213
  fipa = (FTPFileInfo const   * const  *)a;
#line 214
  fipb = (FTPFileInfo const   * const  *)b;
#line 215
  if ((*fipb)->mdtm == (*fipa)->mdtm) {
#line 216
    return (0);
  } else
#line 217
  if ((*fipb)->mdtm < (*fipa)->mdtm) {
#line 218
    return (-1);
  }
#line 219
  return (1);
}
}
#line 225 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int ReverseTimeCmp(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 231
  fipa = (FTPFileInfo const   * const  *)a;
#line 232
  fipb = (FTPFileInfo const   * const  *)b;
#line 233
  if ((*fipa)->mdtm == (*fipb)->mdtm) {
#line 234
    return (0);
  } else
#line 235
  if ((*fipa)->mdtm < (*fipb)->mdtm) {
#line 236
    return (-1);
  }
#line 237
  return (1);
}
}
#line 243 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int SizeCmp(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 249
  fipa = (FTPFileInfo const   * const  *)a;
#line 250
  fipb = (FTPFileInfo const   * const  *)b;
#line 251
  if ((*fipb)->size == (*fipa)->size) {
#line 252
    return (0);
  } else
#line 253
  if ((*fipb)->size < (*fipa)->size) {
#line 254
    return (-1);
  }
#line 255
  return (1);
}
}
#line 261 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int ReverseSizeCmp(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 267
  fipa = (FTPFileInfo const   * const  *)a;
#line 268
  fipb = (FTPFileInfo const   * const  *)b;
#line 269
  if ((*fipa)->size == (*fipb)->size) {
#line 270
    return (0);
  } else
#line 271
  if ((*fipa)->size < (*fipb)->size) {
#line 272
    return (-1);
  }
#line 273
  return (1);
}
}
#line 279 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int ReverseNameCmp(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;
  int tmp ;

  {
  {
#line 285
  fipa = (FTPFileInfo const   * const  *)a;
#line 286
  fipb = (FTPFileInfo const   * const  *)b;
#line 288
  tmp = strcoll((char const   *)(*fipb)->relname, (char const   *)(*fipa)->relname);
  }
#line 288
  return (tmp);
}
}
#line 297 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int NameCmp(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;
  int tmp ;

  {
  {
#line 303
  fipa = (FTPFileInfo const   * const  *)a;
#line 304
  fipb = (FTPFileInfo const   * const  *)b;
#line 306
  tmp = strcoll((char const   *)(*fipa)->relname, (char const   *)(*fipb)->relname);
  }
#line 306
  return (tmp);
}
}
#line 315 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int BreadthFirstCmp(void const   *a , void const   *b ) 
{ 
  char *cp ;
  char *cpa ;
  char *cpb ;
  int depth ;
  int deptha ;
  int depthb ;
  int c ;
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 324
  fipa = (FTPFileInfo const   * const  *)a;
#line 325
  fipb = (FTPFileInfo const   * const  *)b;
#line 327
  cpa = (char *)(*fipa)->relname;
#line 328
  cpb = (char *)(*fipb)->relname;
#line 330
  cp = cpa;
#line 330
  depth = 0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    tmp = cp;
#line 331
    cp ++;
#line 331
    c = (int )*tmp;
#line 332
    if (c == 0) {
#line 333
      goto while_break;
    }
#line 334
    if (c == 47) {
#line 335
      depth ++;
    } else
#line 334
    if (c == 92) {
#line 335
      depth ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  deptha = depth;
#line 340
  cp = cpb;
#line 340
  depth = 0;
  {
#line 340
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 341
    tmp___0 = cp;
#line 341
    cp ++;
#line 341
    c = (int )*tmp___0;
#line 342
    if (c == 0) {
#line 343
      goto while_break___0;
    }
#line 344
    if (c == 47) {
#line 345
      depth ++;
    } else
#line 344
    if (c == 92) {
#line 345
      depth ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  depthb = depth;
#line 350
  if (deptha < depthb) {
#line 351
    return (-1);
  } else
#line 352
  if (deptha > depthb) {
#line 353
    return (1);
  }
  {
#line 356
  tmp___1 = strcoll((char const   *)cpa, (char const   *)cpb);
  }
#line 356
  return (tmp___1);
}
}
#line 365 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void SortFileInfoList(FTPFileInfoListPtr list , int sortKey , int sortOrder ) 
{ 
  FTPFileInfoVec fiv ;
  FTPFileInfoPtr fip ;
  int i___0 ;
  int j ;
  int n ;
  int n2 ;

  {
#line 372
  fiv = list->vec;
#line 373
  if ((unsigned long )fiv == (unsigned long )((void *)0)) {
#line 374
    return;
  }
#line 376
  if (list->sortKey == sortKey) {
#line 377
    if (list->sortOrder == sortOrder) {
#line 378
      return;
    }
#line 381
    n = list->nFileInfos;
#line 382
    if (n > 1) {
#line 383
      n2 = n / 2;
#line 384
      i___0 = 0;
      {
#line 384
      while (1) {
        while_continue: /* CIL Label */ ;
#line 384
        if (! (i___0 < n2)) {
#line 384
          goto while_break;
        }
#line 385
        j = (n - i___0) - 1;
#line 386
        fip = *(fiv + i___0);
#line 387
        *(fiv + i___0) = *(fiv + j);
#line 388
        *(fiv + j) = fip;
#line 384
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 392
    list->sortOrder = sortOrder;
  } else
#line 393
  if (sortKey == 110) {
#line 393
    if (sortOrder == 97) {
      {
#line 394
      qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & NameCmp);
#line 396
      list->sortKey = sortKey;
#line 397
      list->sortOrder = sortOrder;
      }
    } else {
#line 393
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 398
  if (sortKey == 110) {
#line 398
    if (sortOrder == 100) {
      {
#line 399
      qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & ReverseNameCmp);
#line 401
      list->sortKey = sortKey;
#line 402
      list->sortOrder = sortOrder;
      }
    } else {
#line 398
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 403
  if (sortKey == 116) {
#line 403
    if (sortOrder == 97) {
      {
#line 404
      qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & TimeCmp);
#line 406
      list->sortKey = sortKey;
#line 407
      list->sortOrder = sortOrder;
      }
    } else {
#line 403
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 408
  if (sortKey == 116) {
#line 408
    if (sortOrder == 100) {
      {
#line 409
      qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & ReverseTimeCmp);
#line 411
      list->sortKey = sortKey;
#line 412
      list->sortOrder = sortOrder;
      }
    } else {
#line 408
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 413
  if (sortKey == 115) {
#line 413
    if (sortOrder == 97) {
      {
#line 414
      qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & SizeCmp);
#line 416
      list->sortKey = sortKey;
#line 417
      list->sortOrder = sortOrder;
      }
    } else {
#line 413
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 418
  if (sortKey == 115) {
#line 418
    if (sortOrder == 100) {
      {
#line 419
      qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & ReverseSizeCmp);
#line 421
      list->sortKey = sortKey;
#line 422
      list->sortOrder = sortOrder;
      }
    } else {
#line 418
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 423
  if (sortKey == 98) {
    {
#line 425
    list->sortKey = sortKey;
#line 426
    list->sortOrder = sortOrder;
#line 427
    qsort((void *)fiv, (size_t )list->nFileInfos, sizeof(FTPFileInfoPtr ), & BreadthFirstCmp);
    }
  }
#line 430
  return;
}
}
#line 435 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void VectorizeFileInfoList(FTPFileInfoListPtr list ) 
{ 
  FTPFileInfoVec fiv ;
  FTPFileInfoPtr fip ;
  int i___0 ;
  void *tmp ;

  {
  {
#line 442
  tmp = calloc((size_t )(list->nFileInfos + 1), sizeof(FTPFileInfoPtr ));
#line 442
  fiv = (FTPFileInfoVec )tmp;
  }
#line 443
  if ((unsigned long )fiv != (unsigned long )((FTPFileInfoVec )0)) {
#line 444
    i___0 = 0;
#line 444
    fip = list->first;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((unsigned long )fip != (unsigned long )((void *)0))) {
#line 444
        goto while_break;
      }
#line 445
      *(fiv + i___0) = fip;
#line 444
      fip = fip->next;
#line 444
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 446
    list->vec = fiv;
  }
#line 448
  return;
}
}
#line 453 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void UnvectorizeFileInfoList(FTPFileInfoListPtr list ) 
{ 
  FTPFileInfoVec fiv ;
  FTPFileInfoPtr fip ;
  int i___0 ;
  int n ;

  {
#line 460
  fiv = list->vec;
#line 461
  if ((unsigned long )fiv != (unsigned long )((FTPFileInfoVec )0)) {
#line 462
    list->first = *(fiv + 0);
#line 463
    n = list->nFileInfos;
#line 464
    if (n > 0) {
#line 465
      list->last = *(fiv + (n - 1));
#line 466
      fip = *(fiv + 0);
#line 467
      fip->prev = (FTPFileInfoPtr )((void *)0);
#line 468
      fip->next = *(fiv + 1);
#line 469
      i___0 = 1;
      {
#line 469
      while (1) {
        while_continue: /* CIL Label */ ;
#line 469
        if (! (i___0 < n)) {
#line 469
          goto while_break;
        }
#line 470
        fip = *(fiv + i___0);
#line 471
        fip->prev = *(fiv + (i___0 - 1));
#line 472
        fip->next = *(fiv + (i___0 + 1));
#line 469
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 475
    free((void *)fiv);
#line 476
    list->vec = (FTPFileInfoVec )0;
    }
  }
#line 478
  return;
}
}
#line 483 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
void InitFileInfo(FTPFileInfoPtr fip ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  FTPFileInfoPtr tmp___3 ;

  {
  {
#line 486
  memset((void *)fip, 0, sizeof(FTPFileInfo ));
#line 488
  fip->type = '-';
#line 489
  fip->size = -1LL;
#line 490
  fip->mdtm = (time_t )-1;
#line 493
  tmp___2 = (char *)((void *)0);
#line 493
  fip->plug = tmp___2;
#line 493
  tmp___1 = tmp___2;
#line 493
  fip->lname = tmp___1;
#line 493
  tmp___0 = tmp___1;
#line 493
  fip->rlinkto = tmp___0;
#line 493
  tmp = tmp___0;
#line 493
  fip->rname = tmp;
#line 493
  fip->relname = tmp;
#line 494
  tmp___3 = (FTPFileInfoPtr )((void *)0);
#line 494
  fip->next = tmp___3;
#line 494
  fip->prev = tmp___3;
  }
#line 495
  return;
}
}
#line 500 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
FTPFileInfoPtr RemoveFileInfo(FTPFileInfoListPtr list , FTPFileInfoPtr killMe ) 
{ 
  FTPFileInfoPtr nextFileInfo ;
  FTPFileInfoPtr prevFileInfo ;

  {
#line 505
  nextFileInfo = killMe->next;
#line 506
  prevFileInfo = killMe->prev;
#line 507
  if ((unsigned long )killMe->lname != (unsigned long )((void *)0)) {
    {
#line 508
    *(killMe->lname + 0) = (char )'\000';
#line 509
    free((void *)killMe->lname);
    }
  }
#line 511
  if ((unsigned long )killMe->relname != (unsigned long )((void *)0)) {
    {
#line 512
    *(killMe->relname + 0) = (char )'\000';
#line 513
    free((void *)killMe->relname);
    }
  }
#line 515
  if ((unsigned long )killMe->rname != (unsigned long )((void *)0)) {
    {
#line 516
    *(killMe->rname + 0) = (char )'\000';
#line 517
    free((void *)killMe->rname);
    }
  }
#line 519
  if ((unsigned long )killMe->rlinkto != (unsigned long )((void *)0)) {
    {
#line 520
    *(killMe->rlinkto + 0) = (char )'\000';
#line 521
    free((void *)killMe->rlinkto);
    }
  }
#line 523
  if ((unsigned long )killMe->plug != (unsigned long )((void *)0)) {
    {
#line 524
    *(killMe->plug + 0) = (char )'\000';
#line 525
    free((void *)killMe->plug);
    }
  }
#line 528
  if ((unsigned long )list->first == (unsigned long )killMe) {
#line 529
    list->first = nextFileInfo;
  }
#line 530
  if ((unsigned long )list->last == (unsigned long )killMe) {
#line 531
    list->last = prevFileInfo;
  }
#line 533
  if ((unsigned long )nextFileInfo != (unsigned long )((void *)0)) {
#line 534
    nextFileInfo->prev = prevFileInfo;
  }
#line 535
  if ((unsigned long )prevFileInfo != (unsigned long )((void *)0)) {
#line 536
    prevFileInfo->next = nextFileInfo;
  }
  {
#line 538
  free((void *)killMe);
#line 539
  (list->nFileInfos) --;
  }
#line 540
  return (nextFileInfo);
}
}
#line 547 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
FTPFileInfoPtr AddFileInfo(FTPFileInfoListPtr list , FTPFileInfoPtr src ) 
{ 
  FTPFileInfoPtr lp ;
  void *tmp ;
  FTPFileInfoPtr tmp___0 ;

  {
  {
#line 552
  tmp = malloc(sizeof(FTPFileInfo ));
#line 552
  lp = (FTPFileInfoPtr )tmp;
  }
#line 553
  if ((unsigned long )lp != (unsigned long )((void *)0)) {
    {
#line 554
    memcpy((void */* __restrict  */)lp, (void const   */* __restrict  */)src, sizeof(FTPFileInfo ));
#line 555
    lp->next = (FTPFileInfoPtr )((void *)0);
    }
#line 556
    if ((unsigned long )list->first == (unsigned long )((void *)0)) {
#line 557
      tmp___0 = lp;
#line 557
      list->last = tmp___0;
#line 557
      list->first = tmp___0;
#line 558
      lp->prev = (FTPFileInfoPtr )((void *)0);
#line 559
      list->nFileInfos = 1;
    } else {
#line 561
      lp->prev = list->last;
#line 562
      (list->last)->next = lp;
#line 563
      list->last = lp;
#line 564
      (list->nFileInfos) ++;
    }
  }
#line 567
  return (lp);
}
}
#line 573 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int ConcatFileInfoList(FTPFileInfoListPtr dst , FTPFileInfoListPtr src ) 
{ 
  FTPFileInfoPtr lp ;
  FTPFileInfoPtr lp2 ;
  FTPFileInfo newfi ;
  FTPFileInfoPtr tmp ;

  {
#line 579
  lp = src->first;
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 579
      goto while_break;
    }
    {
#line 580
    lp2 = lp->next;
#line 581
    newfi = *lp;
#line 582
    newfi.relname = StrDup((char const   *)lp->relname);
#line 583
    newfi.lname = StrDup((char const   *)lp->lname);
#line 584
    newfi.rname = StrDup((char const   *)lp->rname);
#line 585
    newfi.rlinkto = StrDup((char const   *)lp->rlinkto);
#line 586
    newfi.plug = StrDup((char const   *)lp->plug);
#line 587
    tmp = AddFileInfo(dst, & newfi);
    }
#line 587
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 588
      return (-1);
    }
#line 579
    lp = lp2;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return (0);
}
}
#line 596 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int ComputeRNames(FTPFileInfoListPtr dst , char const   *dstdir , int pflag , int nochop ) 
{ 
  FTPFileInfoPtr lp ;
  FTPFileInfoPtr lp2 ;
  char *buf ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 603
  if ((unsigned long )dstdir == (unsigned long )((void *)0)) {
#line 604
    dstdir = ".";
  }
#line 606
  lp = dst->first;
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 606
      goto while_break;
    }
#line 607
    lp2 = lp->next;
#line 609
    buf = (char *)((void *)0);
#line 610
    if (nochop != 0) {
#line 611
      if ((int const   )*(dstdir + 0) != 0) {
        {
#line 611
        tmp___2 = strcmp(dstdir, ".");
        }
#line 611
        if (tmp___2) {
          {
#line 612
          tmp = Dynscat(& buf, dstdir, "/", lp->relname, (char *)0);
          }
#line 612
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 613
            goto memerr;
          }
#line 615
          if (pflag != 0) {
            {
#line 617
            cp = strrchr(dstdir, '/');
            }
#line 618
            if ((unsigned long )cp == (unsigned long )((void *)0)) {
              {
#line 619
              cp = strrchr(dstdir, '\\');
              }
            }
#line 620
            if ((unsigned long )cp != (unsigned long )((void *)0)) {
              {
#line 621
              tmp___0 = Dynscat(& lp->lname, cp + 1, (char *)0);
              }
#line 621
              if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 622
                goto memerr;
              }
            }
          }
        } else {
#line 611
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 627
        tmp___1 = Dynscat(& buf, lp->relname, (char *)0);
        }
#line 627
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 628
          goto memerr;
        }
      }
    } else
#line 631
    if ((int const   )*(dstdir + 0) != 0) {
      {
#line 631
      tmp___6 = strcmp(dstdir, ".");
      }
#line 631
      if (tmp___6) {
        {
#line 632
        cp = strrchr((char const   *)lp->relname, '/');
        }
#line 633
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
          {
#line 634
          cp = strrchr((char const   *)lp->relname, '\\');
          }
        }
#line 635
        if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 636
          cp ++;
        } else {
#line 638
          cp = lp->relname;
        }
        {
#line 640
        tmp___3 = Dynscat(& buf, dstdir, "/", cp, (char *)0);
        }
#line 640
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 641
          goto memerr;
        }
#line 643
        if (pflag != 0) {
          {
#line 645
          cp = strrchr(dstdir, '/');
          }
#line 646
          if ((unsigned long )cp == (unsigned long )((void *)0)) {
            {
#line 647
            cp = strrchr(dstdir, '\\');
            }
          }
#line 648
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
            {
#line 649
            tmp___4 = Dynscat(& lp->lname, cp + 1, (char *)0);
            }
#line 649
            if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 650
              goto memerr;
            }
          }
        }
      } else {
#line 631
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 655
      cp = strrchr((char const   *)lp->relname, '/');
      }
#line 656
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 657
        cp = strrchr((char const   *)lp->relname, '\\');
        }
      }
#line 658
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 659
        cp ++;
      } else {
#line 661
        cp = lp->relname;
      }
      {
#line 663
      tmp___5 = Dynscat(& buf, cp, (char *)0);
      }
#line 663
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 664
        goto memerr;
      }
    }
#line 667
    lp->rname = buf;
#line 668
    if ((unsigned long )lp->rname == (unsigned long )((void *)0)) {
      memerr: 
#line 670
      return (-1);
    }
#line 606
    lp = lp2;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  return (0);
}
}
#line 680 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int ComputeLNames(FTPFileInfoListPtr dst , char const   *srcdir , char const   *dstdir ,
                  int nochop ) 
{ 
  FTPFileInfoPtr lp ;
  FTPFileInfoPtr lp2 ;
  char *buf ;
  char *cp ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 687
  if ((unsigned long )srcdir != (unsigned long )((void *)0)) {
    {
#line 688
    cp = strrchr(srcdir, '/');
    }
#line 689
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 690
      cp = strrchr(srcdir, '\\');
      }
    }
#line 691
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 692
      srcdir = (char const   *)(cp + 1);
    }
  }
#line 694
  if ((unsigned long )dstdir == (unsigned long )((void *)0)) {
#line 695
    dstdir = ".";
  }
#line 697
  lp = dst->first;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 697
      goto while_break;
    }
#line 698
    lp2 = lp->next;
#line 700
    buf = (char *)((void *)0);
#line 701
    if (nochop != 0) {
#line 702
      if ((int const   )*(dstdir + 0) != 0) {
        {
#line 702
        tmp___0 = strcmp(dstdir, ".");
        }
#line 702
        if (tmp___0) {
          {
#line 703
          tmp = Dynscat(& buf, dstdir, "/", (char *)0);
          }
#line 703
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 704
            goto memerr;
          }
        }
      }
#line 706
      if ((unsigned long )lp->lname != (unsigned long )((void *)0)) {
        {
#line 707
        tmp___1 = Dynscat(& buf, lp->lname, "/", (char *)0);
        }
#line 707
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 708
          goto memerr;
        }
      } else
#line 709
      if ((unsigned long )srcdir != (unsigned long )((void *)0)) {
        {
#line 710
        tmp___2 = Dynscat(& buf, srcdir, "/", (char *)0);
        }
#line 710
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 711
          goto memerr;
        }
      }
      {
#line 713
      tmp___3 = Dynscat(& buf, lp->relname, (char *)0);
      }
#line 713
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 714
        goto memerr;
      }
    } else
#line 716
    if ((int const   )*(dstdir + 0) != 0) {
      {
#line 716
      tmp___6 = strcmp(dstdir, ".");
      }
#line 716
      if (tmp___6) {
        {
#line 717
        cp = strrchr((char const   *)lp->relname, '/');
        }
#line 718
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
          {
#line 719
          cp = strrchr((char const   *)lp->relname, '\\');
          }
        }
#line 720
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 721
          cp = lp->relname;
        } else {
#line 723
          cp ++;
        }
        {
#line 725
        tmp___4 = Dynscat(& buf, dstdir, "/", cp, (char *)0);
        }
#line 725
        if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 726
          goto memerr;
        }
      } else {
#line 716
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 728
      cp = strrchr((char const   *)lp->relname, '/');
      }
#line 729
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 730
        cp = strrchr((char const   *)lp->relname, '\\');
        }
      }
#line 731
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 732
        cp = lp->relname;
      } else {
#line 734
        cp ++;
      }
      {
#line 736
      tmp___5 = Dynscat(& buf, cp, (char *)0);
      }
#line 736
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 737
        goto memerr;
      }
    }
#line 740
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      memerr: 
#line 742
      return (-1);
    }
#line 744
    if ((unsigned long )lp->lname != (unsigned long )((void *)0)) {
      {
#line 745
      free((void *)lp->lname);
#line 746
      lp->lname = (char *)((void *)0);
      }
    }
#line 748
    lp->lname = buf;
#line 697
    lp = lp2;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  return (0);
}
}
#line 757 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int ConcatFileToFileInfoList(FTPFileInfoListPtr dst , char *rfile ) 
{ 
  FTPFileInfo newfi ;
  FTPFileInfoPtr tmp ;

  {
  {
#line 762
  InitFileInfo(& newfi);
#line 763
  newfi.relname = StrDup((char const   *)rfile);
#line 764
  newfi.rname = (char *)((void *)0);
#line 765
  newfi.lname = (char *)((void *)0);
#line 767
  tmp = AddFileInfo(dst, & newfi);
  }
#line 767
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 768
    return (-1);
  }
#line 769
  return (0);
}
}
#line 775 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int LineListToFileInfoList(FTPLineListPtr src , FTPFileInfoListPtr dst ) 
{ 
  FTPLinePtr lp ;
  FTPLinePtr lp2 ;
  int tmp ;

  {
  {
#line 780
  InitFileInfoList(dst);
#line 781
  lp = src->first;
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 781
      goto while_break;
    }
    {
#line 782
    lp2 = lp->next;
#line 783
    tmp = ConcatFileToFileInfoList(dst, lp->line);
    }
#line 783
    if (tmp < 0) {
#line 784
      return (-1);
    }
#line 781
    lp = lp2;
  }
  while_break: /* CIL Label */ ;
  }
#line 786
  return (0);
}
}
#line 792 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
int LineToFileInfoList(FTPLinePtr lp , FTPFileInfoListPtr dst ) 
{ 
  int tmp ;

  {
  {
#line 795
  InitFileInfoList(dst);
#line 796
  tmp = ConcatFileToFileInfoList(dst, lp->line);
  }
#line 796
  if (tmp < 0) {
#line 797
    return (-1);
  }
#line 798
  return (0);
}
}
#line 962 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
time_t UnMDTMDate(char *dstr ) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_unmdtm.c"
time_t UnMDTMDate(char *dstr ) 
{ 
  struct tm ut ;
  time_t mt ;
  time_t now ;
  time_t result ;
  char y2fix[64] ;
  int tmp ;
  time_t tmp___0 ;
  struct tm *tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 25
  result = (time_t )-1;
#line 28
  tmp = strncmp((char const   *)dstr, "1910", (size_t )4);
  }
#line 28
  if (tmp == 0) {
    {
#line 30
    memset((void *)(y2fix), 0, sizeof(y2fix));
#line 31
    y2fix[0] = (char )'2';
#line 32
    y2fix[1] = (char )'0';
#line 33
    y2fix[2] = *(dstr + 3);
#line 34
    y2fix[3] = *(dstr + 4);
#line 35
    strncpy((char */* __restrict  */)(y2fix + 4), (char const   */* __restrict  */)(dstr + 5),
            sizeof(y2fix) - 6UL);
#line 36
    dstr = y2fix;
    }
  }
  {
#line 43
  tmp___0 = time(& now);
#line 43
  tmp___1 = Gmtime(tmp___0, (struct tm */* const  */)(& ut));
  }
#line 43
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 44
    return (result);
  }
  {
#line 47
  tmp___3 = sscanf((char const   */* __restrict  */)dstr, (char const   */* __restrict  */)"%04d%02d%02d%02d%02d%02d",
                   & ut.tm_year, & ut.tm_mon, & ut.tm_mday, & ut.tm_hour, & ut.tm_min,
                   & ut.tm_sec);
  }
#line 47
  if (tmp___3 == 6) {
    {
#line 55
    (ut.tm_mon) --;
#line 56
    ut.tm_year -= 1900;
#line 57
    ut.tm_isdst = -1;
#line 58
    mt = mktime(& ut);
    }
#line 59
    if (mt != -1L) {
      {
#line 60
      tmp___2 = GetUTCOffset2((int const   )ut.tm_year, (int const   )(ut.tm_mon + 1),
                              (int const   )ut.tm_mday, (int const   )ut.tm_hour,
                              (int const   )ut.tm_min);
#line 60
      mt += tmp___2;
#line 61
      result = mt;
      }
    }
  }
#line 64
  return (result);
}
}
#line 336 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.h"
void ( /* format attribute */  Trace)(int const   level , char const   * const  fmt 
                                      , ...) ;
#line 20
void ErrorHook(FTPCIPtr const   cipUnused  __attribute__((__unused__)) , char *msg ) ;
#line 21
void DebugHook(FTPCIPtr const   cipUnused  __attribute__((__unused__)) , char *msg ) ;
#line 22
void SetDebug(int i___0 ) ;
#line 23
void UseTrace(void) ;
#line 24
void OpenTrace(void) ;
#line 25
void CloseTrace(void) ;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
time_t gTraceTime  ;
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
FILE *gTraceFile  =    (FILE *)((void *)0);
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
char gTraceLBuf[256]  ;
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
int gDebug  =    0;
#line 24
FTPConnectionInfo gConn ;
#line 36 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void ( /* format attribute */  Trace)(int const   level , char const   * const  fmt 
                                      , ...) 
{ 
  va_list ap ;
  char buf[512] ;
  struct tm lt ;
  struct tm *ltp ;
  time_t tmp ;

  {
#line 43
  if (gDebug >= (int )level) {
#line 43
    goto _L;
  } else
#line 43
  if (level > 8) {
    _L: /* CIL Label */ 
    {
#line 44
    __builtin_va_start(ap, fmt);
#line 46
    vsnprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)fmt,
              ap);
#line 47
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 51
    __builtin_va_end(ap);
#line 53
    tmp = time(& gTraceTime);
#line 53
    ltp = Localtime(tmp, (struct tm */* const  */)(& lt));
    }
#line 54
    if ((unsigned long )gTraceFile != (unsigned long )((void *)0)) {
#line 54
      if ((unsigned long )ltp != (unsigned long )((void *)0)) {
        {
#line 55
        fprintf((FILE */* __restrict  */)gTraceFile, (char const   */* __restrict  */)"%02d:%02d:%02d  %s",
                lt.tm_hour, lt.tm_min, lt.tm_sec, buf);
        }
      }
    }
#line 62
    if (gDebug > (int )level) {
      {
#line 63
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
              buf);
      }
    }
  }
#line 66
  return;
}
}
#line 71 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void ErrorHook(FTPCIPtr const   cipUnused  __attribute__((__unused__)) , char *msg ) 
{ 


  {
  {
#line 77
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
          msg);
  }
#line 78
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void DebugHook(FTPCIPtr const   cipUnused  __attribute__((__unused__)) , char *msg ) 
{ 


  {
  {
#line 87
  Trace((int const   )0, (char const   */* const  */)"%s", msg);
  }
#line 88
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void SetDebug(int i___0 ) 
{ 


  {
#line 96
  gDebug = i___0;
#line 97
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void UseTrace(void) 
{ 


  {
#line 105
  gConn.debugLogProc = & DebugHook;
#line 106
  gConn.debugLog = (FILE *)((void *)0);
#line 107
  gConn.errLogProc = & ErrorHook;
#line 108
  gConn.errLog = (FILE *)((void *)0);
#line 109
  return;
}
}
#line 114 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void OpenTrace(void) 
{ 
  FILE *tfp ;
  char pathName[256] ;
  char tName[32] ;
  char timeStr[128] ;
  int pid ;
  char const   *term_cp ;
  struct tm *tmp ;
  char *tmp___0 ;

  {
#line 124
  if ((int )gOurDirectoryPath[0] == 0) {
#line 125
    return;
  }
  {
#line 127
  pid = getpid();
#line 127
  sprintf((char */* __restrict  */)(tName), (char const   */* __restrict  */)"trace.%u",
          (unsigned int )pid);
#line 128
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)(tName));
#line 130
  tfp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"w");
  }
#line 131
  if ((unsigned long )tfp != (unsigned long )((void *)0)) {
    {
#line 134
    chmod((char const   *)(pathName), (__mode_t )384);
#line 137
    setvbuf((FILE */* __restrict  */)tfp, (char */* __restrict  */)(gTraceLBuf), 1,
            sizeof(gTraceLBuf));
#line 140
    time(& gTraceTime);
#line 141
    memset((void *)(timeStr), 0, sizeof(timeStr));
#line 142
    tmp = localtime((time_t const   *)(& gTraceTime));
#line 142
    strftime((char */* __restrict  */)(timeStr), sizeof(timeStr) - 1UL, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S %Z %z",
             (struct tm  const  */* __restrict  */)tmp);
#line 143
    fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"SESSION STARTED at:  %s\n",
            timeStr);
#line 144
    fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"Program Version:     %s compiled for %s\n",
            gVersion + 5, gOS);
    }
#line 145
    if ((int const   )gOS[0] != 0) {
      {
#line 146
      fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"Compiled for:        %s\n",
              gOS);
      }
    }
    {
#line 148
    fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"Process ID:          %u\n",
            pid);
    }
#line 150
    if (gGetOurHostNameResult == 100) {
      {
#line 151
      gGetOurHostNameResult = GetOurHostName((char */* const  */)(gOurHostName), (size_t const   )sizeof(gOurHostName));
      }
    }
    {
#line 152
    fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"Hostname:            %s  (rc=%d)\n",
            gOurHostName, gGetOurHostNameResult);
#line 153
    tmp___0 = getenv("TERM");
#line 153
    term_cp = (char const   *)tmp___0;
    }
#line 154
    if ((unsigned long )term_cp == (unsigned long )((void *)0)) {
#line 155
      term_cp = "unknown?";
    }
    {
#line 156
    fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"Terminal:            %s\n",
            term_cp);
#line 157
    gTraceFile = tfp;
    }
  }
#line 159
  return;
}
}
#line 164 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/trace.c"
void CloseTrace(void) 
{ 
  char pathName[256] ;
  char pathName2[256] ;
  char tName[32] ;
  __pid_t tmp ;
  char *tmp___0 ;

  {
#line 171
  if ((int )gOurDirectoryPath[0] == 0) {
#line 172
    return;
  } else
#line 171
  if ((unsigned long )gTraceFile == (unsigned long )((void *)0)) {
#line 172
    return;
  }
  {
#line 174
  tmp = getpid();
#line 174
  sprintf((char */* __restrict  */)(tName), (char const   */* __restrict  */)"trace.%u",
          (unsigned int )tmp);
#line 175
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)(tName));
#line 176
  OurDirectoryPath((char */* const  */)(pathName2), (size_t const   )sizeof(pathName2),
                   (char const   */* const  */)"trace");
#line 178
  time(& gTraceTime);
#line 179
  tmp___0 = ctime((time_t const   *)(& gTraceTime));
#line 179
  fprintf((FILE */* __restrict  */)gTraceFile, (char const   */* __restrict  */)"SESSION ENDED at:    %s",
          tmp___0);
#line 180
  fclose(gTraceFile);
#line 182
  unlink((char const   *)(pathName2));
#line 190
  rename((char const   *)(pathName), (char const   *)(pathName2));
  }
#line 192
  return;
}
}
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/util.c"
static unsigned char const   B64EncodeTable___1[64]  = 
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/util.c"
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/util.c"
static unsigned char const   B64DecodeTable___1[256]  = 
#line 50
  {      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'>', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'?', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'@',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\002', 
        (unsigned char const   )'\003',      (unsigned char const   )'\004',      (unsigned char const   )'\005',      (unsigned char const   )'\006', 
        (unsigned char const   )'\a',      (unsigned char const   )'\b',      (unsigned char const   )'\t',      (unsigned char const   )'\n', 
        (unsigned char const   )'\v',      (unsigned char const   )'\f',      (unsigned char const   )'\r',      (unsigned char const   )'\016', 
        (unsigned char const   )'\017',      (unsigned char const   )'\020',      (unsigned char const   )'\021',      (unsigned char const   )'\022', 
        (unsigned char const   )'\023',      (unsigned char const   )'\024',      (unsigned char const   )'\025',      (unsigned char const   )'\026', 
        (unsigned char const   )'\027',      (unsigned char const   )'\030',      (unsigned char const   )'\031',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\032',      (unsigned char const   )'\033',      (unsigned char const   )'\034', 
        (unsigned char const   )'\035',      (unsigned char const   )'\036',      (unsigned char const   )'\037',      (unsigned char const   )' ', 
        (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#',      (unsigned char const   )'$', 
        (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )'\'',      (unsigned char const   )'(', 
        (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+',      (unsigned char const   )',', 
        (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/',      (unsigned char const   )'0', 
        (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177'};
#line 648 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/util.c"
static void CancelGetHostByName___1(int sigNum ) 
{ 
  int tmp ;

  {
#line 655
  if (sigNum != 0) {
#line 655
    tmp = 1;
  } else {
#line 655
    tmp = 0;
  }
  {
#line 655
  siglongjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), tmp);
  }
}
}
#line 226 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
void FlushSReadlineInfo(SReadlineInfo *srl ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SReadline.c"
void FlushSReadlineInfo(SReadlineInfo *srl ) 
{ 
  int *tmp ;

  {
#line 9
  if ((unsigned long )srl == (unsigned long )((void *)0)) {
    {
#line 10
    tmp = __errno_location();
#line 10
    *tmp = 22;
    }
#line 11
    return;
  }
  {
#line 17
  memset((void *)srl->buf, 0, srl->bufSizeMax);
#line 18
  srl->bufSize = (size_t )0;
#line 19
  srl->bufLim = srl->buf + srl->bufSize;
#line 25
  srl->bufPtr = srl->bufLim;
  }
#line 26
  return;
}
}
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SReadline.c"
int InitSReadlineInfo(SReadlineInfo *srl , int fd , char *buf , size_t bsize , int tlen ,
                      int requireEOLN ) 
{ 
  int *tmp ;
  void *tmp___0 ;

  {
#line 34
  if ((unsigned long )srl == (unsigned long )((void *)0)) {
    {
#line 35
    tmp = __errno_location();
#line 35
    *tmp = 22;
    }
#line 36
    return (-1);
  } else
#line 34
  if (fd < 0) {
    {
#line 35
    tmp = __errno_location();
#line 35
    *tmp = 22;
    }
#line 36
    return (-1);
  } else
#line 34
  if (tlen <= 0) {
    {
#line 35
    tmp = __errno_location();
#line 35
    *tmp = 22;
    }
#line 36
    return (-1);
  }
#line 39
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 40
    if (bsize < 512UL) {
#line 41
      bsize = (size_t )512;
    }
    {
#line 42
    tmp___0 = malloc(bsize);
#line 42
    buf = (char *)tmp___0;
    }
#line 43
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 44
      return (-1);
    }
#line 45
    srl->malloc = 1;
  } else {
#line 47
    srl->malloc = 0;
  }
  {
#line 49
  memset((void *)buf, 0, bsize);
#line 50
  srl->buf = buf;
#line 51
  srl->bufSizeMax = bsize;
#line 52
  srl->bufSize = (size_t )0;
#line 53
  srl->bufLim = srl->buf + srl->bufSize;
#line 54
  srl->fd = fd;
#line 55
  srl->timeoutLen = tlen;
#line 56
  srl->requireEOLN = requireEOLN;
#line 62
  srl->bufPtr = srl->bufLim;
  }
#line 63
  return (0);
}
}
#line 69 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SReadline.c"
void DisposeSReadlineInfo(SReadlineInfo *srl ) 
{ 


  {
  {
#line 72
  memset((void *)srl->buf, 0, srl->bufSizeMax);
  }
#line 73
  if (srl->malloc != 0) {
    {
#line 74
    free((void *)srl->buf);
    }
  }
  {
#line 75
  memset((void *)srl, 0, sizeof(SReadlineInfo ));
  }
#line 78
  return;
}
}
#line 88 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SReadline.c"
int SReadline(SReadlineInfo *srl , char * const  linebuf , size_t linebufsize ) 
{ 
  int err ;
  char *src ;
  char *dst ;
  char *dstlim ;
  int len ;
  int nr ;
  int requireEOLN ;
  int illegals ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 100
  if ((unsigned long )srl == (unsigned long )((void *)0)) {
    {
#line 101
    tmp = __errno_location();
#line 101
    *tmp = 22;
    }
#line 102
    return (-1);
  } else
#line 100
  if ((unsigned long )linebuf == (unsigned long )((void *)0)) {
    {
#line 101
    tmp = __errno_location();
#line 101
    *tmp = 22;
    }
#line 102
    return (-1);
  } else
#line 100
  if (linebufsize < 2UL) {
    {
#line 101
    tmp = __errno_location();
#line 101
    *tmp = 22;
    }
#line 102
    return (-1);
  }
#line 105
  illegals = 0;
#line 106
  err = 0;
#line 107
  dst = (char *)linebuf;
#line 108
  dstlim = (dst + linebufsize) - 1;
#line 109
  src = srl->bufPtr;
#line 110
  requireEOLN = srl->requireEOLN;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (requireEOLN == 0) {
#line 113
      if ((unsigned long )dst >= (unsigned long )dstlim) {
#line 114
        goto while_break;
      }
    }
#line 115
    if ((unsigned long )src >= (unsigned long )srl->bufLim) {
#line 117
      if (illegals > 1) {
#line 121
        goto done;
      }
      {
#line 123
      nr = SRead(srl->fd, (char */* const  */)srl->buf, srl->bufSizeMax, srl->timeoutLen,
                 0);
      }
#line 124
      if (nr == 0) {
#line 126
        goto done;
      } else
#line 127
      if (nr < 0) {
#line 129
        err = nr;
#line 130
        goto done;
      }
#line 132
      src = srl->buf;
#line 132
      srl->bufPtr = src;
#line 133
      srl->bufLim = srl->buf + nr;
#line 134
      srl->bufSize = (size_t )nr;
    }
#line 136
    if ((int )*src == 0) {
#line 137
      src ++;
#line 138
      illegals ++;
    } else
#line 139
    if ((int )*src == 13) {
#line 140
      src ++;
#line 144
      if ((unsigned long )src < (unsigned long )srl->bufLim) {
#line 144
        if ((int )*src != 10) {
#line 145
          illegals ++;
        }
      }
    } else {
#line 147
      if ((int )*src == 10) {
#line 148
        if ((unsigned long )dst < (unsigned long )dstlim) {
#line 149
          tmp___0 = dst;
#line 149
          dst ++;
#line 149
          tmp___1 = src;
#line 149
          src ++;
#line 149
          *tmp___0 = *tmp___1;
        } else {
#line 151
          src ++;
        }
#line 152
        goto done;
      }
#line 154
      if ((unsigned long )dst < (unsigned long )dstlim) {
#line 155
        tmp___2 = dst;
#line 155
        dst ++;
#line 155
        tmp___3 = src;
#line 155
        src ++;
#line 155
        *tmp___2 = *tmp___3;
      } else {
#line 157
        src ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 162
  srl->bufPtr = src;
#line 163
  if (requireEOLN != 0) {
#line 163
    if ((unsigned long )dst == (unsigned long )linebuf) {
#line 163
      if (illegals > 0) {
#line 164
        tmp___4 = dst;
#line 164
        dst ++;
#line 164
        *tmp___4 = (char )'\n';
      }
    }
  }
#line 165
  *dst = (char )'\000';
#line 166
  len = (int )(dst - (char *)linebuf);
#line 167
  if (err < 0) {
#line 168
    return (err);
  }
#line 169
  return (len);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 44 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.h"
void SetAnonPass(char const   * const  val , FILE * const  fp ) ;
#line 45
void SetAutoAscii(char const   * const  val , FILE * const  fp ) ;
#line 46
void SetAutoResume(char const   * const  val , FILE * const  fp ) ;
#line 47
void SetAutoSaveChangesToExistingBookmarks(char const   * const  val , FILE * const  fp ) ;
#line 48
void SetConfirmClose(char const   * const  val , FILE * const  fp ) ;
#line 49
void SetConnTimeout(char const   * const  val , FILE * const  fp ) ;
#line 50
void SetCtrlTimeout(char const   * const  val , FILE * const  fp ) ;
#line 51
void SetLogSize(char const   * const  val , FILE * const  fp ) ;
#line 52
void SetNoAds(char const   * const  val , FILE * const  fp ) ;
#line 53
void SetOneTimeMessages(char const   * const  val , FILE * const  fp ) ;
#line 54
void SetPager(char const   * const  val , FILE * const  fp ) ;
#line 55
void SetPassive(char const   * const  val , FILE * const  fp ) ;
#line 59
void SetProgressMeter(char const   * const  val  __attribute__((__unused__)) , FILE * const  fp  __attribute__((__unused__)) ) ;
#line 61
void SetRedialDelay(char const   * const  val , FILE * const  fp ) ;
#line 62
void SetSavePasswords(char const   * const  val , FILE * const  fp ) ;
#line 63
void SetSOBufsize(char const   * const  val , FILE * const  fp ) ;
#line 64
void SetXferTimeout(char const   * const  val , FILE * const  fp ) ;
#line 65
void SetXtTitle(char const   * const  val , FILE * const  fp ) ;
#line 66
void Set(char const   * const  tok1 , char const   * const  tok2 ) ;
#line 67
void ProcessPrefsFile(FILE * const  fp ) ;
#line 68
void LoadPrefs(void) ;
#line 69
void InitPrefs(void) ;
#line 70
void PostInitPrefs(void) ;
#line 71
void SavePrefs(void) ;
#line 75
void CheckForNewV3User(void) ;
#line 76
int HasSeenOneTimeMessage(char const   * const  msg ) ;
#line 77
void SetSeenOneTimeMessage(char const   * const  msg ) ;
#line 78
int OneTimeMessage(char const   * const  msg ) ;
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
char gPager[128]  ;
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gConnTimeout  ;
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gXferTimeout  ;
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gCtrlTimeout  ;
#line 33 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gAutoResume  ;
#line 36 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gConfirmClose  ;
#line 39 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gAutoSaveChangesToExistingBookmarks  ;
#line 42 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gSavePasswords  ;
#line 44 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gMaySetXtermTitle  ;
#line 47 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gRedialDelay  ;
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
char gOneTimeMessagesSeen[256]  ;
#line 53 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gSOBufsize  ;
#line 56 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gMaxLogSize  ;
#line 59 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
char gAutoAscii[512]  ;
#line 67 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gDoNotDisplayAds  ;
#line 70 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gPrefsDirty  =    0;
#line 76 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
PrefOpt gPrefOpts[35]  = 
#line 76
  {      {"anonopen", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"anonpass", & SetAnonPass, -1}, 
        {"anon-password", & SetAnonPass, 1}, 
        {"auto-ascii", & SetAutoAscii, 1}, 
        {"auto-resume", & SetAutoResume, 1}, 
        {"autosave-bookmark-changes", & SetAutoSaveChangesToExistingBookmarks, 1}, 
        {"blank-lines", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"confirm-close",
      & SetConfirmClose, 1}, 
        {"connect-timeout", & SetConnTimeout, 1}, 
        {"control-timeout", & SetCtrlTimeout, 1}, 
        {"logsize", & SetLogSize, 1}, 
        {"maxbookmarks", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"one-time-messages-seen",
      & SetOneTimeMessages, 0}, 
        {"pager", & SetPager, 1}, 
        {"passive", & SetPassive, 1}, 
        {"progress-meter", & SetProgressMeter, 1}, 
        {"redial-delay", & SetRedialDelay, 1}, 
        {"remote-msgs", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"restore-lcwd",
      (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"save-passwords", & SetSavePasswords, 1}, 
        {"show-trailing-space", (void (*)(char const   * const   , FILE * const  fp ))0,
      -1}, 
        {"show-status-in-xterm-titlebar", & SetXtTitle, 1}, 
        {"so-bufsize", & SetSOBufsize, 1}, 
        {"startup-lcwd", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"startup-msgs",
      (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"timeout", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"total-runs", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"total-xfer-hundredths-of-seconds", (void (*)(char const   * const   , FILE * const  fp ))0,
      -1}, 
        {"total-xfer-kbytes", (void (*)(char const   * const   , FILE * const  fp ))0,
      -1}, 
        {"trace", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"utime", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"visual", (void (*)(char const   * const   , FILE * const  fp ))0, -1}, 
        {"xfer-timeout", & SetXferTimeout, 1}, 
        {"yes-i-know-about-NcFTPd", & SetNoAds, 1}, 
        {(char const   *)((void *)0), (void (*)(char const   * const   , FILE * const  fp ))0,
      0}};
#line 116 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int gNumPrefOpts  =    (int )(sizeof(gPrefOpts) / sizeof(PrefOpt )) - 1;
#line 120 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetAnonPass(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 123
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 124
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", gLib.defaultAnonPassword);
    }
  } else {
    {
#line 126
    Strncpy((char */* const  */)(gLib.defaultAnonPassword), val, (size_t const   )sizeof(gLib.defaultAnonPassword));
    }
  }
#line 128
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetAutoAscii(char const   * const  val , FILE * const  fp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 135
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 136
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", gAutoAscii);
    }
  } else {
    {
#line 138
    Strncpy((char */* const  */)(gAutoAscii), val, (size_t const   )sizeof(gAutoAscii));
    }
#line 139
    if ((int )gAutoAscii[0] == 0) {
#line 140
      gConn.asciiFilenameExtensions = (char const   *)((void *)0);
    } else {
      {
#line 139
      tmp = strcasecmp((char const   *)(gAutoAscii), "no");
      }
#line 139
      if (tmp == 0) {
#line 140
        gConn.asciiFilenameExtensions = (char const   *)((void *)0);
      } else {
        {
#line 139
        tmp___0 = strcasecmp((char const   *)(gAutoAscii), "off");
        }
#line 139
        if (tmp___0 == 0) {
#line 140
          gConn.asciiFilenameExtensions = (char const   *)((void *)0);
        } else {
          {
#line 139
          tmp___1 = strcasecmp((char const   *)(gAutoAscii), "false");
          }
#line 139
          if (tmp___1 == 0) {
#line 140
            gConn.asciiFilenameExtensions = (char const   *)((void *)0);
          } else {
#line 142
            gConn.asciiFilenameExtensions = (char const   *)(gAutoAscii);
          }
        }
      }
    }
  }
#line 145
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetAutoResume(char const   * const  val , FILE * const  fp ) 
{ 
  char const   *tmp ;

  {
#line 152
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 153
    if (gAutoResume == 0) {
#line 153
      tmp = "no";
    } else {
#line 153
      tmp = "yes";
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp);
    }
  } else {
    {
#line 155
    gAutoResume = StrToBool(val);
    }
  }
#line 157
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetAutoSaveChangesToExistingBookmarks(char const   * const  val , FILE * const  fp ) 
{ 
  char const   *tmp ;

  {
#line 164
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 165
    if (gAutoSaveChangesToExistingBookmarks == 0) {
#line 165
      tmp = "no";
    } else {
#line 165
      tmp = "yes";
    }
    {
#line 165
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp);
    }
  } else {
    {
#line 167
    gAutoSaveChangesToExistingBookmarks = StrToBool(val);
    }
  }
#line 169
  return;
}
}
#line 173 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetConfirmClose(char const   * const  val , FILE * const  fp ) 
{ 
  char const   *tmp ;

  {
#line 176
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 177
    if (gConfirmClose == 0) {
#line 177
      tmp = "no";
    } else {
#line 177
      tmp = "yes";
    }
    {
#line 177
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp);
    }
  } else {
    {
#line 179
    gConfirmClose = StrToBool(val);
    }
  }
#line 181
  return;
}
}
#line 185 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetConnTimeout(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 188
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 189
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", gConnTimeout);
    }
  } else {
    {
#line 191
    gConnTimeout = atoi((char const   *)val);
#line 191
    gConn.connTimeout = (unsigned int )gConnTimeout;
    }
  }
#line 193
  return;
}
}
#line 197 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetCtrlTimeout(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 200
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 201
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", gCtrlTimeout);
    }
  } else {
    {
#line 203
    gCtrlTimeout = atoi((char const   *)val);
#line 203
    gConn.ctrlTimeout = (unsigned int )gCtrlTimeout;
    }
  }
#line 205
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetLogSize(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 212
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 213
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", gMaxLogSize);
    }
  } else {
    {
#line 215
    gMaxLogSize = atoi((char const   *)val);
    }
  }
#line 217
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetNoAds(char const   * const  val , FILE * const  fp ) 
{ 
  char const   *tmp ;

  {
#line 224
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 225
    if (gDoNotDisplayAds == 0) {
#line 225
      tmp = "no";
    } else {
#line 225
      tmp = "yes";
    }
    {
#line 225
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp);
    }
  } else {
    {
#line 227
    gDoNotDisplayAds = StrToBool(val);
    }
  }
#line 229
  return;
}
}
#line 233 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetOneTimeMessages(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 236
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 237
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", gOneTimeMessagesSeen);
    }
  } else {
    {
#line 239
    Strncpy((char */* const  */)(gOneTimeMessagesSeen), val, (size_t const   )sizeof(gOneTimeMessagesSeen));
    }
  }
#line 241
  return;
}
}
#line 245 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetPager(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 248
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 249
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", gPager);
    }
  } else {
    {
#line 251
    Strncpy((char */* const  */)(gPager), val, (size_t const   )sizeof(gPager));
    }
  }
#line 253
  return;
}
}
#line 257 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetPassive(char const   * const  val , FILE * const  fp ) 
{ 
  int m ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 262
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 263
    if (gFwDataPortMode >= 0) {
#line 263
      m = gFwDataPortMode;
    } else {
#line 263
      m = gDataPortMode;
    }
#line 264
    if (m == 0) {
      {
#line 265
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              "off");
      }
    } else
#line 266
    if (m == 1) {
      {
#line 267
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              "on");
      }
    } else {
      {
#line 269
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              "optional");
      }
    }
  } else {
#line 272
    if (gFwDataPortMode >= 0) {
#line 273
      gDataPortMode = gFwDataPortMode;
#line 274
      return;
    }
    {
#line 276
    tmp___1 = strncasecmp((char const   *)val, "opt", (size_t )3);
    }
#line 276
    if (tmp___1 == 0) {
#line 277
      gDataPortMode = 2;
    } else {
      {
#line 278
      tmp___0 = strcasecmp((char const   *)val, "on");
      }
#line 278
      if (tmp___0 == 0) {
#line 279
        gDataPortMode = 1;
      } else {
        {
#line 280
        tmp = __ctype_b_loc();
        }
#line 280
        if ((int const   )*(*tmp + (int )*(val + 0)) & 2048) {
          {
#line 281
          gDataPortMode = atoi((char const   *)val);
          }
        } else {
#line 283
          gDataPortMode = 0;
        }
      }
    }
#line 284
    gConn.dataPortMode = gDataPortMode;
  }
#line 286
  return;
}
}
#line 313 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetProgressMeter(char const   * const  val  __attribute__((__unused__)) , FILE * const  fp  __attribute__((__unused__)) ) 
{ 


  {
#line 318
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetRedialDelay(char const   * const  val , FILE * const  fp ) 
{ 
  int i___0 ;

  {
#line 328
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 329
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", gRedialDelay);
    }
  } else {
    {
#line 331
    i___0 = atoi((char const   *)val);
    }
#line 332
    if (i___0 < 10) {
#line 333
      i___0 = 10;
    }
    {
#line 334
    gRedialDelay = atoi((char const   *)val);
    }
  }
#line 336
  return;
}
}
#line 340 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetSavePasswords(char const   * const  val , FILE * const  fp ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 343
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 344
    if (gSavePasswords < 0) {
      {
#line 345
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              "ask");
      }
    } else {
#line 347
      if (gSavePasswords == 0) {
#line 347
        tmp = "no";
      } else {
#line 347
        tmp = "yes";
      }
      {
#line 347
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              tmp);
      }
    }
  } else {
    {
#line 349
    tmp___0 = strcasecmp((char const   *)val, "ask");
    }
#line 349
    if (tmp___0 == 0) {
#line 350
      gSavePasswords = -1;
    } else {
      {
#line 352
      gSavePasswords = StrToBool(val);
      }
    }
  }
#line 354
  return;
}
}
#line 358 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetSOBufsize(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 361
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 362
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", gSOBufsize);
    }
#line 363
    if (gSOBufsize <= 0) {
      {
#line 364
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              " (use system default)");
      }
    }
  } else {
    {
#line 366
    gSOBufsize = atoi((char const   *)val);
#line 366
    gConn.dataSocketSBufSize = (size_t )gSOBufsize;
#line 366
    gConn.dataSocketRBufSize = gConn.dataSocketSBufSize;
    }
  }
#line 368
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetXferTimeout(char const   * const  val , FILE * const  fp ) 
{ 


  {
#line 376
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 377
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d", gXferTimeout);
    }
  } else {
    {
#line 379
    gXferTimeout = atoi((char const   *)val);
#line 379
    gConn.xferTimeout = (unsigned int )gXferTimeout;
    }
  }
#line 381
  return;
}
}
#line 385 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetXtTitle(char const   * const  val , FILE * const  fp ) 
{ 
  char const   *tmp ;

  {
#line 388
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 389
    if (gMaySetXtermTitle == 0) {
#line 389
      tmp = "no";
    } else {
#line 389
      tmp = "yes";
    }
    {
#line 389
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", tmp);
    }
  } else {
    {
#line 391
    gMaySetXtermTitle = StrToBool(val);
    }
  }
#line 393
  return;
}
}
#line 398 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
static void Show1(int t ) 
{ 
  PrefOpt *p___5 ;

  {
  {
#line 401
  p___5 = & gPrefOpts[t];
#line 403
  printf((char const   */* __restrict  */)"%-30s ", p___5->varname);
  }
#line 404
  if ((unsigned long )p___5->proc != (unsigned long )((void (*)(char const   * const   ,
                                                                FILE * const  fp ))0)) {
    {
#line 405
    (*(p___5->proc))((char const   */* const  */)((void *)0), (FILE */* const  */)stdout);
    }
  }
  {
#line 406
  printf((char const   */* __restrict  */)"\n");
  }
#line 407
  return;
}
}
#line 413 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void Set(char const   * const  tok1 , char const   * const  tok2 ) 
{ 
  int t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 418
  if ((unsigned long )tok1 == (unsigned long )((void *)0)) {
#line 418
    goto _L;
  } else {
    {
#line 418
    tmp___1 = strcasecmp((char const   *)tok1, "all");
    }
#line 418
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
#line 420
      t = 0;
      {
#line 420
      while (1) {
        while_continue: /* CIL Label */ ;
#line 420
        if (! (t < gNumPrefOpts)) {
#line 420
          goto while_break;
        }
#line 421
        if (gPrefOpts[t].visible == 1) {
          {
#line 422
          Show1(t);
          }
        }
#line 420
        t ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 424
    if ((unsigned long )tok2 == (unsigned long )((void *)0)) {
#line 426
      t = 0;
      {
#line 426
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 426
        if (! (t < gNumPrefOpts)) {
#line 426
          goto while_break___0;
        }
        {
#line 427
        tmp = strcasecmp((char const   *)tok1, gPrefOpts[t].varname);
        }
#line 427
        if (tmp == 0) {
#line 428
          if (gPrefOpts[t].visible == -1) {
            {
#line 429
            printf((char const   */* __restrict  */)"The \"%s\" option is obselete or not implemented.\n",
                   tok1);
            }
          } else {
            {
#line 431
            Show1(t);
            }
          }
#line 433
          goto while_break___0;
        }
#line 426
        t ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 436
      if (t >= gNumPrefOpts) {
        {
#line 437
        printf((char const   */* __restrict  */)"Unknown option \"%s\" -- try \"show all\" to list available options.\n",
               tok1);
        }
      }
    } else {
#line 441
      t = 0;
      {
#line 441
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 441
        if (! (t < gNumPrefOpts)) {
#line 441
          goto while_break___1;
        }
        {
#line 442
        tmp___0 = strcasecmp((char const   *)tok1, gPrefOpts[t].varname);
        }
#line 442
        if (tmp___0 == 0) {
#line 443
          if (gPrefOpts[t].visible == -1) {
            {
#line 444
            printf((char const   */* __restrict  */)"The \"%s\" option is obselete or not implemented.\n",
                   tok1);
            }
          } else
#line 445
          if ((unsigned long )gPrefOpts[t].proc != (unsigned long )((void (*)(char const   * const   ,
                                                                              FILE * const  fp ))0)) {
            {
#line 446
            (*(gPrefOpts[t].proc))(tok2, (FILE */* const  */)((void *)0));
#line 447
            gPrefsDirty ++;
            }
          }
#line 449
          goto while_break___1;
        }
#line 441
        t ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 452
      if (t >= gNumPrefOpts) {
        {
#line 453
        printf((char const   */* __restrict  */)"Unknown option \"%s\" -- try \"show all\" to list available options.\n",
               tok1);
        }
      }
    }
  }
#line 456
  return;
}
}
#line 460 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int HasSeenOneTimeMessage(char const   * const  msg ) 
{ 
  char buf[256] ;
  char *a ;
  char *b ;
  int tmp ;

  {
  {
#line 466
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(gOneTimeMessagesSeen),
         sizeof(buf));
#line 467
  a = buf;
  }
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 467
    b = strtok((char */* __restrict  */)a, (char const   */* __restrict  */)",\n");
    }
#line 467
    if (! ((unsigned long )b != (unsigned long )((void *)0))) {
#line 467
      goto while_break;
    }
    {
#line 468
    tmp = strcmp((char const   *)msg, (char const   *)b);
    }
#line 468
    if (tmp == 0) {
#line 469
      return (1);
    }
#line 467
    a = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  return (0);
}
}
#line 477 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SetSeenOneTimeMessage(char const   * const  msg ) 
{ 


  {
#line 480
  gPrefsDirty ++;
#line 481
  if ((int )gOneTimeMessagesSeen[0] == 0) {
    {
#line 482
    Strncpy((char */* const  */)(gOneTimeMessagesSeen), msg, (size_t const   )sizeof(gOneTimeMessagesSeen));
    }
  } else {
    {
#line 484
    Strncat((char */* const  */)(gOneTimeMessagesSeen), (char const   */* const  */)",",
            (size_t const   )sizeof(gOneTimeMessagesSeen));
#line 485
    Strncat((char */* const  */)(gOneTimeMessagesSeen), msg, (size_t const   )sizeof(gOneTimeMessagesSeen));
    }
  }
#line 487
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
int OneTimeMessage(char const   * const  msg ) 
{ 
  int tmp ;

  {
  {
#line 494
  tmp = HasSeenOneTimeMessage(msg);
  }
#line 494
  if (tmp) {
#line 495
    return (0);
  }
  {
#line 496
  SetSeenOneTimeMessage(msg);
  }
#line 497
  return (1);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void ProcessPrefsFile(FILE * const  fp ) 
{ 
  char line[1024] ;
  char *tok1 ;
  char *tok2 ;
  int t ;
  int tmp ;
  char *tmp___0 ;

  {
#line 510
  line[sizeof(line) - 1UL] = (char )'\000';
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 511
    tmp___0 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL), (FILE */* __restrict  */)fp);
    }
#line 511
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 511
      goto while_break;
    }
    {
#line 512
    tok1 = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)" =\t\r\n");
    }
#line 513
    if ((unsigned long )tok1 == (unsigned long )((void *)0)) {
#line 514
      goto while_continue;
    } else
#line 513
    if ((int )*(tok1 + 0) == 35) {
#line 514
      goto while_continue;
    }
    {
#line 515
    tok2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\r\n");
    }
#line 516
    if ((unsigned long )tok2 == (unsigned long )((void *)0)) {
#line 517
      goto while_continue;
    }
#line 519
    t = 0;
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 519
      if (! (t < gNumPrefOpts)) {
#line 519
        goto while_break___0;
      }
      {
#line 520
      tmp = strcasecmp((char const   *)tok1, gPrefOpts[t].varname);
      }
#line 520
      if (tmp == 0) {
#line 521
        if (gPrefOpts[t].visible == -1) {
#line 525
          gPrefsDirty ++;
        } else
#line 526
        if ((unsigned long )gPrefOpts[t].proc != (unsigned long )((void (*)(char const   * const   ,
                                                                            FILE * const  fp ))0)) {
          {
#line 527
          (*(gPrefOpts[t].proc))((char const   */* const  */)tok2, (FILE */* const  */)((void *)0));
          }
        }
      }
#line 519
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  return;
}
}
#line 538 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void LoadPrefs(void) 
{ 
  FILE *fp ;
  char pathName[256] ;

  {
  {
#line 556
  fp = fopen((char const   */* __restrict  */)"/usr/local/etc/ncftp.prefs_v3", (char const   */* __restrict  */)"r");
  }
#line 557
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 559
    ProcessPrefsFile((FILE */* const  */)fp);
#line 560
    fclose(fp);
    }
  }
#line 563
  if ((int )gOurDirectoryPath[0] != 0) {
    {
#line 564
    OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                     (char const   */* const  */)"prefs_v3");
#line 566
    fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
    }
#line 567
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 572
      gPrefsDirty ++;
#line 573
      OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                       (char const   */* const  */)"prefs");
#line 574
      fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
      }
    }
#line 577
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 579
      gPrefsDirty ++;
    } else {
      {
#line 582
      ProcessPrefsFile((FILE */* const  */)fp);
#line 583
      fclose(fp);
      }
    }
  }
  {
#line 587
  fp = fopen((char const   */* __restrict  */)"/usr/local/etc/ncftp.prefs_v3.fixed",
             (char const   */* __restrict  */)"r");
  }
#line 588
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 590
    ProcessPrefsFile((FILE */* const  */)fp);
#line 591
    fclose(fp);
    }
  }
#line 593
  return;
}
}
#line 599 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void InitPrefs(void) 
{ 
  char *tok1 ;
  char *tmp ;

  {
  {
#line 605
  gPager[0] = (char )'\000';
#line 606
  memset((void *)(gOneTimeMessagesSeen), 0, sizeof(gOneTimeMessagesSeen));
#line 607
  gXferTimeout = 3600;
#line 608
  gConnTimeout = 20;
#line 609
  gCtrlTimeout = 135;
#line 610
  gDataPortMode = 2;
#line 611
  gConn.dataPortMode = gDataPortMode;
#line 612
  gAutoResume = 0;
#line 613
  gSOBufsize = 0;
#line 614
  gMaxLogSize = 10240;
#line 615
  gConfirmClose = 0;
#line 616
  gAutoSaveChangesToExistingBookmarks = 0;
#line 617
  gRedialDelay = 20;
#line 618
  Strncpy((char */* const  */)(gAutoAscii), (char const   */* const  */)"|.txt|.asc|.html|.htm|.css|.xml|.ini|.pl|.hqx|.cfg|.c|.h|.cpp|.hpp|.bat|.m3u|.pls|",
          (size_t const   )sizeof(gAutoAscii));
#line 626
  gDoNotDisplayAds = 0;
#line 632
  gMaySetXtermTitle = 0;
#line 635
  gSavePasswords = -1;
#line 640
  tok1 = getenv("PAGER");
  }
#line 641
  if ((unsigned long )tok1 != (unsigned long )((void *)0)) {
#line 641
    if ((int )*(tok1 + 0) != 0) {
      {
#line 648
      tmp = strstr((char const   *)(gPager), "less");
      }
#line 648
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        {
#line 649
        Strncpy((char */* const  */)(gPager), (char const   */* const  */)"more",
                (size_t const   )sizeof(gPager));
        }
      } else {
        {
#line 651
        Strncpy((char */* const  */)(gPager), (char const   */* const  */)tok1, (size_t const   )sizeof(gPager));
        }
      }
    } else {
      {
#line 656
      Strncpy((char */* const  */)(gPager), (char const   */* const  */)"more", (size_t const   )sizeof(gPager));
      }
    }
  } else {
    {
#line 656
    Strncpy((char */* const  */)(gPager), (char const   */* const  */)"more", (size_t const   )sizeof(gPager));
    }
  }
#line 658
  return;
}
}
#line 664 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void PostInitPrefs(void) 
{ 


  {
#line 667
  if ((int )gLib.defaultAnonPassword[0] == 0) {
    {
#line 668
    FTPInitializeAnonPassword((FTPLIPtr const   )(& gLib));
#line 669
    gPrefsDirty ++;
    }
  }
#line 671
  if (gFwDataPortMode >= 0) {
#line 672
    gConn.dataPortMode = gFwDataPortMode;
  }
#line 673
  return;
}
}
#line 679 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void SavePrefs(void) 
{ 
  char pathName[256] ;
  char pathName2[256] ;
  char tName[32] ;
  int t ;
  FILE *fp ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 688
  if (gPrefsDirty == 0) {
#line 689
    return;
  }
  {
#line 691
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"prefs_v3");
#line 693
  tmp = getpid();
#line 693
  sprintf((char */* __restrict  */)(tName), (char const   */* __restrict  */)"tpref%06u.txt",
          (unsigned int )tmp);
#line 694
  OurDirectoryPath((char */* const  */)(pathName2), (size_t const   )sizeof(pathName2),
                   (char const   */* const  */)(tName));
#line 696
  fp = fopen((char const   */* __restrict  */)(pathName2), (char const   */* __restrict  */)"w");
  }
#line 697
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 698
    perror("could not save preferences file");
    }
  } else {
    {
#line 700
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", "# NcFTP 3 preferences file\n# This file is loaded and overwritten each time NcFTP is run.\n#\n");
#line 701
    t = 0;
    }
    {
#line 701
    while (1) {
      while_continue: /* CIL Label */ ;
#line 701
      if (! (t < gNumPrefOpts)) {
#line 701
        goto while_break;
      }
#line 702
      if (gPrefOpts[t].visible != -1) {
        {
#line 703
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s=",
                gPrefOpts[t].varname);
#line 704
        (*(gPrefOpts[t].proc))((char const   */* const  */)((void *)0), (FILE */* const  */)fp);
#line 705
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
        }
      }
#line 701
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 708
    fclose(fp);
#line 709
    unlink((char const   *)(pathName));
#line 710
    tmp___0 = rename((char const   *)(pathName2), (char const   *)(pathName));
    }
#line 710
    if (tmp___0 < 0) {
      {
#line 711
      perror("could not finish saving preferences file");
#line 712
      unlink((char const   *)(pathName2));
      }
    }
  }
#line 715
  return;
}
}
#line 722 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/pref.c"
void CheckForNewV3User(void) 
{ 
  FILE *fp ;
  struct stat st ;
  char pathName[256] ;
  char line[256] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 730
  gNumProgramRuns = 0;
#line 733
  if ((int )gOurDirectoryPath[0] != 0) {
    {
#line 734
    OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                     (char const   */* const  */)"init_v3");
#line 736
    tmp___1 = stat((char const   */* __restrict  */)(pathName), (struct stat */* __restrict  */)(& st));
    }
#line 736
    if (tmp___1 < 0) {
      {
#line 736
      tmp___2 = __errno_location();
      }
#line 736
      if (*tmp___2 == 2) {
        {
#line 737
        gNumProgramRuns = 1;
#line 738
        gPrefsDirty ++;
#line 741
        fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"w");
        }
#line 742
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 743
          return;
        }
        {
#line 744
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# NcFTP uses this file to mark that you have run it before, and that you do not\n# need any special first-time instructions or setup.\n#\nruns=%d\n",
                gNumProgramRuns);
#line 745
        fclose(fp);
        }
      } else {
#line 736
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 747
      fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"r");
      }
#line 748
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 749
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 749
          tmp___0 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL),
                          (FILE */* __restrict  */)fp);
          }
#line 749
          if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 749
            goto while_break;
          }
          {
#line 750
          tmp = strncmp((char const   *)(line), "runs=", (size_t )5);
          }
#line 750
          if (tmp == 0) {
            {
#line 751
            sscanf((char const   */* __restrict  */)(line + 5), (char const   */* __restrict  */)"%d",
                   & gNumProgramRuns);
            }
#line 753
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 756
        fclose(fp);
        }
      }
#line 760
      gNumProgramRuns ++;
#line 761
      if (gNumProgramRuns == 1) {
#line 762
        gPrefsDirty ++;
      }
      {
#line 769
      fp = fopen((char const   */* __restrict  */)(pathName), (char const   */* __restrict  */)"w");
      }
#line 770
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 771
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# NcFTP uses this file to mark that you have run it before, and that you do not\n# need any special first-time instructions or setup.\n#\nruns=%d\n",
                gNumProgramRuns);
#line 772
        fclose(fp);
        }
      }
    }
  }
#line 776
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/bookmark.c"
static int HexCharToNibble___1(int c ) 
{ 


  {
  {
#line 109
  if (c == 57) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 56) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 55) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 54) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 53) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 52) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 51) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 50) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 49) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 48) {
#line 109
    goto case_57;
  }
#line 116
  if (c == 102) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 101) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 100) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 99) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 98) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 97) {
#line 116
    goto case_102;
  }
#line 123
  if (c == 70) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 69) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 68) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 67) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 66) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 65) {
#line 123
    goto case_70;
  }
#line 99
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 110
  return (c - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 117
  return ((c - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 124
  return ((c - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
#line 127
  return (-1);
}
}
#line 495 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/bookmark.c"
static int BookmarkSortProc___1(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = strcasecmp((char const   *)(((Bookmark const   *)a)->bookmarkName), (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 498
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/bookmark.c"
static int BookmarkSearchProc___1(void const   *key , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = strcasecmp((char const   *)key, (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 506
  return (tmp);
}
}
#line 578 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/bookmark.c"
static char *BmEscapeTok___1(char *dst , size_t dsize , char *src ) 
{ 
  char *dlim ;
  char *dst0 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 581
  dlim = (dst + dsize) - 1;
#line 582
  dst0 = dst;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    c = (int )*src;
#line 585
    if (! (c != 0)) {
#line 585
      goto while_break;
    }
#line 586
    src ++;
#line 587
    if (c == 92) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 44) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 36) {
      _L: /* CIL Label */ 
#line 589
      if ((unsigned long )(dst + 1) < (unsigned long )dlim) {
#line 590
        tmp = dst;
#line 590
        dst ++;
#line 590
        *tmp = (char )'\\';
#line 591
        tmp___0 = dst;
#line 591
        dst ++;
#line 591
        *tmp___0 = (char )c;
      }
    } else {
      {
#line 593
      tmp___2 = __ctype_b_loc();
      }
#line 593
      if ((int const   )*(*tmp___2 + c) & 16384) {
#line 600
        if ((unsigned long )dst < (unsigned long )dlim) {
#line 601
          tmp___1 = dst;
#line 601
          dst ++;
#line 601
          *tmp___1 = (char )c;
        }
      } else
#line 595
      if ((unsigned long )(dst + 2) < (unsigned long )dlim) {
        {
#line 596
        sprintf((char */* __restrict  */)dst, (char const   */* __restrict  */)"$%02x",
                c);
#line 597
        dst += 3;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *dst = (char )'\000';
#line 605
  return (dst0);
}
}
#line 614 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/bookmark.c"
static int WriteBmLine___1(Bookmark *bmp , FILE *outfp , int savePassword ) 
{ 
  char tok[256] ;
  char pass[160] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 620
  tmp = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s",
                bmp->bookmarkName);
  }
#line 620
  if (tmp < 0) {
#line 620
    return (-1);
  }
  {
#line 621
  tmp___0 = BmEscapeTok___1(tok, sizeof(tok), bmp->name);
#line 621
  tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___0);
  }
#line 621
  if (tmp___1 < 0) {
#line 621
    return (-1);
  }
  {
#line 622
  tmp___2 = BmEscapeTok___1(tok, sizeof(tok), bmp->user);
#line 622
  tmp___3 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___2);
  }
#line 622
  if (tmp___3 < 0) {
#line 622
    return (-1);
  }
#line 623
  if ((int )bmp->pass[0] != 0) {
#line 623
    if (savePassword == 1) {
      {
#line 624
      memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
             (size_t )9);
#line 625
      tmp___4 = strlen((char const   *)(bmp->pass));
#line 625
      ToBase64((void *)(pass + 9), (void const   *)(bmp->pass), tmp___4, 1);
#line 626
      tmp___5 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                        pass);
      }
#line 626
      if (tmp___5 < 0) {
#line 626
        return (-1);
      }
    } else {
#line 623
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 628
    tmp___6 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                      "");
    }
#line 628
    if (tmp___6 < 0) {
#line 628
      return (-1);
    }
  }
  {
#line 630
  tmp___7 = BmEscapeTok___1(tok, sizeof(tok), bmp->acct);
#line 630
  tmp___8 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___7);
  }
#line 630
  if (tmp___8 < 0) {
#line 630
    return (-1);
  }
  {
#line 631
  tmp___9 = BmEscapeTok___1(tok, sizeof(tok), bmp->dir);
#line 631
  tmp___10 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___9);
  }
#line 631
  if (tmp___10 < 0) {
#line 631
    return (-1);
  }
  {
#line 632
  tmp___11 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferType);
  }
#line 632
  if (tmp___11 < 0) {
#line 632
    return (-1);
  }
  {
#line 633
  tmp___12 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%u",
                     bmp->port);
  }
#line 633
  if (tmp___12 < 0) {
#line 633
    return (-1);
  }
  {
#line 634
  tmp___13 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%lu",
                     (unsigned long )bmp->lastCall);
  }
#line 634
  if (tmp___13 < 0) {
#line 634
    return (-1);
  }
  {
#line 635
  tmp___14 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasSIZE);
  }
#line 635
  if (tmp___14 < 0) {
#line 635
    return (-1);
  }
  {
#line 636
  tmp___15 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasMDTM);
  }
#line 636
  if (tmp___15 < 0) {
#line 636
    return (-1);
  }
  {
#line 637
  tmp___16 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasPASV);
  }
#line 637
  if (tmp___16 < 0) {
#line 637
    return (-1);
  }
  {
#line 638
  tmp___17 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->isUnix);
  }
#line 638
  if (tmp___17 < 0) {
#line 638
    return (-1);
  }
  {
#line 639
  tmp___18 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     bmp->lastIP);
  }
#line 639
  if (tmp___18 < 0) {
#line 639
    return (-1);
  }
  {
#line 640
  tmp___19 = BmEscapeTok___1(tok, sizeof(tok), bmp->comment);
#line 640
  tmp___20 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___19);
  }
#line 640
  if (tmp___20 < 0) {
#line 640
    return (-1);
  }
  {
#line 641
  tmp___21 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 641
  if (tmp___21 < 0) {
#line 641
    return (-1);
  }
  {
#line 642
  tmp___22 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 642
  if (tmp___22 < 0) {
#line 642
    return (-1);
  }
  {
#line 643
  tmp___23 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 643
  if (tmp___23 < 0) {
#line 643
    return (-1);
  }
  {
#line 644
  tmp___24 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 644
  if (tmp___24 < 0) {
#line 644
    return (-1);
  }
  {
#line 645
  tmp___25 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferMode);
  }
#line 645
  if (tmp___25 < 0) {
#line 645
    return (-1);
  }
  {
#line 646
  tmp___26 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasUTIME);
  }
#line 646
  if (tmp___26 < 0) {
#line 646
    return (-1);
  }
  {
#line 647
  tmp___27 = BmEscapeTok___1(tok, sizeof(tok), bmp->ldir);
#line 647
  tmp___28 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___27);
  }
#line 647
  if (tmp___28 < 0) {
#line 647
    return (-1);
  }
  {
#line 648
  tmp___29 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n");
  }
#line 648
  if (tmp___29 < 0) {
#line 648
    return (-1);
  }
  {
#line 649
  tmp___30 = fflush(outfp);
  }
#line 649
  if (tmp___30 < 0) {
#line 649
    return (-1);
  }
#line 650
  return (0);
}
}
#line 655 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/../ncftp/bookmark.c"
static int SwapBookmarkFiles___1(void) 
{ 
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 661
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 662
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 666
  tmp = getpid();
#line 666
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 667
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 669
  remove((char const   *)(path2));
#line 670
  tmp___0 = rename((char const   *)(pathName), (char const   *)(path2));
  }
#line 670
  if (tmp___0 < 0) {
#line 671
    return (-1);
  }
#line 673
  return (0);
}
}
#line 611 "/usr/include/curses.h"
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 708
extern int nl(void) ;
#line 711
extern int noecho(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 11 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.h"
void EndWin(void) ;
#line 12
void Exit(int exitStatus ) ;
#line 17
void WAttr(WINDOW *w , int attr , int on ) ;
#line 18
void swclrtoeol(WINDOW *w ) ;
#line 19
void DrawStrAt(WINDOW * const  win , int y , int x , char const   * const  str ) ;
#line 20
void WAddCenteredStr(WINDOW * const  w , int y , char const   * const  str ) ;
#line 21
int PrintDimensions(int shortMode ) ;
#line 22
int InitWindows(void) ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
int gWinInit  =    0;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
int gScreenWidth  =    0;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
int gScreenHeight  =    0;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
void EndWin(void) 
{ 


  {
#line 24
  if (gWinInit) {
    {
#line 25
    gWinInit = 0;
#line 30
    wclear(stdscr);
#line 31
    wrefresh(stdscr);
#line 33
    endwin();
    }
  }
#line 35
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
void Exit(int exitStatus ) 
{ 


  {
  {
#line 43
  EndWin();
#line 44
  exit(exitStatus);
  }
}
}
#line 161 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
void swclrtoeol(WINDOW *w ) 
{ 
  int maxx ;
  int curx ;

  {
#line 167
  if (w) {
#line 167
    maxx = (int )w->_maxx + 1;
  } else {
#line 167
    maxx = -1;
  }
#line 168
  if (w) {
#line 168
    curx = (int )w->_curx;
  } else {
#line 168
    curx = -1;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (curx < maxx)) {
#line 169
      goto while_break;
    }
    {
#line 170
    waddch(w, (chtype const   )' ');
#line 169
    curx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
void WAttr(WINDOW *w , int attr , int on ) 
{ 


  {
#line 189
  if (attr & 4) {
#line 190
    if (on) {
      {
#line 191
      wattr_on(w, 1UL << 18, (void *)0);
      }
    } else {
      {
#line 193
      wattr_off(w, 1UL << 18, (void *)0);
      }
    }
  }
#line 208
  if (attr & 32) {
#line 209
    if (on) {
      {
#line 210
      wattr_on(w, 1UL << 21, (void *)0);
      }
    } else {
      {
#line 212
      wattr_off(w, 1UL << 21, (void *)0);
      }
    }
  }
#line 219
  if (attr & 2) {
#line 220
    if (on) {
      {
#line 221
      wattr_on(w, 1UL << 17, (void *)0);
      }
    } else {
      {
#line 223
      wattr_off(w, 1UL << 17, (void *)0);
      }
    }
  }
#line 239
  if (attr & 16) {
#line 240
    if (on) {
      {
#line 241
      wattr_on(w, 1UL << 20, (void *)0);
      }
    } else {
      {
#line 243
      wattr_off(w, 1UL << 20, (void *)0);
      }
    }
  }
#line 250
  if (attr == 0) {
#line 251
    if (w) {
#line 251
      w->_attrs = 0UL;
    }
#line 252
    return;
  }
#line 262
  return;
}
}
#line 267 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
void DrawStrAt(WINDOW * const  win , int y , int x , char const   * const  str ) 
{ 
  int tmp ;

  {
  {
#line 270
  tmp = wmove((WINDOW *)win, y, x);
  }
#line 270
  if (! (tmp == -1)) {
    {
#line 270
    waddnstr((WINDOW *)win, (char const   *)str, -1);
    }
  }
#line 281
  return;
}
}
#line 286 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
void WAddCenteredStr(WINDOW * const  w , int y , char const   * const  str ) 
{ 
  int x ;
  int maxx ;
  size_t tmp ;

  {
#line 291
  if (w) {
#line 291
    maxx = (int )w->_maxx + 1;
  } else {
#line 291
    maxx = -1;
  }
  {
#line 292
  tmp = strlen((char const   *)str);
#line 292
  x = (maxx - (int )tmp) / 2;
  }
#line 293
  if (x < 0) {
#line 294
    x = 0;
  }
  {
#line 295
  DrawStrAt(w, y, x, str);
  }
#line 296
  return;
}
}
#line 301 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
static void SigTerm(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 305
  Exit(1);
  }
#line 306
  return;
}
}
#line 331 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
int InitWindows(void) 
{ 
  int maxx ;
  int maxy ;

  {
  {
#line 334
  maxx = 0;
#line 334
  maxy = 0;
#line 336
  gWinInit = 0;
#line 337
  initscr();
  }
#line 338
  if ((unsigned long )stdscr == (unsigned long )((void *)0)) {
#line 339
    return (-1);
  }
  {
#line 340
  gWinInit = 1;
#line 341
  NcSignal(15, & SigTerm);
#line 343
  nl();
#line 344
  noecho();
  }
#line 346
  if (stdscr) {
#line 346
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 346
    maxy = -1;
  }
#line 346
  if (stdscr) {
#line 346
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 346
    maxx = -1;
  }
#line 347
  gScreenWidth = maxx;
#line 348
  gScreenHeight = maxy;
#line 359
  return (0);
}
}
#line 364 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wutil.c"
int PrintDimensions(int shortMode ) 
{ 
  int maxy ;
  int maxx ;
  char buf[128] ;
  char const   *tmp ;
  size_t tmp___0 ;

  {
  {
#line 367
  maxy = 0;
#line 367
  maxx = 0;
#line 370
  initscr();
  }
#line 371
  if ((unsigned long )stdscr == (unsigned long )((void *)0)) {
#line 372
    return (-1);
  }
#line 373
  if (stdscr) {
#line 373
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 373
    maxy = -1;
  }
#line 373
  if (stdscr) {
#line 373
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 373
    maxx = -1;
  }
  {
#line 374
  endwin();
  }
#line 375
  if (maxx > 0) {
#line 375
    if (maxy > 0) {
      {
#line 376
      memset((void *)(buf), 0, sizeof(buf));
      }
#line 378
      if (shortMode != 0) {
#line 378
        tmp = "%d %d\n";
      } else {
#line 378
        tmp = "COLUMNS=%d\nLINES=%d\nexport COLUMNS\nexport LINES\n";
      }
      {
#line 378
      snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)tmp,
               maxx, maxy);
#line 389
      tmp___0 = strlen((char const   *)(buf));
#line 389
      write(1, (void const   *)(buf), tmp___0);
      }
#line 390
      return (0);
    }
  }
#line 392
  return (-1);
}
}
#line 581 "/usr/include/curses.h"
extern int beep(void) ;
#line 587
extern int cbreak(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 648
extern char killchar(void) ;
#line 709
extern int nocbreak(void) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1384
extern WINDOW *curscr ;
#line 37 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.h"
int wg_Gets(WGetsParamPtr wgpp ) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static char *gBufPtr  ;
#line 41 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static char *gWinStartPtr  =    (char *)0;
#line 44 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static char *gWinEndPtr  =    (char *)0;
#line 47 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static size_t gBufLen  =    (size_t )0;
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gNeedUpdate  =    0;
#line 57 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static WINDOW *gW  =    (WINDOW *)0;
#line 60 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gSy  =    0;
#line 60 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gSx  =    0;
#line 63 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static char *gDst  =    (char *)0;
#line 68 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gWindowWidth  =    0;
#line 71 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static size_t gDstSize  =    (size_t )0;
#line 76 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gHadStartingString  =    0;
#line 82 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gChanged  =    0;
#line 88 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gMoved  =    0;
#line 94 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int gEchoMode  =    0;
#line 100 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static FTPLineListPtr gHistory  =    (FTPLineListPtr )0;
#line 105 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static FTPLinePtr gCurHistLine  =    (FTPLinePtr )0;
#line 107 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_SetCursorPos(char *newPos ) 
{ 


  {
#line 110
  if ((unsigned long )newPos > (unsigned long )gWinEndPtr) {
#line 114
    gWinStartPtr = newPos;
#line 115
    if (gWindowWidth > 7) {
#line 116
      gWinStartPtr -= (gWindowWidth * 2) / 10;
    } else
#line 117
    if (gWindowWidth > 1) {
#line 118
      gWinStartPtr --;
    }
#line 119
    gBufPtr = newPos;
#line 120
    gWinEndPtr = (gWinStartPtr + gWindowWidth) - 1;
  } else
#line 121
  if ((unsigned long )newPos < (unsigned long )gWinStartPtr) {
#line 125
    gWinStartPtr = newPos;
#line 126
    if (gWindowWidth > 7) {
#line 127
      gWinStartPtr -= (gWindowWidth * 2) / 10;
    } else
#line 128
    if (gWindowWidth > 1) {
#line 129
      gWinStartPtr --;
    }
#line 130
    if ((unsigned long )gWinStartPtr < (unsigned long )gDst) {
#line 131
      gWinStartPtr = gDst;
    }
#line 132
    gBufPtr = newPos;
#line 133
    gWinEndPtr = (gWinStartPtr + gWindowWidth) - 1;
  } else {
#line 136
    gBufPtr = newPos;
  }
#line 138
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_AddCh(int c ) 
{ 
  size_t n ;
  char *limit ;

  {
#line 149
  if (gBufLen < gDstSize) {
#line 150
    limit = gDst + gBufLen;
#line 151
    if ((unsigned long )gBufPtr == (unsigned long )limit) {
      {
#line 155
      *gBufPtr = (char )c;
#line 156
      gBufLen ++;
#line 157
      wg_SetCursorPos(gBufPtr + 1);
      }
    } else {
      {
#line 162
      n = (size_t )(limit - gBufPtr);
#line 163
      memmove((void *)(gBufPtr + 1), (void const   *)gBufPtr, n);
#line 164
      *gBufPtr = (char )c;
#line 165
      gBufLen ++;
#line 166
      wg_SetCursorPos(gBufPtr + 1);
      }
    }
#line 168
    gNeedUpdate = 1;
#line 169
    gChanged = 1;
  } else {
    {
#line 171
    beep();
    }
  }
#line 173
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_KillCh(int count ) 
{ 
  size_t n ;
  char *limit ;

  {
#line 184
  if ((long )count > gBufPtr - gDst) {
#line 185
    count = (int )(gBufPtr - gDst);
  }
#line 186
  if (count) {
#line 187
    limit = gDst + gBufLen;
#line 188
    if ((unsigned long )gBufPtr != (unsigned long )limit) {
      {
#line 192
      n = (size_t )(limit - gBufPtr);
#line 193
      memcpy((void */* __restrict  */)(gBufPtr - count), (void const   */* __restrict  */)gBufPtr,
             n);
      }
    }
    {
#line 195
    gBufLen -= (size_t )count;
#line 196
    wg_SetCursorPos(gBufPtr - count);
#line 197
    gNeedUpdate = 1;
#line 198
    gChanged = 1;
    }
  } else {
    {
#line 200
    beep();
    }
  }
#line 202
  return;
}
}
#line 204 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static int IsWordChar(char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 207
  tmp = __ctype_b_loc();
  }
#line 207
  if ((int const   )*(*tmp + (int )c) & 8192) {
#line 207
    tmp___0 = 0;
  } else
#line 207
  if ((int )c != 47) {
#line 207
    tmp___0 = 1;
  } else {
#line 207
    tmp___0 = 0;
  }
#line 207
  return (tmp___0);
}
}
#line 210 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_KillWord(void) 
{ 
  int count ;
  int off ;
  int tmp ;
  int tmp___0 ;

  {
#line 214
  off = (int )(gBufPtr - gDst) - 1;
#line 215
  count = off;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (off >= 0) {
      {
#line 218
      tmp = IsWordChar(*(gDst + off));
      }
#line 218
      if (tmp) {
#line 218
        goto while_break;
      }
    } else {
#line 218
      goto while_break;
    }
#line 219
    off --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (off >= 0) {
      {
#line 221
      tmp___0 = IsWordChar(*(gDst + off));
      }
#line 221
      if (! tmp___0) {
#line 221
        goto while_break___0;
      }
    } else {
#line 221
      goto while_break___0;
    }
#line 222
    off --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 223
  count -= off;
#line 224
  wg_KillCh(count);
  }
#line 225
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_ForwardKillCh(void) 
{ 
  size_t n ;
  char *limit ;

  {
#line 234
  if (gBufLen != 0UL) {
#line 235
    limit = gDst + gBufLen;
#line 236
    if ((unsigned long )gBufPtr == (unsigned long )limit) {
      {
#line 238
      beep();
      }
    } else {
      {
#line 240
      n = (size_t )((limit - gBufPtr) - 1L);
#line 241
      memcpy((void */* __restrict  */)gBufPtr, (void const   */* __restrict  */)(gBufPtr + 1),
             n);
#line 242
      gBufLen --;
#line 243
      gNeedUpdate = 1;
#line 244
      gChanged = 1;
      }
    }
  } else {
    {
#line 247
    beep();
    }
  }
#line 249
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_GoLeft(void) 
{ 


  {
#line 256
  if ((unsigned long )gBufPtr > (unsigned long )gDst) {
    {
#line 257
    wg_SetCursorPos(gBufPtr - 1);
#line 258
    gNeedUpdate = 1;
#line 259
    gMoved = 1;
    }
  } else {
    {
#line 261
    beep();
    }
  }
#line 263
  return;
}
}
#line 268 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_GoRight(void) 
{ 


  {
#line 271
  if ((unsigned long )gBufPtr < (unsigned long )(gDst + gBufLen)) {
    {
#line 272
    wg_SetCursorPos(gBufPtr + 1);
#line 273
    gNeedUpdate = 1;
#line 274
    gMoved = 1;
    }
  } else {
    {
#line 276
    beep();
    }
  }
#line 278
  return;
}
}
#line 282 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_GoLineStart(void) 
{ 


  {
  {
#line 285
  wg_SetCursorPos(gDst);
#line 286
  gNeedUpdate = 1;
#line 287
  gMoved = 1;
  }
#line 288
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_GoLineEnd(void) 
{ 


  {
  {
#line 296
  wg_SetCursorPos(gDst + gBufLen);
#line 297
  gNeedUpdate = 1;
#line 298
  gMoved = 1;
  }
#line 299
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_LineKill(void) 
{ 


  {
#line 307
  gBufPtr = gDst;
#line 308
  gWinStartPtr = gBufPtr;
#line 309
  gWinEndPtr = (gWinStartPtr + gWindowWidth) - 1;
#line 310
  *(gBufPtr + gDstSize) = (char )'\000';
#line 311
  gBufLen = (size_t )0;
#line 312
  gNeedUpdate = 1;
#line 317
  gMoved = 0;
#line 322
  gChanged = gHadStartingString;
#line 323
  return;
}
}
#line 327 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_HistoryUp(void) 
{ 


  {
#line 330
  if ((unsigned long )gHistory == (unsigned long )((FTPLineListPtr )0)) {
    {
#line 332
    beep();
    }
#line 333
    return;
  }
#line 336
  if ((unsigned long )gCurHistLine != (unsigned long )((void *)0)) {
#line 340
    gCurHistLine = gCurHistLine->prev;
  } else {
#line 343
    gCurHistLine = gHistory->last;
#line 344
    if ((unsigned long )gCurHistLine == (unsigned long )((void *)0)) {
      {
#line 346
      beep();
      }
#line 347
      return;
    }
  }
  {
#line 351
  wg_LineKill();
  }
#line 352
  if ((unsigned long )gCurHistLine != (unsigned long )((void *)0)) {
    {
#line 353
    Strncpy((char */* const  */)gDst, (char const   */* const  */)gCurHistLine->line,
            (size_t const   )gDstSize);
#line 354
    gBufLen = strlen((char const   *)gDst);
#line 355
    wg_GoLineEnd();
    }
  }
#line 361
  return;
}
}
#line 365 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_HistoryDown(void) 
{ 


  {
#line 368
  if ((unsigned long )gHistory == (unsigned long )((FTPLineListPtr )0)) {
    {
#line 370
    beep();
    }
#line 371
    return;
  }
#line 374
  if ((unsigned long )gCurHistLine != (unsigned long )((void *)0)) {
#line 378
    gCurHistLine = gCurHistLine->next;
  } else {
#line 383
    gCurHistLine = gHistory->first;
#line 384
    if ((unsigned long )gCurHistLine == (unsigned long )((void *)0)) {
      {
#line 386
      beep();
      }
#line 387
      return;
    }
  }
  {
#line 391
  wg_LineKill();
  }
#line 392
  if ((unsigned long )gCurHistLine != (unsigned long )((void *)0)) {
    {
#line 393
    Strncpy((char */* const  */)gDst, (char const   */* const  */)gCurHistLine->line,
            (size_t const   )gDstSize);
#line 394
    gBufLen = strlen((char const   *)gDst);
#line 395
    wg_GoLineEnd();
    }
  }
#line 400
  return;
}
}
#line 405 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
static void wg_Update(void) 
{ 
  char *lastCharPtr ;
  char *cp ;

  {
  {
#line 411
  wmove(gW, gSy, gSx);
#line 412
  lastCharPtr = gDst + gBufLen;
#line 413
  *lastCharPtr = (char )'\000';
  }
#line 414
  if (gEchoMode == 0) {
#line 415
    cp = gWinStartPtr;
    {
#line 415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 415
      if (! ((unsigned long )cp < (unsigned long )lastCharPtr)) {
#line 415
        goto while_break;
      }
#line 416
      if ((unsigned long )cp > (unsigned long )gWinEndPtr) {
#line 417
        goto xx;
      }
      {
#line 418
      waddch(gW, (chtype const   )((unsigned char )*cp));
#line 415
      cp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 420
  if (gEchoMode == 1) {
#line 421
    cp = gWinStartPtr;
    {
#line 421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 421
      if (! ((unsigned long )cp < (unsigned long )lastCharPtr)) {
#line 421
        goto while_break___0;
      }
#line 422
      if ((unsigned long )cp > (unsigned long )gWinEndPtr) {
#line 423
        goto xx;
      }
      {
#line 424
      waddch(gW, (chtype const   )'.');
#line 421
      cp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 427
    cp = gWinStartPtr;
    {
#line 427
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 427
      if (! ((unsigned long )cp < (unsigned long )lastCharPtr)) {
#line 427
        goto while_break___1;
      }
#line 428
      if ((unsigned long )cp > (unsigned long )gWinEndPtr) {
#line 429
        goto xx;
      }
      {
#line 430
      waddch(gW, (chtype const   )' ');
#line 427
      cp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 435
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 435
    if (! ((unsigned long )cp <= (unsigned long )gWinEndPtr)) {
#line 435
      goto while_break___2;
    }
    {
#line 436
    waddch(gW, (chtype const   )' ');
#line 435
    cp ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  xx: 
  {
#line 438
  wmove(gW, gSy, gSx + (int )(gBufPtr - gWinStartPtr));
#line 439
  wrefresh(gW);
#line 440
  gNeedUpdate = 0;
  }
#line 441
  return;
}
}
#line 446 "/home/wheatley/newnew/temp/ncftp-3.2.5/vis/wgets.c"
int wg_Gets(WGetsParamPtr wgpp ) 
{ 
  int c ;
  int result ;
  int lineKill ;
  int maxx ;
  int maxy ;
  char tmp ;
  int tmp___0 ;

  {
#line 457
  if ((unsigned long )wgpp == (unsigned long )((void *)0)) {
#line 458
    return (-2);
  }
#line 460
  if (wgpp->dstSize < 2UL) {
#line 461
    return (-3);
  }
#line 462
  gDstSize = wgpp->dstSize - 1UL;
#line 464
  if (wgpp->fieldLen < 1) {
#line 465
    return (-4);
  }
#line 466
  gWindowWidth = wgpp->fieldLen;
#line 468
  if ((unsigned long )wgpp->w == (unsigned long )((void *)0)) {
#line 469
    return (-5);
  }
#line 470
  gW = wgpp->w;
#line 472
  if (gW) {
#line 472
    maxy = (int )gW->_maxy + 1;
  } else {
#line 472
    maxy = -1;
  }
#line 472
  if (gW) {
#line 472
    maxx = (int )gW->_maxx + 1;
  } else {
#line 472
    maxx = -1;
  }
#line 473
  if (wgpp->sy < 0) {
#line 474
    return (-6);
  } else
#line 473
  if (wgpp->sy > maxy) {
#line 474
    return (-6);
  }
#line 475
  gSy = wgpp->sy;
#line 477
  if (wgpp->sx < 0) {
#line 478
    return (-6);
  } else
#line 477
  if (wgpp->sx > maxx) {
#line 478
    return (-6);
  }
#line 479
  gSx = wgpp->sx;
#line 481
  if ((unsigned long )wgpp->dst == (unsigned long )((void *)0)) {
#line 482
    return (-7);
  }
  {
#line 483
  gDst = wgpp->dst;
#line 485
  gHistory = wgpp->history;
#line 486
  gCurHistLine = (FTPLinePtr )((void *)0);
#line 488
  gEchoMode = wgpp->echoMode;
#line 489
  gChanged = 0;
#line 490
  gMoved = 0;
#line 492
  result = 0;
#line 493
  wmove(gW, gSy, gSx);
#line 494
  wrefresh(gW);
#line 503
  cbreak();
#line 506
  nodelay(gW, (_Bool)0);
#line 507
  keypad(gW, (_Bool)1);
#line 512
  tmp = killchar();
#line 512
  lineKill = (int )tmp;
#line 514
  gNeedUpdate = 1;
#line 515
  gBufPtr = gDst;
#line 516
  gWinStartPtr = gBufPtr;
#line 517
  gWinEndPtr = (gWinStartPtr + gWindowWidth) - 1;
#line 518
  *(gBufPtr + gDstSize) = (char )'\000';
#line 519
  gHadStartingString = 0;
  }
#line 520
  if (wgpp->useCurrentContents) {
    {
#line 521
    gBufLen = strlen((char const   *)gBufPtr);
    }
#line 522
    if (gBufLen != 0UL) {
#line 523
      gHadStartingString = 1;
    }
  } else {
#line 525
    gBufLen = (size_t )0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (gNeedUpdate) {
      {
#line 530
      wg_Update();
      }
    }
    {
#line 532
    c = wgetch(gW);
    }
    {
#line 549
    if (c == 343) {
#line 549
      goto case_343;
    }
#line 549
    if (c == 10) {
#line 549
      goto case_343;
    }
#line 549
    if (c == 13) {
#line 549
      goto case_343;
    }
#line 557
    if (c == 127) {
#line 557
      goto case_127;
    }
#line 557
    if (c == 263) {
#line 557
      goto case_127;
    }
#line 557
    if (c == 8) {
#line 557
      goto case_127;
    }
#line 576
    if (c == 4) {
#line 576
      goto case_4;
    }
#line 576
    if (c == 355) {
#line 576
      goto case_4;
    }
#line 576
    if (c == 356) {
#line 576
      goto case_4;
    }
#line 576
    if (c == 361) {
#line 576
      goto case_4;
    }
#line 595
    if (c == 330) {
#line 595
      goto case_330;
    }
#line 611
    if (c == 12) {
#line 611
      goto case_12;
    }
#line 611
    if (c == 333) {
#line 611
      goto case_12;
    }
#line 619
    if (c == 2) {
#line 619
      goto case_2;
    }
#line 619
    if (c == 260) {
#line 619
      goto case_2;
    }
#line 626
    if (c == 6) {
#line 626
      goto case_6;
    }
#line 626
    if (c == 261) {
#line 626
      goto case_6;
    }
#line 633
    if (c == 16) {
#line 633
      goto case_16;
    }
#line 633
    if (c == 259) {
#line 633
      goto case_16;
    }
#line 640
    if (c == 14) {
#line 640
      goto case_14;
    }
#line 640
    if (c == 258) {
#line 640
      goto case_14;
    }
#line 647
    if (c == 1) {
#line 647
      goto case_1;
    }
#line 647
    if (c == 262) {
#line 647
      goto case_1;
    }
#line 653
    if (c == 5) {
#line 653
      goto case_5;
    }
#line 653
    if (c == 360) {
#line 653
      goto case_5;
    }
#line 659
    if (c == 11) {
#line 659
      goto case_11;
    }
#line 659
    if (c == 335) {
#line 659
      goto case_11;
    }
#line 664
    if (c == -1) {
#line 664
      goto case_neg_1;
    }
#line 670
    if (c == 23) {
#line 670
      goto case_23;
    }
#line 674
    if (c == 9) {
#line 674
      goto case_9;
    }
#line 694
    goto switch_default;
    case_343: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 551
    goto done;
    case_127: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 558
    wg_KillCh(1);
    }
#line 559
    goto switch_break;
    case_4: /* CIL Label */ 
    case_355: /* CIL Label */ 
    case_356: /* CIL Label */ 
    case_361: /* CIL Label */ 
#line 580
    if (! gChanged) {
#line 580
      if (! gMoved) {
#line 581
        result = -1;
#line 582
        goto done;
      }
    }
#line 584
    if (! ((unsigned long )gBufPtr == (unsigned long )(gDst + gBufLen))) {
      {
#line 591
      wg_ForwardKillCh();
      }
    }
#line 593
    goto switch_break;
    case_330: /* CIL Label */ 
#line 597
    if (! ((unsigned long )gBufPtr == (unsigned long )(gDst + gBufLen))) {
      {
#line 604
      wg_ForwardKillCh();
      }
    }
#line 606
    goto switch_break;
    case_12: /* CIL Label */ 
    case_333: /* CIL Label */ 
#line 612
    if (curscr) {
#line 612
      tmp___0 = (int )curscr->_maxy + 1;
    } else {
#line 612
      tmp___0 = -1;
    }
    {
#line 612
    wtouchln(curscr, 0, tmp___0, 1);
#line 613
    wrefresh(curscr);
    }
#line 614
    goto switch_break;
    case_2: /* CIL Label */ 
    case_260: /* CIL Label */ 
    {
#line 620
    wg_GoLeft();
    }
#line 621
    goto switch_break;
    case_6: /* CIL Label */ 
    case_261: /* CIL Label */ 
    {
#line 627
    wg_GoRight();
    }
#line 628
    goto switch_break;
    case_16: /* CIL Label */ 
    case_259: /* CIL Label */ 
    {
#line 634
    wg_HistoryUp();
    }
#line 635
    goto switch_break;
    case_14: /* CIL Label */ 
    case_258: /* CIL Label */ 
    {
#line 641
    wg_HistoryDown();
    }
#line 642
    goto switch_break;
    case_1: /* CIL Label */ 
    case_262: /* CIL Label */ 
    {
#line 648
    wg_GoLineStart();
    }
#line 649
    goto switch_break;
    case_5: /* CIL Label */ 
    case_360: /* CIL Label */ 
    {
#line 654
    wg_GoLineEnd();
    }
#line 655
    goto switch_break;
    case_11: /* CIL Label */ 
    case_335: /* CIL Label */ 
    {
#line 660
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 660
      if (gBufLen != 0UL) {
#line 660
        if (! ((unsigned long )gBufPtr < (unsigned long )(gDst + gBufLen))) {
#line 660
          goto while_break___0;
        }
      } else {
#line 660
        goto while_break___0;
      }
      {
#line 661
      wg_ForwardKillCh();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 662
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 668
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 671
    wg_KillWord();
    }
#line 672
    goto switch_break;
    case_9: /* CIL Label */ 
#line 691
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 695
    if (c < 256) {
#line 696
      if (c == lineKill) {
        {
#line 697
        wg_LineKill();
        }
      } else {
        {
#line 699
        wg_AddCh(c);
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 705
  nocbreak();
#line 707
  *(gDst + gBufLen) = (char )'\000';
#line 708
  wgpp->changed = gChanged;
#line 709
  wgpp->dstLen = (int )gBufLen;
  }
#line 710
  if ((unsigned long )gHistory != (unsigned long )((FTPLineListPtr )0)) {
#line 710
    if (gBufLen != 0UL) {
      {
#line 711
      AddLine(wgpp->history, (char const   *)gDst);
      }
    }
  }
#line 719
  return (result);
}
}
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/usio.h"
int UAccept(int sfd , struct sockaddr_un * const  addr , int *ualen , int tlen ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UAccept.c"
int UAccept(int sfd , struct sockaddr_un * const  addr , int *ualen , int tlen ) 
{ 
  int result ;
  fd_set ss ;
  struct timeval tv ;
  socklen_t ualen2 ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0 ;
  int __d1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 15
  sigpipe = (void (*)(int  ))0;
#line 17
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  }
#line 22
  if (sio_sigpipe_ignored_already) {
#line 22
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 22
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 22
    sigpipe = tmp___0;
    }
  }
#line 24
  if (tlen <= 0) {
    {
#line 25
    tmp___1 = __errno_location();
#line 25
    *tmp___1 = 0;
    }
    {
#line 26
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 27
      ualen2 = (socklen_t )sizeof(struct sockaddr_un );
#line 28
      result = accept(sfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)addr),
                      (socklen_t */* __restrict  */)(& ualen2));
      }
#line 29
      if ((unsigned long )ualen != (unsigned long )((void *)0)) {
#line 30
        *ualen = (int )ualen2;
      }
#line 31
      if (result >= 0) {
#line 31
        goto _L;
      } else {
        {
#line 31
        tmp___2 = __errno_location();
        }
#line 31
        if (*tmp___2 != 4) {
          _L: /* CIL Label */ 
#line 32
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 32
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 32
              signal(13, sigpipe);
              }
            }
          }
#line 33
          return (result);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 38
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 39
    tmp___3 = __errno_location();
#line 39
    *tmp___3 = 0;
    }
    {
#line 40
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 40
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 40
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 45
    ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 49
    tv.tv_sec = (__time_t )((long long )tlen);
#line 50
    tv.tv_usec = (__suseconds_t )0;
#line 51
    result = select(sfd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 52
    if (result >= 1) {
#line 54
      goto while_break___0;
    } else
#line 55
    if (result == 0) {
      {
#line 57
      tmp___4 = __errno_location();
#line 57
      *tmp___4 = 110;
      }
#line 58
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 58
        if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
          {
#line 58
          signal(13, sigpipe);
          }
        }
      }
#line 59
      return (-2);
    } else {
      {
#line 60
      tmp___5 = __errno_location();
      }
#line 60
      if (*tmp___5 != 4) {
#line 61
        if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 61
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
            {
#line 61
            signal(13, sigpipe);
            }
          }
        }
#line 62
        return (-1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 67
    ualen2 = (socklen_t )sizeof(struct sockaddr_un );
#line 68
    result = accept(sfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)addr),
                    (socklen_t */* __restrict  */)(& ualen2));
    }
#line 69
    if ((unsigned long )ualen != (unsigned long )((void *)0)) {
#line 70
      *ualen = (int )ualen2;
    }
#line 66
    if (result < 0) {
      {
#line 66
      tmp___6 = __errno_location();
      }
#line 66
      if (! (*tmp___6 == 4)) {
#line 66
        goto while_break___2;
      }
    } else {
#line 66
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 73
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 73
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 73
      signal(13, sigpipe);
      }
    }
  }
#line 74
  return (result);
}
}
#line 214 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SConnectByName(int sfd , char const   * const  addrStr , int const   tlen ) ;
#line 283
int AddrStrToAddr(char const   * const  s , struct sockaddr_in * const  sa , int const   defaultport ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SConnectByName.c"
int SConnectByName(int sfd , char const   * const  addrStr , int const   tlen ) 
{ 
  int result ;
  struct sockaddr_in remoteAddr ;
  int *tmp ;

  {
#line 12
  if ((unsigned long )addrStr == (unsigned long )((void *)0)) {
    {
#line 13
    tmp = __errno_location();
#line 13
    *tmp = 22;
    }
#line 14
    return (-1);
  }
  {
#line 17
  result = AddrStrToAddr(addrStr, (struct sockaddr_in */* const  */)(& remoteAddr),
                         (int const   )-1);
  }
#line 17
  if (result == 0) {
    {
#line 18
    result = SConnect(sfd, (struct sockaddr_in  const  */* const  */)(& remoteAddr),
                      (int )tlen);
    }
  }
#line 20
  return (result);
}
}
#line 902 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPListToMemory(FTPCIPtr const   cip , char const   * const  pattern , FTPLineListPtr const   llines ,
                    char const   * const  lsflags ) ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_listmem.c"
int FTPListToMemory2(FTPCIPtr const   cip , char const   * const  pattern , FTPLineListPtr const   llines ,
                     char const   * const  lsflags , int const   blankLines , int * const  tryMLSD ) 
{ 
  char secondaryBuf[768] ;
  char line[512] ;
  char lsflags1[128] ;
  char const   *command ;
  char const   *pattern1 ;
  char const   *scp ;
  char *dcp ;
  char *lim ;
  ResponsePtr rp ;
  MLstItem mlsInfo ;
  SReadlineInfo lsSrl ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;

  {
#line 40
  command = "NLST";
#line 58
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 59
    return (-139);
  }
  {
#line 60
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 60
  if (tmp) {
#line 61
    return (-138);
  }
#line 63
  if ((unsigned long )llines == (unsigned long )((void *)0)) {
#line 64
    return (-139);
  } else
#line 63
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
#line 64
    return (-139);
  } else
#line 63
  if ((unsigned long )lsflags == (unsigned long )((void *)0)) {
#line 64
    return (-139);
  }
  {
#line 66
  pattern1 = (char const   *)pattern;
#line 67
  tmp___0 = strcmp((char const   *)pattern, ".");
  }
#line 67
  if (tmp___0 == 0) {
#line 68
    pattern1 = "";
  }
#line 70
  if ((unsigned long )tryMLSD != (unsigned long )((int *)0)) {
#line 70
    if (*tryMLSD != 0) {
#line 70
      if (cip->hasMLSD == 1) {
#line 71
        command = "MLSD";
#line 72
        if ((int const   )*(lsflags + 0) == 45) {
          {
#line 72
          tmp___3 = strchr((char const   *)lsflags, 'd');
          }
#line 72
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 72
            if (cip->hasMLST == 1) {
#line 81
              if (cip->hasMLST == 0) {
#line 86
                cip->errNo = -182;
#line 87
                return (cip->errNo);
              } else
#line 81
              if (cip->serverType == 2) {
#line 81
                if (cip->ietfCompatLevel < 19981201) {
#line 86
                  cip->errNo = -182;
#line 87
                  return (cip->errNo);
                } else {
#line 81
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 81
              if (cip->serverType == 10) {
#line 86
                cip->errNo = -182;
#line 87
                return (cip->errNo);
              }
              {
#line 90
              rp = InitResponse();
              }
#line 91
              if ((unsigned long )rp == (unsigned long )((void *)0)) {
                {
#line 92
                tmp___1 = -123;
#line 92
                cip->errNo = tmp___1;
#line 92
                result = tmp___1;
#line 93
                FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
                }
              } else {
                {
#line 95
                FTPRequestMlsOptions(cip);
                }
#line 96
                if ((int const   )*(pattern1 + 0) == 0) {
#line 97
                  pattern1 = ".";
                }
                {
#line 98
                result = RCmd(cip, rp, "MLST %s", pattern1);
                }
#line 99
                if (result == 2) {
#line 99
                  if ((unsigned long )(rp->msg.first)->line != (unsigned long )((void *)0)) {
#line 99
                    if ((unsigned long )(rp->msg.first)->next != (unsigned long )((void *)0)) {
#line 99
                      if ((unsigned long )((rp->msg.first)->next)->line != (unsigned long )((void *)0)) {
                        {
#line 109
                        result = UnMlsT(cip, (char const   */* const  */)((rp->msg.first)->next)->line,
                                        (MLstItemPtr const   )(& mlsInfo));
                        }
#line 110
                        if (result < 0) {
#line 111
                          result = -181;
#line 111
                          cip->errNo = result;
                        } else {
                          {
#line 113
                          tmp___2 = CopyLineList((FTPLineListPtr )llines, & rp->msg);
                          }
#line 113
                          if (tmp___2 < 0) {
                            {
#line 114
                            result = -123;
#line 114
                            cip->errNo = result;
#line 115
                            FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
                            }
                          }
#line 118
                          if (llines->nLines == 3) {
                            {
#line 119
                            RemoveLine((FTPLineListPtr )llines, llines->first);
#line 120
                            RemoveLine((FTPLineListPtr )llines, llines->last);
                            }
                          }
                        }
                      } else {
#line 99
                        goto _L___2;
                      }
                    } else {
#line 99
                      goto _L___2;
                    }
                  } else {
#line 99
                    goto _L___2;
                  }
                } else
                _L___2: /* CIL Label */ 
#line 123
                if (rp->code == 500) {
#line 124
                  cip->hasMLST = 0;
#line 125
                  cip->errNo = -182;
#line 126
                  result = -182;
                } else
#line 123
                if (rp->code == 502) {
#line 124
                  cip->hasMLST = 0;
#line 125
                  cip->errNo = -182;
#line 126
                  result = -182;
                } else
#line 123
                if (rp->code == 504) {
#line 124
                  cip->hasMLST = 0;
#line 125
                  cip->errNo = -182;
#line 126
                  result = -182;
                } else {
#line 128
                  cip->errNo = -180;
#line 129
                  result = -180;
                }
                {
#line 131
                DoneWithResponse(cip, rp);
                }
              }
#line 133
              return (result);
            }
          }
        }
        {
#line 135
        lsflags1[0] = (char )'\000';
#line 136
        FTPRequestMlsOptions(cip);
        }
      } else {
#line 70
        goto _L___5;
      }
    } else {
#line 70
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 139
    if ((unsigned long )tryMLSD != (unsigned long )((int *)0)) {
#line 140
      *tryMLSD = 0;
    }
#line 141
    if ((int const   )*(lsflags + 0) == 45) {
      {
#line 143
      tmp___7 = strstr((char const   *)lsflags, "--");
      }
#line 143
      if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
        {
#line 149
        command = "LIST";
#line 150
        Strncpy((char */* const  */)(lsflags1), lsflags, (size_t const   )sizeof(lsflags1));
        }
      } else {
#line 152
        scp = (char const   *)(lsflags + 1);
#line 153
        dcp = lsflags1;
#line 154
        lim = (dcp + sizeof(lsflags1)) - 2;
        {
#line 155
        while (1) {
          while_continue: /* CIL Label */ ;
#line 155
          if (! ((int const   )*scp != 0)) {
#line 155
            goto while_break;
          }
          {
#line 156
          tmp___4 = __ctype_b_loc();
          }
#line 156
          if ((int const   )*(*tmp___4 + (int )*scp) & 8192) {
#line 157
            goto __Cont;
          }
#line 158
          if ((int const   )*scp == 45) {
#line 159
            goto __Cont;
          }
#line 160
          if ((int const   )*scp == 108) {
#line 162
            command = "LIST";
          } else
#line 163
          if ((int const   )*scp == 97) {
#line 163
            if (cip->hasNLST_a == 0) {
#line 164
              goto __Cont;
            } else {
#line 163
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 165
          if ((unsigned long )dcp < (unsigned long )lim) {
#line 166
            if ((unsigned long )dcp == (unsigned long )(lsflags1)) {
#line 167
              tmp___5 = dcp;
#line 167
              dcp ++;
#line 167
              *tmp___5 = (char )'-';
            }
#line 168
            tmp___6 = dcp;
#line 168
            dcp ++;
#line 168
            *tmp___6 = (char )*scp;
          }
          __Cont: /* CIL Label */ 
#line 155
          scp ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 171
        *dcp = (char )'\000';
      }
    } else {
      {
#line 174
      Strncpy((char */* const  */)(lsflags1), lsflags, (size_t const   )sizeof(lsflags1));
      }
    }
  }
  {
#line 178
  InitLineList((FTPLineListPtr )llines);
  }
#line 180
  if ((int const   )*(pattern1 + 0) == 0) {
#line 180
    tmp___8 = "";
  } else {
#line 180
    tmp___8 = " ";
  }
#line 180
  if ((int )lsflags1[0] == 0) {
#line 180
    tmp___9 = "";
  } else {
#line 180
    tmp___9 = " ";
  }
  {
#line 180
  result = FTPStartDataCmd(cip, (int const   )65, (int const   )'A', (long long const   )0LL,
                           (char const   */* const  */)"%s%s%s%s%s", command, tmp___9,
                           lsflags1, tmp___8, pattern1);
  }
#line 195
  if (result == 0) {
    {
#line 196
    tmp___10 = InitSReadlineInfo(& lsSrl, cip->dataSocket, secondaryBuf, sizeof(secondaryBuf),
                                 (int )cip->xferTimeout, 1);
    }
#line 196
    if (tmp___10 < 0) {
      {
#line 198
      result = -108;
#line 199
      cip->errNo = -108;
#line 200
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not fdopen.\n");
      }
#line 201
      return (result);
    }
    {
#line 204
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 205
      result = SReadline(& lsSrl, (char */* const  */)(line), sizeof(line) - 1UL);
      }
#line 206
      if (result == -2) {
        {
#line 208
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not directory listing data -- timed out.\n");
#line 209
        cip->errNo = -194;
        }
#line 210
        return (cip->errNo);
      } else
#line 211
      if (result == 0) {
#line 213
        (cip->numListings) ++;
#line 214
        goto while_break___0;
      } else
#line 215
      if (result < 0) {
        {
#line 217
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not read directory listing data");
#line 218
        result = -130;
#line 219
        cip->errNo = -130;
        }
#line 220
        goto while_break___0;
      }
#line 223
      if ((int )line[result - 1] == 10) {
#line 224
        line[result - 1] = (char )'\000';
      }
#line 226
      if (blankLines == 0) {
#line 226
        if (result <= 1) {
#line 227
          goto __Cont___0;
        }
      }
#line 231
      if ((int )line[0] == 46) {
#line 231
        if ((int )line[1] == 0) {
#line 232
          goto __Cont___0;
        } else {
          {
#line 231
          tmp___11 = __ctype_b_loc();
          }
#line 231
          if ((int const   )*(*tmp___11 + (int )line[1]) & 2) {
            {
#line 231
            tmp___12 = __ctype_b_loc();
            }
#line 231
            if ((int const   )*(*tmp___12 + (int )line[1]) & 8192) {
#line 231
              goto _L___6;
            } else {
#line 232
              goto __Cont___0;
            }
          } else
          _L___6: /* CIL Label */ 
#line 231
          if ((int )line[1] == 46) {
#line 231
            if ((int )line[2] == 0) {
#line 232
              goto __Cont___0;
            } else {
              {
#line 231
              tmp___13 = __ctype_b_loc();
              }
#line 231
              if ((int const   )*(*tmp___13 + (int )line[2]) & 2) {
                {
#line 231
                tmp___14 = __ctype_b_loc();
                }
#line 231
                if (! ((int const   )*(*tmp___14 + (int )line[2]) & 8192)) {
#line 232
                  goto __Cont___0;
                }
              }
            }
          }
        }
      }
      {
#line 234
      AddLine((FTPLineListPtr )llines, (char const   *)(line));
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 237
    DisposeSReadlineInfo(& lsSrl);
#line 238
    tmp___15 = FTPEndDataCmd(cip, 1);
    }
#line 238
    if (tmp___15 < 0) {
#line 239
      result = -130;
#line 240
      cip->errNo = -130;
    }
  } else
#line 242
  if (result == -1) {
#line 243
    result = -130;
#line 244
    cip->errNo = -130;
  }
#line 312
  return (result);
}
}
#line 317 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_listmem.c"
int FTPListToMemory(FTPCIPtr const   cip , char const   * const  pattern , FTPLineListPtr const   llines ,
                    char const   * const  lsflags ) 
{ 
  int tmp ;

  {
  {
#line 320
  tmp = FTPListToMemory2(cip, pattern, llines, lsflags, (int const   )1, (int */* const  */)((int *)0));
  }
#line 320
  return (tmp);
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/USendto.c"
int USendto(int sfd , char const   * const  buf , size_t size , int fl , struct sockaddr_un  const  * const  toAddr ,
            int ualen , int tlen ) 
{ 
  ssize_t nwrote ;
  int tleft ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __sighandler_t tmp___4 ;
  int *tmp___5 ;

  {
#line 17
  sigpipe = (void (*)(int  ))0;
#line 19
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (size == 0UL) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if ((unsigned long )toAddr == (unsigned long )((void *)0)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (tlen <= 0) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  }
  {
#line 24
  time(& now);
#line 25
  done = now + (time_t )tlen;
#line 26
  nwrote = (ssize_t )0;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 28
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 29
      if (now >= done) {
        {
#line 30
        tmp___0 = __errno_location();
#line 30
        *tmp___0 = 110;
        }
#line 32
        return (-2);
      }
#line 34
      if (done > now) {
#line 34
        tleft = (int )(done - now);
      } else {
#line 34
        tleft = 0;
      }
      {
#line 35
      tmp___1 = __errno_location();
#line 35
      *tmp___1 = 0;
      }
      {
#line 36
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 36
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 36
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 41
      ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 45
      tv.tv_sec = (__time_t )((long long )tleft);
#line 46
      tv.tv_usec = (__suseconds_t )0;
#line 47
      result = select(sfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 48
      if (result >= 1) {
#line 50
        goto while_break___0;
      } else
#line 51
      if (result == 0) {
        {
#line 53
        tmp___2 = __errno_location();
#line 53
        *tmp___2 = 110;
        }
#line 55
        return (-2);
      } else {
        {
#line 56
        tmp___3 = __errno_location();
        }
#line 56
        if (*tmp___3 != 4) {
#line 57
          return (-1);
        }
      }
      {
#line 59
      time(& now);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 62
    if (sio_sigpipe_ignored_already) {
#line 62
      sigpipe = (void (*)(int  ))0;
    } else {
      {
#line 62
      tmp___4 = signal(13, (void (*)(int  ))1);
#line 62
      sigpipe = tmp___4;
      }
    }
    {
#line 63
    nwrote = sendto(sfd, (void const   *)buf, size, fl, (struct sockaddr  const  *)toAddr,
                    (socklen_t )ualen);
    }
#line 66
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 66
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
        {
#line 66
        signal(13, sigpipe);
        }
      }
    }
#line 68
    if (nwrote >= 0L) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp___5 = __errno_location();
    }
#line 70
    if (*tmp___5 != 4) {
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return ((int )nwrote);
}
}
#line 174 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
static int FtwTraverse___0(FtwInfoPtr const   ftwip , size_t dirPathLen , int depth ) 
{ 
  DIR *DIRp ;
  char *cp ;
  size_t fnLen ;
  struct dirent *dentp ;
  mode_t m ;
  char *filename ;
  char *newBuf ;
  char *path ;
  int nSubdirs ;
  FtwSubDirListPtr head ;
  FtwSubDirListPtr tail ;
  FtwSubDirListPtr sdp ;
  FtwSubDirListPtr nextsdp ;
  int rc ;
  int isRootDir ;
  char const   *tmp ;
  char *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 184
  path = ftwip->curPath;
#line 186
  head = (FtwSubDirListPtr )((void *)0);
#line 186
  tail = (FtwSubDirListPtr )((void *)0);
#line 187
  rc = -1;
#line 190
  if (dirPathLen == 1UL) {
#line 190
    if ((int )*(path + 0) == 47) {
#line 190
      isRootDir = 1;
    } else {
#line 190
      isRootDir = 0;
    }
  } else {
#line 190
    isRootDir = 0;
  }
#line 191
  if (dirPathLen) {
#line 191
    tmp = (char const   *)path;
  } else {
#line 191
    tmp = ".";
  }
  {
#line 191
  DIRp = opendir(tmp);
  }
#line 191
  if ((unsigned long )DIRp == (unsigned long )((void *)0)) {
#line 193
    return (0);
  }
#line 196
  nSubdirs = 0;
#line 197
  (ftwip->numDirs) ++;
#line 198
  ftwip->depth = (size_t )depth;
#line 199
  if (ftwip->maxDepth < ftwip->depth) {
#line 200
    ftwip->maxDepth = ftwip->depth;
  }
#line 202
  filename = path + dirPathLen;
#line 203
  if (isRootDir == 0) {
#line 204
    tmp___0 = filename;
#line 204
    filename ++;
#line 204
    *tmp___0 = (char )ftwip->dirSeparator;
#line 205
    dirPathLen ++;
  }
#line 207
  *filename = (char )'\000';
#line 210
  dentp = (struct dirent *)ftwip->direntbuf;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    tmp___1 = Readdir((DIR */* const  */)DIRp, (struct dirent */* const  */)dentp,
                      (size_t const   )ftwip->direntbufSize);
    }
#line 212
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 213
      goto while_break;
    }
#line 214
    cp = dentp->d_name;
#line 215
    if ((int )*(cp + 0) == 46) {
#line 215
      if ((int )*(cp + 1) == 0) {
#line 216
        goto __Cont;
      } else
#line 215
      if ((int )*(cp + 1) == 46) {
#line 215
        if ((int )*(cp + 2) == 0) {
#line 216
          goto __Cont;
        }
      }
    }
    {
#line 218
    *filename = (char )'\000';
#line 219
    tmp___2 = strlen((char const   *)cp);
#line 219
    fnLen = tmp___2 + 1UL;
    }
#line 220
    if (fnLen + dirPathLen > ftwip->curPathAllocSize) {
#line 221
      if (ftwip->autoGrow == 0) {
#line 222
        goto panic;
      } else
#line 223
      if (ftwip->autoGrow == -1) {
#line 224
        goto __Cont;
      }
      {
#line 226
      tmp___3 = realloc((void *)ftwip->curPath, ((fnLen + dirPathLen) + 30UL) + 2UL);
#line 226
      newBuf = (char *)tmp___3;
      }
#line 227
      if ((unsigned long )newBuf == (unsigned long )((void *)0)) {
#line 228
        goto panic;
      }
#line 229
      ftwip->curPath = newBuf;
#line 230
      ftwip->curPathAllocSize = (fnLen + dirPathLen) + 30UL;
#line 231
      path = ftwip->curPath;
#line 232
      filename = path + dirPathLen;
#line 233
      if (isRootDir == 0) {
#line 234
        tmp___4 = filename;
#line 234
        filename ++;
#line 234
        *tmp___4 = (char )ftwip->dirSeparator;
      }
#line 235
      *filename = (char )'\000';
    }
    {
#line 237
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)cp,
           fnLen);
#line 238
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 239
    ftwip->curFile = filename;
#line 240
    ftwip->curFileLen = fnLen - 1UL;
#line 241
    tmp___8 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& ftwip->curStat));
    }
#line 241
    if (tmp___8 == 0) {
#line 242
      m = ftwip->curStat.st_mode;
#line 243
      if ((m & 61440U) == 32768U) {
        {
#line 244
        (ftwip->numFiles) ++;
#line 245
        ftwip->curType = '-';
#line 246
        tmp___5 = (*(ftwip->proc))(ftwip);
        }
#line 246
        if (tmp___5 < 0) {
#line 247
          goto panic;
        }
      } else
#line 250
      if ((m & 61440U) == 40960U) {
        {
#line 251
        ftwip->curType = 'l';
#line 252
        (ftwip->numLinks) ++;
#line 253
        tmp___6 = (*(ftwip->proc))(ftwip);
        }
#line 253
        if (tmp___6 < 0) {
#line 254
          goto panic;
        }
      } else
#line 257
      if ((m & 61440U) == 16384U) {
        {
#line 264
        tmp___7 = malloc(sizeof(FtwSubDirList ) + fnLen);
#line 264
        sdp = (FtwSubDirListPtr )tmp___7;
        }
#line 265
        if ((unsigned long )sdp == (unsigned long )((void *)0)) {
#line 266
          goto panic;
        }
        {
#line 267
        memcpy((void */* __restrict  */)(& sdp->st), (void const   */* __restrict  */)(& ftwip->curStat),
               sizeof(sdp->st));
#line 268
        memcpy((void */* __restrict  */)(sdp->name), (void const   */* __restrict  */)cp,
               fnLen);
#line 269
        sdp->fnLen = fnLen;
#line 270
        sdp->next = (FtwSubDirListPtr )((void *)0);
        }
#line 271
        if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 272
          tail = sdp;
#line 272
          head = tail;
        } else {
#line 274
          tail->next = sdp;
#line 275
          tail = sdp;
        }
#line 277
        nSubdirs ++;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  closedir(DIRp);
#line 282
  DIRp = (DIR *)((void *)0);
#line 285
  sdp = head;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 285
      goto while_break___0;
    }
    {
#line 286
    nextsdp = sdp->next;
#line 287
    memcpy((void */* __restrict  */)(& ftwip->curStat), (void const   */* __restrict  */)(& sdp->st),
           sizeof(ftwip->curStat));
#line 288
    fnLen = sdp->fnLen;
#line 289
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)(sdp->name),
           fnLen);
#line 290
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 291
    ftwip->curFile = filename;
#line 292
    ftwip->curFileLen = fnLen - 1UL;
#line 293
    head = nextsdp;
#line 294
    free((void *)sdp);
#line 296
    ftwip->curType = 'd';
#line 297
    tmp___9 = (*(ftwip->proc))(ftwip);
    }
#line 297
    if (tmp___9 < 0) {
#line 298
      goto panic;
    }
    {
#line 300
    tmp___10 = FtwTraverse___0(ftwip, (dirPathLen + fnLen) - 1UL, depth + 1);
    }
#line 300
    if (tmp___10 < 0) {
#line 301
      goto panic;
    }
#line 306
    path = ftwip->curPath;
#line 307
    filename = path + dirPathLen;
#line 308
    *filename = (char )'\000';
#line 285
    sdp = nextsdp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  head = (FtwSubDirListPtr )((void *)0);
#line 311
  rc = 0;
  panic: 
#line 314
  if ((unsigned long )DIRp != (unsigned long )((void *)0)) {
    {
#line 315
    closedir(DIRp);
    }
  }
#line 317
  sdp = head;
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 317
      goto while_break___1;
    }
    {
#line 318
    nextsdp = sdp->next;
#line 319
    free((void *)sdp);
#line 317
    sdp = nextsdp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (rc);
}
}
#line 894 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPGetFileToMemory(FTPCIPtr const   cip , char const   * const  file , char *memBuf ,
                       size_t const   maxNumberOfBytesToWriteToMemBuf , size_t * const  numberOfBytesWrittenToMemBuf ,
                       long long const   startPoint , int const   deleteflag ) ;
#line 1018
void FTPInitIOTimer(FTPCIPtr const   cip ) ;
#line 1034
void FTPStartIOTimer(FTPCIPtr const   cip ) ;
#line 1035
void FTPStopIOTimer(FTPCIPtr const   cip ) ;
#line 94 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
int WaitForRemoteInput(FTPCIPtr const   cip ) ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getmem.c"
int FTPGetFileToMemory(FTPCIPtr const   cip , char const   * const  file , char *memBuf ,
                       size_t const   maxNumberOfBytesToWriteToMemBuf , size_t * const  numberOfBytesWrittenToMemBuf ,
                       long long const   startPoint , int const   deleteflag ) 
{ 
  int tmpResult ;
  int volatile   result ;
  int atEOF ;
  long long expectedSize ;
  size_t ntoread ;
  ssize_t nread ;
  size_t numberOfBytesLeftInMemBuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 41
  result = (int volatile   )0;
#line 42
  atEOF = 1;
#line 43
  cip->usingTAR = 0;
#line 44
  numberOfBytesLeftInMemBuf = (size_t )maxNumberOfBytesToWriteToMemBuf;
#line 45
  if ((unsigned long )numberOfBytesWrittenToMemBuf != (unsigned long )((void *)0)) {
#line 46
    *numberOfBytesWrittenToMemBuf = (size_t )0;
  }
#line 48
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 49
    return (-139);
  } else
#line 48
  if ((int const   )*(file + 0) == 0) {
#line 49
    return (-139);
  } else
#line 48
  if ((unsigned long )memBuf == (unsigned long )((void *)0)) {
#line 49
    return (-139);
  } else
#line 48
  if (maxNumberOfBytesToWriteToMemBuf == 0UL) {
#line 49
    return (-139);
  }
  {
#line 52
  FTPCheckForRestartModeAvailability(cip);
  }
#line 53
  if (startPoint != 0LL) {
#line 53
    if (cip->hasREST == 0) {
#line 54
      cip->errNo = -201;
#line 55
      return (cip->errNo);
    }
  }
  {
#line 58
  FTPFileSize(cip, file, (long long */* const  */)(& expectedSize), (int const   )'I');
  }
#line 59
  if (expectedSize != 0LL) {
#line 59
    if (startPoint > (long long const   )expectedSize) {
#line 61
      if (deleteflag == 1) {
        {
#line 62
        FTPDelete(cip, file, (int const   )0, (int const   )0);
        }
      }
#line 63
      return (0);
    }
  }
#line 66
  if (cip->numDownloads == 0) {
#line 66
    if (cip->dataSocketRBufSize != 0UL) {
#line 80
      if (cip->hasSITE_RETRBUFSIZE == 1) {
        {
#line 81
        FTPCmd(cip, (char const   */* const  */)"SITE RETRBUFSIZE %lu", cip->dataSocketRBufSize);
        }
      } else
#line 82
      if (cip->hasSITE_RBUFSIZ == 1) {
        {
#line 83
        FTPCmd(cip, (char const   */* const  */)"SITE RBUFSIZ %lu", cip->dataSocketRBufSize);
        }
      } else
#line 84
      if (cip->hasSITE_RBUFSZ == 1) {
        {
#line 85
        FTPCmd(cip, (char const   */* const  */)"SITE RBUFSZ %lu", cip->dataSocketRBufSize);
        }
      } else
#line 86
      if (cip->hasSITE_BUFSIZE == 1) {
        {
#line 87
        FTPCmd(cip, (char const   */* const  */)"SITE BUFSIZE %lu", cip->dataSocketSBufSize);
        }
      }
    }
  }
  {
#line 113
  tmpResult = FTPStartDataCmd(cip, (int const   )65, (int const   )'I', startPoint,
                              (char const   */* const  */)"RETR %s", file);
  }
#line 115
  if (tmpResult < 0) {
#line 116
    result = (int volatile   )tmpResult;
#line 117
    if (result == (int volatile   )-1) {
#line 118
      result = (int volatile   )-131;
    }
#line 119
    cip->errNo = (int )result;
#line 123
    return ((int )result);
  }
#line 126
  if (startPoint != 0LL) {
#line 126
    if (cip->startPoint == 0LL) {
#line 130
      cip->errNo = -117;
#line 134
      return (cip->errNo);
    }
  }
  {
#line 137
  FTPInitIOTimer(cip);
#line 138
  cip->expectedSize = expectedSize;
#line 139
  cip->lname = (char const   *)((void *)0);
#line 140
  cip->rname = (char const   *)file;
#line 141
  FTPStartIOTimer(cip);
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    tmp = WaitForRemoteInput(cip);
    }
#line 145
    if (! tmp) {
      {
#line 146
      result = (int volatile   )-194;
#line 146
      cip->errNo = (int )result;
#line 147
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out.\n");
      }
#line 148
      goto while_break;
    }
#line 150
    if (cip->cancelXfer > 0) {
      {
#line 151
      FTPAbortDataTransfer(cip);
#line 152
      tmp___0 = -169;
#line 152
      cip->errNo = tmp___0;
#line 152
      result = (int volatile   )tmp___0;
      }
#line 153
      goto while_break;
    }
#line 156
    ntoread = numberOfBytesLeftInMemBuf;
#line 157
    if (ntoread > cip->bufSize) {
#line 158
      ntoread = cip->bufSize;
    }
    {
#line 161
    tmp___1 = SRead(cip->dataSocket, (char */* const  */)memBuf, ntoread, (int )cip->xferTimeout,
                    8);
#line 161
    nread = (ssize_t )tmp___1;
    }
#line 162
    if (nread == -2L) {
      {
#line 163
      result = (int volatile   )-194;
#line 163
      cip->errNo = (int )result;
#line 164
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out.\n");
      }
#line 165
      goto while_break;
    } else
#line 166
    if (nread < 0L) {
      {
#line 167
      tmp___5 = __errno_location();
      }
#line 167
      if (*tmp___5 == 32) {
        {
#line 168
        tmp___2 = -136;
#line 168
        cip->errNo = tmp___2;
#line 168
        result = (int volatile   )tmp___2;
#line 169
        tmp___3 = __errno_location();
#line 169
        *tmp___3 = 32;
#line 170
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Lost data connection to remote host.\n");
        }
      } else {
        {
#line 171
        tmp___4 = __errno_location();
        }
#line 171
        if (*tmp___4 == 4) {
#line 172
          goto __Cont;
        } else {
          {
#line 174
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Remote read failed.\n");
#line 175
          result = (int volatile   )-136;
#line 176
          cip->errNo = -136;
          }
        }
      }
#line 178
      goto while_break;
    } else
#line 179
    if (nread == 0L) {
#line 180
      goto while_break;
    }
#line 207
    memBuf += nread;
#line 208
    if ((unsigned long )numberOfBytesWrittenToMemBuf != (unsigned long )((void *)0)) {
#line 209
      *numberOfBytesWrittenToMemBuf += (size_t )nread;
    }
    {
#line 210
    cip->bytesTransferred += (long long )nread;
#line 211
    FTPUpdateIOTimer(cip);
    }
#line 213
    if ((size_t )nread > numberOfBytesLeftInMemBuf) {
#line 215
      tmp___6 = -200;
#line 215
      cip->errNo = tmp___6;
#line 215
      result = (int volatile   )tmp___6;
#line 216
      goto while_break;
    }
#line 219
    numberOfBytesLeftInMemBuf -= (size_t )nread;
#line 220
    if (numberOfBytesLeftInMemBuf == 0UL) {
#line 222
      atEOF = 0;
#line 223
      if (cip->bytesTransferred + (long long )startPoint == expectedSize) {
#line 224
        atEOF = 1;
      }
#line 225
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (result == (int volatile   )0) {
#line 239
    if (atEOF == 0) {
      {
#line 240
      FTPAbortDataTransfer(cip);
#line 241
      tmpResult = FTPEndDataCmd(cip, 1);
      }
#line 242
      if (tmpResult < 0) {
#line 242
        if (result == (int volatile   )0) {
#line 242
          if (tmpResult != -161) {
#line 243
            result = (int volatile   )-131;
#line 244
            cip->errNo = -131;
          }
        }
      }
    } else {
#line 239
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 247
    tmpResult = FTPEndDataCmd(cip, 1);
    }
#line 248
    if (tmpResult < 0) {
#line 248
      if (result == (int volatile   )0) {
#line 249
        result = (int volatile   )-131;
#line 250
        cip->errNo = -131;
      }
    }
  }
  {
#line 254
  FTPStopIOTimer(cip);
  }
#line 259
  if (result == (int volatile   )0) {
#line 260
    (cip->numDownloads) ++;
#line 262
    if (deleteflag == 1) {
      {
#line 263
      tmp___7 = FTPDelete(cip, file, (int const   )0, (int const   )0);
#line 263
      result = (int volatile   )tmp___7;
      }
    }
  }
#line 267
  return ((int )result);
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_error.c"
void ( /* format attribute */  FTPLogError)(FTPCIPtr const   cip , int const   pError ,
                                            char const   * const  fmt  , ...) 
{ 
  va_list ap ;
  int errnum ;
  size_t len ;
  char buf[256] ;
  int endsinperiod ;
  int endsinnewline ;
  size_t buflen ;
  int x ;
  time_t t ;
  struct tm lt ;
  struct tm *ltp ;
  time_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 28
  buflen = (size_t )0;
#line 33
  buf[0] = (char )'\000';
#line 34
  x = cip->debugTimestamping;
#line 34
  if (x != 0) {
    {
#line 35
    tmp = time(& t);
#line 35
    ltp = Localtime(tmp, (struct tm */* const  */)(& lt));
    }
#line 36
    if (x == 1) {
      {
#line 37
      buflen = strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%H:%M:%S  ",
                        (struct tm  const  */* __restrict  */)ltp);
      }
    } else {
      {
#line 39
      buflen = strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S  ",
                        (struct tm  const  */* __restrict  */)ltp);
      }
    }
  }
  {
#line 43
  tmp___0 = __errno_location();
#line 43
  errnum = *tmp___0;
#line 44
  __builtin_va_start(ap, fmt);
#line 46
  vsnprintf((char */* __restrict  */)(buf + buflen), (sizeof(buf) - 1UL) - buflen,
            (char const   */* __restrict  */)fmt, ap);
#line 47
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 51
  __builtin_va_end(ap);
  }
#line 53
  if (pError != 0) {
    {
#line 54
    len = strlen((char const   *)(buf));
#line 55
    endsinperiod = 0;
#line 56
    endsinnewline = 0;
    }
#line 57
    if (len > 2UL) {
#line 58
      if ((int )buf[len - 1UL] == 10) {
#line 59
        endsinnewline = 1;
#line 60
        buf[len - 1UL] = (char )'\000';
#line 61
        if ((int )buf[len - 2UL] == 46) {
#line 62
          endsinperiod = 1;
#line 63
          buf[len - 2UL] = (char )'\000';
        }
      } else
#line 65
      if ((int )buf[len - 1UL] == 46) {
#line 66
        endsinperiod = 1;
#line 67
        buf[len - 1UL] = (char )'\000';
      }
    }
    {
#line 71
    Strncat((char */* const  */)(buf), (char const   */* const  */)": ", (size_t const   )sizeof(buf));
#line 72
    tmp___1 = strerror(errnum);
#line 72
    Strncat((char */* const  */)(buf), (char const   */* const  */)tmp___1, (size_t const   )sizeof(buf));
    }
#line 82
    if (endsinperiod != 0) {
      {
#line 83
      Strncat((char */* const  */)(buf), (char const   */* const  */)".", (size_t const   )sizeof(buf));
      }
    }
#line 84
    if (endsinnewline != 0) {
      {
#line 85
      Strncat((char */* const  */)(buf), (char const   */* const  */)"\n", (size_t const   )sizeof(buf));
      }
    }
  }
#line 88
  if ((unsigned long )cip->errLog != (unsigned long )((void *)0)) {
    {
#line 89
    fprintf((FILE */* __restrict  */)cip->errLog, (char const   */* __restrict  */)"%s",
            buf);
#line 90
    fflush(cip->errLog);
    }
  }
#line 92
  if ((unsigned long )cip->debugLog != (unsigned long )((void *)0)) {
#line 92
    if ((unsigned long )cip->debugLog != (unsigned long )cip->errLog) {
#line 93
      if ((unsigned long )cip->errLog != (unsigned long )stderr) {
        {
#line 94
        fprintf((FILE */* __restrict  */)cip->debugLog, (char const   */* __restrict  */)"%s",
                buf);
#line 95
        fflush(cip->debugLog);
        }
      } else
#line 93
      if ((unsigned long )cip->debugLog != (unsigned long )stdout) {
        {
#line 94
        fprintf((FILE */* __restrict  */)cip->debugLog, (char const   */* __restrict  */)"%s",
                buf);
#line 95
        fflush(cip->debugLog);
        }
      }
    }
  }
#line 98
  if ((unsigned long )cip->errLogProc != (unsigned long )((void *)0)) {
    {
#line 99
    (*(cip->errLogProc))(cip, buf);
    }
  }
#line 101
  if ((unsigned long )cip->debugLogProc != (unsigned long )((void *)0)) {
#line 101
    if ((unsigned long )cip->debugLogProc != (unsigned long )cip->errLogProc) {
      {
#line 102
      (*(cip->debugLogProc))(cip, buf);
      }
    }
  }
#line 104
  return;
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 964 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
char *GetPass(char const   * const  prompt , char * const  pwbuf , size_t const   pwbufsize ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getpass.c"
char *GetPass(char const   * const  prompt , char * const  pwbuf , size_t const   pwbufsize ) 
{ 
  struct termios old_ti ;
  struct termios new_ti ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 62
  memset((void *)pwbuf, 0, (size_t )pwbufsize);
#line 63
  tmp = fileno(stdout);
#line 63
  tmp___0 = isatty(tmp);
  }
#line 63
  if (! tmp___0) {
#line 64
    return ((char *)pwbuf);
  }
  {
#line 65
  fputs((char const   */* __restrict  */)prompt, (FILE */* __restrict  */)stdout);
#line 66
  fflush(stdout);
#line 67
  tmp___1 = fileno(stdout);
#line 67
  tmp___2 = tcgetattr(tmp___1, & old_ti);
  }
#line 67
  if (tmp___2 != 0) {
#line 68
    return ((char *)pwbuf);
  }
  {
#line 69
  new_ti = old_ti;
#line 70
  new_ti.c_lflag &= 4294967287U;
#line 71
  tmp___3 = fileno(stdout);
#line 71
  tmp___4 = tcsetattr(tmp___3, 2, (struct termios  const  *)(& new_ti));
  }
#line 71
  if (tmp___4 != 0) {
#line 72
    return ((char *)pwbuf);
  }
  {
#line 73
  FGets((char *)pwbuf, (size_t )pwbufsize, stdin);
#line 74
  fflush(stdout);
#line 75
  fflush(stdin);
#line 76
  tmp___5 = fileno(stdout);
#line 76
  tcsetattr(tmp___5, 2, (struct termios  const  *)(& old_ti));
  }
#line 77
  return ((char *)pwbuf);
}
}
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_close.c"
void CloseFile(FILE **f ) 
{ 


  {
#line 17
  if ((unsigned long )*f != (unsigned long )((void *)0)) {
#line 18
    if ((unsigned long )*f != (unsigned long )stdout) {
#line 18
      if ((unsigned long )*f != (unsigned long )stdin) {
#line 18
        if ((unsigned long )*f != (unsigned long )stderr) {
          {
#line 19
          fclose(*f);
          }
        }
      }
    }
#line 20
    *f = (FILE *)((void *)0);
  }
#line 22
  return;
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 197 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int PWrite(int sfd , char const   * const  buf0 , size_t size ) ;
#line 889 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
long long FTPLocalASCIIFileSize(char const   * const  fn , char *buf , size_t const   bufsize ) ;
#line 890
int FTPFileSizeAndModificationTime(FTPCIPtr const   cip , char const   * const  file ,
                                   long long * const  size , int const   type , time_t * const  mdtm ) ;
#line 92 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
void AutomaticallyUseASCIIModeDependingOnExtension(FTPCIPtr const   cip , char const   * const  pathName ,
                                                   int * const  xtype ) ;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_get.c"
int FTPGetOneF(FTPCIPtr const   cip , char const   * const  file , char const   *dstfile ,
               int xtype , int const   fdtouse , long long expectedSize , time_t mdtm ,
               int const   resumeflag , int const   appendflag , int const   deleteflag ,
               int (* const  resumeProc)(FTPCIPtr const   cip , char const   **localpath ,
                                         long long localsize , time_t localmtime ,
                                         char const   *remotepath , long long remotesize ,
                                         time_t remotetime , long long *startPoint ) ) 
{ 
  char *buf ;
  size_t bufSize ;
  int tmpResult ;
  int volatile   result ;
  ssize_t nread ;
  ssize_t nwrote ;
  int volatile   fd ;
  char *src ;
  char *srclim ;
  char *dst ;
  char *dstlim ;
  char outbuf[512] ;
  int cr ;
  int crcr ;
  int add_another_eoln ;
  int crcr_offset ;
  long long tstartPoint ;
  long long volatile   startPoint ;
  struct utimbuf ut ;
  struct stat st ;
  int volatile   created ;
  int zaction ;
  int statrc ;
  int noMdtmCheck ;
  int is_dev ;
  time_t now ;
  long long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  int *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  int *tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  int *tmp___41 ;
  int tmp___42 ;

  {
#line 66
  startPoint = (long long volatile   )0;
#line 75
  created = (int volatile   )0;
#line 76
  zaction = 5;
#line 82
  if ((unsigned long )cip->buf == (unsigned long )((void *)0)) {
    {
#line 83
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Transfer buffer not allocated.\n");
#line 84
    cip->errNo = -175;
    }
#line 85
    return (cip->errNo);
  }
#line 88
  result = (int volatile   )0;
#line 89
  cip->usingTAR = 0;
#line 91
  if (fdtouse < 0) {
#line 106
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 107
      return (-139);
    } else
#line 106
    if ((int const   )*(file + 0) == 0) {
#line 107
      return (-139);
    } else
#line 106
    if ((unsigned long )dstfile == (unsigned long )((void *)0)) {
#line 107
      return (-139);
    } else
#line 106
    if ((int const   )*(dstfile + 0) == 0) {
#line 107
      return (-139);
    }
    {
#line 110
    AutomaticallyUseASCIIModeDependingOnExtension(cip, file, (int */* const  */)(& xtype));
    }
#line 112
    if ((unsigned long )cip->progress != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                    int  ))0)) {
#line 112
      goto _L;
    } else
#line 112
    if (resumeflag == 1) {
#line 112
      goto _L;
    } else
#line 112
    if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                                char const   **localpath ,
                                                                long long localsize ,
                                                                time_t localmtime ,
                                                                char const   *remotepath ,
                                                                long long remotesize ,
                                                                time_t remotetime ,
                                                                long long *startPoint ))0)) {
      _L: /* CIL Label */ 
#line 113
      if (expectedSize == -1LL) {
        {
#line 114
        FTPFileSizeAndModificationTime(cip, file, (long long */* const  */)(& expectedSize),
                                       (int const   )xtype, (time_t */* const  */)(& mdtm));
        }
      } else {
        {
#line 116
        FTPFileModificationTime(cip, file, (time_t */* const  */)(& mdtm));
        }
      }
    }
#line 123
    if (resumeflag == 1) {
      {
#line 124
      FTPCheckForRestartModeAvailability(cip);
      }
    } else
#line 123
    if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                                char const   **localpath ,
                                                                long long localsize ,
                                                                time_t localmtime ,
                                                                char const   *remotepath ,
                                                                long long remotesize ,
                                                                time_t remotetime ,
                                                                long long *startPoint ))0)) {
      {
#line 124
      FTPCheckForRestartModeAvailability(cip);
      }
    }
#line 127
    if (appendflag == 1) {
#line 128
      zaction = 4;
    } else
#line 129
    if (cip->hasREST == 0) {
#line 130
      zaction = 3;
    } else
#line 131
    if (resumeflag == 1) {
#line 132
      zaction = 5;
    } else {
#line 134
      zaction = 3;
    }
    {
#line 137
    is_dev = 0;
#line 138
    statrc = stat((char const   */* __restrict  */)dstfile, (struct stat */* __restrict  */)(& st));
    }
#line 139
    if (statrc == 0) {
#line 140
      if ((unsigned long )resumeProc != (unsigned long )((void *)0)) {
        {
#line 141
        tstartPoint = (long long )startPoint;
#line 142
        zaction = (*resumeProc)(cip, & dstfile, (long long )st.st_size, st.st_mtim.tv_sec,
                                (char const   *)file, expectedSize, mdtm, & tstartPoint);
#line 152
        startPoint = (long long volatile   )tstartPoint;
        }
      }
#line 155
      if ((st.st_mode & 61440U) == 24576U) {
#line 156
        is_dev = 1;
      }
#line 159
      if ((st.st_mode & 61440U) == 8192U) {
#line 160
        is_dev = 1;
      }
#line 163
      if (zaction == 5) {
#line 164
        if (expectedSize != -1LL) {
#line 172
          zaction = 2;
#line 173
          startPoint = (long long volatile   )((long long )st.st_size);
#line 174
          if (xtype == 65) {
#line 175
            if ((unsigned long )dstfile == (unsigned long )((void *)0)) {
#line 176
              zaction = 3;
            } else
#line 175
            if ((int const   )*(dstfile + 0) == 0) {
#line 176
              zaction = 3;
            } else {
              {
#line 175
              tmp = FTPLocalASCIIFileSize((char const   */* const  */)dstfile, cip->buf,
                                          (size_t const   )cip->bufSize);
#line 175
              startPoint = (long long volatile   )tmp;
              }
#line 175
              if (startPoint < (long long volatile   )0) {
#line 176
                zaction = 3;
              }
            }
          }
#line 187
          noMdtmCheck = 0;
#line 188
          if (mdtm != -1L) {
            {
#line 189
            time(& now);
            }
#line 190
            if (st.st_mtim.tv_sec > now) {
#line 191
              noMdtmCheck = 1;
            } else
#line 190
            if (now - st.st_mtim.tv_sec < 46200L) {
#line 190
              if (now - mdtm >= 46200L) {
#line 191
                noMdtmCheck = 1;
              }
            }
          }
#line 194
          if (mdtm == -1L) {
#line 194
            goto _L___1;
          } else
#line 194
          if (noMdtmCheck != 0) {
            _L___1: /* CIL Label */ 
#line 196
            if (startPoint == (long long volatile   )expectedSize) {
#line 198
              cip->errNo = -178;
#line 199
              if (deleteflag == 1) {
                {
#line 200
                FTPDelete(cip, file, (int const   )0, (int const   )0);
                }
              }
#line 201
              return (cip->errNo);
            } else
#line 202
            if (startPoint > (long long volatile   )expectedSize) {
#line 208
              zaction = 3;
            }
          } else
#line 210
          if (mdtm == st.st_mtim.tv_sec) {
#line 210
            goto _L___0;
          } else
#line 210
          if (mdtm == st.st_mtim.tv_sec - 1L) {
#line 210
            goto _L___0;
          } else
#line 210
          if (mdtm == st.st_mtim.tv_sec + 1L) {
            _L___0: /* CIL Label */ 
#line 214
            if (startPoint == (long long volatile   )expectedSize) {
#line 216
              cip->errNo = -178;
#line 217
              if (deleteflag == 1) {
                {
#line 218
                FTPDelete(cip, file, (int const   )0, (int const   )0);
                }
              }
#line 219
              return (cip->errNo);
            } else
#line 220
            if (startPoint > (long long volatile   )expectedSize) {
#line 226
              zaction = 3;
            }
          } else
#line 234
          if (mdtm < st.st_mtim.tv_sec) {
#line 239
            cip->errNo = -176;
#line 240
            return (cip->errNo);
          } else {
#line 247
            zaction = 3;
          }
        } else
#line 250
        if (cip->hasMDTM == 1) {
#line 256
          zaction = 1;
        } else
#line 250
        if (cip->hasSIZE != 1) {
#line 256
          zaction = 1;
        } else {
#line 258
          zaction = 3;
        }
      }
    } else {
#line 263
      zaction = 3;
    }
#line 266
    if (zaction == 6) {
#line 270
      cip->errNo = -195;
#line 271
      return (cip->errNo);
    } else
#line 272
    if (zaction == 1) {
#line 274
      if (deleteflag == 1) {
        {
#line 275
        FTPDelete(cip, file, (int const   )0, (int const   )0);
        }
      }
#line 276
      return (0);
    } else
#line 277
    if (zaction == 2) {
#line 279
      if (startPoint == (long long volatile   )expectedSize) {
#line 282
        if (deleteflag == 1) {
          {
#line 283
          FTPDelete(cip, file, (int const   )0, (int const   )0);
          }
        }
#line 284
        return (0);
      } else
#line 285
      if (startPoint > (long long volatile   )expectedSize) {
#line 287
        result = (int volatile   )-117;
#line 287
        cip->errNo = (int )result;
#line 288
        return ((int )result);
      }
#line 290
      if (is_dev) {
#line 290
        tmp___0 = 1;
      } else {
#line 290
        tmp___0 = 1025;
      }
      {
#line 290
      tmp___1 = open(dstfile, tmp___0, 438);
#line 290
      fd = (int volatile   )tmp___1;
      }
    } else
#line 291
    if (zaction == 4) {
#line 293
      startPoint = (long long volatile   )0LL;
#line 294
      if (is_dev) {
#line 294
        tmp___2 = 1025;
      } else {
#line 294
        tmp___2 = 1089;
      }
      {
#line 294
      tmp___3 = open(dstfile, tmp___2, 438);
#line 294
      fd = (int volatile   )tmp___3;
      }
    } else {
#line 296
      created = (int volatile   )1;
#line 297
      startPoint = (long long volatile   )0LL;
#line 298
      if (is_dev) {
#line 298
        tmp___4 = 1;
      } else {
#line 298
        tmp___4 = 577;
      }
      {
#line 298
      tmp___5 = open(dstfile, tmp___4, 438);
#line 298
      fd = (int volatile   )tmp___5;
      }
    }
#line 301
    if (fd < (int volatile   )0) {
      {
#line 302
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Cannot open local file %s for writing.\n",
                  dstfile);
#line 303
      result = (int volatile   )-137;
#line 304
      cip->errNo = -137;
      }
#line 305
      return ((int )result);
    }
#line 308
    if (expectedSize == 0LL) {
#line 308
      if (startPoint <= (long long volatile   )0LL) {
#line 308
        if (zaction != 3) {
          {
#line 314
          close((int )fd);
          }
#line 315
          if (mdtm != -1L) {
            {
#line 316
            cip->mdtm = mdtm;
#line 317
            time(& ut.actime);
#line 318
            ut.modtime = mdtm;
#line 319
            utime(dstfile, (struct utimbuf  const  *)(& ut));
            }
          }
#line 321
          if (deleteflag == 1) {
            {
#line 322
            FTPDelete(cip, file, (int const   )0, (int const   )0);
            }
          }
#line 323
          return (0);
        }
      }
    }
  } else {
#line 326
    fd = (int volatile   )fdtouse;
  }
#line 329
  if (cip->numDownloads == 0) {
#line 329
    if (cip->dataSocketRBufSize != 0UL) {
#line 343
      if (cip->hasSITE_RETRBUFSIZE == 1) {
        {
#line 344
        FTPCmd(cip, (char const   */* const  */)"SITE RETRBUFSIZE %lu", cip->dataSocketRBufSize);
        }
      } else
#line 345
      if (cip->hasSITE_RBUFSIZ == 1) {
        {
#line 346
        FTPCmd(cip, (char const   */* const  */)"SITE RBUFSIZ %lu", cip->dataSocketRBufSize);
        }
      } else
#line 347
      if (cip->hasSITE_RBUFSZ == 1) {
        {
#line 348
        FTPCmd(cip, (char const   */* const  */)"SITE RBUFSZ %lu", cip->dataSocketRBufSize);
        }
      } else
#line 349
      if (cip->hasSITE_BUFSIZE == 1) {
        {
#line 350
        FTPCmd(cip, (char const   */* const  */)"SITE BUFSIZE %lu", cip->dataSocketSBufSize);
        }
      }
    }
  }
  {
#line 381
  tmpResult = FTPStartDataCmd(cip, (int const   )65, (int const   )xtype, (long long const   )startPoint,
                              (char const   */* const  */)"RETR %s", file);
  }
#line 383
  if (tmpResult < 0) {
#line 384
    result = (int volatile   )tmpResult;
#line 385
    if (result == (int volatile   )-1) {
#line 386
      result = (int volatile   )-131;
    }
#line 387
    cip->errNo = (int )result;
#line 388
    if (fdtouse < 0) {
      {
#line 389
      close((int )fd);
      }
#line 390
      if (created != (int volatile   )0) {
#line 390
        if (appendflag == 0) {
#line 390
          if (cip->startPoint == 0LL) {
            {
#line 391
            unlink(dstfile);
            }
          }
        }
      }
    }
#line 396
    return ((int )result);
  }
#line 399
  if (startPoint != (long long volatile   )0) {
#line 399
    if (cip->startPoint == 0LL) {
      {
#line 405
      tmp___6 = lseek((int )fd, (off_t )0, 0);
      }
#line 405
      if (tmp___6 != 0L) {
#line 406
        cip->errNo = -168;
#line 407
        if (fdtouse < 0) {
          {
#line 408
          close((int )fd);
          }
        }
#line 413
        return (cip->errNo);
      }
#line 415
      startPoint = (long long volatile   )0;
    }
  }
  {
#line 418
  buf = cip->buf;
#line 419
  bufSize = cip->bufSize;
#line 421
  FTPInitIOTimer(cip);
#line 422
  cip->mdtm = mdtm;
#line 423
  time(& ut.actime);
#line 424
  ut.modtime = mdtm;
#line 425
  cip->expectedSize = expectedSize;
#line 426
  cip->lname = dstfile;
#line 427
  cip->rname = (char const   *)file;
  }
#line 428
  if (fdtouse >= 0) {
#line 429
    cip->useProgressMeter = 0;
  }
  {
#line 430
  FTPStartIOTimer(cip);
  }
#line 433
  if (xtype == 65) {
#line 434
    add_another_eoln = 0;
#line 434
    crcr_offset = add_another_eoln;
#line 434
    crcr = crcr_offset;
#line 434
    cr = crcr;
    {
#line 436
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 437
      tmp___7 = WaitForRemoteInput(cip);
      }
#line 437
      if (! tmp___7) {
        {
#line 438
        result = (int volatile   )-194;
#line 438
        cip->errNo = (int )result;
#line 439
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out after %lld bytes had been received.\n",
                    cip->bytesTransferred);
        }
#line 440
        goto while_break;
      }
#line 442
      if (cip->cancelXfer > 0) {
        {
#line 443
        FTPAbortDataTransfer(cip);
#line 444
        tmp___8 = -169;
#line 444
        cip->errNo = tmp___8;
#line 444
        result = (int volatile   )tmp___8;
        }
#line 445
        goto while_break;
      }
      {
#line 456
      tmp___9 = SRead(cip->dataSocket, (char */* const  */)buf, bufSize, (int )cip->xferTimeout,
                      8);
#line 456
      nread = (ssize_t )tmp___9;
      }
#line 457
      if (nread == -2L) {
        {
#line 458
        result = (int volatile   )-194;
#line 458
        cip->errNo = (int )result;
#line 459
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out after %lld bytes had been received.\n",
                    cip->bytesTransferred);
        }
#line 460
        goto while_break;
      } else
#line 461
      if (nread < 0L) {
        {
#line 462
        tmp___13 = __errno_location();
        }
#line 462
        if (*tmp___13 == 32) {
          {
#line 463
          tmp___10 = -136;
#line 463
          cip->errNo = tmp___10;
#line 463
          result = (int volatile   )tmp___10;
#line 464
          tmp___11 = __errno_location();
#line 464
          *tmp___11 = 32;
#line 465
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Lost data connection to remote host after %lld bytes had been received.\n",
                      cip->bytesTransferred);
          }
        } else {
          {
#line 466
          tmp___12 = __errno_location();
          }
#line 466
          if (*tmp___12 == 4) {
#line 467
            goto __Cont;
          } else {
            {
#line 469
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Remote read failed after %lld bytes had been received.\n",
                        cip->bytesTransferred);
#line 470
            result = (int volatile   )-136;
#line 471
            cip->errNo = -136;
            }
          }
        }
#line 473
        goto while_break;
      } else
#line 474
      if (nread == 0L) {
#line 475
        goto while_break;
      }
#line 503
      src = buf;
#line 504
      srclim = src + nread;
#line 505
      dst = outbuf;
#line 506
      dstlim = dst + sizeof(outbuf);
      {
#line 507
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 507
        if (! ((unsigned long )src < (unsigned long )srclim)) {
#line 507
          goto while_break___0;
        }
#line 508
        if ((unsigned long )dst >= (unsigned long )dstlim) {
          {
#line 509
          tmp___14 = PWrite((int )fd, (char const   */* const  */)(outbuf), (size_t )(dst - outbuf));
#line 509
          nwrote = (ssize_t )tmp___14;
          }
#line 510
          if (nwrote == dst - outbuf) {
#line 512
            dst = outbuf;
          } else {
            {
#line 513
            tmp___16 = __errno_location();
            }
#line 513
            if (*tmp___16 == 32) {
              {
#line 514
              result = (int volatile   )-133;
#line 515
              cip->errNo = -133;
#line 516
              tmp___15 = __errno_location();
#line 516
              *tmp___15 = 32;
#line 517
              shutdown(cip->dataSocket, 2);
              }
#line 518
              goto brk;
            } else {
              {
#line 520
              FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local write failed after %lld bytes had been received.\n",
                          cip->bytesTransferred);
#line 521
              result = (int volatile   )-133;
#line 522
              cip->errNo = -133;
#line 523
              shutdown(cip->dataSocket, 2);
              }
#line 524
              goto brk;
            }
          }
        }
#line 546
        if (crcr != 0) {
#line 548
          crcr = 0;
#line 549
          crcr_offset = 0;
#line 550
          goto have_char_after_crcr;
        }
#line 552
        if (cr != 0) {
#line 554
          cr = 0;
#line 555
          goto have_char_after_cr;
        }
#line 558
        if ((int )*src == 10) {
#line 560
          src ++;
#line 561
          goto add_eoln;
        }
#line 563
        if ((int )*src == 13) {
#line 564
          src ++;
#line 565
          if ((unsigned long )src < (unsigned long )srclim) {
            have_char_after_cr: 
#line 567
            if ((int )*src == 10) {
#line 571
              src ++;
            } else
#line 572
            if ((int )*src == 13) {
#line 578
              crcr_offset = 1;
              have_char_after_crcr: 
#line 580
              if ((unsigned long )(src + crcr_offset) < (unsigned long )srclim) {
#line 581
                if ((int )*(src + crcr_offset) == 10) {
#line 582
                  src += 1 + crcr_offset;
                } else {
#line 588
                  add_another_eoln ++;
#line 589
                  src += crcr_offset;
                }
              } else {
#line 592
                crcr = 1;
#line 593
                src ++;
#line 594
                goto while_continue___0;
              }
            }
          } else {
#line 599
            cr = 1;
#line 600
            goto while_continue___0;
          }
          add_eoln: 
#line 603
          if ((unsigned long )(dst + 2) >= (unsigned long )dstlim) {
            {
#line 607
            tmp___17 = PWrite((int )fd, (char const   */* const  */)(outbuf), (size_t )(dst - outbuf));
#line 607
            nwrote = (ssize_t )tmp___17;
            }
#line 608
            if (nwrote == dst - outbuf) {
#line 610
              dst = outbuf;
            } else {
              {
#line 611
              tmp___19 = __errno_location();
              }
#line 611
              if (*tmp___19 == 32) {
                {
#line 612
                result = (int volatile   )-133;
#line 613
                cip->errNo = -133;
#line 614
                tmp___18 = __errno_location();
#line 614
                *tmp___18 = 32;
#line 615
                shutdown(cip->dataSocket, 2);
                }
#line 616
                goto brk;
              } else {
                {
#line 618
                FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local write failed after %lld bytes had been received.\n",
                            cip->bytesTransferred);
#line 619
                result = (int volatile   )-133;
#line 620
                cip->errNo = -133;
#line 621
                shutdown(cip->dataSocket, 2);
                }
#line 622
                goto brk;
              }
            }
          }
#line 625
          tmp___20 = dst;
#line 625
          dst ++;
#line 625
          *tmp___20 = cip->textEOLN[0];
#line 626
          if ((int )cip->textEOLN[1] != 0) {
#line 627
            tmp___21 = dst;
#line 627
            dst ++;
#line 627
            *tmp___21 = cip->textEOLN[1];
          }
#line 628
          if (add_another_eoln != 0) {
#line 629
            add_another_eoln --;
#line 630
            goto add_eoln;
          }
#line 632
          goto while_continue___0;
        }
#line 635
        tmp___22 = dst;
#line 635
        dst ++;
#line 635
        tmp___23 = src;
#line 635
        src ++;
#line 635
        *tmp___22 = *tmp___23;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 637
      if ((unsigned long )dst > (unsigned long )(outbuf)) {
        {
#line 638
        tmp___24 = PWrite((int )fd, (char const   */* const  */)(outbuf), (size_t )(dst - outbuf));
#line 638
        nwrote = (ssize_t )tmp___24;
        }
#line 639
        if (nwrote != dst - outbuf) {
          {
#line 640
          tmp___26 = __errno_location();
          }
#line 640
          if (*tmp___26 == 32) {
            {
#line 641
            result = (int volatile   )-133;
#line 642
            cip->errNo = -133;
#line 643
            tmp___25 = __errno_location();
#line 643
            *tmp___25 = 32;
#line 644
            shutdown(cip->dataSocket, 2);
            }
#line 645
            goto brk;
          } else {
            {
#line 647
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local write failed after %lld bytes had been received.\n",
                        cip->bytesTransferred);
#line 648
            result = (int volatile   )-133;
#line 649
            cip->errNo = -133;
#line 650
            shutdown(cip->dataSocket, 2);
            }
#line 651
            goto brk;
          }
        }
      }
#line 656
      if (mdtm != -1L) {
        {
#line 657
        utime(dstfile, (struct utimbuf  const  *)(& ut));
        }
      }
      {
#line 659
      cip->bytesTransferred += (long long )nread;
#line 660
      FTPUpdateIOTimer(cip);
      }
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 662
    if (crcr != 0) {
#line 663
      cr = 2;
    }
    {
#line 664
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 664
      cr --;
#line 664
      if (! (cr >= 0)) {
#line 664
        goto while_break___1;
      }
      {
#line 668
      tmp___27 = strlen((char const   *)(cip->textEOLN));
#line 668
      tmp___28 = PWrite((int )fd, (char const   */* const  */)(cip->textEOLN), tmp___27);
#line 668
      nwrote = (ssize_t )tmp___28;
#line 669
      tmp___31 = strlen((char const   *)(cip->textEOLN));
      }
#line 669
      if (nwrote == (ssize_t )tmp___31) {
#line 671
        if (mdtm != -1L) {
          {
#line 672
          utime(dstfile, (struct utimbuf  const  *)(& ut));
          }
        }
      } else {
        {
#line 674
        tmp___30 = __errno_location();
        }
#line 674
        if (*tmp___30 == 32) {
          {
#line 675
          result = (int volatile   )-133;
#line 676
          cip->errNo = -133;
#line 677
          tmp___29 = __errno_location();
#line 677
          *tmp___29 = 32;
#line 678
          shutdown(cip->dataSocket, 2);
          }
#line 679
          goto brk;
        } else {
          {
#line 681
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local write failed after %lld bytes had been received.\n",
                      cip->bytesTransferred);
#line 682
          result = (int volatile   )-133;
#line 683
          cip->errNo = -133;
#line 684
          shutdown(cip->dataSocket, 2);
          }
#line 685
          goto brk;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 692
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 693
      tmp___32 = WaitForRemoteInput(cip);
      }
#line 693
      if (! tmp___32) {
        {
#line 694
        result = (int volatile   )-194;
#line 694
        cip->errNo = (int )result;
#line 695
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out after %lld bytes had been received.\n",
                    cip->bytesTransferred);
        }
#line 696
        goto while_break___2;
      }
#line 698
      if (cip->cancelXfer > 0) {
        {
#line 699
        FTPAbortDataTransfer(cip);
#line 700
        tmp___33 = -169;
#line 700
        cip->errNo = tmp___33;
#line 700
        result = (int volatile   )tmp___33;
        }
#line 701
        goto while_break___2;
      }
      {
#line 712
      tmp___34 = SRead(cip->dataSocket, (char */* const  */)buf, bufSize, (int )cip->xferTimeout,
                       8);
#line 712
      nread = (ssize_t )tmp___34;
      }
#line 713
      if (nread == -2L) {
        {
#line 714
        result = (int volatile   )-194;
#line 714
        cip->errNo = (int )result;
#line 715
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out after %lld bytes had been received.\n",
                    cip->bytesTransferred);
        }
#line 716
        goto while_break___2;
      } else
#line 717
      if (nread < 0L) {
        {
#line 718
        tmp___38 = __errno_location();
        }
#line 718
        if (*tmp___38 == 32) {
          {
#line 719
          tmp___35 = -136;
#line 719
          cip->errNo = tmp___35;
#line 719
          result = (int volatile   )tmp___35;
#line 720
          tmp___36 = __errno_location();
#line 720
          *tmp___36 = 32;
#line 721
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Lost data connection to remote host after %lld bytes had been received.\n",
                      cip->bytesTransferred);
          }
        } else {
          {
#line 722
          tmp___37 = __errno_location();
          }
#line 722
          if (*tmp___37 == 4) {
#line 723
            goto __Cont___0;
          } else {
            {
#line 725
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Remote read failed after %lld bytes had been received.\n",
                        cip->bytesTransferred);
#line 726
            result = (int volatile   )-136;
#line 727
            cip->errNo = -136;
            }
          }
        }
#line 729
        goto while_break___2;
      } else
#line 730
      if (nread == 0L) {
#line 731
        goto while_break___2;
      }
      {
#line 757
      tmp___39 = PWrite((int )fd, (char const   */* const  */)buf, (size_t )nread);
#line 757
      nwrote = (ssize_t )tmp___39;
      }
#line 758
      if (nwrote != nread) {
        {
#line 759
        tmp___41 = __errno_location();
        }
#line 759
        if (*tmp___41 == 32) {
          {
#line 760
          result = (int volatile   )-133;
#line 761
          cip->errNo = -133;
#line 762
          tmp___40 = __errno_location();
#line 762
          *tmp___40 = 32;
          }
        } else {
          {
#line 764
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local write failed after %lld bytes had been received.\n",
                      cip->bytesTransferred);
#line 765
          result = (int volatile   )-133;
#line 766
          cip->errNo = -133;
          }
        }
        {
#line 768
        shutdown(cip->dataSocket, 2);
        }
#line 769
        goto while_break___2;
      }
#line 776
      if (mdtm != -1L) {
        {
#line 777
        utime(dstfile, (struct utimbuf  const  *)(& ut));
        }
      }
      {
#line 779
      cip->bytesTransferred += (long long )nread;
#line 780
      FTPUpdateIOTimer(cip);
      }
      __Cont___0: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  brk: 
#line 794
  if (fdtouse < 0) {
    {
#line 799
    close((int )fd);
#line 800
    fd = (int volatile   )-1;
    }
  }
  {
#line 803
  tmpResult = FTPEndDataCmd(cip, 1);
  }
#line 804
  if (tmpResult < 0) {
#line 804
    if (result == (int volatile   )0) {
#line 805
      result = (int volatile   )-131;
#line 806
      cip->errNo = -131;
    }
  }
  {
#line 808
  FTPStopIOTimer(cip);
  }
#line 813
  if (mdtm != -1L) {
    {
#line 814
    utime(dstfile, (struct utimbuf  const  *)(& ut));
    }
  }
#line 817
  if (result == (int volatile   )0) {
#line 818
    (cip->numDownloads) ++;
#line 820
    if (deleteflag == 1) {
      {
#line 821
      tmp___42 = FTPDelete(cip, file, (int const   )0, (int const   )0);
#line 821
      result = (int volatile   )tmp___42;
      }
    }
  }
#line 825
  return ((int )result);
}
}
#line 54 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Strncat_NoZeroPad(char * const  dst , char const   * const  src , size_t const   n ) ;
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strncat_NoZeroPad.c"
char *Strncat_NoZeroPad(char * const  dst , char const   * const  src , size_t const   n ) 
{ 
  register size_t i___0 ;
  register char *d ;
  register char const   *s ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 21
  if (n != 0UL) {
    {
#line 21
    i___0 = strlen((char const   *)dst);
    }
#line 21
    if (i___0 < (size_t )(n - 1UL)) {
#line 22
      d = (char *)(dst + i___0);
#line 23
      s = (char const   *)src;
#line 30
      i___0 ++;
      {
#line 30
      while (1) {
        while_continue: /* CIL Label */ ;
#line 30
        if (! (i___0 < (size_t )n)) {
#line 30
          goto while_break;
        }
#line 31
        tmp = d;
#line 31
        d ++;
#line 31
        tmp___1 = s;
#line 31
        s ++;
#line 31
        tmp___0 = (char )*tmp___1;
#line 31
        *tmp = tmp___0;
#line 31
        if ((int )tmp___0 == 0) {
#line 32
          return ((char *)dst);
        }
#line 30
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 38
      *d = (char)0;
    }
  }
#line 40
  return ((char *)dst);
}
}
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_shutdownci.c"
void FTPShutdownHost(FTPCIPtr const   cip ) 
{ 
  int tmp ;

  {
#line 22
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 23
    return;
  }
  {
#line 24
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 24
  if (tmp) {
#line 25
    return;
  }
#line 32
  if (cip->dataSocket != -1) {
    {
#line 33
    SetSocketLinger((int const   )cip->dataSocket, (int const   )0, (int const   )0);
    }
  }
  {
#line 34
  CloseDataConnection(cip);
#line 37
  FTPCloseControlConnection(cip);
#line 39
  FTPDeallocateHost(cip);
  }
#line 44
  return;
}
}
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 203 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SBind(int sockfd , int const   port , int const   nTries , int const   reuseFlag ) ;
#line 204
int SListen(int sfd , int backlog ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SBind.c"
int SBind(int sockfd , int const   port , int const   nTries , int const   reuseFlag ) 
{ 
  unsigned int i___0 ;
  int on ;
  socklen_t onsize ;
  struct sockaddr_in localAddr ;
  int tmp ;

  {
  {
#line 14
  localAddr.sin_family = (sa_family_t )2;
#line 15
  localAddr.sin_addr.s_addr = htonl((in_addr_t )0);
#line 16
  localAddr.sin_port = htons((unsigned short )port);
  }
#line 18
  if (reuseFlag != 0) {
    {
#line 23
    on = 1;
#line 24
    onsize = (socklen_t )sizeof(on);
#line 25
    setsockopt(sockfd, 1, 2, (void const   *)(& on), onsize);
#line 33
    on = 1;
#line 34
    onsize = (socklen_t )sizeof(on);
#line 35
    setsockopt(sockfd, 1, 15, (void const   *)(& on), onsize);
    }
  }
#line 40
  i___0 = 1U;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    tmp = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& localAddr)),
               (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 44
    if (tmp == 0) {
#line 45
      goto while_break;
    }
#line 47
    if ((int )i___0 == (int )nTries) {
#line 48
      return (-1);
    }
    {
#line 53
    sleep(i___0 * 3U);
#line 40
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (0);
}
}
#line 62 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SBind.c"
int SListen(int sfd , int backlog ) 
{ 
  int tmp ;

  {
  {
#line 65
  tmp = listen(sfd, backlog);
  }
#line 65
  return (tmp);
}
}
#line 207 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SCloseSocket(int sfd ) ;
#line 270
int GetSocketLinger(int const   fd , int * const  lingertime ) ;
#line 292
void SIOHandler(int sigNum ) ;
#line 293
void (*SSignal(int signum , void (*handler)(int  ) ))(int  ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SClose.c"
int SCloseSocket(int sfd ) 
{ 
  int result ;
  void (*sigpipe)(int  ) ;
  __sighandler_t tmp ;

  {
#line 10
  sigpipe = (void (*)(int  ))0;
#line 12
  if (sio_sigpipe_ignored_already) {
#line 12
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 12
    tmp = signal(13, (void (*)(int  ))1);
#line 12
    sigpipe = tmp;
    }
  }
  {
#line 13
  result = close(sfd);
  }
#line 14
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 14
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 14
      signal(13, sigpipe);
      }
    }
  }
#line 16
  return (result);
}
}
#line 22
sigjmp_buf gNetTimeoutJmp ;
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SClose.c"
int SClose(int sfd , int tlen ) 
{ 
  void (* volatile  sigalrm)(int  ) ;
  void (* volatile  sigpipe)(int  ) ;
  unsigned int volatile   oalarm ;
  int result ;
  int oerrno ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void (*tmp___9)(int  ) ;
  void (*tmp___10)(int  ) ;
  unsigned int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
#line 29
  sigalrm = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 30
  sigpipe = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 31
  oalarm = (unsigned int volatile   )0;
#line 35
  if (sfd < 0) {
    {
#line 36
    tmp = __errno_location();
#line 36
    *tmp = 9;
    }
#line 37
    return (-1);
  }
  {
#line 40
  tmp___1 = GetSocketLinger((int const   )sfd, (int */* const  */)((void *)0));
  }
#line 40
  if (tmp___1 <= 0) {
    {
#line 44
    tmp___0 = SCloseSocket(sfd);
    }
#line 44
    return (tmp___0);
  }
#line 47
  if (tlen < 1) {
    {
#line 49
    tmp___4 = SetSocketLinger((int const   )sfd, (int const   )0, (int const   )0);
    }
#line 49
    if (tmp___4 == 0) {
      {
#line 53
      tmp___2 = SCloseSocket(sfd);
      }
#line 53
      return (tmp___2);
    } else {
      {
#line 58
      shutdown(sfd, 2);
#line 59
      tmp___3 = SCloseSocket(sfd);
      }
#line 59
      return (tmp___3);
    }
  }
  {
#line 63
  tmp___8 = __sigsetjmp((struct __jmp_buf_tag *)(gNetTimeoutJmp), 1);
  }
#line 63
  if (tmp___8 != 0) {
    {
#line 64
    alarm(0U);
#line 65
    SetSocketLinger((int const   )sfd, (int const   )0, (int const   )0);
#line 66
    tmp___5 = __errno_location();
#line 66
    *tmp___5 = 0;
#line 67
    shutdown(sfd, 2);
#line 68
    result = close(sfd);
#line 69
    tmp___6 = __errno_location();
#line 69
    oerrno = *tmp___6;
#line 70
    SSignal(14, (void (*)(int  ))sigalrm);
#line 71
    SSignal(13, (void (*)(int  ))sigpipe);
#line 72
    alarm((unsigned int )oalarm);
#line 73
    tmp___7 = __errno_location();
#line 73
    *tmp___7 = oerrno;
    }
#line 74
    return (result);
  }
  {
#line 77
  tmp___9 = SSignal(14, & SIOHandler);
#line 77
  sigalrm = (void (*/* volatile  */)(int  ))tmp___9;
#line 78
  tmp___10 = SSignal(13, (void (*)(int  ))1);
#line 78
  sigpipe = (void (*/* volatile  */)(int  ))tmp___10;
#line 80
  tmp___11 = alarm((unsigned int )tlen);
#line 80
  oalarm = (unsigned int volatile   )tmp___11;
#line 81
  tmp___12 = __errno_location();
#line 81
  *tmp___12 = 0;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    result = close(sfd);
    }
#line 83
    if (result == 0) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp___13 = __errno_location();
    }
#line 85
    if (*tmp___13 != 4) {
#line 86
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  tmp___14 = __errno_location();
#line 88
  oerrno = *tmp___14;
#line 89
  alarm(0U);
  }
#line 91
  if (result != 0) {
    {
#line 91
    tmp___16 = __errno_location();
    }
#line 91
    if (*tmp___16 != 9) {
      {
#line 92
      SetSocketLinger((int const   )sfd, (int const   )0, (int const   )0);
#line 93
      shutdown(sfd, 2);
#line 94
      result = close(sfd);
#line 95
      tmp___15 = __errno_location();
#line 95
      oerrno = *tmp___15;
      }
    }
  }
  {
#line 98
  SSignal(14, (void (*)(int  ))sigalrm);
#line 99
  SSignal(13, (void (*)(int  ))sigpipe);
#line 100
  alarm((unsigned int )oalarm);
#line 101
  tmp___17 = __errno_location();
#line 101
  *tmp___17 = oerrno;
  }
#line 103
  return (result);
}
}
#line 892 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPFtw(FTPCIPtr const   cip , FtwInfoPtr const   ftwip , char const   * const  path ,
           int (*proc)(FtwInfoPtr const   ftwip ) ) ;
#line 911
void FTPPerror(FTPCIPtr const   cip , int const   err , int const   eerr , char const   * const  s1 ,
               char const   * const  s2 ) ;
#line 1055
int FTPRemoteRecursiveFileList(FTPCIPtr cip , FTPLineListPtr fileList , FTPFileInfoListPtr files ) ;
#line 1056
int FTPRemoteRecursiveFileList1(FTPCIPtr cip , char * const  rdir , FTPFileInfoListPtr files ) ;
#line 1057
int FTPRemoteFtwProc(FtwInfoPtr const   ftwip ) ;
#line 1091
int UnLslR(FTPCIPtr const   cip , FTPFileInfoListPtr filp , FTPLineListPtr llp , int serverType ) ;
#line 68 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglobr.c"
int FTPRemoteFtwProc(FtwInfoPtr const   ftwip ) 
{ 
  struct MyFtwExtraInfo *xinfop ;
  FTPCIPtr cip ;
  FTPFileInfo fi ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 71
  xinfop = (struct MyFtwExtraInfo *)ftwip->userdata;
#line 72
  cip = (FTPCIPtr )ftwip->cip;
#line 75
  if (xinfop->limitMaxDepth != 0UL) {
#line 75
    if (ftwip->depth >= xinfop->limitMaxDepth) {
      {
#line 76
      FTPLogError((FTPCIPtr const   )cip, (int const   )0, (char const   */* const  */)"Depth limit reached (%u dirs deep).\n",
                  (unsigned int )ftwip->depth);
      }
#line 77
      return (-1);
    }
  }
  {
#line 80
  InitFileInfo(& fi);
#line 81
  tmp___0 = strncmp((char const   *)ftwip->curPath, "./", (size_t )2);
  }
#line 81
  if (tmp___0 == 0) {
    {
#line 82
    fi.relnameLen = ftwip->curPathLen - 2UL;
#line 83
    fi.relname = StrDup((char const   *)(ftwip->curPath + 2));
    }
  } else {
    {
#line 84
    tmp = strcmp((char const   *)ftwip->curPath, ".");
    }
#line 84
    if (tmp == 0) {
#line 86
      return (0);
    } else {
      {
#line 88
      fi.relnameLen = ftwip->curPathLen;
#line 89
      fi.relname = StrDup((char const   *)ftwip->curPath);
      }
    }
  }
#line 91
  fi.rname = (char *)((void *)0);
#line 92
  fi.lname = (char *)((void *)0);
#line 93
  if ((unsigned long )ftwip->rlinkto == (unsigned long )((void *)0)) {
#line 93
    fi.rlinkto = (char *)((void *)0);
  } else {
    {
#line 93
    tmp___1 = StrDup(ftwip->rlinkto);
#line 93
    fi.rlinkto = tmp___1;
    }
  }
  {
#line 94
  fi.mdtm = ftwip->curStat.st_mtim.tv_sec;
#line 95
  fi.size = (long long )ftwip->curStat.st_size;
#line 96
  fi.type = ftwip->curType;
#line 97
  fi.mode = (int )ftwip->curStat.st_mode;
#line 98
  AddFileInfo(xinfop->fileList, & fi);
  }
#line 104
  if (xinfop->limitMaxDirs != 0UL) {
#line 104
    if (ftwip->numDirs >= xinfop->limitMaxDirs) {
      {
#line 105
      FTPLogError((FTPCIPtr const   )cip, (int const   )0, (char const   */* const  */)"Max subdirs limit (%u) reached.\n",
                  (unsigned int )ftwip->numDirs);
      }
#line 106
      return (-1);
    }
  }
#line 108
  if (xinfop->limitMaxFiles != 0UL) {
#line 108
    if (ftwip->numFiles >= xinfop->limitMaxFiles) {
      {
#line 109
      FTPLogError((FTPCIPtr const   )cip, (int const   )0, (char const   */* const  */)"Max files limit (%u) reached.\n",
                  (unsigned int )ftwip->numFiles);
      }
#line 110
      return (-1);
    }
  }
#line 112
  return (0);
}
}
#line 118 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglobr.c"
int FTPRemoteRecursiveFileList2(FTPCIPtr cip , char * const  rdir , FTPFileInfoListPtr files ) 
{ 
  int result ;
  char rcwd[512] ;
  FtwInfo ftwi ;
  struct MyFtwExtraInfo xinfo ;
  int tmp ;

  {
  {
#line 126
  result = FTPGetCWD((FTPCIPtr const   )cip, (char */* const  */)(rcwd), (size_t const   )sizeof(rcwd));
  }
#line 126
  if (result < 0) {
#line 127
    return (result);
  }
  {
#line 129
  InitFileInfoList(files);
  }
#line 131
  if ((unsigned long )rdir == (unsigned long )((void *)0)) {
#line 132
    return (-1);
  }
  {
#line 134
  tmp = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)rdir);
  }
#line 134
  if (tmp < 0) {
    {
#line 139
    ConcatFileToFileInfoList(files, (char *)rdir);
    }
#line 140
    return (0);
  }
  {
#line 143
  FtwInit((FtwInfo */* const  */)(& ftwi));
#line 145
  xinfo.limitMaxDirs = (size_t )0;
#line 146
  xinfo.limitMaxFiles = (size_t )0;
#line 147
  xinfo.limitMaxDepth = (size_t )50;
#line 148
  xinfo.fileList = files;
#line 149
  ftwi.userdata = (void *)(& xinfo);
#line 152
  result = FTPFtw((FTPCIPtr const   )cip, (FtwInfoPtr const   )(& ftwi), (char const   */* const  */)".",
                  & FTPRemoteFtwProc);
  }
#line 152
  if (result != 0) {
    {
#line 153
    FTPPerror((FTPCIPtr const   )cip, (int const   )cip->errNo, (int const   )-125,
              (char const   */* const  */)"Could not traverse directory", (char const   */* const  */)((void *)0));
#line 154
    result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)(rcwd));
    }
#line 154
    if (result < 0) {
#line 155
      rcwd[0] = (char )'\000';
    }
    {
#line 157
    FtwDispose((FtwInfo */* const  */)(& ftwi));
    }
#line 158
    return (result);
  }
  {
#line 160
  FtwDispose((FtwInfo */* const  */)(& ftwi));
#line 165
  ComputeRNames(files, (char const   *)rdir, 1, 1);
#line 167
  result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)(rcwd));
  }
#line 167
  if (result < 0) {
#line 168
    rcwd[0] = (char )'\000';
#line 169
    return (result);
  }
#line 171
  return (0);
}
}
#line 177 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglobr.c"
int FTPRemoteRecursiveFileList1(FTPCIPtr cip , char * const  rdir , FTPFileInfoListPtr files ) 
{ 
  FTPLineList dirContents ;
  FTPFileInfoList fil ;
  int result ;
  char rcwd[512] ;
  int tmp ;

  {
  {
#line 185
  result = FTPGetCWD((FTPCIPtr const   )cip, (char */* const  */)(rcwd), (size_t const   )sizeof(rcwd));
  }
#line 185
  if (result < 0) {
#line 186
    return (result);
  }
  {
#line 188
  InitFileInfoList(files);
  }
#line 190
  if ((unsigned long )rdir == (unsigned long )((void *)0)) {
#line 191
    return (-1);
  }
  {
#line 193
  tmp = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)rdir);
  }
#line 193
  if (tmp < 0) {
    {
#line 198
    ConcatFileToFileInfoList(files, (char *)rdir);
    }
#line 199
    return (0);
  }
  {
#line 203
  result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)"",
                            (FTPLineListPtr const   )(& dirContents), (char const   */* const  */)"-lRa",
                            (int const   )1, (int */* const  */)((int *)0));
  }
#line 203
  if (result < 0) {
    {
#line 204
    result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)(rcwd));
    }
#line 204
    if (result < 0) {
#line 205
      rcwd[0] = (char )'\000';
    }
#line 207
    return (result);
  }
  {
#line 241
  UnLslR((FTPCIPtr const   )cip, & fil, & dirContents, cip->serverType);
#line 242
  DisposeLineListContents(& dirContents);
#line 246
  ComputeRNames(& fil, (char const   *)rdir, 1, 1);
#line 247
  ConcatFileInfoList(files, & fil);
#line 248
  DisposeFileInfoListContents(& fil);
#line 250
  result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)(rcwd));
  }
#line 250
  if (result < 0) {
#line 251
    rcwd[0] = (char )'\000';
#line 252
    return (result);
  }
#line 254
  return (0);
}
}
#line 260 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglobr.c"
int FTPRemoteRecursiveFileList(FTPCIPtr cip , FTPLineListPtr fileList , FTPFileInfoListPtr files ) 
{ 
  FTPLinePtr filePtr ;
  FTPLinePtr nextFilePtr ;
  FTPLineList dirContents ;
  FTPFileInfoList fil ;
  int result ;
  char *rdir ;
  char rcwd[512] ;
  int tmp ;

  {
  {
#line 270
  result = FTPGetCWD((FTPCIPtr const   )cip, (char */* const  */)(rcwd), (size_t const   )sizeof(rcwd));
  }
#line 270
  if (result < 0) {
#line 271
    return (result);
  }
  {
#line 273
  InitFileInfoList(files);
#line 275
  filePtr = fileList->first;
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 275
      goto while_break;
    }
#line 279
    nextFilePtr = filePtr->next;
#line 281
    rdir = filePtr->line;
#line 282
    if ((unsigned long )rdir == (unsigned long )((void *)0)) {
#line 283
      goto __Cont;
    }
    {
#line 285
    tmp = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)rdir);
    }
#line 285
    if (tmp < 0) {
      {
#line 290
      ConcatFileToFileInfoList(files, rdir);
      }
#line 291
      goto __Cont;
    }
    {
#line 295
    result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)"",
                              (FTPLineListPtr const   )(& dirContents), (char const   */* const  */)"-lRa",
                              (int const   )1, (int */* const  */)((int *)0));
    }
#line 295
    if (result < 0) {
#line 296
      goto goback;
    }
    {
#line 299
    UnLslR((FTPCIPtr const   )cip, & fil, & dirContents, cip->serverType);
#line 300
    DisposeLineListContents(& dirContents);
#line 301
    ComputeRNames(& fil, (char const   *)rdir, 1, 1);
#line 302
    ConcatFileInfoList(files, & fil);
#line 303
    DisposeFileInfoListContents(& fil);
    }
    goback: 
    {
#line 306
    result = FTPChdir((FTPCIPtr const   )cip, (char const   */* const  */)(rcwd));
    }
#line 306
    if (result < 0) {
#line 307
      rcwd[0] = (char )'\000';
#line 308
      return (result);
    }
    __Cont: /* CIL Label */ 
#line 275
    filePtr = nextFilePtr;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (0);
}
}
#line 70 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.h"
void InitCommandList(void) ;
#line 71
CommandPtr GetCommandByIndex(int const   i___0 ) ;
#line 72
CommandPtr GetCommandByName(char const   * const  name , int wantExactMatch ) ;
#line 73
void PrintCmdHelp(CommandPtr c ) ;
#line 74
void PrintCmdUsage(CommandPtr c ) ;
#line 75
int MakeArgv(char *line , int *cargc , char **cargv , int cargcmax , char *dbuf ,
             size_t dbufsize , int *noglobargv , int readlineHacks , int fromReadln ) ;
#line 76
void XferCanceller(int sigNum ) ;
#line 77
void BackToTop(int sigNum ) ;
#line 78
void Cancel(int sigNum ) ;
#line 79
void CommandShell(void) ;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.h"
char *Readline(char *prompt ) ;
#line 20
void AddHistory(char const   * const  line ) ;
#line 22
void ( /* format attribute */  SetXtermTitle)(char const   * const  fmt  , ...) ;
#line 27
void MakePrompt(char *dst , size_t dsize ) ;
#line 10 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.h"
void CloseHost(void) ;
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gDoneApplication  =    0;
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gNumInterruptions  =    0;
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gEventNumber  =    0;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
sigjmp_buf gCancelJmp  ;
#line 43 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
sigjmp_buf gBackToTopJmp  ;
#line 57 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gMayCancelJmp  =    0;
#line 60 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gMayBackToTopJmp  =    0;
#line 63 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gGotSig  =    0;
#line 66 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gRunningCommand  =    0;
#line 69 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int gCancelCtrl  =    0;
#line 72 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
time_t gCmdStart  ;
#line 74
Command gCommands[65] ;
#line 75
size_t gNumCommands ;
#line 77
int gUserTypedSensitiveInfoAtShellSoDoNotSaveItToDisk ;
#line 78
char gStartDir[512] ;
#line 82 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
static int CommandSortCmp(CommandPtr const   a , CommandPtr const   b ) 
{ 
  int tmp ;

  {
  {
#line 85
  tmp = strcmp(a->name, b->name);
  }
#line 85
  return (tmp);
}
}
#line 92 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void InitCommandList(void) 
{ 


  {
  {
#line 95
  qsort((void *)(gCommands), gNumCommands, sizeof(Command ), (int (*)(void const   * ,
                                                                      void const   * ))(& CommandSortCmp));
  }
#line 96
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
static int CommandExactSearchCmp(char const   * const  key , CommandPtr const   b ) 
{ 
  int tmp ;

  {
  {
#line 107
  tmp = strcmp((char const   *)key, b->name);
  }
#line 107
  return (tmp);
}
}
#line 118 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
static int CommandSubSearchCmp(char const   * const  key , CommandPtr const   a ) 
{ 
  register char const   *kcp ;
  register char const   *cp ;
  int d ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 124
  cp = a->name;
#line 124
  kcp = (char const   *)key;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if ((int const   )*kcp == 0) {
#line 126
      goto while_break;
    }
#line 127
    tmp = kcp;
#line 127
    kcp ++;
#line 127
    tmp___0 = cp;
#line 127
    cp ++;
#line 127
    d = (int )((int const   )*tmp - (int const   )*tmp___0);
#line 128
    if (d) {
#line 129
      return (d);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return (0);
}
}
#line 142 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
CommandPtr GetCommandByIndex(int const   i___0 ) 
{ 


  {
#line 145
  if (i___0 < 0) {
#line 146
    return ((CommandPtr )0);
  } else
#line 145
  if (i___0 >= (int const   )((int )gNumCommands)) {
#line 146
    return ((CommandPtr )0);
  }
#line 147
  return (& gCommands[i___0]);
}
}
#line 158 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
CommandPtr GetCommandByName(char const   * const  name , int wantExactMatch ) 
{ 
  CommandPtr canp ;
  CommandPtr canp2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 167
  tmp = bsearch((void const   *)name, (void const   *)(gCommands), gNumCommands, sizeof(Command ),
                (int (*)(void const   * , void const   * ))(& CommandExactSearchCmp));
#line 167
  canp = (CommandPtr )tmp;
  }
#line 169
  if ((unsigned long )canp == (unsigned long )((CommandPtr )0)) {
#line 169
    if (! wantExactMatch) {
      {
#line 173
      tmp___0 = bsearch((void const   *)name, (void const   *)(gCommands), gNumCommands,
                        sizeof(Command ), (int (*)(void const   * , void const   * ))(& CommandSubSearchCmp));
#line 173
      canp = (CommandPtr )tmp___0;
      }
#line 175
      if ((unsigned long )canp != (unsigned long )((CommandPtr )0)) {
#line 179
        if ((unsigned long )canp != (unsigned long )(& gCommands[0])) {
          {
#line 180
          canp2 = canp - 1;
#line 181
          tmp___1 = CommandSubSearchCmp(name, (CommandPtr const   )canp2);
          }
#line 181
          if (tmp___1 == 0) {
#line 182
            return ((CommandPtr )-1);
          }
        }
#line 187
        if ((unsigned long )canp != (unsigned long )(& gCommands[gNumCommands - 1UL])) {
          {
#line 188
          canp2 = canp + 1;
#line 189
          tmp___2 = CommandSubSearchCmp(name, (CommandPtr const   )canp2);
          }
#line 189
          if (tmp___2 == 0) {
#line 190
            return ((CommandPtr )-1);
          }
        }
      }
    }
  }
#line 194
  return (canp);
}
}
#line 202 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void PrintCmdHelp(CommandPtr c ) 
{ 


  {
  {
#line 205
  printf((char const   */* __restrict  */)"%s: %s.\n", c->name, c->help);
  }
#line 206
  return;
}
}
#line 212 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void PrintCmdUsage(CommandPtr c ) 
{ 


  {
#line 215
  if ((unsigned long )c->usage != (unsigned long )((void *)0)) {
    {
#line 216
    printf((char const   */* __restrict  */)"Usage: %s %s\n", c->name, c->usage);
    }
  }
#line 217
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
int MakeArgv(char *line , int *cargc , char **cargv , int cargcmax , char *dbuf ,
             size_t dbufsize , int *noglobargv , int readlineHacks , int fromReadln ) 
{ 
  int c ;
  int retval ;
  char *dlim ;
  char *dcp ;
  char *scp ;
  char const   *vcp ;
  char *arg ;
  CommandPtr cmdp ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 235
  *cargc = 0;
#line 236
  scp = line;
#line 237
  dlim = (dbuf + dbufsize) - 1;
#line 238
  dcp = dbuf;
#line 239
  memset((void *)dbuf, 0, dbufsize);
#line 241
  *cargc = 0;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (*cargc < cargcmax)) {
#line 241
      goto while_break;
    }
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      c = (int )*scp;
#line 245
      if (c == 0) {
#line 246
        goto done;
      }
      {
#line 247
      tmp = __ctype_b_loc();
      }
#line 247
      if ((int const   )*(*tmp + c) & 8192) {
#line 248
        goto __Cont;
      }
#line 249
      if (c == 59) {
#line 250
        scp ++;
#line 251
        goto done;
      } else
#line 249
      if (c == 10) {
#line 250
        scp ++;
#line 251
        goto done;
      }
#line 253
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 243
      scp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    arg = dcp;
#line 257
    *(cargv + *cargc) = arg;
#line 258
    *(noglobargv + *cargc) = 0;
#line 259
    (*cargc) ++;
#line 262
    if (*cargc == 1) {
#line 262
      if ((int )*scp == 33) {
#line 263
        if ((int )*(scp + 1) == 33) {
#line 264
          *(scp + 1) = (char )'\000';
        } else
#line 265
        if ((int )*(scp + 1) != 0) {
          {
#line 265
          tmp___3 = __ctype_b_loc();
          }
#line 265
          if (! ((int const   )*(*tmp___3 + (int )*(scp + 1)) & 8192)) {
#line 266
            if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 267
              goto toolong;
            }
#line 268
            tmp___0 = dcp;
#line 268
            dcp ++;
#line 268
            tmp___1 = scp;
#line 268
            scp ++;
#line 268
            *tmp___0 = *tmp___1;
#line 269
            if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 270
              goto toolong;
            }
#line 271
            tmp___2 = dcp;
#line 271
            dcp ++;
#line 271
            *tmp___2 = (char )'\000';
#line 272
            goto __Cont___0;
          }
        }
      }
    }
#line 277
    if (*cargc > 1) {
#line 277
      if (fromReadln == 0) {
#line 277
        if ((int )*(scp + 0) == 126) {
#line 277
          if ((int )*(scp + 1) == 0) {
#line 277
            goto _L___0;
          } else
#line 277
          if ((int )*(scp + 1) == 47) {
#line 277
            goto _L___0;
          } else {
            {
#line 277
            tmp___6 = __ctype_b_loc();
            }
#line 277
            if ((int const   )*(*tmp___6 + (int )*(scp + 1)) & 8192) {
              _L___0: /* CIL Label */ 
              {
#line 278
              scp ++;
#line 279
              vcp = (char const   *)((void *)0);
#line 280
              cmdp = GetCommandByName((char const   */* const  */)*(cargv + 0), 0);
              }
#line 281
              if ((unsigned long )cmdp != (unsigned long )((CommandPtr )-1)) {
#line 281
                if ((unsigned long )cmdp != (unsigned long )((CommandPtr )0)) {
#line 282
                  if ((cmdp->flags & 24) != 0) {
#line 282
                    if ((int )gStartDir[0] != 0) {
#line 283
                      vcp = (char const   *)(gStartDir);
                    } else {
#line 282
                      goto _L;
                    }
                  } else
                  _L: /* CIL Label */ 
#line 284
                  if ((cmdp->flags & 96) != 0) {
#line 284
                    if ((int )gHome[0] != 0) {
#line 285
                      vcp = (char const   *)(gHome);
                    }
                  }
                }
              }
#line 288
              if ((unsigned long )vcp != (unsigned long )((void *)0)) {
                {
#line 289
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 289
                  if (! ((int const   )*vcp != 0)) {
#line 289
                    goto while_break___1;
                  }
#line 290
                  if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 291
                    goto toolong;
                  }
#line 292
                  tmp___4 = dcp;
#line 292
                  dcp ++;
#line 292
                  tmp___5 = vcp;
#line 292
                  vcp ++;
#line 292
                  *tmp___4 = (char )*tmp___5;
                }
                while_break___1: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
    {
#line 298
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 299
      c = (int )*scp;
#line 300
      if (c == 0) {
#line 301
        goto while_break___2;
      }
      {
#line 302
      tmp___7 = __ctype_b_loc();
      }
#line 302
      if ((int const   )*(*tmp___7 + c) & 8192) {
#line 303
        goto while_break___2;
      }
#line 304
      if (c == 59) {
#line 305
        goto while_break___2;
      } else
#line 304
      if (c == 10) {
#line 305
        goto while_break___2;
      }
#line 308
      scp ++;
#line 310
      if (c == 39) {
        {
#line 311
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 312
          tmp___8 = scp;
#line 312
          scp ++;
#line 312
          c = (int )*tmp___8;
#line 313
          if (c == 0) {
#line 314
            if (readlineHacks != 0) {
#line 315
              goto while_break___3;
            }
            {
#line 317
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unbalanced quotes.\n");
            }
#line 318
            return (-1);
          }
#line 320
          if (c == 39) {
#line 321
            goto while_break___3;
          }
#line 324
          if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 325
            goto toolong;
          }
          {
#line 326
          tmp___9 = dcp;
#line 326
          dcp ++;
#line 326
          *tmp___9 = (char )c;
#line 328
          tmp___10 = strchr("[*?", c);
          }
#line 328
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 333
            *(noglobargv + (*cargc - 1)) = 1;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 336
      if (c == 34) {
        {
#line 337
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 338
          tmp___11 = scp;
#line 338
          scp ++;
#line 338
          c = (int )*tmp___11;
#line 339
          if (c == 0) {
#line 340
            if (readlineHacks != 0) {
#line 341
              goto while_break___4;
            }
            {
#line 343
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unbalanced quotes.\n");
            }
#line 344
            return (-1);
          }
#line 346
          if (c == 34) {
#line 347
            goto while_break___4;
          }
#line 350
          if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 351
            goto toolong;
          }
          {
#line 352
          tmp___12 = dcp;
#line 352
          dcp ++;
#line 352
          *tmp___12 = (char )c;
#line 354
          tmp___13 = strchr("[*?", c);
          }
#line 354
          if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 359
            *(noglobargv + (*cargc - 1)) = 1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 366
      if (c == 92) {
#line 369
        tmp___14 = scp;
#line 369
        scp ++;
#line 369
        c = (int )*tmp___14;
#line 370
        if (c == 0) {
#line 371
          goto while_break___2;
        }
#line 374
        if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 375
          goto toolong;
        }
#line 376
        tmp___15 = dcp;
#line 376
        dcp ++;
#line 376
        *tmp___15 = (char )c;
      } else {
#line 379
        if ((unsigned long )dcp >= (unsigned long )dlim) {
#line 380
          goto toolong;
        }
#line 381
        tmp___16 = dcp;
#line 381
        dcp ++;
#line 381
        *tmp___16 = (char )c;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 385
    tmp___17 = dcp;
#line 385
    dcp ++;
#line 385
    *tmp___17 = (char )'\000';
    __Cont___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 388
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Argument list too long.\n");
#line 389
  *cargc = 0;
#line 390
  *(cargv + *cargc) = (char *)((void *)0);
  }
#line 391
  return (-1);
  done: 
#line 394
  retval = (int )(scp - line);
#line 395
  *(cargv + *cargc) = (char *)((void *)0);
#line 396
  return (retval);
  toolong: 
  {
#line 399
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Line too long.\n");
#line 400
  *cargc = 0;
#line 401
  *(cargv + *cargc) = (char *)((void *)0);
  }
#line 402
  return (-1);
}
}
#line 408 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
static int DoCommand(ArgvInfoPtr const   aip ) 
{ 
  CommandPtr cmdp ;
  int flags___0 ;
  int cargc ;
  int cargcm1 ;

  {
  {
#line 415
  cmdp = GetCommandByName((char const   */* const  */)aip->cargv[0], 0);
  }
#line 416
  if ((unsigned long )cmdp == (unsigned long )((CommandPtr )-1)) {
    {
#line 417
    printf((char const   */* __restrict  */)"%s: ambiguous command name.\n", aip->cargv[0]);
    }
#line 418
    return (-1);
  } else
#line 419
  if ((unsigned long )cmdp == (unsigned long )((CommandPtr )0)) {
    {
#line 420
    printf((char const   */* __restrict  */)"%s: no such command.\n", aip->cargv[0]);
    }
#line 421
    return (-1);
  }
#line 424
  cargc = aip->cargc;
#line 425
  cargcm1 = cargc - 1;
#line 426
  flags___0 = cmdp->flags;
#line 428
  if ((flags___0 & 2) != 0) {
#line 428
    if (gConn.connected == 0) {
      {
#line 429
      printf((char const   */* __restrict  */)"%s: must be connected to do that.\n",
             aip->cargv[0]);
      }
    } else {
#line 428
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 430
  if ((flags___0 & 4) != 0) {
#line 430
    if (gConn.connected != 0) {
      {
#line 431
      printf((char const   */* __restrict  */)"%s: must be disconnected to do that.\n",
             aip->cargv[0]);
      }
    } else {
#line 430
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 432
  if (cmdp->minargs != -1) {
#line 432
    if (cmdp->minargs > cargcm1) {
      {
#line 433
      PrintCmdUsage(cmdp);
      }
    } else {
#line 432
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 434
  if (cmdp->maxargs != -1) {
#line 434
    if (cmdp->maxargs < cargcm1) {
      {
#line 435
      PrintCmdUsage(cmdp);
      }
    } else {
      {
#line 437
      (*(cmdp->proc))((int const   )cargc, (char **/* const  */)(aip->cargv), (CommandPtr const   )cmdp,
                      aip);
      }
    }
  } else {
    {
#line 437
    (*(cmdp->proc))((int const   )cargc, (char **/* const  */)(aip->cargv), (CommandPtr const   )cmdp,
                    aip);
    }
  }
#line 439
  return (0);
}
}
#line 446 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void XferCanceller(int sigNum ) 
{ 


  {
#line 449
  gGotSig = sigNum;
#line 450
  if (gConn.cancelXfer > 0) {
#line 460
    gCancelCtrl = 1;
#line 461
    if (gMayBackToTopJmp > 0) {
      {
#line 463
      siglongjmp((struct __jmp_buf_tag *)(gBackToTopJmp), 1);
      }
    }
  }
#line 470
  (gConn.cancelXfer) ++;
#line 471
  return;
}
}
#line 479 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void BackToTop(int sigNum ) 
{ 


  {
#line 482
  gGotSig = sigNum;
#line 483
  if (sigNum == 13) {
#line 484
    if (gRunningCommand == 1) {
      {
#line 485
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected broken pipe.\n");
#line 486
      gRunningCommand = 0;
      }
    } else {
      {
#line 488
      SetXtermTitle((char const   */* const  */)"RESTORE");
#line 489
      exit(1);
      }
    }
  } else
#line 491
  if (sigNum == 2) {
#line 492
    if (gRunningCommand == 0) {
#line 493
      gDoneApplication = 1;
    }
  }
#line 495
  if (gMayBackToTopJmp > 0) {
    {
#line 497
    siglongjmp((struct __jmp_buf_tag *)(gBackToTopJmp), 1);
    }
  }
#line 502
  return;
}
}
#line 508 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void Cancel(int sigNum ) 
{ 


  {
#line 511
  if (gMayCancelJmp != 0) {
    {
#line 512
    gGotSig = sigNum;
#line 513
    gMayCancelJmp = 0;
#line 515
    siglongjmp((struct __jmp_buf_tag *)(gCancelJmp), 1);
    }
  }
#line 520
  return;
}
}
#line 526 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/shell.c"
void CommandShell(void) 
{ 
  int tUsed ;
  int bUsed ;
  ArgvInfo ai ;
  char prompt[64] ;
  char *lineRead ;
  char *l2 ;
  size_t llen ;
  int sj ;
  time_t cmdStop ;
  int oldcount ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 545
  sj = __sigsetjmp((struct __jmp_buf_tag *)(gBackToTopJmp), 1);
  }
#line 552
  if (sj != 0) {
    {
#line 553
    Trace((int const   )0, (char const   */* const  */)"Caught signal %d, back at top.\n",
          gGotSig);
    }
#line 554
    if (gGotSig == 14) {
      {
#line 555
      printf((char const   */* __restrict  */)"\nRemote host was not responding, closing down the session.");
#line 556
      FTPShutdownHost((FTPCIPtr const   )(& gConn));
      }
    } else {
      {
#line 558
      printf((char const   */* __restrict  */)"\nInterrupted.\n");
      }
#line 559
      if (gCancelCtrl != 0) {
        {
#line 560
        gCancelCtrl = 0;
#line 561
        printf((char const   */* __restrict  */)"Closing down the current FTP session: ");
#line 562
        FTPShutdownHost((FTPCIPtr const   )(& gConn));
#line 563
        sleep(1U);
#line 564
        printf((char const   */* __restrict  */)"done.\n");
        }
      }
    }
  }
#line 569
  gMayBackToTopJmp = 1;
#line 573
  gEventNumber ++;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! (gDoneApplication == 0)) {
#line 575
      goto while_break;
    }
    {
#line 578
    NcSignal(2, & BackToTop);
#line 579
    NcSignal(13, & BackToTop);
#line 580
    NcSignal(14, & BackToTop);
#line 583
    MakePrompt(prompt, sizeof(prompt));
    }
#line 585
    if (gConn.connected == 0) {
      {
#line 586
      SetXtermTitle((char const   */* const  */)"DEFAULT");
      }
    } else {
      {
#line 588
      SetXtermTitle((char const   */* const  */)"%s - NcFTP", gConn.host);
      }
    }
    {
#line 591
    lineRead = Readline(prompt);
    }
#line 592
    if ((unsigned long )lineRead == (unsigned long )((void *)0)) {
      {
#line 594
      printf((char const   */* __restrict  */)"\n");
      }
#line 595
      goto while_break;
    }
#line 597
    if ((int )*(lineRead + 0) == 46) {
#line 597
      goto _L;
    } else
#line 597
    if ((int )*(lineRead + 0) == 47) {
      _L: /* CIL Label */ 
      {
#line 598
      tmp = strlen((char const   *)lineRead);
#line 598
      llen = tmp + 1UL;
#line 599
      tmp___0 = malloc((llen + 3UL) + 1UL);
#line 599
      l2 = (char *)tmp___0;
      }
#line 600
      if ((unsigned long )l2 == (unsigned long )((void *)0)) {
#line 601
        goto while_break;
      }
      {
#line 602
      memcpy((void */* __restrict  */)l2, (void const   */* __restrict  */)"cd ",
             (size_t )4);
#line 603
      memcpy((void */* __restrict  */)(l2 + 3), (void const   */* __restrict  */)lineRead,
             llen);
#line 604
      free((void *)lineRead);
#line 605
      lineRead = l2;
      }
    }
    {
#line 607
    Trace((int const   )0, (char const   */* const  */)"> %s\n", lineRead);
#line 608
    oldcount = gUserTypedSensitiveInfoAtShellSoDoNotSaveItToDisk;
#line 609
    tUsed = 0;
    }
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 610
      memset((void *)(& ai), 0, sizeof(ai));
#line 611
      bUsed = MakeArgv(lineRead + tUsed, & ai.cargc, ai.cargv, (int )(sizeof(ai.cargv) / sizeof(char *)),
                       ai.argbuf, sizeof(ai.argbuf), ai.noglobargv, 0, 0);
      }
#line 615
      if (bUsed <= 0) {
#line 616
        goto while_break___0;
      }
#line 617
      tUsed += bUsed;
#line 618
      if (ai.cargc == 0) {
#line 619
        goto __Cont;
      }
      {
#line 620
      gRunningCommand = 1;
#line 621
      time(& gCmdStart);
#line 622
      tmp___1 = DoCommand((ArgvInfoPtr const   )(& ai));
      }
#line 622
      if (tmp___1 < 0) {
        {
#line 623
        time(& cmdStop);
#line 624
        gRunningCommand = 0;
        }
#line 625
        goto while_break___0;
      }
      {
#line 627
      time(& cmdStop);
#line 628
      gRunningCommand = 0;
      }
#line 629
      if (cmdStop - gCmdStart > 15L) {
        {
#line 636
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\a");
        }
      }
#line 639
      gEventNumber ++;
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 642
    if (oldcount == gUserTypedSensitiveInfoAtShellSoDoNotSaveItToDisk) {
      {
#line 643
      AddHistory((char const   */* const  */)lineRead);
      }
    } else {
      {
#line 645
      AddHistory((char const   */* const  */)"(line omitted from history because it contained sensitive information)");
      }
    }
    {
#line 646
    free((void *)lineRead);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 649
  CloseHost();
#line 650
  gMayBackToTopJmp = 0;
  }
#line 651
  return;
}
}
#line 72 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char const   *DStrCpy(DStr * const  dst , char const   * const  src ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrCpy.c"
char const   *DStrCpy(DStr * const  dst , char const   * const  src ) 
{ 
  size_t srcLen ;
  size_t allocSize ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 12
  if (((long )dst->s & 1L) != 0L) {
#line 13
    return ((char const   *)((void *)0));
  } else
#line 12
  if ((dst->allocSize & 4278190095UL) != 0UL) {
#line 13
    return ((char const   *)((void *)0));
  } else
#line 12
  if ((dst->len & 4278190080UL) != 0UL) {
#line 13
    return ((char const   *)((void *)0));
  }
#line 15
  if ((unsigned long )dst->s == (unsigned long )src) {
#line 16
    return ((char const   *)dst->s);
  }
  {
#line 18
  tmp = strlen((char const   *)src);
#line 18
  srcLen = tmp + 1UL;
  }
#line 19
  if (srcLen > 16777215UL) {
#line 20
    return ((char const   *)((void *)0));
  }
#line 21
  if (dst->allocSize < srcLen) {
#line 23
    allocSize = (srcLen + 16UL) & 4294967280UL;
#line 24
    if ((unsigned long )dst->s == (unsigned long )((void *)0)) {
      {
#line 25
      tmp___0 = calloc(allocSize, (size_t )1);
#line 25
      cp = (char *)tmp___0;
      }
#line 26
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 27
        return ((char const   *)((void *)0));
      }
    } else {
      {
#line 29
      tmp___1 = realloc((void *)dst->s, allocSize);
#line 29
      cp = (char *)tmp___1;
      }
#line 30
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 31
        return ((char const   *)((void *)0));
      }
      {
#line 32
      memset((void *)cp, 0, allocSize);
      }
    }
#line 34
    dst->s = cp;
#line 35
    dst->allocSize = allocSize;
  } else {
#line 37
    cp = dst->s;
  }
  {
#line 40
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)src, srcLen);
#line 41
  dst->len = srcLen - 1UL;
  }
#line 42
  return ((char const   *)cp);
}
}
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 1067 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void FTPGetDateStr(time_t t , char const   *fmt , char * const  ltstr1 , size_t const   ltstr1size ,
                   char * const  gtstr1 , size_t const   gtstr1size ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_miscdebug.c"
void FTPGetDateStr(time_t t , char const   *fmt , char * const  ltstr1 , size_t const   ltstr1size ,
                   char * const  gtstr1 , size_t const   gtstr1size ) 
{ 
  char ltstr[64] ;
  char gtstr[64] ;
  struct tm *ltp ;
  struct tm *gtp ;

  {
#line 21
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 26
    fmt = "%a, %d %b %Y %H:%M:%S %z %Z";
  }
  {
#line 29
  memset((void *)(gtstr), 0, sizeof(gtstr));
#line 30
  memset((void *)(ltstr), 0, sizeof(ltstr));
  }
#line 31
  if ((unsigned long )ltstr1 != (unsigned long )((void *)0)) {
#line 31
    if (ltstr1size != 0UL) {
      {
#line 32
      memset((void *)ltstr1, 0, (size_t )ltstr1size);
      }
    }
  }
#line 33
  if ((unsigned long )gtstr1 != (unsigned long )((void *)0)) {
#line 33
    if (gtstr1size != 0UL) {
      {
#line 34
      memset((void *)gtstr1, 0, (size_t )gtstr1size);
      }
    }
  }
#line 36
  if (t == 0L) {
    {
#line 37
    time(& t);
    }
#line 38
    if (t == 0L) {
#line 40
      return;
    } else
#line 38
    if (t == -1L) {
#line 40
      return;
    }
  }
  {
#line 44
  gtp = gmtime((time_t const   *)(& t));
  }
#line 44
  if ((unsigned long )gtp != (unsigned long )((void *)0)) {
    {
#line 45
    strftime((char */* __restrict  */)(gtstr), sizeof(gtstr) - 1UL, (char const   */* __restrict  */)fmt,
             (struct tm  const  */* __restrict  */)gtp);
    }
#line 46
    if ((unsigned long )gtstr1 != (unsigned long )((void *)0)) {
#line 46
      if (gtstr1size != 0UL) {
        {
#line 47
        Strncpy(gtstr1, (char const   */* const  */)(gtstr), gtstr1size);
        }
      }
    }
  }
  {
#line 50
  ltp = localtime((time_t const   *)(& t));
  }
#line 50
  if ((unsigned long )ltp != (unsigned long )((void *)0)) {
    {
#line 51
    strftime((char */* __restrict  */)(ltstr), sizeof(ltstr) - 1UL, (char const   */* __restrict  */)fmt,
             (struct tm  const  */* __restrict  */)ltp);
    }
#line 52
    if ((unsigned long )ltstr1 != (unsigned long )((void *)0)) {
#line 52
      if (ltstr1size != 0UL) {
        {
#line 53
        Strncpy(ltstr1, (char const   */* const  */)(ltstr), ltstr1size);
        }
      }
    }
  }
#line 55
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Dynsrecpy(char **dst  , ...) ;
#line 51
void StrFree(char **dst ) ;
#line 137 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
void RemoteGlobCollapse(FTPCIPtr const   cip , char const   *pattern , FTPLineListPtr fileList ) ;
#line 138
int PathContainsIntermediateDotDotSubDir(char const   *s ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglob.c"
static void StripUnneccesaryGlobEntries(FTPCIPtr const   cip , FTPLineListPtr fileList ) 
{ 
  FTPLinePtr lp ;
  FTPLinePtr nextLine ;
  char const   *cp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 22
  lp = fileList->first;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 22
      goto while_break;
    }
    {
#line 23
    nextLine = lp->next;
#line 24
    tmp = strrchr((char const   *)lp->line, '/');
#line 24
    cp = (char const   *)tmp;
    }
#line 25
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 26
      tmp___0 = strrchr((char const   *)lp->line, '\\');
#line 26
      cp = (char const   *)tmp___0;
      }
    }
#line 27
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 28
      cp = (char const   *)lp->line;
    } else {
#line 30
      cp ++;
    }
    {
#line 31
    tmp___1 = strcmp(cp, ".");
    }
#line 31
    if (tmp___1 == 0) {
      {
#line 32
      PrintF(cip, (char const   */* const  */)"  Rglob omitted: [%s] (type 1)\n",
             lp->line);
#line 33
      nextLine = RemoveLine(fileList, lp);
      }
    } else {
      {
#line 31
      tmp___2 = strcmp(cp, "..");
      }
#line 31
      if (tmp___2 == 0) {
        {
#line 32
        PrintF(cip, (char const   */* const  */)"  Rglob omitted: [%s] (type 1)\n",
               lp->line);
#line 33
        nextLine = RemoveLine(fileList, lp);
        }
      }
    }
#line 22
    lp = nextLine;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 40 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglob.c"
int PathContainsIntermediateDotDotSubDir(char const   *s ) 
{ 
  int c ;
  char const   *a ;
  char const   *tmp ;

  {
#line 46
  if ((int const   )*(s + 0) == 46) {
#line 46
    if ((int const   )*(s + 1) == 46) {
#line 47
      a = s + 2;
      {
#line 48
      while (1) {
        while_continue: /* CIL Label */ ;
#line 48
        if (! ((int const   )*a == 46)) {
#line 48
          goto while_break;
        }
#line 48
        a ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 49
      if ((int const   )*a == 47) {
#line 50
        return (1);
      } else
#line 49
      if ((int const   )*a == 92) {
#line 50
        return (1);
      } else
#line 49
      if ((int const   )*a == 0) {
#line 50
        return (1);
      }
    }
  }
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (! ((int const   )*s != 0)) {
#line 53
      goto while_break___0;
    }
#line 54
    tmp = s;
#line 54
    s ++;
#line 54
    c = (int )*tmp;
#line 55
    if (c == 47) {
#line 55
      goto _L;
    } else
#line 55
    if (c == 92) {
      _L: /* CIL Label */ 
#line 55
      if ((int const   )*(s + 0) == 46) {
#line 55
        if ((int const   )*(s + 1) == 46) {
#line 56
          a = s + 2;
          {
#line 63
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 63
            if (! ((int const   )*a == 46)) {
#line 63
              goto while_break___1;
            }
#line 63
            a ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 64
          if ((int const   )*a == 47) {
#line 65
            return (1);
          } else
#line 64
          if ((int const   )*a == 92) {
#line 65
            return (1);
          } else
#line 64
          if ((int const   )*a == 0) {
#line 65
            return (1);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  return (0);
}
}
#line 103 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglob.c"
void RemoteGlobCollapse(FTPCIPtr const   cip , char const   *pattern , FTPLineListPtr fileList ) 
{ 
  FTPLinePtr lp ;
  FTPLinePtr nextLine ;
  char *patPrefix ;
  char *patDir ;
  char *cur ;
  char *prev___3 ;
  char *cp ;
  char *newpath ;
  size_t plen ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 115
  patDir = (char *)((void *)0);
#line 116
  cp = strrchr(pattern, '/');
  }
#line 117
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 118
    patDir = StrDup(pattern);
    }
#line 119
    if ((unsigned long )patDir == (unsigned long )((void *)0)) {
#line 120
      return;
    }
#line 121
    *(patDir + ((cp - (char *)pattern) + 1L)) = (char )'\000';
  }
  {
#line 125
  cp = strpbrk(pattern, "[*?");
#line 126
  patPrefix = StrDup(pattern);
  }
#line 127
  if ((unsigned long )patPrefix == (unsigned long )((void *)0)) {
    {
#line 128
    free((void *)patDir);
    }
#line 129
    return;
  }
#line 131
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 132
    plen = (size_t )(cp - (char *)pattern);
#line 133
    *(patPrefix + plen) = (char )'\000';
  } else {
    {
#line 135
    plen = strlen((char const   *)patPrefix);
    }
  }
#line 138
  prev___3 = (char *)((void *)0);
#line 138
  cur = prev___3;
#line 139
  lp = fileList->first;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 139
      goto while_break;
    }
    {
#line 140
    nextLine = lp->next;
#line 141
    tmp___5 = strncasecmp((char const   *)lp->line, (char const   *)patPrefix, plen);
    }
#line 141
    if (tmp___5 == 0) {
      {
#line 142
      tmp = Dynsrecpy(& cur, lp->line + plen, 0);
      }
#line 142
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 143
        goto done;
      }
      {
#line 144
      cp = strpbrk((char const   *)cur, "/\\");
      }
#line 145
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 146
        *cp = (char )'\000';
      }
#line 147
      if ((unsigned long )prev___3 != (unsigned long )((void *)0)) {
        {
#line 147
        tmp___2 = strcmp((char const   *)cur, (char const   *)prev___3);
        }
#line 147
        if (tmp___2 == 0) {
          {
#line 148
          PrintF(cip, (char const   */* const  */)"  Rglob omitted: [%s] (type 2)\n",
                 lp->line);
#line 149
          nextLine = RemoveLine(fileList, lp);
          }
        } else {
#line 147
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 150
        tmp___1 = PathContainsIntermediateDotDotSubDir((char const   *)(lp->line + plen));
        }
#line 150
        if (tmp___1) {
          {
#line 151
          PrintF(cip, (char const   */* const  */)"  Rglob omitted: [%s] (type 3)\n",
                 lp->line);
#line 152
          nextLine = RemoveLine(fileList, lp);
          }
        } else {
          {
#line 154
          tmp___0 = Dynsrecpy(& prev___3, cur, 0);
          }
#line 154
          if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 155
            goto done;
          }
          {
#line 163
          sprintf((char */* __restrict  */)lp->line, (char const   */* __restrict  */)"%s%s",
                  patPrefix, cur);
          }
        }
      }
    } else {
      {
#line 165
      tmp___4 = strpbrk((char const   *)lp->line, "/\\");
      }
#line 165
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 166
        if ((unsigned long )patDir != (unsigned long )((void *)0)) {
          {
#line 167
          newpath = (char *)((void *)0);
#line 168
          tmp___3 = Dynsrecpy(& newpath, patDir, lp->line, 0);
          }
#line 168
          if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 169
            goto done;
          }
          {
#line 170
          PrintF(cip, (char const   */* const  */)"  Rglob changed: [%s] to [%s]\n",
                 lp->line, newpath);
#line 171
          free((void *)lp->line);
#line 172
          lp->line = newpath;
          }
        }
      } else {
        {
#line 175
        PrintF(cip, (char const   */* const  */)"  Rglob omitted: [%s] (type 4)\n",
               lp->line);
#line 176
        nextLine = RemoveLine(fileList, lp);
        }
      }
    }
#line 139
    lp = nextLine;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
#line 181
  StrFree(& patDir);
#line 182
  StrFree(& patPrefix);
#line 183
  StrFree(& cur);
#line 184
  StrFree(& prev___3);
  }
#line 185
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rglob.c"
int FTPRemoteGlob(FTPCIPtr cip , FTPLineListPtr fileList , char const   *pattern ,
                  int doGlob ) 
{ 
  char *cp ;
  char const   *lsflags ;
  FTPLinePtr lp ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  FTPLinePtr tmp___7 ;
  char *tmp___8 ;

  {
#line 198
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 199
    return (-139);
  }
  {
#line 200
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 200
  if (tmp) {
#line 201
    return (-138);
  }
#line 203
  if ((unsigned long )fileList == (unsigned long )((void *)0)) {
#line 204
    return (-139);
  }
  {
#line 205
  InitLineList(fileList);
  }
#line 207
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
#line 208
    return (-139);
  } else
#line 207
  if ((int const   )*(pattern + 0) == 0) {
#line 208
    return (-139);
  }
#line 214
  if (doGlob == 1) {
    {
#line 214
    tmp___8 = strpbrk(pattern, "[*?");
    }
#line 214
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
      {
#line 216
      lsflags = "";
#line 219
      tmp___1 = strcmp(pattern, "*");
      }
#line 219
      if (tmp___1 == 0) {
#line 220
        pattern = "";
#line 221
        if (cip->hasNLST_a == 0) {
#line 221
          lsflags = "";
        } else {
#line 221
          lsflags = "-a";
        }
      } else {
        {
#line 222
        tmp___0 = strcmp(pattern, "**");
        }
#line 222
        if (tmp___0 == 0) {
#line 229
          pattern = "";
#line 230
          if (cip->hasNLST_a == 0) {
#line 230
            lsflags = "";
          } else {
#line 230
            lsflags = "-a";
          }
        }
      }
      {
#line 233
      result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)pattern,
                                (FTPLineListPtr const   )fileList, (char const   */* const  */)lsflags,
                                (int const   )0, (int */* const  */)((int *)0));
      }
#line 233
      if (result < 0) {
#line 234
        if ((int const   )*lsflags == 0) {
#line 235
          return (result);
        }
        {
#line 236
        tmp___2 = strchr(lsflags, 'a');
        }
#line 236
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          {
#line 238
          cip->hasNLST_a = 0;
#line 239
          lsflags = "";
#line 240
          result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)pattern,
                                    (FTPLineListPtr const   )fileList, (char const   */* const  */)lsflags,
                                    (int const   )0, (int */* const  */)((int *)0));
          }
#line 240
          if (result < 0) {
#line 241
            return (result);
          }
        } else {
#line 245
          return (result);
        }
      }
#line 261
      if ((unsigned long )fileList->first == (unsigned long )((void *)0)) {
#line 262
        cip->errNo = -172;
#line 263
        return (-172);
      }
#line 265
      if ((unsigned long )fileList->first == (unsigned long )fileList->last) {
        {
#line 270
        cp = strchr((char const   *)(fileList->first)->line, ':');
        }
#line 271
        if ((unsigned long )cp != (unsigned long )((void *)0)) {
          {
#line 272
          tmp___5 = strlen(": No such file or directory");
#line 272
          tmp___6 = strncasecmp((char const   *)cp, ": No such file or directory",
                                tmp___5);
          }
#line 272
          if (tmp___6 == 0) {
            {
#line 273
            RemoveLine(fileList, fileList->first);
#line 274
            cip->errNo = -151;
            }
#line 275
            return (-151);
          } else {
            {
#line 276
            tmp___3 = strlen(": No match");
#line 276
            tmp___4 = strncasecmp((char const   *)cp, ": No match", tmp___3);
            }
#line 276
            if (tmp___4 == 0) {
#line 277
              cip->errNo = -172;
#line 278
              return (-172);
            }
          }
        }
      }
      {
#line 282
      StripUnneccesaryGlobEntries((FTPCIPtr const   )cip, fileList);
#line 283
      RemoteGlobCollapse((FTPCIPtr const   )cip, pattern, fileList);
#line 284
      lp = fileList->first;
      }
      {
#line 284
      while (1) {
        while_continue: /* CIL Label */ ;
#line 284
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 284
          goto while_break;
        }
        {
#line 285
        PrintF((FTPCIPtr const   )cip, (char const   */* const  */)"  Rglob [%s]\n",
               lp->line);
#line 284
        lp = lp->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 291
      tmp___7 = (FTPLinePtr )((void *)0);
#line 291
      fileList->last = tmp___7;
#line 291
      fileList->first = tmp___7;
#line 292
      AddLine(fileList, pattern);
      }
    }
  } else {
    {
#line 291
    tmp___7 = (FTPLinePtr )((void *)0);
#line 291
    fileList->last = tmp___7;
#line 291
    fileList->first = tmp___7;
#line 292
    AddLine(fileList, pattern);
    }
  }
#line 294
  return (0);
}
}
#line 1088 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void URLCopyToken(char *dst , size_t dsize , char const   *src , size_t howmuch ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_decodeurl.c"
void URLCopyToken(char *dst , size_t dsize , char const   *src , size_t howmuch ) 
{ 
  char *dlim ;
  char const   *slim ;
  unsigned int hc ;
  int c ;
  char h[4] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 24
  dlim = (dst + dsize) - 1;
#line 25
  slim = src + howmuch;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! ((unsigned long )src < (unsigned long )slim)) {
#line 26
      goto while_break;
    }
#line 27
    tmp = src;
#line 27
    src ++;
#line 27
    c = (int )*tmp;
#line 28
    if (c == 0) {
#line 29
      goto while_break;
    }
#line 30
    if (c == 37) {
#line 32
      if ((unsigned long )src < (unsigned long )(slim + 2)) {
        {
#line 33
        tmp___0 = src;
#line 33
        src ++;
#line 33
        h[0] = (char )*tmp___0;
#line 34
        tmp___1 = src;
#line 34
        src ++;
#line 34
        h[1] = (char )*tmp___1;
#line 35
        h[2] = (char )'\000';
#line 36
        hc = 61183U;
#line 37
        tmp___2 = sscanf((char const   */* __restrict  */)(h), (char const   */* __restrict  */)"%x",
                         & hc);
        }
#line 37
        if (tmp___2 >= 0) {
#line 37
          if (hc != 61183U) {
#line 38
            if (hc == 0U) {
#line 40
              goto while_break;
            } else
#line 38
            if (hc == 10U) {
#line 40
              goto while_break;
            } else
#line 38
            if (hc == 13U) {
#line 40
              goto while_break;
            } else
#line 38
            if (hc == 7U) {
#line 40
              goto while_break;
            } else
#line 38
            if (hc == 8U) {
#line 40
              goto while_break;
            } else
#line 38
            if (hc == 11U) {
#line 40
              goto while_break;
            } else
#line 38
            if (hc == 12U) {
#line 40
              goto while_break;
            }
#line 42
            if ((unsigned long )dst < (unsigned long )dlim) {
#line 43
              *((unsigned char *)dst) = (unsigned char )hc;
#line 44
              dst ++;
            }
          }
        }
      } else {
#line 48
        goto while_break;
      }
    } else {
#line 51
      tmp___3 = dst;
#line 51
      dst ++;
#line 51
      *tmp___3 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  *dst = (char )'\000';
#line 55
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_decodeurl.c"
int FTPDecodeURL(FTPCIPtr const   cip , char * const  url , FTPLineListPtr cdlist ,
                 char * const  fn , size_t const   fnsize , int * const  xtype , int * const  wantnlst ) 
{ 
  char *cp ;
  char *hstart ;
  char *hend ;
  char *h2start ;
  char *at1 ;
  char portstr[32] ;
  int port ;
  int sc ;
  char *lastslash ;
  char *parsestr ;
  char *tok ;
  char subdir[128] ;
  char *semi ;
  char *ctext ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 85
  InitLineList(cdlist);
#line 86
  *fn = (char )'\000';
  }
#line 87
  if ((unsigned long )wantnlst != (unsigned long )((void *)0)) {
#line 88
    *wantnlst = 0;
  }
#line 89
  if ((unsigned long )xtype != (unsigned long )((void *)0)) {
#line 90
    *xtype = 'I';
  }
  {
#line 92
  cp = (char *)((void *)0);
#line 94
  tmp___1 = strncasecmp((char const   *)url, "<URL:ftp://", (size_t )11);
  }
#line 94
  if (tmp___1 == 0) {
    {
#line 95
    tmp = strlen((char const   *)url);
#line 95
    cp = (char *)((url + tmp) - 1);
    }
#line 96
    if ((int )*cp != 62) {
#line 97
      return (-2);
    }
#line 98
    *cp = (char )'\000';
#line 99
    cp = (char *)(url + 11);
  } else {
    {
#line 100
    tmp___0 = strncasecmp((char const   *)url, "ftp://", (size_t )6);
    }
#line 100
    if (tmp___0 == 0) {
#line 101
      cp = (char *)(url + 6);
    } else {
#line 103
      return (-1);
    }
  }
#line 121
  at1 = (char *)((void *)0);
#line 122
  hstart = cp;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if ((int )*cp == 64) {
#line 124
      if ((unsigned long )at1 == (unsigned long )((void *)0)) {
#line 125
        at1 = cp;
      } else {
#line 127
        return (-2);
      }
    } else
#line 128
    if ((int )*cp == 0) {
#line 129
      hend = cp;
#line 130
      goto while_break;
    } else
#line 128
    if ((int )*cp == 47) {
#line 129
      hend = cp;
#line 130
      goto while_break;
    }
#line 122
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  sc = (int )*hend;
#line 135
  *hend = (char )'\000';
#line 136
  if ((unsigned long )at1 == (unsigned long )((void *)0)) {
#line 138
    h2start = hstart;
  } else {
    {
#line 140
    *at1 = (char )'\000';
#line 141
    cp = strchr((char const   *)hstart, ':');
    }
#line 142
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 144
      URLCopyToken(cip->user, sizeof(cip->user), (char const   *)hstart, (size_t )(at1 - hstart));
      }
    } else {
      {
#line 145
      tmp___2 = strchr((char const   *)(cp + 1), ':');
      }
#line 145
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 147
        return (-2);
      } else {
        {
#line 149
        URLCopyToken(cip->user, sizeof(cip->user), (char const   *)hstart, (size_t )(cp - hstart));
#line 150
        URLCopyToken(cip->pass, sizeof(cip->pass), (char const   *)(cp + 1), (size_t )(at1 - (cp + 1)));
        }
      }
    }
#line 152
    *at1 = (char )'@';
#line 153
    h2start = at1 + 1;
  }
  {
#line 156
  cp = strchr((char const   *)h2start, ':');
  }
#line 157
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 159
    URLCopyToken(cip->host, sizeof(cip->host), (char const   *)h2start, (size_t )(hend - h2start));
    }
  } else {
    {
#line 160
    tmp___3 = strchr((char const   *)(cp + 1), ':');
    }
#line 160
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 162
      return (-2);
    } else {
      {
#line 164
      URLCopyToken(cip->host, sizeof(cip->host), (char const   *)h2start, (size_t )(cp - h2start));
#line 165
      URLCopyToken(portstr, sizeof(portstr), (char const   *)(cp + 1), (size_t )(hend - (cp + 1)));
#line 166
      port = atoi((char const   *)(portstr));
      }
#line 167
      if (port > 0) {
#line 168
        cip->port = (unsigned int )port;
      }
    }
  }
#line 171
  *hend = (char )sc;
#line 172
  if ((int )*hend == 0) {
#line 174
    return (0);
  } else
#line 172
  if ((int )*hend == 47) {
#line 172
    if ((int )*(hend + 1) == 0) {
#line 174
      return (0);
    }
  }
  {
#line 177
  lastslash = strrchr((char const   *)hend, '/');
  }
#line 178
  if ((unsigned long )lastslash == (unsigned long )((void *)0)) {
#line 180
    return (0);
  }
  {
#line 182
  *lastslash = (char )'\000';
#line 184
  semi = strchr((char const   *)(lastslash + 1), ';');
  }
#line 184
  if ((unsigned long )semi != (unsigned long )((void *)0)) {
    {
#line 186
    tmp___11 = strcasecmp((char const   *)semi, ";type=i");
    }
#line 186
    if (tmp___11 == 0) {
#line 187
      tmp___4 = semi;
#line 187
      semi ++;
#line 187
      *tmp___4 = (char )'\000';
#line 188
      if ((unsigned long )xtype != (unsigned long )((void *)0)) {
#line 189
        *xtype = 'I';
      }
    } else {
      {
#line 190
      tmp___10 = strcasecmp((char const   *)semi, ";type=a");
      }
#line 190
      if (tmp___10 == 0) {
#line 191
        tmp___5 = semi;
#line 191
        semi ++;
#line 191
        *tmp___5 = (char )'\000';
#line 192
        if ((unsigned long )xtype != (unsigned long )((void *)0)) {
#line 193
          *xtype = 'A';
        }
      } else {
        {
#line 194
        tmp___9 = strcasecmp((char const   *)semi, ";type=b");
        }
#line 194
        if (tmp___9 == 0) {
#line 195
          tmp___6 = semi;
#line 195
          semi ++;
#line 195
          *tmp___6 = (char )'\000';
#line 196
          if ((unsigned long )xtype != (unsigned long )((void *)0)) {
#line 197
            *xtype = 'I';
          }
        } else {
          {
#line 198
          tmp___8 = strcasecmp((char const   *)semi, ";type=d");
          }
#line 198
          if (tmp___8 == 0) {
#line 199
            if ((unsigned long )wantnlst != (unsigned long )((void *)0)) {
#line 200
              tmp___7 = semi;
#line 200
              semi ++;
#line 200
              *tmp___7 = (char )'\000';
#line 201
              *wantnlst = 1;
#line 202
              if ((unsigned long )xtype != (unsigned long )((void *)0)) {
#line 203
                *xtype = 'A';
              }
            } else {
#line 206
              return (-2);
            }
          }
        }
      }
    }
  }
  {
#line 235
  tmp___12 = strlen((char const   *)(lastslash + 1));
#line 235
  URLCopyToken((char *)fn, (size_t )fnsize, (char const   *)(lastslash + 1), tmp___12);
#line 236
  parsestr = hend;
#line 236
  ctext = (char *)((void *)0);
  }
  {
#line 236
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 236
    tok = strtokc(parsestr, "/", & ctext);
    }
#line 236
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 236
      goto while_break___0;
    }
    {
#line 237
    tmp___13 = strlen((char const   *)tok);
#line 237
    URLCopyToken(subdir, sizeof(subdir), (char const   *)tok, tmp___13);
#line 238
    AddLine(cdlist, (char const   *)(subdir));
#line 236
    parsestr = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 240
  *lastslash = (char )'/';
#line 241
  return (0);
}
}
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_printf.c"
void ( /* format attribute */  PrintF)(FTPCIPtr const   cip , char const   * const  fmt 
                                       , ...) 
{ 
  va_list ap ;
  char buf[1024] ;
  char tbuf[40] ;
  size_t tbuflen ;
  int x ;
  time_t t ;
  struct tm lt ;
  struct tm *ltp ;
  time_t tmp ;

  {
#line 22
  tbuflen = (size_t )0;
#line 27
  tbuf[0] = (char )'\000';
#line 28
  x = cip->debugTimestamping;
#line 28
  if (x != 0) {
    {
#line 29
    tmp = time(& t);
#line 29
    ltp = Localtime(tmp, (struct tm */* const  */)(& lt));
    }
#line 30
    if (x == 1) {
      {
#line 31
      tbuflen = strftime((char */* __restrict  */)(tbuf), sizeof(tbuf), (char const   */* __restrict  */)"%H:%M:%S",
                         (struct tm  const  */* __restrict  */)ltp);
      }
    } else {
      {
#line 33
      tbuflen = strftime((char */* __restrict  */)(tbuf), sizeof(tbuf), (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S",
                         (struct tm  const  */* __restrict  */)ltp);
      }
    }
#line 35
    if ((unsigned long )cip->debugLog != (unsigned long )((void *)0)) {
      {
#line 36
      fprintf((FILE */* __restrict  */)cip->debugLog, (char const   */* __restrict  */)"%s  ",
              tbuf);
      }
    }
  }
  {
#line 39
  __builtin_va_start(ap, fmt);
  }
#line 41
  if ((unsigned long )cip->debugLog != (unsigned long )((void *)0)) {
    {
#line 42
    vfprintf((FILE */* __restrict  */)cip->debugLog, (char const   */* __restrict  */)fmt,
             ap);
#line 43
    fflush(cip->debugLog);
    }
  }
#line 46
  if ((unsigned long )cip->debugLogProc != (unsigned long )((void *)0)) {
#line 47
    if (tbuflen != 0UL) {
      {
#line 48
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(tbuf),
             tbuflen + 1UL);
      }
    }
    {
#line 50
    vsnprintf((char */* __restrict  */)(buf + tbuflen), (sizeof(buf) - tbuflen) - 1UL,
              (char const   */* __restrict  */)fmt, ap);
#line 51
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 55
    (*(cip->debugLogProc))(cip, buf);
    }
  }
  {
#line 57
  __builtin_va_end(ap);
  }
#line 58
  return;
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 37 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_gettar.c"
static int OpenTar(FTPCIPtr const   cip , char const   * const  dstdir , int * const  pid ) 
{ 
  int pipe1[2] ;
  int pid1 ;
  int i___0 ;
  char *argv[8] ;
  int tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 45
  *pid = -1;
#line 47
  tmp = access("/bin/tar", 1);
  }
#line 47
  if (tmp < 0) {
#line 49
    return (-1);
  }
  {
#line 52
  tmp___0 = pipe((int *)(pipe1));
  }
#line 52
  if (tmp___0 < 0) {
    {
#line 53
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"pipe to Tar failed");
    }
#line 54
    return (-1);
  }
  {
#line 57
  tmp___1 = fork();
#line 57
  pid1 = tmp___1;
  }
#line 58
  if (pid1 < 0) {
    {
#line 59
    close(pipe1[0]);
#line 60
    close(pipe1[1]);
    }
#line 61
    return (-1);
  } else
#line 62
  if (pid1 == 0) {
#line 64
    if ((unsigned long )dstdir != (unsigned long )((void *)0)) {
#line 64
      if ((int const   )*(dstdir + 0) != 0) {
        {
#line 64
        tmp___2 = chdir((char const   *)dstdir);
        }
#line 64
        if (tmp___2 < 0) {
          {
#line 65
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"tar chdir to %s failed",
                      dstdir);
#line 66
          exit(1);
          }
        }
      }
    }
    {
#line 68
    close(pipe1[1]);
#line 69
    dup2(pipe1[0], 0);
#line 70
    close(pipe1[0]);
#line 72
    i___0 = 3;
    }
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (! (i___0 < 256)) {
#line 72
        goto while_break;
      }
      {
#line 73
      close(i___0);
#line 72
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 75
    argv[0] = strdup("tar");
#line 76
    argv[1] = strdup("xpf");
#line 77
    argv[2] = strdup("-");
#line 78
    argv[3] = (char *)((void *)0);
#line 80
    execv("/bin/tar", (char * const  *)(argv));
#line 81
    exit(1);
    }
  }
  {
#line 85
  *pid = pid1;
#line 87
  close(pipe1[0]);
  }
#line 88
  return (pipe1[1]);
}
}
#line 94 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_gettar.c"
int FTPGetOneTarF(FTPCIPtr const   cip , char const   *file , char const   * const  dstdir ) 
{ 
  char *buf ;
  size_t bufSize ;
  int tmpResult ;
  int volatile   result ;
  ssize_t nread ;
  ssize_t nwrote ;
  int volatile   fd ;
  int volatile   vfd ;
  char const   * volatile  vfile ;
  int pid ;
  int status ;
  char savedCwd[512] ;
  char * volatile  basecp ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  int *tmp___7 ;
  union __anonunion_71 __constr_expr_0 ;
  union __anonunion_72 __constr_expr_1 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  __pid_t tmp___14 ;
  int *tmp___15 ;
  union __anonunion_73 __constr_expr_2 ;
  union __anonunion_74 __constr_expr_3 ;

  {
#line 115
  result = (int volatile   )0;
#line 116
  cip->usingTAR = 0;
#line 118
  if (cip->hasRETR_tar == 0) {
#line 119
    result = (int volatile   )-137;
#line 120
    cip->errNo = -137;
#line 121
    return ((int )result);
  }
#line 124
  if ((int const   )*(file + 0) == 0) {
#line 129
    result = (int volatile   )-137;
#line 130
    cip->errNo = -137;
#line 131
    return ((int )result);
  } else
#line 124
  if ((int const   )*(file + 0) == 47) {
#line 124
    if ((int const   )*(file + 1) == 0) {
#line 129
      result = (int volatile   )-137;
#line 130
      cip->errNo = -137;
#line 131
      return ((int )result);
    }
  }
  {
#line 134
  tmp = FTPCmd(cip, (char const   */* const  */)"MDTM %s.tar", file);
  }
#line 134
  if (tmp == 2) {
#line 139
    result = (int volatile   )-137;
#line 140
    cip->errNo = -137;
#line 141
    return ((int )result);
  }
  {
#line 144
  tmp___0 = strrchr(file, '/');
#line 144
  basecp = (char */* volatile  */)tmp___0;
  }
#line 145
  if ((unsigned long )basecp != (unsigned long )((void *)0)) {
    {
#line 146
    tmp___1 = strrchr(file, '\\');
#line 146
    basecp = (char */* volatile  */)tmp___1;
    }
  }
#line 147
  if ((unsigned long )basecp != (unsigned long )((void *)0)) {
    {
#line 151
    tmp___2 = FTPGetCWD(cip, (char */* const  */)(savedCwd), (size_t const   )sizeof(savedCwd));
    }
#line 151
    if (tmp___2 != 0) {
#line 152
      result = (int volatile   )-137;
#line 153
      cip->errNo = -137;
#line 154
      return ((int )result);
    }
    {
#line 156
    tmp___3 = FTPChdir(cip, (char const   */* const  */)file);
#line 156
    result = (int volatile   )tmp___3;
    }
#line 157
    if (result != (int volatile   )0) {
#line 158
      return ((int )result);
    }
    {
#line 160
    tmp___4 = FTPChdir(cip, (char const   */* const  */)"..");
#line 160
    result = (int volatile   )tmp___4;
    }
#line 161
    if (result != (int volatile   )0) {
      {
#line 162
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
#line 163
      return ((int )result);
    }
#line 165
    file = (char const   *)(basecp + 1);
  }
  {
#line 168
  tmp___5 = OpenTar(cip, dstdir, (int */* const  */)(& pid));
#line 168
  fd = (int volatile   )tmp___5;
  }
#line 169
  if (fd < (int volatile   )0) {
#line 170
    result = (int volatile   )-137;
#line 171
    cip->errNo = -137;
#line 172
    if ((unsigned long )basecp != (unsigned long )((void *)0)) {
      {
#line 173
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
    }
#line 174
    return ((int )result);
  }
  {
#line 177
  vfd = fd;
#line 178
  vfile = (char const   */* volatile  */)file;
#line 219
  tmpResult = FTPStartDataCmd(cip, (int const   )65, (int const   )'I', (long long const   )0LL,
                              (char const   */* const  */)"RETR %s.tar", vfile);
  }
#line 221
  if (tmpResult < 0) {
#line 222
    result = (int volatile   )tmpResult;
#line 223
    if (result == (int volatile   )-1) {
#line 224
      result = (int volatile   )-131;
    }
#line 225
    cip->errNo = (int )result;
#line 226
    if (cip->hasRETR_tar == -1) {
#line 227
      cip->hasRETR_tar = 0;
    }
    {
#line 232
    close((int )vfd);
    }
    {
#line 233
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 235
      tmp___6 = waitpid(pid, & status, 0);
      }
#line 235
      if (tmp___6 < 0) {
        {
#line 235
        tmp___7 = __errno_location();
        }
#line 235
        if (*tmp___7 != 4) {
#line 236
          goto while_break;
        }
      }
#line 241
      __constr_expr_0.__in = status;
#line 241
      if ((__constr_expr_0.__i & 127) == 0) {
#line 242
        goto while_break;
      } else {
#line 241
        __constr_expr_1.__in = status;
#line 241
        if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
#line 242
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 248
    if ((unsigned long )basecp != (unsigned long )((void *)0)) {
      {
#line 249
      FTPChdir(cip, (char const   */* const  */)(savedCwd));
      }
    }
#line 250
    return ((int )result);
  }
#line 253
  if (cip->hasRETR_tar == -1) {
#line 254
    cip->hasRETR_tar = 1;
  }
  {
#line 255
  cip->usingTAR = 1;
#line 256
  buf = cip->buf;
#line 257
  bufSize = cip->bufSize;
#line 259
  FTPInitIOTimer(cip);
#line 260
  cip->lname = (char const   *)vfile;
#line 261
  cip->rname = (char const   *)vfile;
#line 262
  FTPStartIOTimer(cip);
  }
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 266
    tmp___8 = WaitForRemoteInput(cip);
    }
#line 266
    if (! tmp___8) {
      {
#line 267
      result = (int volatile   )-194;
#line 267
      cip->errNo = (int )result;
#line 268
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out.\n");
      }
#line 269
      goto while_break___0;
    }
#line 271
    if (cip->cancelXfer > 0) {
      {
#line 272
      FTPAbortDataTransfer(cip);
#line 273
      tmp___9 = -169;
#line 273
      cip->errNo = tmp___9;
#line 273
      result = (int volatile   )tmp___9;
      }
#line 274
      goto while_break___0;
    }
    {
#line 282
    tmp___10 = SRead(cip->dataSocket, (char */* const  */)buf, bufSize, (int )cip->xferTimeout,
                     8);
#line 282
    nread = (ssize_t )tmp___10;
    }
#line 283
    if (nread == -2L) {
      {
#line 284
      result = (int volatile   )-194;
#line 284
      cip->errNo = (int )result;
#line 285
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote read timed out.\n");
      }
#line 286
      goto while_break___0;
    } else
#line 287
    if (nread < 0L) {
      {
#line 288
      tmp___11 = __errno_location();
      }
#line 288
      if (*tmp___11 == 4) {
#line 289
        goto __Cont;
      }
      {
#line 290
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Remote read failed.\n");
#line 291
      result = (int volatile   )-136;
#line 292
      cip->errNo = -136;
      }
#line 293
      goto while_break___0;
    } else
#line 294
    if (nread == 0L) {
#line 295
      goto while_break___0;
    }
    {
#line 312
    nwrote = write((int )fd, (void const   *)buf, (size_t )nread);
    }
#line 313
    if (nwrote != nread) {
      {
#line 314
      tmp___13 = __errno_location();
      }
#line 314
      if (*tmp___13 == 32) {
        {
#line 315
        result = (int volatile   )-133;
#line 316
        cip->errNo = -133;
#line 317
        tmp___12 = __errno_location();
#line 317
        *tmp___12 = 32;
        }
      } else {
        {
#line 319
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local write failed.\n");
#line 320
        result = (int volatile   )-133;
#line 321
        cip->errNo = -133;
        }
      }
#line 323
      goto while_break___0;
    }
    {
#line 325
    cip->bytesTransferred += (long long )nread;
#line 326
    FTPUpdateIOTimer(cip);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 335
  close((int )fd);
  }
  {
#line 336
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 338
    tmp___14 = waitpid(pid, & status, 0);
    }
#line 338
    if (tmp___14 < 0) {
      {
#line 338
      tmp___15 = __errno_location();
      }
#line 338
      if (*tmp___15 != 4) {
#line 339
        goto while_break___1;
      }
    }
#line 344
    __constr_expr_2.__in = status;
#line 344
    if ((__constr_expr_2.__i & 127) == 0) {
#line 345
      goto while_break___1;
    } else {
#line 344
      __constr_expr_3.__in = status;
#line 344
      if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 345
        goto while_break___1;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 348
  tmpResult = FTPEndDataCmd(cip, 1);
  }
#line 349
  if (tmpResult < 0) {
#line 349
    if (result == (int volatile   )0) {
#line 350
      result = (int volatile   )-131;
#line 351
      cip->errNo = -131;
    }
  }
  {
#line 353
  FTPStopIOTimer(cip);
  }
#line 358
  if (result == (int volatile   )0) {
#line 358
    if (cip->bytesTransferred == 0LL) {
#line 359
      result = (int volatile   )-137;
#line 360
      cip->errNo = -137;
    }
  }
#line 362
  if ((unsigned long )basecp != (unsigned long )((void *)0)) {
    {
#line 363
    FTPChdir(cip, (char const   */* const  */)(savedCwd));
    }
  }
#line 364
  return ((int )result);
}
}
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/usio.h"
int UConnect(int sfd , struct sockaddr_un  const  * const  addr , int ualen , int tlen ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UConnect.c"
int _SConnect(int const   sfd , struct sockaddr_in  const  * const  addr , size_t const   saddrsiz ,
              int const   tlen ) ;
#line 10 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UConnect.c"
int UConnect(int sfd , struct sockaddr_un  const  * const  addr , int ualen , int tlen ) 
{ 
  int result ;
  int *tmp ;

  {
#line 15
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  } else
#line 15
  if (ualen == 0) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  }
  {
#line 20
  result = _SConnect((int const   )sfd, (struct sockaddr_in  const  */* const  */)((struct sockaddr_in  const  *)addr),
                     (size_t const   )((size_t )ualen), (int const   )tlen);
  }
#line 21
  return (result);
}
}
#line 238 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SRecvmsg(int sfd  __attribute__((__unused__)) , void * const  msg  __attribute__((__unused__)) ,
             int fl  __attribute__((__unused__)) , int tlen  __attribute__((__unused__)) ) ;
#line 7 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SRecvmsg.c"
int SRecvmsg(int sfd  __attribute__((__unused__)) , void * const  msg  __attribute__((__unused__)) ,
             int fl  __attribute__((__unused__)) , int tlen  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 15
  tmp = __errno_location();
#line 15
  *tmp = 38;
  }
#line 17
  return (-1);
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_type.c"
int FTPSetTransferType(FTPCIPtr const   cip , int type ) 
{ 
  int result ;
  int tmp ;

  {
#line 18
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 19
    return (-139);
  }
  {
#line 20
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 20
  if (tmp) {
#line 21
    return (-138);
  }
#line 23
  if (cip->curTransferType != type) {
    {
#line 27
    if (type == 69) {
#line 27
      goto case_69;
    }
#line 27
    if (type == 73) {
#line 27
      goto case_69;
    }
#line 27
    if (type == 65) {
#line 27
      goto case_69;
    }
#line 31
    if (type == 66) {
#line 31
      goto case_66;
    }
#line 31
    if (type == 98) {
#line 31
      goto case_66;
    }
#line 31
    if (type == 105) {
#line 31
      goto case_66;
    }
#line 34
    if (type == 101) {
#line 34
      goto case_101;
    }
#line 37
    if (type == 97) {
#line 37
      goto case_97;
    }
#line 40
    goto switch_default;
    case_69: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 28
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 32
    type = 'I';
#line 33
    goto switch_break;
    case_101: /* CIL Label */ 
#line 35
    type = 'E';
#line 36
    goto switch_break;
    case_97: /* CIL Label */ 
#line 38
    type = 'A';
#line 39
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 42
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Bad transfer type [%c].\n",
                type);
#line 43
    cip->errNo = -121;
    }
#line 44
    return (-121);
    switch_break: /* CIL Label */ ;
    }
    {
#line 46
    result = FTPCmd(cip, (char const   */* const  */)"TYPE %c", type);
    }
#line 47
    if (result != 2) {
#line 48
      result = -147;
#line 49
      cip->errNo = -147;
#line 50
      return (result);
    }
#line 52
    cip->curTransferType = type;
  }
#line 54
  return (0);
}
}
#line 377 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
static void FTPExamineMlstFeatures___0(FTPCIPtr const   cip , char const   *features ) 
{ 
  char buf[256] ;
  char *feat ;
  int flags___0 ;
  char *ctext ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 384
  flags___0 = 0;
#line 385
  Strncpy((char */* const  */)(buf), (char const   */* const  */)features, (size_t const   )sizeof(buf));
#line 386
  ctext = (char *)((void *)0);
#line 387
  feat = strtokc(buf, ";*", & ctext);
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )feat != (unsigned long )((void *)0))) {
#line 388
      goto while_break;
    }
    {
#line 389
    tmp = strncasecmp((char const   *)feat, "OS.", (size_t )3);
    }
#line 389
    if (tmp == 0) {
#line 390
      feat += 3;
    }
    {
#line 391
    tmp___9 = strcasecmp((char const   *)feat, "type");
    }
#line 391
    if (tmp___9 == 0) {
#line 392
      flags___0 |= 1;
    } else {
      {
#line 393
      tmp___8 = strcasecmp((char const   *)feat, "size");
      }
#line 393
      if (tmp___8 == 0) {
#line 394
        flags___0 |= 2;
      } else {
        {
#line 395
        tmp___7 = strcasecmp((char const   *)feat, "modify");
        }
#line 395
        if (tmp___7 == 0) {
#line 396
          flags___0 |= 4;
        } else {
          {
#line 397
          tmp___6 = strcasecmp((char const   *)feat, "UNIX.mode");
          }
#line 397
          if (tmp___6 == 0) {
#line 398
            flags___0 |= 8;
          } else {
            {
#line 399
            tmp___5 = strcasecmp((char const   *)feat, "UNIX.owner");
            }
#line 399
            if (tmp___5 == 0) {
#line 400
              flags___0 |= 16;
            } else {
              {
#line 401
              tmp___4 = strcasecmp((char const   *)feat, "UNIX.group");
              }
#line 401
              if (tmp___4 == 0) {
#line 402
                flags___0 |= 32;
              } else {
                {
#line 403
                tmp___3 = strcasecmp((char const   *)feat, "perm");
                }
#line 403
                if (tmp___3 == 0) {
#line 404
                  flags___0 |= 64;
                } else {
                  {
#line 405
                  tmp___2 = strcasecmp((char const   *)feat, "UNIX.uid");
                  }
#line 405
                  if (tmp___2 == 0) {
#line 406
                    flags___0 |= 128;
                  } else {
                    {
#line 407
                    tmp___1 = strcasecmp((char const   *)feat, "UNIX.gid");
                    }
#line 407
                    if (tmp___1 == 0) {
#line 408
                      flags___0 |= 256;
                    } else {
                      {
#line 409
                      tmp___0 = strcasecmp((char const   *)feat, "UNIX.gid");
                      }
#line 409
                      if (tmp___0 == 0) {
#line 410
                        flags___0 |= 512;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 412
    feat = strtokc((char *)((void *)0), ";*", & ctext);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  cip->mlsFeatures = flags___0;
#line 416
  return;
}
}
#line 965 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FilenameExtensionIndicatesASCII(char const   * const  pathName , char const   * const  extnList ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_fileextn.c"
int FilenameExtensionIndicatesASCII(char const   * const  pathName , char const   * const  extnList ) 
{ 
  char const   *extn ;
  char *cp ;
  int c ;
  char extnPattern[16] ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;

  {
#line 23
  if ((unsigned long )pathName == (unsigned long )((void *)0)) {
#line 24
    return (0);
  } else
#line 23
  if ((int const   )*(pathName + 0) == 0) {
#line 24
    return (0);
  }
  {
#line 26
  tmp = strlen((char const   *)pathName);
#line 26
  extn = (char const   *)((pathName + tmp) - 1);
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if ((unsigned long )extn <= (unsigned long )pathName) {
#line 29
      return (0);
    }
#line 30
    extn --;
#line 30
    c = (int )*extn;
#line 31
    if (c == 47) {
#line 32
      return (0);
    }
#line 33
    if (c == 46) {
#line 34
      extn ++;
#line 35
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 38
  tmp___0 = strlen(extn);
  }
#line 38
  if (tmp___0 > ((sizeof(extnPattern) - 2UL) - 1UL) - 1UL) {
#line 39
    return (0);
  }
  {
#line 42
  snprintf((char */* __restrict  */)(extnPattern), sizeof(extnPattern), (char const   */* __restrict  */)"|.%s|",
           extn);
#line 50
  cp = extnPattern;
  }
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 52
    c = (int )*cp;
#line 53
    if (c == 0) {
#line 54
      goto while_break___0;
    }
    {
#line 55
    tmp___2 = __ctype_b_loc();
    }
#line 55
    if ((int const   )*(*tmp___2 + c) & 256) {
      {
#line 56
      c = tolower(c);
#line 57
      tmp___1 = cp;
#line 57
      cp ++;
#line 57
      *tmp___1 = (char )c;
      }
    } else {
#line 59
      cp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 71
  tmp___3 = strstr((char const   *)extnList, (char const   *)(extnPattern));
  }
#line 71
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 72
    return (1);
  }
#line 74
  return (0);
}
}
#line 846 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
char const   *gLibNcFTP_Uses_Me_To_Quiet_Variable_Unused_Warnings ;
#line 920
char const   *FTPStrError(int e ) ;
#line 921
char *FTPStrError2(FTPCIPtr const   cip , int e , char * const  dst , size_t const   dstsize ,
                   int eerr ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/errno.c"
static char const   *gErrList[108]  = 
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/errno.c"
  {      "gethostname() failed",      "hostname does not include domain name",      "could not set linger mode",      "could not set type of service", 
        "could not enable out-of-band data inline",      "unknown host",      "could not get a new stream socket",      "could not duplicate a socket", 
        "fdopen for reading failed",      "fdopen for writing failed",      "getsockname failed",      "could not bind the data socket", 
        "could not listen on the data socket",      "passive mode failed",      "server sent bogus port number",      "could not connect data socket", 
        "could not accept data socket",      "could not set restart point",      "could not connect to remote host",      "could not connect to remote host, but can try again", 
        "remote host refused connection",      "bad transfer type",      "invalid directory parameter",      "malloc failed", 
        "PWD failed",      "remote chdir failed",      "remote rmdir failed",      "bad line list", 
        "unimplemented option",      "unimplemented function",      "remote directory listing failed",      "could not retrieve remote file", 
        "could not send file to remote host",      "file write error",      "file read error",      "socket write error", 
        "socket read error",      "could not open file",      "bad magic number in FTP library structure",      "bad parameter given to library", 
        "remote mkdir failed",      "remote cd .. failed",      "remote chmod failed",      "remote umask failed", 
        "remote delete failed",      "remote file size inquiry failed",      "remote file timestamp inquiry failed",      "remote transfer type change failed", 
        "file size inquiries not understood by remote server",      "file timestamp inquiries not understood by remote server",      "could not rename remote file",      "could not do remote wildcard expansion", 
        "could not set keepalive option",      "remote host disconnected during login",      "username was not accepted for login",      "username and/or password was not accepted for login", 
        "login failed",      "invalid reply from server",      "remote host closed control connection",      "not connected", 
        "could not start data transfer",      "data transfer failed",      "PORT failed",      "PASV failed", 
        "UTIME failed",      "utime requests not understood by remote server",      "HELP failed",      "file deletion on local host failed", 
        "lseek failed",      "data transfer aborted by local user",      "SYMLINK failed",      "symlink requests not understood by remote server", 
        "no match",      "server features request failed",      "no valid files were specified",      "file transfer buffer has not been allocated", 
        "will not overwrite local file with older remote file",      "will not overwrite remote file with older local file",      "local file appears to be the same as the remote file, download is not necessary",      "could not get extended directory information (MLSD)", 
        "could not get extended file or directory information (MLST)",      "could not parse extended file or directory information",      "server does not support extended file or directory information",      "server does not support extended directory information", 
        "could not get information about specified file",      "server does not support file or directory information",      "could not get directory information about specified file",      "server does not support directory information", 
        "no such file or directory",      "server provides no way to determine file existence",      "item exists, but cannot tell if it is a file or directory",      "not a directory", 
        "directory recursion limit reached",      "timed out while waiting for server response",      "data transfer timed out",      "canceled by user", 
        "no remote host was specified",      "remote file appears to be the same as the local file, upload is not necessary",      "data connection did not originate from same IP address as control connection to server",      "data connection did not originate from correct port number", 
        "internal error: bug in library code detected",      "remote server does not support setting a RESTart point",      "miscellaneous error occurred while trying to open the host",      "miscellaneous error occurred while trying to login to the host", 
        "ascii seek error",      "you have encountered a bug that we have not fixed yet, sorry!",      "could not bind the control connection socket",      (char const   *)((void *)0)};
#line 124 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/errno.c"
char const   *gLibNcFTP_Uses_Me_To_Quiet_Variable_Unused_Warnings  =    (char const   *)0;
#line 126 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/errno.c"
char const   *FTPStrError(int e ) 
{ 


  {
#line 129
  if (e == -1) {
#line 130
    return ("miscellaneous error");
  } else
#line 131
  if (e == 0) {
#line 132
    return ("no error");
  } else {
#line 134
    if (e < 0) {
#line 135
      e = - e;
    }
#line 136
    if (e >= 100) {
#line 136
      if (e <= 206) {
#line 137
        return (gErrList[e - 100]);
      }
    }
  }
#line 140
  return ("unrecognized error number");
}
}
#line 146 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/errno.c"
char *FTPStrError2(FTPCIPtr const   cip , int e , char * const  dst , size_t const   dstsize ,
                   int eerr ) 
{ 
  FTPLinePtr lp ;
  char const   *tmp ;

  {
#line 151
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 152
    return ((char *)((void *)0));
  } else
#line 151
  if (dstsize == 0UL) {
#line 152
    return ((char *)((void *)0));
  }
#line 154
  if (e == eerr) {
#line 154
    if (e != 0) {
      {
#line 155
      Strncpy(dst, (char const   */* const  */)"Server said:", dstsize);
#line 156
      lp = cip->lastFTPCmdResultLL.first;
      }
      {
#line 156
      while (1) {
        while_continue: /* CIL Label */ ;
#line 156
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 156
          goto while_break;
        }
        {
#line 157
        Strncat(dst, (char const   */* const  */)" ", dstsize);
#line 158
        Strncat(dst, (char const   */* const  */)lp->line, dstsize);
#line 156
        lp = lp->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 161
      tmp = FTPStrError(e);
#line 161
      Strncpy(dst, (char const   */* const  */)tmp, dstsize);
      }
    }
  } else {
    {
#line 161
    tmp = FTPStrError(e);
#line 161
    Strncpy(dst, (char const   */* const  */)tmp, dstsize);
    }
  }
#line 163
  return ((char *)dst);
}
}
#line 169 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/errno.c"
void FTPPerror(FTPCIPtr const   cip , int const   err , int const   eerr , char const   * const  s1 ,
               char const   * const  s2 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 172
  if (err != 0) {
#line 173
    if (err == eerr) {
#line 174
      if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 174
        goto _L;
      } else
#line 174
      if ((int const   )*(s2 + 0) == 0) {
        _L: /* CIL Label */ 
#line 175
        if ((unsigned long )s1 == (unsigned long )((void *)0)) {
          {
#line 176
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"server said: %s\n",
                      cip->lastFTPCmdResultStr);
          }
        } else
#line 175
        if ((int const   )*(s1 + 0) == 0) {
          {
#line 176
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"server said: %s\n",
                      cip->lastFTPCmdResultStr);
          }
        } else {
          {
#line 178
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: server said: %s\n",
                      s1, cip->lastFTPCmdResultStr);
          }
        }
      } else
#line 180
      if ((unsigned long )s1 == (unsigned long )((void *)0)) {
        {
#line 181
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: server said: %s\n",
                    s2, cip->lastFTPCmdResultStr);
        }
      } else
#line 180
      if ((int const   )*(s1 + 0) == 0) {
        {
#line 181
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: server said: %s\n",
                    s2, cip->lastFTPCmdResultStr);
        }
      } else {
        {
#line 183
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s %s: server said: %s\n",
                    s1, s2, cip->lastFTPCmdResultStr);
        }
      }
    } else
#line 186
    if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 186
      goto _L___0;
    } else
#line 186
    if ((int const   )*(s2 + 0) == 0) {
      _L___0: /* CIL Label */ 
#line 187
      if ((unsigned long )s1 == (unsigned long )((void *)0)) {
        {
#line 188
        tmp = FTPStrError((int )err);
#line 188
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s.\n", tmp);
        }
      } else
#line 187
      if ((int const   )*(s1 + 0) == 0) {
        {
#line 188
        tmp = FTPStrError((int )err);
#line 188
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s.\n", tmp);
        }
      } else {
        {
#line 190
        tmp___0 = FTPStrError((int )err);
#line 190
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: %s.\n",
                    s1, tmp___0);
        }
      }
    } else
#line 192
    if ((unsigned long )s1 == (unsigned long )((void *)0)) {
      {
#line 193
      tmp___1 = FTPStrError((int )err);
#line 193
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: %s.\n", s2,
                  tmp___1);
      }
    } else
#line 192
    if ((int const   )*(s1 + 0) == 0) {
      {
#line 193
      tmp___1 = FTPStrError((int )err);
#line 193
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s: %s.\n", s2,
                  tmp___1);
      }
    } else {
      {
#line 195
      tmp___2 = FTPStrError((int )err);
#line 195
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s %s: %s.\n",
                  s1, s2, tmp___2);
      }
    }
  }
#line 199
  return;
}
}
#line 254 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_localtime.c"
struct tm *Localtime(time_t t , struct tm * const  tp ) 
{ 
  struct tm *tmp ;

  {
#line 24
  if (t == 0L) {
    {
#line 25
    time(& t);
    }
  }
  {
#line 26
  tmp = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)tp);
  }
#line 26
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 27
    return ((struct tm *)tp);
  }
  {
#line 39
  memset((void *)tp, 0, sizeof(struct tm ));
  }
#line 40
  return ((struct tm *)((void *)0));
}
}
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strncpy.c"
char const   gStrnLibVersion[16]  = 
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strncpy.c"
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )' ',      (char const   )'S',      (char const   )'t',      (char const   )'r', 
        (char const   )'n',      (char const   )' ',      (char const   )'3',      (char const   )'.', 
        (char const   )'2',      (char const   )'.',      (char const   )'0',      (char const   )'\000'};
#line 12 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strncpy.c"
char *Strncpy(char * const  dst , char const   * const  src , size_t const   n ) 
{ 
  register char *d ;
  register char const   *s ;
  register size_t i___0 ;
  char *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 19
  d = (char *)dst;
#line 20
  *d = (char)0;
#line 21
  if (n != 0UL) {
#line 22
    s = (char const   *)src;
#line 29
    i___0 = (size_t )1;
    {
#line 29
    while (1) {
      while_continue: /* CIL Label */ ;
#line 29
      if (! (i___0 < (size_t )n)) {
#line 29
        goto while_break;
      }
#line 30
      tmp___0 = d;
#line 30
      d ++;
#line 30
      tmp___2 = s;
#line 30
      s ++;
#line 30
      tmp___1 = (char )*tmp___2;
#line 30
      *tmp___0 = tmp___1;
#line 30
      if ((int )tmp___1 == 0) {
        {
#line 33
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 33
          if (! (i___0 < (size_t )n)) {
#line 33
            goto while_break___0;
          }
#line 34
          tmp = d;
#line 34
          d ++;
#line 34
          *tmp = (char)0;
#line 33
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 36
        return ((char *)dst);
      }
#line 29
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 42
    *d = (char)0;
  }
#line 44
  return ((char *)dst);
}
}
#line 249 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   * __restrict  __timer ,
                                                                                      struct tm * __restrict  __tp ) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_gmtime.c"
struct tm *Gmtime(time_t t , struct tm * const  tp ) 
{ 
  struct tm *tmp ;

  {
#line 24
  if (t == 0L) {
    {
#line 25
    time(& t);
    }
  }
  {
#line 26
  tmp = gmtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)tp);
  }
#line 26
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 27
    return ((struct tm *)tp);
  }
  {
#line 39
  memset((void *)tp, 0, sizeof(struct tm ));
  }
#line 40
  return ((struct tm *)((void *)0));
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 917 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPRename(FTPCIPtr const   cip , char const   * const  oldname , char const   * const  newname___1 ) ;
#line 924
int FTPUtime(FTPCIPtr const   cip , char const   * const  file , time_t actime , time_t modtime ,
             time_t crtime ) ;
#line 95 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/util.h"
int WaitForRemoteOutput(FTPCIPtr const   cip ) ;
#line 96
void FTPSetUploadSocketBufferSize(FTPCIPtr const   cip ) ;
#line 113
int FTPPutOneF(FTPCIPtr const   cip , char const   * const  file , char const   * volatile  dstfile ,
               int xtype , int const   fdtouse , int const   appendflag , char const   * volatile  tmppfx ,
               char const   * volatile  tmpsfx , int const   resumeflag , int const   deleteflag ,
               int (* const  resumeProc)(FTPCIPtr const   cip , char const   *localpath ,
                                         long long localsize , time_t localmtime ,
                                         char const   **remotepath , long long remotesize ,
                                         time_t remotetime , long long *startPoint ) ) ;
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_put.c"
static int FTPASCIILocalFileSeek(int const   fd , long long const   howMuchToSkip ,
                                 char * const  inbuf , size_t const   bufsize ) 
{ 
  int c ;
  long long count ;
  long long startpos ;
  long long endpos ;
  long long backskip ;
  char const   *src ;
  char const   *srclim ;
  ssize_t nread ;
  __off_t tmp ;
  char const   *tmp___0 ;
  __off_t tmp___1 ;
  __off_t tmp___2 ;

  {
#line 28
  count = (long long )howMuchToSkip;
#line 30
  src = (char const   *)((void *)0);
#line 30
  srclim = (char const   *)((void *)0);
#line 33
  if (count == 0LL) {
#line 34
    return (0);
  }
#line 35
  if (count < 0LL) {
#line 36
    return (-1);
  }
  {
#line 37
  tmp = lseek((int )fd, (off_t )0, 1);
#line 37
  startpos = (long long )tmp;
  }
#line 38
  if (startpos == -1LL) {
#line 39
    return (-1);
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (count > 0LL)) {
#line 41
      goto while_break;
    }
    {
#line 42
    nread = read((int )fd, (void *)inbuf, (size_t )bufsize);
    }
#line 43
    if (nread <= 0L) {
#line 44
      count = -1LL;
#line 45
      goto while_break;
    }
#line 47
    src = (char const   *)inbuf;
#line 47
    srclim = (char const   *)(inbuf + nread);
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 47
      if (! ((unsigned long )src < (unsigned long )srclim)) {
#line 47
        goto while_break___0;
      }
#line 48
      tmp___0 = src;
#line 48
      src ++;
#line 48
      c = (int )*tmp___0;
#line 49
      if (c == 13) {
#line 51
        count = -1LL;
      } else
#line 52
      if (c == 10) {
#line 53
        count -= 2LL;
      } else {
#line 58
        count --;
      }
#line 60
      if (count <= 0LL) {
#line 61
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (count < 0LL) {
    {
#line 65
    tmp___1 = lseek((int )fd, (off_t )startpos, 0);
#line 65
    endpos = (long long )tmp___1;
    }
#line 66
    if (endpos != startpos) {
#line 67
      return (-2);
    }
#line 68
    return (-1);
  }
#line 71
  if ((unsigned long )src != (unsigned long )((void *)0)) {
#line 72
    backskip = (long long )(- (srclim - src));
#line 73
    if (backskip != 0LL) {
      {
#line 74
      tmp___2 = lseek((int )fd, (off_t )backskip, 1);
#line 74
      endpos = (long long )tmp___2;
      }
#line 75
      if (endpos == -1LL) {
#line 76
        return (-2);
      }
    }
  }
#line 80
  return (0);
}
}
#line 85 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_put.c"
static int FTPPutBlock(FTPCIPtr const   cip , char const   *cp , size_t ntowrite ) 
{ 
  ssize_t nwrote ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 93
  result = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    tmp = WaitForRemoteOutput(cip);
    }
#line 96
    if (! tmp) {
      {
#line 97
      result = -194;
#line 97
      cip->errNo = result;
#line 98
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote write timed out after %lld bytes had been sent.\n",
                  cip->bytesTransferred);
      }
#line 99
      return (result);
    }
#line 101
    if (cip->cancelXfer > 0) {
      {
#line 102
      FTPAbortDataTransfer(cip);
#line 103
      tmp___0 = -169;
#line 103
      cip->errNo = tmp___0;
#line 103
      result = tmp___0;
      }
#line 104
      return (result);
    }
    {
#line 107
    tmp___1 = SWrite(cip->dataSocket, (char const   */* const  */)cp, ntowrite, (int )cip->xferTimeout,
                     8);
#line 107
    nwrote = (ssize_t )tmp___1;
    }
#line 108
    if (nwrote < 0L) {
#line 109
      if (nwrote == -2L) {
        {
#line 110
        result = -194;
#line 110
        cip->errNo = result;
#line 111
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote write timed out after %lld bytes had been sent.\n",
                    cip->bytesTransferred);
        }
      } else {
        {
#line 112
        tmp___4 = __errno_location();
        }
#line 112
        if (*tmp___4 == 32) {
          {
#line 113
          result = -135;
#line 113
          cip->errNo = result;
#line 114
          tmp___2 = __errno_location();
#line 114
          *tmp___2 = 32;
#line 115
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Lost data connection to remote host after %lld bytes had been sent.\n",
                      cip->bytesTransferred);
          }
        } else {
          {
#line 116
          tmp___3 = __errno_location();
          }
#line 116
          if (*tmp___3 == 4) {
#line 117
            goto __Cont;
          } else {
            {
#line 119
            result = -135;
#line 119
            cip->errNo = result;
#line 120
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Remote write failed after %lld bytes had been sent.\n",
                        cip->bytesTransferred);
            }
          }
        }
      }
      {
#line 122
      shutdown(cip->dataSocket, 2);
      }
#line 123
      return (result);
    }
#line 125
    cp += nwrote;
#line 126
    ntowrite -= (size_t )nwrote;
    __Cont: /* CIL Label */ 
#line 95
    if (! (ntowrite != 0UL)) {
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  FTPUpdateIOTimer(cip);
  }
#line 130
  return (result);
}
}
#line 136 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_put.c"
int FTPPutOneF(FTPCIPtr const   cip , char const   * const  file , char const   * volatile  dstfile ,
               int xtype , int const   fdtouse , int const   appendflag , char const   * volatile  tmppfx ,
               char const   * volatile  tmpsfx , int const   resumeflag , int const   deleteflag ,
               int (* const  resumeProc)(FTPCIPtr const   cip , char const   *localpath ,
                                         long long localsize , time_t localmtime ,
                                         char const   **remotepath , long long remotesize ,
                                         time_t remotetime , long long *startPoint ) ) 
{ 
  char *buf ;
  char *cp ;
  char const   *cmd ;
  char const   *odstfile ;
  char const   *tdstfile ;
  size_t bufSize ;
  size_t l ;
  int tmpResult ;
  int result ;
  int pbrc ;
  ssize_t nread ;
  int volatile   fd ;
  char dstfile2[512] ;
  char *src ;
  char *srclim ;
  char *dst ;
  size_t ntowrite ;
  char inbuf[256] ;
  char crlf[4] ;
  int lastch_of_prev_block ;
  int lastch_of_cur_block ;
  int fstatrc ;
  int statrc ;
  long long startPoint ;
  long long localsize ;
  struct stat st ;
  time_t mdtm ;
  int volatile   vzaction ;
  int zaction ;
  int sameAsRemote ;
  int skiprc ;
  size_t skipbufsize ;
  longstring cmdStr ;
  int tmp ;
  char const   *tmp___0 ;
  char const   * volatile  tmp___1 ;
  char const   * volatile  tmp___2 ;
  char const   * volatile  tmp___3 ;
  char const   * volatile  tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  __off_t tmp___7 ;
  __off_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 165
  startPoint = 0LL;
#line 170
  zaction = 5;
#line 176
  if ((unsigned long )cip->buf == (unsigned long )((void *)0)) {
    {
#line 177
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Transfer buffer not allocated.\n");
#line 178
    cip->errNo = -175;
    }
#line 179
    return (cip->errNo);
  }
#line 182
  cip->usingTAR = 0;
#line 183
  if (fdtouse < 0) {
    {
#line 184
    tmp = open((char const   *)file, 0, 0);
#line 184
    fd = (int volatile   )tmp;
    }
#line 185
    if (fd < (int volatile   )0) {
      {
#line 186
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Cannot open local file %s for reading.\n",
                  file);
#line 187
      cip->errNo = -137;
      }
#line 188
      return (cip->errNo);
    }
  } else {
#line 191
    fd = (int volatile   )fdtouse;
  }
  {
#line 194
  fstatrc = fstat((int )fd, & st);
  }
#line 195
  if (fstatrc == 0) {
#line 195
    if ((st.st_mode & 61440U) == 16384U) {
#line 196
      if (fdtouse < 0) {
        {
#line 197
        close((int )fd);
        }
      }
#line 199
      if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 199
        tmp___0 = file;
      } else {
#line 199
        tmp___0 = (char const   */* const  */)"that";
      }
      {
#line 199
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"%s is a directory.\n",
                  tmp___0);
#line 200
      cip->errNo = -137;
      }
#line 201
      return (cip->errNo);
    }
  }
#line 204
  localsize = (long long )st.st_size;
#line 205
  if (xtype == 65) {
#line 205
    if ((unsigned long )file != (unsigned long )((void *)0)) {
#line 205
      if ((int const   )*(file + 0) != 0) {
        {
#line 206
        localsize = FTPLocalASCIIFileSize(file, cip->buf, (size_t const   )cip->bufSize);
        }
      }
    }
  }
#line 212
  if (resumeflag == 1) {
    {
#line 213
    FTPCheckForRestartModeAvailability(cip);
    }
  } else
#line 212
  if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                              char const   *localpath ,
                                                              long long localsize ,
                                                              time_t localmtime ,
                                                              char const   **remotepath ,
                                                              long long remotesize ,
                                                              time_t remotetime ,
                                                              long long *startPoint ))0)) {
    {
#line 213
    FTPCheckForRestartModeAvailability(cip);
    }
  }
#line 216
  odstfile = (char const   *)dstfile;
#line 217
  if ((unsigned long )tmppfx != (unsigned long )((void *)0)) {
#line 217
    if ((int const   )*(tmppfx + 0) != 0) {
#line 217
      goto _L;
    } else {
#line 217
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 217
  if ((unsigned long )tmpsfx != (unsigned long )((void *)0)) {
#line 217
    if ((int const   )*(tmpsfx + 0) != 0) {
      _L: /* CIL Label */ 
      {
#line 218
      cp = strrchr((char const   *)dstfile, '/');
      }
#line 219
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
        {
#line 220
        cp = strrchr((char const   *)dstfile, '\\');
        }
      }
#line 221
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 222
        if ((unsigned long )tmppfx == (unsigned long )((void *)0)) {
#line 222
          tmp___1 = (char const   */* volatile  */)"";
        } else {
#line 222
          tmp___1 = tmppfx;
        }
        {
#line 222
        Strncpy((char */* const  */)(dstfile2), (char const   */* const  */)tmp___1,
                (size_t const   )sizeof(dstfile2));
#line 223
        Strncat((char */* const  */)(dstfile2), (char const   */* const  */)dstfile,
                (size_t const   )sizeof(dstfile2));
        }
#line 224
        if ((unsigned long )tmpsfx == (unsigned long )((void *)0)) {
#line 224
          tmp___2 = (char const   */* volatile  */)"";
        } else {
#line 224
          tmp___2 = tmpsfx;
        }
        {
#line 224
        Strncat((char */* const  */)(dstfile2), (char const   */* const  */)tmp___2,
                (size_t const   )sizeof(dstfile2));
        }
      } else {
        {
#line 226
        cp ++;
#line 227
        l = (size_t )(cp - (char *)dstfile);
#line 228
        Strncpy((char */* const  */)(dstfile2), (char const   */* const  */)dstfile,
                (size_t const   )sizeof(dstfile2));
#line 229
        dstfile2[l] = (char )'\000';
        }
#line 230
        if ((unsigned long )tmppfx == (unsigned long )((void *)0)) {
#line 230
          tmp___3 = (char const   */* volatile  */)"";
        } else {
#line 230
          tmp___3 = tmppfx;
        }
        {
#line 230
        Strncat((char */* const  */)(dstfile2), (char const   */* const  */)tmp___3,
                (size_t const   )sizeof(dstfile2));
#line 231
        Strncat((char */* const  */)(dstfile2), (char const   */* const  */)cp, (size_t const   )sizeof(dstfile2));
        }
#line 232
        if ((unsigned long )tmpsfx == (unsigned long )((void *)0)) {
#line 232
          tmp___4 = (char const   */* volatile  */)"";
        } else {
#line 232
          tmp___4 = tmpsfx;
        }
        {
#line 232
        Strncat((char */* const  */)(dstfile2), (char const   */* const  */)tmp___4,
                (size_t const   )sizeof(dstfile2));
        }
      }
#line 234
      dstfile = (char const   */* volatile  */)(dstfile2);
    }
  }
#line 237
  if (fdtouse < 0) {
    {
#line 238
    AutomaticallyUseASCIIModeDependingOnExtension(cip, (char const   */* const  */)dstfile,
                                                  (int */* const  */)(& xtype));
#line 239
    mdtm = (time_t )-1;
    }
#line 240
    if ((unsigned long )cip->progress != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                    int  ))0)) {
      {
#line 241
      FTPFileSizeAndModificationTime(cip, (char const   */* const  */)dstfile, (long long */* const  */)(& startPoint),
                                     (int const   )xtype, (time_t */* const  */)(& mdtm));
      }
    } else
#line 240
    if (resumeflag == 1) {
      {
#line 241
      FTPFileSizeAndModificationTime(cip, (char const   */* const  */)dstfile, (long long */* const  */)(& startPoint),
                                     (int const   )xtype, (time_t */* const  */)(& mdtm));
      }
    } else
#line 240
    if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                                char const   *localpath ,
                                                                long long localsize ,
                                                                time_t localmtime ,
                                                                char const   **remotepath ,
                                                                long long remotesize ,
                                                                time_t remotetime ,
                                                                long long *startPoint ))0)) {
      {
#line 241
      FTPFileSizeAndModificationTime(cip, (char const   */* const  */)dstfile, (long long */* const  */)(& startPoint),
                                     (int const   )xtype, (time_t */* const  */)(& mdtm));
      }
    }
#line 244
    if (appendflag == 1) {
#line 245
      zaction = 4;
    } else
#line 246
    if (fstatrc < 0) {
#line 251
      zaction = 3;
    } else
#line 252
    if (resumeflag == 1) {
#line 253
      zaction = 5;
    } else {
#line 255
      zaction = 3;
    }
#line 258
    statrc = -1;
#line 259
    if (mdtm != -1L) {
#line 263
      statrc = 0;
    } else
#line 259
    if (startPoint != -1LL) {
#line 263
      statrc = 0;
    } else
#line 264
    if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                                char const   *localpath ,
                                                                long long localsize ,
                                                                time_t localmtime ,
                                                                char const   **remotepath ,
                                                                long long remotesize ,
                                                                time_t remotetime ,
                                                                long long *startPoint ))0)) {
#line 264
      if (cip->hasMDTM != 1) {
#line 264
        if (cip->hasSIZE != 1) {
          {
#line 271
          statrc = FTPFileExists2(cip, (char const   */* const  */)dstfile, (int const   )0,
                                  (int const   )0, (int const   )0, (int const   )1,
                                  (int const   )1);
          }
        }
      }
    }
#line 274
    sameAsRemote = 0;
#line 275
    if ((unsigned long )resumeProc != (unsigned long )((int (*)(FTPCIPtr const   cip ,
                                                                char const   *localpath ,
                                                                long long localsize ,
                                                                time_t localmtime ,
                                                                char const   **remotepath ,
                                                                long long remotesize ,
                                                                time_t remotetime ,
                                                                long long *startPoint ))0)) {
#line 275
      if (statrc == 0) {
        {
#line 279
        tdstfile = (char const   *)dstfile;
#line 280
        zaction = (*resumeProc)(cip, (char const   *)file, (long long )st.st_size,
                                st.st_mtim.tv_sec, & tdstfile, startPoint, mdtm, & startPoint);
#line 281
        dstfile = (char const   */* volatile  */)tdstfile;
        }
      }
    }
#line 284
    if (zaction == 6) {
#line 288
      cip->errNo = -195;
#line 289
      return (cip->errNo);
    }
#line 292
    if (zaction == 5) {
#line 293
      if (mdtm != -1L) {
#line 293
        if (st.st_mtim.tv_sec > mdtm + 1L) {
#line 302
          zaction = 3;
        } else {
#line 293
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 303
      if (localsize == startPoint) {
#line 305
        zaction = 1;
#line 306
        sameAsRemote = 1;
      } else
#line 307
      if (startPoint != -1LL) {
#line 307
        if (localsize > startPoint) {
#line 308
          zaction = 2;
        } else {
#line 310
          zaction = 3;
        }
      } else {
#line 310
        zaction = 3;
      }
    }
#line 314
    if (zaction == 1) {
#line 316
      if (fdtouse < 0) {
        {
#line 317
        close((int )fd);
        }
      }
#line 319
      if (deleteflag == 1) {
        {
#line 320
        tmp___5 = unlink((char const   *)file);
        }
#line 320
        if (tmp___5 < 0) {
#line 321
          cip->errNo = -167;
#line 322
          return (cip->errNo);
        }
      }
#line 325
      if (sameAsRemote != 0) {
#line 326
        cip->errNo = -197;
#line 327
        return (cip->errNo);
      }
#line 329
      return (0);
    } else
#line 330
    if (zaction == 2) {
#line 332
      if (localsize == startPoint) {
#line 334
        if (fdtouse < 0) {
          {
#line 335
          close((int )fd);
          }
        }
#line 338
        if (deleteflag == 1) {
          {
#line 339
          tmp___6 = unlink((char const   *)file);
          }
#line 339
          if (tmp___6 < 0) {
#line 340
            cip->errNo = -167;
#line 341
            return (cip->errNo);
          }
        }
#line 344
        return (0);
      } else
#line 345
      if (xtype == 65) {
#line 346
        skipbufsize = cip->bufSize;
#line 347
        if (fdtouse >= 0) {
#line 347
          if (skipbufsize > 4096UL) {
#line 348
            skipbufsize = (size_t )4096;
          }
        }
        {
#line 350
        skiprc = FTPASCIILocalFileSeek((int const   )fd, (long long const   )startPoint,
                                       (char */* const  */)cip->buf, (size_t const   )skipbufsize);
        }
#line 351
        if (skiprc == -2) {
#line 352
          cip->errNo = -204;
#line 353
          return (cip->errNo);
        } else
#line 354
        if (skiprc == -1) {
#line 356
          startPoint = 0LL;
#line 356
          cip->startPoint = startPoint;
        } else {
#line 363
          zaction = 4;
#line 364
          startPoint = 0LL;
#line 364
          cip->startPoint = startPoint;
        }
      } else {
        {
#line 366
        tmp___7 = lseek((int )fd, (off_t )startPoint, 0);
        }
#line 366
        if (tmp___7 != -1L) {
#line 367
          cip->startPoint = startPoint;
        }
      }
    } else
#line 369
    if (zaction == 4) {
#line 371
      startPoint = 0LL;
#line 371
      cip->startPoint = startPoint;
    } else {
#line 374
      startPoint = 0LL;
#line 374
      cip->startPoint = startPoint;
    }
  } else
#line 376
  if (appendflag == 1) {
#line 377
    zaction = 4;
  }
  {
#line 380
  FTPSetUploadSocketBufferSize(cip);
#line 382
  vzaction = (int volatile   )zaction;
  }
#line 383
  if (vzaction == (int volatile   )4) {
#line 384
    cmd = "APPE ";
#line 385
    tmppfx = (char const   */* volatile  */)"";
#line 386
    tmpsfx = (char const   */* volatile  */)"";
  } else {
#line 388
    cmd = "STOR ";
#line 389
    if ((unsigned long )tmppfx == (unsigned long )((void *)0)) {
#line 390
      tmppfx = (char const   */* volatile  */)"";
    }
#line 391
    if ((unsigned long )tmpsfx == (unsigned long )((void *)0)) {
#line 392
      tmpsfx = (char const   */* volatile  */)"";
    }
  }
  {
#line 395
  memcpy((void */* __restrict  */)(cmdStr), (void const   */* __restrict  */)cmd,
         (size_t )6);
#line 396
  Strncat((char */* const  */)(cmdStr), (char const   */* const  */)dstfile, (size_t const   )sizeof(cmdStr));
#line 398
  tmpResult = FTPStartDataCmd2(cip, (int const   )64, (int const   )xtype, (long long const   )startPoint,
                               (char */* const  */)(cmdStr), (size_t const   )sizeof(cmdStr),
                               "(not used)");
  }
#line 408
  if (tmpResult < 0) {
#line 409
    cip->errNo = tmpResult;
#line 410
    if (fdtouse < 0) {
      {
#line 411
      close((int )fd);
      }
    }
#line 413
    return (cip->errNo);
  }
#line 416
  if (startPoint != 0LL) {
#line 416
    if (cip->startPoint == 0LL) {
      {
#line 422
      tmp___8 = lseek((int )fd, (off_t )0, 0);
      }
#line 422
      if (tmp___8 != 0L) {
#line 423
        cip->errNo = -168;
#line 424
        if (fdtouse < 0) {
          {
#line 425
          close((int )fd);
          }
        }
#line 427
        return (cip->errNo);
      }
#line 429
      startPoint = 0LL;
    }
  }
  {
#line 432
  result = 0;
#line 433
  buf = cip->buf;
#line 434
  bufSize = cip->bufSize;
#line 436
  FTPInitIOTimer(cip);
  }
#line 437
  if (fstatrc == 0) {
#line 437
    if (((st.st_mode & 61440U) == 32768U) != 0) {
#line 438
      cip->expectedSize = (long long )st.st_size;
#line 439
      cip->mdtm = st.st_mtim.tv_sec;
    }
  }
#line 441
  cip->lname = (char const   *)file;
#line 442
  cip->rname = odstfile;
#line 443
  if (fdtouse >= 0) {
#line 444
    cip->useProgressMeter = 0;
  }
  {
#line 445
  FTPStartIOTimer(cip);
  }
#line 452
  if (xtype == 65) {
#line 455
    if (cip->asciiTranslationMode == -1) {
      {
#line 459
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 460
        nread = read((int )fd, (void *)(inbuf), sizeof(inbuf));
        }
#line 461
        if (nread < 0L) {
          {
#line 462
          tmp___9 = __errno_location();
          }
#line 462
          if (*tmp___9 == 4) {
#line 463
            goto __Cont;
          } else {
            {
#line 465
            result = -134;
#line 466
            cip->errNo = -134;
#line 467
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local read failed.\n");
            }
          }
#line 469
          goto while_break;
        } else
#line 470
        if (nread == 0L) {
#line 471
          goto while_break;
        }
        {
#line 473
        cip->bytesTransferred += (long long )nread;
#line 475
        ntowrite = (size_t )nread;
#line 476
        cp = inbuf;
#line 478
        pbrc = FTPPutBlock(cip, (char const   *)cp, ntowrite);
        }
#line 478
        if (pbrc < 0) {
#line 479
          result = pbrc;
#line 480
          goto brk;
        }
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 483
    if (cip->asciiTranslationMode == 1) {
#line 483
      goto _L___2;
    } else
#line 483
    if (cip->asciiTranslationMode == 0) {
      _L___2: /* CIL Label */ 
#line 485
      lastch_of_prev_block = 0;
      {
#line 486
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 487
        nread = read((int )fd, (void *)(inbuf), sizeof(inbuf));
        }
#line 488
        if (nread < 0L) {
          {
#line 489
          tmp___10 = __errno_location();
          }
#line 489
          if (*tmp___10 == 4) {
#line 490
            goto __Cont___0;
          } else {
            {
#line 492
            result = -134;
#line 493
            cip->errNo = -134;
#line 494
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local read failed.\n");
            }
          }
#line 496
          goto while_break___0;
        } else
#line 497
        if (nread == 0L) {
#line 498
          goto while_break___0;
        }
#line 500
        cip->bytesTransferred += (long long )nread;
#line 502
        src = inbuf;
#line 503
        srclim = src + nread;
#line 504
        lastch_of_cur_block = (int )*(srclim + -1);
#line 505
        if (lastch_of_cur_block == 13) {
#line 506
          *(srclim + -1) = (char )'\000';
#line 507
          srclim --;
#line 508
          nread --;
#line 509
          if (nread == 0L) {
#line 510
            lastch_of_prev_block = lastch_of_cur_block;
#line 511
            goto while_break___0;
          }
        }
#line 514
        dst = cip->buf;
#line 516
        if ((int )*src == 10) {
#line 517
          src ++;
#line 518
          tmp___11 = dst;
#line 518
          dst ++;
#line 518
          *tmp___11 = (char )'\r';
#line 519
          tmp___12 = dst;
#line 519
          dst ++;
#line 519
          *tmp___12 = (char )'\n';
        } else
#line 520
        if (lastch_of_prev_block == 13) {
#line 524
          tmp___13 = dst;
#line 524
          dst ++;
#line 524
          *tmp___13 = (char )'\r';
#line 525
          tmp___14 = dst;
#line 525
          dst ++;
#line 525
          *tmp___14 = (char )'\n';
        }
        {
#line 531
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 531
          if (! ((unsigned long )src < (unsigned long )srclim)) {
#line 531
            goto while_break___1;
          }
#line 532
          if ((int )*src == 13) {
#line 533
            if ((int )*(src + 1) == 10) {
#line 535
              tmp___15 = dst;
#line 535
              dst ++;
#line 535
              tmp___16 = src;
#line 535
              src ++;
#line 535
              *tmp___15 = *tmp___16;
#line 536
              tmp___17 = dst;
#line 536
              dst ++;
#line 536
              tmp___18 = src;
#line 536
              src ++;
#line 536
              *tmp___17 = *tmp___18;
            } else {
#line 539
              tmp___19 = dst;
#line 539
              dst ++;
#line 539
              tmp___20 = src;
#line 539
              src ++;
#line 539
              *tmp___19 = *tmp___20;
#line 540
              tmp___21 = dst;
#line 540
              dst ++;
#line 540
              *tmp___21 = (char )'\n';
            }
          } else
#line 542
          if ((int )*src == 10) {
#line 544
            tmp___22 = dst;
#line 544
            dst ++;
#line 544
            *tmp___22 = (char )'\r';
#line 545
            tmp___23 = dst;
#line 545
            dst ++;
#line 545
            tmp___24 = src;
#line 545
            src ++;
#line 545
            *tmp___23 = *tmp___24;
          } else {
#line 547
            tmp___25 = dst;
#line 547
            dst ++;
#line 547
            tmp___26 = src;
#line 547
            src ++;
#line 547
            *tmp___25 = *tmp___26;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 550
        lastch_of_prev_block = lastch_of_cur_block;
#line 552
        ntowrite = (size_t )(dst - cip->buf);
#line 553
        cp = cip->buf;
#line 555
        pbrc = FTPPutBlock(cip, (char const   *)cp, ntowrite);
        }
#line 555
        if (pbrc < 0) {
#line 556
          result = pbrc;
#line 557
          goto brk;
        }
        __Cont___0: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 561
      if (lastch_of_prev_block == 13) {
        {
#line 566
        crlf[0] = (char )'\r';
#line 567
        crlf[1] = (char )'\n';
#line 568
        crlf[2] = (char )'\000';
#line 569
        cp = crlf;
#line 570
        ntowrite = (size_t )2;
#line 572
        pbrc = FTPPutBlock(cip, (char const   *)cp, ntowrite);
        }
#line 572
        if (pbrc < 0) {
#line 573
          result = pbrc;
#line 574
          goto brk;
        }
      }
    }
  } else {
    {
#line 580
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 581
      cp = buf;
#line 582
      nread = read((int )fd, (void *)cp, bufSize);
      }
#line 583
      if (nread < 0L) {
        {
#line 584
        tmp___27 = __errno_location();
        }
#line 584
        if (*tmp___27 == 4) {
#line 585
          goto __Cont___1;
        } else {
          {
#line 587
          result = -134;
#line 588
          cip->errNo = -134;
#line 589
          FTPLogError(cip, (int const   )1, (char const   */* const  */)"Local read failed.\n");
          }
        }
#line 591
        goto while_break___2;
      } else
#line 592
      if (nread == 0L) {
#line 593
        goto while_break___2;
      }
      {
#line 595
      cip->bytesTransferred += (long long )nread;
#line 597
      ntowrite = (size_t )nread;
#line 598
      pbrc = FTPPutBlock(cip, (char const   *)cp, ntowrite);
      }
#line 598
      if (pbrc < 0) {
#line 599
        result = pbrc;
#line 600
        goto brk;
      }
      __Cont___1: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  brk: 
  {
#line 622
  shutdown(cip->dataSocket, 1);
#line 623
  WaitForRemoteInput(cip);
#line 625
  tmpResult = FTPEndDataCmd(cip, 1);
  }
#line 626
  if (tmpResult < 0) {
#line 626
    if (result == 0) {
#line 627
      result = -132;
#line 627
      cip->errNo = result;
    }
  }
  {
#line 629
  FTPStopIOTimer(cip);
  }
#line 631
  if (fdtouse < 0) {
    {
#line 636
    fstat((int )fd, & st);
#line 637
    close((int )fd);
#line 638
    fd = (int volatile   )-1;
    }
  }
#line 641
  if (result == 0) {
#line 646
    (cip->numUploads) ++;
#line 648
    if ((int const   )*(tmppfx + 0) != 0) {
#line 648
      goto _L___3;
    } else
#line 648
    if ((int const   )*(tmpsfx + 0) != 0) {
      _L___3: /* CIL Label */ 
      {
#line 649
      result = FTPRename(cip, (char const   */* const  */)dstfile, (char const   */* const  */)odstfile);
      }
#line 649
      if (result < 0) {
        {
#line 654
        tmp___30 = FTPDelete(cip, (char const   */* const  */)odstfile, (int const   )0,
                             (int const   )0);
        }
#line 654
        if (tmp___30 == 0) {
          {
#line 655
          result = FTPRename(cip, (char const   */* const  */)dstfile, (char const   */* const  */)odstfile);
          }
#line 656
          if (result < 0) {
            {
#line 657
            tmp___28 = FTPStrError(cip->errNo);
#line 657
            FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not rename %s to %s: %s.\n",
                        dstfile, odstfile, tmp___28);
            }
          }
        } else {
          {
#line 660
          tmp___29 = FTPStrError(cip->errNo);
#line 660
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not delete old %s, so could not rename %s to that: %s\n",
                      odstfile, dstfile, tmp___29);
          }
        }
      }
    }
    {
#line 665
    tmp___32 = FTPUtime(cip, (char const   */* const  */)odstfile, st.st_atim.tv_sec,
                        st.st_mtim.tv_sec, st.st_ctim.tv_sec);
    }
#line 665
    if (tmp___32 != 0) {
#line 666
      if (cip->errNo != -165) {
        {
#line 667
        tmp___31 = FTPStrError(cip->errNo);
#line 667
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not preserve times for %s: %s.\n",
                    odstfile, tmp___31);
        }
      }
    }
#line 670
    if (result == 0) {
#line 670
      if (deleteflag == 1) {
        {
#line 671
        tmp___34 = unlink((char const   *)file);
        }
#line 671
        if (tmp___34 < 0) {
#line 672
          tmp___33 = -167;
#line 672
          cip->errNo = tmp___33;
#line 672
          result = tmp___33;
        }
      }
    }
  }
#line 677
  return (result);
}
}
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putmem.c"
int FTPPutFileFromMemory(FTPCIPtr const   cip , char const   * volatile  dstfile ,
                         char const   * volatile  src , size_t const   srcLen , int const   appendflag ) 
{ 
  char const   *cp ;
  char const   *cmd ;
  int tmpResult ;
  int result ;
  ssize_t nread ;
  ssize_t nwrote ;
  size_t bufSize ;
  char const   *srcLim ;
  char const   * volatile  srcp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 39
  if ((unsigned long )cip->buf == (unsigned long )((void *)0)) {
    {
#line 40
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Transfer buffer not allocated.\n");
#line 41
    cip->errNo = -175;
    }
#line 42
    return (cip->errNo);
  }
  {
#line 45
  cip->usingTAR = 0;
#line 50
  FTPCheckForRestartModeAvailability(cip);
#line 52
  FTPSetUploadSocketBufferSize(cip);
  }
#line 77
  if (appendflag == 1) {
#line 77
    cmd = "APPE";
  } else {
#line 77
    cmd = "STOR";
  }
  {
#line 78
  tmpResult = FTPStartDataCmd(cip, (int const   )64, (int const   )'I', (long long const   )0LL,
                              (char const   */* const  */)"%s %s", cmd, dstfile);
  }
#line 88
  if (tmpResult < 0) {
#line 89
    cip->errNo = tmpResult;
#line 93
    return (cip->errNo);
  }
  {
#line 96
  result = 0;
#line 97
  bufSize = cip->bufSize;
#line 99
  FTPInitIOTimer(cip);
#line 100
  cip->expectedSize = (long long )srcLen;
#line 101
  cip->lname = (char const   *)((void *)0);
#line 102
  cip->rname = (char const   *)dstfile;
#line 103
  srcp = src;
#line 104
  srcLim = (char const   *)(src + srcLen);
#line 105
  FTPStartIOTimer(cip);
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    nread = (ssize_t )bufSize;
#line 113
    if ((size_t )(srcLim - (char const   *)srcp) < bufSize) {
#line 114
      nread = srcLim - (char const   *)srcp;
#line 115
      if (nread == 0L) {
#line 116
        result = 0;
#line 117
        goto while_break;
      }
    }
#line 120
    cip->bytesTransferred += (long long )nread;
#line 121
    cp = (char const   *)srcp;
#line 122
    srcp += nread;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 130
      tmp = WaitForRemoteOutput(cip);
      }
#line 130
      if (! tmp) {
        {
#line 131
        result = -194;
#line 131
        cip->errNo = result;
#line 132
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote write timed out.\n");
        }
#line 133
        goto brk;
      }
#line 135
      if (cip->cancelXfer > 0) {
        {
#line 136
        FTPAbortDataTransfer(cip);
#line 137
        tmp___0 = -169;
#line 137
        cip->errNo = tmp___0;
#line 137
        result = tmp___0;
        }
#line 138
        goto brk;
      }
      {
#line 142
      tmp___1 = SWrite(cip->dataSocket, (char const   */* const  */)cp, (size_t )nread,
                       (int )cip->xferTimeout, 8);
#line 142
      nwrote = (ssize_t )tmp___1;
      }
#line 143
      if (nwrote < 0L) {
#line 144
        if (nwrote == -2L) {
          {
#line 145
          result = -194;
#line 145
          cip->errNo = result;
#line 146
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"Remote write timed out.\n");
          }
        } else {
          {
#line 147
          tmp___4 = __errno_location();
          }
#line 147
          if (*tmp___4 == 32) {
            {
#line 148
            result = -135;
#line 148
            cip->errNo = result;
#line 149
            tmp___2 = __errno_location();
#line 149
            *tmp___2 = 32;
#line 150
            FTPLogError(cip, (int const   )1, (char const   */* const  */)"Lost data connection to remote host.\n");
            }
          } else {
            {
#line 151
            tmp___3 = __errno_location();
            }
#line 151
            if (*tmp___3 == 4) {
#line 152
              goto __Cont;
            } else {
              {
#line 154
              result = -135;
#line 154
              cip->errNo = result;
#line 155
              FTPLogError(cip, (int const   )1, (char const   */* const  */)"Remote write failed.\n");
              }
            }
          }
        }
        {
#line 157
        shutdown(cip->dataSocket, 2);
        }
#line 158
        goto brk;
      }
#line 177
      cp += nwrote;
#line 178
      nread -= nwrote;
      __Cont: /* CIL Label */ 
#line 129
      if (! (nread > 0L)) {
#line 129
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 180
    FTPUpdateIOTimer(cip);
    }
  }
  while_break: /* CIL Label */ ;
  }
  brk: 
  {
#line 201
  shutdown(cip->dataSocket, 1);
#line 202
  WaitForRemoteInput(cip);
#line 209
  tmpResult = FTPEndDataCmd(cip, 1);
  }
#line 210
  if (tmpResult < 0) {
#line 210
    if (result == 0) {
#line 211
      result = -132;
#line 211
      cip->errNo = result;
    }
  }
  {
#line 213
  FTPStopIOTimer(cip);
  }
#line 215
  if (result == 0) {
#line 220
    (cip->numUploads) ++;
  }
#line 226
  return (result);
}
}
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/StrFree.c"
void StrFree(char **dst ) 
{ 


  {
#line 30
  if ((unsigned long )dst != (unsigned long )((char **)0)) {
#line 31
    if ((unsigned long )*dst != (unsigned long )((void *)0)) {
      {
#line 32
      free((void *)*dst);
#line 33
      *dst = (char *)((void *)0);
      }
    }
  }
#line 36
  return;
}
}
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_utime.c"
static void GmTimeStr(char * const  dst , size_t const   dstsize , time_t t ) 
{ 
  char buf[64] ;
  struct tm gt ;
  struct tm *tmp ;

  {
  {
#line 21
  tmp = Gmtime(t, (struct tm */* const  */)(& gt));
  }
#line 21
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 22
    *(dst + 0) = (char )'\000';
  } else {
    {
#line 25
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 26
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%04d%02d%02d%02d%02d%02d",
             gt.tm_year + 1900, gt.tm_mon + 1, gt.tm_mday, gt.tm_hour, gt.tm_min,
             gt.tm_sec);
#line 37
    Strncpy(dst, (char const   */* const  */)(buf), dstsize);
    }
  }
#line 39
  return;
}
}
#line 44 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_utime.c"
int FTPUtime(FTPCIPtr const   cip , char const   * const  file , time_t actime , time_t modtime ,
             time_t crtime ) 
{ 
  char mstr[64] ;
  char astr[64] ;
  char cstr[64] ;
  time_t now ;
  int result ;
  int wantToSetCrTime ;
  ResponsePtr rp ;
  int tmp ;
  char *tmp___0 ;

  {
#line 49
  result = 0;
#line 50
  wantToSetCrTime = 1;
#line 53
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 54
    return (-139);
  }
  {
#line 55
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 55
  if (tmp) {
#line 56
    return (-138);
  }
#line 58
  now = (time_t )0;
#line 59
  if (modtime == 0L) {
    {
#line 60
    modtime = time(& now);
    }
  } else
#line 59
  if (modtime == -1L) {
    {
#line 60
    modtime = time(& now);
    }
  }
  {
#line 61
  GmTimeStr((char */* const  */)(mstr), (size_t const   )sizeof(mstr), modtime);
  }
#line 63
  if (actime == 0L) {
#line 63
    goto _L;
  } else
#line 63
  if (actime == -1L) {
    _L: /* CIL Label */ 
#line 64
    if (now != 0L) {
#line 65
      actime = now;
    } else {
      {
#line 67
      actime = time(& now);
      }
    }
  }
#line 70
  if (crtime == 0L) {
#line 70
    goto _L___0;
  } else
#line 70
  if (crtime == -1L) {
    _L___0: /* CIL Label */ 
#line 71
    wantToSetCrTime = 0;
#line 72
    if (now != 0L) {
#line 73
      crtime = now;
    } else {
      {
#line 75
      crtime = time(& now);
      }
    }
  }
  {
#line 78
  GmTimeStr((char */* const  */)(astr), (size_t const   )sizeof(astr), actime);
#line 79
  GmTimeStr((char */* const  */)(cstr), (size_t const   )sizeof(cstr), crtime);
  }
#line 81
  if (cip->hasMFF == 1) {
#line 81
    if (wantToSetCrTime != 0) {
      {
#line 82
      result = FTPCmd(cip, (char const   */* const  */)"MFF Modify=%s;Create=%s %s",
                      mstr, cstr, file);
      }
#line 83
      if (result == 2) {
#line 84
        result = 0;
#line 85
        return (result);
      } else
#line 83
      if (result == 0) {
#line 84
        result = 0;
#line 85
        return (result);
      } else {
#line 87
        cip->errNo = -164;
#line 88
        result = -164;
      }
    }
  }
#line 95
  if (cip->hasMFMT == 1) {
    {
#line 96
    result = FTPCmd(cip, (char const   */* const  */)"MFMT %s %s", mstr, file);
    }
#line 97
    if (result == 2) {
#line 98
      result = 0;
    } else
#line 97
    if (result == 0) {
#line 98
      result = 0;
    } else {
#line 100
      cip->errNo = -164;
#line 101
      result = -164;
    }
#line 103
    return (result);
  }
#line 106
  if (result == 0) {
#line 107
    result = -165;
  }
#line 108
  if (cip->hasSITE_UTIME != 0) {
    {
#line 109
    rp = InitResponse();
    }
#line 110
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 111
      result = -123;
#line 112
      cip->errNo = -123;
#line 113
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
      }
    } else {
      {
#line 115
      result = RCmd(cip, rp, "SITE UTIME %s %s %s %s UTC", file, astr, mstr, cstr);
      }
#line 116
      if (result < 0) {
        {
#line 117
        DoneWithResponse(cip, rp);
        }
#line 118
        return (result);
      } else
#line 119
      if (result == 2) {
        {
#line 120
        cip->hasSITE_UTIME = 1;
#line 121
        result = 0;
#line 122
        DoneWithResponse(cip, rp);
        }
      } else
#line 123
      if (rp->code == 500) {
        {
#line 124
        cip->hasSITE_UTIME = 0;
#line 125
        cip->errNo = -165;
#line 126
        result = -165;
#line 127
        DoneWithResponse(cip, rp);
        }
      } else
#line 123
      if (rp->code == 502) {
        {
#line 124
        cip->hasSITE_UTIME = 0;
#line 125
        cip->errNo = -165;
#line 126
        result = -165;
#line 127
        DoneWithResponse(cip, rp);
        }
      } else
#line 123
      if (rp->code == 504) {
        {
#line 124
        cip->hasSITE_UTIME = 0;
#line 125
        cip->errNo = -165;
#line 126
        result = -165;
#line 127
        DoneWithResponse(cip, rp);
        }
      } else
#line 123
      if (rp->code == 501) {
        {
#line 124
        cip->hasSITE_UTIME = 0;
#line 125
        cip->errNo = -165;
#line 126
        result = -165;
#line 127
        DoneWithResponse(cip, rp);
        }
      } else
#line 128
      if (cip->serverType == 2) {
        {
#line 128
        tmp___0 = strchr((char const   *)file, ' ');
        }
#line 128
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          {
#line 132
          DoneWithResponse(cip, rp);
#line 133
          result = FTPCmd(cip, (char const   */* const  */)"MDTM %s %s", mstr, file);
          }
#line 134
          if (result == 2) {
#line 135
            result = 0;
          } else
#line 134
          if (result == 0) {
#line 135
            result = 0;
          } else {
#line 137
            cip->errNo = -164;
#line 138
            result = -164;
          }
        } else {
          {
#line 141
          cip->errNo = -164;
#line 142
          result = -164;
#line 143
          DoneWithResponse(cip, rp);
          }
        }
      } else {
        {
#line 141
        cip->errNo = -164;
#line 142
        result = -164;
#line 143
        DoneWithResponse(cip, rp);
        }
      }
    }
  }
#line 147
  if (result == -165) {
#line 148
    if (cip->hasMDTM == 0) {
#line 149
      cip->errNo = -165;
#line 150
      result = -165;
    } else
#line 148
    if (cip->hasMDTM_set == 0) {
#line 149
      cip->errNo = -165;
#line 150
      result = -165;
    } else {
      {
#line 152
      rp = InitResponse();
      }
#line 153
      if ((unsigned long )rp == (unsigned long )((void *)0)) {
        {
#line 154
        result = -123;
#line 155
        cip->errNo = -123;
#line 156
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
        }
      } else {
        {
#line 158
        result = RCmd(cip, rp, "MDTM %s %s", mstr, file);
        }
#line 159
        if (result < 0) {
          {
#line 160
          DoneWithResponse(cip, rp);
          }
#line 161
          return (result);
        } else
#line 162
        if (result == 2) {
#line 163
          cip->hasMDTM_set = 1;
#line 164
          result = 0;
        } else {
#line 186
          if (rp->code == 500) {
#line 187
            cip->hasMDTM_set = 0;
          } else
#line 186
          if (rp->code == 502) {
#line 187
            cip->hasMDTM_set = 0;
          } else
#line 186
          if (rp->code == 504) {
#line 187
            cip->hasMDTM_set = 0;
          } else
#line 186
          if (rp->code == 501) {
#line 187
            cip->hasMDTM_set = 0;
          } else
#line 186
          if (rp->code == 550) {
#line 187
            cip->hasMDTM_set = 0;
          }
#line 188
          cip->errNo = -165;
#line 189
          result = -165;
        }
        {
#line 191
        DoneWithResponse(cip, rp);
        }
      }
    }
  }
#line 195
  return (result);
}
}
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/log.h"
void EndLog(void) ;
#line 16
void InitLog(void) ;
#line 17
void LogOpen(char const   * const  host ) ;
#line 18
void LogXfer(char const   * const  mode , char const   * const  url ) ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/log.c"
char gLogFileName[256]  ;
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/log.c"
void InitLog(void) 
{ 


  {
  {
#line 25
  OurDirectoryPath((char */* const  */)(gLogFileName), (size_t const   )sizeof(gLogFileName),
                   (char const   */* const  */)"log");
  }
#line 26
  return;
}
}
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/log.c"
void LogXfer(char const   * const  mode , char const   * const  url ) 
{ 
  FILE *fp ;

  {
#line 35
  if (gMaxLogSize == 0) {
#line 36
    return;
  }
  {
#line 38
  fp = fopen((char const   */* __restrict  */)(gLogFileName), (char const   */* __restrict  */)"a");
  }
#line 39
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 40
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %s %s\n",
            mode, url);
#line 41
    fclose(fp);
    }
  }
#line 43
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/log.c"
void LogOpen(char const   * const  host ) 
{ 
  time_t now ;
  FILE *fp ;
  char *tmp ;

  {
#line 53
  if (gMaxLogSize == 0) {
#line 54
    return;
  }
  {
#line 56
  time(& now);
#line 57
  fp = fopen((char const   */* __restrict  */)(gLogFileName), (char const   */* __restrict  */)"a");
  }
#line 58
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 59
    tmp = ctime((time_t const   *)(& now));
#line 59
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s at %s",
            host, tmp);
#line 60
    fclose(fp);
    }
  }
#line 62
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/log.c"
void EndLog(void) 
{ 
  FILE *newfp ;
  FILE *oldfp ;
  struct stat st ;
  long fat ;
  char str[512] ;
  char siteline[128] ;
  char tmpLog[256] ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 77
  if ((int )gOurDirectoryPath[0] == 0) {
#line 78
    return;
  }
#line 84
  if (gMaxLogSize <= 0) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = stat((char const   */* __restrict  */)(gLogFileName), (struct stat */* __restrict  */)(& st));
    }
#line 84
    if (tmp < 0) {
#line 85
      return;
    }
  }
#line 87
  if ((size_t )st.st_size < (size_t )gMaxLogSize) {
#line 88
    return;
  }
  {
#line 90
  oldfp = fopen((char const   */* __restrict  */)(gLogFileName), (char const   */* __restrict  */)"r");
  }
#line 90
  if ((unsigned long )oldfp == (unsigned long )((void *)0)) {
#line 91
    return;
  }
#line 96
  fat = (st.st_size - (long )gMaxLogSize) + (long )(0.20 * (double )gMaxLogSize);
#line 97
  siteline[0] = (char )'\000';
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (fat > 0L)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp___0 = fgets((char */* __restrict  */)(str), (int )sizeof(str), (FILE */* __restrict  */)oldfp);
    }
#line 99
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 100
      return;
    }
    {
#line 101
    tmp___1 = strlen((char const   *)(str));
#line 101
    fat -= (long )tmp___1;
#line 102
    tmp___2 = __ctype_b_loc();
    }
#line 102
    if (! ((int const   )*(*tmp___2 + (int )str[0]) & 8192)) {
      {
#line 103
      Strncpy((char */* const  */)(siteline), (char const   */* const  */)(str), (size_t const   )sizeof(siteline));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  fat = 0L;
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (fat < (long )(0.10 * (double )gMaxLogSize))) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    tmp___3 = fgets((char */* __restrict  */)(str), (int )sizeof(str), (FILE */* __restrict  */)oldfp);
    }
#line 107
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
#line 108
      fclose(oldfp);
#line 109
      remove((char const   *)(gLogFileName));
      }
#line 110
      return;
    }
    {
#line 112
    tmp___4 = strlen((char const   *)(str));
#line 112
    fat += (long )tmp___4;
#line 113
    tmp___5 = __ctype_b_loc();
    }
#line 113
    if (! ((int const   )*(*tmp___5 + (int )str[0]) & 8192)) {
#line 114
      siteline[0] = (char )'\000';
#line 115
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 120
  OurDirectoryPath((char */* const  */)(tmpLog), (size_t const   )sizeof(tmpLog),
                   (char const   */* const  */)"log.tmp");
#line 121
  newfp = fopen((char const   */* __restrict  */)(tmpLog), (char const   */* __restrict  */)"w");
  }
#line 121
  if ((unsigned long )newfp == (unsigned long )((void *)0)) {
    {
#line 122
    fclose(oldfp);
    }
#line 123
    return;
  }
#line 125
  if ((int )siteline[0] != 0) {
    {
#line 126
    tmp___7 = strlen((char const   *)(siteline));
    }
#line 126
    if ((int )siteline[tmp___7 - 1UL] == 10) {
      {
#line 127
      tmp___6 = strlen((char const   *)(siteline));
#line 127
      siteline[tmp___6 - 1UL] = (char )'\000';
      }
    }
    {
#line 128
    tmp___9 = strlen((char const   *)(siteline));
    }
#line 128
    if ((int )siteline[tmp___9 - 1UL] == 13) {
      {
#line 129
      tmp___8 = strlen((char const   *)(siteline));
#line 129
      siteline[tmp___8 - 1UL] = (char )'\000';
      }
    }
    {
#line 131
    tmp___10 = strstr((char const   *)(siteline), "(other entries from this session have been purged)");
    }
#line 131
    if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
      {
#line 135
      fprintf((FILE */* __restrict  */)newfp, (char const   */* __restrict  */)"%s\n",
              siteline);
      }
    } else {
      {
#line 137
      fprintf((FILE */* __restrict  */)newfp, (char const   */* __restrict  */)"%s %s\n",
              siteline, "(other entries from this session have been purged)");
      }
    }
  }
  {
#line 144
  fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)newfp);
  }
  {
#line 145
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 145
    tmp___11 = fgets((char */* __restrict  */)(str), (int )sizeof(str), (FILE */* __restrict  */)oldfp);
    }
#line 145
    if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 145
      goto while_break___1;
    }
    {
#line 146
    fputs((char const   */* __restrict  */)(str), (FILE */* __restrict  */)newfp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 147
  fclose(oldfp);
#line 148
  fclose(newfp);
#line 149
  tmp___12 = remove((char const   *)(gLogFileName));
  }
#line 149
  if (tmp___12 < 0) {
#line 150
    return;
  }
  {
#line 151
  tmp___13 = rename((char const   *)(tmpLog), (char const   *)(gLogFileName));
  }
#line 151
  if (tmp___13 < 0) {
#line 152
    return;
  }
#line 153
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
void DStrFree(DStr * const  dst ) ;
#line 70
void DStrClear(DStr * const  dst ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrFree.c"
void DStrClear(DStr * const  dst ) 
{ 


  {
#line 9
  if (! (((long )dst->s & 1L) != 0L)) {
#line 9
    if (! ((dst->allocSize & 4278190095UL) != 0UL)) {
#line 9
      if (! ((dst->len & 4278190080UL) != 0UL)) {
#line 10
        if ((unsigned long )dst->s != (unsigned long )((void *)0)) {
          {
#line 11
          memset((void *)dst->s, 0, dst->allocSize);
          }
        }
#line 12
        dst->len = (size_t )0;
      }
    }
  }
#line 14
  return;
}
}
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrFree.c"
void DStrFree(DStr * const  dst ) 
{ 


  {
#line 21
  if (! (((long )dst->s & 1L) != 0L)) {
#line 21
    if (! ((dst->allocSize & 4278190095UL) != 0UL)) {
#line 21
      if (! ((dst->len & 4278190080UL) != 0UL)) {
#line 22
        if ((unsigned long )dst->s != (unsigned long )((void *)0)) {
          {
#line 23
          free((void *)dst->s);
          }
        }
      }
    }
  }
  {
#line 25
  memset((void *)dst, 0, sizeof(DStr ));
  }
#line 26
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.h"
void PrPhilBar(FTPCIPtr const   cip , int mode ) ;
#line 63 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/pref.c"
void (*gProgressMeter)(FTPCIPtr const    , int  )  ;
#line 398 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/pref.c"
static void Show1___0(int t ) 
{ 
  PrefOpt *p___5 ;

  {
  {
#line 401
  p___5 = & gPrefOpts[t];
#line 403
  printf((char const   */* __restrict  */)"%-30s ", p___5->varname);
  }
#line 404
  if ((unsigned long )p___5->proc != (unsigned long )((void (*)(char const   * const   ,
                                                                FILE * const  fp ))0)) {
    {
#line 405
    (*(p___5->proc))((char const   */* const  */)((void *)0), (FILE */* const  */)stdout);
    }
  }
  {
#line 406
  printf((char const   */* __restrict  */)"\n");
  }
#line 407
  return;
}
}
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 232 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SRecv(int sfd , char * const  buf0 , size_t size , int fl , int tlen , int retry ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SRecv.c"
int SRecv(int sfd , char * const  buf0 , size_t size , int fl , int tlen , int retry ) 
{ 
  ssize_t nread ;
  size_t nleft ;
  char *buf ;
  int tleft ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  int firstRead ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0 ;
  int __d1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 11
  buf = (char *)buf0;
#line 17
  sigpipe = (void (*)(int  ))0;
#line 19
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (size == 0UL) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (tlen <= 0) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  }
#line 24
  if (sio_sigpipe_ignored_already) {
#line 24
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 24
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 24
    sigpipe = tmp___0;
    }
  }
  {
#line 25
  tmp___1 = __errno_location();
#line 25
  *tmp___1 = 0;
#line 27
  nleft = size;
#line 28
  time(& now);
#line 29
  done = now + (time_t )tlen;
#line 30
  firstRead = 1;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (done > now) {
#line 33
      tleft = (int )(done - now);
    } else {
#line 33
      tleft = 0;
    }
#line 34
    if (tleft < 1) {
#line 35
      nread = (ssize_t )size - (ssize_t )nleft;
#line 36
      if (nread == 0L) {
        {
#line 37
        nread = (ssize_t )-2;
#line 38
        tmp___2 = __errno_location();
#line 38
        *tmp___2 = 110;
        }
      } else
#line 36
      if ((retry & 3) != 0) {
        {
#line 37
        nread = (ssize_t )-2;
#line 38
        tmp___2 = __errno_location();
#line 38
        *tmp___2 = 110;
        }
      }
#line 41
      goto done;
    }
#line 44
    if (! firstRead) {
#line 44
      goto _L;
    } else
#line 44
    if ((retry & 8) == 0) {
      _L: /* CIL Label */ 
      {
#line 45
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 46
        tmp___3 = __errno_location();
#line 46
        *tmp___3 = 0;
        }
        {
#line 47
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 47
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& ss.__fds_bits[0]): "memory");
#line 47
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 52
        ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 56
        tv.tv_sec = (__time_t )((long long )tleft);
#line 57
        tv.tv_usec = (__suseconds_t )0;
#line 58
        result = select(sfd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 59
        if (result >= 1) {
#line 61
          goto while_break___0;
        } else
#line 62
        if (result == 0) {
#line 64
          nread = (ssize_t )size - (ssize_t )nleft;
#line 65
          if (nread > 0L) {
#line 65
            if ((retry & 3) == 0) {
#line 66
              if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 66
                if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
                  {
#line 66
                  signal(13, sigpipe);
                  }
                }
              }
#line 67
              return ((int )nread);
            }
          }
          {
#line 69
          tmp___4 = __errno_location();
#line 69
          *tmp___4 = 110;
          }
#line 71
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 71
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 71
              signal(13, sigpipe);
              }
            }
          }
#line 72
          return (-2);
        } else {
          {
#line 73
          tmp___5 = __errno_location();
          }
#line 73
          if (*tmp___5 != 4) {
#line 74
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 74
              if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
                {
#line 74
                signal(13, sigpipe);
                }
              }
            }
#line 75
            return (-1);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 78
      firstRead = 0;
    }
    {
#line 81
    nread = recv(sfd, (void *)buf, nleft, fl);
    }
#line 83
    if (nread <= 0L) {
#line 84
      if (nread == 0L) {
#line 86
        if (retry == ((retry & 2) != 0)) {
#line 87
          nread = (ssize_t )size - (ssize_t )nleft;
        }
#line 88
        goto done;
      } else {
        {
#line 89
        tmp___7 = __errno_location();
        }
#line 89
        if (*tmp___7 != 4) {
#line 90
          nread = (ssize_t )size - (ssize_t )nleft;
#line 91
          if (nread == 0L) {
#line 92
            nread = (ssize_t )-1;
          }
#line 93
          goto done;
        } else {
          {
#line 95
          tmp___6 = __errno_location();
#line 95
          *tmp___6 = 0;
#line 96
          nread = (ssize_t )0;
          }
        }
      }
    }
#line 100
    nleft -= (size_t )nread;
#line 101
    if (nleft == 0UL) {
#line 102
      goto while_break;
    } else
#line 101
    if ((retry & 3) == 0) {
#line 101
      if (nleft != size) {
#line 102
        goto while_break;
      }
    }
    {
#line 103
    buf += nread;
#line 104
    time(& now);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  nread = (ssize_t )size - (ssize_t )nleft;
  done: 
#line 109
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 109
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 109
      signal(13, sigpipe);
      }
    }
  }
#line 110
  return ((int )nread);
}
}
#line 922 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPSymlink(FTPCIPtr const   cip , char const   * const  lfrom , char const   * const  lto ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_symlink.c"
int FTPSymlink(FTPCIPtr const   cip , char const   * const  lfrom , char const   * const  lto ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 16
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 16
  if (tmp) {
#line 17
    return (-138);
  }
#line 18
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 19
    return (-139);
  } else
#line 18
  if ((unsigned long )lfrom == (unsigned long )((void *)0)) {
#line 19
    return (-139);
  } else
#line 18
  if ((unsigned long )lto == (unsigned long )((void *)0)) {
#line 19
    return (-139);
  }
#line 20
  if ((int const   )*(lfrom + 0) == 0) {
#line 21
    return (-139);
  } else
#line 20
  if ((int const   )*(lto + 0) == 0) {
#line 21
    return (-139);
  }
  {
#line 22
  tmp___0 = FTPCmd(cip, (char const   */* const  */)"SITE SYMLINK %s %s", lfrom, lto);
  }
#line 22
  if (tmp___0 == 2) {
#line 23
    return (0);
  }
#line 24
  cip->errNo = -170;
#line 25
  return (-170);
}
}
#line 883 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPDecodeHostName(FTPCIPtr const   cip , char const   * const  hstr0 ) ;
#line 915
int FTPReadLoginConfigFile(FTPCIPtr cip , char const   * const  fn ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_decodehost.c"
int FTPDecodeHostName(FTPCIPtr const   cip , char const   * const  hstr0 ) 
{ 
  char hstr[256] ;
  char *cp ;
  char *hcp ;
  int port ;
  FILE *fp ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 28
  if ((int const   )*(hstr0 + 0) == 47) {
    {
#line 30
    tmp = FTPReadLoginConfigFile((FTPCIPtr )cip, hstr0);
    }
#line 30
    return (tmp);
  }
  {
#line 33
  Strncpy((char */* const  */)(hstr), hstr0, (size_t const   )sizeof(hstr));
#line 34
  cp = strchr((char const   *)(hstr), '@');
  }
#line 35
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 36
    hcp = hstr;
  } else {
    {
#line 39
    tmp___0 = cp;
#line 39
    cp ++;
#line 39
    *tmp___0 = (char )'\000';
#line 40
    hcp = cp;
#line 41
    cp = strchr((char const   *)(hstr), ':');
    }
#line 42
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 44
      tmp___1 = cp;
#line 44
      cp ++;
#line 44
      *tmp___1 = (char )'\000';
#line 45
      Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)cp, (size_t const   )sizeof(cip->pass));
      }
    } else {
      {
#line 47
      cp = strchr((char const   *)(hstr), '/');
      }
#line 48
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 50
        fp = fopen((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"r");
#line 51
        *cp = (char )'\000';
        }
#line 52
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 54
          return (-3);
        }
        {
#line 56
        tmp___2 = FGets(cip->pass, sizeof(cip->pass), fp);
        }
#line 56
        if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 57
          return (-4);
        }
        {
#line 59
        fclose(fp);
        }
      }
    }
    {
#line 67
    Strncpy((char */* const  */)(cip->user), (char const   */* const  */)(hstr), (size_t const   )sizeof(cip->user));
    }
  }
  {
#line 70
  cp = strchr((char const   *)hcp, '@');
  }
#line 71
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 73
    return (-1);
  }
  {
#line 76
  cp = strchr((char const   *)hcp, ':');
  }
#line 77
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 79
    tmp___3 = cp;
#line 79
    cp ++;
#line 79
    *tmp___3 = (char )'\000';
#line 80
    port = atoi((char const   *)cp);
    }
#line 81
    if (port <= 0) {
#line 82
      return (-2);
    } else
#line 81
    if (port > 65535) {
#line 82
      return (-2);
    }
#line 83
    cip->port = (unsigned int )port;
  }
  {
#line 86
  Strncpy((char */* const  */)(cip->host), (char const   */* const  */)hcp, (size_t const   )sizeof(cip->host));
  }
#line 87
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_decodehost.c"
int FTPReadLoginConfigFile(FTPCIPtr cip , char const   * const  fn ) 
{ 
  FILE *fp ;
  char line[256] ;
  char *cp ;
  int goodfile ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 99
  goodfile = 0;
#line 101
  fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"r");
  }
#line 102
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 103
    return (-1);
  }
  {
#line 106
  memset((void *)(line), 0, sizeof(line));
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp___10 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL),
                     (FILE */* __restrict  */)fp);
    }
#line 107
    if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 107
      goto while_break;
    }
#line 108
    if ((int )line[0] == 35) {
#line 109
      goto while_continue;
    } else {
      {
#line 108
      tmp = __ctype_b_loc();
      }
#line 108
      if ((int const   )*(*tmp + (int )line[0]) & 8192) {
#line 109
        goto while_continue;
      }
    }
    {
#line 110
    tmp___0 = strlen((char const   *)(line));
#line 110
    cp = (line + tmp___0) - 1;
    }
#line 111
    if ((int )*cp == 10) {
#line 112
      *cp = (char )'\000';
    }
    {
#line 113
    tmp___9 = strncasecmp((char const   *)(line), "user", (size_t )4);
    }
#line 113
    if (tmp___9 == 0) {
      {
#line 114
      Strncpy((char */* const  */)(cip->user), (char const   */* const  */)(line + 5),
              (size_t const   )sizeof(cip->user));
#line 115
      goodfile = 1;
      }
    } else {
      {
#line 116
      tmp___8 = strncasecmp((char const   *)(line), "password", (size_t )8);
      }
#line 116
      if (tmp___8 == 0) {
        {
#line 117
        Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)(line + 9),
                (size_t const   )sizeof(cip->pass));
#line 118
        goodfile = 1;
        }
      } else {
        {
#line 119
        tmp___6 = strncasecmp((char const   *)(line), "pass", (size_t )4);
        }
#line 119
        if (tmp___6 == 0) {
          {
#line 119
          tmp___7 = __ctype_b_loc();
          }
#line 119
          if ((int const   )*(*tmp___7 + (int )line[4]) & 8192) {
            {
#line 120
            Strncpy((char */* const  */)(cip->pass), (char const   */* const  */)(line + 5),
                    (size_t const   )sizeof(cip->pass));
#line 121
            goodfile = 1;
            }
          } else {
#line 119
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 122
          tmp___5 = strncasecmp((char const   *)(line), "host", (size_t )4);
          }
#line 122
          if (tmp___5 == 0) {
            {
#line 123
            Strncpy((char */* const  */)(cip->host), (char const   */* const  */)(line + 5),
                    (size_t const   )sizeof(cip->host));
#line 124
            goodfile = 1;
            }
          } else {
            {
#line 125
            tmp___4 = strncasecmp((char const   *)(line), "machine", (size_t )7);
            }
#line 125
            if (tmp___4 == 0) {
              {
#line 126
              Strncpy((char */* const  */)(cip->host), (char const   */* const  */)(line + 8),
                      (size_t const   )sizeof(cip->host));
#line 127
              goodfile = 1;
              }
            } else {
              {
#line 128
              tmp___2 = strncasecmp((char const   *)(line), "acct", (size_t )4);
              }
#line 128
              if (tmp___2 == 0) {
                {
#line 128
                tmp___3 = __ctype_b_loc();
                }
#line 128
                if ((int const   )*(*tmp___3 + (int )line[4]) & 8192) {
                  {
#line 129
                  Strncpy((char */* const  */)(cip->acct), (char const   */* const  */)(line + 5),
                          (size_t const   )sizeof(cip->acct));
                  }
                } else {
#line 128
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 130
                tmp___1 = strncasecmp((char const   *)(line), "account", (size_t )7);
                }
#line 130
                if (tmp___1 == 0) {
                  {
#line 131
                  Strncpy((char */* const  */)(cip->acct), (char const   */* const  */)(line + 8),
                          (size_t const   )sizeof(cip->acct));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  fclose(fp);
  }
#line 136
  if (goodfile) {
#line 136
    tmp___11 = 0;
  } else {
#line 136
    tmp___11 = -2;
  }
#line 136
  return (tmp___11);
}
}
#line 75 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char const   *DStrCpyList(DStr * const  dst  , ...) ;
#line 7 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrCpyList.c"
char const   *DStrCpyList(DStr * const  dst  , ...) 
{ 
  size_t newLen ;
  size_t allocSize ;
  size_t srcLen ;
  char *dcp ;
  char *cp ;
  char *osrc ;
  char const   *src ;
  char *recursive ;
  va_list ap ;
  char const   *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 16
  if (((long )dst->s & 1L) != 0L) {
#line 17
    return ((char const   *)((void *)0));
  } else
#line 16
  if ((dst->allocSize & 4278190095UL) != 0UL) {
#line 17
    return ((char const   *)((void *)0));
  } else
#line 16
  if ((dst->len & 4278190080UL) != 0UL) {
#line 17
    return ((char const   *)((void *)0));
  }
  {
#line 19
  osrc = dst->s;
#line 20
  recursive = (char *)((void *)0);
#line 21
  newLen = (size_t )0;
#line 22
  __builtin_va_start(ap, dst);
#line 23
  tmp = __builtin_va_arg(ap, char *);
#line 23
  src = tmp;
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 24
      goto while_break;
    }
#line 25
    if ((unsigned long )src == (unsigned long )osrc) {
#line 26
      if ((unsigned long )recursive == (unsigned long )((void *)0)) {
        {
#line 27
        recursive = strdup(src);
        }
      }
    }
    {
#line 29
    tmp___0 = strlen(src);
#line 29
    newLen += tmp___0;
#line 30
    tmp___1 = __builtin_va_arg(ap, char *);
#line 30
    src = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  __builtin_va_end(ap);
#line 34
  newLen ++;
  }
#line 35
  if (newLen > 16777215UL) {
#line 36
    if ((unsigned long )recursive != (unsigned long )((void *)0)) {
      {
#line 37
      free((void *)recursive);
      }
    }
#line 38
    return ((char const   *)((void *)0));
  }
#line 40
  if (dst->allocSize < newLen) {
#line 42
    allocSize = (newLen + 16UL) & 4294967280UL;
#line 43
    if ((unsigned long )dst->s == (unsigned long )((void *)0)) {
      {
#line 44
      tmp___2 = calloc(allocSize, (size_t )1);
#line 44
      cp = (char *)tmp___2;
      }
#line 45
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 46
        if ((unsigned long )recursive != (unsigned long )((void *)0)) {
          {
#line 47
          free((void *)recursive);
          }
        }
#line 48
        return ((char const   *)((void *)0));
      }
    } else {
      {
#line 51
      tmp___3 = realloc((void *)dst->s, allocSize);
#line 51
      cp = (char *)tmp___3;
      }
#line 52
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 53
        if ((unsigned long )recursive != (unsigned long )((void *)0)) {
          {
#line 54
          free((void *)recursive);
          }
        }
#line 55
        return ((char const   *)((void *)0));
      }
      {
#line 57
      memset((void *)cp, 0, allocSize);
      }
    }
#line 59
    dst->s = cp;
#line 60
    dst->allocSize = allocSize;
  } else {
#line 62
    cp = dst->s;
  }
  {
#line 65
  dcp = cp;
#line 66
  __builtin_va_start(ap, dst);
#line 67
  tmp___4 = __builtin_va_arg(ap, char *);
#line 67
  src = tmp___4;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 68
      goto while_break___0;
    }
#line 69
    if ((unsigned long )src == (unsigned long )osrc) {
#line 70
      src = (char const   *)recursive;
    }
    {
#line 71
    srcLen = strlen(src);
#line 72
    memcpy((void */* __restrict  */)dcp, (void const   */* __restrict  */)src, srcLen);
#line 73
    dcp += srcLen;
#line 74
    tmp___5 = __builtin_va_arg(ap, char *);
#line 74
    src = tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 76
  __builtin_va_end(ap);
#line 77
  *dcp = (char )'\000';
#line 79
  dst->len = newLen - 1UL;
  }
#line 80
  if ((unsigned long )recursive != (unsigned long )((void *)0)) {
    {
#line 81
    free((void *)recursive);
    }
  }
#line 82
  return ((char const   *)cp);
}
}
#line 248 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SSend(int sfd , char *buf0 , size_t size , int fl , int tlen ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSend.c"
int SSend(int sfd , char *buf0 , size_t size , int fl , int tlen ) 
{ 
  char *buf ;
  ssize_t nwrote ;
  size_t nleft ;
  int tleft ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int __d0 ;
  int __d1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 9
  buf = buf0;
#line 17
  sigpipe = (void (*)(int  ))0;
#line 19
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (size == 0UL) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (tlen <= 0) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  }
#line 24
  if (sio_sigpipe_ignored_already) {
#line 24
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 24
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 24
    sigpipe = tmp___0;
    }
  }
  {
#line 26
  nleft = size;
#line 27
  time(& now);
#line 28
  done = now + (time_t )tlen;
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (done > now) {
#line 30
      tleft = (int )(done - now);
    } else {
#line 30
      tleft = 0;
    }
#line 31
    if (tleft < 1) {
#line 32
      nwrote = (ssize_t )size - (ssize_t )nleft;
#line 33
      if (nwrote == 0L) {
        {
#line 34
        nwrote = (ssize_t )-2;
#line 35
        tmp___1 = __errno_location();
#line 35
        *tmp___1 = 110;
        }
      }
#line 38
      goto done;
    }
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 50
      tmp___2 = __errno_location();
#line 50
      *tmp___2 = 0;
      }
      {
#line 51
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 51
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 51
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 56
      ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 60
      tv.tv_sec = (__time_t )((long long )tlen);
#line 61
      tv.tv_usec = (__suseconds_t )0;
#line 62
      result = select(sfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 63
      if (result >= 1) {
#line 65
        goto while_break___0;
      } else
#line 66
      if (result == 0) {
#line 68
        nwrote = (ssize_t )size - (ssize_t )nleft;
#line 69
        if (nwrote > 0L) {
#line 70
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 70
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 70
              signal(13, sigpipe);
              }
            }
          }
#line 71
          return ((int )nwrote);
        }
        {
#line 73
        tmp___3 = __errno_location();
#line 73
        *tmp___3 = 110;
        }
#line 75
        if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 75
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
            {
#line 75
            signal(13, sigpipe);
            }
          }
        }
#line 76
        return (-2);
      } else {
        {
#line 77
        tmp___4 = __errno_location();
        }
#line 77
        if (*tmp___4 != 4) {
#line 78
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 78
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 78
              signal(13, sigpipe);
              }
            }
          }
#line 79
          return (-1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 83
    nwrote = send(sfd, (void const   *)buf, nleft, fl);
    }
#line 85
    if (nwrote < 0L) {
      {
#line 86
      tmp___6 = __errno_location();
      }
#line 86
      if (*tmp___6 != 4) {
#line 87
        nwrote = (ssize_t )size - (ssize_t )nleft;
#line 88
        if (nwrote == 0L) {
#line 89
          nwrote = (ssize_t )-1;
        }
#line 90
        goto done;
      } else {
        {
#line 92
        tmp___5 = __errno_location();
#line 92
        *tmp___5 = 0;
#line 93
        nwrote = (ssize_t )0;
        }
      }
    }
#line 97
    nleft -= (size_t )nwrote;
#line 98
    if (nleft == 0UL) {
#line 99
      goto while_break;
    }
    {
#line 100
    buf += nwrote;
#line 101
    time(& now);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  nwrote = (ssize_t )size - (ssize_t )nleft;
  done: 
#line 106
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 106
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 106
      signal(13, sigpipe);
      }
    }
  }
#line 107
  return ((int )nwrote);
}
}
#line 1039 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPRemoteHelp(FTPCIPtr const   cip , char const   * const  pattern , FTPLineListPtr const   llp ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_rhelp.c"
int FTPRemoteHelp(FTPCIPtr const   cip , char const   * const  pattern , FTPLineListPtr const   llp ) 
{ 
  int result ;
  ResponsePtr rp ;
  int tmp ;
  int tmp___0 ;

  {
#line 19
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 20
    return (-139);
  } else
#line 19
  if ((unsigned long )llp == (unsigned long )((void *)0)) {
#line 20
    return (-139);
  }
  {
#line 21
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 21
  if (tmp) {
#line 22
    return (-138);
  }
  {
#line 24
  InitLineList((FTPLineListPtr )llp);
#line 25
  rp = InitResponse();
  }
#line 26
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 27
    result = -123;
#line 28
    cip->errNo = -123;
#line 29
    FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
    }
  } else {
#line 31
    if ((unsigned long )pattern == (unsigned long )((void *)0)) {
      {
#line 32
      result = RCmd(cip, rp, "HELP");
      }
    } else
#line 31
    if ((int const   )*pattern == 0) {
      {
#line 32
      result = RCmd(cip, rp, "HELP");
      }
    } else {
      {
#line 34
      result = RCmd(cip, rp, "HELP %s", pattern);
      }
    }
#line 35
    if (result < 0) {
      {
#line 36
      DoneWithResponse(cip, rp);
      }
#line 37
      return (result);
    } else
#line 38
    if (result == 2) {
      {
#line 39
      tmp___0 = CopyLineList((FTPLineListPtr )llp, & rp->msg);
      }
#line 39
      if (tmp___0 < 0) {
        {
#line 40
        result = -123;
#line 41
        cip->errNo = -123;
#line 42
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
        }
      } else {
#line 44
        result = 0;
      }
    } else {
#line 47
      cip->errNo = -166;
#line 48
      result = -166;
    }
    {
#line 50
    DoneWithResponse(cip, rp);
    }
  }
#line 52
  return (result);
}
}
#line 23 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
char const   *tcap_normal ;
#line 24
char const   *tcap_reverse ;
#line 25
int gScreenColumns ;
#line 28
char gRemoteCWD[512] ;
#line 77 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static char const   *uStr___3  ;
#line 78 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static double uMult___3  ;
#line 209 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static char const   *uStr___4  ;
#line 210 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static double uTotal___1  ;
#line 210 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static double uMult___4  ;
#line 356 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static int maxBarLen  ;
#line 358 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static char bar[256]  ;
#line 361 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static char const   *uStr___5  ;
#line 362 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
static double uMult___5  ;
#line 350 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/progress.c"
void PrPhilBar(FTPCIPtr const   cip , int mode ) 
{ 
  int perc ;
  long long s ;
  int curBarLen ;
  char spec1[64] ;
  char spec3[64] ;
  int i___0 ;
  int secsLeft ;
  int minLeft ;
  double rate ;
  char const   *rStr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char url[256] ;
  char const   *tmp___1 ;

  {
  {
#line 367
  if (mode == 1) {
#line 367
    goto case_1;
  }
#line 414
  if (mode == 2) {
#line 414
    goto case_2;
  }
#line 479
  if (mode == 3) {
#line 479
    goto case_3;
  }
#line 366
  goto switch_break;
  case_1: /* CIL Label */ 
#line 368
  if (cip->expectedSize == -1LL) {
    {
#line 369
    cip->progress = & PrSizeAndRateMeter;
#line 370
    PrSizeAndRateMeter(cip, mode);
    }
#line 371
    return;
  }
  {
#line 373
  FileSize((double const   )((double )cip->expectedSize), & uStr___5, (double */* const  */)(& uMult___5));
#line 374
  fflush(stdout);
  }
#line 375
  if (cip->netMode == 65) {
#line 375
    tmp = "Receiving";
  } else {
#line 375
    tmp = "Sending";
  }
  {
#line 375
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s file: %s \n",
          tmp, cip->lname);
#line 380
  i___0 = 0;
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! (i___0 < (int )sizeof(bar) - 1)) {
#line 380
      goto while_break;
    }
#line 381
    bar[i___0] = (char )'=';
#line 380
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  bar[i___0] = (char )'\000';
#line 389
  maxBarLen = (gScreenColumns - 1) - 28;
#line 390
  s = cip->expectedSize;
  {
#line 390
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 390
    if (! (s > 0LL)) {
#line 390
      goto while_break___0;
    }
#line 391
    maxBarLen --;
#line 390
    s /= 10LL;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 395
  sprintf((char */* __restrict  */)(spec1), (char const   */* __restrict  */)"      0 %%%ds %%lld bytes. ETA: --:--",
          maxBarLen);
#line 400
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(spec1),
          " ", cip->expectedSize);
#line 411
  fflush(stdout);
  }
#line 412
  goto switch_break;
  case_2: /* CIL Label */ 
#line 416
  curBarLen = (int )((cip->percentCompleted * 0.01) * (double )maxBarLen);
#line 422
  if (curBarLen < 1) {
#line 423
    curBarLen = 1;
  }
  {
#line 425
  bar[curBarLen - 1] = (char )'>';
#line 426
  bar[curBarLen] = (char )'\000';
#line 429
  Strncpy((char */* const  */)(spec1), (char const   */* const  */)"\r%3d%%  0 ",
          (size_t const   )sizeof(spec1));
#line 432
  sprintf((char */* __restrict  */)(spec3), (char const   */* __restrict  */)"%%%ds %%lld bytes. %s%%3d:%%02d",
          maxBarLen - curBarLen, "ETA:");
#line 454
  perc = (int )cip->percentCompleted;
#line 455
  secsLeft = (int )cip->secLeft;
#line 456
  minLeft = secsLeft / 60;
#line 457
  secsLeft -= minLeft * 60;
  }
#line 458
  if (minLeft > 999) {
#line 459
    minLeft = 999;
#line 460
    secsLeft = 59;
  }
  {
#line 464
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(spec1),
          perc);
#line 465
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s%s",
          tcap_reverse, bar, tcap_normal);
#line 466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(spec3),
          "", cip->expectedSize, minLeft, secsLeft);
#line 473
  bar[curBarLen - 1] = (char )'=';
#line 474
  bar[curBarLen] = (char )'=';
#line 475
  fflush(stdout);
#line 477
  SetXtermTitle((char const   */* const  */)"%s - [%.1f%%]", cip->lname, cip->percentCompleted);
  }
#line 478
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 480
  printf((char const   */* __restrict  */)"\n");
#line 481
  rate = FileSize((double const   )(cip->kBytesPerSec * 1024.0), & rStr, (double */* const  */)((void *)0));
  }
#line 483
  if ((unsigned long )cip->lname == (unsigned long )((void *)0)) {
#line 483
    tmp___0 = "remote";
  } else {
#line 483
    tmp___0 = cip->lname;
  }
  {
#line 483
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: finished in %ld:%02ld:%02ld, %.2f %s/s\n",
          tmp___0, (long )cip->sec / 3600L, ((long )cip->sec / 60L) % 60L, (long )cip->sec % 60L,
          rate, rStr);
  }
#line 492
  if ((unsigned long )cip->rname != (unsigned long )((void *)0)) {
    {
#line 495
    FileToURL(url, sizeof(url), (char const   */* const  */)cip->rname, (char const   */* const  */)(gRemoteCWD),
              (char const   */* const  */)cip->startingWorkingDirectory, (char const   */* const  */)(cip->user),
              (char const   */* const  */)(cip->pass), (char const   */* const  */)(cip->host),
              (unsigned int const   )cip->port);
    }
#line 496
    if (cip->netMode == 65) {
#line 496
      tmp___1 = "get";
    } else {
#line 496
      tmp___1 = "put";
    }
    {
#line 496
    LogXfer((char const   */* const  */)tmp___1, (char const   */* const  */)(url));
    }
  }
#line 499
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 501
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int TimeCmp___0(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 213
  fipa = (FTPFileInfo const   * const  *)a;
#line 214
  fipb = (FTPFileInfo const   * const  *)b;
#line 215
  if ((*fipb)->mdtm == (*fipa)->mdtm) {
#line 216
    return (0);
  } else
#line 217
  if ((*fipb)->mdtm < (*fipa)->mdtm) {
#line 218
    return (-1);
  }
#line 219
  return (1);
}
}
#line 225 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int ReverseTimeCmp___0(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 231
  fipa = (FTPFileInfo const   * const  *)a;
#line 232
  fipb = (FTPFileInfo const   * const  *)b;
#line 233
  if ((*fipa)->mdtm == (*fipb)->mdtm) {
#line 234
    return (0);
  } else
#line 235
  if ((*fipa)->mdtm < (*fipb)->mdtm) {
#line 236
    return (-1);
  }
#line 237
  return (1);
}
}
#line 243 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int SizeCmp___0(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 249
  fipa = (FTPFileInfo const   * const  *)a;
#line 250
  fipb = (FTPFileInfo const   * const  *)b;
#line 251
  if ((*fipb)->size == (*fipa)->size) {
#line 252
    return (0);
  } else
#line 253
  if ((*fipb)->size < (*fipa)->size) {
#line 254
    return (-1);
  }
#line 255
  return (1);
}
}
#line 261 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int ReverseSizeCmp___0(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;

  {
#line 267
  fipa = (FTPFileInfo const   * const  *)a;
#line 268
  fipb = (FTPFileInfo const   * const  *)b;
#line 269
  if ((*fipa)->size == (*fipb)->size) {
#line 270
    return (0);
  } else
#line 271
  if ((*fipa)->size < (*fipb)->size) {
#line 272
    return (-1);
  }
#line 273
  return (1);
}
}
#line 279 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int ReverseNameCmp___0(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;
  int tmp ;

  {
  {
#line 285
  fipa = (FTPFileInfo const   * const  *)a;
#line 286
  fipb = (FTPFileInfo const   * const  *)b;
#line 288
  tmp = strcoll((char const   *)(*fipb)->relname, (char const   *)(*fipa)->relname);
  }
#line 288
  return (tmp);
}
}
#line 297 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int NameCmp___0(void const   *a , void const   *b ) 
{ 
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;
  int tmp ;

  {
  {
#line 303
  fipa = (FTPFileInfo const   * const  *)a;
#line 304
  fipb = (FTPFileInfo const   * const  *)b;
#line 306
  tmp = strcoll((char const   *)(*fipa)->relname, (char const   *)(*fipb)->relname);
  }
#line 306
  return (tmp);
}
}
#line 315 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/linelist.c"
static int BreadthFirstCmp___0(void const   *a , void const   *b ) 
{ 
  char *cp ;
  char *cpa ;
  char *cpb ;
  int depth ;
  int deptha ;
  int depthb ;
  int c ;
  FTPFileInfo const   * const  *fipa ;
  FTPFileInfo const   * const  *fipb ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 324
  fipa = (FTPFileInfo const   * const  *)a;
#line 325
  fipb = (FTPFileInfo const   * const  *)b;
#line 327
  cpa = (char *)(*fipa)->relname;
#line 328
  cpb = (char *)(*fipb)->relname;
#line 330
  cp = cpa;
#line 330
  depth = 0;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    tmp = cp;
#line 331
    cp ++;
#line 331
    c = (int )*tmp;
#line 332
    if (c == 0) {
#line 333
      goto while_break;
    }
#line 334
    if (c == 47) {
#line 335
      depth ++;
    } else
#line 334
    if (c == 92) {
#line 335
      depth ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  deptha = depth;
#line 340
  cp = cpb;
#line 340
  depth = 0;
  {
#line 340
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 341
    tmp___0 = cp;
#line 341
    cp ++;
#line 341
    c = (int )*tmp___0;
#line 342
    if (c == 0) {
#line 343
      goto while_break___0;
    }
#line 344
    if (c == 47) {
#line 345
      depth ++;
    } else
#line 344
    if (c == 92) {
#line 345
      depth ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  depthb = depth;
#line 350
  if (deptha < depthb) {
#line 351
    return (-1);
  } else
#line 352
  if (deptha > depthb) {
#line 353
    return (1);
  }
  {
#line 356
  tmp___1 = strcoll((char const   *)cpa, (char const   *)cpb);
  }
#line 356
  return (tmp___1);
}
}
#line 1090 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int UnMlsD(FTPCIPtr const   cip , FTPFileInfoListPtr filp , FTPLineListPtr llp ) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
static char const   *rwx[9]  = 
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
  {      "---",      "--x",      "-w-",      "-wx", 
        "r--",      "r-x",      "rw-",      "rwx", 
        (char const   *)((void *)0)};
#line 54 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
static int LsMonthNameToNum(char *cp ) 
{ 
  int mon ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 59
  tmp = cp;
#line 59
  cp ++;
  {
#line 60
  if ((int )*tmp == 65) {
#line 60
    goto case_65;
  }
#line 63
  if ((int )*tmp == 68) {
#line 63
    goto case_68;
  }
#line 66
  if ((int )*tmp == 70) {
#line 66
    goto case_70;
  }
#line 76
  if ((int )*tmp == 77) {
#line 76
    goto case_77;
  }
#line 79
  if ((int )*tmp == 78) {
#line 79
    goto case_78;
  }
#line 82
  if ((int )*tmp == 79) {
#line 82
    goto case_79;
  }
#line 85
  if ((int )*tmp == 83) {
#line 85
    goto case_83;
  }
#line 69
  goto switch_default;
  case_65: /* CIL Label */ 
#line 61
  if ((int )*cp == 117) {
#line 61
    mon = 7;
  } else {
#line 61
    mon = 3;
  }
#line 62
  goto switch_break;
  case_68: /* CIL Label */ 
#line 64
  mon = 11;
#line 65
  goto switch_break;
  case_70: /* CIL Label */ 
#line 67
  mon = 1;
#line 68
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 71
  tmp___0 = cp;
#line 71
  cp ++;
#line 71
  if ((int )*tmp___0 == 117) {
#line 72
    if ((int )*cp == 108) {
#line 72
      mon = 6;
    } else {
#line 72
      mon = 5;
    }
  } else {
#line 74
    mon = 0;
  }
#line 75
  goto switch_break;
  case_77: /* CIL Label */ 
#line 77
  cp ++;
#line 77
  if ((int )*cp == 114) {
#line 77
    mon = 2;
  } else {
#line 77
    mon = 4;
  }
#line 78
  goto switch_break;
  case_78: /* CIL Label */ 
#line 80
  mon = 10;
#line 81
  goto switch_break;
  case_79: /* CIL Label */ 
#line 83
  mon = 9;
#line 84
  goto switch_break;
  case_83: /* CIL Label */ 
#line 86
  mon = 8;
  switch_break: /* CIL Label */ ;
  }
#line 88
  return (mon);
}
}
#line 94 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
static int UnDosLine(char * const  line , char const   * const  curdir , size_t curdirlen ,
                     char *fname , size_t fnamesize , int *ftype , long long *fsize ,
                     time_t *ftime ) 
{ 
  char *cp ;
  int hour ;
  int year ;
  char *filestart ;
  char *sizestart ;
  struct tm ftm ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
  {
#line 122
  cp = (char *)line;
#line 123
  tmp___7 = __ctype_b_loc();
  }
#line 123
  if ((int const   )*(*tmp___7 + (int )*(cp + 0)) & 2048) {
    {
#line 123
    tmp___8 = __ctype_b_loc();
    }
#line 123
    if ((int const   )*(*tmp___8 + (int )*(cp + 1)) & 2048) {
      {
#line 123
      tmp___9 = __ctype_b_loc();
      }
#line 123
      if ((int const   )*(*tmp___9 + (int )*(cp + 2)) & 4) {
        {
#line 123
        tmp___10 = __ctype_b_loc();
        }
#line 123
        if ((int const   )*(*tmp___10 + (int )*(cp + 3)) & 2048) {
          {
#line 123
          tmp___11 = __ctype_b_loc();
          }
#line 123
          if ((int const   )*(*tmp___11 + (int )*(cp + 4)) & 2048) {
            {
#line 123
            tmp___12 = __ctype_b_loc();
            }
#line 123
            if ((int const   )*(*tmp___12 + (int )*(cp + 5)) & 4) {
              {
#line 123
              tmp___13 = __ctype_b_loc();
              }
#line 123
              if ((int const   )*(*tmp___13 + (int )*(cp + 6)) & 2048) {
                {
#line 123
                tmp___14 = __ctype_b_loc();
                }
#line 123
                if ((int const   )*(*tmp___14 + (int )*(cp + 7)) & 2048) {
                  {
#line 133
                  memset((void *)(& ftm), 0, sizeof(struct tm ));
#line 134
                  ftm.tm_isdst = -1;
#line 135
                  *(cp + 2) = (char )'\000';
#line 136
                  ftm.tm_mon = atoi((char const   *)(cp + 0));
                  }
#line 137
                  if (ftm.tm_mon > 0) {
#line 138
                    (ftm.tm_mon) --;
                  }
                  {
#line 139
                  *(cp + 5) = (char )'\000';
#line 140
                  ftm.tm_mday = atoi((char const   *)(cp + 3));
#line 141
                  tmp = __ctype_b_loc();
                  }
#line 141
                  if ((int const   )*(*tmp + (int )*(cp + 8)) & 2048) {
                    {
#line 141
                    tmp___0 = __ctype_b_loc();
                    }
#line 141
                    if ((int const   )*(*tmp___0 + (int )*(cp + 9)) & 2048) {
                      {
#line 143
                      *(cp + 10) = (char )'\000';
#line 144
                      year = atoi((char const   *)(cp + 6));
                      }
#line 145
                      if (year > 1900) {
#line 146
                        year -= 1900;
                      }
#line 147
                      ftm.tm_year = year;
#line 148
                      cp += 11;
                    } else {
#line 141
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    {
#line 151
                    *(cp + 8) = (char )'\000';
#line 152
                    year = atoi((char const   *)(cp + 6));
                    }
#line 153
                    if (year < 98) {
#line 154
                      year += 100;
                    }
#line 155
                    ftm.tm_year = year;
#line 156
                    cp += 9;
                  }
                  {
#line 159
                  while (1) {
                    while_continue: /* CIL Label */ ;
#line 160
                    if ((int )*cp == 0) {
#line 161
                      return (-1);
                    }
                    {
#line 162
                    tmp___1 = __ctype_b_loc();
                    }
#line 162
                    if ((int const   )*(*tmp___1 + (int )*cp) & 2048) {
#line 163
                      goto while_break;
                    }
#line 164
                    cp ++;
                  }
                  while_break: /* CIL Label */ ;
                  }
                  {
#line 167
                  *(cp + 2) = (char )'\000';
#line 168
                  hour = atoi((char const   *)cp);
                  }
#line 169
                  if ((int )*(cp + 5) == 80) {
#line 169
                    goto _L___2;
                  } else
#line 169
                  if ((int )*(cp + 5) == 112) {
                    _L___2: /* CIL Label */ 
#line 169
                    if (hour < 12) {
#line 170
                      hour += 12;
                    } else {
#line 169
                      goto _L___1;
                    }
                  } else
                  _L___1: /* CIL Label */ 
#line 171
                  if ((int )*(cp + 5) == 65) {
#line 171
                    goto _L___0;
                  } else
#line 171
                  if ((int )*(cp + 5) == 97) {
                    _L___0: /* CIL Label */ 
#line 171
                    if (hour == 12) {
#line 172
                      hour -= 12;
                    }
                  }
                  {
#line 173
                  ftm.tm_hour = hour;
#line 174
                  *(cp + 5) = (char )'\000';
#line 175
                  ftm.tm_min = atoi((char const   *)(cp + 3));
#line 176
                  *ftime = mktime(& ftm);
                  }
#line 177
                  if ((time_t )*ftype == -1L) {
#line 178
                    return (-1);
                  }
#line 180
                  cp += 6;
#line 181
                  *ftype = '-';
                  {
#line 182
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 183
                    if ((int )*cp == 0) {
#line 184
                      return (-1);
                    }
#line 185
                    if ((int )*cp == 60) {
#line 185
                      if ((int )*(cp + 1) == 68) {
#line 187
                        *ftype = 'd';
#line 188
                        cp += 5;
#line 189
                        goto while_break___0;
                      } else {
#line 185
                        goto _L___4;
                      }
                    } else
                    _L___4: /* CIL Label */ 
#line 190
                    if ((int )*cp == 60) {
#line 190
                      if ((int )*(cp + 1) == 74) {
#line 198
                        *ftype = 'd';
#line 199
                        cp += 10;
#line 200
                        goto while_break___0;
                      } else {
#line 190
                        goto _L___3;
                      }
                    } else {
                      _L___3: /* CIL Label */ 
                      {
#line 201
                      tmp___2 = __ctype_b_loc();
                      }
#line 201
                      if ((int const   )*(*tmp___2 + (int )*cp) & 2048) {
#line 202
                        goto while_break___0;
                      } else {
#line 204
                        cp ++;
                      }
                    }
                  }
                  while_break___0: /* CIL Label */ ;
                  }
#line 208
                  sizestart = cp;
                  {
#line 209
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 210
                    if ((int )*cp == 0) {
#line 211
                      return (-1);
                    }
#line 213
                    if ((int )*cp == 44) {
                      {
#line 215
                      tmp___3 = strlen((char const   *)(cp + 1));
#line 215
                      memmove((void *)cp, (void const   *)(cp + 1), tmp___3 + 1UL);
                      }
                    }
                    {
#line 218
                    tmp___5 = __ctype_b_loc();
                    }
#line 218
                    if (! ((int const   )*(*tmp___5 + (int )*cp) & 2048)) {
#line 219
                      tmp___4 = cp;
#line 219
                      cp ++;
#line 219
                      *tmp___4 = (char )'\000';
#line 220
                      goto while_break___1;
                    }
#line 222
                    cp ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
#line 225
                  if ((unsigned long )fsize != (unsigned long )((void *)0)) {
#line 227
                    if (*ftype == 100) {
#line 228
                      *fsize = 0LL;
                    } else {
                      {
#line 230
                      sscanf((char const   */* __restrict  */)sizestart, (char const   */* __restrict  */)"%lld",
                             fsize);
                      }
                    }
                  }
                  {
#line 247
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 248
                    if ((int )*cp == 0) {
#line 249
                      return (-1);
                    }
                    {
#line 250
                    tmp___6 = __ctype_b_loc();
                    }
#line 250
                    if (! ((int const   )*(*tmp___6 + (int )*cp) & 8192)) {
#line 251
                      goto while_break___2;
                    }
#line 253
                    cp ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 256
                  filestart = cp;
#line 257
                  if (curdirlen == 0UL) {
                    {
#line 258
                    Strncpy((char */* const  */)fname, (char const   */* const  */)filestart,
                            (size_t const   )fnamesize);
                    }
                  } else {
                    {
#line 260
                    Strncpy((char */* const  */)fname, curdir, (size_t const   )fnamesize);
#line 261
                    Strncat((char */* const  */)fname, (char const   */* const  */)filestart,
                            (size_t const   )fnamesize);
                    }
                  }
#line 264
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 266
  return (-1);
}
}
#line 272 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
static int UnLslRLine(char * const  line , char const   * const  curdir , size_t curdirlen ,
                      char *fname , size_t fnamesize , char *linkto , size_t linktosize ,
                      int *ftype , long long *fsize , time_t *ftime , time_t now ,
                      int thisyear , int *plugend ) 
{ 
  char *cp ;
  int mon ;
  int day ;
  int hr ;
  int min ;
  int year ;
  int sec ;
  int haveIsoHHMMSS ;
  char *monstart ;
  char *daystart ;
  char *hrstart ;
  char *minstart ;
  char *yearstart ;
  char *secstart ;
  char *linktostart ;
  char *filestart ;
  char *sizestart ;
  char *pe ;
  struct tm ftm ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  unsigned short const   **tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  unsigned short const   **tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  unsigned short const   **tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  unsigned short const   **tmp___40 ;
  unsigned short const   **tmp___41 ;
  unsigned short const   **tmp___42 ;
  unsigned short const   **tmp___43 ;
  unsigned short const   **tmp___44 ;
  unsigned short const   **tmp___45 ;
  unsigned short const   **tmp___46 ;
  unsigned short const   **tmp___47 ;
  unsigned short const   **tmp___48 ;
  unsigned short const   **tmp___49 ;
  unsigned short const   **tmp___50 ;

  {
#line 288
  mon = 0;
#line 288
  day = 0;
#line 288
  hr = 0;
#line 288
  min = 0;
#line 288
  year = 0;
#line 288
  sec = 0;
#line 289
  haveIsoHHMMSS = -1;
#line 290
  secstart = (char *)((void *)0);
#line 291
  filestart = (char *)((void *)0);
#line 296
  *plugend = 0;
#line 297
  *ftype = 0;
#line 298
  if ((unsigned long )ftime != (unsigned long )((void *)0)) {
#line 299
    *ftime = (time_t )-1;
  }
#line 300
  if ((unsigned long )fsize != (unsigned long )((void *)0)) {
#line 301
    *fsize = -1LL;
  }
#line 320
  cp = (char *)line;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! ((int )*cp != 0)) {
#line 320
      goto while_break;
    }
    {
#line 321
    tmp___38 = __ctype_b_loc();
    }
#line 321
    if ((int const   )*(*tmp___38 + (int )*cp) & 2048) {
      {
#line 321
      tmp___39 = __ctype_b_loc();
      }
#line 321
      if ((int const   )*(*tmp___39 + (int )*(cp + 1)) & 8192) {
        {
#line 321
        tmp___40 = __ctype_b_loc();
        }
#line 321
        if ((int const   )*(*tmp___40 + (int )*(cp + 2)) & 256) {
          {
#line 321
          tmp___41 = __ctype_b_loc();
          }
#line 321
          if ((int const   )*(*tmp___41 + (int )*(cp + 3)) & 512) {
            {
#line 321
            tmp___42 = __ctype_b_loc();
            }
#line 321
            if ((int const   )*(*tmp___42 + (int )*(cp + 5)) & 8192) {
              {
#line 321
              tmp___43 = __ctype_b_loc();
              }
#line 321
              if ((int const   )*(*tmp___43 + (int )*(cp + 6)) & 2048) {
                {
#line 321
                tmp___44 = __ctype_b_loc();
                }
#line 321
                if ((int const   )*(*tmp___44 + (int )*(cp + 7)) & 2048) {
#line 321
                  goto _L___8;
                } else {
#line 321
                  goto _L___10;
                }
              } else {
                _L___10: /* CIL Label */ 
                {
#line 321
                tmp___45 = __ctype_b_loc();
                }
#line 321
                if ((int const   )*(*tmp___45 + (int )*(cp + 6)) & 2048) {
                  {
#line 321
                  tmp___46 = __ctype_b_loc();
                  }
#line 321
                  if ((int const   )*(*tmp___46 + (int )*(cp + 7)) & 8192) {
#line 321
                    goto _L___8;
                  } else {
#line 321
                    goto _L___9;
                  }
                } else {
                  _L___9: /* CIL Label */ 
                  {
#line 321
                  tmp___47 = __ctype_b_loc();
                  }
#line 321
                  if ((int const   )*(*tmp___47 + (int )*(cp + 6)) & 8192) {
                    {
#line 321
                    tmp___48 = __ctype_b_loc();
                    }
#line 321
                    if ((int const   )*(*tmp___48 + (int )*(cp + 7)) & 2048) {
                      _L___8: /* CIL Label */ 
                      {
#line 321
                      tmp___49 = __ctype_b_loc();
                      }
#line 321
                      if ((int const   )*(*tmp___49 + (int )*(cp + 8)) & 8192) {
                        {
#line 334
                        monstart = cp + 2;
#line 335
                        daystart = cp + 6;
#line 336
                        tmp___9 = __ctype_b_loc();
                        }
#line 336
                        if ((int const   )*(*tmp___9 + (int )*(cp + 9)) & 8192) {
#line 336
                          goto _L___4;
                        } else {
                          {
#line 336
                          tmp___10 = __ctype_b_loc();
                          }
#line 336
                          if ((int const   )*(*tmp___10 + (int )*(cp + 9)) & 2048) {
                            _L___4: /* CIL Label */ 
                            {
#line 336
                            tmp___11 = __ctype_b_loc();
                            }
#line 336
                            if ((int const   )*(*tmp___11 + (int )*(cp + 10)) & 2048) {
                              {
#line 336
                              tmp___12 = __ctype_b_loc();
                              }
#line 336
                              if ((int const   )*(*tmp___12 + (int )*(cp + 11)) & 2048) {
                                {
#line 336
                                tmp___13 = __ctype_b_loc();
                                }
#line 336
                                if ((int const   )*(*tmp___13 + (int )*(cp + 12)) & 2048) {
                                  {
#line 336
                                  tmp___14 = __ctype_b_loc();
                                  }
#line 336
                                  if ((int const   )*(*tmp___14 + (int )*(cp + 13)) & 2048) {
#line 336
                                    goto _L___0;
                                  } else {
                                    {
#line 336
                                    tmp___15 = __ctype_b_loc();
                                    }
#line 336
                                    if ((int const   )*(*tmp___15 + (int )*(cp + 13)) & 8192) {
                                      _L___0: /* CIL Label */ 
                                      {
#line 343
                                      yearstart = cp + 9;
#line 344
                                      tmp = __ctype_b_loc();
                                      }
#line 344
                                      if ((int const   )*(*tmp + (int )*yearstart) & 8192) {
#line 345
                                        yearstart ++;
                                      }
                                      {
#line 346
                                      hrstart = (char *)((void *)0);
#line 347
                                      minstart = (char *)((void *)0);
#line 348
                                      filestart = cp + 15;
#line 349
                                      *(cp + 1) = (char )'\000';
#line 350
                                      *(cp + 5) = (char )'\000';
#line 351
                                      *(cp + 8) = (char )'\000';
#line 352
                                      tmp___1 = __ctype_b_loc();
                                      }
#line 352
                                      if (! ((int const   )*(*tmp___1 + (int )*(filestart + -1)) & 8192)) {
                                        {
#line 353
                                        tmp___0 = __ctype_b_loc();
                                        }
#line 353
                                        if ((int const   )*(*tmp___0 + (int )*(filestart + -2)) & 8192) {
#line 354
                                          filestart --;
                                        }
                                      }
                                      {
#line 357
                                      *(filestart + -1) = (char )'\000';
#line 358
                                      mon = LsMonthNameToNum(monstart);
#line 359
                                      day = atoi((char const   *)daystart);
#line 360
                                      hr = 23;
#line 361
                                      min = 59;
#line 362
                                      sec = 59;
#line 363
                                      year = atoi((char const   *)yearstart);
#line 365
                                      pe = cp;
                                      }
                                      {
#line 366
                                      while (1) {
                                        while_continue___0: /* CIL Label */ ;
                                        {
#line 366
                                        tmp___2 = __ctype_b_loc();
                                        }
#line 366
                                        if (! ((int const   )*(*tmp___2 + (int )*pe) & 2048)) {
#line 366
                                          goto while_break___0;
                                        }
#line 367
                                        pe --;
                                      }
                                      while_break___0: /* CIL Label */ ;
                                      }
                                      {
#line 368
                                      while (1) {
                                        while_continue___1: /* CIL Label */ ;
                                        {
#line 368
                                        tmp___3 = __ctype_b_loc();
                                        }
#line 368
                                        if (! ((int const   )*(*tmp___3 + (int )*pe) & 8192)) {
#line 368
                                          goto while_break___1;
                                        }
#line 369
                                        pe --;
                                      }
                                      while_break___1: /* CIL Label */ ;
                                      }
#line 370
                                      *plugend = (int )(pe - (char *)line) + 1;
#line 371
                                      goto while_break;
                                    } else {
#line 336
                                      goto _L___3;
                                    }
                                  }
                                } else {
#line 336
                                  goto _L___3;
                                }
                              } else {
#line 336
                                goto _L___3;
                              }
                            } else {
#line 336
                              goto _L___3;
                            }
                          } else {
                            _L___3: /* CIL Label */ 
                            {
#line 372
                            tmp___6 = __ctype_b_loc();
                            }
#line 372
                            if ((int const   )*(*tmp___6 + (int )*(cp + 10)) & 2048) {
#line 372
                              if ((int )*(cp + 11) == 58) {
                                {
#line 372
                                tmp___7 = __ctype_b_loc();
                                }
#line 372
                                if ((int const   )*(*tmp___7 + (int )*(cp + 12)) & 2048) {
                                  {
#line 372
                                  tmp___8 = __ctype_b_loc();
                                  }
#line 372
                                  if ((int const   )*(*tmp___8 + (int )*(cp + 13)) & 2048) {
                                    {
#line 382
                                    yearstart = (char *)((void *)0);
#line 383
                                    hrstart = cp + 9;
#line 384
                                    minstart = cp + 12;
#line 385
                                    filestart = cp + 15;
#line 386
                                    *(cp + 1) = (char )'\000';
#line 387
                                    *(cp + 5) = (char )'\000';
#line 388
                                    *(cp + 8) = (char )'\000';
#line 389
                                    *(cp + 11) = (char )'\000';
#line 390
                                    *(cp + 14) = (char )'\000';
#line 391
                                    mon = LsMonthNameToNum(monstart);
#line 392
                                    day = atoi((char const   *)daystart);
#line 393
                                    hr = atoi((char const   *)hrstart);
#line 394
                                    min = atoi((char const   *)minstart);
#line 395
                                    sec = 0;
#line 396
                                    year = 0;
#line 398
                                    pe = cp;
                                    }
                                    {
#line 399
                                    while (1) {
                                      while_continue___2: /* CIL Label */ ;
                                      {
#line 399
                                      tmp___4 = __ctype_b_loc();
                                      }
#line 399
                                      if (! ((int const   )*(*tmp___4 + (int )*pe) & 2048)) {
#line 399
                                        goto while_break___2;
                                      }
#line 400
                                      pe --;
                                    }
                                    while_break___2: /* CIL Label */ ;
                                    }
                                    {
#line 401
                                    while (1) {
                                      while_continue___3: /* CIL Label */ ;
                                      {
#line 401
                                      tmp___5 = __ctype_b_loc();
                                      }
#line 401
                                      if (! ((int const   )*(*tmp___5 + (int )*pe) & 8192)) {
#line 401
                                        goto while_break___3;
                                      }
#line 402
                                      pe --;
                                    }
                                    while_break___3: /* CIL Label */ ;
                                    }
#line 403
                                    *plugend = (int )(pe - (char *)line) + 1;
#line 404
                                    goto while_break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
#line 321
                        goto _L___14;
                      }
                    } else {
#line 321
                      goto _L___14;
                    }
                  } else {
#line 321
                    goto _L___14;
                  }
                }
              }
            } else {
#line 321
              goto _L___14;
            }
          } else {
#line 321
            goto _L___14;
          }
        } else {
#line 321
          goto _L___14;
        }
      } else {
#line 321
        goto _L___14;
      }
    } else {
      _L___14: /* CIL Label */ 
      {
#line 406
      tmp___19 = __ctype_b_loc();
      }
#line 406
      if ((int const   )*(*tmp___19 + (int )*cp) & 2048) {
        {
#line 406
        tmp___20 = __ctype_b_loc();
        }
#line 406
        if ((int const   )*(*tmp___20 + (int )*(cp + 1)) & 8192) {
          {
#line 406
          tmp___21 = __ctype_b_loc();
          }
#line 406
          if ((int const   )*(*tmp___21 + (int )*(cp + 2)) & 2048) {
            {
#line 406
            tmp___22 = __ctype_b_loc();
            }
#line 406
            if ((int const   )*(*tmp___22 + (int )*(cp + 3)) & 2048) {
              {
#line 406
              tmp___23 = __ctype_b_loc();
              }
#line 406
              if ((int const   )*(*tmp___23 + (int )*(cp + 4)) & 2048) {
                {
#line 406
                tmp___24 = __ctype_b_loc();
                }
#line 406
                if ((int const   )*(*tmp___24 + (int )*(cp + 5)) & 2048) {
#line 406
                  if ((int )*(cp + 6) == 45) {
                    {
#line 406
                    tmp___25 = __ctype_b_loc();
                    }
#line 406
                    if ((int const   )*(*tmp___25 + (int )*(cp + 7)) & 2048) {
                      {
#line 406
                      tmp___26 = __ctype_b_loc();
                      }
#line 406
                      if ((int const   )*(*tmp___26 + (int )*(cp + 8)) & 2048) {
#line 406
                        if ((int )*(cp + 9) == 45) {
                          {
#line 406
                          tmp___27 = __ctype_b_loc();
                          }
#line 406
                          if ((int const   )*(*tmp___27 + (int )*(cp + 10)) & 2048) {
                            {
#line 406
                            tmp___28 = __ctype_b_loc();
                            }
#line 406
                            if ((int const   )*(*tmp___28 + (int )*(cp + 11)) & 2048) {
                              {
#line 406
                              tmp___29 = __ctype_b_loc();
                              }
#line 406
                              if ((int const   )*(*tmp___29 + (int )*(cp + 12)) & 8192) {
                                {
#line 406
                                tmp___30 = __ctype_b_loc();
                                }
#line 406
                                if ((int const   )*(*tmp___30 + (int )*(cp + 13)) & 2048) {
                                  {
#line 406
                                  tmp___31 = __ctype_b_loc();
                                  }
#line 406
                                  if ((int const   )*(*tmp___31 + (int )*(cp + 14)) & 2048) {
#line 406
                                    if ((int )*(cp + 15) == 58) {
                                      {
#line 406
                                      tmp___32 = __ctype_b_loc();
                                      }
#line 406
                                      if ((int const   )*(*tmp___32 + (int )*(cp + 16)) & 2048) {
                                        {
#line 406
                                        tmp___33 = __ctype_b_loc();
                                        }
#line 406
                                        if ((int const   )*(*tmp___33 + (int )*(cp + 17)) & 2048) {
                                          {
#line 406
                                          tmp___34 = __ctype_b_loc();
#line 406
                                          haveIsoHHMMSS = (int )((int const   )*(*tmp___34 + (int )*(cp + 18)) & 8192);
                                          }
#line 406
                                          if (haveIsoHHMMSS) {
#line 406
                                            goto _L___5;
                                          } else {
                                            {
#line 406
                                            tmp___35 = __ctype_b_loc();
                                            }
#line 406
                                            if ((int const   )*(*tmp___35 + (int )*(cp + 19)) & 2048) {
                                              {
#line 406
                                              tmp___36 = __ctype_b_loc();
                                              }
#line 406
                                              if ((int const   )*(*tmp___36 + (int )*(cp + 20)) & 2048) {
                                                {
#line 406
                                                tmp___37 = __ctype_b_loc();
                                                }
#line 406
                                                if ((int const   )*(*tmp___37 + (int )*(cp + 21)) & 8192) {
#line 406
                                                  haveIsoHHMMSS = (int )*(cp + 18);
#line 406
                                                  if (haveIsoHHMMSS == 58) {
                                                    _L___5: /* CIL Label */ 
#line 443
                                                    yearstart = cp + 2;
#line 444
                                                    *(cp + 6) = (char )'\000';
#line 446
                                                    monstart = cp + 7;
#line 447
                                                    *(cp + 9) = (char )'\000';
#line 449
                                                    daystart = cp + 10;
#line 450
                                                    *(cp + 12) = (char )'\000';
#line 452
                                                    hrstart = cp + 13;
#line 453
                                                    *(cp + 15) = (char )'\000';
#line 455
                                                    minstart = cp + 16;
#line 456
                                                    *(cp + 18) = (char )'\000';
#line 458
                                                    if (haveIsoHHMMSS == 58) {
                                                      {
#line 459
                                                      secstart = cp + 19;
#line 460
                                                      *(cp + 21) = (char )'\000';
#line 461
                                                      sec = atoi((char const   *)secstart);
#line 462
                                                      filestart = cp + 22;
                                                      }
                                                    } else {
#line 464
                                                      filestart = cp + 19;
#line 465
                                                      sec = 0;
                                                    }
                                                    {
#line 468
                                                    tmp___16 = atoi((char const   *)monstart);
#line 468
                                                    mon = tmp___16 - 1;
#line 469
                                                    day = atoi((char const   *)daystart);
#line 470
                                                    hr = atoi((char const   *)hrstart);
#line 471
                                                    min = atoi((char const   *)minstart);
#line 472
                                                    year = atoi((char const   *)yearstart);
#line 474
                                                    pe = cp;
                                                    }
                                                    {
#line 475
                                                    while (1) {
                                                      while_continue___4: /* CIL Label */ ;
                                                      {
#line 475
                                                      tmp___17 = __ctype_b_loc();
                                                      }
#line 475
                                                      if (! ((int const   )*(*tmp___17 + (int )*pe) & 2048)) {
#line 475
                                                        goto while_break___4;
                                                      }
#line 476
                                                      pe --;
                                                    }
                                                    while_break___4: /* CIL Label */ ;
                                                    }
                                                    {
#line 477
                                                    while (1) {
                                                      while_continue___5: /* CIL Label */ ;
                                                      {
#line 477
                                                      tmp___18 = __ctype_b_loc();
                                                      }
#line 477
                                                      if (! ((int const   )*(*tmp___18 + (int )*pe) & 8192)) {
#line 477
                                                        goto while_break___5;
                                                      }
#line 478
                                                      pe --;
                                                    }
                                                    while_break___5: /* CIL Label */ ;
                                                    }
#line 479
                                                    *plugend = (int )(pe - (char *)line) + 1;
#line 480
                                                    goto while_break;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 320
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  if ((int )*cp == 0) {
#line 485
    return (-1);
  }
  {
#line 487
  linktostart = strstr((char const   *)filestart, " -> ");
  }
#line 488
  if ((unsigned long )linktostart != (unsigned long )((void *)0)) {
    {
#line 489
    *linktostart = (char )'\000';
#line 490
    linktostart += 4;
#line 491
    Strncpy((char */* const  */)linkto, (char const   */* const  */)linktostart, (size_t const   )linktosize);
    }
  } else {
#line 493
    *linkto = (char )'\000';
  }
#line 496
  if (curdirlen == 0UL) {
    {
#line 497
    Strncpy((char */* const  */)fname, (char const   */* const  */)filestart, (size_t const   )fnamesize);
    }
  } else {
    {
#line 499
    Strncpy((char */* const  */)fname, curdir, (size_t const   )fnamesize);
#line 500
    Strncat((char */* const  */)fname, (char const   */* const  */)filestart, (size_t const   )fnamesize);
    }
  }
#line 503
  if ((unsigned long )ftime != (unsigned long )((void *)0)) {
    {
#line 504
    memset((void *)(& ftm), 0, sizeof(struct tm ));
#line 505
    ftm.tm_mon = mon;
#line 506
    ftm.tm_mday = day;
#line 507
    ftm.tm_hour = hr;
#line 508
    ftm.tm_min = min;
#line 509
    ftm.tm_sec = sec;
#line 510
    ftm.tm_isdst = -1;
    }
#line 511
    if (year == 0) {
      {
#line 524
      ftm.tm_year = thisyear - 1900;
#line 525
      *ftime = mktime(& ftm);
      }
#line 526
      if (! (*ftime == -1L)) {
#line 528
        if (*ftime > now + 172800L) {
          {
#line 529
          (ftm.tm_year) --;
#line 530
          *ftime = mktime(& ftm);
          }
        }
      }
    } else {
      {
#line 533
      ftm.tm_year = year - 1900;
#line 534
      *ftime = mktime(& ftm);
      }
    }
  }
#line 538
  if ((unsigned long )fsize != (unsigned long )((void *)0)) {
    {
#line 539
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 539
      if ((unsigned long )cp > (unsigned long )line) {
        {
#line 539
        tmp___50 = __ctype_b_loc();
        }
#line 539
        if (! ((int const   )*(*tmp___50 + (int )*cp) & 2048)) {
#line 539
          goto while_break___6;
        }
      } else {
#line 539
        goto while_break___6;
      }
#line 540
      cp --;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 541
    sizestart = cp + 1;
#line 543
    sscanf((char const   */* __restrict  */)sizestart, (char const   */* __restrict  */)"%lld",
           fsize);
    }
  }
  {
#line 558
  if ((int )*(line + 0) == 108) {
#line 558
    goto case_108;
  }
#line 558
  if ((int )*(line + 0) == 100) {
#line 558
    goto case_108;
  }
#line 563
  if ((int )*(line + 0) == 115) {
#line 563
    goto case_115;
  }
#line 563
  if ((int )*(line + 0) == 99) {
#line 563
    goto case_115;
  }
#line 563
  if ((int )*(line + 0) == 98) {
#line 563
    goto case_115;
  }
#line 566
  goto switch_default;
  case_108: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 559
  *ftype = (int )*(line + 0);
#line 560
  goto switch_break;
  case_115: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
#line 564
  *ftype = (int )*(line + 0);
#line 565
  return (-1);
  switch_default: /* CIL Label */ 
#line 567
  *ftype = '-';
  switch_break: /* CIL Label */ ;
  }
#line 570
  return (0);
}
}
#line 575 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
int UnLslR(FTPCIPtr const   cip , FTPFileInfoListPtr filp , FTPLineListPtr llp , int serverType ) 
{ 
  char curdir[512] ;
  char line[512] ;
  int len ;
  size_t curdirlen ;
  char fname[256] ;
  char linkto[256] ;
  char *cp ;
  long long fsize ;
  int ftype ;
  time_t ftime ;
  time_t now ;
  int thisyear ;
  struct tm nowtm ;
  int rc ;
  FTPLinePtr lp ;
  FTPFileInfo fi ;
  int linesread ;
  int linesconverted ;
  size_t maxFileLen ;
  size_t maxPlugLen ;
  size_t fileLen ;
  int plugend ;
  int skipdir ;
  size_t cwdlen ;
  time_t tmp ;
  struct tm *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 581
  curdirlen = (size_t )0;
#line 593
  linesread = 0;
#line 594
  linesconverted = 0;
#line 595
  maxFileLen = (size_t )0;
#line 596
  maxPlugLen = (size_t )0;
#line 599
  skipdir = 0;
#line 602
  tmp = time(& now);
#line 602
  tmp___0 = Localtime(tmp, (struct tm */* const  */)(& nowtm));
  }
#line 602
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 603
    thisyear = 1970;
  } else {
#line 605
    thisyear = nowtm.tm_year + 1900;
  }
  {
#line 607
  curdir[0] = (char )'\000';
#line 608
  *(cip->buf + 0) = (char )'\000';
#line 609
  cwdlen = (size_t )0;
#line 611
  InitFileInfoList(filp);
#line 612
  lp = llp->first;
  }
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 612
      goto while_break;
    }
    {
#line 613
    tmp___1 = Strncpy((char */* const  */)(line), (char const   */* const  */)lp->line,
                      (size_t const   )sizeof(line));
#line 613
    tmp___2 = strlen((char const   *)tmp___1);
#line 613
    len = (int )tmp___2;
#line 614
    cp = line;
    }
    {
#line 614
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 615
      if ((int )*cp == 0) {
#line 616
        goto while_break___0;
      } else {
        {
#line 615
        tmp___3 = __ctype_b_loc();
        }
#line 615
        if (! ((int const   )*(*tmp___3 + (int )*cp) & 8192)) {
#line 616
          goto while_break___0;
        }
      }
#line 614
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 618
    if ((int )*cp == 0) {
#line 621
      goto __Cont;
    }
#line 624
    if (serverType == 4) {
#line 630
      cp = line;
      {
#line 630
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 630
        if (! ((int )*cp != 0)) {
#line 630
          goto while_break___1;
        }
#line 631
        if ((int )*cp == 92) {
#line 632
          *cp = (char )'/';
        }
#line 630
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 636
    linesread ++;
#line 637
    rc = UnLslRLine((char */* const  */)(line), (char const   */* const  */)(curdir),
                    curdirlen, fname, sizeof(fname), linkto, sizeof(linkto), & ftype,
                    & fsize, & ftime, now, thisyear, & plugend);
    }
#line 638
    if (rc < 0) {
#line 638
      if (serverType == 4) {
        {
#line 639
        rc = UnDosLine((char */* const  */)(line), (char const   */* const  */)(curdir),
                       curdirlen, fname, sizeof(fname), & ftype, & fsize, & ftime);
        }
#line 640
        if (rc == 0) {
#line 641
          linkto[0] = (char )'\000';
#line 642
          plugend = 0;
        }
      }
    }
#line 646
    if (rc == 0) {
#line 647
      if (skipdir != 0) {
#line 648
        goto __Cont;
      }
#line 649
      cp = fname + curdirlen;
#line 650
      if ((int )*(cp + 0) == 46) {
#line 650
        if ((int )*(cp + 1) == 0) {
#line 651
          goto __Cont;
        } else
#line 650
        if ((int )*(cp + 1) == 46) {
#line 650
          if ((int )*(cp + 2) == 0) {
#line 651
            goto __Cont;
          }
        }
      }
#line 652
      linesconverted ++;
#line 653
      cp = fname;
#line 654
      if ((int )*(cp + 0) == 46) {
#line 654
        if ((int )*(cp + 1) == 47) {
#line 655
          cp += 2;
        } else
#line 654
        if ((int )*(cp + 1) == 92) {
#line 655
          cp += 2;
        }
      }
#line 656
      if ((int )*cp == 47) {
#line 656
        goto _L;
      } else
#line 656
      if ((int )*cp == 92) {
        _L: /* CIL Label */ 
#line 660
        if ((int )*(cip->buf + 0) == 0) {
          {
#line 661
          FTPGetCWD(cip, (char */* const  */)cip->buf, (size_t const   )cip->bufSize);
#line 662
          cwdlen = strlen((char const   *)cip->buf);
          }
        }
#line 667
        if (cwdlen > 1UL) {
          {
#line 668
          tmp___4 = memcmp((void const   *)cp, (void const   *)cip->buf, cwdlen);
          }
#line 668
          if (tmp___4 == 0) {
#line 670
            cp += cwdlen;
#line 671
            if ((int )*cp == 47) {
#line 672
              cp ++;
            } else
#line 671
            if ((int )*cp == 92) {
#line 672
              cp ++;
            }
          } else {
#line 675
            goto __Cont;
          }
        }
      }
      {
#line 679
      tmp___5 = PathContainsIntermediateDotDotSubDir((char const   *)cp);
      }
#line 679
      if (tmp___5) {
#line 680
        goto __Cont;
      }
      {
#line 681
      fileLen = strlen((char const   *)cp);
      }
#line 682
      if (fileLen > maxFileLen) {
#line 683
        maxFileLen = fileLen;
      }
      {
#line 684
      fi.relnameLen = fileLen;
#line 685
      fi.relname = StrDup((char const   *)cp);
#line 686
      fi.rname = (char *)((void *)0);
#line 687
      fi.lname = (char *)((void *)0);
      }
#line 688
      if ((int )linkto[0] == 0) {
#line 688
        fi.rlinkto = (char *)((void *)0);
      } else {
        {
#line 688
        tmp___6 = StrDup((char const   *)(linkto));
#line 688
        fi.rlinkto = tmp___6;
        }
      }
#line 689
      fi.mdtm = ftime;
#line 690
      fi.size = fsize;
#line 691
      fi.type = ftype;
#line 692
      fi.mode = -1;
#line 693
      if (plugend > 0) {
        {
#line 694
        tmp___7 = malloc((size_t )plugend + 1UL);
#line 694
        fi.plug = (char *)tmp___7;
        }
#line 695
        if ((unsigned long )fi.plug != (unsigned long )((void *)0)) {
          {
#line 696
          memcpy((void */* __restrict  */)fi.plug, (void const   */* __restrict  */)(line),
                 (size_t )plugend);
#line 697
          *(fi.plug + plugend) = (char )'\000';
          }
#line 698
          if ((size_t )plugend > maxPlugLen) {
#line 699
            maxPlugLen = (size_t )plugend;
          }
        }
      } else {
        {
#line 702
        tmp___8 = malloc((size_t )33);
#line 702
        fi.plug = (char *)tmp___8;
        }
#line 703
        if ((unsigned long )fi.plug != (unsigned long )((void *)0)) {
          {
#line 704
          strcpy((char */* __restrict  */)fi.plug, (char const   */* __restrict  */)"----------   1 ftpuser  ftpusers");
#line 705
          *(fi.plug + 0) = (char )ftype;
          }
#line 706
          if (32UL > maxPlugLen) {
#line 707
            maxPlugLen = (size_t )32;
          }
        }
      }
      {
#line 710
      AddFileInfo(filp, & fi);
      }
    } else
#line 711
    if (rc < 0) {
#line 711
      if ((int )line[len - 1] == 58) {
#line 712
        if ((int )line[0] == 46) {
#line 712
          if ((int )line[1] == 47) {
            {
#line 713
            line[len - 1] = (char )'/';
#line 714
            memcpy((void */* __restrict  */)(curdir), (void const   */* __restrict  */)(line + 2),
                   ((size_t )len + 1UL) - 2UL);
#line 715
            curdirlen = (size_t )(len - 2);
            }
          } else {
#line 712
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 716
        if ((int )line[0] == 46) {
#line 716
          if ((int )line[1] == 92) {
            {
#line 717
            line[len - 1] = (char )'\\';
#line 718
            memcpy((void */* __restrict  */)(curdir), (void const   */* __restrict  */)(line + 2),
                   ((size_t )len + 1UL) - 2UL);
#line 719
            curdirlen = (size_t )(len - 2);
            }
          } else {
            {
#line 721
            line[len - 1] = (char )'/';
#line 722
            memcpy((void */* __restrict  */)(curdir), (void const   */* __restrict  */)(line),
                   (size_t )len + 1UL);
#line 723
            curdirlen = (size_t )len;
            }
          }
        } else {
          {
#line 721
          line[len - 1] = (char )'/';
#line 722
          memcpy((void */* __restrict  */)(curdir), (void const   */* __restrict  */)(line),
                 (size_t )len + 1UL);
#line 723
          curdirlen = (size_t )len;
          }
        }
#line 725
        skipdir = 0;
#line 726
        cp = curdir;
#line 727
        if ((int )*cp == 47) {
#line 727
          goto _L___1;
        } else
#line 727
        if ((int )*cp == 92) {
          _L___1: /* CIL Label */ 
#line 728
          skipdir = 1;
#line 729
          if ((int )*(cip->buf + 0) == 0) {
            {
#line 730
            FTPGetCWD(cip, (char */* const  */)cip->buf, (size_t const   )cip->bufSize);
#line 731
            cwdlen = strlen((char const   *)cip->buf);
            }
          }
#line 733
          if (cwdlen == 1UL) {
#line 737
            skipdir = 0;
          } else {
            {
#line 739
            tmp___10 = memcmp((void const   *)cp, (void const   *)cip->buf, cwdlen);
            }
#line 739
            if (tmp___10 == 0) {
#line 740
              cp += cwdlen;
#line 741
              if ((int )*cp == 47) {
#line 742
                cp ++;
              } else
#line 741
              if ((int )*cp == 92) {
#line 742
                cp ++;
              }
              {
#line 743
              tmp___9 = strlen((char const   *)cp);
#line 743
              memmove((void *)(curdir), (void const   *)cp, tmp___9 + 1UL);
#line 744
              skipdir = 0;
#line 745
              cp = curdir;
              }
            }
          }
        }
        {
#line 749
        tmp___11 = PathContainsIntermediateDotDotSubDir((char const   *)cp);
        }
#line 749
        if (tmp___11) {
#line 750
          skipdir = 1;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 612
    lp = lp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  filp->maxFileLen = maxFileLen;
#line 756
  filp->maxPlugLen = maxPlugLen;
#line 757
  if (linesread == 0) {
#line 758
    return (0);
  }
#line 759
  if (linesconverted > 0) {
#line 759
    tmp___12 = linesconverted;
  } else {
#line 759
    tmp___12 = -1;
  }
#line 759
  return (tmp___12);
}
}
#line 765 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
int UnMlsT(FTPCIPtr const   cip  __attribute__((__unused__)) , char const   * const  line0 ,
           MLstItemPtr const   mlip ) 
{ 
  char *cp ;
  char *val ;
  char *fact ;
  int ec ;
  size_t len ;
  char line[1024] ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 774
  memset((void *)mlip, 0, sizeof(MLstItem ));
#line 775
  mlip->mode = -1;
#line 776
  mlip->fsize = -1LL;
#line 777
  mlip->ftype = '-';
#line 778
  mlip->ftime = (time_t )-1;
#line 780
  len = strlen((char const   *)line0);
  }
#line 781
  if (len > sizeof(line) - 1UL) {
#line 782
    return (-1);
  }
  {
#line 786
  memcpy((void */* __restrict  */)(line), (void const   */* __restrict  */)line0,
         len + 1UL);
#line 789
  cp = line;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! ((int )*cp != 0)) {
#line 789
      goto while_break;
    }
    {
#line 790
    tmp = __ctype_b_loc();
    }
#line 790
    if (! ((int const   )*(*tmp + (int )*cp) & 8192)) {
#line 791
      goto while_break;
    }
#line 789
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 794
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 794
    if (! ((int )*cp != 0)) {
#line 794
      goto while_break___0;
    }
#line 795
    fact = cp;
    {
#line 795
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 796
      if ((int )*cp == 0) {
#line 798
        return (-1);
      } else
#line 796
      if ((int )*cp == 32) {
#line 798
        return (-1);
      }
#line 800
      if ((int )*cp == 61) {
#line 802
        tmp___0 = cp;
#line 802
        cp ++;
#line 802
        *tmp___0 = (char )'\000';
#line 803
        goto while_break___1;
      }
#line 795
      cp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 806
    val = cp;
    {
#line 806
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 807
      if ((int )*cp == 0) {
#line 809
        return (-1);
      }
#line 811
      if ((int )*cp == 32) {
#line 812
        ec = ' ';
#line 813
        tmp___1 = cp;
#line 813
        cp ++;
#line 813
        *tmp___1 = (char )'\000';
#line 814
        goto while_break___2;
      } else
#line 815
      if ((int )*cp == 59) {
#line 816
        if ((int )*(cp + 1) == 32) {
#line 817
          ec = ' ';
#line 818
          tmp___2 = cp;
#line 818
          cp ++;
#line 818
          *tmp___2 = (char )'\000';
#line 819
          tmp___3 = cp;
#line 819
          cp ++;
#line 819
          *tmp___3 = (char )'\000';
        } else {
#line 821
          ec = ';';
#line 822
          tmp___4 = cp;
#line 822
          cp ++;
#line 822
          *tmp___4 = (char )'\000';
        }
#line 824
        goto while_break___2;
      }
#line 806
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 827
    tmp___5 = strncasecmp((char const   *)fact, "OS.", (size_t )3);
    }
#line 827
    if (tmp___5 == 0) {
#line 828
      fact += 3;
    }
    {
#line 829
    tmp___19 = strcasecmp((char const   *)fact, "type");
    }
#line 829
    if (tmp___19 == 0) {
      {
#line 830
      tmp___9 = strcasecmp((char const   *)val, "file");
      }
#line 830
      if (tmp___9 == 0) {
#line 831
        mlip->ftype = '-';
      } else {
        {
#line 832
        tmp___8 = strcasecmp((char const   *)val, "dir");
        }
#line 832
        if (tmp___8 == 0) {
#line 833
          mlip->ftype = 'd';
        } else {
          {
#line 834
          tmp___7 = strcasecmp((char const   *)val, "cdir");
          }
#line 834
          if (tmp___7 == 0) {
#line 836
            return (-2);
          } else {
            {
#line 837
            tmp___6 = strcasecmp((char const   *)val, "pdir");
            }
#line 837
            if (tmp___6 == 0) {
#line 839
              return (-2);
            } else {
#line 842
              return (-1);
            }
          }
        }
      }
    } else {
      {
#line 844
      tmp___18 = strcasecmp((char const   *)fact, "UNIX.mode");
      }
#line 844
      if (tmp___18 == 0) {
#line 845
        if ((int )*(val + 0) == 48) {
          {
#line 846
          sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%o",
                 & mlip->mode);
          }
        } else {
          {
#line 848
          sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%i",
                 & mlip->mode);
          }
        }
#line 849
        if (mlip->mode != -1) {
#line 850
          mlip->mode &= 511;
        }
      } else {
        {
#line 851
        tmp___17 = strcasecmp((char const   *)fact, "perm");
        }
#line 851
        if (tmp___17 == 0) {
          {
#line 852
          Strncpy((char */* const  */)(mlip->perm), (char const   */* const  */)val,
                  (size_t const   )sizeof(mlip->perm));
          }
        } else {
          {
#line 853
          tmp___16 = strcasecmp((char const   *)fact, "size");
          }
#line 853
          if (tmp___16 == 0) {
            {
#line 855
            sscanf((char const   */* __restrict  */)val, (char const   */* __restrict  */)"%lld",
                   & mlip->fsize);
            }
          } else {
            {
#line 866
            tmp___15 = strcasecmp((char const   *)fact, "modify");
            }
#line 866
            if (tmp___15 == 0) {
              {
#line 867
              mlip->ftime = UnMDTMDate(val);
              }
            } else {
              {
#line 868
              tmp___14 = strcasecmp((char const   *)fact, "UNIX.owner");
              }
#line 868
              if (tmp___14 == 0) {
                {
#line 869
                Strncpy((char */* const  */)(mlip->owner), (char const   */* const  */)val,
                        (size_t const   )sizeof(mlip->owner));
                }
              } else {
                {
#line 870
                tmp___13 = strcasecmp((char const   *)fact, "UNIX.group");
                }
#line 870
                if (tmp___13 == 0) {
                  {
#line 871
                  Strncpy((char */* const  */)(mlip->group), (char const   */* const  */)val,
                          (size_t const   )sizeof(mlip->group));
                  }
                } else {
                  {
#line 872
                  tmp___12 = strcasecmp((char const   *)fact, "UNIX.uid");
                  }
#line 872
                  if (tmp___12 == 0) {
                    {
#line 873
                    mlip->uid = atoi((char const   *)val);
                    }
                  } else {
                    {
#line 874
                    tmp___11 = strcasecmp((char const   *)fact, "UNIX.gid");
                    }
#line 874
                    if (tmp___11 == 0) {
                      {
#line 875
                      mlip->gid = atoi((char const   *)val);
                      }
                    } else {
                      {
#line 876
                      tmp___10 = strcasecmp((char const   *)fact, "perm");
                      }
#line 876
                      if (tmp___10 == 0) {
                        {
#line 877
                        Strncpy((char */* const  */)(mlip->perm), (char const   */* const  */)val,
                                (size_t const   )sizeof(mlip->perm));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 881
    if (ec == 32) {
#line 882
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 885
  len = strlen((char const   *)cp);
  }
#line 886
  if (len > sizeof(mlip->fname) - 1UL) {
#line 888
    return (-1);
  }
  {
#line 890
  memcpy((void */* __restrict  */)(mlip->fname), (void const   */* __restrict  */)cp,
         len);
  }
#line 894
  return (0);
}
}
#line 900 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/unls.c"
int UnMlsD(FTPCIPtr const   cip , FTPFileInfoListPtr filp , FTPLineListPtr llp ) 
{ 
  MLstItem mli ;
  char plug[64] ;
  char og[32] ;
  int rc ;
  FTPLinePtr lp ;
  FTPFileInfo fi ;
  int linesread ;
  int linesconverted ;
  int linesignored ;
  size_t maxFileLen ;
  size_t maxPlugLen ;
  size_t fileLen ;
  size_t plugLen ;
  int m1 ;
  int m2 ;
  int m3 ;
  char const   *cm1 ;
  char const   *cm2 ;
  char const   *cm3 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 909
  linesread = 0;
#line 910
  linesconverted = 0;
#line 911
  linesignored = 0;
#line 912
  maxFileLen = (size_t )0;
#line 913
  maxPlugLen = (size_t )0;
#line 918
  InitFileInfoList(filp);
#line 919
  lp = llp->first;
  }
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 919
      goto while_break;
    }
    {
#line 920
    linesread ++;
#line 921
    rc = UnMlsT(cip, (char const   */* const  */)lp->line, (MLstItemPtr const   )(& mli));
    }
#line 922
    if (rc == 0) {
      {
#line 923
      tmp = PathContainsIntermediateDotDotSubDir((char const   *)(mli.fname));
      }
#line 923
      if (tmp) {
#line 924
        linesignored ++;
#line 925
        goto __Cont;
      }
      {
#line 927
      fileLen = strlen((char const   *)(mli.fname));
#line 928
      linesconverted ++;
      }
#line 929
      if (fileLen > maxFileLen) {
#line 930
        maxFileLen = fileLen;
      }
      {
#line 931
      fi.relnameLen = fileLen;
#line 932
      fi.relname = StrDup((char const   *)(mli.fname));
#line 933
      fi.rname = (char *)((void *)0);
#line 934
      fi.lname = (char *)((void *)0);
      }
#line 935
      if ((int )mli.linkto[0] == 0) {
#line 935
        fi.rlinkto = (char *)((void *)0);
      } else {
        {
#line 935
        tmp___0 = StrDup((char const   *)(mli.linkto));
#line 935
        fi.rlinkto = tmp___0;
        }
      }
#line 936
      fi.mdtm = mli.ftime;
#line 937
      fi.size = mli.fsize;
#line 938
      fi.type = mli.ftype;
#line 939
      fi.mode = -1;
#line 940
      plug[0] = (char )mli.ftype;
#line 941
      plug[1] = (char )'\000';
#line 942
      m1 = 0;
#line 943
      m2 = 0;
#line 944
      m3 = -1;
#line 945
      if (mli.mode != -1) {
#line 946
        fi.mode = mli.mode;
#line 947
        m1 = (mli.mode & 448) >> 6;
#line 948
        m2 = (mli.mode & 56) >> 3;
#line 949
        m3 = mli.mode & 7;
      } else
#line 950
      if ((int )mli.perm[0] != 0) {
#line 957
        m3 = 0;
#line 958
        if (fi.type == 100) {
          {
#line 959
          tmp___1 = strchr((char const   *)(mli.perm), 'e');
          }
#line 959
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 961
            m3 |= 1;
          }
          {
#line 963
          tmp___2 = strchr((char const   *)(mli.perm), 'c');
          }
#line 963
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 965
            m3 |= 2;
          }
          {
#line 967
          tmp___3 = strchr((char const   *)(mli.perm), 'l');
          }
#line 967
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 969
            m3 |= 4;
          }
        } else {
          {
#line 972
          tmp___4 = strchr((char const   *)(mli.perm), 'w');
          }
#line 972
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 974
            m3 |= 2;
          }
          {
#line 976
          tmp___5 = strchr((char const   *)(mli.perm), 'r');
          }
#line 976
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 978
            m3 |= 4;
          }
        }
      }
#line 982
      if (m3 != -1) {
        {
#line 983
        cm1 = rwx[m1];
#line 984
        cm2 = rwx[m2];
#line 985
        cm3 = rwx[m3];
#line 986
        sprintf((char */* __restrict  */)(plug + 1), (char const   */* __restrict  */)"%s%s%s",
                cm1, cm2, cm3);
        }
      }
#line 988
      if ((int )mli.owner[0] != 0) {
#line 989
        if ((int )mli.group[0] != 0) {
          {
#line 991
          snprintf((char */* __restrict  */)(og), sizeof(og) - 1UL, (char const   */* __restrict  */)"   %-8.8s %s",
                   mli.owner, mli.group);
#line 998
          Strncat((char */* const  */)(plug), (char const   */* const  */)(og), (size_t const   )sizeof(plug));
          }
        } else {
          {
#line 1000
          Strncat((char */* const  */)(plug), (char const   */* const  */)"   ", (size_t const   )sizeof(plug));
#line 1001
          Strncat((char */* const  */)(plug), (char const   */* const  */)(mli.owner),
                  (size_t const   )sizeof(plug));
          }
        }
      }
      {
#line 1004
      fi.plug = StrDup((char const   *)(plug));
      }
#line 1005
      if ((unsigned long )fi.plug != (unsigned long )((void *)0)) {
        {
#line 1006
        plugLen = strlen((char const   *)(plug));
        }
#line 1007
        if (plugLen > maxPlugLen) {
#line 1008
          maxPlugLen = plugLen;
        }
      }
      {
#line 1010
      AddFileInfo(filp, & fi);
      }
    } else
#line 1011
    if (rc == -2) {
#line 1012
      linesignored ++;
    }
    __Cont: /* CIL Label */ 
#line 919
    lp = lp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  filp->maxFileLen = maxFileLen;
#line 1017
  filp->maxPlugLen = maxPlugLen;
#line 1018
  if (linesread == 0) {
#line 1019
    return (0);
  } else
#line 1018
  if (linesconverted == 0) {
#line 1018
    if (linesignored > 0) {
#line 1019
      return (0);
    }
  }
#line 1020
  if (linesconverted > 0) {
#line 1020
    tmp___6 = linesconverted;
  } else {
#line 1020
    tmp___6 = -1;
  }
#line 1020
  return (tmp___6);
}
}
#line 956 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void Scramble(unsigned char *dst , size_t dsize , unsigned char *src , char *key ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_scram.c"
void Scramble(unsigned char *dst , size_t dsize , unsigned char *src , char *key ) 
{ 
  int i___0 ;
  unsigned int ch ;
  unsigned char *k2 ;
  size_t keyLen ;

  {
  {
#line 21
  keyLen = strlen((char const   *)key);
#line 22
  k2 = (unsigned char *)key;
#line 23
  i___0 = 0;
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (i___0 < (int )dsize - 1)) {
#line 23
      goto while_break;
    }
#line 24
    ch = (unsigned int )*(src + i___0);
#line 25
    if (ch == 0U) {
#line 26
      goto while_break;
    }
#line 27
    *(dst + i___0) = (unsigned char )(ch ^ (unsigned int )((int )*(k2 + i___0 % (int )keyLen)));
#line 23
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  *(dst + i___0) = (unsigned char )'\000';
#line 30
  return;
}
}
#line 809 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 1049 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPLocalRecursiveFileList(FTPCIPtr cip , FTPLineListPtr fileList , FTPFileInfoListPtr files ) ;
#line 1050
int FTPLocalRecursiveFileList2(FTPCIPtr cip , FTPLineListPtr fileList , FTPFileInfoListPtr files ,
                               int erelative ) ;
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglobr.c"
static int FTPLocalRecursiveFileListFtwProc(FtwInfoPtr const   ftwip ) 
{ 
  FTPFileInfo fi ;
  mode_t m ;
  LRFLState *lrflstate ;
  char const   *cp ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 28
  if ((int )*(ftwip->curPath + 0) == 0) {
#line 29
    return (0);
  } else {
    {
#line 28
    tmp = strcmp((char const   *)ftwip->curPath, ".");
    }
#line 28
    if (tmp == 0) {
#line 29
      return (0);
    }
  }
#line 31
  lrflstate = (LRFLState *)ftwip->userdata;
#line 32
  cp = (char const   *)ftwip->curPath;
#line 33
  if (lrflstate->relativePathStartOffset > 0) {
#line 34
    cp += lrflstate->relativePathStartOffset;
#line 35
    if ((int const   )*cp == 47) {
#line 36
      cp ++;
    }
  }
  {
#line 38
  fi.relname = StrDup(cp);
#line 39
  fi.rname = (char *)((void *)0);
#line 40
  fi.lname = StrDup((char const   *)ftwip->curPath);
#line 41
  fi.mdtm = ftwip->curStat.st_mtim.tv_sec;
#line 42
  fi.rlinkto = (char *)((void *)0);
#line 43
  fi.plug = (char *)((void *)0);
#line 45
  m = ftwip->curStat.st_mode;
  }
#line 46
  if (((m & 61440U) == 32768U) != 0) {
    {
#line 48
    fi.type = '-';
#line 49
    fi.size = (long long )ftwip->curStat.st_size;
#line 50
    AddFileInfo(lrflstate->filp, & fi);
    }
  } else
#line 54
  if ((m & 61440U) == 16384U) {
    {
#line 56
    fi.type = 'd';
#line 57
    fi.size = 0LL;
#line 58
    AddFileInfo(lrflstate->filp, & fi);
    }
  } else
#line 63
  if ((m & 61440U) == 40960U) {
    {
#line 65
    fi.type = 'l';
#line 66
    fi.size = 0LL;
#line 67
    tmp___0 = calloc((size_t )256, (size_t )1);
#line 67
    fi.rlinkto = (char *)tmp___0;
    }
#line 68
    if ((unsigned long )fi.rlinkto != (unsigned long )((void *)0)) {
      {
#line 69
      tmp___1 = readlink((char const   */* __restrict  */)ftwip->curPath, (char */* __restrict  */)fi.rlinkto,
                         (size_t )255);
      }
#line 69
      if (tmp___1 < 0L) {
        {
#line 70
        free((void *)fi.rlinkto);
#line 71
        fi.rlinkto = (char *)((void *)0);
        }
      } else {
        {
#line 73
        AddFileInfo(lrflstate->filp, & fi);
        }
      }
    }
#line 76
    if ((unsigned long )fi.rlinkto == (unsigned long )((void *)0)) {
      {
#line 77
      free((void *)fi.relname);
#line 78
      free((void *)fi.lname);
      }
    }
  } else {
    {
#line 89
    free((void *)fi.relname);
#line 90
    free((void *)fi.lname);
    }
  }
#line 93
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglobr.c"
int FTPLocalRecursiveFileList2(FTPCIPtr cip , FTPLineListPtr fileList , FTPFileInfoListPtr files ,
                               int erelative ) 
{ 
  FTPLinePtr filePtr ;
  FTPLinePtr nextFilePtr ;
  char *cp ;
  FtwInfo ftwi ;
  LRFLState lrflstate ;
  struct stat st ;
  FTPFileInfo fi ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 109
  FtwInit((FtwInfo */* const  */)(& ftwi));
#line 110
  InitFileInfoList(files);
#line 111
  lrflstate.filp = files;
#line 113
  filePtr = fileList->first;
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 113
      goto while_break;
    }
    {
#line 117
    nextFilePtr = filePtr->next;
#line 119
    StrRemoveTrailingSlashes(filePtr->line);
#line 120
    cp = (char *)((void *)0);
    }
#line 121
    if (erelative != 0) {
      {
#line 123
      cp = filePtr->line;
#line 124
      tmp = strlen((char const   *)cp);
#line 124
      lrflstate.relativePathStartOffset = (int )tmp;
      }
    } else {
      {
#line 125
      tmp___0 = strcmp((char const   *)filePtr->line, ".");
      }
#line 125
      if (tmp___0 == 0) {
#line 127
        lrflstate.relativePathStartOffset = 1;
      } else
#line 128
      if ((int )*(filePtr->line + 0) == 47) {
#line 128
        if ((int )*(filePtr->line + 1) == 0) {
#line 130
          lrflstate.relativePathStartOffset = 1;
        } else {
#line 128
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 131
        cp = strrchr((char const   *)filePtr->line, '/');
        }
#line 131
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 133
          lrflstate.relativePathStartOffset = 0;
#line 134
          cp = filePtr->line;
        } else {
#line 137
          cp ++;
#line 138
          lrflstate.relativePathStartOffset = (int )(cp - filePtr->line);
        }
      }
    }
#line 142
    if ((int )*(filePtr->line + 0) == 0) {
#line 142
      tmp___2 = ".";
    } else {
#line 142
      tmp___2 = (char const   *)filePtr->line;
    }
    {
#line 142
    tmp___3 = stat((char const   */* __restrict  */)tmp___2, (struct stat */* __restrict  */)(& st));
    }
#line 142
    if (tmp___3 < 0) {
#line 143
      if ((int )*(filePtr->line + 0) == 0) {
#line 143
        tmp___1 = ".";
      } else {
#line 143
        tmp___1 = (char const   *)filePtr->line;
      }
      {
#line 143
      FTPLogError((FTPCIPtr const   )cip, (int const   )1, (char const   */* const  */)"could not stat %s.\n",
                  tmp___1);
      }
#line 144
      goto __Cont;
    }
#line 147
    if (((st.st_mode & 61440U) == 16384U) == 0) {
      {
#line 148
      fi.relname = StrDup((char const   *)cp);
#line 149
      fi.rname = (char *)((void *)0);
#line 150
      fi.lname = StrDup((char const   *)filePtr->line);
#line 151
      fi.mdtm = st.st_mtim.tv_sec;
#line 152
      fi.size = (long long )st.st_size;
#line 153
      fi.rlinkto = (char *)((void *)0);
#line 154
      fi.plug = (char *)((void *)0);
#line 155
      fi.type = '-';
#line 156
      AddFileInfo(files, & fi);
      }
#line 157
      goto __Cont;
    }
    {
#line 161
    ftwi.userdata = (void *)(& lrflstate);
#line 162
    Ftw((FtwInfo */* const  */)(& ftwi), (char const   */* const  */)filePtr->line,
        & FTPLocalRecursiveFileListFtwProc);
    }
    __Cont: /* CIL Label */ 
#line 113
    filePtr = nextFilePtr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  FtwDispose((FtwInfo */* const  */)(& ftwi));
  }
#line 166
  return (0);
}
}
#line 172 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglobr.c"
int FTPLocalRecursiveFileList(FTPCIPtr cip , FTPLineListPtr fileList , FTPFileInfoListPtr files ) 
{ 
  int tmp ;

  {
  {
#line 175
  tmp = FTPLocalRecursiveFileList2(cip, fileList, files, 0);
  }
#line 175
  return (tmp);
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_sizemdtm.c"
int FTPFileSizeAndModificationTime(FTPCIPtr const   cip , char const   * const  file ,
                                   long long * const  size , int const   type , time_t * const  mdtm ) 
{ 
  MLstItem mlsInfo ;
  int result ;
  int tmp ;

  {
#line 19
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 20
    return (-139);
  }
  {
#line 21
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 21
  if (tmp) {
#line 22
    return (-138);
  }
#line 24
  if ((unsigned long )mdtm == (unsigned long )((void *)0)) {
#line 25
    return (-139);
  } else
#line 24
  if ((unsigned long )size == (unsigned long )((void *)0)) {
#line 25
    return (-139);
  } else
#line 24
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 25
    return (-139);
  }
  {
#line 27
  *mdtm = (time_t )-1;
#line 28
  *size = -1LL;
#line 30
  result = FTPSetTransferType(cip, (int )type);
  }
#line 31
  if (result < 0) {
#line 32
    return (result);
  }
  {
#line 34
  result = FTPMListOneFile(cip, file, (MLstItemPtr const   )(& mlsInfo));
  }
#line 35
  if (result < 0) {
    {
#line 39
    result = FTPFileSize(cip, file, size, type);
    }
#line 40
    if (result < 0) {
#line 41
      return (result);
    }
    {
#line 42
    result = FTPFileModificationTime(cip, file, mdtm);
    }
#line 43
    return (result);
  } else {
#line 45
    *mdtm = mlsInfo.ftime;
#line 46
    *size = mlsInfo.fsize;
  }
#line 49
  return (result);
}
}
#line 288 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
char const   *SError(int e ) ;
#line 144 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SError.c"
char const   *SError(int e ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 165
  if (e == 0) {
    {
#line 166
    tmp = __errno_location();
#line 166
    e = *tmp;
    }
  }
  {
#line 167
  tmp___0 = strerror(e);
  }
#line 167
  return ((char const   *)tmp___0);
}
}
#line 914 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPPutOneFile3(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   appendflag ,
                   char const   * const  tmppfx , char const   * const  tmpsfx , int const   resumeflag ,
                   int const   deleteflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                      char const   *localpath ,
                                                                      long long localsize ,
                                                                      time_t localmtime ,
                                                                      char const   **remotepath ,
                                                                      long long remotesize ,
                                                                      time_t remotetime ,
                                                                      long long *startPoint ) ,
                   int reserved  __attribute__((__unused__)) ) ;
#line 994
int FTPPutOneFile(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) ;
#line 995
int FTPPutOneFile2(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   appendflag ,
                   char const   * const  tmppfx , char const   * const  tmpsfx ) ;
#line 998
int FTPPutOneFileAscii(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putonefile.c"
int FTPPutOneFile3(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   appendflag ,
                   char const   * const  tmppfx , char const   * const  tmpsfx , int const   resumeflag ,
                   int const   deleteflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                      char const   *localpath ,
                                                                      long long localsize ,
                                                                      time_t localmtime ,
                                                                      char const   **remotepath ,
                                                                      long long remotesize ,
                                                                      time_t remotetime ,
                                                                      long long *startPoint ) ,
                   int reserved  __attribute__((__unused__)) ) 
{ 
  int result ;
  int tmp ;

  {
#line 52
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 53
    return (-139);
  }
  {
#line 54
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 54
  if (tmp) {
#line 55
    return (-138);
  }
#line 57
  if ((unsigned long )dstfile == (unsigned long )((void *)0)) {
#line 58
    return (-139);
  } else
#line 57
  if ((int const   )*(dstfile + 0) == 0) {
#line 58
    return (-139);
  }
#line 59
  if (fdtouse < 0) {
#line 60
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 61
      return (-139);
    } else
#line 60
    if ((int const   )*(file + 0) == 0) {
#line 61
      return (-139);
    }
  }
  {
#line 63
  result = FTPPutOneF(cip, file, (char const   */* volatile  */)dstfile, (int )xtype,
                      fdtouse, appendflag, (char const   */* volatile  */)tmppfx,
                      (char const   */* volatile  */)tmpsfx, resumeflag, deleteflag,
                      resumeProc);
  }
#line 64
  return (result);
}
}
#line 70 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putonefile.c"
int FTPPutOneFile(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = FTPPutOneFile3(cip, file, dstfile, (int const   )'I', (int const   )-1, (int const   )0,
                       (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                       (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                              char const   *localpath ,
                                                                              long long localsize ,
                                                                              time_t localmtime ,
                                                                              char const   **remotepath ,
                                                                              long long remotesize ,
                                                                              time_t remotetime ,
                                                                              long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                char const   *localpath ,
                                                                                                                long long localsize ,
                                                                                                                time_t localmtime ,
                                                                                                                char const   **remotepath ,
                                                                                                                long long remotesize ,
                                                                                                                time_t remotetime ,
                                                                                                                long long *startPoint ))0),
                       0);
  }
#line 73
  return (tmp);
}
}
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putonefile.c"
int FTPPutOneFile2(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   appendflag ,
                   char const   * const  tmppfx , char const   * const  tmpsfx ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = FTPPutOneFile3(cip, file, dstfile, xtype, fdtouse, appendflag, tmppfx, tmpsfx,
                       (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                              char const   *localpath ,
                                                                              long long localsize ,
                                                                              time_t localmtime ,
                                                                              char const   **remotepath ,
                                                                              long long remotesize ,
                                                                              time_t remotetime ,
                                                                              long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                char const   *localpath ,
                                                                                                                long long localsize ,
                                                                                                                time_t localmtime ,
                                                                                                                char const   **remotepath ,
                                                                                                                long long remotesize ,
                                                                                                                time_t remotetime ,
                                                                                                                long long *startPoint ))0),
                       0);
  }
#line 82
  return (tmp);
}
}
#line 88 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putonefile.c"
int FTPPutOneFileAscii(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) 
{ 
  int tmp ;

  {
  {
#line 91
  tmp = FTPPutOneFile3(cip, file, dstfile, (int const   )'A', (int const   )-1, (int const   )0,
                       (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                       (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                              char const   *localpath ,
                                                                              long long localsize ,
                                                                              time_t localmtime ,
                                                                              char const   **remotepath ,
                                                                              long long remotesize ,
                                                                              time_t remotetime ,
                                                                              long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                char const   *localpath ,
                                                                                                                long long localsize ,
                                                                                                                time_t localmtime ,
                                                                                                                char const   **remotepath ,
                                                                                                                long long remotesize ,
                                                                                                                time_t remotetime ,
                                                                                                                long long *startPoint ))0),
                       0);
  }
#line 91
  return (tmp);
}
}
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rftw.c"
static int FTPFtwTraverse(FtwInfoPtr const   ftwip , size_t dirPathLen , int depth ) 
{ 
  char *cp ;
  size_t fnLen ;
  mode_t m ;
  char *filename ;
  char *newBuf ;
  char *path ;
  int nSubdirs ;
  FtwSubDirListPtr head ;
  FtwSubDirListPtr tail ;
  FtwSubDirListPtr sdp ;
  FtwSubDirListPtr nextsdp ;
  int rc ;
  int lsl ;
  int mls ;
  int unlsrc ;
  FTPCIPtr cip ;
  FTPLineList ll ;
  FTPFileInfoList fil ;
  FTPLinePtr filePtr ;
  FTPFileInfoPtr fip ;
  int result ;
  int isRootDir ;
  long long sz ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 33
  path = ftwip->curPath;
#line 35
  head = (FtwSubDirListPtr )((void *)0);
#line 35
  tail = (FtwSubDirListPtr )((void *)0);
#line 36
  rc = -1;
#line 38
  cip = (FTPCIPtr )ftwip->cip;
#line 47
  if (dirPathLen == 1UL) {
#line 47
    if ((int )*(path + 0) == 47) {
#line 47
      isRootDir = 1;
    } else
#line 47
    if ((int )*(path + 0) == 92) {
#line 47
      isRootDir = 1;
    } else {
#line 47
      isRootDir = 0;
    }
  } else {
#line 47
    isRootDir = 0;
  }
#line 48
  filePtr = (FTPLinePtr )((void *)0);
#line 49
  fip = (FTPFileInfoPtr )((void *)0);
#line 50
  mls = 0;
#line 51
  lsl = 0;
#line 53
  if (cip->hasMLSD == 1) {
#line 54
    mls = 1;
#line 55
    if (dirPathLen) {
#line 55
      tmp = (char const   *)path;
    } else {
#line 55
      tmp = ".";
    }
    {
#line 55
    result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)tmp,
                              (FTPLineListPtr const   )(& ll), (char const   */* const  */)"-a",
                              (int const   )0, (int */* const  */)(& mls));
    }
#line 55
    if (result < 0) {
      {
#line 57
      DisposeLineListContents(& ll);
      }
#line 58
      return (0);
    } else
#line 55
    if ((unsigned long )ll.first == (unsigned long )((void *)0)) {
      {
#line 57
      DisposeLineListContents(& ll);
      }
#line 58
      return (0);
    }
    {
#line 62
    unlsrc = UnMlsD((FTPCIPtr const   )cip, & fil, & ll);
    }
#line 63
    if (unlsrc < 0) {
      {
#line 64
      DisposeLineListContents(& ll);
#line 65
      tmp___0 = -181;
#line 65
      cip->errNo = tmp___0;
      }
#line 65
      return (tmp___0);
    } else
#line 66
    if (unlsrc == 0) {
      {
#line 68
      DisposeLineListContents(& ll);
      }
#line 69
      return (0);
    }
    {
#line 71
    fip = fil.first;
#line 72
    DisposeLineListContents(& ll);
    }
  } else {
#line 74
    if (dirPathLen) {
#line 74
      tmp___4 = (char const   *)path;
    } else {
#line 74
      tmp___4 = ".";
    }
    {
#line 74
    result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)tmp___4,
                              (FTPLineListPtr const   )(& ll), (char const   */* const  */)"-la",
                              (int const   )0, (int */* const  */)(& mls));
    }
#line 74
    if (result < 0) {
#line 74
      goto _L;
    } else
#line 74
    if ((unsigned long )ll.first == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 75
      DisposeLineListContents(& ll);
      }
#line 76
      if (cip->hasNLST_a == 0) {
#line 76
        tmp___1 = "";
      } else {
#line 76
        tmp___1 = "-a";
      }
#line 76
      if (dirPathLen) {
#line 76
        tmp___2 = (char const   *)path;
      } else {
#line 76
        tmp___2 = ".";
      }
      {
#line 76
      result = FTPListToMemory2((FTPCIPtr const   )cip, (char const   */* const  */)tmp___2,
                                (FTPLineListPtr const   )(& ll), (char const   */* const  */)tmp___1,
                                (int const   )0, (int */* const  */)(& mls));
      }
#line 76
      if (result < 0) {
        {
#line 77
        DisposeLineListContents(& ll);
        }
#line 78
        return (0);
      } else
#line 76
      if ((unsigned long )ll.first == (unsigned long )((void *)0)) {
        {
#line 77
        DisposeLineListContents(& ll);
        }
#line 78
        return (0);
      } else {
        {
#line 81
        RemoteGlobCollapse((FTPCIPtr const   )cip, (char const   *)path, & ll);
#line 82
        filePtr = ll.first;
        }
      }
    } else {
      {
#line 86
      lsl = 1;
#line 87
      unlsrc = UnLslR((FTPCIPtr const   )cip, & fil, & ll, cip->serverType);
      }
#line 88
      if (unlsrc < 0) {
        {
#line 89
        DisposeLineListContents(& ll);
#line 90
        tmp___3 = -181;
#line 90
        cip->errNo = tmp___3;
        }
#line 90
        return (tmp___3);
      } else
#line 91
      if (unlsrc == 0) {
        {
#line 93
        DisposeLineListContents(& ll);
        }
#line 94
        return (0);
      }
      {
#line 96
      fip = fil.first;
#line 97
      DisposeLineListContents(& ll);
      }
    }
  }
#line 101
  nSubdirs = 0;
#line 102
  (ftwip->numDirs) ++;
#line 103
  ftwip->depth = (size_t )depth;
#line 104
  if (ftwip->maxDepth < ftwip->depth) {
#line 105
    ftwip->maxDepth = ftwip->depth;
  }
#line 107
  filename = path + dirPathLen;
#line 108
  if (isRootDir == 0) {
#line 109
    tmp___5 = filename;
#line 109
    filename ++;
#line 109
    *tmp___5 = (char )ftwip->dirSeparator;
#line 110
    dirPathLen ++;
  }
#line 112
  *filename = (char )'\000';
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (mls != 0) {
#line 116
      goto _L___0;
    } else
#line 116
    if (lsl != 0) {
      _L___0: /* CIL Label */ 
#line 117
      if ((unsigned long )fip == (unsigned long )((void *)0)) {
#line 118
        goto while_break;
      }
#line 119
      cp = fip->relname;
    } else {
#line 121
      if ((unsigned long )filePtr == (unsigned long )((void *)0)) {
#line 122
        goto while_break;
      }
#line 123
      cp = filePtr->line;
    }
#line 125
    if ((int )*(cp + 0) == 46) {
#line 125
      if ((int )*(cp + 1) == 0) {
#line 126
        goto nxt;
      } else
#line 125
      if ((int )*(cp + 1) == 46) {
#line 125
        if ((int )*(cp + 2) == 0) {
#line 126
          goto nxt;
        }
      }
    }
    {
#line 128
    ftwip->rlinkto = (char const   *)((void *)0);
#line 129
    *filename = (char )'\000';
#line 130
    tmp___6 = strlen((char const   *)cp);
#line 130
    fnLen = tmp___6 + 1UL;
    }
#line 131
    if (fnLen + dirPathLen > ftwip->curPathAllocSize) {
#line 132
      if (ftwip->autoGrow == 0) {
#line 133
        goto panic;
      } else
#line 134
      if (ftwip->autoGrow == -1) {
#line 135
        goto nxt;
      }
      {
#line 137
      tmp___7 = realloc((void *)ftwip->curPath, ((fnLen + dirPathLen) + 30UL) + 2UL);
#line 137
      newBuf = (char *)tmp___7;
      }
#line 138
      if ((unsigned long )newBuf == (unsigned long )((void *)0)) {
#line 139
        goto panic;
      }
#line 140
      ftwip->curPath = newBuf;
#line 141
      ftwip->curPathAllocSize = (fnLen + dirPathLen) + 30UL;
#line 142
      path = ftwip->curPath;
#line 143
      filename = path + dirPathLen;
#line 144
      if (isRootDir == 0) {
#line 145
        tmp___8 = filename;
#line 145
        filename ++;
#line 145
        *tmp___8 = (char )ftwip->dirSeparator;
      }
#line 146
      *filename = (char )'\000';
    }
    {
#line 148
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)cp,
           fnLen);
#line 149
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 150
    ftwip->curFile = filename;
#line 151
    ftwip->curFileLen = fnLen - 1UL;
#line 153
    memset((void *)(& ftwip->curStat), 0, sizeof(ftwip->curStat));
    }
#line 154
    if (mls != 0) {
#line 155
      ftwip->curType = fip->type;
#line 156
      if (fip->type == 100) {
#line 157
        ftwip->curStat.st_mode = (__mode_t )16384;
#line 158
        ftwip->curStat.st_size = (__off_t )-1LL;
      } else
#line 160
      if (fip->type == 108) {
#line 161
        ftwip->curStat.st_mode = (__mode_t )40960;
#line 162
        ftwip->rlinkto = (char const   *)fip->rlinkto;
      } else
#line 164
      if (fip->type == 45) {
#line 165
        ftwip->curStat.st_mode = (__mode_t )32768;
#line 166
        ftwip->curStat.st_size = (__off_t )fip->size;
      } else {
#line 169
        goto nxt;
      }
#line 171
      if (fip->mode != -1) {
#line 172
        ftwip->curStat.st_mode |= (unsigned int )(fip->mode & 511);
      }
#line 173
      ftwip->curStat.st_mtim.tv_sec = fip->mdtm;
    } else
#line 174
    if (lsl != 0) {
#line 175
      ftwip->curType = fip->type;
#line 176
      if (fip->type == 100) {
#line 177
        ftwip->curStat.st_mode = (__mode_t )16384;
#line 178
        ftwip->curStat.st_size = (__off_t )-1LL;
      } else
#line 180
      if (fip->type == 108) {
#line 181
        ftwip->curStat.st_mode = (__mode_t )40960;
#line 182
        ftwip->rlinkto = (char const   *)fip->rlinkto;
      } else
#line 184
      if (fip->type == 45) {
#line 185
        ftwip->curStat.st_mode = (__mode_t )32768;
#line 186
        ftwip->curStat.st_size = (__off_t )fip->size;
      } else {
#line 189
        goto nxt;
      }
#line 191
      if (fip->mode != -1) {
#line 192
        ftwip->curStat.st_mode |= (unsigned int )(fip->mode & 511);
      }
      {
#line 193
      ftwip->curStat.st_mtim.tv_sec = fip->mdtm;
#line 196
      result = FTPFileModificationTime((FTPCIPtr const   )cip, (char const   */* const  */)path,
                                       (time_t */* const  */)(& fip->mdtm));
      }
#line 197
      if (fip->mdtm != -1L) {
#line 198
        ftwip->curStat.st_mtim.tv_sec = fip->mdtm;
      }
    } else {
      {
#line 201
      result = FTPIsDir((FTPCIPtr const   )cip, (char const   */* const  */)path);
      }
#line 202
      if (result < 0) {
#line 205
        goto nxt;
      } else
#line 206
      if (result == 1) {
        {
#line 208
        ftwip->curType = 'd';
#line 209
        ftwip->curStat.st_mode = (__mode_t )16877;
#line 210
        result = FTPFileModificationTime((FTPCIPtr const   )cip, (char const   */* const  */)path,
                                         (time_t */* const  */)(& ftwip->curStat.st_mtim.tv_sec));
        }
      } else {
        {
#line 213
        ftwip->curType = '-';
#line 214
        ftwip->curStat.st_mode = (__mode_t )33188;
#line 215
        result = FTPFileSizeAndModificationTime((FTPCIPtr const   )cip, (char const   */* const  */)path,
                                                (long long */* const  */)(& sz), (int const   )'I',
                                                (time_t */* const  */)(& ftwip->curStat.st_mtim.tv_sec));
#line 219
        ftwip->curStat.st_size = (__off_t )sz;
        }
      }
    }
#line 225
    m = ftwip->curStat.st_mode;
#line 226
    if ((m & 61440U) == 32768U) {
      {
#line 227
      (ftwip->numFiles) ++;
#line 228
      ftwip->curType = '-';
#line 229
      tmp___9 = (*(ftwip->proc))(ftwip);
      }
#line 229
      if (tmp___9 < 0) {
#line 230
        goto panic;
      }
    } else
#line 232
    if ((m & 61440U) == 40960U) {
      {
#line 233
      (ftwip->numLinks) ++;
#line 234
      ftwip->curType = 'l';
#line 235
      tmp___10 = (*(ftwip->proc))(ftwip);
      }
#line 235
      if (tmp___10 < 0) {
#line 236
        goto panic;
      }
    } else
#line 238
    if ((m & 61440U) == 16384U) {
      {
#line 245
      tmp___11 = malloc(sizeof(FtwSubDirList ) + fnLen);
#line 245
      sdp = (FtwSubDirListPtr )tmp___11;
      }
#line 246
      if ((unsigned long )sdp == (unsigned long )((void *)0)) {
#line 247
        goto panic;
      }
      {
#line 248
      memcpy((void */* __restrict  */)(& sdp->st), (void const   */* __restrict  */)(& ftwip->curStat),
             sizeof(sdp->st));
#line 249
      memcpy((void */* __restrict  */)(sdp->name), (void const   */* __restrict  */)cp,
             fnLen);
#line 250
      sdp->fnLen = fnLen;
#line 251
      sdp->next = (FtwSubDirListPtr )((void *)0);
      }
#line 252
      if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 253
        tail = sdp;
#line 253
        head = tail;
      } else {
#line 255
        tail->next = sdp;
#line 256
        tail = sdp;
      }
#line 258
      nSubdirs ++;
    }
    nxt: 
#line 262
    if (mls != 0) {
#line 263
      fip = fip->next;
    } else
#line 262
    if (lsl != 0) {
#line 263
      fip = fip->next;
    } else {
#line 265
      filePtr = filePtr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if (mls != 0) {
    {
#line 270
    DisposeFileInfoListContents(& fil);
    }
  } else
#line 269
  if (lsl != 0) {
    {
#line 270
    DisposeFileInfoListContents(& fil);
    }
  } else {
    {
#line 272
    DisposeLineListContents(& ll);
    }
  }
#line 276
  sdp = head;
  {
#line 276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 276
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 276
      goto while_break___0;
    }
    {
#line 277
    nextsdp = sdp->next;
#line 278
    memcpy((void */* __restrict  */)(& ftwip->curStat), (void const   */* __restrict  */)(& sdp->st),
           sizeof(ftwip->curStat));
#line 279
    fnLen = sdp->fnLen;
#line 280
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)(sdp->name),
           fnLen);
#line 281
    ftwip->curFile = filename;
#line 282
    ftwip->curFileLen = fnLen - 1UL;
#line 283
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 284
    head = nextsdp;
#line 285
    free((void *)sdp);
#line 287
    ftwip->curType = 'd';
#line 288
    tmp___12 = (*(ftwip->proc))(ftwip);
    }
#line 288
    if (tmp___12 < 0) {
#line 289
      goto panic;
    }
    {
#line 291
    tmp___13 = FTPFtwTraverse(ftwip, (dirPathLen + fnLen) - 1UL, depth + 1);
    }
#line 291
    if (tmp___13 < 0) {
#line 292
      goto panic;
    }
#line 297
    path = ftwip->curPath;
#line 298
    filename = path + dirPathLen;
#line 299
    *filename = (char )'\000';
#line 276
    sdp = nextsdp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 301
  head = (FtwSubDirListPtr )((void *)0);
#line 302
  rc = 0;
  panic: 
#line 305
  if (mls != 0) {
    {
#line 306
    DisposeFileInfoListContents(& fil);
    }
  } else {
    {
#line 308
    DisposeLineListContents(& ll);
    }
  }
#line 311
  sdp = head;
  {
#line 311
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 311
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 311
      goto while_break___1;
    }
    {
#line 312
    nextsdp = sdp->next;
#line 313
    free((void *)sdp);
#line 311
    sdp = nextsdp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 316
  return (rc);
}
}
#line 320 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rftw.c"
int FTPFtw(FTPCIPtr const   cip , FtwInfoPtr const   ftwip , char const   * const  path ,
           int (*proc)(FtwInfoPtr const   ftwip ) ) 
{ 
  size_t len ;
  size_t alen ;
  int rc ;
  MLstItem mli ;
  char *cp ;
  char *endp ;
  int tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
#line 328
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 329
    return (-139);
  }
  {
#line 330
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 330
  if (tmp) {
#line 331
    return (-138);
  }
#line 333
  if (ftwip->init != 4063516287U) {
    {
#line 334
    cip->errNo = -139;
#line 335
    tmp___0 = __errno_location();
#line 335
    *tmp___0 = 22;
    }
#line 336
    return (-139);
  } else
#line 333
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 334
    cip->errNo = -139;
#line 335
    tmp___0 = __errno_location();
#line 335
    *tmp___0 = 22;
    }
#line 336
    return (-139);
  } else
#line 333
  if ((int const   )*(path + 0) == 0) {
    {
#line 334
    cip->errNo = -139;
#line 335
    tmp___0 = __errno_location();
#line 335
    *tmp___0 = 22;
    }
#line 336
    return (-139);
  } else
#line 333
  if ((unsigned long )proc == (unsigned long )((int (*)(FtwInfoPtr const   ftwip ))0)) {
    {
#line 334
    cip->errNo = -139;
#line 335
    tmp___0 = __errno_location();
#line 335
    *tmp___0 = 22;
    }
#line 336
    return (-139);
  }
  {
#line 339
  ftwip->rlinkto = (char const   *)((void *)0);
#line 340
  ftwip->dirSeparator = '/';
#line 341
  ftwip->rootDir[0] = (char )'/';
#line 342
  ftwip->startPathLen = (size_t )0;
#line 344
  len = strlen((char const   *)path);
  }
#line 345
  if ((unsigned long )ftwip->curPath == (unsigned long )((void *)0)) {
#line 350
    ftwip->autoGrow = 1;
#line 351
    alen = (len + 30UL) + 2UL;
#line 352
    if (alen < 256UL) {
#line 353
      alen = (size_t )256;
    }
    {
#line 354
    tmp___1 = malloc(alen);
#line 354
    ftwip->curPath = (char *)tmp___1;
    }
#line 355
    if ((unsigned long )ftwip->curPath == (unsigned long )((void *)0)) {
#line 356
      return (-1);
    }
#line 357
    ftwip->curPathAllocSize = alen - 2UL;
  }
  {
#line 360
  ftwip->cip = (void *)cip;
#line 362
  rc = FTPIsDir(cip, path);
  }
#line 363
  if (rc < 0) {
#line 365
    return (rc);
  } else
#line 366
  if (rc == 0) {
    {
#line 367
    tmp___2 = -191;
#line 367
    cip->errNo = tmp___2;
#line 367
    rc = tmp___2;
#line 368
    tmp___3 = __errno_location();
#line 368
    *tmp___3 = 20;
    }
#line 369
    return (rc);
  }
  {
#line 371
  memset((void *)(& ftwip->curStat), 0, sizeof(ftwip->curStat));
#line 372
  ftwip->curStat.st_mode = (__mode_t )16877;
#line 373
  ftwip->curType = 'd';
#line 374
  tmp___4 = FTPMListOneFile(cip, path, (MLstItemPtr const   )(& mli));
  }
#line 374
  if (tmp___4 == 0) {
#line 375
    ftwip->curStat.st_mtim.tv_sec = mli.ftime;
#line 376
    if (mli.mode != -1) {
#line 377
      ftwip->curStat.st_mode = (__mode_t )16384;
#line 378
      ftwip->curStat.st_mode |= (unsigned int )(mli.mode & 511);
    }
  } else {
    {
#line 381
    FTPFileModificationTime(cip, path, (time_t */* const  */)(& ftwip->curStat.st_mtim.tv_sec));
    }
  }
  {
#line 383
  ftwip->curStat.st_size = (__off_t )-1LL;
#line 385
  memset((void *)ftwip->curPath, 0, ftwip->curPathAllocSize);
#line 386
  memcpy((void */* __restrict  */)ftwip->curPath, (void const   */* __restrict  */)path,
         len + 1UL);
#line 387
  tmp___5 = strlen((char const   *)ftwip->curPath);
#line 387
  cp = ftwip->curPath + tmp___5;
#line 387
  endp = cp;
#line 388
  cp --;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if ((unsigned long )cp > (unsigned long )ftwip->curPath) {
#line 389
      if (! ((int )*cp == 47)) {
#line 389
        if (! ((int )*cp == 92)) {
#line 389
          goto while_break;
        }
      }
    } else {
#line 389
      goto while_break;
    }
#line 390
    tmp___6 = cp;
#line 390
    cp --;
#line 390
    *tmp___6 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  len = (size_t )(endp - ftwip->curPath);
#line 391
  tmp___7 = len;
#line 391
  ftwip->startPathLen = tmp___7;
#line 391
  ftwip->curPathLen = tmp___7;
  {
#line 392
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 392
    if (! ((unsigned long )cp >= (unsigned long )ftwip->curPath)) {
#line 392
      goto while_break___0;
    }
#line 393
    if ((int )*cp == 47) {
#line 394
      goto while_break___0;
    } else
#line 393
    if ((int )*cp == 92) {
#line 394
      goto while_break___0;
    }
#line 395
    cp --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 397
  cp ++;
#line 397
  ftwip->curFile = cp;
#line 398
  ftwip->curFileLen = (size_t )(endp - cp);
#line 399
  ftwip->proc = proc;
#line 400
  tmp___8 = (*proc)(ftwip);
  }
#line 400
  if (tmp___8 < 0) {
#line 401
    return (-1);
  }
  {
#line 404
  tmp___12 = (size_t )0;
#line 404
  ftwip->numLinks = tmp___12;
#line 404
  tmp___11 = tmp___12;
#line 404
  ftwip->numFiles = tmp___11;
#line 404
  tmp___10 = tmp___11;
#line 404
  ftwip->numDirs = tmp___10;
#line 404
  tmp___9 = tmp___10;
#line 404
  ftwip->maxDepth = tmp___9;
#line 404
  ftwip->depth = tmp___9;
#line 405
  rc = FTPFtwTraverse(ftwip, len, 1);
#line 408
  memset((void *)(ftwip->curPath + ftwip->startPathLen), 0, ftwip->curPathAllocSize - ftwip->startPathLen);
#line 409
  ftwip->curPathLen = ftwip->startPathLen;
#line 414
  memset((void *)(& ftwip->curStat), 0, sizeof(ftwip->curStat));
#line 415
  ftwip->proc = (int (*)(FtwInfoPtr const   ftwip ))0;
#line 416
  ftwip->curFile = ftwip->curPath;
#line 417
  ftwip->curFileLen = (size_t )0;
#line 418
  ftwip->cip = (void *)0;
#line 419
  ftwip->rlinkto = (char const   *)((void *)0);
  }
#line 421
  return (rc);
}
}
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.h"
void InitLsCache(void) ;
#line 21
void InitLsMonths(void) ;
#line 22
void InitLs(void) ;
#line 23
void FlushLsCache(void) ;
#line 24
int LsCacheLookup(char const   * const  itempath ) ;
#line 25
void LsDate(char *dstr , size_t dsiz , time_t ts ) ;
#line 26
void LsL(FTPFileInfoListPtr dirp , int endChars , int linkedTo , FILE *stream ) ;
#line 27
void Ls1(FTPFileInfoListPtr dirp , int endChars , FILE *stream ) ;
#line 28
void Ls(char const   * const  item , int listmode , char const   * const  options ,
        FILE *stream ) ;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
time_t gNowMinus6Mon  ;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
time_t gNowPlus1Hr  ;
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
char gLsMon[13][16]  ;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
LsCacheItem gLsCache[32]  ;
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
int gOldestLsCacheItem  ;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
int gLsCacheItemLifetime  =    900;
#line 35
int gServerUsesMSDOSPaths ;
#line 39 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void InitLsCache(void) 
{ 


  {
  {
#line 42
  memset((void *)(gLsCache), 0, sizeof(gLsCache));
#line 43
  gOldestLsCacheItem = 0;
  }
#line 44
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void InitLsMonths(void) 
{ 
  struct tm lt ;
  int i___0 ;

  {
  {
#line 56
  memset((void *)(gLsMon), 0, sizeof(gLsMon));
#line 57
  Localtime((time_t )0, (struct tm */* const  */)(& lt));
#line 58
  lt.tm_mday = 15;
#line 59
  lt.tm_hour = 12;
#line 60
  i___0 = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i___0 < 12)) {
#line 60
      goto while_break;
    }
    {
#line 61
    lt.tm_mon = i___0;
#line 62
    strftime((char */* __restrict  */)(gLsMon[i___0]), sizeof(gLsMon[i___0]) - 1UL,
             (char const   */* __restrict  */)"%b", (struct tm  const  */* __restrict  */)(& lt));
#line 60
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  strcpy((char */* __restrict  */)(gLsMon[i___0]), (char const   */* __restrict  */)"BUG");
  }
#line 65
  return;
}
}
#line 70 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void InitLs(void) 
{ 


  {
  {
#line 72
  InitLsCache();
#line 73
  InitLsMonths();
  }
#line 74
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
static void FlushLsCacheItem(int i___0 ) 
{ 


  {
  {
#line 83
  Trace((int const   )1, (char const   */* const  */)"flush ls cache item: %s\n",
        gLsCache[i___0].itempath);
  }
#line 84
  if ((unsigned long )gLsCache[i___0].itempath != (unsigned long )((void *)0)) {
    {
#line 85
    free((void *)gLsCache[i___0].itempath);
    }
  }
  {
#line 86
  gLsCache[i___0].itempath = (char *)((void *)0);
#line 87
  gLsCache[i___0].expiration = (time_t )0;
#line 88
  DisposeFileInfoListContents(& gLsCache[i___0].fil);
  }
#line 89
  return;
}
}
#line 95 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void FlushLsCache(void) 
{ 
  int i___0 ;

  {
#line 100
  i___0 = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i___0 < 32)) {
#line 100
      goto while_break;
    }
#line 101
    if (gLsCache[i___0].expiration != 0L) {
      {
#line 102
      FlushLsCacheItem(i___0);
      }
    }
#line 100
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 111 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
int LsCacheLookup(char const   * const  itempath ) 
{ 
  int i___0 ;
  int j ;
  time_t now ;
  int tmp ;

  {
  {
#line 117
  time(& now);
#line 118
  i___0 = 0;
#line 118
  j = gOldestLsCacheItem;
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i___0 < 32)) {
#line 118
      goto while_break;
    }
#line 119
    j --;
#line 119
    if (j < 0) {
#line 120
      j = 31;
    }
#line 121
    if (gLsCache[j].expiration != 0L) {
#line 121
      if ((unsigned long )gLsCache[j].itempath != (unsigned long )((void *)0)) {
        {
#line 122
        tmp = strcmp((char const   *)itempath, (char const   *)gLsCache[j].itempath);
        }
#line 122
        if (tmp == 0) {
#line 123
          if (now > gLsCache[j].expiration) {
            {
#line 125
            FlushLsCacheItem(j);
            }
#line 126
            return (-1);
          }
#line 128
          (gLsCache[j].hits) ++;
#line 129
          return (j);
        }
      }
    }
#line 118
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (-1);
}
}
#line 140 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
static void LsCacheAdd(char const   * const  itempath , FTPFileInfoListPtr files ) 
{ 
  char *cp ;
  int j ;

  {
#line 147
  if (files->nFileInfos == 0) {
#line 148
    return;
  }
  {
#line 150
  j = LsCacheLookup(itempath);
  }
#line 151
  if (j >= 0) {
    {
#line 156
    FlushLsCacheItem(j);
    }
  }
  {
#line 159
  cp = StrDup((char const   *)itempath);
  }
#line 160
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 161
    return;
  }
  {
#line 163
  j = gOldestLsCacheItem;
#line 164
  memcpy((void */* __restrict  */)(& gLsCache[j].fil), (void const   */* __restrict  */)files,
         sizeof(FTPFileInfoList ));
#line 165
  time(& gLsCache[j].expiration);
#line 166
  gLsCache[j].expiration += (time_t )gLsCacheItemLifetime;
#line 167
  gLsCache[j].hits = 0;
#line 168
  gLsCache[j].itempath = cp;
#line 169
  Trace((int const   )1, (char const   */* const  */)"ls cache add: %s\n", itempath);
#line 174
  gOldestLsCacheItem ++;
  }
#line 175
  if (gOldestLsCacheItem >= 32) {
#line 176
    gOldestLsCacheItem = 0;
  }
#line 177
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
static void LsC(FTPFileInfoListPtr dirp , int endChars , FILE *stream ) 
{ 
  char buf[400] ;
  char buf2[400] ;
  int ncol ;
  int nrow ;
  int i___0 ;
  int j ;
  int k ;
  int l ;
  int colw ;
  int n ;
  FTPFileInfoVec itemv ;
  FTPFileInfoPtr itemp ;
  char *cp1 ;
  char *cp2 ;
  char *lim ;
  int screenColumns ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 197
  screenColumns = gScreenColumns;
#line 198
  if (screenColumns > 400) {
#line 199
    screenColumns = 400;
  }
#line 200
  ncol = (screenColumns - 1) / (((int )dirp->maxFileLen + 2) + endChars);
#line 201
  if (ncol < 1) {
#line 202
    ncol = 1;
  }
#line 203
  colw = (screenColumns - 1) / ncol;
#line 204
  n = dirp->nFileInfos;
#line 205
  nrow = n / ncol;
#line 206
  if (n % ncol != 0) {
#line 207
    nrow ++;
  }
#line 209
  i___0 = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i___0 < (int )sizeof(buf2))) {
#line 209
      goto while_break;
    }
#line 210
    buf2[i___0] = (char )' ';
#line 209
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  itemv = dirp->vec;
#line 214
  j = 0;
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (! (j < nrow)) {
#line 214
      goto while_break___0;
    }
    {
#line 215
    memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(buf2),
           sizeof(buf));
#line 216
    i___0 = 0;
#line 216
    k = j;
#line 216
    l = 0;
    }
    {
#line 216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 216
      if (! (i___0 < ncol)) {
#line 216
        goto while_break___1;
      }
#line 217
      if (k >= n) {
#line 218
        goto __Cont;
      }
#line 219
      itemp = *(itemv + k);
#line 220
      cp1 = buf + l;
#line 221
      lim = cp1 + (int )itemp->relnameLen;
#line 222
      cp2 = itemp->relname;
      {
#line 223
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 223
        if (! ((unsigned long )cp1 < (unsigned long )lim)) {
#line 223
          goto while_break___2;
        }
#line 224
        tmp = cp1;
#line 224
        cp1 ++;
#line 224
        tmp___0 = cp2;
#line 224
        cp2 ++;
#line 224
        *tmp = *tmp___0;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 225
      if (endChars != 0) {
#line 226
        if (itemp->type == 108) {
#line 231
          tmp___1 = cp1;
#line 231
          cp1 ++;
#line 231
          *tmp___1 = (char )'@';
        } else
#line 232
        if (itemp->type == 100) {
#line 233
          tmp___2 = cp1;
#line 233
          cp1 ++;
#line 233
          *tmp___2 = (char )'/';
        }
      }
      __Cont: /* CIL Label */ 
#line 216
      i___0 ++;
#line 216
      k += nrow;
#line 216
      l += colw;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 237
    cp1 = buf;
#line 238
    cp1 += sizeof(buf) - 1UL;
    {
#line 239
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 239
      cp1 --;
#line 239
      if (! ((int )*cp1 == 32)) {
#line 239
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 240
    cp1 ++;
#line 241
    tmp___3 = cp1;
#line 241
    cp1 ++;
#line 241
    *tmp___3 = (char )'\n';
#line 242
    *cp1 = (char )'\000';
#line 243
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
            buf);
#line 244
    Trace((int const   )0, (char const   */* const  */)"%s", buf);
#line 214
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 253 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void LsDate(char *dstr , size_t dsiz , time_t ts ) 
{ 
  struct tm t ;
  struct tm *tmp ;

  {
#line 258
  if (ts == -1L) {
    {
#line 259
    Strncpy((char */* const  */)dstr, (char const   */* const  */)"            ",
            (size_t const   )dsiz);
    }
#line 260
    return;
  }
  {
#line 262
  tmp = Localtime(ts, (struct tm */* const  */)(& t));
  }
#line 262
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 263
    Strncpy((char */* const  */)dstr, (char const   */* const  */)"Jan  0  1900",
            (size_t const   )dsiz);
    }
#line 264
    return;
  }
#line 266
  if (ts > gNowPlus1Hr) {
    {
#line 268
    snprintf((char */* __restrict  */)dstr, dsiz, (char const   */* __restrict  */)"%s %2d  %4d",
             gLsMon[t.tm_mon], t.tm_mday, t.tm_year + 1900);
    }
  } else
#line 266
  if (ts < gNowMinus6Mon) {
    {
#line 268
    snprintf((char */* __restrict  */)dstr, dsiz, (char const   */* __restrict  */)"%s %2d  %4d",
             gLsMon[t.tm_mon], t.tm_mday, t.tm_year + 1900);
    }
  } else {
    {
#line 279
    snprintf((char */* __restrict  */)dstr, dsiz, (char const   */* __restrict  */)"%s %2d %02d:%02d",
             gLsMon[t.tm_mon], t.tm_mday, t.tm_hour, t.tm_min);
    }
  }
#line 290
  return;
}
}
#line 296 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void LsL(FTPFileInfoListPtr dirp , int endChars , int linkedTo , FILE *stream ) 
{ 
  FTPFileInfoPtr diritemp ;
  FTPFileInfoVec diritemv___0 ;
  int i___0 ;
  char fTail[2] ;
  int fType ;
  char const   *l1 ;
  char const   *l2 ;
  char datestr[32] ;
  char sizestr[32] ;
  char plugspec[16] ;
  char plugstr[64] ;
  char const   *expad ;

  {
  {
#line 311
  fTail[0] = (char )'\000';
#line 312
  fTail[1] = (char )'\000';
#line 314
  time(& gNowPlus1Hr);
#line 315
  gNowMinus6Mon = gNowPlus1Hr - 15552000L;
#line 316
  gNowPlus1Hr += 3600L;
#line 318
  diritemv___0 = dirp->vec;
#line 320
  snprintf((char */* __restrict  */)(plugspec), sizeof(plugspec) - 1UL, (char const   */* __restrict  */)"%%-%ds",
           (int )dirp->maxPlugLen);
  }
#line 331
  if (dirp->maxPlugLen < 29UL) {
#line 335
    expad = "  ";
  } else {
#line 337
    expad = "";
  }
#line 340
  i___0 = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    diritemp = *(diritemv___0 + i___0);
#line 342
    if ((unsigned long )diritemp == (unsigned long )((void *)0)) {
#line 343
      goto while_break;
    }
#line 345
    fType = diritemp->type;
#line 346
    if (endChars != 0) {
#line 347
      if (fType == 100) {
#line 348
        fTail[0] = (char )'/';
      } else {
#line 350
        fTail[0] = (char )'\000';
      }
    }
#line 353
    if ((unsigned long )diritemp->rlinkto != (unsigned long )((void *)0)) {
#line 354
      if (linkedTo != 0) {
#line 355
        l1 = "";
#line 356
        l2 = "";
      } else {
#line 358
        l1 = " -> ";
#line 359
        l2 = (char const   *)diritemp->rlinkto;
      }
    } else {
#line 362
      l1 = "";
#line 363
      l2 = "";
    }
    {
#line 366
    LsDate(datestr, sizeof(datestr), diritemp->mdtm);
    }
#line 368
    if (diritemp->size == -1LL) {
#line 369
      sizestr[0] = (char )'\000';
    } else {
      {
#line 372
      snprintf((char */* __restrict  */)(sizestr), sizeof(sizestr) - 1UL, (char const   */* __restrict  */)"%lld",
               diritemp->size);
      }
    }
    {
#line 389
    snprintf((char */* __restrict  */)(plugstr), sizeof(plugstr) - 1UL, (char const   */* __restrict  */)(plugspec),
             diritemp->plug);
#line 400
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %12s %s%s %s%s%s%s%s\n",
            plugstr, sizestr, expad, datestr, expad, diritemp->relname, l1, l2, fTail);
#line 411
    Trace((int const   )0, (char const   */* const  */)"%s %12s %s%s %s%s%s%s%s\n",
          plugstr, sizestr, expad, datestr, expad, diritemp->relname, l1, l2, fTail);
#line 340
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return;
}
}
#line 431 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void Ls1(FTPFileInfoListPtr dirp , int endChars , FILE *stream ) 
{ 
  char fTail[2] ;
  int i___0 ;
  int fType ;
  FTPFileInfoVec diritemv___0 ;
  FTPFileInfoPtr diritemp ;

  {
#line 440
  fTail[0] = (char )'\000';
#line 441
  fTail[1] = (char )'\000';
#line 442
  diritemv___0 = dirp->vec;
#line 444
  i___0 = 0;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    diritemp = *(diritemv___0 + i___0);
#line 446
    if ((unsigned long )diritemp == (unsigned long )((void *)0)) {
#line 447
      goto while_break;
    }
#line 449
    fType = diritemp->type;
#line 450
    if (endChars != 0) {
#line 451
      if (fType == 100) {
#line 452
        fTail[0] = (char )'/';
      } else {
#line 454
        fTail[0] = (char )'\000';
      }
    }
    {
#line 457
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s%s\n",
            diritemp->relname, fTail);
#line 462
    Trace((int const   )0, (char const   */* const  */)"%s%s\n", diritemp->relname,
          fTail);
#line 444
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  return;
}
}
#line 477 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/ls.c"
void Ls(char const   * const  item , int listmode , char const   * const  options ,
        FILE *stream ) 
{ 
  char itempath[512] ;
  FTPFileInfoList fil ;
  FTPFileInfoListPtr filp ;
  FTPLinePtr linePtr ;
  FTPLinePtr nextLinePtr ;
  FTPLineList dirContents ;
  int parsed ;
  int linkedTo ;
  int endChars ;
  int rlisted ;
  int opt ;
  char const   *cp ;
  int sortBy ;
  int sortOrder ;
  int unknownOpts ;
  char optstr[32] ;
  char unoptstr[32] ;
  int doNotUseCache ;
  int wasInCache ;
  int mlsd ;
  int ci ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 501
  InitLineList(& dirContents);
#line 502
  InitFileInfoList(& fil);
#line 504
  sortBy = 'n';
#line 505
  sortOrder = 'a';
#line 506
  linkedTo = 0;
  }
#line 507
  if (listmode == 67) {
#line 507
    endChars = 1;
  } else {
#line 507
    endChars = 0;
  }
  {
#line 508
  unknownOpts = 0;
#line 509
  memset((void *)(unoptstr), 0, sizeof(unoptstr));
#line 510
  unoptstr[0] = (char )'-';
#line 511
  doNotUseCache = 0;
#line 512
  rlisted = 0;
#line 514
  cp = (char const   *)options;
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! ((int const   )*cp != 0)) {
#line 514
      goto while_break;
    }
#line 515
    opt = (int )*cp;
    {
#line 517
    if (opt == 116) {
#line 517
      goto case_116;
    }
#line 520
    if (opt == 83) {
#line 520
      goto case_83;
    }
#line 523
    if (opt == 114) {
#line 523
      goto case_114;
    }
#line 526
    if (opt == 76) {
#line 526
      goto case_76;
    }
#line 529
    if (opt == 102) {
#line 529
      goto case_102;
    }
#line 533
    if (opt == 112) {
#line 533
      goto case_112;
    }
#line 533
    if (opt == 70) {
#line 533
      goto case_112;
    }
#line 538
    if (opt == 108) {
#line 538
      goto case_108;
    }
#line 538
    if (opt == 67) {
#line 538
      goto case_108;
    }
#line 538
    if (opt == 49) {
#line 538
      goto case_108;
    }
#line 541
    if (opt == 45) {
#line 541
      goto case_45;
    }
#line 543
    goto switch_default;
    case_116: /* CIL Label */ 
#line 518
    sortBy = 't';
#line 519
    goto switch_break;
    case_83: /* CIL Label */ 
#line 521
    sortBy = 's';
#line 522
    goto switch_break;
    case_114: /* CIL Label */ 
#line 524
    sortOrder = 'd';
#line 525
    goto switch_break;
    case_76: /* CIL Label */ 
#line 527
    linkedTo = 1;
#line 528
    goto switch_break;
    case_102: /* CIL Label */ 
#line 530
    doNotUseCache = 1;
#line 531
    goto switch_break;
    case_112: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 534
    endChars = 1;
#line 535
    goto switch_break;
    case_108: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 539
    listmode = opt;
#line 540
    goto switch_break;
    case_45: /* CIL Label */ 
#line 542
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 544
    if (unknownOpts < (int )sizeof(unoptstr) - 2) {
#line 545
      unoptstr[unknownOpts + 1] = (char )opt;
    }
#line 546
    unknownOpts ++;
#line 547
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 514
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 552
    tmp = (char const   */* const  */)".";
  } else {
#line 552
    tmp = item;
  }
  {
#line 552
  PathCat((char */* const  */)(itempath), (size_t const   )sizeof(itempath), (char const   */* const  */)(gRemoteCWD),
          tmp, gServerUsesMSDOSPaths);
  }
#line 555
  if (unknownOpts > 0) {
    {
#line 560
    Trace((int const   )0, (char const   */* const  */)"ls caching not used because of ls flags: %s\n",
          unoptstr);
#line 561
    optstr[0] = (char )'-';
#line 562
    optstr[1] = (char )listmode;
#line 563
    optstr[2] = (char )'\000';
#line 564
    Strncat((char */* const  */)(optstr), options, (size_t const   )sizeof(optstr));
    }
#line 565
    if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 565
      tmp___0 = (char const   */* const  */)"";
    } else {
#line 565
      tmp___0 = item;
    }
    {
#line 565
    tmp___1 = FTPListToMemory2((FTPCIPtr const   )(& gConn), tmp___0, (FTPLineListPtr const   )(& dirContents),
                               (char const   */* const  */)(optstr), (int const   )1,
                               (int */* const  */)0);
    }
#line 565
    if (tmp___1 < 0) {
#line 566
      if ((unsigned long )stream != (unsigned long )((void *)0)) {
        {
#line 567
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"List failed.\n");
        }
      }
#line 568
      return;
    }
#line 571
    rlisted = 1;
#line 572
    parsed = -1;
#line 573
    wasInCache = 0;
#line 574
    filp = (FTPFileInfoListPtr )((void *)0);
  } else
#line 575
  if (doNotUseCache != 0) {
#line 575
    goto _L;
  } else {
    {
#line 575
    ci = LsCacheLookup((char const   */* const  */)(itempath));
    }
#line 575
    if (ci < 0) {
      _L: /* CIL Label */ 
#line 577
      wasInCache = 0;
#line 579
      mlsd = 1;
#line 580
      if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 580
        tmp___2 = (char const   */* const  */)"";
      } else {
#line 580
        tmp___2 = item;
      }
      {
#line 580
      tmp___3 = FTPListToMemory2((FTPCIPtr const   )(& gConn), tmp___2, (FTPLineListPtr const   )(& dirContents),
                                 (char const   */* const  */)"-l", (int const   )1,
                                 (int */* const  */)(& mlsd));
      }
#line 580
      if (tmp___3 < 0) {
#line 581
        if ((unsigned long )stream != (unsigned long )((void *)0)) {
          {
#line 582
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"List failed.\n");
          }
        }
#line 583
        return;
      }
#line 586
      rlisted = 1;
#line 587
      filp = & fil;
#line 588
      if (mlsd != 0) {
        {
#line 589
        parsed = UnMlsD((FTPCIPtr const   )(& gConn), filp, & dirContents);
        }
#line 590
        if (parsed < 0) {
          {
#line 591
          Trace((int const   )0, (char const   */* const  */)"UnMlsD: %d\n", parsed);
          }
        }
      } else {
        {
#line 594
        parsed = UnLslR((FTPCIPtr const   )(& gConn), filp, & dirContents, gConn.serverType);
        }
#line 595
        if (parsed < 0) {
          {
#line 596
          Trace((int const   )0, (char const   */* const  */)"UnLslR: %d\n", parsed);
          }
        }
      }
#line 599
      if (parsed >= 0) {
        {
#line 600
        VectorizeFileInfoList(filp);
        }
#line 601
        if ((unsigned long )filp->vec == (unsigned long )((void *)0)) {
#line 602
          if ((unsigned long )stream != (unsigned long )((void *)0)) {
            {
#line 603
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"List processing failed.\n");
            }
          }
#line 604
          return;
        }
      }
    } else {
      {
#line 608
      filp = & gLsCache[ci].fil;
#line 609
      wasInCache = 1;
#line 610
      parsed = 1;
#line 611
      Trace((int const   )0, (char const   */* const  */)"ls cache hit: %s\n", itempath);
      }
    }
  }
#line 614
  if (rlisted != 0) {
    {
#line 615
    Trace((int const   )0, (char const   */* const  */)"Remote listing contents {\n");
#line 616
    linePtr = dirContents.first;
    }
    {
#line 616
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 616
      if (! ((unsigned long )linePtr != (unsigned long )((void *)0))) {
#line 616
        goto while_break___0;
      }
      {
#line 620
      nextLinePtr = linePtr->next;
#line 621
      Trace((int const   )0, (char const   */* const  */)"    %s\n", linePtr->line);
#line 616
      linePtr = nextLinePtr;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 623
    Trace((int const   )0, (char const   */* const  */)"}\n");
    }
  }
#line 626
  if (parsed >= 0) {
    {
#line 627
    SortFileInfoList(filp, sortBy, sortOrder);
    }
#line 628
    if ((unsigned long )stream != (unsigned long )((void *)0)) {
#line 629
      if (listmode == 108) {
        {
#line 630
        LsL(filp, endChars, linkedTo, stream);
        }
      } else
#line 631
      if (listmode == 49) {
        {
#line 632
        Ls1(filp, endChars, stream);
        }
      } else {
        {
#line 634
        LsC(filp, endChars, stream);
        }
      }
    }
#line 636
    if (wasInCache == 0) {
      {
#line 637
      LsCacheAdd((char const   */* const  */)(itempath), filp);
      }
    }
  } else
#line 639
  if ((unsigned long )stream != (unsigned long )((void *)0)) {
#line 640
    linePtr = dirContents.first;
    {
#line 640
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 640
      if (! ((unsigned long )linePtr != (unsigned long )((void *)0))) {
#line 640
        goto while_break___1;
      }
      {
#line 644
      nextLinePtr = linePtr->next;
#line 645
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n",
              linePtr->line);
#line 646
      Trace((int const   )0, (char const   */* const  */)"    %s\n", linePtr->line);
#line 640
      linePtr = nextLinePtr;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 650
  DisposeLineListContents(& dirContents);
  }
#line 651
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/bookmark.c"
static int HexCharToNibble___2(int c ) 
{ 


  {
  {
#line 109
  if (c == 57) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 56) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 55) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 54) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 53) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 52) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 51) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 50) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 49) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 48) {
#line 109
    goto case_57;
  }
#line 116
  if (c == 102) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 101) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 100) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 99) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 98) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 97) {
#line 116
    goto case_102;
  }
#line 123
  if (c == 70) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 69) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 68) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 67) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 66) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 65) {
#line 123
    goto case_70;
  }
#line 99
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 110
  return (c - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 117
  return ((c - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 124
  return ((c - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
#line 127
  return (-1);
}
}
#line 495 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/bookmark.c"
static int BookmarkSortProc___2(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = strcasecmp((char const   *)(((Bookmark const   *)a)->bookmarkName), (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 498
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/bookmark.c"
static int BookmarkSearchProc___2(void const   *key , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = strcasecmp((char const   *)key, (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 506
  return (tmp);
}
}
#line 578 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/bookmark.c"
static char *BmEscapeTok___2(char *dst , size_t dsize , char *src ) 
{ 
  char *dlim ;
  char *dst0 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 581
  dlim = (dst + dsize) - 1;
#line 582
  dst0 = dst;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    c = (int )*src;
#line 585
    if (! (c != 0)) {
#line 585
      goto while_break;
    }
#line 586
    src ++;
#line 587
    if (c == 92) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 44) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 36) {
      _L: /* CIL Label */ 
#line 589
      if ((unsigned long )(dst + 1) < (unsigned long )dlim) {
#line 590
        tmp = dst;
#line 590
        dst ++;
#line 590
        *tmp = (char )'\\';
#line 591
        tmp___0 = dst;
#line 591
        dst ++;
#line 591
        *tmp___0 = (char )c;
      }
    } else {
      {
#line 593
      tmp___2 = __ctype_b_loc();
      }
#line 593
      if ((int const   )*(*tmp___2 + c) & 16384) {
#line 600
        if ((unsigned long )dst < (unsigned long )dlim) {
#line 601
          tmp___1 = dst;
#line 601
          dst ++;
#line 601
          *tmp___1 = (char )c;
        }
      } else
#line 595
      if ((unsigned long )(dst + 2) < (unsigned long )dlim) {
        {
#line 596
        sprintf((char */* __restrict  */)dst, (char const   */* __restrict  */)"$%02x",
                c);
#line 597
        dst += 3;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *dst = (char )'\000';
#line 605
  return (dst0);
}
}
#line 614 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/bookmark.c"
static int WriteBmLine___2(Bookmark *bmp , FILE *outfp , int savePassword ) 
{ 
  char tok[256] ;
  char pass[160] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 620
  tmp = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s",
                bmp->bookmarkName);
  }
#line 620
  if (tmp < 0) {
#line 620
    return (-1);
  }
  {
#line 621
  tmp___0 = BmEscapeTok___2(tok, sizeof(tok), bmp->name);
#line 621
  tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___0);
  }
#line 621
  if (tmp___1 < 0) {
#line 621
    return (-1);
  }
  {
#line 622
  tmp___2 = BmEscapeTok___2(tok, sizeof(tok), bmp->user);
#line 622
  tmp___3 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___2);
  }
#line 622
  if (tmp___3 < 0) {
#line 622
    return (-1);
  }
#line 623
  if ((int )bmp->pass[0] != 0) {
#line 623
    if (savePassword == 1) {
      {
#line 624
      memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
             (size_t )9);
#line 625
      tmp___4 = strlen((char const   *)(bmp->pass));
#line 625
      ToBase64((void *)(pass + 9), (void const   *)(bmp->pass), tmp___4, 1);
#line 626
      tmp___5 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                        pass);
      }
#line 626
      if (tmp___5 < 0) {
#line 626
        return (-1);
      }
    } else {
#line 623
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 628
    tmp___6 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                      "");
    }
#line 628
    if (tmp___6 < 0) {
#line 628
      return (-1);
    }
  }
  {
#line 630
  tmp___7 = BmEscapeTok___2(tok, sizeof(tok), bmp->acct);
#line 630
  tmp___8 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___7);
  }
#line 630
  if (tmp___8 < 0) {
#line 630
    return (-1);
  }
  {
#line 631
  tmp___9 = BmEscapeTok___2(tok, sizeof(tok), bmp->dir);
#line 631
  tmp___10 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___9);
  }
#line 631
  if (tmp___10 < 0) {
#line 631
    return (-1);
  }
  {
#line 632
  tmp___11 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferType);
  }
#line 632
  if (tmp___11 < 0) {
#line 632
    return (-1);
  }
  {
#line 633
  tmp___12 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%u",
                     bmp->port);
  }
#line 633
  if (tmp___12 < 0) {
#line 633
    return (-1);
  }
  {
#line 634
  tmp___13 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%lu",
                     (unsigned long )bmp->lastCall);
  }
#line 634
  if (tmp___13 < 0) {
#line 634
    return (-1);
  }
  {
#line 635
  tmp___14 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasSIZE);
  }
#line 635
  if (tmp___14 < 0) {
#line 635
    return (-1);
  }
  {
#line 636
  tmp___15 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasMDTM);
  }
#line 636
  if (tmp___15 < 0) {
#line 636
    return (-1);
  }
  {
#line 637
  tmp___16 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasPASV);
  }
#line 637
  if (tmp___16 < 0) {
#line 637
    return (-1);
  }
  {
#line 638
  tmp___17 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->isUnix);
  }
#line 638
  if (tmp___17 < 0) {
#line 638
    return (-1);
  }
  {
#line 639
  tmp___18 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     bmp->lastIP);
  }
#line 639
  if (tmp___18 < 0) {
#line 639
    return (-1);
  }
  {
#line 640
  tmp___19 = BmEscapeTok___2(tok, sizeof(tok), bmp->comment);
#line 640
  tmp___20 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___19);
  }
#line 640
  if (tmp___20 < 0) {
#line 640
    return (-1);
  }
  {
#line 641
  tmp___21 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 641
  if (tmp___21 < 0) {
#line 641
    return (-1);
  }
  {
#line 642
  tmp___22 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 642
  if (tmp___22 < 0) {
#line 642
    return (-1);
  }
  {
#line 643
  tmp___23 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 643
  if (tmp___23 < 0) {
#line 643
    return (-1);
  }
  {
#line 644
  tmp___24 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 644
  if (tmp___24 < 0) {
#line 644
    return (-1);
  }
  {
#line 645
  tmp___25 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferMode);
  }
#line 645
  if (tmp___25 < 0) {
#line 645
    return (-1);
  }
  {
#line 646
  tmp___26 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasUTIME);
  }
#line 646
  if (tmp___26 < 0) {
#line 646
    return (-1);
  }
  {
#line 647
  tmp___27 = BmEscapeTok___2(tok, sizeof(tok), bmp->ldir);
#line 647
  tmp___28 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___27);
  }
#line 647
  if (tmp___28 < 0) {
#line 647
    return (-1);
  }
  {
#line 648
  tmp___29 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n");
  }
#line 648
  if (tmp___29 < 0) {
#line 648
    return (-1);
  }
  {
#line 649
  tmp___30 = fflush(outfp);
  }
#line 649
  if (tmp___30 < 0) {
#line 649
    return (-1);
  }
#line 650
  return (0);
}
}
#line 655 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/bookmark.c"
static int SwapBookmarkFiles___2(void) 
{ 
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 661
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 662
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 666
  tmp = getpid();
#line 666
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 667
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 669
  remove((char const   *)(path2));
#line 670
  tmp___0 = rename((char const   *)(pathName), (char const   *)(path2));
  }
#line 670
  if (tmp___0 < 0) {
#line 671
    return (-1);
  }
#line 673
  return (0);
}
}
#line 241 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
void SelectSetInit(SelectSetPtr const   ssp , double const   timeout ) ;
#line 242
void SelectSetAdd(SelectSetPtr const   ssp , int const   fd ) ;
#line 243
void SelectSetRemove(SelectSetPtr const   ssp , int const   fd ) ;
#line 244
int SelectW(SelectSetPtr ssp , SelectSetPtr resultssp ) ;
#line 245
int SelectR(SelectSetPtr ssp , SelectSetPtr resultssp ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSelect.c"
void SelectSetInit(SelectSetPtr const   ssp , double const   timeout ) 
{ 
  double i___0 ;
  long long l ;

  {
  {
#line 15
  memset((void *)ssp, 0, sizeof(SelectSet ));
#line 16
  l = (long long )timeout;
#line 17
  i___0 = (double )l;
#line 18
  ssp->timeout.tv_sec = (__time_t )l;
#line 19
  ssp->timeout.tv_usec = (__suseconds_t )((long long )((timeout - (double const   )i___0) * (double const   )1000000.0));
  }
#line 20
  return;
}
}
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSelect.c"
void SelectSetAdd(SelectSetPtr const   ssp , int const   fd ) 
{ 


  {
#line 28
  if (fd >= 0) {
#line 33
    ssp->fds.__fds_bits[fd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 37
    if (ssp->maxfd < (int )(fd + 1)) {
#line 38
      ssp->maxfd = (int )(fd + 1);
    }
#line 39
    (ssp->numfds) ++;
  }
#line 41
  return;
}
}
#line 46 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSelect.c"
void SelectSetRemove(SelectSetPtr const   ssp , int const   fd ) 
{ 


  {
#line 53
  if (fd >= 0) {
#line 53
    if ((ssp->fds.__fds_bits[fd / (int const   )(8 * (int )sizeof(__fd_mask ))] & (1L << fd % (int const   )(8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 54
      ssp->fds.__fds_bits[fd / (int const   )(8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (int const   )(8 * (int )sizeof(__fd_mask )));
#line 58
      (ssp->numfds) --;
    }
  }
#line 63
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSelect.c"
int SelectW(SelectSetPtr ssp , SelectSetPtr resultssp ) 
{ 
  int rc ;
  int *tmp ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 73
    memcpy((void */* __restrict  */)resultssp, (void const   */* __restrict  */)ssp,
           sizeof(SelectSet ));
#line 74
    rc = select(resultssp->maxfd, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& resultssp->fds),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& resultssp->timeout));
    }
#line 72
    if (rc < 0) {
      {
#line 72
      tmp = __errno_location();
      }
#line 72
      if (! (*tmp == 4)) {
#line 72
        goto while_break;
      }
    } else {
#line 72
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (rc);
}
}
#line 81 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSelect.c"
int SelectR(SelectSetPtr ssp , SelectSetPtr resultssp ) 
{ 
  int rc ;
  int *tmp ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    memcpy((void */* __restrict  */)resultssp, (void const   */* __restrict  */)ssp,
           sizeof(SelectSet ));
#line 88
    rc = select(resultssp->maxfd, (fd_set */* __restrict  */)(& resultssp->fds), (fd_set */* __restrict  */)((void *)0),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& resultssp->timeout));
    }
#line 86
    if (rc < 0) {
      {
#line 86
      tmp = __errno_location();
      }
#line 86
      if (! (*tmp == 4)) {
#line 86
        goto while_break;
      }
    } else {
#line 86
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return (rc);
}
}
#line 945 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void GetoptReset(GetoptInfo * const  opt ) ;
#line 946
int Getopt(GetoptInfo * const  opt , int nargc , char ** const  nargv , char const   * const  ostr ) ;
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getopt.c"
void GetoptReset(GetoptInfo * const  opt ) 
{ 


  {
  {
#line 17
  memset((void *)opt, 0, sizeof(GetoptInfo ));
#line 18
  opt->ind = 1;
#line 19
  opt->init = 4045620591U;
  }
#line 20
  return;
}
}
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getopt.c"
int Getopt(GetoptInfo * const  opt , int nargc , char ** const  nargv , char const   * const  ostr ) 
{ 
  char const   *oli ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 28
  if ((unsigned long )opt == (unsigned long )((void *)0)) {
#line 29
    return (-1);
  } else
#line 28
  if (nargc == 0) {
#line 29
    return (-1);
  } else
#line 28
  if ((unsigned long )nargv == (unsigned long )((char **)0)) {
#line 29
    return (-1);
  } else
#line 28
  if ((unsigned long )ostr == (unsigned long )((void *)0)) {
#line 29
    return (-1);
  }
#line 31
  if (opt->init != 4045620591U) {
    {
#line 33
    GetoptReset(opt);
    }
  }
#line 36
  if ((unsigned long )opt->place == (unsigned long )((void *)0)) {
#line 36
    goto _L;
  } else
#line 36
  if ((int )*(opt->place + 0) == 0) {
    _L: /* CIL Label */ 
#line 38
    if (opt->ind >= nargc) {
#line 39
      return (-1);
    } else {
#line 38
      tmp = *(nargv + opt->ind);
#line 38
      opt->place = tmp;
#line 38
      if ((int )*tmp != 45) {
#line 39
        return (-1);
      }
    }
#line 40
    if (*(opt->place + 1)) {
#line 40
      (opt->place) ++;
#line 40
      if ((int )*(opt->place) == 45) {
#line 41
        (opt->ind) ++;
#line 42
        return (-1);
      }
    }
  }
#line 46
  if ((unsigned long )opt->place == (unsigned long )((void *)0)) {
#line 47
    oli = (char const   *)((void *)0);
  } else {
#line 48
    tmp___2 = opt->place;
#line 48
    (opt->place) ++;
#line 48
    tmp___1 = (int )*tmp___2;
#line 48
    opt->opt = tmp___1;
#line 48
    if (tmp___1 == 58) {
#line 49
      oli = (char const   *)((void *)0);
    } else {
      {
#line 51
      tmp___0 = strchr((char const   *)ostr, opt->opt);
#line 51
      oli = (char const   *)tmp___0;
      }
    }
  }
#line 53
  if ((unsigned long )oli == (unsigned long )((void *)0)) {
#line 54
    if ((unsigned long )opt->place == (unsigned long )((void *)0)) {
#line 55
      (opt->ind) ++;
    } else
#line 54
    if ((int )*(opt->place + 0) == 0) {
#line 55
      (opt->ind) ++;
    }
#line 56
    if (opt->err) {
      {
#line 57
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s%c\n",
              *nargv, ": illegal option -- ", opt->opt);
      }
    }
#line 58
    return ('?');
  }
#line 60
  oli ++;
#line 60
  if ((int const   )*oli != 58) {
#line 61
    opt->arg = (char *)((void *)0);
#line 62
    if ((unsigned long )opt->place == (unsigned long )((void *)0)) {
#line 63
      (opt->ind) ++;
    } else
#line 62
    if ((int )*(opt->place + 0) == 0) {
#line 63
      (opt->ind) ++;
    }
  } else {
#line 65
    if ((unsigned long )opt->place != (unsigned long )((void *)0)) {
#line 65
      if ((int )*(opt->place + 0) != 0) {
#line 66
        opt->arg = opt->place;
      } else {
#line 65
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 67
      (opt->ind) ++;
#line 67
      if (nargc <= opt->ind) {
#line 68
        opt->place = (char *)((void *)0);
#line 69
        if (opt->err) {
          {
#line 70
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s%s%c\n",
                  *nargv, ": option requires an argument -- ", opt->opt);
          }
        }
#line 71
        return ('?');
      } else {
#line 73
        opt->arg = *(nargv + opt->ind);
      }
    }
#line 74
    opt->place = (char *)((void *)0);
#line 75
    (opt->ind) ++;
  }
#line 77
  return (opt->opt);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 160 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
char const   *gLibSio_Uses_Me_To_Quiet_Variable_Unused_Warnings ;
#line 294
void SIOPipeSignalIsBeingIgnoredGloballyByApplication(int value ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
char const   *gLibSio_Uses_Me_To_Quiet_Variable_Unused_Warnings  =    (char const   *)((void *)0);
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
int sio_sigpipe_ignored_already  =    0;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
void SIOPipeSignalIsBeingIgnoredGloballyByApplication(int value ) 
{ 


  {
#line 16
  sio_sigpipe_ignored_already = value;
#line 17
  return;
}
}
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
sigjmp_buf gNetTimeoutJmp  ;
#line 28 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
sigjmp_buf gPipeJmp  ;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
void SIOHandler(int sigNum ) 
{ 


  {
#line 34
  if (sigNum == 13) {
    {
#line 35
    siglongjmp((struct __jmp_buf_tag *)(gPipeJmp), 1);
    }
  }
  {
#line 36
  siglongjmp((struct __jmp_buf_tag *)(gNetTimeoutJmp), 1);
  }
}
}
#line 42 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/main.c"
void (*SSignal(int signum , void (*handler)(int  ) ))(int  ) 
{ 
  struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;

  {
  {
#line 47
  sigemptyset(& sa.sa_mask);
#line 48
  sa.sa_flags = 0;
#line 49
  sa.__sigaction_handler.sa_handler = handler;
  }
#line 50
  if (signum == 14) {
#line 52
    sa.sa_flags |= 536870912;
  } else {
#line 56
    sa.sa_flags |= 268435456;
  }
  {
#line 59
  tmp = sigaction(signum, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)(& osa));
  }
#line 59
  if (tmp < 0) {
#line 60
    return ((void (*)(int  ))-1);
  }
#line 61
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 918 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPRmdir(FTPCIPtr const   cip , char const   * const  pattern , int const   recurse ,
             int const   doGlob ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_rmdir.c"
int FTPRmdir(FTPCIPtr const   cip , char const   * const  pattern , int const   recurse ,
             int const   doGlob ) 
{ 
  FTPLineList fileList ;
  FTPLinePtr filePtr ;
  char *file ;
  int onceResult ;
  int batchResult ;
  int tmp ;

  {
#line 21
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 22
    return (-139);
  }
  {
#line 23
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 23
  if (tmp) {
#line 24
    return (-138);
  }
  {
#line 26
  batchResult = FTPRemoteGlob((FTPCIPtr )cip, & fileList, (char const   *)pattern,
                              (int )doGlob);
  }
#line 27
  if (batchResult != 0) {
#line 28
    return (batchResult);
  }
#line 30
  batchResult = 0;
#line 30
  filePtr = fileList.first;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 30
      goto while_break;
    }
#line 34
    file = filePtr->line;
#line 35
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 36
      batchResult = -127;
#line 37
      cip->errNo = -127;
#line 38
      goto while_break;
    }
    {
#line 40
    onceResult = FTPCmd(cip, (char const   */* const  */)"RMD %s", file);
    }
#line 41
    if (onceResult < 0) {
#line 42
      batchResult = onceResult;
#line 43
      goto while_break;
    }
#line 45
    if (onceResult != 2) {
#line 46
      if (recurse == 1) {
        {
#line 47
        onceResult = FTPRmdirRecursive(cip, (char const   */* const  */)file);
        }
#line 48
        if (onceResult < 0) {
#line 49
          batchResult = -126;
#line 50
          cip->errNo = -126;
        }
      } else {
#line 53
        batchResult = -126;
#line 54
        cip->errNo = -126;
      }
    }
#line 30
    filePtr = filePtr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  DisposeLineListContents(& fileList);
  }
#line 59
  return (batchResult);
}
}
#line 1078 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int IsValidUNCPath(char const   * const  src ) ;
#line 1079
void CompressPath(char * const  dst , char const   * const  src , size_t const   dsize ,
                  int dosCompat ) ;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_pathcat.c"
int IsValidUNCPath(char const   * const  src ) 
{ 
  char const   *a ;
  char const   *b ;
  int c ;
  int n ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 29
  if ((int const   )*(src + 0) == 92) {
#line 29
    if ((int const   )*(src + 1) == 92) {
      {
#line 29
      tmp___5 = __ctype_b_loc();
      }
#line 29
      if ((int const   )*(*tmp___5 + (int )*(src + 2)) & 1024) {
#line 30
        a = (char const   *)(src + 3);
        {
#line 30
        while (1) {
          while_continue: /* CIL Label */ ;
#line 31
          tmp = a;
#line 31
          a ++;
#line 31
          c = (int )*tmp;
#line 32
          if (c == 92) {
#line 33
            goto while_break;
          }
          {
#line 34
          tmp___0 = __ctype_b_loc();
          }
#line 34
          if (! ((int const   )*(*tmp___0 + c) & 8)) {
#line 34
            if (c != 95) {
#line 35
              return (0);
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 37
        b = a;
#line 38
        tmp___1 = b;
#line 38
        b ++;
#line 38
        c = (int )*tmp___1;
#line 39
        tmp___2 = __ctype_b_loc();
        }
#line 39
        if (! ((int const   )*(*tmp___2 + c) & 1024)) {
#line 40
          return (0);
        }
        {
#line 41
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 42
          tmp___3 = b;
#line 42
          b ++;
#line 42
          c = (int )*tmp___3;
#line 43
          if (c == 92) {
#line 44
            goto while_break___0;
          } else
#line 43
          if (c == 0) {
#line 44
            goto while_break___0;
          }
          {
#line 45
          tmp___4 = __ctype_b_loc();
          }
#line 45
          if (! ((int const   )*(*tmp___4 + c) & 8)) {
#line 45
            if (c != 95) {
#line 46
              return (0);
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 48
        n = (int )(b - (char const   *)src);
#line 49
        return (n);
      }
    }
  }
#line 51
  return (0);
}
}
#line 56 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_pathcat.c"
void CompressPath(char * const  dst , char const   * const  src , size_t const   dsize ,
                  int dosCompat ) 
{ 
  int c ;
  char const   *s ;
  char const   *start ;
  char const   *dotp ;
  char *d ;
  char *lim ;
  char *dstart ;
  char *a ;
  char *b ;
  char slash ;
  size_t n ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;

  {
#line 63
  slash = (char )'/';
#line 67
  start = (char const   *)src;
#line 67
  s = start;
#line 68
  dstart = (char *)dst;
#line 68
  d = dstart;
#line 69
  lim = (d + dsize) - 1;
#line 71
  if (dsize == 0UL) {
#line 72
    return;
  }
#line 73
  *dst = (char )'\000';
#line 75
  if ((int const   )*(s + 0) == 0) {
#line 76
    return;
  } else
#line 75
  if (dsize < 4UL) {
#line 76
    return;
  } else
#line 77
  if (dosCompat != 0) {
#line 78
    if ((int const   )*(src + 0) == 92) {
      {
#line 80
      slash = (char )'\\';
#line 81
      tmp = IsValidUNCPath(src);
#line 81
      n = (size_t )tmp;
      }
#line 82
      if (n != 0UL) {
#line 83
        if (dsize < (size_t const   )n) {
#line 84
          return;
        }
        {
#line 85
        n --;
#line 86
        memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)src, n);
#line 87
        d += n;
#line 88
        *d = (char )'\000';
#line 89
        dstart = d;
#line 90
        s += n;
#line 91
        start = s;
        }
      }
    } else {
      {
#line 94
      tmp___3 = __ctype_b_loc();
      }
#line 94
      if ((int const   )*(*tmp___3 + (int )*(src + 0)) & 1024) {
#line 94
        if ((int const   )*(src + 1) == 58) {
#line 96
          tmp___0 = d;
#line 96
          d ++;
#line 96
          *tmp___0 = (char )*(src + 0);
#line 97
          tmp___1 = d;
#line 97
          d ++;
#line 97
          *tmp___1 = (char )':';
#line 98
          start += 2;
#line 99
          dstart += 2;
#line 100
          s += 2;
#line 101
          if ((int const   )*(src + 2) == 47) {
#line 105
            slash = (char )*(src + 2);
          } else
#line 101
          if ((int const   )*(src + 2) == 92) {
#line 105
            slash = (char )*(src + 2);
          } else {
#line 102
            slash = (char )'\\';
#line 103
            tmp___2 = d;
#line 103
            d ++;
#line 103
            *tmp___2 = (char )'\\';
          }
        }
      }
    }
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    c = (int )*s;
#line 113
    if (c == 46) {
#line 114
      if ((unsigned long )s == (unsigned long )start) {
#line 114
        goto _L___3;
      } else
#line 114
      if ((int const   )*(s + -1) == 47) {
#line 114
        goto _L___3;
      } else
#line 114
      if ((int const   )*(s + -1) == 92) {
        _L___3: /* CIL Label */ 
#line 114
        if ((int const   )*(s + 1) == 47) {
#line 114
          goto _L___1;
        } else
#line 114
        if ((int const   )*(s + 1) == 92) {
#line 114
          goto _L___1;
        } else
#line 114
        if ((int const   )*(s + 1) == 0) {
          _L___1: /* CIL Label */ 
#line 116
          if ((int const   )*(s + 1) == 47) {
#line 117
            s ++;
          } else
#line 116
          if ((int const   )*(s + 1) == 92) {
#line 117
            s ++;
          }
#line 118
          s ++;
        } else {
#line 114
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 119
      if (dosCompat != 0) {
#line 119
        if ((int const   )*(s + 1) == 46) {
#line 120
          if ((unsigned long )d < (unsigned long )lim) {
#line 121
            tmp___4 = d;
#line 121
            d ++;
#line 121
            tmp___5 = s;
#line 121
            s ++;
#line 121
            *tmp___4 = (char )*tmp___5;
          }
#line 122
          if ((unsigned long )d < (unsigned long )lim) {
#line 123
            tmp___6 = d;
#line 123
            d ++;
#line 123
            tmp___7 = s;
#line 123
            s ++;
#line 123
            *tmp___6 = (char )*tmp___7;
          }
#line 124
          if ((int const   )*s == 46) {
#line 125
            dotp = s;
            {
#line 126
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 126
              if (! ((int const   )*dotp == 46)) {
#line 126
                goto while_break___0;
              }
#line 127
              dotp ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 128
            if ((int const   )*dotp == 0) {
#line 133
              s = dotp;
            } else
#line 128
            if ((int const   )*dotp == 47) {
#line 133
              s = dotp;
            } else
#line 128
            if ((int const   )*dotp == 92) {
#line 133
              s = dotp;
            }
          }
        } else {
#line 119
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 136
      if ((unsigned long )d < (unsigned long )lim) {
#line 137
        tmp___8 = d;
#line 137
        d ++;
#line 137
        tmp___9 = s;
#line 137
        s ++;
#line 137
        *tmp___8 = (char )*tmp___9;
      } else {
#line 139
        s ++;
      }
    } else
#line 141
    if (c == 47) {
#line 141
      goto _L___5;
    } else
#line 141
    if (c == 92) {
      _L___5: /* CIL Label */ 
#line 143
      if ((unsigned long )d < (unsigned long )lim) {
#line 144
        tmp___10 = d;
#line 144
        d ++;
#line 144
        *tmp___10 = slash;
      }
#line 145
      s ++;
      {
#line 146
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 147
        c = (int )*s;
#line 148
        if (c == 47) {
#line 150
          s ++;
        } else
#line 148
        if (c == 92) {
#line 150
          s ++;
        } else
#line 151
        if (c == 46) {
#line 152
          c = (int )*(s + 1);
#line 153
          if (c == 47) {
#line 155
            s += 2;
          } else
#line 153
          if (c == 92) {
#line 155
            s += 2;
          } else
#line 156
          if (c == 0) {
#line 158
            s ++;
          } else {
#line 160
            goto while_break___1;
          }
        } else {
#line 163
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 166
    if (c == 0) {
#line 168
      if ((int )*(d + -1) == 47) {
#line 168
        goto _L___4;
      } else
#line 168
      if ((int )*(d + -1) == 92) {
        _L___4: /* CIL Label */ 
#line 168
        if ((unsigned long )d > (unsigned long )(dstart + 1)) {
#line 169
          *(d + -1) = (char )'\000';
        }
      }
#line 170
      *d = (char )'\000';
#line 171
      goto while_break;
    } else
#line 172
    if ((unsigned long )d < (unsigned long )lim) {
#line 173
      tmp___11 = d;
#line 173
      d ++;
#line 173
      tmp___12 = s;
#line 173
      s ++;
#line 173
      *tmp___11 = (char )*tmp___12;
    } else {
#line 175
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  a = dstart;
  {
#line 185
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 185
    if (! ((int )*a != 0)) {
#line 185
      goto while_break___2;
    }
#line 186
    b = a;
    {
#line 187
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 189
      if ((int )*a == 0) {
#line 190
        return;
      }
#line 191
      if ((int )*a == 47) {
#line 192
        a ++;
#line 193
        goto while_break___3;
      } else
#line 191
      if ((int )*a == 92) {
#line 192
        a ++;
#line 193
        goto while_break___3;
      }
#line 195
      a ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 197
    if ((int )*(b + 0) == 46) {
#line 197
      if ((int )*(b + 1) == 46) {
#line 198
        if ((int )*(b + 2) == 47) {
#line 202
          goto while_continue___2;
        } else
#line 198
        if ((int )*(b + 2) == 92) {
#line 202
          goto while_continue___2;
        }
      }
    }
#line 205
    if ((int )*(a + 0) == 46) {
#line 205
      if ((int )*(a + 1) == 46) {
#line 206
        if ((int )*(a + 2) == 47) {
#line 206
          goto _L___6;
        } else
#line 206
        if ((int )*(a + 2) == 92) {
          _L___6: /* CIL Label */ 
#line 208
          if ((unsigned long )b == (unsigned long )dstart) {
#line 208
            if ((int )*dstart == 47) {
              {
#line 209
              tmp___13 = strlen((char const   *)(a + 3));
#line 209
              memmove((void *)(b + 1), (void const   *)(a + 3), tmp___13 + 1UL);
              }
            } else
#line 208
            if ((int )*dstart == 92) {
              {
#line 209
              tmp___13 = strlen((char const   *)(a + 3));
#line 209
              memmove((void *)(b + 1), (void const   *)(a + 3), tmp___13 + 1UL);
              }
            } else {
              {
#line 211
              tmp___14 = strlen((char const   *)(a + 3));
#line 211
              memmove((void *)b, (void const   *)(a + 3), tmp___14 + 1UL);
              }
            }
          } else {
            {
#line 211
            tmp___14 = strlen((char const   *)(a + 3));
#line 211
            memmove((void *)b, (void const   *)(a + 3), tmp___14 + 1UL);
            }
          }
#line 212
          a = dstart;
        } else
#line 213
        if ((int )*(a + 2) == 0) {
#line 215
          if ((unsigned long )b == (unsigned long )dstart) {
#line 216
            if ((int const   )*(start + 0) == 47) {
#line 216
              tmp___15 = (int )slash;
            } else
#line 216
            if ((int const   )*(start + 0) == 92) {
#line 216
              tmp___15 = (int )slash;
            } else {
#line 216
              tmp___15 = '.';
            }
#line 216
            *(dstart + 0) = (char )tmp___15;
#line 217
            *(dstart + 1) = (char )'\000';
          } else
#line 218
          if ((unsigned long )b <= (unsigned long )(dstart + 1)) {
#line 218
            if ((int )*dstart == 47) {
#line 219
              *(dstart + 1) = (char )'\000';
            } else
#line 218
            if ((int )*dstart == 92) {
#line 219
              *(dstart + 1) = (char )'\000';
            } else {
#line 221
              *(b + -1) = (char )'\000';
            }
          } else {
#line 221
            *(b + -1) = (char )'\000';
          }
#line 223
          a = dstart;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 233
  return;
}
}
#line 237 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_pathcat.c"
void PathCat(char * const  dst , size_t const   dsize , char const   * const  cwd ,
             char const   * const  src , int dosCompat ) 
{ 
  char *cp ;
  char tmp[512] ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 243
  if (dosCompat != 0) {
    {
#line 244
    tmp___4 = __ctype_b_loc();
    }
#line 244
    if ((int const   )*(*tmp___4 + (int )*(cwd + 0)) & 1024) {
#line 244
      if ((int const   )*(cwd + 1) == 58) {
        {
#line 245
        tmp___1 = __ctype_b_loc();
        }
#line 245
        if ((int const   )*(*tmp___1 + (int )*(src + 0)) & 1024) {
#line 245
          if ((int const   )*(src + 1) == 58) {
            {
#line 247
            CompressPath(dst, src, dsize, dosCompat);
            }
#line 248
            return;
          } else {
#line 245
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 249
          tmp___0 = IsValidUNCPath(src);
          }
#line 249
          if (tmp___0) {
            {
#line 250
            CompressPath(dst, src, dsize, dosCompat);
            }
#line 251
            return;
          } else
#line 252
          if ((int const   )*(src + 0) == 92) {
            {
#line 256
            *(dst + 0) = (char )*(cwd + 0);
#line 257
            *(dst + 1) = (char )':';
#line 258
            CompressPath(dst + 2, src, dsize - 2UL, dosCompat);
            }
#line 259
            return;
          }
        }
      } else {
#line 244
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 261
      tmp___3 = IsValidUNCPath(src);
      }
#line 261
      if (tmp___3) {
        {
#line 265
        CompressPath(dst, src, dsize, dosCompat);
        }
#line 266
        return;
      } else
#line 267
      if ((int const   )*(src + 0) == 92) {
        {
#line 271
        CompressPath(dst, src, dsize, dosCompat);
        }
#line 272
        return;
      } else {
        {
#line 267
        tmp___2 = __ctype_b_loc();
        }
#line 267
        if ((int const   )*(*tmp___2 + (int )*(src + 0)) & 1024) {
#line 267
          if ((int const   )*(src + 1) == 58) {
            {
#line 271
            CompressPath(dst, src, dsize, dosCompat);
            }
#line 272
            return;
          }
        }
      }
    }
  }
#line 275
  if ((int const   )*(src + 0) == 47) {
    {
#line 277
    CompressPath(dst, src, dsize, dosCompat);
    }
#line 278
    return;
  } else
#line 275
  if ((int const   )*(src + 0) == 126) {
    {
#line 277
    CompressPath(dst, src, dsize, dosCompat);
    }
#line 278
    return;
  }
  {
#line 281
  cp = Strnpcpy((char */* const  */)(tmp), cwd, sizeof(tmp) - 1UL);
  }
#line 282
  if (dosCompat) {
#line 283
    if ((int )*(dst + 0) == 92) {
#line 284
      tmp___5 = cp;
#line 284
      cp ++;
#line 284
      *tmp___5 = (char )'\\';
    } else
#line 285
    if ((int )*(dst + 1) != 58) {
#line 286
      tmp___6 = cp;
#line 286
      cp ++;
#line 286
      *tmp___6 = (char )'/';
    } else
#line 285
    if ((int )*(dst + 2) == 47) {
#line 286
      tmp___6 = cp;
#line 286
      cp ++;
#line 286
      *tmp___6 = (char )'/';
    } else {
#line 288
      tmp___7 = cp;
#line 288
      cp ++;
#line 288
      *tmp___7 = (char )'\\';
    }
  } else {
#line 290
    tmp___8 = cp;
#line 290
    cp ++;
#line 290
    *tmp___8 = (char )'/';
  }
  {
#line 292
  *cp = (char )'\000';
#line 293
  Strnpcat((char */* const  */)cp, src, sizeof(tmp) - (unsigned long )(cp - tmp));
#line 294
  CompressPath(dst, (char const   */* const  */)(tmp), dsize, dosCompat);
  }
#line 295
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_pathcat.c"
int DPathCat(char ** const  dst0 , char const   * const  cwd , char const   * const  src ,
             int dosCompat ) 
{ 
  char *cp ;
  char *dst ;
  char *tmp ;
  size_t dsize ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 305
  tmp___0 = strlen((char const   *)cwd);
#line 305
  tmp___1 = strlen((char const   *)src);
#line 305
  dsize = (((tmp___0 + 1UL) + tmp___1) + 1UL) + 10UL;
#line 311
  tmp___2 = calloc(dsize, (size_t )1);
#line 311
  dst = (char *)tmp___2;
#line 312
  *dst0 = dst;
  }
#line 313
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 314
    return (-1);
  }
#line 316
  if (dosCompat != 0) {
    {
#line 317
    tmp___7 = __ctype_b_loc();
    }
#line 317
    if ((int const   )*(*tmp___7 + (int )*(cwd + 0)) & 1024) {
#line 317
      if ((int const   )*(cwd + 1) == 58) {
        {
#line 318
        tmp___4 = __ctype_b_loc();
        }
#line 318
        if ((int const   )*(*tmp___4 + (int )*(src + 0)) & 1024) {
#line 318
          if ((int const   )*(src + 1) == 58) {
            {
#line 320
            CompressPath((char */* const  */)dst, src, (size_t const   )dsize, dosCompat);
            }
#line 321
            return (0);
          } else {
#line 318
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 322
          tmp___3 = IsValidUNCPath(src);
          }
#line 322
          if (tmp___3) {
            {
#line 323
            CompressPath((char */* const  */)dst, src, (size_t const   )dsize, dosCompat);
            }
#line 324
            return (0);
          } else
#line 325
          if ((int const   )*(src + 0) == 92) {
            {
#line 329
            *(dst + 0) = (char )*(cwd + 0);
#line 330
            *(dst + 1) = (char )':';
#line 331
            CompressPath((char */* const  */)(dst + 2), src, (size_t const   )(dsize - 2UL),
                         dosCompat);
            }
#line 332
            return (0);
          }
        }
      } else {
#line 317
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 334
      tmp___6 = IsValidUNCPath(src);
      }
#line 334
      if (tmp___6) {
        {
#line 338
        CompressPath((char */* const  */)dst, src, (size_t const   )dsize, dosCompat);
        }
#line 339
        return (0);
      } else
#line 340
      if ((int const   )*(src + 0) == 92) {
        {
#line 344
        CompressPath((char */* const  */)dst, src, (size_t const   )dsize, dosCompat);
        }
#line 345
        return (0);
      } else {
        {
#line 340
        tmp___5 = __ctype_b_loc();
        }
#line 340
        if ((int const   )*(*tmp___5 + (int )*(src + 0)) & 1024) {
#line 340
          if ((int const   )*(src + 1) == 58) {
            {
#line 344
            CompressPath((char */* const  */)dst, src, (size_t const   )dsize, dosCompat);
            }
#line 345
            return (0);
          }
        }
      }
    }
  }
#line 348
  if ((int const   )*(src + 0) == 47) {
    {
#line 350
    CompressPath((char */* const  */)dst, src, (size_t const   )dsize, dosCompat);
    }
#line 351
    return (0);
  }
  {
#line 354
  tmp___8 = calloc(dsize, (size_t )1);
#line 354
  tmp = (char *)tmp___8;
  }
#line 355
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 356
    free((void *)dst);
#line 357
    *dst0 = (char *)((void *)0);
    }
#line 358
    return (-1);
  }
  {
#line 361
  cp = Strnpcpy((char */* const  */)tmp, cwd, dsize - 1UL);
  }
#line 362
  if (dosCompat) {
#line 363
    if ((int )*(dst + 0) == 92) {
#line 364
      tmp___9 = cp;
#line 364
      cp ++;
#line 364
      *tmp___9 = (char )'\\';
    } else
#line 365
    if ((int )*(dst + 1) != 58) {
#line 366
      tmp___10 = cp;
#line 366
      cp ++;
#line 366
      *tmp___10 = (char )'/';
    } else
#line 365
    if ((int )*(dst + 2) == 47) {
#line 366
      tmp___10 = cp;
#line 366
      cp ++;
#line 366
      *tmp___10 = (char )'/';
    } else {
#line 368
      tmp___11 = cp;
#line 368
      cp ++;
#line 368
      *tmp___11 = (char )'\\';
    }
  } else {
#line 370
    tmp___12 = cp;
#line 370
    cp ++;
#line 370
    *tmp___12 = (char )'/';
  }
  {
#line 372
  *cp = (char )'\000';
#line 373
  Strnpcat((char */* const  */)cp, src, dsize - (size_t )(cp - tmp));
#line 374
  CompressPath((char */* const  */)dst, (char const   */* const  */)tmp, (size_t const   )dsize,
               dosCompat);
#line 375
  free((void *)tmp);
  }
#line 376
  return (0);
}
}
#line 901 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPList(FTPCIPtr const   cip , int const   outfd , int const   longMode , char const   * const  lsflag ) ;
#line 37 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_list.c"
int FTPList(FTPCIPtr const   cip , int const   outfd , int const   longMode , char const   * const  lsflag ) 
{ 
  char const   *cmd ;
  char line[512] ;
  char secondaryBuf[768] ;
  SReadlineInfo lsSrl ;
  int result ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 52
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 53
    return (-139);
  }
  {
#line 54
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 54
  if (tmp) {
#line 55
    return (-138);
  }
#line 57
  if (longMode != 0) {
#line 57
    cmd = "LIST";
  } else {
#line 57
    cmd = "NLST";
  }
#line 58
  if ((unsigned long )lsflag == (unsigned long )((void *)0)) {
    {
#line 59
    result = FTPStartDataCmd(cip, (int const   )65, (int const   )'A', (long long const   )0LL,
                             (char const   */* const  */)"%s", cmd);
    }
  } else
#line 58
  if ((int const   )*(lsflag + 0) == 0) {
    {
#line 59
    result = FTPStartDataCmd(cip, (int const   )65, (int const   )'A', (long long const   )0LL,
                             (char const   */* const  */)"%s", cmd);
    }
  } else {
    {
#line 61
    result = FTPStartDataCmd(cip, (int const   )65, (int const   )'A', (long long const   )0LL,
                             (char const   */* const  */)"%s %s", cmd, lsflag);
    }
  }
#line 67
  if (result == 0) {
    {
#line 68
    tmp___0 = InitSReadlineInfo(& lsSrl, cip->dataSocket, secondaryBuf, sizeof(secondaryBuf),
                                (int )cip->xferTimeout, 1);
    }
#line 68
    if (tmp___0 < 0) {
      {
#line 70
      result = -108;
#line 71
      cip->errNo = -108;
#line 72
      FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not fdopen.\n");
      }
#line 73
      return (result);
    }
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 77
      result = SReadline(& lsSrl, (char */* const  */)(line), sizeof(line) - 2UL);
      }
#line 78
      if (result == -2) {
        {
#line 80
        FTPLogError(cip, (int const   )0, (char const   */* const  */)"Could not directory listing data -- timed out.\n");
#line 81
        cip->errNo = -194;
        }
#line 82
        return (cip->errNo);
      } else
#line 83
      if (result == 0) {
#line 85
        (cip->numListings) ++;
#line 86
        goto while_break;
      } else
#line 87
      if (result < 0) {
        {
#line 89
        FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not read directory listing data");
#line 90
        result = -130;
#line 91
        cip->errNo = -130;
        }
#line 92
        goto while_break;
      }
      {
#line 95
      tmp___1 = strlen((char const   *)(line));
#line 95
      write((int )outfd, (void const   *)(line), tmp___1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 98
    DisposeSReadlineInfo(& lsSrl);
#line 99
    tmp___2 = FTPEndDataCmd(cip, 1);
    }
#line 99
    if (tmp___2 < 0) {
#line 100
      result = -130;
#line 101
      cip->errNo = -130;
    }
  } else
#line 103
  if (result == -1) {
#line 104
    result = -130;
#line 105
    cip->errNo = -130;
  }
#line 146
  return (result);
}
}
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spoolutil.c"
int gUnprocessedJobs ;
#line 89 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spoolutil.c"
static int WriteSpoolLine___1(FILE * const  ofp , char const   * const  line ) 
{ 
  int c ;
  char const   *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 95
  c = 0;
#line 96
  cp = (char const   *)line;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! *cp) {
#line 96
      goto while_break;
    }
#line 97
    c = (int )*cp;
#line 98
    if (c == 10) {
#line 98
      if ((int const   )*(cp + 1) != 0) {
        {
#line 99
        tmp = _IO_putc('\\', (_IO_FILE *)ofp);
        }
#line 99
        if (tmp == -1) {
#line 100
          return (-1);
        }
      }
    }
    {
#line 102
    tmp___0 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 102
    if (tmp___0 == -1) {
#line 103
      return (-1);
    }
#line 96
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (c != 10) {
    {
#line 106
    c = '\n';
#line 107
    tmp___1 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 107
    if (tmp___1 == -1) {
#line 108
      return (-1);
    }
  }
#line 110
  return (0);
}
}
#line 55 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Strncpy_NoZeroPad(char * const  dst , char const   * const  src , size_t const   n ) ;
#line 10 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strncpy_NoZeroPad.c"
char *Strncpy_NoZeroPad(char * const  dst , char const   * const  src , size_t const   n ) 
{ 
  register char *d ;
  register char const   *s ;
  register size_t i___0 ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 17
  d = (char *)dst;
#line 18
  *d = (char)0;
#line 19
  if (n != 0UL) {
#line 20
    s = (char const   *)src;
#line 27
    i___0 = (size_t )1;
    {
#line 27
    while (1) {
      while_continue: /* CIL Label */ ;
#line 27
      if (! (i___0 < (size_t )n)) {
#line 27
        goto while_break;
      }
#line 28
      tmp = d;
#line 28
      d ++;
#line 28
      tmp___1 = s;
#line 28
      s ++;
#line 28
      tmp___0 = (char )*tmp___1;
#line 28
      *tmp = tmp___0;
#line 28
      if ((int )tmp___0 == 0) {
#line 29
        return ((char *)dst);
      }
#line 27
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 35
    *d = (char)0;
  }
#line 37
  return ((char *)dst);
}
}
#line 73 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
static void SaveLastResponse___0(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 


  {
#line 76
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 77
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 78
    cip->lastFTPCmdResultNum = -1;
#line 79
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else
#line 80
  if ((unsigned long )rp->msg.first == (unsigned long )((void *)0)) {
    {
#line 81
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 82
    cip->lastFTPCmdResultNum = rp->code;
#line 83
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else
#line 80
  if ((unsigned long )(rp->msg.first)->line == (unsigned long )((void *)0)) {
    {
#line 81
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 82
    cip->lastFTPCmdResultNum = rp->code;
#line 83
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else {
    {
#line 85
    Strncpy((char */* const  */)(cip->lastFTPCmdResultStr), (char const   */* const  */)(rp->msg.first)->line,
            (size_t const   )sizeof(cip->lastFTPCmdResultStr));
#line 86
    cip->lastFTPCmdResultNum = rp->code;
#line 89
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
#line 92
    cip->lastFTPCmdResultLL = rp->msg;
    }
  }
#line 94
  return;
}
}
#line 923 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPUmask(FTPCIPtr const   cip , char const   * const  umsk ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_umask.c"
int FTPUmask(FTPCIPtr const   cip , char const   * const  umsk ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 16
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 17
    return (-139);
  }
  {
#line 18
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 18
  if (tmp) {
#line 19
    return (-138);
  }
#line 20
  if ((unsigned long )umsk == (unsigned long )((void *)0)) {
#line 21
    return (-139);
  } else
#line 20
  if ((int const   )*(umsk + 0) == 0) {
#line 21
    return (-139);
  }
  {
#line 22
  tmp___0 = FTPCmd(cip, (char const   */* const  */)"SITE UMASK %s", umsk);
  }
#line 22
  if (tmp___0 == 2) {
#line 23
    return (0);
  }
#line 24
  cip->errNo = -143;
#line 25
  return (-143);
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_rename.c"
int FTPRename(FTPCIPtr const   cip , char const   * const  oldname , char const   * const  newname___1 ) 
{ 
  int result ;
  int tmp ;

  {
#line 18
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 19
    return (-139);
  }
  {
#line 20
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 20
  if (tmp) {
#line 21
    return (-138);
  }
#line 22
  if ((unsigned long )oldname == (unsigned long )((void *)0)) {
#line 23
    return (-139);
  } else
#line 22
  if ((int const   )*(oldname + 0) == 0) {
#line 23
    return (-139);
  }
#line 24
  if ((unsigned long )newname___1 == (unsigned long )((void *)0)) {
#line 25
    return (-139);
  } else
#line 24
  if ((int const   )*(oldname + 0) == 0) {
#line 25
    return (-139);
  }
  {
#line 28
  result = FTPCmd(cip, (char const   */* const  */)"RNFR %s", oldname);
  }
#line 29
  if (result < 0) {
#line 30
    return (result);
  }
#line 31
  if (result != 3) {
#line 32
    cip->errNo = -150;
#line 33
    return (cip->errNo);
  }
  {
#line 36
  result = FTPCmd(cip, (char const   */* const  */)"RNTO %s", newname___1);
  }
#line 37
  if (result < 0) {
#line 38
    return (result);
  }
#line 39
  if (result != 2) {
#line 40
    cip->errNo = -150;
#line 41
    return (cip->errNo);
  }
#line 43
  return (0);
}
}
#line 967 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int StrToBoolOrInt(char const   *s ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_feat.c"
int StrToBoolOrInt(char const   *s ) 
{ 
  int c ;
  int result ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    tmp = s;
#line 20
    s ++;
#line 20
    c = (int )*tmp;
#line 21
    if (c == 0) {
#line 22
      return (0);
    }
    {
#line 23
    tmp___0 = __ctype_b_loc();
    }
#line 23
    if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 24
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 27
  tmp___1 = __ctype_b_loc();
  }
#line 27
  if ((int const   )*(*tmp___1 + c) & 256) {
    {
#line 28
    c = tolower(c);
    }
  }
#line 29
  result = 0;
  {
#line 32
  if (c == 110) {
#line 32
    goto case_110;
  }
#line 32
  if (c == 102) {
#line 32
    goto case_110;
  }
#line 34
  if (c == 111) {
#line 34
    goto case_111;
  }
#line 43
  if (c == 121) {
#line 43
    goto case_121;
  }
#line 43
  if (c == 116) {
#line 43
    goto case_121;
  }
#line 46
  goto switch_default;
  case_110: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 33
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 35
  c = (int )*(s + 1);
#line 36
  tmp___2 = __ctype_b_loc();
  }
#line 36
  if ((int const   )*(*tmp___2 + c) & 256) {
    {
#line 37
    c = tolower(c);
    }
  }
#line 38
  if (c == 102) {
#line 39
    goto switch_break;
  }
#line 40
  result = 1;
#line 41
  goto switch_break;
  case_121: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 44
  result = 1;
#line 45
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 47
  result = atoi(s - 1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 49
  return (result);
}
}
#line 55 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_feat.c"
static char const   *gConnInfoOptStrings[19]  = 
#line 55
  {      "PASV",      "SIZE",      "MDTM",      "MDTM_set", 
        "REST",      "NLST_a",      "NLST_d",      "FEAT", 
        "MLSD",      "MLST",      "CLNT",      "HELP_SITE", 
        "SITE_UTIME",      "STATfileParamWorks",      "NLSTfileParamWorks",      "require20", 
        "allowProxyForPORT",      "doNotGetStartCWD",      (char const   *)((void *)0)};
#line 103 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_feat.c"
void FTPManualOverrideFeatures(FTPCIPtr const   cip ) 
{ 
  char tokbuf[256] ;
  char *parse ;
  char *context ;
  char *opt ;
  int intval ;
  char *charval ;
  char const   **optlist ;
  ConnInfoOptions optnum ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 120
  if ((unsigned long )cip->manualOverrideFeatures == (unsigned long )((void *)0)) {
#line 121
    return;
  } else
#line 120
  if ((int const   )*(cip->manualOverrideFeatures + 0) == 0) {
#line 121
    return;
  }
  {
#line 123
  Strncpy((char */* const  */)(tokbuf), (char const   */* const  */)cip->manualOverrideFeatures,
          (size_t const   )sizeof(tokbuf));
#line 125
  parse = tokbuf;
#line 125
  context = (char *)((void *)0);
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    opt = strtokc(parse, ",;\n\t\r", & context);
    }
#line 125
    if (! ((unsigned long )opt != (unsigned long )((void *)0))) {
#line 125
      goto while_break;
    }
    {
#line 129
    intval = 1;
#line 130
    charval = strchr((char const   *)opt, '=');
    }
#line 131
    if ((unsigned long )charval != (unsigned long )((void *)0)) {
      {
#line 132
      tmp = charval;
#line 132
      charval ++;
#line 132
      *tmp = (char )'\000';
#line 133
      intval = StrToBoolOrInt((char const   *)charval);
      }
    } else
#line 134
    if ((int )*opt == 33) {
#line 135
      opt ++;
#line 136
      intval = 0;
    }
    {
#line 138
    tmp___0 = strncasecmp((char const   *)opt, "has", (size_t )3);
    }
#line 138
    if (tmp___0 == 0) {
#line 139
      opt += 3;
    }
    {
#line 140
    tmp___1 = strncasecmp((char const   *)opt, "use", (size_t )3);
    }
#line 140
    if (tmp___1 == 0) {
#line 141
      opt += 3;
    }
    {
#line 142
    tmp___2 = strncasecmp((char const   *)opt, "have", (size_t )4);
    }
#line 142
    if (tmp___2 == 0) {
#line 143
      opt += 4;
    }
    {
#line 144
    tmp___3 = strncasecmp((char const   *)opt, "no", (size_t )2);
    }
#line 144
    if (tmp___3 == 0) {
#line 145
      opt += 2;
#line 146
      intval = 0;
    }
#line 148
    optlist = gConnInfoOptStrings;
#line 148
    optnum = (ConnInfoOptions )0;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! ((unsigned long )*optlist != (unsigned long )((void *)0))) {
#line 148
        goto while_break___0;
      }
      {
#line 149
      tmp___4 = strcasecmp((char const   *)opt, *optlist);
      }
#line 149
      if (tmp___4 == 0) {
        {
#line 151
        if ((unsigned int )optnum == 0U) {
#line 151
          goto case_0;
        }
#line 154
        if ((unsigned int )optnum == 1U) {
#line 154
          goto case_1;
        }
#line 157
        if ((unsigned int )optnum == 2U) {
#line 157
          goto case_2;
        }
#line 160
        if ((unsigned int )optnum == 3U) {
#line 160
          goto case_3;
        }
#line 163
        if ((unsigned int )optnum == 4U) {
#line 163
          goto case_4;
        }
#line 166
        if ((unsigned int )optnum == 5U) {
#line 166
          goto case_5;
        }
#line 169
        if ((unsigned int )optnum == 6U) {
#line 169
          goto case_6;
        }
#line 172
        if ((unsigned int )optnum == 7U) {
#line 172
          goto case_7;
        }
#line 175
        if ((unsigned int )optnum == 8U) {
#line 175
          goto case_8;
        }
#line 178
        if ((unsigned int )optnum == 9U) {
#line 178
          goto case_9;
        }
#line 181
        if ((unsigned int )optnum == 10U) {
#line 181
          goto case_10;
        }
#line 184
        if ((unsigned int )optnum == 11U) {
#line 184
          goto case_11;
        }
#line 187
        if ((unsigned int )optnum == 12U) {
#line 187
          goto case_12;
        }
#line 190
        if ((unsigned int )optnum == 13U) {
#line 190
          goto case_13;
        }
#line 193
        if ((unsigned int )optnum == 14U) {
#line 193
          goto case_14;
        }
#line 196
        if ((unsigned int )optnum == 15U) {
#line 196
          goto case_15;
        }
#line 199
        if ((unsigned int )optnum == 16U) {
#line 199
          goto case_16;
        }
#line 202
        if ((unsigned int )optnum == 17U) {
#line 202
          goto case_17;
        }
#line 205
        if ((unsigned int )optnum == 18U) {
#line 205
          goto case_18;
        }
#line 150
        goto switch_break;
        case_0: /* CIL Label */ 
#line 152
        cip->hasPASV = intval;
#line 153
        goto switch_break;
        case_1: /* CIL Label */ 
#line 155
        cip->hasSIZE = intval;
#line 156
        goto switch_break;
        case_2: /* CIL Label */ 
#line 158
        cip->hasMDTM = intval;
#line 159
        goto switch_break;
        case_3: /* CIL Label */ 
#line 161
        cip->hasMDTM_set = intval;
#line 162
        goto switch_break;
        case_4: /* CIL Label */ 
#line 164
        cip->hasREST = intval;
#line 165
        goto switch_break;
        case_5: /* CIL Label */ 
#line 167
        cip->hasNLST_a = intval;
#line 168
        goto switch_break;
        case_6: /* CIL Label */ 
#line 170
        cip->hasNLST_d = intval;
#line 171
        goto switch_break;
        case_7: /* CIL Label */ 
#line 173
        cip->hasFEAT = intval;
#line 174
        goto switch_break;
        case_8: /* CIL Label */ 
#line 176
        cip->hasMLSD = intval;
#line 177
        goto switch_break;
        case_9: /* CIL Label */ 
#line 179
        cip->hasMLST = intval;
#line 180
        goto switch_break;
        case_10: /* CIL Label */ 
#line 182
        cip->hasCLNT = intval;
#line 183
        goto switch_break;
        case_11: /* CIL Label */ 
#line 185
        cip->hasHELP_SITE = intval;
#line 186
        goto switch_break;
        case_12: /* CIL Label */ 
#line 188
        cip->hasSITE_UTIME = intval;
#line 189
        goto switch_break;
        case_13: /* CIL Label */ 
#line 191
        cip->STATfileParamWorks = intval;
#line 192
        goto switch_break;
        case_14: /* CIL Label */ 
#line 194
        cip->NLSTfileParamWorks = intval;
#line 195
        goto switch_break;
        case_15: /* CIL Label */ 
#line 197
        cip->require20 = intval;
#line 198
        goto switch_break;
        case_16: /* CIL Label */ 
#line 200
        cip->allowProxyForPORT = intval;
#line 201
        goto switch_break;
        case_17: /* CIL Label */ 
#line 203
        cip->doNotGetStartingWorkingDirectory = intval;
#line 204
        goto switch_break;
        case_18: /* CIL Label */ 
#line 206
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 208
        goto while_break___0;
      }
#line 148
      optlist ++;
#line 148
      optnum = (ConnInfoOptions )((unsigned int )optnum + 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    parse = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  return;
}
}
#line 910 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPOpenHostNoLogin(FTPCIPtr const   cip ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_opennologin.c"
int FTPOpenHostNoLogin(FTPCIPtr const   cip ) 
{ 
  int result ;
  time_t t0 ;
  time_t t1 ;
  int elapsed ;
  int tmp ;

  {
#line 20
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 21
    return (-139);
  }
  {
#line 22
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 22
  if (tmp) {
#line 23
    return (-138);
  }
#line 25
  if ((int )cip->host[0] == 0) {
#line 26
    cip->errNo = -139;
#line 27
    return (-139);
  }
  {
#line 30
  FTPInitialLogEntry(cip);
#line 32
  result = -118;
#line 32
  cip->numDials = 0;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (cip->maxDials < 0)) {
#line 32
      if (! (cip->numDials < cip->maxDials)) {
#line 32
        goto while_break;
      }
    }
    {
#line 40
    result = FTPAllocateHost(cip);
    }
#line 41
    if (result < 0) {
#line 42
      return (result);
    }
    {
#line 44
    memset((void *)(& cip->connectTime), 0, sizeof(cip->connectTime));
#line 45
    memset((void *)(& cip->loginTime), 0, sizeof(cip->loginTime));
#line 46
    memset((void *)(& cip->disconnectTime), 0, sizeof(cip->disconnectTime));
#line 48
    (cip->totalDials) ++;
#line 49
    (cip->numDials) ++;
    }
#line 50
    if (cip->numDials > 1) {
      {
#line 51
      PrintF(cip, (char const   */* const  */)"Retry Number: %d\n", cip->numDials - 1);
      }
    }
#line 52
    if ((unsigned long )cip->redialStatusProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                            int  ,
                                                                            int  ))0)) {
      {
#line 53
      (*(cip->redialStatusProc))(cip, 0, cip->numDials - 1);
      }
    }
    {
#line 54
    time(& t0);
#line 55
    result = OpenControlConnection(cip, cip->host, cip->port);
#line 56
    time(& t1);
    }
#line 57
    if (result == 0) {
      {
#line 59
      PrintF(cip, (char const   */* const  */)"Connected to %s.\n", cip->host);
      }
#line 62
      if (result == 0) {
#line 63
        goto while_break;
      }
    } else
#line 64
    if (result != -119) {
#line 64
      if (result != -120) {
#line 64
        if (result != -158) {
          {
#line 69
          PrintF(cip, (char const   */* const  */)"Cannot recover from miscellaneous open error %d.\n",
                 result);
          }
#line 70
          return (result);
        }
      }
    }
#line 74
    if (cip->redialDelay > 0) {
#line 76
      if (cip->maxDials < 0) {
#line 76
        goto _L;
      } else
#line 76
      if (cip->numDials < cip->maxDials) {
        _L: /* CIL Label */ 
#line 77
        elapsed = (int )(t1 - t0);
#line 78
        if (elapsed < cip->redialDelay) {
          {
#line 79
          PrintF(cip, (char const   */* const  */)"Sleeping %u seconds.\n", (unsigned int )cip->redialDelay - (unsigned int )elapsed);
          }
#line 81
          if ((unsigned long )cip->redialStatusProc != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                                  int  ,
                                                                                  int  ))0)) {
            {
#line 82
            (*(cip->redialStatusProc))(cip, 1, cip->redialDelay - elapsed);
            }
          }
          {
#line 83
          sleep((unsigned int )cip->redialDelay - (unsigned int )elapsed);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (result);
}
}
#line 7 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Dynscat.c"
char *Dynscat(char **dst  , ...) 
{ 
  va_list ap ;
  char const   *src ;
  char *newdst ;
  char *dcp ;
  size_t curLen ;
  size_t catLen ;
  size_t srcLen ;
  int recursive ;
  char const   *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 14
  recursive = 0;
#line 16
  if ((unsigned long )dst == (unsigned long )((char **)0)) {
#line 17
    return ((char *)((void *)0));
  }
  {
#line 19
  catLen = (size_t )0;
#line 20
  __builtin_va_start(ap, dst);
#line 21
  tmp = __builtin_va_arg(ap, char *);
#line 21
  src = tmp;
  }
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 22
      goto while_break;
    }
#line 23
    if ((unsigned long )src == (unsigned long )*dst) {
#line 24
      recursive = 1;
    }
    {
#line 25
    tmp___0 = strlen(src);
#line 25
    catLen += tmp___0;
#line 26
    tmp___1 = __builtin_va_arg(ap, char *);
#line 26
    src = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 28
  __builtin_va_end(ap);
  }
#line 30
  if (recursive != 0) {
#line 36
    if ((unsigned long )*dst != (unsigned long )((void *)0)) {
      {
#line 37
      free((void *)*dst);
      }
    }
#line 38
    *dst = (char *)((void *)0);
#line 39
    return ((char *)((void *)0));
  }
#line 42
  if ((unsigned long )*dst == (unsigned long )((void *)0)) {
#line 43
    curLen = (size_t )0;
  } else
#line 42
  if ((int )*(*dst) == 0) {
#line 43
    curLen = (size_t )0;
  } else {
    {
#line 45
    curLen = strlen((char const   *)*dst);
    }
  }
#line 47
  if ((unsigned long )*dst == (unsigned long )((void *)0)) {
    {
#line 48
    tmp___2 = malloc((curLen + catLen) + 2UL);
#line 48
    newdst = (char *)tmp___2;
    }
  } else {
    {
#line 50
    tmp___3 = realloc((void *)*dst, (curLen + catLen) + 2UL);
#line 50
    newdst = (char *)tmp___3;
    }
  }
#line 51
  if ((unsigned long )newdst == (unsigned long )((void *)0)) {
#line 52
    return ((char *)((void *)0));
  }
  {
#line 54
  dcp = newdst + curLen;
#line 55
  __builtin_va_start(ap, dst);
#line 56
  tmp___4 = __builtin_va_arg(ap, char *);
#line 56
  src = tmp___4;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 57
      goto while_break___0;
    }
    {
#line 58
    srcLen = strlen(src);
#line 59
    memcpy((void */* __restrict  */)dcp, (void const   */* __restrict  */)src, srcLen);
#line 60
    dcp += srcLen;
#line 61
    tmp___5 = __builtin_va_arg(ap, char *);
#line 61
    src = tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 63
  __builtin_va_end(ap);
#line 64
  *dcp = (char )'\000';
#line 66
  *dst = newdst;
  }
#line 67
  return (newdst);
}
}
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char const   copyright___0[59]  = 
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
  {      (char const   )'g',      (char const   )'l',      (char const   )'_',      (char const   )'g', 
        (char const   )'e',      (char const   )'t',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'1',      (char const   )',', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'2',      (char const   )',',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'3',      (char const   )',', 
        (char const   )' ',      (char const   )'C',      (char const   )'h',      (char const   )'r', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'e',      (char const   )'w',      (char const   )'a', 
        (char const   )'l',      (char const   )'t',      (char const   )'\000'};
#line 167
static int gl_tab___0(char *buf , int offset , int *loc , size_t bufsize ) ;
#line 185 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char gl_killbuf___0[256]  ;
#line 186 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_init_done___0  =    -1;
#line 187 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_termw___0  =    80;
#line 188 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_termh___0  =    24;
#line 189 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_scroll___0  =    27;
#line 190 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_width___0  =    0;
#line 191 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_extent___0  =    0;
#line 192 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_overwrite___0  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_pos___0  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_cnt___0  =    0;
#line 194 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char const   *gl_prompt___0  ;
#line 195 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char gl_intrc___0  =    (char)0;
#line 196 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char gl_quitc___0  =    (char)0;
#line 197 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char gl_suspc___0  =    (char)0;
#line 198 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char gl_dsuspc___0  =    (char)0;
#line 199 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_search_mode___0  =    0;
#line 200 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char **gl_matchlist___0  =    (char **)0;
#line 201 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char *gl_home_dir___0  =    (char *)((void *)0);
#line 202 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_vi_preferred___0  =    -1;
#line 203 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_vi_mode___0  =    0;
#line 204 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_result___0  =    0;
#line 206
static void gl_init___0(void) ;
#line 207
static void gl_cleanup___0(void) ;
#line 208
static void gl_char_init___0(void) ;
#line 209
static void gl_char_cleanup___0(void) ;
#line 212
static void gl_addchar___0(int c ) ;
#line 213
static void gl_del___0(int loc , int killsave ) ;
#line 214
static void gl_error___0(char const   * const  buf ) ;
#line 215
static void gl_fixup___0(char const   *prompt , int change , int cursor ) ;
#line 216
static int gl_getc___0(void) ;
#line 217
static int gl_getcx___0(int tlen ) ;
#line 218
static void gl_kill___0(int pos ) ;
#line 219
static void gl_newline___0(void) ;
#line 220
static void gl_putc___0(int c ) ;
#line 221
static void gl_puts___0(char const   *buf ) ;
#line 222
static void gl_redraw___0(void) ;
#line 223
static void gl_transpose___0(void) ;
#line 224
static void gl_yank___0(void) ;
#line 225
static void gl_word___0(int direction ) ;
#line 226
static void gl_killword___0(int direction ) ;
#line 228
static void hist_init___0(void) ;
#line 229
static void hist_dispose___0(void) ;
#line 230
static char *hist_next___0(void) ;
#line 231
static char *hist_prev___0(void) ;
#line 232
static char *hist_save___0(char const   * const  p___5 ) ;
#line 234
static void search_addchar___0(int c ) ;
#line 235
static void search_term___0(void) ;
#line 236
static void search_back___0(int new_search ) ;
#line 237
static void search_forw___0(int new_search ) ;
#line 238
static void gl_beep___0(void) ;
#line 240
static int gl_do_tab_completion___0(char *buf , int *loc , size_t bufsize , int tabtab ) ;
#line 248 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_char_init___0(void) 
{ 
  int tmp ;

  {
  {
#line 253
  tmp = tcgetattr(0, & old_termios);
  }
#line 253
  if (tmp == 0) {
#line 254
    gl_intrc___0 = (char )old_termios.c_cc[0];
#line 255
    gl_quitc___0 = (char )old_termios.c_cc[1];
#line 257
    gl_suspc___0 = (char )old_termios.c_cc[10];
  }
  {
#line 263
  new_termios = old_termios;
#line 264
  new_termios.c_iflag &= 4294962141U;
#line 265
  new_termios.c_iflag |= 5U;
#line 266
  new_termios.c_lflag &= 4294934516U;
#line 267
  new_termios.c_cc[6] = (cc_t )1;
#line 268
  new_termios.c_cc[5] = (cc_t )0;
#line 269
  tcsetattr(0, 0, (struct termios  const  *)(& new_termios));
  }
#line 297
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_char_cleanup___0(void) 
{ 


  {
  {
#line 304
  tcsetattr(0, 0, (struct termios  const  *)(& old_termios));
  }
#line 311
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_getc___0(void) 
{ 
  int c ;
  unsigned char ch ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 383
  ch = (unsigned char )'\000';
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 384
    tmp___0 = read(0, (void *)(& ch), (size_t )1);
#line 384
    c = (int )tmp___0;
    }
#line 384
    if (! (c == -1)) {
#line 384
      goto while_break;
    }
    {
#line 385
    tmp = __errno_location();
    }
#line 385
    if (*tmp != 4) {
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  if (c != -1) {
#line 389
    c = (int )ch;
  }
#line 412
  return (c);
}
}
#line 419 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_getcx___0(int tlen ) 
{ 
  int c ;
  int result ;
  char ch ;
  fd_set ss ;
  struct timeval tv ;
  int *tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 430
  tmp = __errno_location();
#line 430
  *tmp = 0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 431
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 436
    ss.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 440
    tv.tv_sec = (__time_t )((long long )(tlen / 10));
#line 441
    tv.tv_usec = (__suseconds_t )((long long )((tlen % 10) * 100000));
#line 442
    result = select(1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 443
    if (result == 1) {
#line 445
      goto while_break;
    } else
#line 446
    if (result == 0) {
      {
#line 447
      tmp___0 = __errno_location();
#line 447
      *tmp___0 = 110;
      }
#line 448
      return (-2);
    } else {
      {
#line 449
      tmp___1 = __errno_location();
      }
#line 449
      if (*tmp___1 != 4) {
#line 450
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp___2 = __errno_location();
#line 454
  *tmp___2 = 0;
  }
  {
#line 454
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 455
    tmp___3 = read(0, (void *)(& ch), (size_t )1);
#line 455
    c = (int )tmp___3;
    }
#line 456
    if (c == 1) {
#line 457
      return ((int )ch);
    }
    {
#line 458
    tmp___4 = __errno_location();
    }
#line 458
    if (*tmp___4 != 4) {
#line 459
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 462
  return (-1);
}
}
#line 501 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_putc___0(int c ) 
{ 
  char ch ;

  {
  {
#line 504
  ch = (char )((unsigned char )c);
#line 506
  write(1, (void const   *)(& ch), (size_t )1);
  }
#line 507
  if ((int )ch == 10) {
    {
#line 508
    ch = (char )'\r';
#line 509
    write(1, (void const   *)(& ch), (size_t )1);
    }
  }
#line 511
  return;
}
}
#line 515 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_puts___0(char const   *buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
#line 554
  if (buf) {
    {
#line 555
    tmp = strlen(buf);
#line 555
    len = tmp;
#line 556
    write(1, (void const   *)buf, len);
    }
  }
#line 559
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_error___0(char const   * const  buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 564
  tmp = strlen((char const   *)buf);
#line 564
  len = tmp;
#line 566
  gl_cleanup___0();
#line 567
  write(2, (void const   *)buf, len);
#line 568
  exit(1);
  }
}
}
#line 571 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_init___0(void) 
{ 
  char const   *cp ;
  int w ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 579
  tmp = strncmp(copyright___0, "gl_getline", (size_t )7);
  }
#line 579
  if (tmp != 0) {
    {
#line 580
    exit(1);
    }
  }
#line 582
  if (gl_init_done___0 < 0) {
    {
#line 583
    tmp___0 = getenv("COLUMNS");
#line 583
    cp = (char const   *)tmp___0;
    }
#line 584
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 585
      w = atoi(cp);
      }
#line 586
      if (w > 20) {
        {
#line 587
        gl_setwidth(w);
        }
      }
    }
    {
#line 589
    tmp___1 = getenv("ROWS");
#line 589
    cp = (char const   *)tmp___1;
    }
#line 590
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 591
      w = atoi(cp);
      }
#line 592
      if (w > 10) {
        {
#line 593
        gl_setheight(w);
        }
      }
    }
    {
#line 595
    hist_init___0();
    }
  }
  {
#line 597
  tmp___2 = isatty(0);
  }
#line 597
  if (tmp___2 == 0) {
    {
#line 598
    gl_error___0((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
    }
  } else {
    {
#line 597
    tmp___3 = isatty(1);
    }
#line 597
    if (tmp___3 == 0) {
      {
#line 598
      gl_error___0((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
      }
    }
  }
  {
#line 599
  gl_char_init___0();
#line 600
  gl_init_done___0 = 1;
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_cleanup___0(void) 
{ 


  {
#line 607
  if (gl_init_done___0 > 0) {
    {
#line 608
    gl_char_cleanup___0();
    }
  }
#line 609
  gl_init_done___0 = 0;
#line 614
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_check_inputrc_for_vi___0(void) 
{ 
  FILE *fp ;
  char path[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 644
  gl_set_home_dir((char const   *)((void *)0));
  }
#line 645
  if ((unsigned long )gl_home_dir___0 == (unsigned long )((void *)0)) {
#line 646
    return;
  }
  {
#line 649
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s",
           gl_home_dir___0, ".inputrc");
#line 657
  fp = fopen((char const   */* __restrict  */)(path), (char const   */* __restrict  */)"r");
  }
#line 666
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 667
    return;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 669
    tmp___1 = fgets((char */* __restrict  */)(path), (int )(sizeof(path) - 1UL), (FILE */* __restrict  */)fp);
    }
#line 669
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 669
      goto while_break;
    }
    {
#line 670
    tmp = strstr((char const   *)(path), "editing-mode");
    }
#line 670
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 670
      tmp___0 = strstr((char const   *)(path), "vi");
      }
#line 670
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 671
        gl_vi_preferred___0 = 1;
#line 672
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  fclose(fp);
  }
#line 677
  return;
}
}
#line 1122 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_addchar___0(int c ) 
{ 
  int i___0 ;

  {
#line 1128
  if (gl_cnt___0 >= 2047) {
    {
#line 1129
    gl_error___0((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1130
  if (gl_overwrite___0 == 0) {
#line 1130
    goto _L;
  } else
#line 1130
  if (gl_pos___0 == gl_cnt___0) {
    _L: /* CIL Label */ 
#line 1131
    i___0 = gl_cnt___0;
    {
#line 1131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1131
      if (! (i___0 >= gl_pos___0)) {
#line 1131
        goto while_break;
      }
#line 1132
      gl_buf[i___0 + 1] = gl_buf[i___0];
#line 1131
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1133
    gl_buf[gl_pos___0] = (char )c;
#line 1134
    gl_fixup___0(gl_prompt___0, gl_pos___0, gl_pos___0 + 1);
    }
  } else {
    {
#line 1136
    gl_buf[gl_pos___0] = (char )c;
#line 1137
    gl_extent___0 = 1;
#line 1138
    gl_fixup___0(gl_prompt___0, gl_pos___0, gl_pos___0 + 1);
    }
  }
#line 1140
  return;
}
}
#line 1142 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_yank___0(void) 
{ 
  int i___0 ;
  int len ;
  size_t tmp ;

  {
  {
#line 1148
  tmp = strlen((char const   *)(gl_killbuf___0));
#line 1148
  len = (int )tmp;
  }
#line 1149
  if (len > 0) {
#line 1150
    if (gl_overwrite___0 == 0) {
#line 1151
      if (gl_cnt___0 + len >= 2047) {
        {
#line 1152
        gl_error___0((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
        }
      }
#line 1153
      i___0 = gl_cnt___0;
      {
#line 1153
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1153
        if (! (i___0 >= gl_pos___0)) {
#line 1153
          goto while_break;
        }
#line 1154
        gl_buf[i___0 + len] = gl_buf[i___0];
#line 1153
        i___0 --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1155
      i___0 = 0;
      {
#line 1155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1155
        if (! (i___0 < len)) {
#line 1155
          goto while_break___0;
        }
#line 1156
        gl_buf[gl_pos___0 + i___0] = gl_killbuf___0[i___0];
#line 1155
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1157
      gl_fixup___0(gl_prompt___0, gl_pos___0, gl_pos___0 + len);
      }
    } else {
#line 1159
      if (gl_pos___0 + len > gl_cnt___0) {
#line 1160
        if (gl_pos___0 + len >= 2047) {
          {
#line 1161
          gl_error___0((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
          }
        }
#line 1162
        gl_buf[gl_pos___0 + len] = (char)0;
      }
#line 1164
      i___0 = 0;
      {
#line 1164
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1164
        if (! (i___0 < len)) {
#line 1164
          goto while_break___1;
        }
#line 1165
        gl_buf[gl_pos___0 + i___0] = gl_killbuf___0[i___0];
#line 1164
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1166
      gl_extent___0 = len;
#line 1167
      gl_fixup___0(gl_prompt___0, gl_pos___0, gl_pos___0 + len);
      }
    }
  } else {
    {
#line 1170
    gl_beep___0();
    }
  }
#line 1171
  return;
}
}
#line 1173 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_transpose___0(void) 
{ 
  int c ;

  {
#line 1179
  if (gl_pos___0 > 0) {
#line 1179
    if (gl_cnt___0 > gl_pos___0) {
      {
#line 1180
      c = (int )gl_buf[gl_pos___0 - 1];
#line 1181
      gl_buf[gl_pos___0 - 1] = gl_buf[gl_pos___0];
#line 1182
      gl_buf[gl_pos___0] = (char )c;
#line 1183
      gl_extent___0 = 2;
#line 1184
      gl_fixup___0(gl_prompt___0, gl_pos___0 - 1, gl_pos___0);
      }
    } else {
      {
#line 1186
      gl_beep___0();
      }
    }
  } else {
    {
#line 1186
    gl_beep___0();
    }
  }
#line 1187
  return;
}
}
#line 1189 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_newline___0(void) 
{ 
  int change ;
  int len ;
  int loc ;
  size_t tmp ;

  {
#line 1196
  change = gl_cnt___0;
#line 1197
  len = gl_cnt___0;
#line 1198
  loc = gl_width___0 - 5;
#line 1200
  if (gl_cnt___0 >= 2047) {
    {
#line 1201
    gl_error___0((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1202
  if (gl_out_hook) {
    {
#line 1203
    change = (*gl_out_hook)(gl_buf);
#line 1204
    tmp = strlen((char const   *)(gl_buf));
#line 1204
    len = (int )tmp;
    }
  }
#line 1206
  if (loc > len) {
#line 1207
    loc = len;
  }
  {
#line 1208
  gl_fixup___0(gl_prompt___0, change, loc);
#line 1209
  gl_buf[len] = (char )'\n';
#line 1210
  gl_buf[len + 1] = (char )'\000';
#line 1211
  gl_putc___0('\n');
  }
#line 1212
  return;
}
}
#line 1214 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_del___0(int loc , int killsave ) 
{ 
  int i___0 ;
  int j ;

  {
#line 1225
  if (loc == -1) {
#line 1225
    if (gl_pos___0 > 0) {
#line 1225
      goto _L;
    } else {
#line 1225
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1225
  if (loc == 0) {
#line 1225
    if (gl_pos___0 < gl_cnt___0) {
      _L: /* CIL Label */ 
#line 1226
      j = 0;
#line 1226
      i___0 = gl_pos___0 + loc;
      {
#line 1226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1226
        if (! (i___0 < gl_cnt___0)) {
#line 1226
          goto while_break;
        }
#line 1227
        if (j == 0) {
#line 1227
          if (killsave != 0) {
#line 1227
            if (gl_vi_mode___0 != 0) {
#line 1228
              gl_killbuf___0[0] = gl_buf[i___0];
#line 1229
              gl_killbuf___0[1] = (char )'\000';
#line 1230
              j = 1;
            }
          }
        }
#line 1232
        gl_buf[i___0] = gl_buf[i___0 + 1];
#line 1226
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1234
      gl_fixup___0(gl_prompt___0, gl_pos___0 + loc, gl_pos___0 + loc);
      }
    } else {
      {
#line 1236
      gl_beep___0();
      }
    }
  } else {
    {
#line 1236
    gl_beep___0();
    }
  }
#line 1237
  return;
}
}
#line 1239 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_kill___0(int pos ) 
{ 
  size_t tmp ;

  {
#line 1244
  if (pos < gl_cnt___0) {
    {
#line 1244
    tmp = strlen((char const   *)(gl_buf + pos));
    }
#line 1244
    if (tmp < sizeof(gl_killbuf___0)) {
      {
#line 1245
      strcpy((char */* __restrict  */)(gl_killbuf___0), (char const   */* __restrict  */)(gl_buf + pos));
#line 1246
      gl_buf[pos] = (char )'\000';
#line 1247
      gl_fixup___0(gl_prompt___0, pos, pos);
      }
    } else {
      {
#line 1249
      gl_beep___0();
      }
    }
  } else {
    {
#line 1249
    gl_beep___0();
    }
  }
#line 1250
  return;
}
}
#line 1252 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_killword___0(int direction ) 
{ 
  int pos ;
  int startpos ;
  int tmp ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1255
  pos = gl_pos___0;
#line 1256
  startpos = gl_pos___0;
#line 1260
  if (direction > 0) {
    {
#line 1261
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1261
      tmp___0 = __ctype_b_loc();
      }
#line 1261
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1261
        goto while_break;
      } else
#line 1261
      if (! (pos < gl_cnt___0)) {
#line 1261
        goto while_break;
      }
#line 1262
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1263
      tmp___1 = __ctype_b_loc();
      }
#line 1263
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1263
        if (! (pos < gl_cnt___0)) {
#line 1263
          goto while_break___0;
        }
      } else {
#line 1263
        goto while_break___0;
      }
#line 1264
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1266
    if (pos > 0) {
#line 1267
      pos --;
    }
    {
#line 1268
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1268
      tmp___2 = __ctype_b_loc();
      }
#line 1268
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1268
        if (! (pos > 0)) {
#line 1268
          goto while_break___1;
        }
      } else {
#line 1268
        goto while_break___1;
      }
#line 1269
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1270
      tmp___3 = __ctype_b_loc();
      }
#line 1270
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1270
        goto while_break___2;
      } else
#line 1270
      if (! (pos > 0)) {
#line 1270
        goto while_break___2;
      }
#line 1271
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1272
    if (pos < gl_cnt___0) {
      {
#line 1272
      tmp___4 = __ctype_b_loc();
      }
#line 1272
      if ((int const   )*(*tmp___4 + (int )gl_buf[pos]) & 8192) {
#line 1273
        pos ++;
      }
    }
  }
#line 1275
  if (pos < startpos) {
#line 1276
    tmp = pos;
#line 1277
    pos = startpos;
#line 1278
    startpos = tmp;
  }
#line 1280
  if ((size_t )(pos - startpos) >= sizeof(gl_killbuf___0)) {
    {
#line 1281
    gl_beep___0();
    }
#line 1282
    return;
  }
  {
#line 1284
  memcpy((void */* __restrict  */)(gl_killbuf___0), (void const   */* __restrict  */)(gl_buf + startpos),
         (size_t )(pos - startpos));
#line 1285
  gl_killbuf___0[pos - startpos] = (char )'\000';
#line 1286
  tmp___5 = __ctype_b_loc();
  }
#line 1286
  if ((int const   )*(*tmp___5 + (int )gl_killbuf___0[(pos - startpos) - 1]) & 8192) {
#line 1287
    gl_killbuf___0[(pos - startpos) - 1] = (char )'\000';
  }
  {
#line 1288
  gl_fixup___0(gl_prompt___0, -1, startpos);
#line 1289
  i___0 = 0;
#line 1289
  tmp = pos - startpos;
  }
  {
#line 1289
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1289
    if (! (i___0 < tmp)) {
#line 1289
      goto while_break___3;
    }
    {
#line 1290
    gl_del___0(0, 0);
#line 1289
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1291
  return;
}
}
#line 1293 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_word___0(int direction ) 
{ 
  int pos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1298
  pos = gl_pos___0;
#line 1300
  if (direction > 0) {
    {
#line 1301
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1301
      tmp = __ctype_b_loc();
      }
#line 1301
      if ((int const   )*(*tmp + (int )gl_buf[pos]) & 8192) {
#line 1301
        goto while_break;
      } else
#line 1301
      if (! (pos < gl_cnt___0)) {
#line 1301
        goto while_break;
      }
#line 1302
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1303
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1303
      tmp___0 = __ctype_b_loc();
      }
#line 1303
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1303
        if (! (pos < gl_cnt___0)) {
#line 1303
          goto while_break___0;
        }
      } else {
#line 1303
        goto while_break___0;
      }
#line 1304
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1306
    if (pos > 0) {
#line 1307
      pos --;
    }
    {
#line 1308
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1308
      tmp___1 = __ctype_b_loc();
      }
#line 1308
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1308
        if (! (pos > 0)) {
#line 1308
          goto while_break___1;
        }
      } else {
#line 1308
        goto while_break___1;
      }
#line 1309
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1310
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1310
      tmp___2 = __ctype_b_loc();
      }
#line 1310
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1310
        goto while_break___2;
      } else
#line 1310
      if (! (pos > 0)) {
#line 1310
        goto while_break___2;
      }
#line 1311
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1312
    if (pos < gl_cnt___0) {
      {
#line 1312
      tmp___3 = __ctype_b_loc();
      }
#line 1312
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1313
        pos ++;
      }
    }
  }
  {
#line 1315
  gl_fixup___0(gl_prompt___0, -1, pos);
  }
#line 1316
  return;
}
}
#line 1318 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_redraw___0(void) 
{ 


  {
#line 1322
  if (gl_init_done___0 > 0) {
    {
#line 1323
    gl_putc___0('\n');
#line 1324
    gl_fixup___0(gl_prompt___0, -2, gl_pos___0);
    }
  }
#line 1326
  return;
}
}
#line 1344 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_shift___0  ;
#line 1345 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int off_right___0  ;
#line 1346 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int off_left___0  ;
#line 1347 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char last_prompt___0[80]  = {      (char )'\000'};
#line 1328 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_fixup___0(char const   *prompt , int change , int cursor ) 
{ 
  int left ;
  int right ;
  int pad ;
  int backup ;
  int new_shift ;
  int extra ;
  int i___0 ;
  int new_right ;
  int l1 ;
  int l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1348
  left = 0;
#line 1348
  right = -1;
#line 1354
  new_right = -1;
#line 1357
  if (change == -2) {
    {
#line 1358
    off_left___0 = 0;
#line 1358
    off_right___0 = off_left___0;
#line 1358
    gl_shift___0 = off_right___0;
#line 1358
    gl_cnt___0 = gl_shift___0;
#line 1358
    gl_pos___0 = gl_cnt___0;
#line 1359
    gl_putc___0('\r');
#line 1360
    gl_puts___0(prompt);
#line 1361
    strncpy((char */* __restrict  */)(last_prompt___0), (char const   */* __restrict  */)prompt,
            sizeof(last_prompt___0) - 1UL);
#line 1362
    last_prompt___0[sizeof(last_prompt___0) - 1UL] = (char )'\000';
#line 1363
    change = 0;
#line 1364
    tmp = (*gl_strlen)(prompt);
#line 1364
    l2 = (int )tmp;
#line 1365
    gl_width___0 = gl_termw___0 - l2;
    }
  } else {
    {
#line 1366
    tmp___2 = strcmp(prompt, (char const   *)(last_prompt___0));
    }
#line 1366
    if (tmp___2 != 0) {
      {
#line 1367
      tmp___0 = (*gl_strlen)((char const   *)(last_prompt___0));
#line 1367
      l1 = (int )tmp___0;
#line 1368
      tmp___1 = (*gl_strlen)(prompt);
#line 1368
      l2 = (int )tmp___1;
#line 1369
      gl_cnt___0 = (gl_cnt___0 + l1) - l2;
#line 1370
      strcpy((char */* __restrict  */)(last_prompt___0), (char const   */* __restrict  */)prompt);
#line 1371
      gl_putc___0('\r');
#line 1372
      gl_puts___0(prompt);
#line 1373
      gl_pos___0 = gl_shift___0;
#line 1374
      gl_width___0 = gl_termw___0 - l2;
#line 1375
      change = 0;
      }
    }
  }
#line 1377
  if (off_right___0) {
#line 1377
    pad = gl_width___0 - 1;
  } else {
#line 1377
    pad = gl_cnt___0 - gl_shift___0;
  }
#line 1378
  backup = gl_pos___0 - gl_shift___0;
#line 1379
  if (change >= 0) {
    {
#line 1380
    tmp___3 = strlen((char const   *)(gl_buf));
#line 1380
    gl_cnt___0 = (int )tmp___3;
    }
#line 1381
    if (change > gl_cnt___0) {
#line 1382
      change = gl_cnt___0;
    }
  }
#line 1384
  if (cursor > gl_cnt___0) {
#line 1385
    if (cursor != 2048) {
#line 1386
      if (gl_ellipses_during_completion == 0) {
        {
#line 1387
        gl_beep___0();
        }
      }
    }
#line 1390
    cursor = gl_cnt___0;
  }
#line 1392
  if (cursor < 0) {
    {
#line 1393
    gl_beep___0();
#line 1394
    cursor = 0;
    }
  }
#line 1396
  if (off_right___0) {
#line 1397
    extra = 2;
  } else
#line 1396
  if (off_left___0) {
#line 1396
    if (cursor < (gl_shift___0 + gl_width___0) - gl_scroll___0 / 2) {
#line 1397
      extra = 2;
    } else {
#line 1399
      extra = 0;
    }
  } else {
#line 1399
    extra = 0;
  }
#line 1400
  new_shift = ((cursor + extra) + gl_scroll___0) - gl_width___0;
#line 1401
  if (new_shift > 0) {
#line 1402
    new_shift /= gl_scroll___0;
#line 1403
    new_shift *= gl_scroll___0;
  } else {
#line 1405
    new_shift = 0;
  }
#line 1406
  if (new_shift != gl_shift___0) {
#line 1407
    gl_shift___0 = new_shift;
#line 1408
    if (gl_shift___0) {
#line 1408
      off_left___0 = 1;
    } else {
#line 1408
      off_left___0 = 0;
    }
#line 1409
    if (gl_cnt___0 > (gl_shift___0 + gl_width___0) - 1) {
#line 1409
      off_right___0 = 1;
    } else {
#line 1409
      off_right___0 = 0;
    }
#line 1410
    left = gl_shift___0;
#line 1411
    if (off_right___0) {
#line 1411
      right = (gl_shift___0 + gl_width___0) - 2;
    } else {
#line 1411
      right = gl_cnt___0;
    }
#line 1411
    new_right = right;
  } else
#line 1412
  if (change >= 0) {
#line 1413
    if (change < gl_shift___0 + off_left___0) {
#line 1414
      left = gl_shift___0;
    } else {
#line 1416
      left = change;
#line 1417
      backup = gl_pos___0 - change;
    }
#line 1419
    if (gl_cnt___0 > (gl_shift___0 + gl_width___0) - 1) {
#line 1419
      off_right___0 = 1;
    } else {
#line 1419
      off_right___0 = 0;
    }
#line 1420
    if (off_right___0) {
#line 1420
      right = (gl_shift___0 + gl_width___0) - 2;
    } else {
#line 1420
      right = gl_cnt___0;
    }
#line 1421
    if (gl_extent___0) {
#line 1421
      if (right > left + gl_extent___0) {
#line 1421
        new_right = left + gl_extent___0;
      } else {
#line 1421
        new_right = right;
      }
    } else {
#line 1421
      new_right = right;
    }
  }
#line 1424
  if (off_right___0) {
#line 1424
    tmp___4 = gl_width___0 - 1;
  } else {
#line 1424
    tmp___4 = gl_cnt___0 - gl_shift___0;
  }
#line 1424
  pad -= tmp___4;
#line 1425
  if (pad < 0) {
#line 1425
    pad = 0;
  } else {
#line 1425
    pad = pad;
  }
#line 1426
  if (left <= right) {
#line 1427
    i___0 = 0;
    {
#line 1427
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1427
      if (! (i___0 < backup)) {
#line 1427
        goto while_break;
      }
      {
#line 1428
      gl_putc___0('\b');
#line 1427
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1429
    if (left == gl_shift___0) {
#line 1429
      if (off_left___0) {
        {
#line 1430
        gl_putc___0('$');
#line 1431
        left ++;
        }
      }
    }
#line 1433
    i___0 = left;
    {
#line 1433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1433
      if (! (i___0 < new_right)) {
#line 1433
        goto while_break___0;
      }
      {
#line 1434
      gl_putc___0((int )gl_buf[i___0]);
#line 1433
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1435
    gl_pos___0 = new_right;
#line 1436
    if (off_right___0) {
#line 1436
      if (new_right == right) {
        {
#line 1437
        gl_putc___0('$');
#line 1438
        gl_pos___0 ++;
        }
      } else {
#line 1436
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1440
      i___0 = 0;
      {
#line 1440
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1440
        if (! (i___0 < pad)) {
#line 1440
          goto while_break___1;
        }
        {
#line 1441
        gl_putc___0(' ');
#line 1440
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1442
      gl_pos___0 += pad;
    }
  }
#line 1445
  i___0 = gl_pos___0 - cursor;
#line 1446
  if (i___0 > 0) {
    {
#line 1447
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1447
      tmp___5 = i___0;
#line 1447
      i___0 --;
#line 1447
      if (! tmp___5) {
#line 1447
        goto while_break___2;
      }
      {
#line 1448
      gl_putc___0('\b');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1450
    i___0 = gl_pos___0;
    {
#line 1450
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1450
      if (! (i___0 < cursor)) {
#line 1450
        goto while_break___3;
      }
      {
#line 1451
      gl_putc___0((int )gl_buf[i___0]);
#line 1450
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1453
  gl_pos___0 = cursor;
#line 1454
  return;
}
}
#line 1456 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_tab___0(char *buf , int offset , int *loc , size_t bufsize ) 
{ 
  int i___0 ;
  int count ;
  int len ;
  size_t tmp ;

  {
  {
#line 1462
  tmp = strlen((char const   *)buf);
#line 1462
  len = (int )tmp;
#line 1463
  count = 8 - (offset + *loc) % 8;
#line 1464
  i___0 = len;
  }
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    if (! (i___0 >= *loc)) {
#line 1464
      goto while_break;
    }
#line 1465
    if (i___0 + count < (int )bufsize) {
#line 1466
      *(buf + (i___0 + count)) = *(buf + i___0);
    }
#line 1464
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1467
  i___0 = 0;
  {
#line 1467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1467
    if (! (i___0 < count)) {
#line 1467
      goto while_break___0;
    }
#line 1468
    if (*loc + i___0 < (int )bufsize) {
#line 1469
      *(buf + (*loc + i___0)) = (char )' ';
    }
#line 1467
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1470
  i___0 = *loc;
#line 1471
  *loc = i___0 + count;
#line 1472
  return (i___0);
}
}
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int hist_pos___0  =    0;
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int hist_last___0  =    0;
#line 1482 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char *hist_buf___0[100]  ;
#line 1483 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char hist_empty_elem___0[2]  = {      (char )'\000'};
#line 1485 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void hist_init___0(void) 
{ 
  int i___0 ;

  {
#line 1490
  hist_buf___0[0] = hist_empty_elem___0;
#line 1491
  i___0 = 1;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if (! (i___0 < 100)) {
#line 1491
      goto while_break;
    }
#line 1492
    hist_buf___0[i___0] = (char *)0;
#line 1491
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1493
  hist_last___0 = 0;
#line 1493
  hist_pos___0 = hist_last___0;
#line 1494
  return;
}
}
#line 1496 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void hist_dispose___0(void) 
{ 
  int i___0 ;

  {
#line 1501
  i___0 = 0;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! (i___0 < 100)) {
#line 1501
      goto while_break;
    }
#line 1502
    if ((unsigned long )hist_buf___0[i___0] != (unsigned long )(hist_empty_elem___0)) {
#line 1502
      if ((unsigned long )hist_buf___0[i___0] != (unsigned long )((char *)0)) {
        {
#line 1503
        free((void *)hist_buf___0[i___0]);
#line 1504
        hist_buf___0[i___0] = (char *)0;
        }
      }
    }
#line 1501
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1509
  hist_buf___0[0] = hist_empty_elem___0;
#line 1510
  hist_last___0 = 0;
#line 1510
  hist_pos___0 = hist_last___0;
#line 1511
  return;
}
}
#line 1516 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char *prev___0  =    (char *)0;
#line 1545 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char *hist_prev___0(void) 
{ 
  char *p___5 ;
  int next ;

  {
#line 1549
  p___5 = (char *)0;
#line 1550
  next = ((hist_pos___0 - 1) + 100) % 100;
#line 1552
  if ((unsigned long )hist_buf___0[hist_pos___0] != (unsigned long )((char *)0)) {
#line 1552
    if (next != hist_last___0) {
#line 1553
      hist_pos___0 = next;
#line 1554
      p___5 = hist_buf___0[hist_pos___0];
    }
  }
#line 1556
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1557
    p___5 = hist_empty_elem___0;
#line 1558
    gl_beep___0();
    }
  }
#line 1560
  return (p___5);
}
}
#line 1563 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char *hist_next___0(void) 
{ 
  char *p___5 ;

  {
#line 1567
  p___5 = (char *)0;
#line 1569
  if (hist_pos___0 != hist_last___0) {
#line 1570
    hist_pos___0 = (hist_pos___0 + 1) % 100;
#line 1571
    p___5 = hist_buf___0[hist_pos___0];
  }
#line 1573
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1574
    p___5 = hist_empty_elem___0;
#line 1575
    gl_beep___0();
    }
  }
#line 1577
  return (p___5);
}
}
#line 1580 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char *hist_save___0(char const   * const  p___5 ) 
{ 
  char *s ;
  size_t len ;
  size_t tmp ;
  char *nl___0 ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1584
  s = (char *)0;
#line 1585
  tmp = strlen((char const   *)p___5);
#line 1585
  len = tmp;
#line 1586
  tmp___0 = strpbrk((char const   *)p___5, "\n\r");
#line 1586
  nl___0 = tmp___0;
  }
#line 1588
  if (nl___0) {
    {
#line 1589
    tmp___1 = malloc(len);
#line 1589
    s = (char *)tmp___1;
    }
#line 1589
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1590
      strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5,
              len - 1UL);
#line 1591
      *(s + (len - 1UL)) = (char)0;
      }
    }
  } else {
    {
#line 1594
    tmp___2 = malloc(len + 1UL);
#line 1594
    s = (char *)tmp___2;
    }
#line 1594
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1595
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5);
      }
    }
  }
#line 1598
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 1599
    gl_error___0((char const   */* const  */)"\n*** Error: hist_save() failed on malloc\n");
    }
  }
#line 1600
  return (s);
}
}
#line 1662 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char search_prompt___0[101]  ;
#line 1663 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static char search_string___0[100]  ;
#line 1664 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int search_pos___0  =    0;
#line 1665 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int search_forw_flg___0  =    0;
#line 1666 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int search_last___0  =    0;
#line 1668 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void search_update___0(int c ) 
{ 


  {
#line 1671
  if (c == 0) {
#line 1672
    search_pos___0 = 0;
#line 1673
    search_string___0[0] = (char)0;
#line 1674
    search_prompt___0[0] = (char )'?';
#line 1675
    search_prompt___0[1] = (char )' ';
#line 1676
    search_prompt___0[2] = (char)0;
  } else
#line 1677
  if (c > 0) {
#line 1678
    search_string___0[search_pos___0] = (char )c;
#line 1679
    search_string___0[search_pos___0 + 1] = (char)0;
#line 1680
    search_prompt___0[search_pos___0] = (char )c;
#line 1681
    search_prompt___0[search_pos___0 + 1] = (char )'?';
#line 1682
    search_prompt___0[search_pos___0 + 2] = (char )' ';
#line 1683
    search_prompt___0[search_pos___0 + 3] = (char)0;
#line 1684
    search_pos___0 ++;
  } else
#line 1686
  if (search_pos___0 > 0) {
#line 1687
    search_pos___0 --;
#line 1688
    search_string___0[search_pos___0] = (char)0;
#line 1689
    search_prompt___0[search_pos___0] = (char )'?';
#line 1690
    search_prompt___0[search_pos___0 + 1] = (char )' ';
#line 1691
    search_prompt___0[search_pos___0 + 2] = (char)0;
  } else {
    {
#line 1693
    gl_beep___0();
#line 1694
    hist_pos___0 = hist_last___0;
    }
  }
#line 1697
  return;
}
}
#line 1699 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void search_addchar___0(int c ) 
{ 
  char *loc ;

  {
  {
#line 1704
  search_update___0(c);
  }
#line 1705
  if (c < 0) {
#line 1706
    if (search_pos___0 > 0) {
#line 1707
      hist_pos___0 = search_last___0;
    } else {
#line 1709
      gl_buf[0] = (char)0;
#line 1710
      hist_pos___0 = hist_last___0;
    }
    {
#line 1712
    strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)hist_buf___0[hist_pos___0]);
    }
  }
  {
#line 1714
  loc = strstr((char const   *)(gl_buf), (char const   *)(search_string___0));
  }
#line 1714
  if ((unsigned long )loc != (unsigned long )((char *)0)) {
    {
#line 1715
    gl_fixup___0((char const   *)(search_prompt___0), 0, (int )(loc - gl_buf));
    }
  } else
#line 1716
  if (search_pos___0 > 0) {
#line 1717
    if (search_forw_flg___0) {
      {
#line 1718
      search_forw___0(0);
      }
    } else {
      {
#line 1720
      search_back___0(0);
      }
    }
  } else {
    {
#line 1723
    gl_fixup___0((char const   *)(search_prompt___0), 0, 0);
    }
  }
#line 1725
  return;
}
}
#line 1727 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void search_term___0(void) 
{ 


  {
#line 1730
  gl_search_mode___0 = 0;
#line 1731
  if ((int )gl_buf[0] == 0) {
#line 1732
    hist_pos___0 = hist_last___0;
  }
#line 1733
  if (gl_in_hook) {
    {
#line 1734
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 1735
  gl_fixup___0(gl_prompt___0, 0, gl_pos___0);
  }
#line 1736
  return;
}
}
#line 1738 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void search_back___0(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1741
  found = 0;
#line 1744
  search_forw_flg___0 = 0;
#line 1745
  if (gl_search_mode___0 == 0) {
    {
#line 1746
    hist_pos___0 = hist_last___0;
#line 1746
    search_last___0 = hist_pos___0;
#line 1747
    search_update___0(0);
#line 1748
    gl_search_mode___0 = 1;
#line 1749
    gl_buf[0] = (char)0;
#line 1750
    gl_fixup___0((char const   *)(search_prompt___0), 0, 0);
    }
  } else
#line 1751
  if (search_pos___0 > 0) {
    {
#line 1752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1752
      if (! (! found)) {
#line 1752
        goto while_break;
      }
      {
#line 1753
      p___5 = hist_prev___0();
      }
#line 1754
      if ((int )*p___5 == 0) {
        {
#line 1755
        gl_buf[0] = (char)0;
#line 1756
        gl_fixup___0((char const   *)(search_prompt___0), 0, 0);
#line 1757
        found = 1;
        }
      } else {
        {
#line 1758
        loc = strstr((char const   *)p___5, (char const   *)(search_string___0));
        }
#line 1758
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1759
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1760
          gl_fixup___0((char const   *)(search_prompt___0), 0, (int )(loc - p___5));
          }
#line 1761
          if (new_search) {
#line 1762
            search_last___0 = hist_pos___0;
          }
#line 1763
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1768
    gl_beep___0();
    }
  }
#line 1770
  return;
}
}
#line 1772 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void search_forw___0(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1775
  found = 0;
#line 1778
  search_forw_flg___0 = 1;
#line 1779
  if (gl_search_mode___0 == 0) {
    {
#line 1780
    hist_pos___0 = hist_last___0;
#line 1780
    search_last___0 = hist_pos___0;
#line 1781
    search_update___0(0);
#line 1782
    gl_search_mode___0 = 1;
#line 1783
    gl_buf[0] = (char)0;
#line 1784
    gl_fixup___0((char const   *)(search_prompt___0), 0, 0);
    }
  } else
#line 1785
  if (search_pos___0 > 0) {
    {
#line 1786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1786
      if (! (! found)) {
#line 1786
        goto while_break;
      }
      {
#line 1787
      p___5 = hist_next___0();
      }
#line 1788
      if ((int )*p___5 == 0) {
        {
#line 1789
        gl_buf[0] = (char)0;
#line 1790
        gl_fixup___0((char const   *)(search_prompt___0), 0, 0);
#line 1791
        found = 1;
        }
      } else {
        {
#line 1792
        loc = strstr((char const   *)p___5, (char const   *)(search_string___0));
        }
#line 1792
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1793
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1794
          gl_fixup___0((char const   *)(search_prompt___0), 0, (int )(loc - p___5));
          }
#line 1795
          if (new_search) {
#line 1796
            search_last___0 = hist_pos___0;
          }
#line 1797
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1801
    gl_beep___0();
    }
  }
#line 1803
  return;
}
}
#line 1806 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_beep___0(void) 
{ 


  {
  {
#line 1812
  gl_putc___0('\a');
  }
#line 1814
  return;
}
}
#line 1818 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_display_matches_sort_proc___0(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 1821
  tmp = strcasecmp((char const   *)*((char const   * const  *)a), (char const   *)*((char const   * const  *)b));
  }
#line 1821
  return (tmp);
}
}
#line 1829 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static void gl_display_matches___0(int nused ) 
{ 
  char buf[256] ;
  char buf2[256] ;
  size_t ilen ;
  size_t imaxlen ;
  int i___0 ;
  int j ;
  int k ;
  int l ;
  int glen ;
  int allmatch ;
  int nmax ;
  int ncol ;
  int colw ;
  int nrow ;
  char *cp1 ;
  char *cp2 ;
  char *lim ;
  char *itemp ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1840
  gl_putc___0('\n');
  }
#line 1841
  if (nused == 0) {
    {
#line 1842
    gl_beep___0();
#line 1843
    gl_puts___0("    (no matches)");
#line 1844
    gl_putc___0('\n');
    }
  } else {
    {
#line 1846
    qsort((void *)gl_matchlist___0, (size_t )nused, sizeof(char *), & gl_display_matches_sort_proc___0);
#line 1849
    glen = 0;
    }
    {
#line 1849
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1850
      allmatch = 1;
#line 1851
      if ((int )*(*(gl_matchlist___0 + 0) + glen) == 0) {
        {
#line 1852
        gl_beep___0();
#line 1853
        gl_putc___0('\n');
        }
#line 1854
        return;
      }
#line 1856
      i___0 = 1;
      {
#line 1856
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1856
        if (! (i___0 < nused)) {
#line 1856
          goto while_break___0;
        }
#line 1857
        if ((int )*(*(gl_matchlist___0 + 0) + glen) != (int )*(*(gl_matchlist___0 + i___0) + glen)) {
#line 1858
          allmatch = 0;
#line 1859
          goto while_break___0;
        }
#line 1856
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1862
      if (allmatch == 0) {
#line 1863
        goto while_break;
      }
#line 1849
      glen ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1866
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1866
      if (! (glen > 0)) {
#line 1866
        goto while_break___1;
      }
      {
#line 1867
      tmp = __ctype_b_loc();
      }
#line 1867
      if (! ((int const   )*(*tmp + (int )*(*(gl_matchlist___0 + 0) + (glen - 1))) & 8)) {
#line 1868
        goto while_break___1;
      }
#line 1869
      glen --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1872
    nmax = nused;
#line 1873
    imaxlen = strlen((char const   *)*(gl_matchlist___0 + 0));
#line 1874
    i___0 = 1;
    }
    {
#line 1874
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1874
      if (! (i___0 < nused)) {
#line 1874
        goto while_break___2;
      }
      {
#line 1875
      ilen = strlen((char const   *)*(gl_matchlist___0 + i___0));
      }
#line 1876
      if (ilen > imaxlen) {
#line 1877
        imaxlen = ilen;
      }
#line 1874
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1881
    if (imaxlen == (size_t )((unsigned int )glen)) {
      {
#line 1882
      gl_beep___0();
#line 1883
      gl_putc___0('\n');
      }
#line 1884
      return;
    }
#line 1886
    imaxlen -= (size_t )glen;
#line 1888
    ncol = (gl_termw___0 - 8) / ((int )imaxlen + 2);
#line 1889
    if (ncol < 1) {
#line 1890
      ncol = 1;
    }
#line 1892
    colw = (gl_termw___0 - 8) / ncol;
#line 1893
    nrow = nmax / ncol;
#line 1894
    if (nused % ncol != 0) {
#line 1895
      nrow ++;
    }
#line 1897
    if (nrow > gl_termh___0 - 4) {
#line 1898
      nrow = gl_termh___0 - 4;
#line 1899
      nmax = ncol * nrow;
    }
#line 1902
    i___0 = 0;
    {
#line 1902
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1902
      if (! (i___0 < (int )sizeof(buf2))) {
#line 1902
        goto while_break___3;
      }
#line 1903
      buf2[i___0] = (char )' ';
#line 1902
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1905
    j = 0;
    {
#line 1905
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1905
      if (! (j < nrow)) {
#line 1905
        goto while_break___4;
      }
      {
#line 1906
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(buf2),
             sizeof(buf));
#line 1907
      i___0 = 0;
#line 1907
      k = j;
#line 1907
      l = 4;
      }
      {
#line 1907
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1907
        if (! (i___0 < ncol)) {
#line 1907
          goto while_break___5;
        }
#line 1908
        if (k >= nmax) {
#line 1909
          goto __Cont;
        }
        {
#line 1910
        itemp = *(gl_matchlist___0 + k) + glen;
#line 1911
        cp1 = buf + l;
#line 1912
        tmp___0 = strlen((char const   *)itemp);
#line 1912
        lim = cp1 + (int )tmp___0;
        }
#line 1913
        if ((unsigned long )lim >= (unsigned long )(buf + sizeof(buf))) {
#line 1914
          goto __Cont;
        }
#line 1915
        cp2 = itemp;
        {
#line 1916
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1916
          if (! ((unsigned long )cp1 < (unsigned long )lim)) {
#line 1916
            goto while_break___6;
          }
#line 1917
          tmp___1 = cp1;
#line 1917
          cp1 ++;
#line 1917
          tmp___2 = cp2;
#line 1917
          cp2 ++;
#line 1917
          *tmp___1 = *tmp___2;
        }
        while_break___6: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 1907
        i___0 ++;
#line 1907
        k += nrow;
#line 1907
        l += colw;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1919
      cp1 = buf;
#line 1920
      cp1 += sizeof(buf);
#line 1921
      cp1 --;
      {
#line 1922
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1922
        if (! ((int )*cp1 == 32)) {
#line 1922
          goto while_break___7;
        }
#line 1923
        cp1 --;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1924
      cp1 ++;
#line 1925
      *cp1 = (char )'\000';
#line 1926
      gl_puts___0((char const   *)(buf));
#line 1927
      gl_putc___0('\n');
#line 1905
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1930
    if (nused > nmax) {
      {
#line 1931
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"    ... %d others omitted ...",
              nused - nmax);
#line 1932
      gl_puts___0((char const   *)(buf));
#line 1933
      gl_putc___0('\n');
      }
    }
  }
  {
#line 1936
  gl_fixup___0(gl_prompt___0, -2, 2048);
  }
#line 1937
  return;
}
}
#line 1942 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int gl_do_tab_completion___0(char *buf , int *loc , size_t bufsize , int tabtab ) 
{ 
  char *startp ;
  size_t startoff ;
  size_t amt ;
  int c ;
  int qmode ;
  char *qstart ;
  char *lastspacestart ;
  char *cp ;
  int ntoalloc ;
  int nused ;
  int nprocused ;
  int nalloced ;
  int i___0 ;
  char **newgl_matchlist ;
  char *strtoadd ;
  char *strtoadd1 ;
  int addquotes ;
  size_t llen ;
  size_t mlen ;
  size_t glen ;
  int allmatch ;
  char *curposp ;
  size_t lenaftercursor ;
  char *matchpfx ;
  int wasateol ;
  char ellipsessave[4] ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
  {
#line 1967
  llen = strlen((char const   *)buf);
#line 1968
  memset((void *)(buf + llen), 0, bufsize - llen);
#line 1969
  bufsize -= 4UL;
#line 1970
  curposp = buf + *loc;
#line 1971
  wasateol = (int )*curposp == 0;
#line 1972
  lenaftercursor = llen - (size_t )(curposp - buf);
  }
#line 1973
  if (gl_ellipses_during_completion != 0) {
    {
#line 1974
    memcpy((void */* __restrict  */)(ellipsessave), (void const   */* __restrict  */)curposp,
           (size_t )4);
#line 1975
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)"... ",
           (size_t )4);
#line 1976
    gl_fixup___0(gl_prompt___0, gl_pos___0, gl_pos___0 + 3);
#line 1977
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)(ellipsessave),
           (size_t )4);
    }
  }
#line 1980
  qmode = 0;
#line 1981
  qstart = (char *)((void *)0);
#line 1982
  lastspacestart = (char *)((void *)0);
#line 1983
  matchpfx = (char *)((void *)0);
#line 1985
  cp = buf;
  {
#line 1986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1986
    if (! ((unsigned long )cp < (unsigned long )curposp)) {
#line 1986
      goto while_break;
    }
#line 1987
    tmp = cp;
#line 1987
    cp ++;
#line 1987
    c = (int )*tmp;
#line 1988
    if (c == 0) {
#line 1989
      goto while_break;
    }
#line 1990
    if (c == 34) {
#line 1990
      goto _L;
    } else
#line 1990
    if (c == 39) {
      _L: /* CIL Label */ 
#line 1991
      if (qmode == c) {
#line 1993
        qstart = (char *)((void *)0);
#line 1994
        qmode = 0;
      } else
#line 1995
      if (! (qmode != 0)) {
#line 1999
        qmode = c;
#line 2000
        qstart = cp - 1;
      }
    } else {
      {
#line 2002
      tmp___0 = __ctype_b_loc();
      }
#line 2002
      if ((int const   )*(*tmp___0 + c) & 8192) {
#line 2002
        if (qmode == 0) {
#line 2004
          lastspacestart = cp - 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  if ((unsigned long )qstart != (unsigned long )((void *)0)) {
#line 2011
    startp = qstart + 1;
  } else
#line 2012
  if ((unsigned long )lastspacestart != (unsigned long )((void *)0)) {
#line 2013
    startp = lastspacestart + 1;
  } else {
#line 2015
    startp = buf;
  }
  {
#line 2017
  cp = startp;
#line 2018
  mlen = (size_t )(curposp - cp);
#line 2020
  tmp___1 = malloc(mlen + 1UL);
#line 2020
  matchpfx = (char *)tmp___1;
#line 2021
  memcpy((void */* __restrict  */)matchpfx, (void const   */* __restrict  */)cp, mlen);
#line 2022
  *(matchpfx + mlen) = (char )'\000';
#line 2026
  nused = 0;
#line 2027
  ntoalloc = 64;
#line 2028
  tmp___2 = malloc(sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2028
  newgl_matchlist = (char **)tmp___2;
  }
#line 2029
  if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
    {
#line 2030
    free((void *)matchpfx);
#line 2031
    gl_beep___0();
    }
#line 2032
    return (0);
  }
#line 2034
  gl_matchlist___0 = newgl_matchlist;
#line 2035
  nalloced = ntoalloc;
#line 2036
  i___0 = nused;
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i___0 <= nalloced)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(gl_matchlist___0 + i___0) = (char *)((void *)0);
#line 2036
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2039
  gl_completion_exact_match_extra_char = ' ';
#line 2040
  nprocused = 0;
  {
#line 2040
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2041
    if (nused == nalloced) {
      {
#line 2042
      ntoalloc += 64;
#line 2043
      tmp___3 = realloc((void *)((char *)gl_matchlist___0), sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2043
      newgl_matchlist = (char **)tmp___3;
      }
#line 2044
      if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
#line 2046
        i___0 = 0;
        {
#line 2046
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2046
          if (! (i___0 < nused)) {
#line 2046
            goto while_break___2;
          }
          {
#line 2047
          free((void *)*(gl_matchlist___0 + i___0));
#line 2046
          i___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2048
        free((void *)gl_matchlist___0);
#line 2049
        gl_matchlist___0 = (char **)((void *)0);
#line 2050
        gl_beep___0();
#line 2051
        free((void *)matchpfx);
        }
#line 2052
        return (0);
      }
#line 2054
      gl_matchlist___0 = newgl_matchlist;
#line 2055
      nalloced = ntoalloc;
#line 2056
      i___0 = nused;
      {
#line 2056
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2056
        if (! (i___0 <= nalloced)) {
#line 2056
          goto while_break___3;
        }
#line 2057
        *(gl_matchlist___0 + i___0) = (char *)((void *)0);
#line 2056
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2059
    cp = (*gl_completion_proc)((char const   *)matchpfx, nprocused);
    }
#line 2060
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2061
      goto while_break___1;
    }
#line 2062
    if ((int )*(cp + 0) == 46) {
#line 2062
      if ((int )*(cp + 1) == 0) {
#line 2063
        goto __Cont;
      } else
#line 2062
      if ((int )*(cp + 1) == 46) {
#line 2062
        if ((int )*(cp + 2) == 0) {
#line 2063
          goto __Cont;
        }
      }
    }
#line 2064
    tmp___4 = nused;
#line 2064
    nused ++;
#line 2064
    *(gl_matchlist___0 + tmp___4) = cp;
    __Cont: /* CIL Label */ 
#line 2040
    nprocused ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2067
  if (gl_ellipses_during_completion != 0) {
    {
#line 2068
    gl_fixup___0(gl_prompt___0, gl_pos___0, gl_pos___0);
#line 2069
    gl_puts___0("    ");
    }
  }
#line 2073
  strtoadd = (char *)((void *)0);
#line 2074
  strtoadd1 = (char *)((void *)0);
#line 2075
  amt = (size_t )0;
#line 2077
  if (gl_filename_quoting_desired > 0) {
#line 2077
    tmp___5 = 1;
  } else
#line 2077
  if (gl_filename_quoting_desired < 0) {
#line 2077
    if ((unsigned long )gl_completion_proc == (unsigned long )(& gl_local_filename_completion_proc)) {
#line 2077
      tmp___5 = 1;
    } else {
#line 2077
      tmp___5 = 0;
    }
  } else {
#line 2077
    tmp___5 = 0;
  }
#line 2077
  addquotes = tmp___5;
#line 2079
  if (nused == 1) {
#line 2081
    strtoadd = *(gl_matchlist___0 + 0);
  } else
#line 2082
  if (tabtab != 0) {
    {
#line 2084
    gl_display_matches___0(nused);
    }
  } else
#line 2085
  if (nused > 1) {
#line 2085
    if (mlen != 0UL) {
      {
#line 2087
      glen = strlen((char const   *)matchpfx);
      }
      {
#line 2087
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2088
        allmatch = 1;
#line 2089
        i___0 = 1;
        {
#line 2089
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2089
          if (! (i___0 < nused)) {
#line 2089
            goto while_break___5;
          }
#line 2090
          if ((int )*(*(gl_matchlist___0 + 0) + glen) != (int )*(*(gl_matchlist___0 + i___0) + glen)) {
#line 2091
            allmatch = 0;
#line 2092
            goto while_break___5;
          }
#line 2089
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2095
        if (allmatch == 0) {
#line 2096
          goto while_break___4;
        }
#line 2087
        glen ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2098
      tmp___6 = malloc(glen + 1UL);
#line 2098
      strtoadd1 = (char *)tmp___6;
      }
#line 2099
      if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
        {
#line 2100
        memcpy((void */* __restrict  */)strtoadd1, (void const   */* __restrict  */)*(gl_matchlist___0 + 0),
               glen);
#line 2101
        *(strtoadd1 + glen) = (char )'\000';
#line 2102
        strtoadd = strtoadd1;
        }
      }
    }
  }
#line 2106
  if ((unsigned long )strtoadd != (unsigned long )((void *)0)) {
#line 2107
    if (qmode == 0) {
#line 2107
      if (addquotes != 0) {
        {
#line 2108
        tmp___10 = strpbrk((char const   *)strtoadd, gl_filename_quote_characters);
        }
#line 2108
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          {
#line 2109
          tmp___8 = strchr((char const   *)strtoadd, '\"');
          }
#line 2109
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 2109
            qmode = '\"';
          } else {
#line 2109
            qmode = '\'';
          }
          {
#line 2110
          memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2111
          curposp ++;
#line 2112
          tmp___9 = startp;
#line 2112
          startp ++;
#line 2112
          *tmp___9 = (char )qmode;
          }
        }
      }
    }
    {
#line 2115
    startoff = (size_t )(startp - buf);
#line 2116
    amt = strlen((char const   *)strtoadd);
    }
#line 2117
    if ((amt + startoff) + lenaftercursor >= bufsize) {
#line 2118
      amt = bufsize - ((amt + startoff) + lenaftercursor);
    }
    {
#line 2119
    memmove((void *)((curposp + amt) - mlen), (void const   *)curposp, lenaftercursor + 1UL);
#line 2120
    curposp += amt - mlen;
#line 2121
    memcpy((void */* __restrict  */)startp, (void const   */* __restrict  */)strtoadd,
           amt);
    }
#line 2122
    if (nused == 1) {
#line 2124
      if (qmode != 0) {
        {
#line 2126
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2127
        curposp ++;
#line 2128
        *(buf + (amt + startoff)) = (char )qmode;
#line 2129
        amt ++;
        }
      }
      {
#line 2131
      memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2132
      curposp ++;
#line 2133
      *(buf + (amt + startoff)) = (char )gl_completion_exact_match_extra_char;
#line 2134
      amt ++;
      }
    } else
#line 2135
    if (! wasateol) {
      {
#line 2135
      tmp___11 = __ctype_b_loc();
      }
#line 2135
      if (! ((int const   )*(*tmp___11 + (int )*curposp) & 8192)) {
        {
#line 2139
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2140
        curposp ++;
#line 2141
        *(buf + (amt + startoff)) = (char )' ';
        }
      }
    }
#line 2143
    *loc = (int )(startoff + amt);
#line 2145
    if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
      {
#line 2146
      free((void *)strtoadd1);
      }
    }
  }
#line 2150
  i___0 = 0;
  {
#line 2150
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2150
    if (! (i___0 < nused)) {
#line 2150
      goto while_break___6;
    }
    {
#line 2151
    free((void *)*(gl_matchlist___0 + i___0));
#line 2150
    i___0 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2152
  free((void *)gl_matchlist___0);
#line 2153
  gl_matchlist___0 = (char **)((void *)0);
#line 2154
  free((void *)matchpfx);
  }
#line 2156
  return (0);
}
}
#line 2354 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static DIR *dir___0  =    (DIR *)((void *)0);
#line 2355 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static int filepfxoffset___0  ;
#line 2356 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/gl_getline.c"
static size_t filepfxlen___0  ;
#line 45 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
char *Dynscpy(char **dst  , ...) ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Dynscpy.c"
char *Dynscpy(char **dst  , ...) 
{ 
  va_list ap ;
  char const   *src ;
  char *newdst ;
  char *dcp ;
  size_t curLen ;
  size_t catLen ;
  size_t srcLen ;
  char const   *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 42
  if ((unsigned long )dst == (unsigned long )((char **)0)) {
#line 43
    return ((char *)((void *)0));
  }
  {
#line 45
  catLen = (size_t )0;
#line 46
  __builtin_va_start(ap, dst);
#line 47
  tmp = __builtin_va_arg(ap, char *);
#line 47
  src = tmp;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 48
      goto while_break;
    }
    {
#line 49
    tmp___0 = strlen(src);
#line 49
    catLen += tmp___0;
#line 50
    tmp___1 = __builtin_va_arg(ap, char *);
#line 50
    src = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  __builtin_va_end(ap);
#line 54
  curLen = (size_t )0;
#line 56
  tmp___2 = malloc((curLen + catLen) + 2UL);
#line 56
  newdst = (char *)tmp___2;
  }
#line 57
  if ((unsigned long )newdst == (unsigned long )((void *)0)) {
#line 58
    *dst = (char *)((void *)0);
#line 59
    return ((char *)((void *)0));
  }
  {
#line 62
  dcp = newdst + curLen;
#line 63
  __builtin_va_start(ap, dst);
#line 64
  tmp___3 = __builtin_va_arg(ap, char *);
#line 64
  src = tmp___3;
  }
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 65
      goto while_break___0;
    }
    {
#line 66
    srcLen = strlen(src);
#line 67
    memcpy((void */* __restrict  */)dcp, (void const   */* __restrict  */)src, srcLen);
#line 68
    dcp += srcLen;
#line 69
    tmp___4 = __builtin_va_arg(ap, char *);
#line 69
    src = tmp___4;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 71
  __builtin_va_end(ap);
#line 72
  *dcp = (char )'\000';
#line 74
  *dst = newdst;
  }
#line 75
  return (newdst);
}
}
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_slash.c"
char *FGets(char *str , size_t size , FILE *fp ) 
{ 
  char *cp ;
  char *nlptr ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 19
  cp = fgets((char */* __restrict  */)str, (int )size - 1, (FILE */* __restrict  */)fp);
  }
#line 20
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 21
    *(cp + ((int )size - 1)) = (char )'\000';
#line 22
    tmp = strlen((char const   *)cp);
#line 22
    nlptr = (cp + tmp) - 1;
    }
#line 23
    if ((int )*nlptr == 10) {
#line 24
      tmp___0 = nlptr;
#line 24
      nlptr --;
#line 24
      *tmp___0 = (char )'\000';
    }
#line 25
    if ((int )*nlptr == 13) {
#line 26
      *nlptr = (char )'\000';
    }
  } else {
    {
#line 28
    memset((void *)str, 0, size);
    }
  }
#line 30
  return (cp);
}
}
#line 36 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_slash.c"
void StrRemoveTrailingSlashes(char *dst ) 
{ 
  char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 42
  tmp = strlen((char const   *)dst);
#line 42
  cp = dst + tmp;
#line 43
  cp --;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if ((unsigned long )cp > (unsigned long )dst) {
#line 44
      if (! ((int )*cp == 47)) {
#line 44
        goto while_break;
      }
    } else {
#line 44
      goto while_break;
    }
#line 45
    tmp___0 = cp;
#line 45
    cp --;
#line 45
    *tmp___0 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 255 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SSendtoByName(int sfd , char const   * const  buf , size_t size , int fl , char const   * const  toAddrStr ,
                  int tlen ) ;
#line 256
int SendtoByName(int sfd , char const   * const  buf , size_t size , char const   * const  toAddrStr ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSendtoByName.c"
int SSendtoByName(int sfd , char const   * const  buf , size_t size , int fl , char const   * const  toAddrStr ,
                  int tlen ) 
{ 
  ssize_t nwrote ;
  int tleft ;
  int result ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  struct sockaddr_in toAddr ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __sighandler_t tmp___4 ;
  int *tmp___5 ;

  {
#line 15
  sigpipe = (void (*)(int  ))0;
#line 17
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if (size == 0UL) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if ((unsigned long )toAddrStr == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if ((int const   )*(toAddrStr + 0) == 0) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if (tlen <= 0) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  }
  {
#line 22
  result = AddrStrToAddr(toAddrStr, (struct sockaddr_in */* const  */)(& toAddr),
                         (int const   )-1);
  }
#line 22
  if (result < 0) {
#line 23
    return (result);
  }
  {
#line 26
  time(& now);
#line 27
  done = now + (time_t )tlen;
#line 28
  nwrote = (ssize_t )0;
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 30
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 31
      if (now >= done) {
        {
#line 32
        tmp___0 = __errno_location();
#line 32
        *tmp___0 = 110;
        }
#line 33
        return (-2);
      }
#line 35
      if (done > now) {
#line 35
        tleft = (int )(done - now);
      } else {
#line 35
        tleft = 0;
      }
      {
#line 36
      tmp___1 = __errno_location();
#line 36
      *tmp___1 = 0;
      }
      {
#line 37
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 37
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 37
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 42
      ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 46
      tv.tv_sec = (__time_t )((long long )tleft);
#line 47
      tv.tv_usec = (__suseconds_t )0;
#line 48
      result = select(sfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 49
      if (result >= 1) {
#line 51
        goto while_break___0;
      } else
#line 52
      if (result == 0) {
        {
#line 54
        tmp___2 = __errno_location();
#line 54
        *tmp___2 = 110;
        }
#line 55
        return (-2);
      } else {
        {
#line 56
        tmp___3 = __errno_location();
        }
#line 56
        if (*tmp___3 != 4) {
#line 57
          return (-1);
        }
      }
      {
#line 59
      time(& now);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 62
    if (sio_sigpipe_ignored_already) {
#line 62
      sigpipe = (void (*)(int  ))0;
    } else {
      {
#line 62
      tmp___4 = signal(13, (void (*)(int  ))1);
#line 62
      sigpipe = tmp___4;
      }
    }
    {
#line 63
    nwrote = sendto(sfd, (void const   *)buf, size, fl, (struct sockaddr  const  *)((struct sockaddr *)(& toAddr)),
                    (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 66
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 66
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
        {
#line 66
        signal(13, sigpipe);
        }
      }
    }
#line 68
    if (nwrote >= 0L) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp___5 = __errno_location();
    }
#line 70
    if (*tmp___5 != 4) {
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return ((int )nwrote);
}
}
#line 80 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSendtoByName.c"
int SendtoByName(int sfd , char const   * const  buf , size_t size , char const   * const  toAddrStr ) 
{ 
  int result ;
  struct sockaddr_in toAddr ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 85
  sigpipe = (void (*)(int  ))0;
#line 87
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 88
    tmp = __errno_location();
#line 88
    *tmp = 22;
    }
#line 89
    return (-1);
  } else
#line 87
  if (size == 0UL) {
    {
#line 88
    tmp = __errno_location();
#line 88
    *tmp = 22;
    }
#line 89
    return (-1);
  } else
#line 87
  if ((unsigned long )toAddrStr == (unsigned long )((void *)0)) {
    {
#line 88
    tmp = __errno_location();
#line 88
    *tmp = 22;
    }
#line 89
    return (-1);
  }
  {
#line 93
  result = AddrStrToAddr(toAddrStr, (struct sockaddr_in */* const  */)(& toAddr),
                         (int const   )-1);
  }
#line 93
  if (result < 0) {
#line 94
    return (result);
  }
#line 97
  if (sio_sigpipe_ignored_already) {
#line 97
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 97
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 97
    sigpipe = tmp___0;
    }
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp___1 = sendto(sfd, (void const   *)buf, size, 0, (struct sockaddr  const  *)((struct sockaddr *)(& toAddr)),
                     (socklen_t )sizeof(struct sockaddr_in ));
#line 99
    result = (int )tmp___1;
    }
#line 98
    if (result < 0) {
      {
#line 98
      tmp___2 = __errno_location();
      }
#line 98
      if (! (*tmp___2 == 4)) {
#line 98
        goto while_break;
      }
    } else {
#line 98
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 103
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 103
      signal(13, sigpipe);
      }
    }
  }
#line 105
  return (result);
}
}
#line 68 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
void DStrInit(DStr * const  dst ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrInit.c"
void DStrInit(DStr * const  dst ) 
{ 


  {
  {
#line 9
  memset((void *)dst, 0, sizeof(DStr ));
  }
#line 10
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 897
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getdomainname)(char *__name ,
                                                                                                    size_t __len ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 172 "/usr/include/netdb.h"
extern int gethostbyaddr_r(void const   * __restrict  __addr , __socklen_t __len ,
                           int __type , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 185
extern int gethostbyname2_r(char const   * __restrict  __name , int __af , struct hostent * __restrict  __result_buf ,
                            char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                            int * __restrict  __h_errnop ) ;
#line 185 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int GetHostByName(struct hostent * const  hp , char const   * const  name , char * const  hpbuf ,
                  size_t hpbufsize ) ;
#line 186
int GetHostByAddr(struct hostent * const  hp , void *addr , int asize , int atype ,
                  char * const  hpbuf , size_t hpbufsize ) ;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/DNSUtil.c"
int GetHostByName(struct hostent * const  hp , char const   * const  name , char * const  hpbuf ,
                  size_t hpbufsize ) 
{ 
  char *usehpbuf ;
  struct hostent *h ;
  int my_h_errno ;
  int rc ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 65
  usehpbuf = (char *)hpbuf;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp = __errno_location();
#line 67
    *tmp = 0;
#line 68
    my_h_errno = 0;
#line 69
    h = (struct hostent *)((void *)0);
#line 70
    memset((void *)usehpbuf, 0, hpbufsize);
#line 71
    rc = gethostbyname2_r((char const   */* __restrict  */)name, 2, (struct hostent */* __restrict  */)hp,
                          (char */* __restrict  */)usehpbuf, hpbufsize, (struct hostent **/* __restrict  */)(& h),
                          (int */* __restrict  */)(& my_h_errno));
    }
#line 72
    if (rc == 0) {
#line 72
      if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 73
        return (0);
      }
    }
#line 74
    if (rc == 34) {
#line 74
      goto _L;
    } else
#line 74
    if (rc == -1) {
      {
#line 74
      tmp___2 = __errno_location();
      }
#line 74
      if (*tmp___2 == 34) {
        _L: /* CIL Label */ 
        {
#line 75
        hpbufsize *= 2UL;
#line 76
        tmp___0 = __builtin_alloca(hpbufsize);
#line 76
        usehpbuf = (char *)tmp___0;
        }
#line 77
        if ((unsigned long )usehpbuf == (unsigned long )((void *)0)) {
          {
#line 78
          tmp___1 = __errno_location();
#line 78
          *tmp___1 = 12;
          }
#line 79
          return (-1);
        }
#line 81
        goto __Cont;
      }
    }
#line 83
    if (rc == 0) {
#line 83
      if (my_h_errno != 0) {
        {
#line 84
        tmp___3 = __errno_location();
#line 84
        *tmp___3 = 2;
        }
      }
    }
#line 85
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (-1);
}
}
#line 138 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/DNSUtil.c"
int GetHostByAddr(struct hostent * const  hp , void *addr , int asize , int atype ,
                  char * const  hpbuf , size_t hpbufsize ) 
{ 
  char *usehpbuf ;
  struct hostent *h ;
  int my_h_errno ;
  int rc ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 167
  usehpbuf = (char *)hpbuf;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    tmp = __errno_location();
#line 169
    *tmp = 0;
#line 170
    my_h_errno = 0;
#line 171
    h = (struct hostent *)((void *)0);
#line 172
    memset((void *)usehpbuf, 0, hpbufsize);
#line 173
    rc = gethostbyaddr_r((void const   */* __restrict  */)((struct in_addr  const  *)addr),
                         (__socklen_t )asize, atype, (struct hostent */* __restrict  */)hp,
                         (char */* __restrict  */)usehpbuf, hpbufsize, (struct hostent **/* __restrict  */)(& h),
                         (int */* __restrict  */)(& my_h_errno));
    }
#line 174
    if (rc == 0) {
#line 174
      if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 175
        return (0);
      }
    }
#line 176
    if (rc == 34) {
#line 176
      goto _L;
    } else
#line 176
    if (rc == -1) {
      {
#line 176
      tmp___2 = __errno_location();
      }
#line 176
      if (*tmp___2 == 34) {
        _L: /* CIL Label */ 
        {
#line 177
        hpbufsize *= 2UL;
#line 178
        tmp___0 = __builtin_alloca(hpbufsize);
#line 178
        usehpbuf = (char *)tmp___0;
        }
#line 179
        if ((unsigned long )usehpbuf == (unsigned long )((void *)0)) {
          {
#line 180
          tmp___1 = __errno_location();
#line 180
          *tmp___1 = 12;
          }
#line 181
          return (-1);
        }
#line 183
        goto __Cont;
      }
    }
#line 185
    if (rc == 0) {
#line 185
      if (my_h_errno != 0) {
        {
#line 186
        tmp___3 = __errno_location();
#line 186
        *tmp___3 = 2;
        }
      }
    }
#line 187
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return (-1);
}
}
#line 219 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/DNSUtil.c"
int GetHostEntry(struct hostent * const  hp , char const   * const  host , struct in_addr * const  ip_address ,
                 char * const  hpbuf , size_t hpbufsize ) 
{ 
  struct in_addr ip ;
  int rc ;

  {
  {
#line 229
  ip.s_addr = inet_addr((char const   *)host);
  }
#line 230
  if (ip.s_addr != 4294967295U) {
    {
#line 231
    rc = GetHostByAddr(hp, (void *)((char *)(& ip)), (int )sizeof(ip), 2, hpbuf, hpbufsize);
    }
#line 232
    if (rc == 0) {
#line 233
      rc = 0;
#line 234
      if ((unsigned long )ip_address != (unsigned long )((void *)0)) {
        {
#line 235
        memcpy((void */* __restrict  */)(& ip_address->s_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
               (size_t )hp->h_length);
        }
      }
    } else
#line 236
    if ((unsigned long )ip_address != (unsigned long )((void *)0)) {
      {
#line 237
      memcpy((void */* __restrict  */)ip_address, (void const   */* __restrict  */)(& ip),
             sizeof(struct in_addr ));
      }
    }
  } else {
#line 241
    if ((unsigned long )ip_address != (unsigned long )((void *)0)) {
#line 242
      ip_address->s_addr = 4294967295U;
    }
    {
#line 243
    rc = GetHostByName(hp, host, hpbuf, hpbufsize);
    }
#line 244
    if (rc == 0) {
#line 245
      if ((unsigned long )ip_address != (unsigned long )((void *)0)) {
        {
#line 246
        memcpy((void */* __restrict  */)(& ip_address->s_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
               (size_t )hp->h_length);
        }
      }
    }
  }
#line 253
  if (rc < 0) {
#line 253
    if (rc != -1) {
#line 254
      rc = -1;
    }
  }
#line 256
  return (rc);
}
}
#line 262 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/DNSUtil.c"
static char *strtokc___0(char *parsestr , char const   *delims , char **context ) 
{ 
  char *cp ;
  char const   *cp2 ;
  char c ;
  char c2 ;
  char *start ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 270
  if ((unsigned long )parsestr == (unsigned long )((void *)0)) {
#line 271
    start = *context;
  } else {
#line 273
    start = parsestr;
  }
#line 275
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 276
    *context = (char *)((void *)0);
#line 277
    return ((char *)((void *)0));
  } else
#line 275
  if ((unsigned long )delims == (unsigned long )((void *)0)) {
#line 276
    *context = (char *)((void *)0);
#line 277
    return ((char *)((void *)0));
  }
#line 281
  cp = start;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    next1: 
#line 283
    tmp = cp;
#line 283
    cp ++;
#line 283
    c = *tmp;
#line 284
    if ((int )c == 0) {
#line 286
      *context = (char *)((void *)0);
#line 287
      return ((char *)((void *)0));
    }
#line 289
    cp2 = delims;
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 290
      tmp___0 = cp2;
#line 290
      cp2 ++;
#line 290
      c2 = (char )*tmp___0;
#line 291
      if ((int )c2 == 0) {
#line 295
        start = cp - 1;
#line 296
        goto starttok;
      }
#line 298
      if ((int )c2 == (int )c) {
#line 301
        goto next1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  starttok: 
  {
#line 308
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 309
    c = *cp;
#line 310
    if ((int )c == 0) {
#line 312
      *context = cp;
#line 313
      goto while_break___1;
    }
#line 315
    cp2 = delims;
    {
#line 315
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 316
      tmp___1 = cp2;
#line 316
      cp2 ++;
#line 316
      c2 = (char )*tmp___1;
#line 317
      if ((int )c2 == 0) {
#line 321
        goto while_break___2;
      }
#line 323
      if ((int )c2 == (int )c) {
#line 326
        tmp___2 = cp;
#line 326
        cp ++;
#line 326
        *tmp___2 = (char )'\000';
#line 327
        *context = cp;
#line 328
        return (start);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 308
    cp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 332
  return (start);
}
}
#line 427 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/DNSUtil.c"
int GetOurHostName(char * const  host , size_t const   siz ) 
{ 
  struct hostent hp ;
  struct in_addr ip ;
  int result ;
  char **curAlias ;
  char domain[128] ;
  char hpbuf[1024] ;
  char *cp ;
  char *dlim ;
  char *dcp ;
  char *ctext ;
  int rc ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  FILE *fp ;
  char line[256] ;
  char srch[128] ;
  char *tok ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 446
  rc = 0;
#line 448
  memset((void *)host, 0, (size_t )siz);
#line 449
  result = gethostname((char *)host, (size_t )siz);
  }
#line 450
  if (result < 0) {
#line 451
    rc = -1;
#line 452
    goto done;
  } else
#line 450
  if ((int )*(host + 0) == 0) {
#line 451
    rc = -1;
#line 452
    goto done;
  }
  {
#line 455
  tmp = strchr((char const   *)host, '.');
  }
#line 455
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 459
    rc = 2;
#line 460
    goto done;
  }
  {
#line 463
  tmp___1 = GetHostByName((struct hostent */* const  */)(& hp), (char const   */* const  */)host,
                          (char */* const  */)(hpbuf), sizeof(hpbuf));
  }
#line 463
  if (tmp___1 == 0) {
#line 463
    if ((unsigned long )hp.h_name != (unsigned long )((void *)0)) {
#line 463
      if ((int )*(hp.h_name + 0) != 0) {
        {
#line 465
        cp = strchr((char const   *)hp.h_name, '.');
        }
#line 466
        if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 466
          if ((int )*(cp + 1) != 0) {
            {
#line 468
            strncpy((char */* __restrict  */)host, (char const   */* __restrict  */)hp.h_name,
                    (size_t )siz);
#line 468
            *(host + (siz - 1UL)) = (char )'\000';
#line 469
            rc = 3;
            }
#line 470
            goto done;
          }
        }
#line 474
        ip = *(*((struct in_addr **)hp.h_addr_list + 0));
#line 477
        curAlias = hp.h_aliases;
        {
#line 477
        while (1) {
          while_continue: /* CIL Label */ ;
#line 477
          if (! ((unsigned long )*curAlias != (unsigned long )((void *)0))) {
#line 477
            goto while_break;
          }
          {
#line 478
          cp = strchr((char const   *)*curAlias, '.');
          }
#line 479
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 479
            if ((int )*(cp + 1) != 0) {
              {
#line 480
              strncpy((char */* __restrict  */)host, (char const   */* __restrict  */)*curAlias,
                      (size_t )siz);
#line 480
              *(host + (siz - 1UL)) = (char )'\000';
#line 481
              rc = 4;
              }
#line 482
              goto done;
            }
          }
#line 477
          curAlias ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 487
        if (ip.s_addr != 4294967295U) {
          {
#line 488
          tmp___0 = GetHostByAddr((struct hostent */* const  */)(& hp), (void *)((char *)(& ip)),
                                  (int )sizeof(ip), 2, (char */* const  */)(hpbuf),
                                  sizeof(hpbuf));
          }
#line 488
          if (tmp___0 == 0) {
            {
#line 490
            cp = strchr((char const   *)hp.h_name, '.');
            }
#line 491
            if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 491
              if ((int )*(cp + 1) != 0) {
                {
#line 493
                strncpy((char */* __restrict  */)host, (char const   */* __restrict  */)hp.h_name,
                        (size_t )siz);
#line 493
                *(host + (siz - 1UL)) = (char )'\000';
#line 494
                rc = 5;
                }
#line 495
                goto done;
              }
            }
#line 499
            curAlias = hp.h_aliases;
            {
#line 499
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 499
              if (! ((unsigned long )*curAlias != (unsigned long )((void *)0))) {
#line 499
                goto while_break___0;
              }
              {
#line 500
              cp = strchr((char const   *)*curAlias, '.');
              }
#line 501
              if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 501
                if ((int )*(cp + 1) != 0) {
                  {
#line 502
                  strncpy((char */* __restrict  */)host, (char const   */* __restrict  */)*curAlias,
                          (size_t )siz);
#line 502
                  *(host + (siz - 1UL)) = (char )'\000';
#line 503
                  rc = 6;
                  }
#line 504
                  goto done;
                }
              }
#line 499
              curAlias ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 518
  rc = -2;
#line 519
  domain[0] = (char )'\000';
#line 531
  if ((int )domain[0] == 0) {
    {
#line 537
    fp = fopen((char const   */* __restrict  */)"/etc/resolv.conf", (char const   */* __restrict  */)"r");
    }
#line 538
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 539
      srch[0] = (char )'\000';
#line 540
      memset((void *)(line), 0, sizeof(line));
      }
      {
#line 541
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 541
        tmp___5 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL),
                        (FILE */* __restrict  */)fp);
        }
#line 541
        if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 541
          goto while_break___1;
        }
        {
#line 542
        tmp___2 = __ctype_b_loc();
        }
#line 542
        if (! ((int const   )*(*tmp___2 + (int )line[0]) & 1024)) {
#line 543
          goto while_continue___1;
        }
        {
#line 544
        ctext = (char *)((void *)0);
#line 545
        tok = strtokc___0(line, " \t\n\r", & ctext);
        }
#line 546
        if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 547
          goto while_continue___1;
        }
        {
#line 548
        tmp___4 = strcmp((char const   *)tok, "domain");
        }
#line 548
        if (tmp___4 == 0) {
          {
#line 549
          tok = strtokc___0((char *)((void *)0), " \t\n\r", & ctext);
          }
#line 550
          if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 551
            goto while_continue___1;
          }
          {
#line 552
          strncpy((char */* __restrict  */)(domain), (char const   */* __restrict  */)tok,
                  sizeof(domain));
#line 552
          domain[sizeof(domain) - 1UL] = (char )'\000';
#line 553
          rc = 9;
          }
#line 554
          goto while_break___1;
        } else {
          {
#line 555
          tmp___3 = strcmp((char const   *)tok, "search");
          }
#line 555
          if (tmp___3 == 0) {
            {
#line 556
            tok = strtokc___0((char *)((void *)0), " \t\n\r", & ctext);
            }
#line 557
            if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 558
              goto while_continue___1;
            }
            {
#line 559
            strncpy((char */* __restrict  */)(srch), (char const   */* __restrict  */)tok,
                    sizeof(srch));
#line 559
            srch[sizeof(srch) - 1UL] = (char )'\000';
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 563
      fclose(fp);
      }
#line 565
      if ((int )domain[0] == 0) {
#line 565
        if ((int )srch[0] != 0) {
          {
#line 566
          strncpy((char */* __restrict  */)(domain), (char const   */* __restrict  */)(srch),
                  sizeof(domain));
#line 566
          domain[sizeof(domain) - 1UL] = (char )'\000';
#line 567
          rc = 10;
          }
        }
      }
    }
  }
#line 574
  if ((int )domain[0] == 0) {
    {
#line 575
    tmp___7 = getdomainname(domain, sizeof(domain) - 1UL);
    }
#line 575
    if (tmp___7 != 0) {
#line 576
      domain[0] = (char )'\000';
    } else {
      {
#line 577
      tmp___6 = strchr((char const   *)(domain), '.');
      }
#line 577
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 579
        domain[0] = (char )'\000';
      }
    }
  }
#line 585
  if ((int )domain[0] != 0) {
    {
#line 589
    tmp___8 = strlen((char const   *)(domain));
#line 589
    cp = (domain + tmp___8) - 1;
    }
#line 590
    if ((int )*cp == 46) {
#line 591
      *cp = (char )'\000';
    }
    {
#line 592
    cp = domain;
#line 593
    tmp___9 = strlen((char const   *)host);
#line 593
    dcp = (char *)(host + tmp___9);
#line 594
    dlim = (char *)((host + siz) - 1);
    }
#line 595
    if ((int )domain[0] != 46) {
#line 595
      if ((unsigned long )dcp < (unsigned long )dlim) {
#line 596
        tmp___10 = dcp;
#line 596
        dcp ++;
#line 596
        *tmp___10 = (char )'.';
      }
    }
    {
#line 597
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 597
      if (! *cp) {
#line 597
        goto while_break___2;
      }
#line 598
      if ((unsigned long )dcp < (unsigned long )dlim) {
#line 599
        tmp___11 = dcp;
#line 599
        dcp ++;
#line 599
        *tmp___11 = *cp;
      }
#line 600
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 602
    *dcp = (char )'\000';
  }
  done: 
#line 605
  if (rc < 0) {
    {
#line 606
    memset((void *)host, 0, (size_t )siz);
    }
  }
#line 607
  if ((int )*(host + (siz - 1UL)) != 0) {
#line 613
    rc = -3;
  }
#line 615
  return (rc);
}
}
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 312
extern int getservbyname_r(char const   * __restrict  __name , char const   * __restrict  __proto ,
                           struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                           size_t __buflen , struct servent ** __restrict  __result ) ;
#line 318
extern int getservbyport_r(int __port , char const   * __restrict  __proto , struct servent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct servent ** __restrict  __result ) ;
#line 281 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int ServicePortNumberToName(unsigned short port , char * const  dst , size_t const   dsize ,
                            int const   proto ) ;
#line 285
char *AddrStrToIPStr(char * const  dst , size_t dsize , char const   * const  src ,
                     int const   defaultport ) ;
#line 23 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/StrAddr.c"
unsigned int ServiceNameToPortNumber(char const   * const  s , int const   proto ) 
{ 
  char str[64] ;
  char *cp ;
  struct servent se ;
  struct servent *sp ;
  char spbuf[256] ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint16_t tmp___4 ;

  {
  {
#line 36
  strncpy((char */* __restrict  */)(str), (char const   */* __restrict  */)s, sizeof(str) - 1UL);
#line 37
  str[sizeof(str) - 1UL] = (char )'\000';
#line 38
  cp = str;
#line 39
  tmp___1 = __ctype_b_loc();
  }
#line 39
  if ((int const   )*(*tmp___1 + (int )*cp) & 2048) {
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 40
      tmp = __ctype_b_loc();
      }
#line 40
      if (! ((int const   )*(*tmp + (int )*cp) & 2048)) {
#line 40
        goto while_break;
      }
#line 41
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    *cp = (char )'\000';
#line 43
    tmp___0 = atoi((char const   *)(str));
    }
#line 43
    return ((unsigned int )tmp___0);
  }
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if ((int )*cp == 0) {
#line 48
      goto while_break___0;
    } else
#line 46
    if ((int )*cp >= 65) {
#line 46
      if (! ((int )*cp <= 90)) {
#line 46
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 46
    if ((int )*cp >= 97) {
#line 46
      if (! ((int )*cp <= 122)) {
#line 46
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 46
    if ((int )*cp >= 48) {
#line 46
      if (! ((int )*cp <= 57)) {
#line 46
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 46
    if ((int )*cp != 45) {
#line 46
      if ((int )*cp != 95) {
#line 48
        goto while_break___0;
      }
    }
#line 45
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  *cp = (char )'\000';
#line 52
  sp = (struct servent *)((void *)0);
#line 63
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 63
    if (proto == 0) {
#line 63
      goto _L___2;
    } else
#line 63
    if (proto == 116) {
      _L___2: /* CIL Label */ 
      {
#line 64
      memset((void *)(spbuf), 0, sizeof(spbuf));
#line 65
      tmp___2 = getservbyname_r((char const   */* __restrict  */)(str), (char const   */* __restrict  */)"tcp",
                                (struct servent */* __restrict  */)(& se), (char */* __restrict  */)(spbuf),
                                sizeof(spbuf), (struct servent **/* __restrict  */)(& sp));
      }
#line 65
      if (tmp___2 != 0) {
#line 66
        sp = (struct servent *)((void *)0);
      }
    }
  }
#line 68
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 68
    if (proto == 0) {
#line 68
      goto _L___3;
    } else
#line 68
    if (proto == 117) {
      _L___3: /* CIL Label */ 
      {
#line 69
      memset((void *)(spbuf), 0, sizeof(spbuf));
#line 70
      tmp___3 = getservbyname_r((char const   */* __restrict  */)(str), (char const   */* __restrict  */)"udp",
                                (struct servent */* __restrict  */)(& se), (char */* __restrict  */)(spbuf),
                                sizeof(spbuf), (struct servent **/* __restrict  */)(& sp));
      }
#line 70
      if (tmp___3 != 0) {
#line 71
        sp = (struct servent *)((void *)0);
      }
    }
  }
#line 97
  if ((unsigned long )sp != (unsigned long )((void *)0)) {
    {
#line 98
    tmp___4 = ntohs((unsigned short )sp->s_port);
    }
#line 98
    return ((unsigned int )tmp___4);
  }
#line 100
  return (0U);
}
}
#line 106 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/StrAddr.c"
int ServicePortNumberToName(unsigned short port , char * const  dst , size_t const   dsize ,
                            int const   proto ) 
{ 
  struct servent se ;
  struct servent *sp ;
  char spbuf[256] ;
  uint16_t tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  int tmp___2 ;

  {
#line 118
  sp = (struct servent *)((void *)0);
#line 129
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 129
    if (proto == 0) {
#line 129
      goto _L;
    } else
#line 129
    if (proto == 116) {
      _L: /* CIL Label */ 
      {
#line 130
      memset((void *)(spbuf), 0, sizeof(spbuf));
#line 131
      tmp = htons(port);
#line 131
      tmp___0 = getservbyport_r((int )tmp, (char const   */* __restrict  */)"tcp",
                                (struct servent */* __restrict  */)(& se), (char */* __restrict  */)(spbuf),
                                sizeof(spbuf), (struct servent **/* __restrict  */)(& sp));
      }
#line 131
      if (tmp___0 != 0) {
#line 132
        sp = (struct servent *)((void *)0);
      }
    }
  }
#line 134
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 134
    if (proto == 0) {
#line 134
      goto _L___0;
    } else
#line 134
    if (proto == 117) {
      _L___0: /* CIL Label */ 
      {
#line 135
      memset((void *)(spbuf), 0, sizeof(spbuf));
#line 136
      tmp___1 = htons(port);
#line 136
      tmp___2 = getservbyport_r((int )tmp___1, (char const   */* __restrict  */)"udp",
                                (struct servent */* __restrict  */)(& se), (char */* __restrict  */)(spbuf),
                                sizeof(spbuf), (struct servent **/* __restrict  */)(& sp));
      }
#line 136
      if (tmp___2 != 0) {
#line 137
        sp = (struct servent *)((void *)0);
      }
    }
  }
#line 163
  if ((unsigned long )sp != (unsigned long )((void *)0)) {
    {
#line 164
    strncpy((char */* __restrict  */)dst, (char const   */* __restrict  */)sp->s_name,
            (size_t )dsize);
#line 165
    *(dst + (dsize - 1UL)) = (char )'\000';
    }
#line 166
    return (1);
  }
  {
#line 170
  snprintf((char */* __restrict  */)dst, (size_t )dsize, (char const   */* __restrict  */)"%u",
           (unsigned int )port);
  }
#line 176
  return (0);
}
}
#line 182 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/StrAddr.c"
void InetNtoA(char *dst , struct in_addr *ia , size_t siz ) 
{ 


  {
  {
#line 190
  memset((void *)dst, 0, siz);
#line 191
  inet_ntop(2, (void const   */* __restrict  */)ia, (char */* __restrict  */)dst,
            (socklen_t )(siz - 1UL));
  }
#line 200
  return;
}
}
#line 205 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/StrAddr.c"
int AddrStrToAddr(char const   * const  s , struct sockaddr_in * const  sa , int const   defaultport ) 
{ 
  char portstr[128] ;
  unsigned int ipnum ;
  unsigned int port ;
  struct hostent *hp ;
  char *hostcp ;
  char *atsign ;
  char *colon ;
  char *cp ;
  char *p2 ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 214
  memset((void *)sa, 0, sizeof(struct sockaddr_in ));
#line 215
  strncpy((char */* __restrict  */)(portstr), (char const   */* __restrict  */)s,
          sizeof(portstr));
#line 216
  portstr[sizeof(portstr) - 1UL] = (char )'\000';
#line 218
  colon = strchr((char const   *)(portstr), ':');
  }
#line 218
  if ((unsigned long )colon != (unsigned long )((void *)0)) {
#line 220
    if ((int )*(colon + 1) == 47) {
#line 220
      if ((int )*(colon + 2) == 47) {
#line 221
        *colon = (char )'\000';
#line 222
        port = 0U;
#line 223
        hostcp = colon + 3;
#line 224
        cp = hostcp;
        {
#line 224
        while (1) {
          while_continue: /* CIL Label */ ;
#line 224
          if (! ((int )*cp != 0)) {
#line 224
            goto while_break;
          }
#line 225
          if ((int )*cp >= 65) {
#line 225
            if (! ((int )*cp <= 90)) {
#line 225
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 225
          if ((int )*cp >= 97) {
#line 225
            if (! ((int )*cp <= 122)) {
#line 225
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 225
          if ((int )*cp >= 48) {
#line 225
            if (! ((int )*cp <= 57)) {
#line 225
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 225
          if ((int )*cp != 46) {
#line 227
            if ((int )*cp == 58) {
              {
#line 227
              tmp___2 = __ctype_b_loc();
              }
#line 227
              if ((int const   )*(*tmp___2 + (int )*(cp + 1)) & 2048) {
#line 228
                tmp = cp;
#line 228
                cp ++;
#line 228
                *tmp = (char )'\000';
#line 229
                p2 = cp;
                {
#line 230
                while (1) {
                  while_continue___0: /* CIL Label */ ;
                  {
#line 230
                  tmp___0 = __ctype_b_loc();
                  }
#line 230
                  if (! ((int const   )*(*tmp___0 + (int )*cp) & 2048)) {
#line 230
                    goto while_break___0;
                  }
#line 231
                  cp ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 232
                *cp = (char )'\000';
#line 233
                tmp___1 = atoi((char const   *)p2);
#line 233
                port = (unsigned int )tmp___1;
                }
              }
            }
#line 235
            *cp = (char )'\000';
#line 236
            goto while_break;
          }
#line 224
          cp ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 239
        if (port == 0U) {
          {
#line 240
          port = ServiceNameToPortNumber((char const   */* const  */)(portstr), (int const   )0);
          }
        }
      } else {
        {
#line 243
        *colon = (char )'\000';
#line 244
        hostcp = portstr;
#line 245
        tmp___3 = atoi((char const   *)(colon + 1));
#line 245
        port = (unsigned int )tmp___3;
        }
      }
    } else {
      {
#line 243
      *colon = (char )'\000';
#line 244
      hostcp = portstr;
#line 245
      tmp___3 = atoi((char const   *)(colon + 1));
#line 245
      port = (unsigned int )tmp___3;
      }
    }
  } else {
    {
#line 247
    atsign = strchr((char const   *)(portstr), '@');
    }
#line 247
    if ((unsigned long )atsign != (unsigned long )((void *)0)) {
      {
#line 249
      *atsign = (char )'\000';
#line 250
      hostcp = atsign + 1;
#line 251
      tmp___4 = atoi((char const   *)(portstr));
#line 251
      port = (unsigned int )tmp___4;
      }
    } else
#line 252
    if (defaultport > 0) {
#line 254
      port = (unsigned int )defaultport;
#line 255
      hostcp = portstr;
    } else {
      {
#line 260
      tmp___5 = __errno_location();
#line 260
      *tmp___5 = 99;
      }
#line 261
      return (-4);
    }
  }
  {
#line 264
  sa->sin_port = htons((uint16_t )((short )port));
#line 266
  ipnum = inet_addr((char const   *)hostcp);
  }
#line 267
  if (ipnum != 4294967295U) {
#line 268
    sa->sin_family = (sa_family_t )2;
#line 269
    sa->sin_addr.s_addr = ipnum;
  } else {
    {
#line 278
    tmp___6 = __errno_location();
#line 278
    *tmp___6 = 0;
#line 279
    hp = gethostbyname((char const   *)hostcp);
    }
#line 281
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
      {
#line 282
      tmp___8 = __errno_location();
      }
#line 282
      if (*tmp___8 == 0) {
        {
#line 283
        tmp___7 = __errno_location();
#line 283
        *tmp___7 = 2;
        }
      }
#line 284
      return (-5);
    }
    {
#line 286
    sa->sin_family = (sa_family_t )hp->h_addrtype;
#line 287
    memcpy((void */* __restrict  */)(& sa->sin_addr.s_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )hp->h_length);
    }
  }
#line 290
  return (0);
}
}
#line 296 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/StrAddr.c"
char *AddrToAddrStr(char * const  dst , size_t dsize , struct sockaddr_in * const  saddrp ,
                    int dns , char const   *fmt ) 
{ 
  char addrName[128] ;
  char *addrNamePtr ;
  struct hostent *hp ;
  char str[128] ;
  char s_name[64] ;
  char *dlim ;
  char *dp ;
  char const   *cp ;
  char *tmp ;
  uint16_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint16_t tmp___3 ;
  char *tmp___4 ;
  uint16_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 307
  if (dsize == 0UL) {
#line 308
    return ((char *)((void *)0));
  }
  {
#line 309
  memset((void *)dst, 0, dsize);
#line 311
  addrNamePtr = (char *)((void *)0);
  }
#line 312
  if (dns == 0) {
    {
#line 313
    InetNtoA(addrName, & saddrp->sin_addr, sizeof(addrName));
#line 314
    addrNamePtr = addrName;
    }
  } else {
    {
#line 322
    hp = gethostbyaddr((void const   *)((struct in_addr  const  *)(& saddrp->sin_addr)),
                       (__socklen_t )sizeof(struct in_addr ), 2);
    }
#line 324
    if ((unsigned long )hp != (unsigned long )((void *)0)) {
#line 324
      if ((unsigned long )hp->h_name != (unsigned long )((void *)0)) {
#line 324
        if ((int )*(hp->h_name + 0) != 0) {
#line 325
          addrNamePtr = hp->h_name;
        } else {
          {
#line 327
          InetNtoA(addrName, & saddrp->sin_addr, sizeof(addrName));
#line 328
          addrNamePtr = addrName;
          }
        }
      } else {
        {
#line 327
        InetNtoA(addrName, & saddrp->sin_addr, sizeof(addrName));
#line 328
        addrNamePtr = addrName;
        }
      }
    } else {
      {
#line 327
      InetNtoA(addrName, & saddrp->sin_addr, sizeof(addrName));
#line 328
      addrNamePtr = addrName;
      }
    }
  }
#line 331
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 332
    fmt = "%h:%p";
  }
#line 333
  dp = (char *)dst;
#line 333
  dlim = (dp + dsize) - 1;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if ((int const   )*fmt == 0) {
#line 335
      goto while_break;
    } else
#line 336
    if ((int const   )*fmt == 37) {
#line 337
      fmt ++;
#line 338
      if ((int const   )*fmt == 37) {
#line 339
        if ((unsigned long )dp < (unsigned long )dlim) {
#line 340
          tmp = dp;
#line 340
          dp ++;
#line 340
          *tmp = (char )'%';
        }
      } else
#line 341
      if ((int const   )*fmt == 112) {
        {
#line 342
        tmp___0 = ntohs(saddrp->sin_port);
#line 342
        sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%u",
                (unsigned int )tmp___0);
#line 343
        cp = (char const   *)(str);
        }
        {
#line 343
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 343
          if (! ((int const   )*cp != 0)) {
#line 343
            goto while_break___0;
          }
#line 344
          if ((unsigned long )dp < (unsigned long )dlim) {
#line 345
            tmp___1 = dp;
#line 345
            dp ++;
#line 345
            *tmp___1 = (char )*cp;
          }
#line 343
          cp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 346
        *dp = (char )'\000';
      } else
#line 347
      if ((int const   )*fmt == 104) {
#line 348
        if ((unsigned long )addrNamePtr != (unsigned long )((void *)0)) {
#line 349
          cp = (char const   *)addrNamePtr;
        } else {
#line 351
          cp = "unknown";
        }
        {
#line 353
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 353
          if (! ((int const   )*cp != 0)) {
#line 353
            goto while_break___1;
          }
#line 354
          if ((unsigned long )dp < (unsigned long )dlim) {
#line 355
            tmp___2 = dp;
#line 355
            dp ++;
#line 355
            *tmp___2 = (char )*cp;
          }
#line 353
          cp ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 356
        *dp = (char )'\000';
      } else
#line 357
      if ((int const   )*fmt == 115) {
        {
#line 358
        cp = (char const   *)(s_name);
#line 359
        tmp___3 = ntohs(saddrp->sin_port);
#line 359
        ServicePortNumberToName(tmp___3, (char */* const  */)(s_name), (size_t const   )sizeof(s_name),
                                (int const   )0);
        }
        {
#line 360
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 360
          if (! ((int const   )*cp != 0)) {
#line 360
            goto while_break___2;
          }
#line 361
          if ((unsigned long )dp < (unsigned long )dlim) {
#line 362
            tmp___4 = dp;
#line 362
            dp ++;
#line 362
            *tmp___4 = (char )*cp;
          }
#line 360
          cp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 364
        *dp = (char )'\000';
      } else
#line 365
      if ((int const   )*fmt == 116) {
#line 365
        goto _L;
      } else
#line 365
      if ((int const   )*fmt == 117) {
        _L: /* CIL Label */ 
        {
#line 366
        cp = (char const   *)(s_name);
#line 367
        tmp___5 = ntohs(saddrp->sin_port);
#line 367
        ServicePortNumberToName(tmp___5, (char */* const  */)(s_name), (size_t const   )sizeof(s_name),
                                (int const   )((int )*fmt));
        }
        {
#line 368
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 368
          if (! ((int const   )*cp != 0)) {
#line 368
            goto while_break___3;
          }
#line 369
          if ((unsigned long )dp < (unsigned long )dlim) {
#line 370
            tmp___6 = dp;
#line 370
            dp ++;
#line 370
            *tmp___6 = (char )*cp;
          }
#line 368
          cp ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 372
        *dp = (char )'\000';
      } else
#line 373
      if ((int const   )*fmt == 0) {
#line 374
        goto while_break;
      } else
#line 376
      if ((unsigned long )dp < (unsigned long )dlim) {
#line 377
        tmp___7 = dp;
#line 377
        dp ++;
#line 377
        *tmp___7 = (char )*fmt;
      }
    } else
#line 379
    if ((unsigned long )dp < (unsigned long )dlim) {
#line 380
      tmp___8 = dp;
#line 380
      dp ++;
#line 380
      *tmp___8 = (char )*fmt;
    }
#line 333
    fmt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  *dp = (char )'\000';
#line 384
  return ((char *)dst);
}
}
#line 390 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/StrAddr.c"
char *AddrStrToIPStr(char * const  dst , size_t dsize , char const   * const  src ,
                     int const   defaultport ) 
{ 
  int rc ;
  struct sockaddr_in sa ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 396
  if (dsize == 0UL) {
#line 397
    return ((char *)((void *)0));
  }
  {
#line 398
  memset((void *)dst, 0, dsize);
  }
#line 400
  if (defaultport <= 0) {
#line 400
    tmp = 21;
  } else {
#line 400
    tmp = (int )defaultport;
  }
  {
#line 400
  rc = AddrStrToAddr(src, (struct sockaddr_in */* const  */)(& sa), (int const   )tmp);
  }
#line 401
  if (rc < 0) {
#line 402
    return ((char *)((void *)0));
  }
#line 404
  if (defaultport <= 0) {
#line 404
    tmp___0 = "%h";
  } else {
#line 404
    tmp___0 = "%h:%p";
  }
  {
#line 404
  AddrToAddrStr(dst, dsize, (struct sockaddr_in */* const  */)(& sa), 0, tmp___0);
  }
#line 405
  return ((char *)dst);
}
}
#line 219 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 268 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int GetSocketNagleAlgorithm(int const   fd ) ;
#line 269
int SetSocketNagleAlgorithm(int const   fd , int const   onoff ) ;
#line 272
int GetSocketKeepAlive(int const   fd ) ;
#line 274
int GetSocketTypeOfService(int const   fd ) ;
#line 276
int GetSocketInlineOutOfBandData(int const   fd ) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int GetSocketBufSize(int const   sockfd , size_t * const  rsize , size_t * const  ssize ) 
{ 
  int rc ;
  int opt ;
  socklen_t optsize ;

  {
#line 21
  rc = -1;
#line 25
  if ((unsigned long )ssize != (unsigned long )((void *)0)) {
    {
#line 26
    opt = 0;
#line 27
    optsize = (socklen_t )sizeof(opt);
#line 28
    rc = getsockopt((int )sockfd, 1, 7, (void */* __restrict  */)(& opt), (socklen_t */* __restrict  */)(& optsize));
    }
#line 29
    if (rc == 0) {
#line 30
      *ssize = (size_t )opt;
    } else {
#line 32
      *ssize = (size_t )0;
    }
  }
#line 34
  if ((unsigned long )rsize != (unsigned long )((void *)0)) {
    {
#line 35
    opt = 0;
#line 36
    optsize = (socklen_t )sizeof(opt);
#line 37
    rc = getsockopt((int )sockfd, 1, 8, (void */* __restrict  */)(& opt), (socklen_t */* __restrict  */)(& optsize));
    }
#line 38
    if (rc == 0) {
#line 39
      *rsize = (size_t )opt;
    } else {
#line 41
      *rsize = (size_t )0;
    }
  }
#line 43
  return (rc);
}
}
#line 60 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int SetSocketBufSize(int const   sockfd , size_t const   rsize , size_t const   ssize ) 
{ 
  int rc ;
  int opt ;
  socklen_t optsize ;

  {
#line 63
  rc = -1;
#line 76
  if (ssize != 0UL) {
    {
#line 77
    opt = (int )ssize;
#line 78
    optsize = (socklen_t )sizeof(opt);
#line 79
    rc = setsockopt((int )sockfd, 1, 7, (void const   *)(& opt), optsize);
    }
#line 80
    if (rc < 0) {
#line 81
      return (rc);
    }
  }
#line 83
  if (rsize != 0UL) {
    {
#line 84
    opt = (int )rsize;
#line 85
    optsize = (socklen_t )sizeof(opt);
#line 86
    rc = setsockopt((int )sockfd, 1, 8, (void const   *)(& opt), optsize);
    }
#line 87
    if (rc < 0) {
#line 88
      return (rc);
    }
  }
#line 90
  return (0);
}
}
#line 105 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int GetSocketKeepAlive(int const   fd ) 
{ 
  socklen_t optsize ;
  int opt ;
  int tmp ;

  {
  {
#line 111
  opt = -2;
#line 112
  optsize = (socklen_t )sizeof(opt);
#line 113
  tmp = getsockopt((int )fd, 1, 9, (void */* __restrict  */)((char *)(& opt)), (socklen_t */* __restrict  */)(& optsize));
  }
#line 113
  if (tmp < 0) {
#line 114
    return (-1);
  }
#line 115
  return (opt);
}
}
#line 132 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int SetSocketKeepAlive(int const   fd , int const   onoff ) 
{ 
  int opt ;
  int tmp ;

  {
  {
#line 137
  opt = (int )onoff;
#line 138
  tmp = setsockopt((int )fd, 1, 9, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
  }
#line 138
  return (tmp);
}
}
#line 153 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int GetSocketNagleAlgorithm(int const   fd ) 
{ 
  socklen_t optsize ;
  int opt ;
  int tmp ;

  {
  {
#line 159
  opt = -2;
#line 160
  optsize = (socklen_t )sizeof(opt);
#line 161
  tmp = getsockopt((int )fd, 6, 1, (void */* __restrict  */)((char *)(& opt)), (socklen_t */* __restrict  */)(& optsize));
  }
#line 161
  if (tmp < 0) {
#line 162
    return (-1);
  }
#line 163
  return (opt);
}
}
#line 180 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int SetSocketNagleAlgorithm(int const   fd , int const   onoff ) 
{ 
  int opt ;
  int tmp ;

  {
  {
#line 185
  opt = (int )onoff;
#line 186
  tmp = setsockopt((int )fd, 6, 1, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
  }
#line 186
  return (tmp);
}
}
#line 201 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int GetSocketInlineOutOfBandData(int const   fd ) 
{ 
  socklen_t optsize ;
  int opt ;
  int tmp ;

  {
  {
#line 207
  opt = -2;
#line 208
  optsize = (socklen_t )sizeof(opt);
#line 209
  tmp = getsockopt((int )fd, 1, 10, (void */* __restrict  */)((char *)(& opt)), (socklen_t */* __restrict  */)(& optsize));
  }
#line 209
  if (tmp < 0) {
#line 210
    return (-1);
  }
#line 211
  return (opt);
}
}
#line 228 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int SetSocketInlineOutOfBandData(int const   fd , int const   onoff ) 
{ 
  int opt ;
  int tmp ;

  {
  {
#line 233
  opt = (int )onoff;
#line 234
  tmp = setsockopt((int )fd, 1, 10, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
  }
#line 234
  return (tmp);
}
}
#line 249 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int GetSocketTypeOfService(int const   fd ) 
{ 
  socklen_t optsize ;
  int opt ;
  int tmp ;

  {
  {
#line 255
  opt = -2;
#line 256
  optsize = (socklen_t )sizeof(opt);
#line 257
  tmp = getsockopt((int )fd, 0, 1, (void */* __restrict  */)((char *)(& opt)), (socklen_t */* __restrict  */)(& optsize));
  }
#line 257
  if (tmp < 0) {
#line 258
    return (-1);
  }
#line 259
  return (opt);
}
}
#line 276 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int SetSocketTypeOfService(int const   fd , int const   tosType ) 
{ 
  int opt ;
  int tmp ;

  {
  {
#line 281
  opt = (int )tosType;
#line 282
  tmp = setsockopt((int )fd, 0, 1, (void const   *)((char *)(& opt)), (socklen_t )sizeof(opt));
  }
#line 282
  return (tmp);
}
}
#line 298 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int GetSocketLinger(int const   fd , int * const  lingertime ) 
{ 
  socklen_t optsize ;
  struct linger opt ;
  int tmp ;

  {
  {
#line 304
  optsize = (socklen_t )sizeof(opt);
#line 305
  opt.l_onoff = 0;
#line 306
  opt.l_linger = 0;
#line 307
  tmp = getsockopt((int )fd, 1, 13, (void */* __restrict  */)((char *)(& opt)), (socklen_t */* __restrict  */)(& optsize));
  }
#line 307
  if (tmp < 0) {
#line 308
    return (-1);
  }
#line 309
  if ((unsigned long )lingertime != (unsigned long )((void *)0)) {
#line 310
    *lingertime = opt.l_linger;
  }
#line 311
  return (opt.l_onoff);
}
}
#line 327 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SocketUtil.c"
int SetSocketLinger(int const   fd , int const   l_onoff , int const   l_linger ) 
{ 
  struct linger opt ;
  socklen_t optsize ;
  int tmp ;

  {
  {
#line 357
  opt.l_onoff = (int )l_onoff;
#line 358
  opt.l_linger = (int )l_linger;
#line 360
  optsize = (socklen_t )sizeof(opt);
#line 361
  tmp = setsockopt((int )fd, 1, 13, (void const   *)((char *)(& opt)), optsize);
  }
#line 361
  return (tmp);
}
}
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_size.c"
int FTPFileSize(FTPCIPtr const   cip , char const   * const  file , long long * const  size ,
                int const   type ) 
{ 
  int result ;
  ResponsePtr rp ;
  int tmp ;

  {
#line 25
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 26
    return (-139);
  }
  {
#line 27
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 27
  if (tmp) {
#line 28
    return (-138);
  }
#line 30
  if ((unsigned long )size == (unsigned long )((void *)0)) {
#line 31
    return (-139);
  } else
#line 30
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 31
    return (-139);
  }
  {
#line 32
  *size = -1LL;
#line 34
  result = FTPSetTransferType(cip, (int )type);
  }
#line 35
  if (result < 0) {
#line 36
    return (result);
  }
#line 38
  if (cip->hasSIZE == 0) {
#line 39
    cip->errNo = -148;
#line 40
    result = -148;
  } else {
    {
#line 42
    rp = InitResponse();
    }
#line 43
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 44
      result = -123;
#line 45
      cip->errNo = -123;
#line 46
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
      }
    } else {
      {
#line 48
      result = RCmd(cip, rp, "SIZE %s", file);
      }
#line 49
      if (result < 0) {
        {
#line 50
        DoneWithResponse(cip, rp);
        }
#line 51
        return (result);
      } else
#line 52
      if (result == 2) {
        {
#line 54
        sscanf((char const   */* __restrict  */)(rp->msg.first)->line, (char const   */* __restrict  */)"%lld",
               size);
#line 60
        cip->hasSIZE = 1;
#line 61
        result = 0;
        }
      } else
#line 62
      if (rp->code == 500) {
#line 63
        cip->hasSIZE = 0;
#line 64
        cip->errNo = -148;
#line 65
        result = -148;
      } else
#line 62
      if (rp->code == 502) {
#line 63
        cip->hasSIZE = 0;
#line 64
        cip->errNo = -148;
#line 65
        result = -148;
      } else
#line 62
      if (rp->code == 504) {
#line 63
        cip->hasSIZE = 0;
#line 64
        cip->errNo = -148;
#line 65
        result = -148;
      } else {
#line 67
        cip->errNo = -145;
#line 68
        result = -145;
      }
      {
#line 70
      DoneWithResponse(cip, rp);
      }
    }
  }
#line 73
  return (result);
}
}
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_size.c"
long long FTPLocalASCIIFileSize(char const   * const  fn , char *buf , size_t const   bufsize ) 
{ 
  char *tbuf ;
  int c ;
  int prevc ;
  long long asize ;
  char const   *scp ;
  char const   *slim ;
  int fd ;
  ssize_t nread ;
  int oerrno ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 82
  tbuf = (char *)((void *)0);
#line 90
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 91
    tmp = malloc((size_t )bufsize);
#line 91
    tbuf = (char *)tmp;
    }
#line 92
    if ((unsigned long )tbuf == (unsigned long )((void *)0)) {
#line 93
      return (-1LL);
    }
#line 94
    buf = tbuf;
  }
  {
#line 97
  fd = open((char const   *)fn, 0, 438);
  }
#line 98
  if (fd < 0) {
#line 99
    if ((unsigned long )tbuf != (unsigned long )((void *)0)) {
      {
#line 100
      free((void *)tbuf);
      }
    }
#line 101
    return (-1LL);
  }
#line 104
  prevc = 0;
#line 105
  asize = 0LL;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    nread = read(fd, (void *)buf, (size_t )bufsize);
    }
#line 107
    if (nread < 0L) {
      {
#line 108
      tmp___0 = __errno_location();
#line 108
      oerrno = *tmp___0;
#line 109
      close(fd);
      }
#line 110
      if ((unsigned long )tbuf != (unsigned long )((void *)0)) {
        {
#line 111
        free((void *)tbuf);
        }
      }
      {
#line 112
      tmp___1 = __errno_location();
#line 112
      *tmp___1 = oerrno;
      }
#line 113
      return (-1LL);
    } else
#line 114
    if (nread == 0L) {
#line 115
      goto while_break;
    }
#line 118
    scp = (char const   *)buf;
#line 118
    slim = (char const   *)(buf + nread);
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! ((unsigned long )scp < (unsigned long )slim)) {
#line 118
        goto while_break___0;
      }
#line 119
      tmp___2 = scp;
#line 119
      scp ++;
#line 119
      c = (int )*tmp___2;
#line 120
      if (c == 10) {
#line 120
        if (prevc != 13) {
#line 127
          nread ++;
        }
      }
#line 129
      prevc = c;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 105
    asize += (long long )nread;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if ((unsigned long )tbuf != (unsigned long )((void *)0)) {
    {
#line 134
    free((void *)tbuf);
    }
  }
  {
#line 135
  close(fd);
  }
#line 136
  return (asize);
}
}
#line 251 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SSendto(int sfd , char const   * const  buf , size_t size , int fl , struct sockaddr_in  const  * const  toAddr ,
            int tlen ) ;
#line 252
int Sendto(int sfd , char const   * const  buf , size_t size , struct sockaddr_in  const  * const  toAddr ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSendto.c"
int SSendto(int sfd , char const   * const  buf , size_t size , int fl , struct sockaddr_in  const  * const  toAddr ,
            int tlen ) 
{ 
  ssize_t nwrote ;
  int tleft ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __sighandler_t tmp___4 ;
  int *tmp___5 ;

  {
#line 15
  sigpipe = (void (*)(int  ))0;
#line 17
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if (size == 0UL) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if ((unsigned long )toAddr == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if (tlen <= 0) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  }
  {
#line 22
  time(& now);
#line 23
  done = now + (time_t )tlen;
#line 24
  nwrote = (ssize_t )0;
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 27
      if (now >= done) {
        {
#line 28
        tmp___0 = __errno_location();
#line 28
        *tmp___0 = 110;
        }
#line 30
        return (-2);
      }
#line 32
      if (done > now) {
#line 32
        tleft = (int )(done - now);
      } else {
#line 32
        tleft = 0;
      }
      {
#line 33
      tmp___1 = __errno_location();
#line 33
      *tmp___1 = 0;
      }
      {
#line 34
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 34
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 34
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 39
      ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 43
      tv.tv_sec = (__time_t )((long long )tleft);
#line 44
      tv.tv_usec = (__suseconds_t )0;
#line 45
      result = select(sfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                      (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 46
      if (result >= 1) {
#line 48
        goto while_break___0;
      } else
#line 49
      if (result == 0) {
        {
#line 51
        tmp___2 = __errno_location();
#line 51
        *tmp___2 = 110;
        }
#line 53
        return (-2);
      } else {
        {
#line 54
        tmp___3 = __errno_location();
        }
#line 54
        if (*tmp___3 != 4) {
#line 55
          return (-1);
        }
      }
      {
#line 57
      time(& now);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 60
    if (sio_sigpipe_ignored_already) {
#line 60
      sigpipe = (void (*)(int  ))0;
    } else {
      {
#line 60
      tmp___4 = signal(13, (void (*)(int  ))1);
#line 60
      sigpipe = tmp___4;
      }
    }
    {
#line 61
    nwrote = sendto(sfd, (void const   *)buf, size, fl, (struct sockaddr  const  *)toAddr,
                    (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 64
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 64
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
        {
#line 64
        signal(13, sigpipe);
        }
      }
    }
#line 66
    if (nwrote >= 0L) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp___5 = __errno_location();
    }
#line 68
    if (*tmp___5 != 4) {
#line 69
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return ((int )nwrote);
}
}
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SSendto.c"
int Sendto(int sfd , char const   * const  buf , size_t size , struct sockaddr_in  const  * const  toAddr ) 
{ 
  int result ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 83
  sigpipe = (void (*)(int  ))0;
#line 85
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 86
    tmp = __errno_location();
#line 86
    *tmp = 22;
    }
#line 87
    return (-1);
  } else
#line 85
  if (size == 0UL) {
    {
#line 86
    tmp = __errno_location();
#line 86
    *tmp = 22;
    }
#line 87
    return (-1);
  } else
#line 85
  if ((unsigned long )toAddr == (unsigned long )((void *)0)) {
    {
#line 86
    tmp = __errno_location();
#line 86
    *tmp = 22;
    }
#line 87
    return (-1);
  }
#line 90
  if (sio_sigpipe_ignored_already) {
#line 90
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 90
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 90
    sigpipe = tmp___0;
    }
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp___1 = sendto(sfd, (void const   *)buf, size, 0, (struct sockaddr  const  *)toAddr,
                     (socklen_t )sizeof(struct sockaddr_in ));
#line 92
    result = (int )tmp___1;
    }
#line 91
    if (result < 0) {
      {
#line 91
      tmp___2 = __errno_location();
      }
#line 91
      if (! (*tmp___2 == 4)) {
#line 91
        goto while_break;
      }
    } else {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 96
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 96
      signal(13, sigpipe);
      }
    }
  }
#line 97
  return (result);
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_modtime.c"
int FTPFileModificationTime(FTPCIPtr const   cip , char const   * const  file , time_t * const  mdtm ) 
{ 
  int result ;
  ResponsePtr rp ;
  int tmp ;
  int tmp___0 ;

  {
#line 19
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 20
    return (-139);
  }
  {
#line 21
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 21
  if (tmp) {
#line 22
    return (-138);
  }
#line 24
  if ((unsigned long )mdtm == (unsigned long )((void *)0)) {
#line 25
    return (-139);
  } else
#line 24
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 25
    return (-139);
  }
#line 26
  *mdtm = (time_t )-1;
#line 28
  if (cip->hasMDTM == 0) {
#line 29
    cip->errNo = -149;
#line 30
    result = -149;
  } else {
    {
#line 32
    rp = InitResponse();
    }
#line 33
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
      {
#line 34
      result = -123;
#line 35
      cip->errNo = -123;
#line 36
      FTPLogError(cip, (int const   )0, (char const   */* const  */)"Malloc failed.\n");
      }
    } else {
      {
#line 38
      result = RCmd(cip, rp, "MDTM %s", file);
      }
#line 39
      if (result < 0) {
        {
#line 40
        DoneWithResponse(cip, rp);
        }
#line 41
        return (result);
      }
#line 43
      if (result == 2) {
        {
#line 44
        tmp___0 = strncmp((char const   *)(rp->msg.first)->line, "1910", (size_t )4);
        }
#line 44
        if (tmp___0 == 0) {
          {
#line 48
          FTPLogError(cip, (int const   )0, (char const   */* const  */)"Warning: Server has Y2K Bug in \"MDTM\" command.\n");
          }
        }
        {
#line 50
        *mdtm = UnMDTMDate((rp->msg.first)->line);
#line 51
        cip->hasMDTM = 1;
#line 52
        result = 0;
        }
      } else
#line 53
      if (rp->code == 500) {
#line 54
        cip->hasMDTM = 0;
#line 55
        cip->hasMDTM_set = 0;
#line 56
        cip->errNo = -149;
#line 57
        result = -149;
      } else
#line 53
      if (rp->code == 502) {
#line 54
        cip->hasMDTM = 0;
#line 55
        cip->hasMDTM_set = 0;
#line 56
        cip->errNo = -149;
#line 57
        result = -149;
      } else
#line 53
      if (rp->code == 504) {
#line 54
        cip->hasMDTM = 0;
#line 55
        cip->hasMDTM_set = 0;
#line 56
        cip->errNo = -149;
#line 57
        result = -149;
      } else {
#line 59
        cip->errNo = -146;
#line 60
        result = -146;
      }
      {
#line 62
      DoneWithResponse(cip, rp);
      }
    }
  }
#line 65
  return (result);
}
}
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/usio.h"
int UConnectByName(int sfd , char const   * const  addrStr , int const   tlen ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UConnectByName.c"
int UConnectByName(int sfd , char const   * const  addrStr , int const   tlen ) 
{ 
  int result ;
  struct sockaddr_un remoteAddr ;
  int ualen ;
  int *tmp ;

  {
#line 15
  if ((unsigned long )addrStr == (unsigned long )((void *)0)) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  } else
#line 15
  if ((int const   )*(addrStr + 0) == 0) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  }
  {
#line 20
  ualen = MakeSockAddrUn(& remoteAddr, addrStr);
#line 21
  result = UConnect(sfd, (struct sockaddr_un  const  */* const  */)(& remoteAddr),
                    ualen, (int )tlen);
  }
#line 22
  return (result);
}
}
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_getcwd.c"
char *FTPGetLocalCWD(char *buf , size_t size ) 
{ 
  char *tmp ;

  {
  {
#line 20
  memset((void *)buf, 0, size);
#line 21
  tmp = getcwd(buf, size - 1UL);
  }
#line 21
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 22
    memset((void *)buf, 0, size);
    }
#line 23
    return ((char *)((void *)0));
  } else
#line 21
  if ((int )*(buf + (size - 1UL)) != 0) {
    {
#line 22
    memset((void *)buf, 0, size);
    }
#line 23
    return ((char *)((void *)0));
  } else
#line 21
  if ((int )*(buf + (size - 2UL)) != 0) {
    {
#line 22
    memset((void *)buf, 0, size);
    }
#line 23
    return ((char *)((void *)0));
  }
#line 25
  return (buf);
}
}
#line 71 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
int DStrNew(DStr * const  dst , size_t const   srcLen ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/DStrNew.c"
int DStrNew(DStr * const  dst , size_t const   srcLen ) 
{ 
  size_t allocSize ;
  char *cp ;
  void *tmp ;

  {
  {
#line 12
  memset((void *)dst, 0, sizeof(DStr ));
  }
#line 13
  if (srcLen > 16777215UL) {
#line 14
    return (-1);
  }
  {
#line 15
  allocSize = (size_t )((srcLen + 16UL) & 4294967280UL);
#line 16
  tmp = calloc(allocSize, (size_t )1);
#line 16
  cp = (char *)tmp;
  }
#line 17
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 18
    return (-1);
  }
#line 19
  dst->allocSize = allocSize;
#line 20
  dst->s = cp;
#line 21
  dst->len = (size_t )0;
#line 22
  return (0);
}
}
#line 44 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Dynsrecpy.c"
char *Dynsrecpy(char **dst  , ...) 
{ 
  va_list ap ;
  char const   *src ;
  char *newdst ;
  char *dcp ;
  size_t catLen ;
  size_t srcLen ;
  int recursive ;
  char const   *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 52
  if ((unsigned long )dst == (unsigned long )((char **)0)) {
#line 53
    return ((char *)((void *)0));
  }
  {
#line 55
  recursive = 0;
#line 56
  catLen = (size_t )0;
#line 57
  __builtin_va_start(ap, dst);
#line 58
  tmp = __builtin_va_arg(ap, char *);
#line 58
  src = tmp;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 59
      goto while_break;
    }
#line 60
    if ((unsigned long )src == (unsigned long )*dst) {
#line 61
      recursive = 1;
    }
    {
#line 63
    tmp___0 = strlen(src);
#line 63
    catLen += tmp___0;
#line 64
    tmp___1 = __builtin_va_arg(ap, char *);
#line 64
    src = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  __builtin_va_end(ap);
  }
#line 68
  if (recursive == 0) {
#line 69
    if ((unsigned long )*dst == (unsigned long )((void *)0)) {
      {
#line 70
      tmp___2 = malloc(catLen + 2UL);
#line 70
      newdst = (char *)tmp___2;
      }
    } else {
      {
#line 71
      tmp___4 = strlen((char const   *)*dst);
      }
#line 71
      if (catLen + 2UL > tmp___4 + 1UL) {
        {
#line 72
        tmp___3 = realloc((void *)*dst, catLen + 2UL);
#line 72
        newdst = (char *)tmp___3;
        }
      } else {
#line 75
        newdst = *dst;
      }
    }
#line 77
    if ((unsigned long )newdst == (unsigned long )((void *)0)) {
#line 78
      return ((char *)((void *)0));
    }
    {
#line 80
    dcp = newdst;
#line 81
    __builtin_va_start(ap, dst);
#line 82
    tmp___5 = __builtin_va_arg(ap, char *);
#line 82
    src = tmp___5;
    }
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 83
        goto while_break___0;
      }
      {
#line 84
      srcLen = strlen(src);
#line 85
      memcpy((void */* __restrict  */)dcp, (void const   */* __restrict  */)src, srcLen);
#line 86
      dcp += srcLen;
#line 87
      tmp___6 = __builtin_va_arg(ap, char *);
#line 87
      src = tmp___6;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    __builtin_va_end(ap);
#line 90
    *dcp = (char )'\000';
    }
  } else {
    {
#line 92
    tmp___7 = malloc(catLen + 2UL);
#line 92
    newdst = (char *)tmp___7;
    }
#line 93
    if ((unsigned long )newdst == (unsigned long )((void *)0)) {
#line 94
      return ((char *)((void *)0));
    }
    {
#line 96
    dcp = newdst;
#line 97
    __builtin_va_start(ap, dst);
#line 98
    tmp___8 = __builtin_va_arg(ap, char *);
#line 98
    src = tmp___8;
    }
    {
#line 99
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 99
      if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 99
        goto while_break___1;
      }
      {
#line 100
      srcLen = strlen(src);
#line 101
      memcpy((void */* __restrict  */)dcp, (void const   */* __restrict  */)src, srcLen);
#line 102
      dcp += srcLen;
#line 103
      tmp___9 = __builtin_va_arg(ap, char *);
#line 103
      src = tmp___9;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 105
    __builtin_va_end(ap);
#line 106
    *dcp = (char )'\000';
    }
#line 108
    if ((unsigned long )*dst != (unsigned long )((void *)0)) {
      {
#line 109
      free((void *)*dst);
      }
    }
  }
#line 111
  *dst = newdst;
#line 112
  return (newdst);
}
}
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 717
extern int system(char const   *__command ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 896 "../libncftp/ncftp.h"
int FTPGetOneFile3(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   resumeflag ,
                   int const   appendflag , int const   deleteflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                                               char const   **localpath ,
                                                                                               long long localsize ,
                                                                                               time_t localmtime ,
                                                                                               char const   *remotepath ,
                                                                                               long long remotesize ,
                                                                                               time_t remotetime ,
                                                                                               long long *startPoint ) ,
                   int reserved  __attribute__((__unused__)) ) ;
#line 904
int FTPLocalGlob(FTPCIPtr cip , FTPLineListPtr fileList , char const   *pattern ,
                 int doGlob ) ;
#line 913
int FTPPutFiles3(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir1 ,
                 int const   recurse , int const   doGlob , int const   xtype , int appendflag ,
                 char const   * const  tmppfx , char const   * const  tmpsfx , int const   resumeflag ,
                 int const   deleteflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                    char const   *localpath ,
                                                                    long long localsize ,
                                                                    time_t localmtime ,
                                                                    char const   **remotepath ,
                                                                    long long remotesize ,
                                                                    time_t remotetime ,
                                                                    long long *startPoint ) ,
                 int reserved  __attribute__((__unused__)) ) ;
#line 954
void GetTmpDir(char * const  dst , size_t const   size ) ;
#line 989
int FTPGetOneFile2(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   resumeflag ,
                   int const   appendflag ) ;
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.h"
int PromptForBookmarkName(BookmarkPtr bmp ) ;
#line 10
void CurrentURL(char *dst , size_t dsize , int showpass ) ;
#line 11
void FillBookmarkInfo(BookmarkPtr bmp ) ;
#line 12
void SaveCurrentAsBookmark(void) ;
#line 13
void SaveUnsavedBookmark(void) ;
#line 14
void BookmarkCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) ;
#line 15
void CatCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 16
void PrintResp(FTPLineListPtr llp ) ;
#line 17
int nFTPChdirAndGetCWD(FTPCIPtr const   cip , char const   *cdCwd , int const   quietMode ) ;
#line 18
int Chdirs(FTPCIPtr cip , char const   * const  cdCwd ) ;
#line 19
void BGStartCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
#line 20
void ChdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 21
void ChmodCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 22
void CloseCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 23
void DebugCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 24
void DeleteCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
               ArgvInfoPtr const   aip ) ;
#line 25
void EchoCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 26
void EditCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 28
void GetCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 29
void HelpCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 30
void HostsCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 31
void JobsCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 32
void ListCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 33
void LocalChdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) ;
#line 34
void LocalListCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                  ArgvInfoPtr const   aip ) ;
#line 35
void LocalChmodCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) ;
#line 36
void LocalMkdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) ;
#line 37
void LocalPageCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                  ArgvInfoPtr const   aip ) ;
#line 38
void LocalRenameCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                    ArgvInfoPtr const   aip ) ;
#line 39
void LocalRmCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
#line 40
void LocalRmdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) ;
#line 41
void LocalPwdCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) ;
#line 42
void LookupCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
               ArgvInfoPtr const   aip ) ;
#line 43
void MkdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 44
void MlsCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 45
int DoOpen(void) ;
#line 46
void OpenCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 47
void PageCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 48
void PassiveCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
#line 49
void PutCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 50
void PwdCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 51
void QuitCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 52
void QuoteCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 53
void RGlobCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 54
void RenameCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
               ArgvInfoPtr const   aip ) ;
#line 55
void RmdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 56
void RmtHelpCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
#line 57
void SetCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 58
void ShellCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 59
void SiteCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 60
void SpoolGetCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) ;
#line 61
void SpoolPutCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) ;
#line 62
void SymlinkCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
#line 63
void TypeCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 64
void UmaskCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) ;
#line 65
void VersionCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) ;
#line 67
int ( /* format attribute */  AskYesNoQuestion)(int const   defaultAnswer , char const   * const  fmt 
                                                , ...) ;
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.h"
void InitConnectionInfo(void) ;
#line 19 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.h"
int CanSpool(void) ;
#line 20
int HaveSpool(void) ;
#line 51
void Jobs(void) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.h"
void ReCacheBookmarks(void) ;
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
char gStartDir[512]  ;
#line 35 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
char gRemoteCWD[512]  ;
#line 40 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
char gPrevRemoteCWD[512]  ;
#line 43 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
char gScratchCWD[512]  ;
#line 47 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int gServerUsesMSDOSPaths  ;
#line 52 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int gUnusedArg  ;
#line 56 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
FTPConnectionInfo gTmpURLConn  ;
#line 61 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int gResumeAnswerAll  ;
#line 64 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int gUserTypedSensitiveInfoAtShellSoDoNotSaveItToDisk  =    0;
#line 82
int gIsTTYr ;
#line 96
char gLocalCWD[512] ;
#line 96
char gPrevLocalCWD[512] ;
#line 108
static void ( /* format attribute */  OpenMsg)(char const   * const  fmt  , ...) ;
#line 125 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static FILE *OpenPager___0(void) 
{ 
  FILE *fp ;
  char *pprog ;
  char const   *tmp ;

  {
  {
#line 131
  fflush(stdout);
#line 132
  pprog = gPager;
  }
#line 133
  if ((int )*(pprog + 0) == 0) {
#line 133
    tmp = "more";
  } else {
#line 133
    tmp = (char const   *)pprog;
  }
  {
#line 133
  fp = popen(tmp, "w");
  }
#line 134
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 135
    return (stdout);
  }
#line 136
  return (fp);
}
}
#line 143 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void ClosePager___0(FILE *pagerfp ) 
{ 
  void (*osigpipe)(int  ) ;
  void (*tmp)(int  ) ;

  {
#line 150
  if ((unsigned long )pagerfp != (unsigned long )((void *)0)) {
#line 150
    if ((unsigned long )pagerfp != (unsigned long )stdout) {
      {
#line 152
      tmp = NcSignal(13, (void (*)(int  ))1);
#line 152
      osigpipe = tmp;
#line 154
      pclose(pagerfp);
#line 156
      NcSignal(13, osigpipe);
      }
    }
  }
#line 159
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int PromptForBookmarkName(BookmarkPtr bmp ) 
{ 
  char dfltname[64] ;
  char bmname[64] ;

  {
  {
#line 171
  DefaultBookmarkName(dfltname, sizeof(dfltname), gConn.host);
  }
#line 172
  if ((int )dfltname[0] == 0) {
    {
#line 173
    printf((char const   */* __restrict  */)"Enter a name for this bookmark: ");
    }
  } else {
    {
#line 175
    printf((char const   */* __restrict  */)"Enter a name for this bookmark, or hit enter for \"%s\": ",
           dfltname);
    }
  }
  {
#line 177
  fflush(stdin);
#line 178
  FGets(bmname, sizeof(bmname), stdin);
  }
#line 179
  if ((int )bmname[0] != 0) {
    {
#line 180
    Strncpy((char */* const  */)(bmp->bookmarkName), (char const   */* const  */)(bmname),
            (size_t const   )sizeof(bmp->bookmarkName));
    }
#line 181
    return (0);
  } else
#line 182
  if ((int )dfltname[0] != 0) {
    {
#line 183
    Strncpy((char */* const  */)(bmp->bookmarkName), (char const   */* const  */)(dfltname),
            (size_t const   )sizeof(bmp->bookmarkName));
    }
#line 184
    return (0);
  }
#line 186
  return (-1);
}
}
#line 191 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void CurrentURL(char *dst , size_t dsize , int showpass ) 
{ 
  Bookmark bm ;
  char dir___3[160] ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 197
  memset((void *)(& bm), 0, sizeof(bm));
#line 198
  Strncpy((char */* const  */)(bm.name), (char const   */* const  */)(gConn.host),
          (size_t const   )sizeof(bm.name));
  }
#line 199
  if ((int )gConn.user[0] != 0) {
    {
#line 199
    tmp___0 = strcmp((char const   *)(gConn.user), "anonymous");
    }
#line 199
    if (! (tmp___0 == 0)) {
      {
#line 199
      tmp___1 = strcmp((char const   *)(gConn.user), "ftp");
      }
#line 199
      if (! (tmp___1 == 0)) {
        {
#line 200
        Strncpy((char */* const  */)(bm.user), (char const   */* const  */)(gConn.user),
                (size_t const   )sizeof(bm.user));
        }
#line 201
        if (showpass == 0) {
#line 201
          tmp = "PASSWORD";
        } else {
#line 201
          tmp = (char const   *)(gConn.pass);
        }
        {
#line 201
        Strncpy((char */* const  */)(bm.pass), (char const   */* const  */)tmp, (size_t const   )sizeof(bm.pass));
#line 202
        Strncpy((char */* const  */)(bm.acct), (char const   */* const  */)(gConn.acct),
                (size_t const   )sizeof(bm.acct));
        }
      }
    }
  }
  {
#line 205
  bm.port = gConn.port;
#line 212
  Strncpy((char */* const  */)(dir___3), (char const   */* const  */)(gRemoteCWD),
          (size_t const   )sizeof(dir___3));
#line 213
  tmp___2 = strlen((char const   *)(gStartDir));
#line 213
  AbsoluteToRelative((char */* const  */)(bm.dir), (size_t const   )sizeof(bm.dir),
                     (char const   */* const  */)(dir___3), (char const   */* const  */)(gStartDir),
                     (size_t const   )tmp___2);
#line 215
  BookmarkToURL(& bm, dst, dsize);
  }
#line 216
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int ( /* format attribute */  AskYesNoQuestion)(int const   defaultAnswer , char const   * const  fmt 
                                                , ...) 
{ 
  va_list ap ;
  char ans[128] ;
  char buf[512] ;

  {
  {
#line 228
  __builtin_va_start(ap, fmt);
#line 230
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)fmt,
            ap);
#line 231
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 235
  __builtin_va_end(ap);
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 238
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
            buf);
#line 239
    fflush(stdout);
#line 240
    fflush(stdin);
#line 241
    memset((void *)(ans), 0, sizeof(ans));
#line 242
    fgets((char */* __restrict  */)(ans), (int )(sizeof(ans) - 1UL), (FILE */* __restrict  */)stdin);
#line 243
    Trace((int const   )0, (char const   */* const  */)"%s%s", buf, ans);
    }
    {
#line 246
    if ((int )ans[0] == 89) {
#line 246
      goto case_89;
    }
#line 246
    if ((int )ans[0] == 121) {
#line 246
      goto case_89;
    }
#line 250
    if ((int )ans[0] == 78) {
#line 250
      goto case_78;
    }
#line 250
    if ((int )ans[0] == 110) {
#line 250
      goto case_78;
    }
#line 253
    goto switch_default;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 247
    return (1);
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 251
    return (0);
    switch_default: /* CIL Label */ 
#line 254
    if (defaultAnswer >= 0) {
#line 255
      return ((int )defaultAnswer);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 267 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void FillBookmarkInfo(BookmarkPtr bmp ) 
{ 
  char dir___3[160] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 272
  Strncpy((char */* const  */)(bmp->name), (char const   */* const  */)(gConn.host),
          (size_t const   )sizeof(bmp->name));
#line 273
  tmp = strcmp((char const   *)(gConn.user), "anonymous");
  }
#line 273
  if (tmp == 0) {
#line 274
    bmp->user[0] = (char )'\000';
#line 275
    bmp->pass[0] = (char )'\000';
#line 276
    bmp->acct[0] = (char )'\000';
  } else {
    {
#line 273
    tmp___0 = strcmp((char const   *)(gConn.user), "ftp");
    }
#line 273
    if (tmp___0 == 0) {
#line 274
      bmp->user[0] = (char )'\000';
#line 275
      bmp->pass[0] = (char )'\000';
#line 276
      bmp->acct[0] = (char )'\000';
    } else {
      {
#line 278
      Strncpy((char */* const  */)(bmp->user), (char const   */* const  */)(gConn.user),
              (size_t const   )sizeof(bmp->user));
#line 279
      Strncpy((char */* const  */)(bmp->pass), (char const   */* const  */)(gConn.pass),
              (size_t const   )sizeof(bmp->pass));
#line 280
      Strncpy((char */* const  */)(bmp->acct), (char const   */* const  */)(gConn.acct),
              (size_t const   )sizeof(bmp->acct));
      }
    }
  }
  {
#line 288
  Strncpy((char */* const  */)(dir___3), (char const   */* const  */)(gRemoteCWD),
          (size_t const   )sizeof(dir___3));
#line 289
  tmp___1 = strlen((char const   *)(gStartDir));
#line 289
  AbsoluteToRelative((char */* const  */)(bmp->dir), (size_t const   )sizeof(bmp->dir),
                     (char const   */* const  */)(dir___3), (char const   */* const  */)(gStartDir),
                     (size_t const   )tmp___1);
#line 290
  bmp->port = gConn.port;
#line 291
  time(& bmp->lastCall);
#line 292
  bmp->hasSIZE = gConn.hasSIZE;
#line 293
  bmp->hasMDTM = gConn.hasMDTM;
#line 294
  bmp->hasPASV = gConn.hasPASV;
#line 295
  bmp->hasUTIME = gConn.hasSITE_UTIME;
  }
#line 296
  if (gFirewallType == 0) {
    {
#line 297
    Strncpy((char */* const  */)(bmp->lastIP), (char const   */* const  */)(gConn.ip),
            (size_t const   )sizeof(bmp->lastIP));
    }
  }
#line 298
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SaveCurrentAsBookmark(void) 
{ 
  int saveBmPassword ;
  int tmp ;

  {
  {
#line 310
  FillBookmarkInfo(& gBm);
#line 312
  saveBmPassword = gSavePasswords;
  }
#line 313
  if (saveBmPassword < 0) {
#line 313
    if ((int )gBm.pass[0] != 0) {
#line 314
      if (gLoadedBm != 0) {
#line 315
        saveBmPassword = 1;
      } else
#line 316
      if (gIsTTYr == 0) {
#line 317
        saveBmPassword = 0;
      } else {
        {
#line 319
        printf((char const   */* __restrict  */)"\n\nYou logged into this site using a password.\nWould you like to save the password with this bookmark?\n\n");
#line 320
        saveBmPassword = AskYesNoQuestion((int const   )0, (char const   */* const  */)"Save? [no] ");
        }
#line 320
        if (saveBmPassword == 0) {
          {
#line 321
          printf((char const   */* __restrict  */)"\nNot saving the password.\n");
          }
        }
      }
    }
  }
  {
#line 324
  tmp = PutBookmark(& gBm, saveBmPassword);
  }
#line 324
  if (tmp < 0) {
    {
#line 325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not save bookmark.\n");
    }
  } else {
    {
#line 328
    gLoadedBm = 1;
#line 329
    printf((char const   */* __restrict  */)"Bookmark \"%s\" saved.\n", gBm.bookmarkName);
#line 331
    ReCacheBookmarks();
    }
  }
#line 333
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SaveUnsavedBookmark(void) 
{ 
  char url[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 346
  if (gIsTTYr == 0) {
#line 347
    return;
  } else
#line 348
  if (gConfirmClose != 0) {
#line 348
    if (gLoadedBm == 0) {
#line 348
      if ((int )gOurDirectoryPath[0] != 0) {
        {
#line 349
        FillBookmarkInfo(& gBm);
#line 350
        BookmarkToURL(& gBm, url, sizeof(url));
#line 351
        printf((char const   */* __restrict  */)"\n\nYou have not saved a bookmark for this site.\n");
#line 352
        sleep(1U);
#line 353
        printf((char const   */* __restrict  */)"\nWould you like to save a bookmark to:\n\t%s\n\n",
               url);
#line 354
        tmp___0 = AskYesNoQuestion((int const   )0, (char const   */* const  */)"Save? (yes/no) ");
        }
#line 354
        if (tmp___0 == 0) {
          {
#line 355
          printf((char const   */* __restrict  */)"Not saved.  (If you don\'t want to be asked this, \"set confirm-close no\")\n\n\n");
          }
        } else {
          {
#line 356
          tmp = PromptForBookmarkName(& gBm);
          }
#line 356
          if (tmp < 0) {
            {
#line 357
            printf((char const   */* __restrict  */)"Nevermind.\n");
            }
          } else {
            {
#line 359
            SaveCurrentAsBookmark();
            }
          }
        }
      } else {
#line 348
        goto _L___0;
      }
    } else {
#line 348
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 361
  if (gLoadedBm == 1) {
#line 361
    if ((int )gOurDirectoryPath[0] != 0) {
      {
#line 361
      tmp___1 = strcmp((char const   *)(gOurDirectoryPath), (char const   *)(gBm.dir));
      }
#line 361
      if (tmp___1 != 0) {
#line 363
        if (gAutoSaveChangesToExistingBookmarks != 0) {
          {
#line 364
          SaveCurrentAsBookmark();
          }
        }
      }
    }
  }
#line 367
  return;
}
}
#line 374 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void BookmarkCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 380
  if (argc != 0) {
#line 380
    tmp = 1;
  } else
#line 380
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 380
    tmp = 1;
  } else
#line 380
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 380
    tmp = 1;
  } else
#line 380
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 380
    tmp = 1;
  } else {
#line 380
    tmp = 0;
  }
#line 380
  gUnusedArg = tmp;
#line 382
  if ((int )gOurDirectoryPath[0] == 0) {
    {
#line 383
    printf((char const   */* __restrict  */)"Sorry, configuration information is not saved for this user.\n");
    }
  } else
#line 384
  if (argc <= 1) {
#line 384
    goto _L;
  } else
#line 384
  if ((int )*(*(argv + 1) + 0) == 0) {
    _L: /* CIL Label */ 
#line 386
    if ((int )gBm.bookmarkName[0] == 0) {
      {
#line 388
      tmp___0 = PromptForBookmarkName(& gBm);
      }
#line 388
      if (tmp___0 < 0) {
        {
#line 389
        printf((char const   */* __restrict  */)"Nevermind.\n");
        }
      } else {
        {
#line 391
        SaveCurrentAsBookmark();
        }
      }
    } else {
      {
#line 395
      SaveCurrentAsBookmark();
      }
    }
  } else {
    {
#line 398
    Strncpy((char */* const  */)(gBm.bookmarkName), (char const   */* const  */)*(argv + 1),
            (size_t const   )sizeof(gBm.bookmarkName));
#line 399
    SaveCurrentAsBookmark();
    }
  }
#line 401
  return;
}
}
#line 407 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void CatCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int i___0 ;
  int tmp ;

  {
#line 413
  if (argc != 0) {
#line 413
    tmp = 1;
  } else
#line 413
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 413
    tmp = 1;
  } else
#line 413
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 413
    tmp = 1;
  } else
#line 413
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 413
    tmp = 1;
  } else {
#line 413
    tmp = 0;
  }
#line 413
  gUnusedArg = tmp;
#line 414
  i___0 = 1;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i___0 < (int )argc)) {
#line 414
      goto while_break;
    }
    {
#line 415
    result = FTPGetOneFile2((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                            (char const   */* const  */)((void *)0), (int const   )'A',
                            (int const   )1, (int const   )0, (int const   )0);
#line 416
    FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-160,
              (char const   */* const  */)"cat", (char const   */* const  */)*(argv + i___0));
#line 414
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return;
}
}
#line 422 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void NcFTPCdResponseProc(FTPCIPtr const   cipUNUSED , ResponsePtr rp ) 
{ 
  FTPLinePtr lp ;
  FTPLineListPtr llp ;
  int tmp ;

  {
#line 428
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 429
  if ((rp->printMode & 1) != 0) {
#line 430
    return;
  }
#line 431
  llp = & rp->msg;
#line 432
  lp = llp->first;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 432
      goto while_break;
    }
#line 433
    if ((unsigned long )lp == (unsigned long )llp->first) {
#line 433
      if (rp->codeType == 2) {
        {
#line 434
        tmp = strncasecmp((char const   *)lp->line, "CWD command", (size_t )11);
        }
#line 434
        if (tmp == 0) {
#line 435
          goto __Cont;
        }
#line 436
        if ((int )*(lp->line + 0) == 34) {
#line 437
          goto __Cont;
        }
      }
    }
    {
#line 439
    printf((char const   */* __restrict  */)"%s\n", lp->line);
    }
    __Cont: /* CIL Label */ 
#line 432
    lp = lp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return;
}
}
#line 447 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void PrintResp(FTPLineListPtr llp ) 
{ 
  FTPLinePtr lp ;
  int tmp ;

  {
#line 452
  if ((unsigned long )llp != (unsigned long )((void *)0)) {
#line 453
    lp = llp->first;
    {
#line 453
    while (1) {
      while_continue: /* CIL Label */ ;
#line 453
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 453
        goto while_break;
      }
#line 454
      if ((unsigned long )lp == (unsigned long )llp->first) {
        {
#line 454
        tmp = strncasecmp((char const   *)lp->line, "CWD command", (size_t )11);
        }
#line 454
        if (tmp == 0) {
#line 455
          goto __Cont;
        }
      }
      {
#line 456
      printf((char const   */* __restrict  */)"%s\n", lp->line);
      }
      __Cont: /* CIL Label */ 
#line 453
      lp = lp->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 459
  return;
}
}
#line 468 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int nFTPChdirAndGetCWD(FTPCIPtr const   cip , char const   *cdCwd , int const   quietMode ) 
{ 
  ResponsePtr rp ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 478
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 479
    return (-139);
  }
  {
#line 480
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 480
  if (tmp) {
#line 481
    return (-138);
  }
#line 483
  if ((unsigned long )cdCwd == (unsigned long )((void *)0)) {
#line 484
    result = -122;
#line 485
    cip->errNo = -122;
  } else
#line 483
  if ((int const   )*(cdCwd + 0) == 0) {
#line 484
    result = -122;
#line 485
    cip->errNo = -122;
  } else {
    {
#line 487
    rp = InitResponse();
    }
#line 488
    if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 489
      result = -123;
#line 490
      cip->errNo = -123;
    } else {
      {
#line 493
      tmp___0 = strcmp(cdCwd, "..");
      }
#line 493
      if (tmp___0 == 0) {
        {
#line 494
        result = RCmd(cip, rp, "CDUP");
        }
      } else {
        {
#line 496
        result = RCmd(cip, rp, "CWD %s", cdCwd);
        }
      }
#line 498
      if (result == 2) {
#line 530
        if (quietMode) {
#line 531
          rp->printMode |= 1;
        }
        {
#line 532
        NcFTPCdResponseProc(cip, rp);
#line 533
        DoneWithResponse(cip, rp);
#line 534
        Strncpy((char */* const  */)(gScratchCWD), (char const   */* const  */)(gRemoteCWD),
                (size_t const   )sizeof(gScratchCWD));
#line 535
        PathCat((char */* const  */)(gRemoteCWD), (size_t const   )sizeof(gRemoteCWD),
                (char const   */* const  */)(gScratchCWD), (char const   */* const  */)cdCwd,
                gServerUsesMSDOSPaths);
#line 536
        result = 0;
        }
      } else
#line 538
      if (result > 0) {
        {
#line 539
        result = -125;
#line 540
        cip->errNo = -125;
#line 541
        DoneWithResponse(cip, rp);
        }
      } else {
        {
#line 543
        DoneWithResponse(cip, rp);
        }
      }
    }
  }
#line 547
  return (result);
}
}
#line 553 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int Chdirs(FTPCIPtr cip , char const   * const  cdCwd ) 
{ 
  char *cp ;
  char *startcp ;
  int result ;
  int lastSubDir ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
#line 560
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 561
    return (-139);
  }
  {
#line 562
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 562
  if (tmp) {
#line 563
    return (-138);
  }
#line 565
  if ((unsigned long )cdCwd == (unsigned long )((void *)0)) {
#line 566
    result = -122;
#line 567
    cip->errNo = -122;
#line 568
    return (result);
  }
#line 571
  if ((int const   )*(cdCwd + 0) == 0) {
#line 572
    return (0);
  } else {
    {
#line 571
    tmp___0 = strcmp((char const   *)cdCwd, ".");
    }
#line 571
    if (tmp___0 == 0) {
#line 572
      return (0);
    }
  }
#line 574
  cp = cip->buf;
#line 575
  *(cp + (cip->bufSize - 2UL)) = (char )'\000';
#line 576
  if ((int const   )*(cdCwd + 0) == 46) {
#line 576
    if ((int const   )*(cdCwd + 1) == 46) {
#line 576
      if ((int const   )*(cdCwd + 2) == 0) {
        {
#line 577
        PathCat((char */* const  */)cip->buf, (size_t const   )cip->bufSize, (char const   */* const  */)(gRemoteCWD),
                cdCwd, gServerUsesMSDOSPaths);
        }
      } else
#line 576
      if ((int const   )*(cdCwd + 2) == 47) {
        {
#line 577
        PathCat((char */* const  */)cip->buf, (size_t const   )cip->bufSize, (char const   */* const  */)(gRemoteCWD),
                cdCwd, gServerUsesMSDOSPaths);
        }
      } else {
        {
#line 579
        Strncpy((char */* const  */)cip->buf, cdCwd, (size_t const   )cip->bufSize);
        }
      }
    } else {
      {
#line 579
      Strncpy((char */* const  */)cip->buf, cdCwd, (size_t const   )cip->bufSize);
      }
    }
  } else {
    {
#line 579
    Strncpy((char */* const  */)cip->buf, cdCwd, (size_t const   )cip->bufSize);
    }
  }
#line 581
  if ((int )*(cp + (cip->bufSize - 2UL)) != 0) {
#line 582
    return (-139);
  }
  {
#line 584
  StrRemoveTrailingSlashes(cp);
#line 587
  result = nFTPChdirAndGetCWD((FTPCIPtr const   )cip, (char const   *)cp, (int const   )0);
  }
#line 588
  if (result == 0) {
#line 589
    return (result);
  }
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 593
    startcp = cp;
#line 594
    cp = strchr((char const   *)(cp + 0), '/');
    }
#line 595
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 596
      tmp___1 = cp;
#line 596
      cp ++;
#line 596
      *tmp___1 = (char )'\000';
    }
#line 598
    lastSubDir = (unsigned long )cp == (unsigned long )((void *)0);
#line 599
    if (lastSubDir) {
#line 599
      tmp___2 = 0;
    } else {
#line 599
      tmp___2 = 1;
    }
#line 599
    if ((int )*startcp != 0) {
#line 599
      tmp___3 = (char const   *)startcp;
    } else {
#line 599
      tmp___3 = "/";
    }
    {
#line 599
    result = nFTPChdirAndGetCWD((FTPCIPtr const   )cip, tmp___3, (int const   )tmp___2);
    }
#line 600
    if (result < 0) {
#line 601
      cip->errNo = result;
    }
#line 592
    if (! lastSubDir) {
#line 592
      if (! (result == 0)) {
#line 592
        goto while_break;
      }
    } else {
#line 592
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return (result);
}
}
#line 612 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void ChdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int result ;
  FTPLineList ll ;
  FTPLinePtr lp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 619
  if (argc != 0) {
#line 619
    tmp = 1;
  } else
#line 619
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 619
    tmp = 1;
  } else
#line 619
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 619
    tmp = 1;
  } else
#line 619
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 619
    tmp = 1;
  } else {
#line 619
    tmp = 0;
  }
#line 619
  gUnusedArg = tmp;
#line 621
  if (argc <= 1) {
#line 622
    if ((int )gStartDir[0] != 0) {
      {
#line 623
      Strncpy((char */* const  */)(gPrevRemoteCWD), (char const   */* const  */)(gRemoteCWD),
              (size_t const   )sizeof(gPrevRemoteCWD));
#line 624
      result = Chdirs(& gConn, (char const   */* const  */)(gStartDir));
      }
#line 625
      if (result != 0) {
        {
#line 627
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-125,
                  (char const   */* const  */)"Could not chdir to", (char const   */* const  */)(gStartDir));
        }
      }
    } else {
      {
#line 630
      PrintCmdUsage((CommandPtr )cmdp);
      }
    }
  } else {
    {
#line 633
    InitLineList(& ll);
    }
#line 634
    if (aip->noglobargv[1] != 0) {
#line 634
      tmp___0 = 0;
    } else {
#line 634
      tmp___0 = 1;
    }
    {
#line 634
    result = FTPRemoteGlob(& gConn, & ll, (char const   *)*(argv + 1), tmp___0);
    }
#line 635
    if (result < 0) {
      {
#line 636
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-151,
                (char const   */* const  */)*(argv + 0), (char const   */* const  */)*(argv + 1));
      }
    } else {
#line 638
      lp = ll.first;
#line 639
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
#line 639
        if ((unsigned long )lp->line != (unsigned long )((void *)0)) {
          {
#line 640
          tmp___1 = strcmp((char const   *)lp->line, "-");
          }
#line 640
          if (tmp___1 == 0) {
#line 640
            if ((int )gPrevRemoteCWD[0] != 0) {
              {
#line 641
              free((void *)lp->line);
#line 642
              lp->line = StrDup((char const   *)(gPrevRemoteCWD));
              }
#line 643
              if ((unsigned long )lp->line == (unsigned long )((void *)0)) {
#line 644
                result = -123;
#line 645
                gConn.errNo = -123;
              } else {
                {
#line 647
                Strncpy((char */* const  */)(gPrevRemoteCWD), (char const   */* const  */)(gRemoteCWD),
                        (size_t const   )sizeof(gPrevRemoteCWD));
#line 648
                result = Chdirs(& gConn, (char const   */* const  */)lp->line);
                }
              }
            } else {
              {
#line 651
              Strncpy((char */* const  */)(gPrevRemoteCWD), (char const   */* const  */)(gRemoteCWD),
                      (size_t const   )sizeof(gPrevRemoteCWD));
#line 652
              result = Chdirs(& gConn, (char const   */* const  */)lp->line);
              }
            }
          } else {
            {
#line 651
            Strncpy((char */* const  */)(gPrevRemoteCWD), (char const   */* const  */)(gRemoteCWD),
                    (size_t const   )sizeof(gPrevRemoteCWD));
#line 652
            result = Chdirs(& gConn, (char const   */* const  */)lp->line);
            }
          }
#line 654
          if (result != 0) {
            {
#line 655
            FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-125,
                      (char const   */* const  */)"Could not chdir to", (char const   */* const  */)lp->line);
            }
          }
        }
      }
    }
    {
#line 658
    DisposeLineListContents(& ll);
    }
  }
#line 660
  return;
}
}
#line 666 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void ChmodCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
#line 671
  if (argc != 0) {
#line 671
    tmp = 1;
  } else
#line 671
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 671
    tmp = 1;
  } else
#line 671
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 671
    tmp = 1;
  } else
#line 671
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 671
    tmp = 1;
  } else {
#line 671
    tmp = 0;
  }
#line 671
  gUnusedArg = tmp;
#line 672
  i___0 = 2;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (i___0 < (int )argc)) {
#line 672
      goto while_break;
    }
#line 673
    if (aip->noglobargv[i___0] != 0) {
#line 673
      tmp___0 = 0;
    } else {
#line 673
      tmp___0 = 1;
    }
    {
#line 673
    result = FTPChmod((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                      (char const   */* const  */)*(argv + 1), (int const   )tmp___0);
    }
#line 677
    if (result < 0) {
      {
#line 678
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-142,
                (char const   */* const  */)"chmod", (char const   */* const  */)*(argv + i___0));
      }
    }
#line 672
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  FlushLsCache();
  }
#line 685
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void CloseCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 694
  if (argc != 0) {
#line 694
    tmp = 1;
  } else
#line 694
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 694
    tmp = 1;
  } else
#line 694
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 694
    tmp = 1;
  } else
#line 694
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 694
    tmp = 1;
  } else {
#line 694
    tmp = 0;
  }
#line 694
  gUnusedArg = tmp;
#line 695
  if (gConn.connected == 0) {
    {
#line 696
    printf((char const   */* __restrict  */)"Already closed.\n");
    }
  } else {
    {
#line 698
    CloseHost();
    }
  }
#line 699
  return;
}
}
#line 704 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void DebugCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 707
  if (argc != 0) {
#line 707
    tmp = 1;
  } else
#line 707
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 707
    tmp = 1;
  } else
#line 707
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 707
    tmp = 1;
  } else
#line 707
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 707
    tmp = 1;
  } else {
#line 707
    tmp = 0;
  }
#line 707
  gUnusedArg = tmp;
#line 708
  if (argc > 1) {
    {
#line 709
    tmp___0 = atoi((char const   *)*(argv + 1));
#line 709
    SetDebug(tmp___0);
    }
  } else {
    {
#line 711
    SetDebug(! gDebug);
    }
  }
#line 712
  return;
}
}
#line 718 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void DeleteCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
               ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int i___0 ;
  int c ;
  int recursive ;
  GetoptInfo opt ;
  int tmp ;
  int tmp___0 ;

  {
#line 723
  recursive = 0;
#line 726
  if (argc != 0) {
#line 726
    tmp = 1;
  } else
#line 726
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 726
    tmp = 1;
  } else
#line 726
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 726
    tmp = 1;
  } else
#line 726
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 726
    tmp = 1;
  } else {
#line 726
    tmp = 0;
  }
  {
#line 726
  gUnusedArg = tmp;
#line 727
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 728
    c = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"rf");
    }
#line 728
    if (! (c > 0)) {
#line 728
      goto while_break;
    }
    {
#line 729
    if (c == 114) {
#line 729
      goto case_114;
    }
#line 732
    if (c == 102) {
#line 732
      goto case_102;
    }
#line 735
    goto switch_default;
    case_114: /* CIL Label */ 
#line 730
    recursive = 1;
#line 731
    goto switch_break;
    case_102: /* CIL Label */ 
#line 734
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 736
    PrintCmdUsage((CommandPtr )cmdp);
    }
#line 737
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  i___0 = opt.ind;
  {
#line 740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 740
    if (! (i___0 < (int )argc)) {
#line 740
      goto while_break___0;
    }
#line 741
    if (aip->noglobargv[i___0] != 0) {
#line 741
      tmp___0 = 0;
    } else {
#line 741
      tmp___0 = 1;
    }
    {
#line 741
    result = FTPDelete((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                       (int const   )recursive, (int const   )tmp___0);
    }
#line 745
    if (result < 0) {
      {
#line 746
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-144,
                (char const   */* const  */)"delete", (char const   */* const  */)*(argv + i___0));
      }
    }
#line 740
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 752
  FlushLsCache();
  }
#line 753
  return;
}
}
#line 761 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void EchoCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int result ;
  int np ;
  FTPLineList ll ;
  FTPLinePtr lp ;
  int tmp ;
  int tmp___0 ;

  {
#line 766
  np = 0;
#line 770
  if (argc != 0) {
#line 770
    tmp = 1;
  } else
#line 770
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 770
    tmp = 1;
  } else
#line 770
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 770
    tmp = 1;
  } else
#line 770
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 770
    tmp = 1;
  } else {
#line 770
    tmp = 0;
  }
#line 770
  gUnusedArg = tmp;
#line 771
  i___0 = 1;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i___0 < (int )argc)) {
#line 771
      goto while_break;
    }
    {
#line 772
    InitLineList(& ll);
    }
#line 773
    if (aip->noglobargv[i___0] != 0) {
#line 773
      tmp___0 = 0;
    } else {
#line 773
      tmp___0 = 1;
    }
    {
#line 773
    result = FTPLocalGlob(& gConn, & ll, (char const   *)*(argv + i___0), tmp___0);
    }
#line 774
    if (result < 0) {
      {
#line 775
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-151,
                (char const   */* const  */)"local glob", (char const   */* const  */)*(argv + i___0));
      }
    } else {
#line 777
      lp = ll.first;
      {
#line 777
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 777
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 777
          goto while_break___0;
        }
#line 778
        if ((unsigned long )lp->line != (unsigned long )((void *)0)) {
#line 779
          if (np > 0) {
            {
#line 780
            printf((char const   */* __restrict  */)" ");
            }
          }
          {
#line 781
          printf((char const   */* __restrict  */)"%s", lp->line);
#line 782
          np ++;
          }
        }
#line 777
        lp = lp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 786
    DisposeLineListContents(& ll);
#line 771
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 788
  printf((char const   */* __restrict  */)"\n");
  }
#line 789
  return;
}
}
#line 797 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int AddToListOfFilesToEdit(FTPLineListPtr rfiles , FTPLineListPtr lfiles ,
                                  char *remoteFile , int createIt ) 
{ 
  char tname[260] ;
  int fd ;
  FTPLinePtr tmp ;
  FTPLinePtr tmp___0 ;
  FTPLinePtr tmp___1 ;

  {
  {
#line 803
  GetTmpDir((char */* const  */)(tname), (size_t const   )sizeof(tname));
  }
#line 804
  if ((int )tname[0] == 0) {
#line 805
    return (-1);
  }
  {
#line 807
  Strncat((char */* const  */)(tname), (char const   */* const  */)"/", (size_t const   )sizeof(tname));
#line 808
  Strncat((char */* const  */)(tname), (char const   */* const  */)"ncftp_editcmd.XXXXXX",
          (size_t const   )sizeof(tname));
#line 809
  fd = mkstemp(tname);
  }
#line 809
  if (fd < 0) {
#line 810
    return (-1);
  }
  {
#line 811
  close(fd);
  }
#line 813
  if ((int )tname[0] == 0) {
#line 814
    return (-1);
  } else {
    {
#line 813
    tmp = AddLine(lfiles, (char const   *)(tname));
    }
#line 813
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 814
      return (-1);
    }
  }
#line 816
  if ((unsigned long )remoteFile == (unsigned long )((void *)0)) {
#line 817
    return (-1);
  } else
#line 816
  if ((int )*(remoteFile + 0) == 0) {
#line 817
    return (-1);
  }
#line 819
  if (createIt != 0) {
    {
#line 825
    Strncpy((char */* const  */)(tname), (char const   */* const  */)"//|||//", (size_t const   )sizeof(tname));
#line 826
    Strncat((char */* const  */)(tname), (char const   */* const  */)remoteFile, (size_t const   )sizeof(tname));
#line 827
    tmp___0 = AddLine(rfiles, (char const   *)(tname));
    }
#line 827
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 828
      return (-1);
    }
#line 829
    return (0);
  }
  {
#line 832
  tmp___1 = AddLine(rfiles, (char const   *)remoteFile);
  }
#line 832
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 833
    return (-1);
  }
#line 835
  return (0);
}
}
#line 841 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void EditCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int n ;
  int n2 ;
  int result ;
  char cmdbuf[2048] ;
  char modstr[80] ;
  char *rpath ;
  char const   *envEDITOR ;
  FTPLineList globlist ;
  FTPLineList rfiles ;
  FTPLineList lfiles ;
  FTPLineList modstrs ;
  FTPLinePtr lp ;
  FTPLinePtr rlp ;
  FTPLinePtr llp ;
  FTPLinePtr mlp ;
  FILE *fp ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  FTPLinePtr tmp___10 ;
  union __anonunion_60 __constr_expr_4 ;
  union __anonunion_61 __constr_expr_5 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 855
  if (argc != 0) {
#line 855
    tmp = 1;
  } else
#line 855
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 855
    tmp = 1;
  } else
#line 855
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 855
    tmp = 1;
  } else
#line 855
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 855
    tmp = 1;
  } else {
#line 855
    tmp = 0;
  }
  {
#line 855
  gUnusedArg = tmp;
#line 856
  tmp___0 = getenv("EDITOR");
#line 856
  envEDITOR = (char const   *)tmp___0;
  }
#line 857
  if ((unsigned long )envEDITOR == (unsigned long )((void *)0)) {
    {
#line 862
    Trace((int const   )-1, (char const   */* const  */)"Set your EDITOR environment variable prior to running ncftp.\nExample for /bin/sh:\n\n\tEDITOR=\"/usr/bin/vi\" ; export EDITOR\n\n");
    }
#line 863
    return;
  } else
#line 857
  if ((int const   )*(envEDITOR + 0) == 0) {
    {
#line 862
    Trace((int const   )-1, (char const   */* const  */)"Set your EDITOR environment variable prior to running ncftp.\nExample for /bin/sh:\n\n\tEDITOR=\"/usr/bin/vi\" ; export EDITOR\n\n");
    }
#line 863
    return;
  }
  {
#line 866
  InitLineList(& rfiles);
#line 867
  InitLineList(& lfiles);
#line 869
  i___0 = 1;
#line 869
  n = 0;
  }
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! (i___0 < (int )argc)) {
#line 869
      goto while_break;
    }
    {
#line 870
    InitLineList(& globlist);
#line 871
    result = FTPRemoteGlob(& gConn, & globlist, (char const   *)*(argv + i___0), 1);
    }
#line 872
    if (result < 0) {
      {
#line 873
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-151,
                (char const   */* const  */)"remote glob", (char const   */* const  */)*(argv + i___0));
      }
#line 874
      goto __Cont;
    }
#line 876
    lp = globlist.first;
    {
#line 876
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 876
      if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 876
        goto while_break___0;
      }
      {
#line 877
      result = FTPIsRegularFile((FTPCIPtr const   )(& gConn), (char const   */* const  */)lp->line);
      }
      {
#line 879
      if (result == 1) {
#line 879
        goto case_1;
      }
#line 890
      if (result == 0) {
#line 890
        goto case_0;
      }
#line 893
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 880
      tmp___1 = AddToListOfFilesToEdit(& rfiles, & lfiles, lp->line, 0);
      }
#line 880
      if (tmp___1 < 0) {
        {
#line 881
        Trace((int const   )-1, (char const   */* const  */)"failed to AddToListOfFilesToEdit %s\n",
              lp->line);
#line 882
        DisposeLineListContents(& globlist);
#line 883
        DisposeLineListContents(& rfiles);
#line 884
        DisposeLineListContents(& lfiles);
#line 885
        time(& gCmdStart);
        }
#line 886
        return;
      }
#line 888
      n ++;
#line 889
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 891
      Trace((int const   )-1, (char const   */* const  */)"Cannot edit directory - ignoring \"%s\"\n",
            lp->line);
      }
#line 892
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 894
      tmp___3 = AskYesNoQuestion((int const   )1, (char const   */* const  */)"The file \"%s\" does not exist!  Do you want to create it? (Yes/no) ",
                                 lp->line);
      }
#line 894
      if (tmp___3 > 0) {
        {
#line 895
        tmp___2 = AddToListOfFilesToEdit(& rfiles, & lfiles, lp->line, 1);
        }
#line 895
        if (tmp___2 < 0) {
          {
#line 896
          Trace((int const   )-1, (char const   */* const  */)"failed to AddToListOfFilesToEdit %s\n",
                lp->line);
#line 897
          DisposeLineListContents(& globlist);
#line 898
          DisposeLineListContents(& rfiles);
#line 899
          DisposeLineListContents(& lfiles);
#line 900
          time(& gCmdStart);
          }
#line 901
          return;
        }
#line 903
        n ++;
      }
      switch_break: /* CIL Label */ ;
      }
#line 876
      lp = lp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 907
    DisposeLineListContents(& globlist);
    }
    __Cont: /* CIL Label */ 
#line 869
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 911
  InitLineList(& modstrs);
#line 912
  rlp = rfiles.first;
#line 912
  llp = lfiles.first;
#line 912
  n2 = n;
  }
  {
#line 912
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 912
    if ((unsigned long )rlp != (unsigned long )((void *)0)) {
#line 912
      if (! ((unsigned long )llp != (unsigned long )((void *)0))) {
#line 912
        goto while_break___1;
      }
    } else {
#line 912
      goto while_break___1;
    }
    {
#line 914
    rpath = rlp->line;
#line 915
    tmp___7 = strlen("//|||//");
#line 915
    tmp___8 = strncmp((char const   *)rpath, "//|||//", tmp___7);
    }
#line 915
    if (tmp___8 == 0) {
      {
#line 916
      tmp___4 = strlen("//|||//");
#line 916
      rpath += tmp___4;
#line 917
      fp = fopen((char const   */* __restrict  */)llp->line, (char const   */* __restrict  */)"w");
      }
#line 917
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
#line 918
        tmp___5 = __errno_location();
#line 918
        tmp___6 = strerror(*tmp___5);
#line 918
        Trace((int const   )0, (char const   */* const  */)"Could not create temporary file \"%s\" : %s\n",
              llp->line, tmp___6);
#line 919
        DisposeLineListContents(& modstrs);
#line 920
        DisposeLineListContents(& rfiles);
#line 921
        DisposeLineListContents(& lfiles);
#line 922
        time(& gCmdStart);
        }
#line 923
        return;
      }
      {
#line 925
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"This will be the remote file \"%s\" after you finish editing this file.\n",
              rpath);
#line 926
      fclose(fp);
#line 927
      result = 0;
      }
    } else {
#line 930
      if (n2 > 0) {
        {
#line 931
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
        }
      }
      {
#line 932
      Trace((int const   )-1, (char const   */* const  */)"Please wait while %s is downloaded for editing.\n",
            rpath);
#line 933
      result = FTPGetOneFile3((FTPCIPtr const   )(& gConn), (char const   */* const  */)rpath,
                              (char const   */* const  */)llp->line, (int const   )'I',
                              (int const   )-1, (int const   )0, (int const   )0,
                              (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                    char const   **localpath ,
                                                                    long long localsize ,
                                                                    time_t localmtime ,
                                                                    char const   *remotepath ,
                                                                    long long remotesize ,
                                                                    time_t remotetime ,
                                                                    long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                      char const   **localpath ,
                                                                                                      long long localsize ,
                                                                                                      time_t localmtime ,
                                                                                                      char const   *remotepath ,
                                                                                                      long long remotesize ,
                                                                                                      time_t remotetime ,
                                                                                                      long long *startPoint ))0),
                              0);
      }
    }
#line 935
    if (result < 0) {
      {
#line 936
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-160,
                (char const   */* const  */)"get for editing", (char const   */* const  */)rpath);
#line 937
      *(rlp->line + 0) = (char )'\000';
#line 938
      n --;
#line 939
      memset((void *)(& st), 0, sizeof(st));
      }
    } else {
      {
#line 940
      tmp___9 = stat((char const   */* __restrict  */)llp->line, (struct stat */* __restrict  */)(& st));
      }
#line 940
      if (tmp___9 < 0) {
        {
#line 942
        Trace((int const   )-1, (char const   */* const  */)"Cannot edit \"%s\", as the local file \"%s\" was deleted after it was downloaded.\n",
              rpath, llp->line);
#line 943
        *(rlp->line + 0) = (char )'\000';
#line 944
        *(llp->line + 0) = (char )'\000';
#line 945
        n --;
#line 946
        memset((void *)(& st), 0, sizeof(st));
        }
      }
    }
    {
#line 949
    sprintf((char */* __restrict  */)(modstr), (char const   */* __restrict  */)"%u %llu",
            (unsigned int )st.st_mtim.tv_sec, (unsigned long long )st.st_size);
#line 953
    tmp___10 = AddLine(& modstrs, (char const   *)(modstr));
    }
#line 953
    if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
      {
#line 954
      DisposeLineListContents(& modstrs);
#line 955
      DisposeLineListContents(& rfiles);
#line 956
      DisposeLineListContents(& lfiles);
#line 957
      time(& gCmdStart);
      }
#line 958
      return;
    }
#line 912
    rlp = rlp->next;
#line 912
    llp = llp->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 962
  if (n <= 0) {
    {
#line 963
    Trace((int const   )-1, (char const   */* const  */)"Nothing to edit!\n");
#line 964
    DisposeLineListContents(& modstrs);
#line 965
    DisposeLineListContents(& rfiles);
#line 966
    DisposeLineListContents(& lfiles);
#line 967
    time(& gCmdStart);
    }
#line 968
    return;
  }
  {
#line 972
  Strncpy((char */* const  */)(cmdbuf), (char const   */* const  */)"exec ", (size_t const   )sizeof(cmdbuf));
#line 973
  Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)envEDITOR, (size_t const   )sizeof(cmdbuf));
#line 974
  rlp = rfiles.first;
#line 974
  llp = lfiles.first;
  }
  {
#line 974
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 974
    if ((unsigned long )rlp != (unsigned long )((void *)0)) {
#line 974
      if (! ((unsigned long )llp != (unsigned long )((void *)0))) {
#line 974
        goto while_break___2;
      }
    } else {
#line 974
      goto while_break___2;
    }
#line 975
    if ((int )*(rlp->line + 0) == 0) {
#line 976
      goto __Cont___0;
    } else
#line 975
    if ((int )*(llp->line + 0) == 0) {
#line 976
      goto __Cont___0;
    }
    {
#line 977
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)" \'", (size_t const   )sizeof(cmdbuf));
#line 978
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)llp->line, (size_t const   )sizeof(cmdbuf));
#line 979
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)"\'", (size_t const   )sizeof(cmdbuf));
    }
    __Cont___0: /* CIL Label */ 
#line 974
    rlp = rlp->next;
#line 974
    llp = llp->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 982
  if (n2 > 1) {
    {
#line 983
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
#line 984
    AskYesNoQuestion((int const   )1, (char const   */* const  */)"All files downloaded.  Press ENTER to start editing. ");
    }
  }
  {
#line 987
  result = system((char const   *)(cmdbuf));
#line 988
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
  }
#line 990
  if (result == 0) {
    {
#line 991
    __constr_expr_4.__in = result;
#line 991
    Trace((int const   )0, (char const   */* const  */)"%.480s (es=%d)\n", cmdbuf,
          (__constr_expr_4.__i & 65280) >> 8);
    }
  } else {
#line 990
    __constr_expr_5.__in = result;
#line 990
    if ((__constr_expr_5.__i & 127) == 0) {
      {
#line 991
      __constr_expr_4.__in = result;
#line 991
      Trace((int const   )0, (char const   */* const  */)"%.480s (es=%d)\n", cmdbuf,
            (__constr_expr_4.__i & 65280) >> 8);
      }
    } else {
      {
#line 993
      Trace((int const   )0, (char const   */* const  */)"%.480s (es=0x%08x)\n", cmdbuf,
            result);
      }
    }
  }
#line 999
  rlp = rfiles.first;
#line 999
  llp = lfiles.first;
#line 999
  mlp = modstrs.first;
  {
#line 999
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 999
    if ((unsigned long )rlp != (unsigned long )((void *)0)) {
#line 999
      if ((unsigned long )llp != (unsigned long )((void *)0)) {
#line 999
        if (! ((unsigned long )mlp != (unsigned long )((void *)0))) {
#line 999
          goto while_break___3;
        }
      } else {
#line 999
        goto while_break___3;
      }
    } else {
#line 999
      goto while_break___3;
    }
#line 1000
    if ((int )*(rlp->line + 0) == 0) {
#line 1001
      goto __Cont___1;
    } else
#line 1000
    if ((int )*(llp->line + 0) == 0) {
#line 1001
      goto __Cont___1;
    }
    {
#line 1002
    rpath = rlp->line;
#line 1003
    tmp___12 = strlen("//|||//");
#line 1003
    tmp___13 = strncmp((char const   *)rpath, "//|||//", tmp___12);
    }
#line 1003
    if (tmp___13 == 0) {
      {
#line 1004
      tmp___11 = strlen("//|||//");
#line 1004
      rpath += tmp___11;
      }
    }
    {
#line 1005
    tmp___14 = stat((char const   */* __restrict  */)llp->line, (struct stat */* __restrict  */)(& st));
    }
#line 1005
    if (tmp___14 < 0) {
      {
#line 1006
      Trace((int const   )-1, (char const   */* const  */)"Cannot upload edited file \"%s\", as the local file \"%s\" was deleted after it was downloaded.\n",
            rpath, llp->line);
#line 1007
      *(rlp->line + 0) = (char )'\000';
#line 1008
      *(llp->line + 0) = (char )'\000';
#line 1009
      n --;
#line 1010
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
      }
#line 1011
      goto __Cont___1;
    }
    {
#line 1014
    sprintf((char */* __restrict  */)(modstr), (char const   */* __restrict  */)"%u %llu",
            (unsigned int )st.st_mtim.tv_sec, (unsigned long long )st.st_size);
#line 1018
    tmp___15 = strcmp((char const   *)(modstr), (char const   *)mlp->line);
    }
#line 1018
    if (tmp___15 == 0) {
      {
#line 1019
      Trace((int const   )-1, (char const   */* const  */)"No changes made to \"%s\".\n",
            rpath);
      }
#line 1020
      goto __Cont___1;
    }
    {
#line 1022
    tmp___16 = AskYesNoQuestion((int const   )-1, (char const   */* const  */)"Put edited file \"%s\" ? (yes/no) ",
                                rpath);
    }
#line 1022
    if (tmp___16 > 0) {
      {
#line 1023
      result = FTPPutOneFile3((FTPCIPtr const   )(& gConn), (char const   */* const  */)llp->line,
                              (char const   */* const  */)rpath, (int const   )'I',
                              (int const   )-1, (int const   )0, (char const   */* const  */)((void *)0),
                              (char const   */* const  */)((void *)0), (int const   )0,
                              (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                    char const   *localpath ,
                                                                    long long localsize ,
                                                                    time_t localmtime ,
                                                                    char const   **remotepath ,
                                                                    long long remotesize ,
                                                                    time_t remotetime ,
                                                                    long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                      char const   *localpath ,
                                                                                                      long long localsize ,
                                                                                                      time_t localmtime ,
                                                                                                      char const   **remotepath ,
                                                                                                      long long remotesize ,
                                                                                                      time_t remotetime ,
                                                                                                      long long *startPoint ))0),
                              0);
      }
#line 1024
      if (result < 0) {
        {
#line 1025
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-160,
                  (char const   */* const  */)"put", (char const   */* const  */)rpath);
#line 1026
        Trace((int const   )-1, (char const   */* const  */)"Local changes to \"%s\" can be recovered from \"%s\".\n",
              rpath, llp->line);
#line 1027
        *(llp->line + 0) = (char )'\000';
#line 1028
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
        }
      }
    }
    __Cont___1: /* CIL Label */ 
#line 999
    rlp = rlp->next;
#line 999
    llp = llp->next;
#line 999
    mlp = mlp->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1033
  llp = lfiles.first;
  {
#line 1033
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1033
    if (! ((unsigned long )llp != (unsigned long )((void *)0))) {
#line 1033
      goto while_break___4;
    }
#line 1034
    if ((int )*(llp->line + 0) != 0) {
      {
#line 1035
      tmp___19 = remove((char const   *)llp->line);
      }
#line 1035
      if (tmp___19 < 0) {
        {
#line 1036
        tmp___17 = __errno_location();
#line 1036
        tmp___18 = strerror(*tmp___17);
#line 1036
        Trace((int const   )0, (char const   */* const  */)"Could not remove temporary file \"%s\" : %s\n",
              llp->line, tmp___18);
        }
      }
    }
#line 1033
    llp = llp->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1040
  DisposeLineListContents(& modstrs);
#line 1041
  DisposeLineListContents(& rfiles);
#line 1042
  DisposeLineListContents(& lfiles);
#line 1043
  FlushLsCache();
#line 1044
  time(& gCmdStart);
  }
#line 1045
  return;
}
}
#line 1066 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static char newname[128]  ;
#line 1053 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int NcFTPConfirmResumeDownloadProc(FTPCIPtr const   cipUNUSED , char const   **localpath ,
                                          long long localsize , time_t localmtime ,
                                          char const   *remotepath , long long remotesize ,
                                          time_t remotemtime , long long *startPoint ) 
{ 
  int zaction ;
  char tstr[80] ;
  char ans[32] ;
  struct tm t ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 1064
  zaction = 5;
#line 1069
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 1070
  if (gResumeAnswerAll != 0) {
#line 1071
    if (gResumeAnswerAll == 2) {
#line 1072
      if (gConn.hasREST != 1) {
#line 1074
        return (zaction);
      } else
#line 1072
      if (remotesize == -1LL) {
#line 1074
        return (zaction);
      } else
#line 1075
      if (remotesize < localsize) {
#line 1077
        return (zaction);
      } else
#line 1078
      if (remotesize <= localsize) {
#line 1080
        return (zaction);
      }
#line 1082
      *startPoint = localsize;
    }
#line 1084
    return (gResumeAnswerAll);
  }
#line 1087
  if (gAutoResume != 0) {
#line 1088
    return (5);
  } else
#line 1087
  if (gIsTTYr == 0) {
#line 1088
    return (5);
  }
  {
#line 1090
  tstr[sizeof(tstr) - 1UL] = (char )'\000';
#line 1091
  tmp = Localtime(localmtime, (struct tm */* const  */)(& t));
#line 1091
  strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
           (struct tm  const  */* __restrict  */)tmp);
#line 1092
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nThe local file \"%s\" already exists.\n\tLocal:  %12lld bytes, dated %s.\n",
          *localpath, localsize, tstr);
  }
#line 1107
  if (remotemtime != -1L) {
#line 1107
    if (remotesize != -1LL) {
      {
#line 1108
      tmp___0 = Localtime(remotemtime, (struct tm */* const  */)(& t));
#line 1108
      strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
               (struct tm  const  */* __restrict  */)tmp___0);
#line 1109
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tRemote: %12lld bytes, dated %s.\n",
              remotesize, tstr);
      }
#line 1122
      if (remotemtime == localmtime) {
#line 1122
        if (remotesize == localsize) {
          {
#line 1123
          printf((char const   */* __restrict  */)"\t(Files are identical, skipped)\n\n");
          }
#line 1124
          return (1);
        }
      }
    } else {
#line 1107
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1126
  if (remotesize != -1LL) {
    {
#line 1127
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tRemote: %12lld bytes, date unknown.\n",
            remotesize);
    }
  } else
#line 1139
  if (remotemtime != -1L) {
    {
#line 1140
    tmp___1 = Localtime(remotemtime, (struct tm */* const  */)(& t));
#line 1140
    strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
             (struct tm  const  */* __restrict  */)tmp___1);
#line 1141
    printf((char const   */* __restrict  */)"\tRemote: size unknown, dated %s.\n",
           tstr);
    }
  }
  {
#line 1147
  printf((char const   */* __restrict  */)"\n");
#line 1148
  memset((void *)(ans), 0, sizeof(ans));
  }
  {
#line 1149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1150
    printf((char const   */* __restrict  */)"\t[O]verwrite?");
    }
#line 1151
    if (gConn.hasREST == 1) {
#line 1151
      if (remotesize != -1LL) {
#line 1151
        if (remotesize > localsize) {
          {
#line 1152
          printf((char const   */* __restrict  */)"  [R]esume?");
          }
        }
      }
    }
    {
#line 1153
    printf((char const   */* __restrict  */)"  [A]ppend to?  [S]kip?  [N]ew Name?\n");
#line 1154
    printf((char const   */* __restrict  */)"\t[O!]verwrite all?");
    }
#line 1155
    if (gConn.hasREST == 1) {
#line 1155
      if (remotesize != -1LL) {
#line 1155
        if (remotesize > localsize) {
          {
#line 1156
          printf((char const   */* __restrict  */)"  [R!]esume all?");
          }
        }
      }
    }
    {
#line 1157
    printf((char const   */* __restrict  */)"  [S!]kip all?  [C]ancel  > ");
#line 1158
    fflush(stdin);
#line 1159
    fgets((char */* __restrict  */)(ans), (int )(sizeof(ans) - 1UL), (FILE */* __restrict  */)stdin);
    }
    {
#line 1162
    if ((int )ans[0] == 67) {
#line 1162
      goto case_67;
    }
#line 1162
    if ((int )ans[0] == 99) {
#line 1162
      goto case_67;
    }
#line 1168
    if ((int )ans[0] == 79) {
#line 1168
      goto case_79;
    }
#line 1168
    if ((int )ans[0] == 111) {
#line 1168
      goto case_79;
    }
#line 1173
    if ((int )ans[0] == 82) {
#line 1173
      goto case_82;
    }
#line 1173
    if ((int )ans[0] == 114) {
#line 1173
      goto case_82;
    }
#line 1195
    if ((int )ans[0] == 83) {
#line 1195
      goto case_83;
    }
#line 1195
    if ((int )ans[0] == 115) {
#line 1195
      goto case_83;
    }
#line 1200
    if ((int )ans[0] == 78) {
#line 1200
      goto case_78;
    }
#line 1200
    if ((int )ans[0] == 110) {
#line 1200
      goto case_78;
    }
#line 1206
    if ((int )ans[0] == 65) {
#line 1206
      goto case_65;
    }
#line 1206
    if ((int )ans[0] == 97) {
#line 1206
      goto case_65;
    }
#line 1212
    if ((int )ans[0] == 71) {
#line 1212
      goto case_71;
    }
#line 1212
    if ((int )ans[0] == 103) {
#line 1212
      goto case_71;
    }
#line 1216
    goto switch_default;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 1163
    ans[0] = (char )'C';
#line 1164
    ans[1] = (char )'\000';
#line 1165
    zaction = 6;
#line 1166
    goto switch_break;
    case_79: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 1169
    ans[0] = (char )'O';
#line 1170
    zaction = 3;
#line 1171
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 1174
    if (gConn.hasREST != 1) {
      {
#line 1175
      printf((char const   */* __restrict  */)"\tResume is not available on this server.\n\n");
#line 1176
      ans[0] = (char )'\000';
      }
#line 1177
      goto switch_break;
    } else
#line 1174
    if (remotesize == -1LL) {
      {
#line 1175
      printf((char const   */* __restrict  */)"\tResume is not available on this server.\n\n");
#line 1176
      ans[0] = (char )'\000';
      }
#line 1177
      goto switch_break;
    } else
#line 1178
    if (remotesize < localsize) {
      {
#line 1179
      printf((char const   */* __restrict  */)"\tCannot resume when local file is already larger than the remote file.\n\n");
#line 1180
      ans[0] = (char )'\000';
      }
#line 1181
      goto switch_break;
    } else
#line 1182
    if (remotesize <= localsize) {
      {
#line 1183
      printf((char const   */* __restrict  */)"\tLocal file is already the same size as the remote file.\n\n");
#line 1184
      ans[0] = (char )'\000';
      }
#line 1185
      goto switch_break;
    }
    {
#line 1187
    ans[0] = (char )'R';
#line 1188
    *startPoint = localsize;
#line 1189
    zaction = 2;
#line 1190
    tmp___2 = OneTimeMessage((char const   */* const  */)"auto-resume");
    }
#line 1190
    if (tmp___2 != 0) {
      {
#line 1191
      printf((char const   */* __restrict  */)"\n\tNOTE: If you want NcFTP to guess automatically, \"set auto-resume yes\"\n\n");
      }
    }
#line 1193
    goto switch_break;
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1196
    ans[0] = (char )'S';
#line 1197
    zaction = 1;
#line 1198
    goto switch_break;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 1201
    ans[0] = (char )'N';
#line 1202
    ans[1] = (char )'\000';
#line 1203
    zaction = 3;
#line 1204
    goto switch_break;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 1207
    ans[0] = (char )'A';
#line 1208
    ans[1] = (char )'\000';
#line 1209
    zaction = 4;
#line 1210
    goto switch_break;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
#line 1213
    ans[0] = (char )'G';
#line 1214
    zaction = 5;
#line 1215
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1217
    ans[0] = (char )'\000';
    switch_break: /* CIL Label */ ;
    }
#line 1219
    if ((int )ans[0] != 0) {
#line 1220
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1223
  if ((int )ans[0] == 78) {
    {
#line 1224
    memset((void *)(newname), 0, sizeof(newname));
#line 1225
    printf((char const   */* __restrict  */)"\tSave as:  ");
#line 1226
    fflush(stdin);
#line 1227
    fgets((char */* __restrict  */)(newname), (int )(sizeof(newname) - 1UL), (FILE */* __restrict  */)stdin);
#line 1228
    tmp___3 = strlen((char const   *)(newname));
#line 1228
    newname[tmp___3 - 1UL] = (char )'\000';
    }
#line 1229
    if ((int )newname[0] == 0) {
      {
#line 1231
      printf((char const   */* __restrict  */)"Skipped %s.\n", remotepath);
#line 1232
      zaction = 1;
      }
    } else {
#line 1234
      *localpath = (char const   *)(newname);
    }
  }
#line 1238
  if ((int )ans[1] == 33) {
#line 1239
    gResumeAnswerAll = zaction;
  }
#line 1240
  return (zaction);
}
}
#line 1247 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void GetCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int optrc ;
  int renameMode ;
  int recurseFlag ;
  int appendFlag ;
  int resumeFlag ;
  int tarflag ;
  char const   *dstdir ;
  int rc ;
  int i___0 ;
  int doGlob ;
  int xtype ;
  int nD ;
  int deleteFlag ;
  char pattern[256] ;
  void (* volatile  osigint)(int  ) ;
  int (*confirmProc)(FTPCIPtr const   cip , char const   **localpath , long long localsize ,
                     time_t localmtime , char const   *remotepath , long long remotesize ,
                     time_t remotetime , long long *startPoint ) ;
  GetoptInfo opt ;
  int tmp ;
  void (*tmp___0)(int  ) ;
  void (*tmp___1)(int  ) ;

  {
#line 1251
  renameMode = 0;
#line 1252
  recurseFlag = 0;
#line 1253
  appendFlag = 0;
#line 1254
  resumeFlag = 1;
#line 1255
  tarflag = 1;
#line 1256
  dstdir = (char const   *)((void *)0);
#line 1260
  xtype = gBm.xferType;
#line 1261
  nD = 0;
#line 1262
  deleteFlag = 0;
#line 1268
  confirmProc = & NcFTPConfirmResumeDownloadProc;
#line 1269
  gResumeAnswerAll = 0;
#line 1270
  if (argc != 0) {
#line 1270
    tmp = 1;
  } else
#line 1270
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1270
    tmp = 1;
  } else
#line 1270
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1270
    tmp = 1;
  } else
#line 1270
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1270
    tmp = 1;
  } else {
#line 1270
    tmp = 0;
  }
  {
#line 1270
  gUnusedArg = tmp;
#line 1271
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 1272
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1272
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"aAzfrRTD");
    }
#line 1272
    if (! (optrc >= 0)) {
#line 1272
      goto while_break;
    }
    {
#line 1273
    if (optrc == 97) {
#line 1273
      goto case_97;
    }
#line 1276
    if (optrc == 65) {
#line 1276
      goto case_65;
    }
#line 1283
    if (optrc == 90) {
#line 1283
      goto case_90;
    }
#line 1283
    if (optrc == 102) {
#line 1283
      goto case_90;
    }
#line 1291
    if (optrc == 122) {
#line 1291
      goto case_122;
    }
#line 1300
    if (optrc == 82) {
#line 1300
      goto case_82;
    }
#line 1300
    if (optrc == 114) {
#line 1300
      goto case_82;
    }
#line 1306
    if (optrc == 84) {
#line 1306
      goto case_84;
    }
#line 1317
    if (optrc == 68) {
#line 1317
      goto case_68;
    }
#line 1326
    goto switch_default;
    case_97: /* CIL Label */ 
#line 1274
    xtype = 'A';
#line 1275
    goto switch_break;
    case_65: /* CIL Label */ 
#line 1280
    appendFlag = 1;
#line 1281
    goto switch_break;
    case_90: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 1288
    resumeFlag = 0;
#line 1289
    confirmProc = (int (*)(FTPCIPtr const   cip , char const   **localpath , long long localsize ,
                           time_t localmtime , char const   *remotepath , long long remotesize ,
                           time_t remotetime , long long *startPoint ))0;
#line 1290
    goto switch_break;
    case_122: /* CIL Label */ 
#line 1297
    renameMode = 1;
#line 1298
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 1304
    recurseFlag = 1;
#line 1305
    goto switch_break;
    case_84: /* CIL Label */ 
#line 1315
    tarflag = 0;
#line 1316
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1324
    nD ++;
#line 1325
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1327
    PrintCmdUsage((CommandPtr )cmdp);
    }
#line 1328
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1331
  if (nD >= 2) {
#line 1332
    deleteFlag = 1;
  }
#line 1334
  if (renameMode != 0) {
#line 1335
    if (opt.ind > (int )(argc - 2)) {
      {
#line 1336
      PrintCmdUsage((CommandPtr )cmdp);
#line 1337
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFor get with rename, try \"get -z remote-path-name local-path-name\".\n");
      }
#line 1338
      return;
    }
    {
#line 1340
    tmp___0 = NcSignal(2, & XferCanceller);
#line 1340
    osigint = (void (*/* volatile  */)(int  ))tmp___0;
#line 1341
    rc = FTPGetOneFile3((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + opt.ind),
                        (char const   */* const  */)*(argv + (opt.ind + 1)), (int const   )xtype,
                        (int const   )-1, (int const   )resumeFlag, (int const   )appendFlag,
                        (int const   )deleteFlag, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                       char const   **localpath ,
                                                                       long long localsize ,
                                                                       time_t localmtime ,
                                                                       char const   *remotepath ,
                                                                       long long remotesize ,
                                                                       time_t remotetime ,
                                                                       long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                         char const   **localpath ,
                                                                                                         long long localsize ,
                                                                                                         time_t localmtime ,
                                                                                                         char const   *remotepath ,
                                                                                                         long long remotesize ,
                                                                                                         time_t remotetime ,
                                                                                                         long long *startPoint ))0),
                        0);
    }
#line 1342
    if (rc < 0) {
      {
#line 1343
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-160,
                (char const   */* const  */)"get", (char const   */* const  */)*(argv + opt.ind));
      }
    }
  } else {
    {
#line 1345
    tmp___1 = NcSignal(2, & XferCanceller);
#line 1345
    osigint = (void (*/* volatile  */)(int  ))tmp___1;
#line 1346
    i___0 = opt.ind;
    }
    {
#line 1346
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1346
      if (! (i___0 < (int )argc)) {
#line 1346
        goto while_break___0;
      }
#line 1347
      if (aip->noglobargv[i___0] != 0) {
#line 1347
        doGlob = 0;
      } else {
#line 1347
        doGlob = 1;
      }
      {
#line 1348
      Strncpy((char */* const  */)(pattern), (char const   */* const  */)*(argv + i___0),
              (size_t const   )sizeof(pattern));
#line 1349
      StrRemoveTrailingSlashes(pattern);
#line 1350
      rc = FTPGetFiles3((FTPCIPtr const   )(& gConn), (char const   *)(pattern), (char const   */* const  */)dstdir,
                        (int const   )recurseFlag, doGlob, (int const   )xtype, (int const   )resumeFlag,
                        appendFlag, (int const   )deleteFlag, (int const   )tarflag,
                        (int (*/* const  */)(FTPCIPtr const   cip , char const   **localpath ,
                                             long long localsize , time_t localmtime ,
                                             char const   *remotepath , long long remotesize ,
                                             time_t remotetime , long long *startPoint ))confirmProc,
                        0);
      }
#line 1351
      if (rc < 0) {
        {
#line 1352
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-160,
                  (char const   */* const  */)"get", (char const   */* const  */)*(argv + i___0));
        }
      }
#line 1346
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1355
  NcSignal(2, (void (*)(int  ))osigint);
#line 1356
  fflush(stdin);
  }
#line 1358
  if (deleteFlag == 1) {
    {
#line 1360
    FlushLsCache();
    }
  }
#line 1362
  return;
}
}
#line 1368 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void HelpCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  CommandPtr c ;
  int showall ;
  int helpall ;
  int i___0 ;
  int j ;
  int k ;
  int n ;
  int nRows ;
  int nCols ;
  int nCmds2Print ;
  int screenColumns ;
  int len ;
  int widestName ;
  char *cp ;
  char spec[16] ;
  char const   *cmdnames[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 1372
  showall = 0;
#line 1372
  helpall = 0;
#line 1381
  if (argc != 0) {
#line 1381
    tmp = 1;
  } else
#line 1381
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1381
    tmp = 1;
  } else
#line 1381
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1381
    tmp = 1;
  } else
#line 1381
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1381
    tmp = 1;
  } else {
#line 1381
    tmp = 0;
  }
#line 1381
  gUnusedArg = tmp;
#line 1382
  if (! (gNumCommands < sizeof(cmdnames) / sizeof(char *))) {
    {
#line 1382
    __assert_fail("gNumCommands < (sizeof(cmdnames) / sizeof(char *))", "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c",
                  1382U, "HelpCmd");
    }
  }
#line 1383
  if (argc == 2) {
    {
#line 1384
    tmp___0 = strcmp((char const   *)*(argv + 1), "showall");
#line 1384
    showall = tmp___0 == 0;
#line 1385
    tmp___1 = strcmp((char const   *)*(argv + 1), "helpall");
#line 1385
    helpall = tmp___1 == 0;
    }
  }
#line 1387
  if (argc == 1) {
#line 1387
    goto _L___0;
  } else
#line 1387
  if (showall) {
    _L___0: /* CIL Label */ 
    {
#line 1388
    printf((char const   */* __restrict  */)"Commands may be abbreviated.  \'help showall\' shows hidden and unsupported \ncommands.  \'help <command>\' gives a brief description of <command>.\n\n");
#line 1396
    c = gCommands;
#line 1397
    nCmds2Print = 0;
#line 1398
    n = 0;
    }
    {
#line 1398
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1398
      if (! (n < (int )gNumCommands)) {
#line 1398
        goto while_break;
      }
      {
#line 1399
      tmp___2 = __ctype_b_loc();
      }
#line 1399
      if (! ((int const   )*(*tmp___2 + (int )*(c->name + 0)) & 2)) {
#line 1399
        if (! (c->flags & 1)) {
#line 1400
          nCmds2Print ++;
        } else
#line 1399
        if (showall) {
#line 1400
          nCmds2Print ++;
        }
      }
#line 1398
      c ++;
#line 1398
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1405
    memset((void *)(cmdnames), 0, sizeof(cmdnames));
#line 1411
    c = gCommands;
#line 1412
    i___0 = 0;
#line 1413
    widestName = 0;
#line 1414
    n = 0;
    }
    {
#line 1414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1414
      if (! (n < (int )gNumCommands)) {
#line 1414
        goto while_break___0;
      }
      {
#line 1415
      tmp___5 = __ctype_b_loc();
      }
#line 1415
      if (! ((int const   )*(*tmp___5 + (int )*(c->name + 0)) & 2)) {
#line 1415
        if (! (c->flags & 1)) {
#line 1415
          goto _L;
        } else
#line 1415
        if (showall) {
          _L: /* CIL Label */ 
          {
#line 1416
          tmp___3 = i___0;
#line 1416
          i___0 ++;
#line 1416
          cmdnames[tmp___3] = c->name;
#line 1417
          tmp___4 = strlen(c->name);
#line 1417
          len = (int )tmp___4;
          }
#line 1418
          if (len > widestName) {
#line 1419
            widestName = len;
          }
        }
      }
#line 1414
      c ++;
#line 1414
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1423
    tmp___6 = getenv("COLUMNS");
#line 1423
    cp = tmp___6;
    }
#line 1423
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 1424
      screenColumns = 80;
    } else {
      {
#line 1426
      screenColumns = atoi((char const   *)cp);
      }
    }
#line 1429
    widestName += 2;
#line 1431
    nCols = screenColumns / widestName;
#line 1432
    nRows = nCmds2Print / nCols;
#line 1433
    if (nCmds2Print % nCols > 0) {
#line 1434
      nRows ++;
    }
#line 1436
    i___0 = 0;
    {
#line 1436
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1436
      if (! (i___0 < nRows)) {
#line 1436
        goto while_break___1;
      }
#line 1437
      j = 0;
      {
#line 1437
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1437
        if (! (j < nCols)) {
#line 1437
          goto while_break___2;
        }
#line 1438
        k = nRows * j + i___0;
#line 1439
        if (k < nCmds2Print) {
#line 1440
          if (j < nCols - 1) {
#line 1440
            tmp___7 = widestName;
          } else {
#line 1440
            tmp___7 = widestName - 2;
          }
          {
#line 1440
          sprintf((char */* __restrict  */)(spec), (char const   */* __restrict  */)"%%-%ds",
                  tmp___7);
#line 1443
          printf((char const   */* __restrict  */)(spec), cmdnames[k]);
          }
        }
#line 1437
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1446
      printf((char const   */* __restrict  */)"\n");
#line 1436
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 1448
  if (helpall) {
#line 1450
    c = gCommands;
#line 1450
    n = 0;
    {
#line 1450
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1450
      if (! (n < (int )gNumCommands)) {
#line 1450
        goto while_break___3;
      }
      {
#line 1451
      PrintCmdHelp(c);
#line 1452
      PrintCmdUsage(c);
#line 1450
      c ++;
#line 1450
      n ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
#line 1456
    i___0 = 1;
    {
#line 1456
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1456
      if (! (i___0 < (int )argc)) {
#line 1456
        goto while_break___4;
      }
      {
#line 1457
      c = GetCommandByName((char const   */* const  */)*(argv + i___0), 0);
      }
#line 1458
      if ((unsigned long )c == (unsigned long )((CommandPtr )-1)) {
        {
#line 1459
        printf((char const   */* __restrict  */)"%s: ambiguous command name.\n", *(argv + i___0));
        }
      } else
#line 1460
      if ((unsigned long )c == (unsigned long )((CommandPtr )0)) {
        {
#line 1461
        printf((char const   */* __restrict  */)"%s: no such command.\n", *(argv + i___0));
        }
      } else {
#line 1463
        if (i___0 > 1) {
          {
#line 1464
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 1465
        PrintCmdHelp(c);
#line 1466
        PrintCmdUsage(c);
        }
      }
#line 1456
      i___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1470
  printf((char const   */* __restrict  */)"\nFor details, please see the manual (\"man ncftp\" at your regular shell prompt\nor online at http://www.NcFTP.com/ncftp/doc/ncftp.html).\n");
  }
#line 1471
  return;
}
}
#line 1479 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int PrintHosts(void) 
{ 
  FILE *bookmarks ;
  FILE *pager ;
  int nbm ;
  Bookmark bm ;
  char url[128] ;
  void (*osigpipe)(int  ) ;
  void (*tmp)(int  ) ;
  int tmp___0 ;

  {
  {
#line 1484
  nbm = 0;
#line 1491
  bookmarks = OpenBookmarkFile((int *)((void *)0));
  }
#line 1492
  if ((unsigned long )bookmarks == (unsigned long )((void *)0)) {
#line 1493
    return (0);
  }
  {
#line 1496
  tmp = NcSignal(13, (void (*)(int  ))1);
#line 1496
  osigpipe = tmp;
#line 1498
  pager = OpenPager___0();
  }
  {
#line 1500
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1500
    tmp___0 = GetNextBookmark(bookmarks, & bm);
    }
#line 1500
    if (! (tmp___0 == 0)) {
#line 1500
      goto while_break;
    }
#line 1501
    nbm ++;
#line 1502
    if (nbm == 1) {
      {
#line 1504
      fprintf((FILE */* __restrict  */)pager, (char const   */* __restrict  */)"--BOOKMARK----------URL--------------------------------------------------------\n");
      }
    }
    {
#line 1506
    BookmarkToURL(& bm, url, sizeof(url));
#line 1507
    fprintf((FILE */* __restrict  */)pager, (char const   */* __restrict  */)"  %-16s  %s\n",
            bm.bookmarkName, url);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1510
  ClosePager___0(pager);
#line 1511
  CloseBookmarkFile(bookmarks);
#line 1514
  NcSignal(13, osigpipe);
  }
#line 1516
  return (nbm);
}
}
#line 1523 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int RunBookmarkEditor(char *selectedBmName , size_t dsize ) 
{ 
  char ncftpbookmarks[256] ;
  char *av[8] ;
  int pid ;
  int status ;
  char bmSelectionFile[256] ;
  char pidStr[32] ;
  FILE *fp ;
  __pid_t tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  union __anonunion_62 __constr_expr_6 ;
  union __anonunion_63 __constr_expr_7 ;
  int tmp___4 ;

  {
#line 1602
  if ((unsigned long )selectedBmName != (unsigned long )((void *)0)) {
    {
#line 1603
    memset((void *)selectedBmName, 0, dsize);
    }
  }
  {
#line 1605
  Strncpy((char */* const  */)(ncftpbookmarks), (char const   */* const  */)"/usr/local/bin",
          (size_t const   )sizeof(ncftpbookmarks));
#line 1606
  Strncat((char */* const  */)(ncftpbookmarks), (char const   */* const  */)"/", (size_t const   )sizeof(ncftpbookmarks));
#line 1607
  Strncat((char */* const  */)(ncftpbookmarks), (char const   */* const  */)"ncftpbookmarks",
          (size_t const   )sizeof(ncftpbookmarks));
#line 1624
  Strncpy((char */* const  */)(bmSelectionFile), (char const   */* const  */)"view",
          (size_t const   )sizeof(bmSelectionFile));
  }
#line 1625
  if ((unsigned long )selectedBmName != (unsigned long )((void *)0)) {
#line 1625
    if ((int )gOurDirectoryPath[0] != 0) {
      {
#line 1626
      tmp = getpid();
#line 1626
      sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)".%u",
              (unsigned int )tmp);
#line 1627
      OurDirectoryPath((char */* const  */)(bmSelectionFile), (size_t const   )sizeof(bmSelectionFile),
                       (char const   */* const  */)"bm2open");
#line 1628
      Strncat((char */* const  */)(bmSelectionFile), (char const   */* const  */)(pidStr),
              (size_t const   )sizeof(bmSelectionFile));
      }
    }
  }
  {
#line 1632
  tmp___0 = access((char const   *)(ncftpbookmarks), 1);
  }
#line 1632
  if (tmp___0 < 0) {
#line 1633
    return (-1);
  }
  {
#line 1636
  tmp___1 = fork();
#line 1636
  pid = tmp___1;
  }
#line 1637
  if (pid < 0) {
#line 1638
    return (-1);
  } else
#line 1639
  if (pid == 0) {
    {
#line 1642
    av[0] = strdup("ncftpbookmarks");
#line 1643
    av[1] = strdup((char const   *)(bmSelectionFile));
#line 1644
    av[2] = (char *)((void *)0);
#line 1645
    execv((char const   *)(ncftpbookmarks), (char * const  *)(av));
#line 1646
    exit(1);
    }
  } else {
    {
#line 1649
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1651
      tmp___2 = waitpid(pid, & status, 0);
      }
#line 1651
      if (tmp___2 < 0) {
        {
#line 1651
        tmp___3 = __errno_location();
        }
#line 1651
        if (*tmp___3 != 4) {
#line 1652
          goto while_break;
        }
      }
#line 1657
      __constr_expr_6.__in = status;
#line 1657
      if ((__constr_expr_6.__i & 127) == 0) {
#line 1658
        goto while_break;
      } else {
#line 1657
        __constr_expr_7.__in = status;
#line 1657
        if ((int )((signed char )((__constr_expr_7.__i & 127) + 1)) >> 1 > 0) {
#line 1658
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1661
    tmp___4 = strcmp((char const   *)(bmSelectionFile), "view");
    }
#line 1661
    if (tmp___4 != 0) {
      {
#line 1662
      fp = fopen((char const   */* __restrict  */)(bmSelectionFile), (char const   */* __restrict  */)"r");
      }
#line 1663
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 1664
        FGets(selectedBmName, dsize, fp);
#line 1665
        fclose(fp);
#line 1666
        unlink((char const   *)(bmSelectionFile));
#line 1667
        Trace((int const   )0, (char const   */* const  */)"Selected bookmark from editor: [%s]\n",
              selectedBmName);
        }
      }
    }
#line 1670
    return (0);
  }
#line 1672
  return (-1);
}
}
#line 1679 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void HostsCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  char *av[3] ;
  char bm[128] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1685
  if (argc != 0) {
#line 1685
    tmp = 1;
  } else
#line 1685
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1685
    tmp = 1;
  } else
#line 1685
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1685
    tmp = 1;
  } else
#line 1685
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1685
    tmp = 1;
  } else {
#line 1685
    tmp = 0;
  }
#line 1685
  gUnusedArg = tmp;
#line 1687
  if (argc == 1) {
    {
#line 1687
    tmp___0 = RunBookmarkEditor(bm, sizeof(bm));
    }
#line 1687
    if (tmp___0 == 0) {
#line 1688
      if ((int )bm[0] != 0) {
        {
#line 1689
        av[0] = strdup("open");
#line 1690
        av[1] = strdup((char const   *)(bm));
#line 1691
        av[2] = (char *)((void *)0);
#line 1692
        OpenCmd((int const   )2, (char **/* const  */)(av), (CommandPtr const   )((CommandPtr )0),
                (ArgvInfoPtr const   )((ArgvInfoPtr )0));
#line 1693
        free((void *)av[0]);
#line 1694
        free((void *)av[1]);
        }
      }
#line 1696
      return;
    }
  }
  {
#line 1698
  tmp___1 = PrintHosts();
  }
#line 1698
  if (tmp___1 <= 0) {
    {
#line 1699
    printf((char const   */* __restrict  */)"You haven\'t bookmarked any FTP sites.\n");
#line 1700
    printf((char const   */* __restrict  */)"Before closing a site, you can use the \"bookmark\" command to save the current\nhost and directory for next time.\n");
    }
  } else {
    {
#line 1702
    printf((char const   */* __restrict  */)"\nTo use a bookmark, use the \"open\" command with the name of the bookmark.\n");
    }
  }
#line 1704
  return;
}
}
#line 1710 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void JobsCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 1713
  if (argc != 0) {
#line 1713
    tmp = 1;
  } else
#line 1713
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1713
    tmp = 1;
  } else
#line 1713
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1713
    tmp = 1;
  } else
#line 1713
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1713
    tmp = 1;
  } else {
#line 1713
    tmp = 0;
  }
  {
#line 1713
  gUnusedArg = tmp;
#line 1714
  Jobs();
  }
#line 1715
  return;
}
}
#line 1723 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void ListCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int volatile   i___0 ;
  int j ;
  char options[32] ;
  char option[2] ;
  int volatile   listmode ;
  FILE * volatile  stream ;
  int volatile   paging ;
  int sj ;
  void (* volatile  osigpipe)(int  ) ;
  void (* volatile  osigint)(int  ) ;
  int tmp ;
  FILE *tmp___0 ;
  void (*tmp___1)(int  ) ;
  void (*tmp___2)(int  ) ;

  {
#line 1739
  if (argc != 0) {
#line 1739
    tmp = 1;
  } else
#line 1739
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1739
    tmp = 1;
  } else
#line 1739
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1739
    tmp = 1;
  } else
#line 1739
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1739
    tmp = 1;
  } else {
#line 1739
    tmp = 0;
  }
#line 1739
  gUnusedArg = tmp;
#line 1740
  stream = (FILE */* volatile  */)stdout;
#line 1741
  paging = (int volatile   )0;
#line 1743
  if ((int )*(*(argv + 0) + 0) == 100) {
#line 1745
    listmode = (int volatile   )'l';
  } else
#line 1743
  if ((int )*(*(argv + 0) + 0) == 108) {
#line 1743
    if ((int )*(*(argv + 0) + 1) == 108) {
#line 1745
      listmode = (int volatile   )'l';
    } else {
#line 1743
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1746
  if ((int )*(*(argv + 0) + 0) == 110) {
#line 1748
    listmode = (int volatile   )'1';
  } else
#line 1749
  if ((int )*(*(argv + 0) + 0) == 112) {
#line 1751
    paging = (int volatile   )1;
#line 1753
    if ((int )*(*(argv + 0) + 1) == 100) {
#line 1755
      listmode = (int volatile   )'l';
    } else
#line 1756
    if ((int )*(*(argv + 0) + 1) == 110) {
#line 1758
      listmode = (int volatile   )'1';
    } else {
#line 1761
      listmode = (int volatile   )'C';
    }
  } else {
#line 1765
    listmode = (int volatile   )'C';
  }
#line 1767
  options[0] = (char )'\000';
#line 1768
  option[1] = (char )'\000';
#line 1770
  i___0 = (int volatile   )1;
  {
#line 1770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1770
    if (! (i___0 < (int volatile   )argc)) {
#line 1770
      goto while_break;
    }
#line 1771
    if ((int )*(*(argv + i___0) + 0) != 45) {
#line 1772
      goto while_break;
    }
#line 1773
    if ((int )*(*(argv + i___0) + 1) == 45) {
#line 1774
      if ((int )*(*(argv + i___0) + 2) == 0) {
#line 1776
        i___0 += (int volatile   )1;
#line 1777
        goto while_break;
      } else {
        {
#line 1780
        PrintCmdUsage((CommandPtr )cmdp);
        }
      }
    } else {
#line 1783
      j = 1;
      {
#line 1783
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1784
        option[0] = *(*(argv + i___0) + j);
#line 1785
        if ((int )*(*(argv + i___0) + j) == 0) {
#line 1786
          goto while_break___0;
        }
        {
#line 1788
        if ((int )*(*(argv + i___0) + j) == 108) {
#line 1788
          goto case_108;
        }
#line 1791
        if ((int )*(*(argv + i___0) + j) == 49) {
#line 1791
          goto case_49;
        }
#line 1794
        if ((int )*(*(argv + i___0) + j) == 67) {
#line 1794
          goto case_67;
        }
#line 1797
        goto switch_default;
        case_108: /* CIL Label */ 
#line 1789
        listmode = (int volatile   )'l';
#line 1790
        goto switch_break;
        case_49: /* CIL Label */ 
#line 1792
        listmode = (int volatile   )'1';
#line 1793
        goto switch_break;
        case_67: /* CIL Label */ 
#line 1795
        listmode = (int volatile   )'C';
#line 1796
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1798
        Strncat((char */* const  */)(options), (char const   */* const  */)(option),
                (size_t const   )sizeof(options));
        }
#line 1799
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1783
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1770
    i___0 += (int volatile   )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1806
  if (paging != (int volatile   )0) {
    {
#line 1807
    tmp___0 = OpenPager___0();
#line 1807
    stream = (FILE */* volatile  */)tmp___0;
    }
#line 1808
    if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 1809
      return;
    }
    {
#line 1814
    osigint = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 1814
    osigpipe = osigint;
#line 1815
    sj = __sigsetjmp((struct __jmp_buf_tag *)(gCancelJmp), 1);
    }
#line 1823
    if (sj != 0) {
      {
#line 1825
      NcSignal(13, (void (*)(int  ))1);
#line 1826
      ClosePager___0((FILE *)stream);
#line 1827
      NcSignal(13, (void (*)(int  ))osigpipe);
#line 1828
      NcSignal(2, (void (*)(int  ))osigint);
#line 1829
      Trace((int const   )0, (char const   */* const  */)"Canceled because of signal %d.\n",
            gGotSig);
#line 1830
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Canceled.\n");
#line 1831
      gMayCancelJmp = 0;
      }
#line 1832
      return;
    } else {
      {
#line 1834
      tmp___1 = NcSignal(13, & Cancel);
#line 1834
      osigpipe = (void (*/* volatile  */)(int  ))tmp___1;
#line 1835
      tmp___2 = NcSignal(2, & Cancel);
#line 1835
      osigint = (void (*/* volatile  */)(int  ))tmp___2;
#line 1836
      gMayCancelJmp = 1;
      }
    }
  }
#line 1841
  if ((unsigned long )*(argv + i___0) == (unsigned long )((void *)0)) {
    {
#line 1843
    Ls((char const   */* const  */)((void *)0), (int )listmode, (char const   */* const  */)(options),
       (FILE *)stream);
    }
  } else {
    {
#line 1846
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1846
      if (! (i___0 < (int volatile   )argc)) {
#line 1846
        goto while_break___1;
      }
      {
#line 1847
      Ls((char const   */* const  */)*(argv + i___0), (int )listmode, (char const   */* const  */)(options),
         (FILE *)stream);
#line 1846
      i___0 += (int volatile   )1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1851
  if (paging != (int volatile   )0) {
    {
#line 1852
    ClosePager___0((FILE *)stream);
#line 1855
    NcSignal(13, (void (*)(int  ))osigpipe);
#line 1856
    NcSignal(2, (void (*)(int  ))osigint);
    }
  }
#line 1859
  gMayCancelJmp = 0;
#line 1860
  return;
}
}
#line 1866 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalChdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) 
{ 
  int result ;
  char const   *dir___3 ;
  char buf[512] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 1873
  if (argc != 0) {
#line 1873
    tmp = 1;
  } else
#line 1873
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1873
    tmp = 1;
  } else
#line 1873
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1873
    tmp = 1;
  } else
#line 1873
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1873
    tmp = 1;
  } else {
#line 1873
    tmp = 0;
  }
#line 1873
  gUnusedArg = tmp;
#line 1874
  if (argc < 2) {
#line 1874
    dir___3 = (char const   *)(gHome);
  } else {
#line 1874
    dir___3 = (char const   *)*(argv + 1);
  }
#line 1875
  if ((int const   )*(dir___3 + 0) == 45) {
#line 1875
    if ((int const   )*(dir___3 + 1) == 0) {
#line 1876
      if ((int )gPrevLocalCWD[0] == 0) {
        {
#line 1877
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No previous local working directory to switch to.\n");
        }
#line 1878
        return;
      } else {
#line 1880
        dir___3 = (char const   *)(gPrevLocalCWD);
      }
    } else {
#line 1875
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1882
  if ((int const   )*(dir___3 + 0) == 126) {
#line 1883
    if ((int const   )*(dir___3 + 1) == 0) {
#line 1884
      dir___3 = (char const   *)(gHome);
    } else
#line 1885
    if ((int const   )*(dir___3 + 1) == 47) {
      {
#line 1886
      Strncpy((char */* const  */)(buf), (char const   */* const  */)(gHome), (size_t const   )sizeof(buf));
#line 1887
      tmp___0 = Strncat((char */* const  */)(buf), (char const   */* const  */)(dir___3 + 1),
                        (size_t const   )sizeof(buf));
#line 1887
      dir___3 = (char const   *)tmp___0;
      }
    }
  }
  {
#line 1890
  result = chdir(dir___3);
  }
#line 1891
  if (result < 0) {
    {
#line 1892
    perror(dir___3);
    }
  } else {
    {
#line 1894
    Strncpy((char */* const  */)(gPrevLocalCWD), (char const   */* const  */)(gLocalCWD),
            (size_t const   )sizeof(gPrevLocalCWD));
#line 1895
    FTPGetLocalCWD(gLocalCWD, sizeof(gLocalCWD));
    }
  }
#line 1898
  return;
}
}
#line 1904 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalListCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                  ArgvInfoPtr const   aip ) 
{ 
  FILE * volatile  outfp ;
  FILE * volatile  infp ;
  int i___0 ;
  int sj ;
  int dashopts ;
  char incmd[256] ;
  char line[256] ;
  void (* volatile  osigpipe)(int  ) ;
  void (* volatile  osigint)(int  ) ;
  int tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  void (*tmp___2)(int  ) ;
  void (*tmp___3)(int  ) ;
  char *tmp___4 ;

  {
#line 1988
  osigpipe = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 1988
  osigint = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 1990
  if (argc != 0) {
#line 1990
    tmp = 1;
  } else
#line 1990
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 1990
    tmp = 1;
  } else
#line 1990
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 1990
    tmp = 1;
  } else
#line 1990
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 1990
    tmp = 1;
  } else {
#line 1990
    tmp = 0;
  }
  {
#line 1990
  gUnusedArg = tmp;
#line 1991
  fflush(stdin);
#line 1992
  tmp___0 = OpenPager___0();
#line 1992
  outfp = (FILE */* volatile  */)tmp___0;
#line 1994
  Strncpy((char */* const  */)(incmd), (char const   */* const  */)"/bin/ls", (size_t const   )sizeof(incmd));
#line 1995
  i___0 = 1;
#line 1995
  dashopts = 0;
  }
  {
#line 1995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1995
    if (! (i___0 < (int )argc)) {
#line 1995
      goto while_break;
    }
    {
#line 1996
    Strncat((char */* const  */)(incmd), (char const   */* const  */)" ", (size_t const   )sizeof(incmd));
    }
#line 1997
    if ((int )*(*(argv + i___0) + 0) == 45) {
#line 1998
      dashopts ++;
    }
    {
#line 1999
    Strncat((char */* const  */)(incmd), (char const   */* const  */)*(argv + i___0),
            (size_t const   )sizeof(incmd));
#line 1995
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2002
  if (dashopts == 0) {
    {
#line 2003
    Strncpy((char */* const  */)(incmd), (char const   */* const  */)"/bin/ls -CF",
            (size_t const   )sizeof(incmd));
#line 2004
    i___0 = 1;
    }
    {
#line 2004
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2004
      if (! (i___0 < (int )argc)) {
#line 2004
        goto while_break___0;
      }
      {
#line 2005
      Strncat((char */* const  */)(incmd), (char const   */* const  */)" ", (size_t const   )sizeof(incmd));
#line 2006
      Strncat((char */* const  */)(incmd), (char const   */* const  */)*(argv + i___0),
              (size_t const   )sizeof(incmd));
#line 2004
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2010
  tmp___1 = popen((char const   *)(incmd), "r");
#line 2010
  infp = (FILE */* volatile  */)tmp___1;
  }
#line 2011
  if ((unsigned long )infp == (unsigned long )((void *)0)) {
    {
#line 2012
    ClosePager___0((FILE *)outfp);
    }
#line 2013
    return;
  }
  {
#line 2018
  sj = __sigsetjmp((struct __jmp_buf_tag *)(gCancelJmp), 1);
  }
#line 2023
  if (sj != 0) {
    {
#line 2025
    NcSignal(13, (void (*)(int  ))1);
#line 2026
    ClosePager___0((FILE *)outfp);
    }
#line 2027
    if ((unsigned long )infp != (unsigned long )((void *)0)) {
      {
#line 2028
      pclose((FILE *)infp);
      }
    }
    {
#line 2029
    NcSignal(13, (void (*)(int  ))osigpipe);
#line 2030
    NcSignal(2, (void (*)(int  ))osigint);
#line 2031
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Canceled.\n");
#line 2032
    Trace((int const   )0, (char const   */* const  */)"Canceled because of signal %d.\n",
          gGotSig);
#line 2033
    gMayCancelJmp = 0;
    }
#line 2034
    return;
  } else {
    {
#line 2036
    tmp___2 = NcSignal(13, & Cancel);
#line 2036
    osigpipe = (void (*/* volatile  */)(int  ))tmp___2;
#line 2037
    tmp___3 = NcSignal(2, & Cancel);
#line 2037
    osigint = (void (*/* volatile  */)(int  ))tmp___3;
#line 2038
    gMayCancelJmp = 1;
    }
  }
  {
#line 2041
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2041
    tmp___4 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 1UL), (FILE */* __restrict  */)infp);
    }
#line 2041
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 2041
      goto while_break___1;
    }
    {
#line 2042
    fputs((char const   */* __restrict  */)(line), (FILE */* __restrict  */)outfp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2043
  fflush((FILE *)outfp);
#line 2045
  pclose((FILE *)infp);
#line 2046
  infp = (FILE */* volatile  */)((void *)0);
#line 2047
  ClosePager___0((FILE *)outfp);
#line 2048
  outfp = (FILE */* volatile  */)((void *)0);
#line 2050
  NcSignal(13, (void (*)(int  ))osigpipe);
#line 2051
  NcSignal(2, (void (*)(int  ))osigint);
#line 2052
  gMayCancelJmp = 0;
  }
#line 2054
  return;
}
}
#line 2059 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void Sys(int const   argc , char ** const  argv , ArgvInfoPtr const   aip ,
                char const   *syscmd , int noDQuote ) 
{ 
  char cmd[256] ;
  int i___0 ;

  {
  {
#line 2065
  Strncpy((char */* const  */)(cmd), (char const   */* const  */)syscmd, (size_t const   )sizeof(cmd));
#line 2066
  i___0 = 1;
  }
  {
#line 2066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2066
    if (! (i___0 < (int )argc)) {
#line 2066
      goto while_break;
    }
#line 2067
    if (aip->noglobargv[i___0] != 0) {
      {
#line 2068
      Strncat((char */* const  */)(cmd), (char const   */* const  */)" \'", (size_t const   )sizeof(cmd));
#line 2069
      Strncat((char */* const  */)(cmd), (char const   */* const  */)*(argv + i___0),
              (size_t const   )sizeof(cmd));
#line 2070
      Strncat((char */* const  */)(cmd), (char const   */* const  */)"\'", (size_t const   )sizeof(cmd));
      }
    } else
#line 2071
    if (noDQuote != 0) {
      {
#line 2072
      Strncat((char */* const  */)(cmd), (char const   */* const  */)" ", (size_t const   )sizeof(cmd));
#line 2073
      Strncat((char */* const  */)(cmd), (char const   */* const  */)*(argv + i___0),
              (size_t const   )sizeof(cmd));
      }
    } else {
      {
#line 2075
      Strncat((char */* const  */)(cmd), (char const   */* const  */)" \"", (size_t const   )sizeof(cmd));
#line 2076
      Strncat((char */* const  */)(cmd), (char const   */* const  */)*(argv + i___0),
              (size_t const   )sizeof(cmd));
#line 2077
      Strncat((char */* const  */)(cmd), (char const   */* const  */)"\" ", (size_t const   )sizeof(cmd));
      }
    }
#line 2066
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2083
  Trace((int const   )0, (char const   */* const  */)"Sys: %s\n", cmd);
#line 2084
  system((char const   *)(cmd));
  }
#line 2086
  return;
}
}
#line 2093 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalChmodCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 2096
  if (argc != 0) {
#line 2096
    tmp = 1;
  } else
#line 2096
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2096
    tmp = 1;
  } else
#line 2096
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2096
    tmp = 1;
  } else
#line 2096
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2096
    tmp = 1;
  } else {
#line 2096
    tmp = 0;
  }
  {
#line 2096
  gUnusedArg = tmp;
#line 2097
  Sys(argc, argv, aip, "/bin/chmod", 1);
  }
#line 2098
  return;
}
}
#line 2103 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalMkdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 2117
  if (argc != 0) {
#line 2117
    tmp = 1;
  } else
#line 2117
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2117
    tmp = 1;
  } else
#line 2117
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2117
    tmp = 1;
  } else
#line 2117
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2117
    tmp = 1;
  } else {
#line 2117
    tmp = 0;
  }
  {
#line 2117
  gUnusedArg = tmp;
#line 2118
  Sys(argc, argv, aip, "/bin/mkdir", 0);
  }
#line 2120
  return;
}
}
#line 2127 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalPageCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                  ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 2130
  if (argc != 0) {
#line 2130
    tmp = 1;
  } else
#line 2130
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2130
    tmp = 1;
  } else
#line 2130
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2130
    tmp = 1;
  } else
#line 2130
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2130
    tmp = 1;
  } else {
#line 2130
    tmp = 0;
  }
  {
#line 2130
  gUnusedArg = tmp;
#line 2131
  Sys(argc, argv, aip, (char const   *)(gPager), 0);
  }
#line 2132
  return;
}
}
#line 2138 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalRenameCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                    ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 2146
  if (argc != 0) {
#line 2146
    tmp = 1;
  } else
#line 2146
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2146
    tmp = 1;
  } else
#line 2146
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2146
    tmp = 1;
  } else
#line 2146
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2146
    tmp = 1;
  } else {
#line 2146
    tmp = 0;
  }
  {
#line 2146
  gUnusedArg = tmp;
#line 2147
  Sys(argc, argv, aip, "/bin/mv", 1);
  }
#line 2149
  return;
}
}
#line 2154 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalRmCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 2180
  if (argc != 0) {
#line 2180
    tmp = 1;
  } else
#line 2180
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2180
    tmp = 1;
  } else
#line 2180
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2180
    tmp = 1;
  } else
#line 2180
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2180
    tmp = 1;
  } else {
#line 2180
    tmp = 0;
  }
  {
#line 2180
  gUnusedArg = tmp;
#line 2181
  Sys(argc, argv, aip, "/bin/rm", 1);
  }
#line 2183
  return;
}
}
#line 2188 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalRmdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                   ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 2214
  if (argc != 0) {
#line 2214
    tmp = 1;
  } else
#line 2214
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2214
    tmp = 1;
  } else
#line 2214
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2214
    tmp = 1;
  } else
#line 2214
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2214
    tmp = 1;
  } else {
#line 2214
    tmp = 0;
  }
  {
#line 2214
  gUnusedArg = tmp;
#line 2215
  Sys(argc, argv, aip, "/bin/rmdir", 1);
  }
#line 2217
  return;
}
}
#line 2223 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LocalPwdCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 2226
  if (argc != 0) {
#line 2226
    tmp = 1;
  } else
#line 2226
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2226
    tmp = 1;
  } else
#line 2226
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2226
    tmp = 1;
  } else
#line 2226
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2226
    tmp = 1;
  } else {
#line 2226
    tmp = 0;
  }
  {
#line 2226
  gUnusedArg = tmp;
#line 2227
  tmp___0 = FTPGetLocalCWD(gLocalCWD, sizeof(gLocalCWD));
  }
#line 2227
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 2228
    Trace((int const   )-1, (char const   */* const  */)"%s\n", gLocalCWD);
    }
  }
#line 2230
  return;
}
}
#line 2238 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void LookupCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
               ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int j ;
  struct hostent hp ;
  int hpok ;
  char const   *host ;
  char **cpp ;
  struct in_addr ip_address ;
  int shortMode ;
  int optrc ;
  int dnsrc ;
  char ipStr[16] ;
  GetoptInfo opt ;
  int tmp ;

  {
#line 2251
  if (argc != 0) {
#line 2251
    tmp = 1;
  } else
#line 2251
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2251
    tmp = 1;
  } else
#line 2251
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2251
    tmp = 1;
  } else
#line 2251
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2251
    tmp = 1;
  } else {
#line 2251
    tmp = 0;
  }
  {
#line 2251
  gUnusedArg = tmp;
#line 2252
  shortMode = 0;
#line 2254
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 2255
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2255
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"vqV");
    }
#line 2255
    if (! (optrc >= 0)) {
#line 2255
      goto while_break;
    }
#line 2256
    if (optrc == 118) {
#line 2257
      shortMode = 0;
    } else
#line 2258
    if (optrc == 86) {
#line 2259
      shortMode = 1;
    } else
#line 2260
    if (optrc == 113) {
#line 2261
      shortMode = 1;
    } else {
      {
#line 2263
      PrintCmdUsage((CommandPtr )cmdp);
      }
#line 2264
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2268
  i___0 = opt.ind;
  {
#line 2268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2268
    if (! (i___0 < (int )argc)) {
#line 2268
      goto while_break___0;
    }
    {
#line 2269
    hpok = 0;
#line 2270
    host = (char const   *)*(argv + i___0);
#line 2270
    dnsrc = GetHostEntry((struct hostent */* const  */)(& hp), (char const   */* const  */)host,
                         (struct in_addr */* const  */)(& ip_address), (char */* const  */)gConn.buf,
                         gConn.bufSize);
    }
#line 2271
    if (dnsrc == 0) {
#line 2272
      hpok = 1;
    }
#line 2273
    if (i___0 > opt.ind) {
#line 2273
      if (shortMode == 0) {
        {
#line 2274
        Trace((int const   )-1, (char const   */* const  */)"\n");
        }
      }
    }
#line 2275
    if (hpok == 0) {
#line 2277
      if (dnsrc == -2) {
        {
#line 2278
        Trace((int const   )-1, (char const   */* const  */)"DNS response for site %s is untrused.\n",
              host);
        }
      } else {
        {
#line 2281
        Trace((int const   )-1, (char const   */* const  */)"Unable to get information about site %s.\n",
              host);
        }
      }
    } else
#line 2282
    if (shortMode) {
      {
#line 2283
      MyInetAddr(ipStr, sizeof(ipStr), (void *)hp.h_addr_list, 0);
#line 2284
      Trace((int const   )-1, (char const   */* const  */)"%-40s %s\n", hp.h_name,
            ipStr);
      }
    } else {
      {
#line 2286
      Trace((int const   )-1, (char const   */* const  */)"%s:\n", host);
#line 2287
      Trace((int const   )-1, (char const   */* const  */)"    Name:     %s\n", hp.h_name);
#line 2288
      cpp = hp.h_aliases;
      }
      {
#line 2288
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2288
        if (! ((unsigned long )*cpp != (unsigned long )((void *)0))) {
#line 2288
          goto while_break___1;
        }
        {
#line 2289
        Trace((int const   )-1, (char const   */* const  */)"    Alias:    %s\n",
              *cpp);
#line 2288
        cpp ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2290
      j = 0;
#line 2290
      cpp = hp.h_addr_list;
      {
#line 2290
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2290
        if (! ((unsigned long )*cpp != (unsigned long )((void *)0))) {
#line 2290
          goto while_break___2;
        }
        {
#line 2291
        MyInetAddr(ipStr, sizeof(ipStr), (void *)hp.h_addr_list, j);
#line 2292
        Trace((int const   )-1, (char const   */* const  */)"    Address:  %s\n",
              ipStr);
#line 2290
        cpp ++;
#line 2290
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2268
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2296
  return;
}
}
#line 2303 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void MlsCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int optrc ;
  FTPLinePtr linePtr ;
  FTPLinePtr nextLinePtr ;
  int result ;
  FTPLineList dirContents ;
  int mlsd ;
  int x ;
  char const   *item ;
  GetoptInfo opt ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2311
  mlsd = 1;
#line 2315
  if (argc != 0) {
#line 2315
    tmp = 1;
  } else
#line 2315
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2315
    tmp = 1;
  } else
#line 2315
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2315
    tmp = 1;
  } else
#line 2315
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2315
    tmp = 1;
  } else {
#line 2315
    tmp = 0;
  }
  {
#line 2315
  gUnusedArg = tmp;
#line 2316
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 2317
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2317
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"dt");
    }
#line 2317
    if (! (optrc >= 0)) {
#line 2317
      goto while_break;
    }
#line 2318
    if (optrc == 100) {
#line 2322
      mlsd = 0;
    } else
#line 2318
    if (optrc == 116) {
#line 2322
      mlsd = 0;
    } else {
      {
#line 2324
      PrintCmdUsage((CommandPtr )cmdp);
      }
#line 2325
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2329
  i___0 = opt.ind;
#line 2330
  if (i___0 == (int )argc) {
#line 2332
    x = 1;
#line 2333
    item = "";
#line 2334
    if (mlsd == 0) {
#line 2334
      tmp___0 = "-d";
    } else {
#line 2334
      tmp___0 = "";
    }
    {
#line 2334
    result = FTPListToMemory2((FTPCIPtr const   )(& gConn), (char const   */* const  */)item,
                              (FTPLineListPtr const   )(& dirContents), (char const   */* const  */)tmp___0,
                              (int const   )1, (int */* const  */)(& x));
    }
#line 2334
    if (result < 0) {
#line 2335
      if (mlsd != 0) {
        {
#line 2336
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )0,
                  (char const   */* const  */)"Could not MLSD", (char const   */* const  */)item);
        }
      } else {
        {
#line 2338
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )0,
                  (char const   */* const  */)"Could not MLST", (char const   */* const  */)item);
        }
      }
    } else {
#line 2341
      linePtr = dirContents.first;
      {
#line 2341
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2341
        if (! ((unsigned long )linePtr != (unsigned long )((void *)0))) {
#line 2341
          goto while_break___0;
        }
        {
#line 2345
        nextLinePtr = linePtr->next;
#line 2346
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
                linePtr->line);
#line 2347
        Trace((int const   )0, (char const   */* const  */)"%s\n", linePtr->line);
#line 2341
        linePtr = nextLinePtr;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 2352
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2352
    if (! (i___0 < (int )argc)) {
#line 2352
      goto while_break___1;
    }
#line 2353
    x = 1;
#line 2354
    item = (char const   *)*(argv + i___0);
#line 2355
    if (mlsd == 0) {
#line 2355
      tmp___1 = "-d";
    } else {
#line 2355
      tmp___1 = "";
    }
    {
#line 2355
    result = FTPListToMemory2((FTPCIPtr const   )(& gConn), (char const   */* const  */)item,
                              (FTPLineListPtr const   )(& dirContents), (char const   */* const  */)tmp___1,
                              (int const   )1, (int */* const  */)(& x));
    }
#line 2355
    if (result < 0) {
#line 2356
      if (mlsd != 0) {
        {
#line 2357
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )0,
                  (char const   */* const  */)"Could not MLSD", (char const   */* const  */)item);
        }
      } else {
        {
#line 2359
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )0,
                  (char const   */* const  */)"Could not MLST", (char const   */* const  */)item);
        }
      }
    } else {
#line 2362
      linePtr = dirContents.first;
      {
#line 2362
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2362
        if (! ((unsigned long )linePtr != (unsigned long )((void *)0))) {
#line 2362
          goto while_break___2;
        }
        {
#line 2366
        nextLinePtr = linePtr->next;
#line 2367
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
                linePtr->line);
#line 2368
        Trace((int const   )0, (char const   */* const  */)"%s\n", linePtr->line);
#line 2362
        linePtr = nextLinePtr;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2352
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2372
  return;
}
}
#line 2378 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void MkdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int optrc ;
  int result ;
  int recurseFlag ;
  GetoptInfo opt ;
  int tmp ;

  {
#line 2384
  recurseFlag = 0;
#line 2387
  if (argc != 0) {
#line 2387
    tmp = 1;
  } else
#line 2387
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2387
    tmp = 1;
  } else
#line 2387
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2387
    tmp = 1;
  } else
#line 2387
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2387
    tmp = 1;
  } else {
#line 2387
    tmp = 0;
  }
  {
#line 2387
  gUnusedArg = tmp;
#line 2388
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 2389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2389
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"p");
    }
#line 2389
    if (! (optrc >= 0)) {
#line 2389
      goto while_break;
    }
#line 2390
    if (optrc == 112) {
#line 2398
      recurseFlag = 1;
    } else {
      {
#line 2400
      PrintCmdUsage((CommandPtr )cmdp);
      }
#line 2401
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2405
  i___0 = opt.ind;
  {
#line 2405
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2405
    if (! (i___0 < (int )argc)) {
#line 2405
      goto while_break___0;
    }
    {
#line 2406
    result = FTPMkdir((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                      (int const   )recurseFlag);
    }
#line 2407
    if (result < 0) {
      {
#line 2408
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-140,
                (char const   */* const  */)"Could not mkdir", (char const   */* const  */)*(argv + i___0));
      }
    }
#line 2405
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2412
  FlushLsCache();
  }
#line 2413
  return;
}
}
#line 2418 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void ( /* format attribute */  OpenMsg)(char const   * const  fmt  , ...) 
{ 
  va_list ap ;
  char buf[512] ;
  size_t len ;
  size_t padlim ;
  int tmp ;

  {
#line 2425
  padlim = (size_t )gScreenColumns;
#line 2426
  if ((size_t )gScreenColumns > sizeof(buf) - 1UL) {
#line 2427
    padlim = sizeof(buf) - 1UL;
  }
  {
#line 2429
  __builtin_va_start(ap, fmt);
#line 2431
  tmp = vsnprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)fmt,
                  ap);
#line 2431
  len = (size_t )tmp;
#line 2432
  __builtin_va_end(ap);
#line 2433
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 2439
  buf[len] = (char )'\000';
#line 2440
  Trace((int const   )9, (char const   */* const  */)"%s\n", buf);
  }
  {
#line 2441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2441
    if (! (len < padlim)) {
#line 2441
      goto while_break;
    }
#line 2442
    buf[len] = (char )' ';
#line 2441
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2443
  buf[len] = (char )'\000';
#line 2448
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\r",
          buf);
#line 2450
  fflush(stdout);
  }
#line 2451
  return;
}
}
#line 2456 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void NcFTPOpenPrintResponseProc(FTPCIPtr const   cipUNUSED , ResponsePtr rp ) 
{ 


  {
#line 2459
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 2460
  if ((rp->printMode & 1) != 0) {
#line 2461
    return;
  }
#line 2467
  if (rp->code < 400) {
#line 2468
    return;
  }
  {
#line 2470
  PrintResp(& rp->msg);
  }
#line 2471
  return;
}
}
#line 2475 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void NcFTPOnConnectMessageProc(FTPCIPtr const   cipUNUSED , ResponsePtr rp ) 
{ 


  {
  {
#line 2478
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 2479
  printf((char const   */* __restrict  */)"\n");
#line 2480
  PrintResp(& rp->msg);
#line 2481
  OpenMsg((char const   */* const  */)"Logging in...");
  }
#line 2482
  return;
}
}
#line 2486 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void NcFTPOnLoginMessageProc(FTPCIPtr const   cipUNUSED , ResponsePtr rp ) 
{ 


  {
  {
#line 2489
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 2490
  printf((char const   */* __restrict  */)"\n");
#line 2491
  PrintResp(& rp->msg);
#line 2492
  OpenMsg((char const   */* const  */)"Logging in...");
  }
#line 2493
  return;
}
}
#line 2498 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void NcFTPRedialStatusProc(FTPCIPtr const   cipUNUSED , int mode , int val ) 
{ 


  {
#line 2501
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 2502
  if (mode == 0) {
#line 2503
    if (val > 0) {
      {
#line 2504
      OpenMsg((char const   */* const  */)"Redialing (try %d)...", val);
#line 2505
      sleep(1U);
      }
    }
  } else
#line 2507
  if (mode == 1) {
    {
#line 2508
    OpenMsg((char const   */* const  */)"Sleeping %d seconds...", val);
    }
  }
#line 2510
  return;
}
}
#line 2515 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static void NcFTPGetPassphraseProc(FTPCIPtr const   cip , FTPLineListPtr pwPrompt ,
                                   char *pass , size_t dsize ) 
{ 
  FTPLinePtr lp ;

  {
  {
#line 2520
  printf((char const   */* __restrict  */)"\nPassword requested by %s for user \"%s\".\n\n",
         cip->host, cip->user);
#line 2525
  lp = pwPrompt->first;
  }
  {
#line 2525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2525
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 2525
      goto while_break;
    }
    {
#line 2526
    printf((char const   */* __restrict  */)"    %s\n", lp->line);
#line 2525
    lp = lp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2528
  printf((char const   */* __restrict  */)"\n");
#line 2529
  gl_getpass((char const   */* const  */)"Password: ", (char */* const  */)pass, (int )dsize);
  }
#line 2530
  return;
}
}
#line 2536 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
int DoOpen(void) 
{ 
  int result ;
  char ipstr[128] ;
  char ohost[128] ;
  void (*osigalrm)(int  ) ;
  char prompt[256] ;
  char *cp ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 2548
  if (gConn.firewallType == 0) {
    {
#line 2549
    Strncpy((char */* const  */)(ohost), (char const   */* const  */)(gConn.host),
            (size_t const   )sizeof(ohost));
#line 2550
    OpenMsg((char const   */* const  */)"Resolving %s...", ohost);
    }
#line 2552
    if (gLoadedBm != 0) {
#line 2552
      if ((int )gBm.lastIP[0] != 0) {
        {
#line 2553
        result = MyGetHostByName((char */* const volatile  */)(ipstr), sizeof(ipstr),
                                 (char const   */* const  */)(ohost), 3);
        }
#line 2554
        if (result < 0) {
          {
#line 2555
          Strncpy((char */* const  */)(ipstr), (char const   */* const  */)(gBm.lastIP),
                  (size_t const   )sizeof(ipstr));
#line 2556
          result = 0;
          }
        } else {
          {
#line 2558
          result = MyGetHostByName((char */* const volatile  */)(ipstr), sizeof(ipstr),
                                   (char const   */* const  */)(ohost), 7);
          }
        }
      } else {
        {
#line 2561
        result = MyGetHostByName((char */* const volatile  */)(ipstr), sizeof(ipstr),
                                 (char const   */* const  */)(ohost), 10);
        }
      }
    } else {
      {
#line 2561
      result = MyGetHostByName((char */* const volatile  */)(ipstr), sizeof(ipstr),
                               (char const   */* const  */)(ohost), 10);
      }
    }
#line 2563
    if (result < 0) {
      {
#line 2564
      printf((char const   */* __restrict  */)"\n");
#line 2565
      printf((char const   */* __restrict  */)"Unknown host \"%s\".\n", ohost);
      }
#line 2566
      return (-1);
    }
    {
#line 2583
    Strncpy((char */* const  */)(gConn.host), (char const   */* const  */)(ipstr),
            (size_t const   )sizeof(gConn.host));
#line 2584
    OpenMsg((char const   */* const  */)"Connecting to %s...", ipstr);
    }
  } else {
    {
#line 2586
    OpenMsg((char const   */* const  */)"Connecting to %s via %s...", gConn.host,
            gConn.firewallHost);
    }
#line 2587
    if ((int )gConn.firewallPass[0] == 0) {
#line 2587
      tmp = "(none)";
    } else {
#line 2587
      tmp = "********";
    }
    {
#line 2587
    Trace((int const   )0, (char const   */* const  */)"Fw: %s  Type: %d  User: %s  Pass: %s  Port: %u\n",
          gConn.firewallHost, gConn.firewallType, gConn.firewallUser, tmp, gConn.firewallPort);
#line 2594
    Trace((int const   )0, (char const   */* const  */)"FwExceptions: %s\n", gFirewallExceptionList);
#line 2595
    tmp___0 = strchr((char const   *)(gOurHostName), '.');
    }
#line 2595
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 2596
      Trace((int const   )0, (char const   */* const  */)"NOTE:  Your domain name could not be detected.\n");
      }
#line 2597
      if (gConn.firewallType != 0) {
        {
#line 2598
        Trace((int const   )0, (char const   */* const  */)"       Make sure you manually add your domain name to firewall-exception-list.\n");
        }
      }
    }
  }
#line 2603
  if ((int )gConn.firewallPass[0] == 0) {
    {
#line 2605
    if (gConn.firewallType == 0) {
#line 2605
      goto case_0;
    }
#line 2609
    if (gConn.firewallType == 9) {
#line 2609
      goto case_9;
    }
#line 2609
    if (gConn.firewallType == 8) {
#line 2609
      goto case_9;
    }
#line 2609
    if (gConn.firewallType == 1) {
#line 2609
      goto case_9;
    }
#line 2616
    if (gConn.firewallType == 7) {
#line 2616
      goto case_7;
    }
#line 2616
    if (gConn.firewallType == 6) {
#line 2616
      goto case_7;
    }
#line 2616
    if (gConn.firewallType == 5) {
#line 2616
      goto case_7;
    }
#line 2616
    if (gConn.firewallType == 4) {
#line 2616
      goto case_7;
    }
#line 2616
    if (gConn.firewallType == 3) {
#line 2616
      goto case_7;
    }
#line 2616
    if (gConn.firewallType == 2) {
#line 2616
      goto case_7;
    }
#line 2604
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2606
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 2610
    goto switch_break;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 2617
    printf((char const   */* __restrict  */)"\n");
#line 2618
    Strncpy((char */* const  */)(prompt), (char const   */* const  */)"Password for firewall user \"",
            (size_t const   )sizeof(prompt));
#line 2619
    Strncat((char */* const  */)(prompt), (char const   */* const  */)(gConn.firewallUser),
            (size_t const   )sizeof(prompt));
#line 2620
    Strncat((char */* const  */)(prompt), (char const   */* const  */)"\" at ", (size_t const   )sizeof(prompt));
#line 2621
    Strncat((char */* const  */)(prompt), (char const   */* const  */)(gConn.firewallHost),
            (size_t const   )sizeof(prompt));
#line 2622
    Strncat((char */* const  */)(prompt), (char const   */* const  */)": ", (size_t const   )sizeof(prompt));
#line 2623
    gl_getpass((char const   */* const  */)(prompt), (char */* const  */)(gConn.firewallPass),
               (int )sizeof(gConn.firewallPass));
    }
#line 2624
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2628
  if ((int )gConn.user[0] != 0) {
    {
#line 2628
    tmp___1 = strcmp((char const   *)(gConn.user), "anonymous");
    }
#line 2628
    if (tmp___1 != 0) {
      {
#line 2628
      tmp___2 = strcmp((char const   *)(gConn.user), "ftp");
      }
#line 2628
      if (tmp___2 != 0) {
#line 2629
        gConn.passphraseProc = & NcFTPGetPassphraseProc;
      }
    }
  }
  {
#line 2633
  gConn.printResponseProc = & NcFTPOpenPrintResponseProc;
#line 2634
  gConn.onConnectMsgProc = & NcFTPOnConnectMessageProc;
#line 2635
  gConn.onLoginMsgProc = & NcFTPOnLoginMessageProc;
#line 2636
  gConn.redialStatusProc = & NcFTPRedialStatusProc;
#line 2639
  osigalrm = NcSignal(14, (void (*)(int  ))1);
#line 2640
  result = FTPOpenHost((FTPCIPtr const   )(& gConn));
#line 2641
  NcSignal(14, osigalrm);
  }
#line 2646
  if (gConn.firewallType == 0) {
    {
#line 2647
    Strncpy((char */* const  */)(gConn.host), (char const   */* const  */)(ohost),
            (size_t const   )sizeof(gConn.host));
    }
  }
#line 2648
  if (result >= 0) {
    {
#line 2649
    time(& gBm.lastCall);
#line 2650
    LogOpen((char const   */* const  */)(gConn.host));
#line 2651
    OpenMsg((char const   */* const  */)"Logged in to %s.", gConn.host);
#line 2652
    printf((char const   */* __restrict  */)"\n");
#line 2655
    gConn.printResponseProc = (void (*)(FTPCIPtr const    , ResponsePtr  ))0;
#line 2658
    gServerUsesMSDOSPaths = 0;
    }
#line 2659
    if ((unsigned long )gConn.startingWorkingDirectory == (unsigned long )((void *)0)) {
      {
#line 2660
      Strncpy((char */* const  */)(gRemoteCWD), (char const   */* const  */)"/", (size_t const   )sizeof(gRemoteCWD));
      }
    } else {
      {
#line 2662
      cp = gConn.startingWorkingDirectory;
#line 2663
      Strncpy((char */* const  */)(gRemoteCWD), (char const   */* const  */)cp, (size_t const   )sizeof(gRemoteCWD));
#line 2664
      tmp___3 = strlen((char const   *)cp);
      }
#line 2664
      if (tmp___3 >= 2UL) {
        {
#line 2664
        tmp___4 = __ctype_b_loc();
        }
#line 2664
        if ((int const   )*(*tmp___4 + (int )*(cp + 0)) & 1024) {
#line 2664
          if ((int )*(cp + 1) == 58) {
#line 2665
            gServerUsesMSDOSPaths = 1;
          }
        }
      }
    }
    {
#line 2667
    Strncpy((char */* const  */)(gStartDir), (char const   */* const  */)(gRemoteCWD),
            (size_t const   )sizeof(gStartDir));
    }
#line 2670
    if (gLoadedBm != 0) {
#line 2670
      if ((int )gBm.dir[0] != 0) {
        {
#line 2671
        result = Chdirs(& gConn, (char const   */* const  */)(gBm.dir));
        }
#line 2672
        if (result < 0) {
          {
#line 2673
          FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-125,
                    (char const   */* const  */)"Could not chdir to previous directory",
                    (char const   */* const  */)(gBm.dir));
          }
        }
        {
#line 2675
        Trace((int const   )-1, (char const   */* const  */)"Current remote directory is %s.\n",
              gRemoteCWD);
        }
      }
    }
#line 2679
    if (gLoadedBm != 0) {
#line 2679
      if ((int )gBm.ldir[0] != 0) {
        {
#line 2680
        chdir((char const   *)(gBm.ldir));
#line 2681
        Strncpy((char */* const  */)(gPrevLocalCWD), (char const   */* const  */)(gLocalCWD),
                (size_t const   )sizeof(gPrevLocalCWD));
#line 2682
        tmp___5 = FTPGetLocalCWD(gLocalCWD, sizeof(gLocalCWD));
        }
#line 2682
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
          {
#line 2683
          Trace((int const   )-1, (char const   */* const  */)"Current local directory is %s.\n",
                gLocalCWD);
          }
        }
      }
    }
#line 2688
    if (gConn.hasCLNT != 0) {
      {
#line 2689
      FTPCmd((FTPCIPtr const   )(& gConn), (char const   */* const  */)"CLNT NcFTP %.5s %s",
             gVersion + 11, gOS);
      }
    }
#line 2690
    return (0);
  } else {
    {
#line 2692
    FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )0,
              (char const   */* const  */)"Could not open host", (char const   */* const  */)(gConn.host));
    }
  }
  {
#line 2696
  gConn.printResponseProc = (void (*)(FTPCIPtr const    , ResponsePtr  ))0;
#line 2697
  printf((char const   */* __restrict  */)"\n");
  }
#line 2698
  return (-1);
}
}
#line 2708 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void OpenCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int c ;
  int opts ;
  int uOptInd ;
  int n ;
  int rc ;
  char url[256] ;
  char urlfile[128] ;
  int directoryURL ;
  FTPLineList cdlist ;
  FTPLinePtr lp ;
  char prompt[256] ;
  GetoptInfo opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 2712
  opts = 0;
#line 2713
  uOptInd = 0;
#line 2718
  directoryURL = 0;
#line 2724
  if (argc != 0) {
#line 2724
    tmp = 1;
  } else
#line 2724
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2724
    tmp = 1;
  } else
#line 2724
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2724
    tmp = 1;
  } else
#line 2724
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2724
    tmp = 1;
  } else {
#line 2724
    tmp = 0;
  }
  {
#line 2724
  gUnusedArg = tmp;
#line 2725
  FlushLsCache();
#line 2726
  CloseHost();
#line 2727
  gLoadedBm = 0;
#line 2728
  InitConnectionInfo();
#line 2731
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 2732
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2732
    c = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"aP:u:p:j:rd:g:o:");
    }
#line 2732
    if (! (c > 0)) {
#line 2732
      goto while_break;
    }
    {
#line 2733
    if (c == 117) {
#line 2733
      goto case_117;
    }
#line 2737
    goto switch_default;
    case_117: /* CIL Label */ 
#line 2734
    uOptInd = opt.ind + 1;
#line 2735
    opts ++;
#line 2736
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2738
    opts ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2740
  if (opt.ind < (int )argc) {
    {
#line 2741
    Strncpy((char */* const  */)(gConn.host), (char const   */* const  */)*(argv + opt.ind),
            (size_t const   )sizeof(gConn.host));
#line 2742
    Strncpy((char */* const  */)(url), (char const   */* const  */)*(argv + opt.ind),
            (size_t const   )sizeof(url));
    }
  } else
#line 2743
  if (uOptInd > (int )argc) {
    {
#line 2745
    Strncpy((char */* const  */)(gConn.host), (char const   */* const  */)*(argv + (argc - 1)),
            (size_t const   )sizeof(gConn.host));
#line 2746
    Strncpy((char */* const  */)(url), (char const   */* const  */)*(argv + (argc - 1)),
            (size_t const   )sizeof(url));
    }
  } else
#line 2749
  if (opts > 0) {
    {
#line 2750
    PrintCmdUsage((CommandPtr )cmdp);
    }
  } else {
    {
#line 2751
    tmp___1 = RunBookmarkEditor(gConn.host, sizeof(gConn.host));
    }
#line 2751
    if (tmp___1 == 0) {
#line 2752
      if ((int )gConn.host[0] != 0) {
#line 2753
        gLoadedBm = 1;
      } else {
#line 2756
        return;
      }
    } else {
      {
#line 2758
      tmp___0 = PrintHosts();
      }
#line 2758
      if (tmp___0 <= 0) {
        {
#line 2759
        printf((char const   */* __restrict  */)"You haven\'t bookmarked any FTP sites.\n");
#line 2760
        printf((char const   */* __restrict  */)"Before closing a site, you can use the \"bookmark\" command to save the current\nhost and directory for next time.\n");
        }
#line 2761
        return;
      } else {
        {
#line 2763
        printf((char const   */* __restrict  */)"\nTo use a bookmark, use the \"open\" command with the name of the bookmark.\n");
        }
#line 2764
        return;
      }
    }
  }
  {
#line 2768
  InitLineList(& cdlist);
#line 2770
  tmp___2 = GetBookmark((char const   */* const  */)(gConn.host), & gBm);
  }
#line 2770
  if (tmp___2 >= 0) {
    {
#line 2771
    gLoadedBm = 1;
#line 2772
    Strncpy((char */* const  */)(gConn.host), (char const   */* const  */)(gBm.name),
            (size_t const   )sizeof(gConn.host));
#line 2773
    Strncpy((char */* const  */)(gConn.user), (char const   */* const  */)(gBm.user),
            (size_t const   )sizeof(gConn.user));
#line 2774
    Strncpy((char */* const  */)(gConn.pass), (char const   */* const  */)(gBm.pass),
            (size_t const   )sizeof(gConn.pass));
#line 2775
    Strncpy((char */* const  */)(gConn.acct), (char const   */* const  */)(gBm.acct),
            (size_t const   )sizeof(gConn.acct));
#line 2785
    gConn.port = gBm.port;
#line 2792
    gConn.hasPASV = gBm.hasPASV;
    }
  } else {
    {
#line 2794
    SetBookmarkDefaults(& gBm);
#line 2796
    memcpy((void */* __restrict  */)(& gTmpURLConn), (void const   */* __restrict  */)(& gConn),
           sizeof(gTmpURLConn));
#line 2797
    rc = DecodeDirectoryURL((FTPCIPtr const   )(& gTmpURLConn), url, & cdlist, urlfile,
                            sizeof(urlfile));
    }
#line 2798
    if ((int )gTmpURLConn.pass[0] != 0) {
#line 2799
      gUserTypedSensitiveInfoAtShellSoDoNotSaveItToDisk ++;
    }
#line 2801
    if (rc == -2) {
      {
#line 2802
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Malformed URL: %s\n",
              url);
#line 2803
      DisposeLineListContents(& cdlist);
#line 2804
      memset((void *)(& gTmpURLConn), 0, sizeof(gTmpURLConn));
      }
#line 2805
      return;
    } else
#line 2806
    if (rc == -1) {
#line 2807
      directoryURL = 0;
    } else {
#line 2810
      if ((int )urlfile[0] != 0) {
        {
#line 2812
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Use ncftpget or ncftpput to handle file URLs.\n");
#line 2813
        DisposeLineListContents(& cdlist);
        }
#line 2814
        return;
      }
      {
#line 2816
      memcpy((void */* __restrict  */)(& gConn), (void const   */* __restrict  */)(& gTmpURLConn),
             sizeof(gConn));
#line 2817
      directoryURL = 1;
      }
    }
    {
#line 2819
    memset((void *)(& gTmpURLConn), 0, sizeof(gTmpURLConn));
    }
  }
  {
#line 2822
  tmp___3 = MayUseFirewall((char const   */* const  */)(gConn.host), gFirewallType,
                           (char const   */* const  */)(gFirewallExceptionList));
  }
#line 2822
  if (tmp___3 != 0) {
    {
#line 2823
    gConn.firewallType = gFirewallType;
#line 2824
    Strncpy((char */* const  */)(gConn.firewallHost), (char const   */* const  */)(gFirewallHost),
            (size_t const   )sizeof(gConn.firewallHost));
#line 2825
    Strncpy((char */* const  */)(gConn.firewallUser), (char const   */* const  */)(gFirewallUser),
            (size_t const   )sizeof(gConn.firewallUser));
#line 2826
    Strncpy((char */* const  */)(gConn.firewallPass), (char const   */* const  */)(gFirewallPass),
            (size_t const   )sizeof(gConn.firewallPass));
#line 2827
    gConn.firewallPort = gFirewallPort;
    }
  }
  {
#line 2830
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 2831
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2831
    c = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"aP:u:p:j:rd:g:o:");
    }
#line 2831
    if (! (c > 0)) {
#line 2831
      goto while_break___0;
    }
    {
#line 2832
    if (c == 106) {
#line 2832
      goto case_106;
    }
#line 2835
    if (c == 97) {
#line 2835
      goto case_97;
    }
#line 2841
    if (c == 80) {
#line 2841
      goto case_80;
    }
#line 2844
    if (c == 117) {
#line 2844
      goto case_117___0;
    }
#line 2848
    if (c == 112) {
#line 2848
      goto case_112;
    }
#line 2861
    if (c == 114) {
#line 2861
      goto case_114;
    }
#line 2864
    if (c == 103) {
#line 2864
      goto case_103;
    }
#line 2868
    if (c == 100) {
#line 2868
      goto case_100;
    }
#line 2873
    if (c == 111) {
#line 2873
      goto case_111;
    }
#line 2876
    goto switch_default___0;
    case_106: /* CIL Label */ 
    {
#line 2833
    Strncpy((char */* const  */)(gConn.acct), (char const   */* const  */)opt.arg,
            (size_t const   )sizeof(gConn.acct));
    }
#line 2834
    goto switch_break___0;
    case_97: /* CIL Label */ 
    {
#line 2836
    Strncpy((char */* const  */)(gConn.user), (char const   */* const  */)"anonymous",
            (size_t const   )sizeof(gConn.user));
#line 2837
    Strncpy((char */* const  */)(gConn.pass), (char const   */* const  */)"", (size_t const   )sizeof(gConn.pass));
#line 2838
    gConn.passIsEmpty = 0U;
#line 2839
    Strncpy((char */* const  */)(gConn.acct), (char const   */* const  */)"", (size_t const   )sizeof(gConn.acct));
    }
#line 2840
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 2842
    tmp___4 = atoi((char const   *)opt.arg);
#line 2842
    gConn.port = (unsigned int )tmp___4;
    }
#line 2843
    goto switch_break___0;
    case_117___0: /* CIL Label */ 
#line 2845
    if (uOptInd <= (int )argc) {
      {
#line 2846
      Strncpy((char */* const  */)(gConn.user), (char const   */* const  */)opt.arg,
              (size_t const   )sizeof(gConn.user));
      }
    }
#line 2847
    goto switch_break___0;
    case_112: /* CIL Label */ 
    {
#line 2849
    Strncpy((char */* const  */)(gConn.pass), (char const   */* const  */)opt.arg,
            (size_t const   )sizeof(gConn.pass));
    }
#line 2850
    if ((int )gConn.pass[0] == 0) {
#line 2851
      gConn.passIsEmpty = 1U;
    }
    {
#line 2852
    tmp___5 = strlen((char const   *)opt.arg);
#line 2852
    memset((void *)opt.arg, '*', tmp___5);
#line 2859
    gUserTypedSensitiveInfoAtShellSoDoNotSaveItToDisk ++;
    }
#line 2860
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 2863
    goto switch_break___0;
    case_103: /* CIL Label */ 
    {
#line 2865
    n = atoi((char const   *)opt.arg);
#line 2866
    gConn.maxDials = n;
    }
#line 2867
    goto switch_break___0;
    case_100: /* CIL Label */ 
    {
#line 2869
    n = atoi((char const   *)opt.arg);
    }
#line 2870
    if (n >= 10) {
#line 2871
      gConn.redialDelay = n;
    }
#line 2872
    goto switch_break___0;
    case_111: /* CIL Label */ 
#line 2874
    gConn.manualOverrideFeatures = (char const   *)opt.arg;
#line 2875
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2877
    PrintCmdUsage((CommandPtr )cmdp);
#line 2878
    DisposeLineListContents(& cdlist);
    }
#line 2879
    return;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2882
  if (uOptInd > (int )argc) {
    {
#line 2883
    Strncpy((char */* const  */)(prompt), (char const   */* const  */)"Username at ",
            (size_t const   )sizeof(prompt));
#line 2884
    Strncat((char */* const  */)(prompt), (char const   */* const  */)(gConn.host),
            (size_t const   )sizeof(prompt));
#line 2885
    Strncat((char */* const  */)(prompt), (char const   */* const  */)": ", (size_t const   )sizeof(prompt));
#line 2886
    gl_getpass((char const   */* const  */)(prompt), (char */* const  */)(gConn.user),
               (int )sizeof(gConn.user));
    }
  }
  {
#line 2889
  rc = DoOpen();
  }
#line 2890
  if (rc >= 0) {
#line 2890
    if (directoryURL != 0) {
#line 2891
      lp = cdlist.first;
      {
#line 2891
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2891
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 2891
          goto while_break___1;
        }
        {
#line 2892
        rc = FTPChdir((FTPCIPtr const   )(& gConn), (char const   */* const  */)lp->line);
        }
#line 2893
        if (rc != 0) {
          {
#line 2894
          FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-125,
                    (char const   */* const  */)"Could not chdir to", (char const   */* const  */)lp->line);
          }
#line 2895
          goto while_break___1;
        }
#line 2891
        lp = lp->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2898
      rc = FTPGetCWD((FTPCIPtr const   )(& gConn), (char */* const  */)(gRemoteCWD),
                     (size_t const   )sizeof(gRemoteCWD));
      }
#line 2899
      if (rc != 0) {
        {
#line 2900
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-124,
                  (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0));
        }
      } else {
        {
#line 2902
        printf((char const   */* __restrict  */)"Current remote directory is %s.\n",
               gRemoteCWD);
        }
      }
    }
  }
  {
#line 2905
  DisposeLineListContents(& cdlist);
  }
#line 2906
  return;
}
}
#line 2912 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void PageCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int i___0 ;
  FILE * volatile  stream ;
  int sj ;
  void (* volatile  osigpipe)(int  ) ;
  void (* volatile  osigint)(int  ) ;
  int tmp ;
  FILE *tmp___0 ;
  void (*tmp___1)(int  ) ;
  void (*tmp___2)(int  ) ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 2924
  if (argc != 0) {
#line 2924
    tmp = 1;
  } else
#line 2924
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2924
    tmp = 1;
  } else
#line 2924
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2924
    tmp = 1;
  } else
#line 2924
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2924
    tmp = 1;
  } else {
#line 2924
    tmp = 0;
  }
  {
#line 2924
  gUnusedArg = tmp;
#line 2925
  tmp___0 = OpenPager___0();
#line 2925
  stream = (FILE */* volatile  */)tmp___0;
  }
#line 2926
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 2927
    return;
  }
  {
#line 2934
  osigint = (void (*/* volatile  */)(int  ))((void (*)(int  ))0);
#line 2934
  osigpipe = osigint;
#line 2935
  sj = __sigsetjmp((struct __jmp_buf_tag *)(gCancelJmp), 1);
  }
#line 2941
  if (sj != 0) {
    {
#line 2943
    NcSignal(13, (void (*)(int  ))1);
#line 2944
    ClosePager___0((FILE *)stream);
#line 2945
    NcSignal(13, (void (*)(int  ))osigpipe);
#line 2946
    NcSignal(2, (void (*)(int  ))osigint);
#line 2947
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Canceled.\n");
#line 2948
    Trace((int const   )0, (char const   */* const  */)"Canceled because of signal %d.\n",
          gGotSig);
#line 2949
    gMayCancelJmp = 0;
    }
#line 2950
    return;
  } else {
    {
#line 2952
    tmp___1 = NcSignal(13, & Cancel);
#line 2952
    osigpipe = (void (*/* volatile  */)(int  ))tmp___1;
#line 2953
    tmp___2 = NcSignal(2, & Cancel);
#line 2953
    osigint = (void (*/* volatile  */)(int  ))tmp___2;
#line 2954
    gMayCancelJmp = 1;
    }
  }
#line 2959
  i___0 = 1;
  {
#line 2959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2959
    if (! (i___0 < (int )argc)) {
#line 2959
      goto while_break;
    }
    {
#line 2960
    tmp___3 = fileno((FILE *)stream);
#line 2960
    result = FTPGetOneFile2((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                            (char const   */* const  */)((void *)0), (int const   )'A',
                            (int const   )tmp___3, (int const   )0, (int const   )0);
    }
#line 2961
    if (result < 0) {
      {
#line 2962
      tmp___4 = __errno_location();
      }
#line 2962
      if (*tmp___4 != 32) {
        {
#line 2963
        ClosePager___0((FILE *)stream);
#line 2964
        stream = (FILE */* volatile  */)((void *)0);
#line 2965
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-160,
                  (char const   */* const  */)*(argv + 0), (char const   */* const  */)*(argv + i___0));
        }
      }
#line 2967
      goto while_break;
    }
#line 2959
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2974
  NcSignal(13, (void (*)(int  ))1);
#line 2975
  ClosePager___0((FILE *)stream);
#line 2976
  NcSignal(13, (void (*)(int  ))osigpipe);
#line 2977
  NcSignal(2, (void (*)(int  ))osigint);
#line 2979
  gMayCancelJmp = 0;
  }
#line 2980
  return;
}
}
#line 2988 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void PassiveCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
#line 2991
  if (argc != 0) {
#line 2991
    tmp = 1;
  } else
#line 2991
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 2991
    tmp = 1;
  } else
#line 2991
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 2991
    tmp = 1;
  } else
#line 2991
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 2991
    tmp = 1;
  } else {
#line 2991
    tmp = 0;
  }
#line 2991
  gUnusedArg = tmp;
#line 2992
  if (gConn.dataPortMode == 1) {
#line 2992
    tmp___0 = "off";
  } else {
#line 2992
    tmp___0 = "on";
  }
  {
#line 2992
  Set((char const   */* const  */)"passive", (char const   */* const  */)tmp___0);
#line 2993
  Set((char const   */* const  */)"passive", (char const   */* const  */)((void *)0));
  }
#line 2994
  return;
}
}
#line 3012 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static char newname___0[128]  ;
#line 2999 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int NcFTPConfirmResumeUploadProc(FTPCIPtr const   cipUNUSED , char const   *localpath ,
                                        long long localsize , time_t localmtime ,
                                        char const   **remotepath , long long remotesize ,
                                        time_t remotemtime , long long *startPoint ) 
{ 
  int zaction ;
  char tstr[80] ;
  char ans[32] ;
  struct tm t ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;
  struct tm *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
#line 3010
  zaction = 5;
#line 3015
  gUnusedArg = (unsigned long )cipUNUSED != (unsigned long )((void *)0);
#line 3016
  if (gResumeAnswerAll != 0) {
#line 3017
    if (gResumeAnswerAll == 2) {
#line 3018
      if (gConn.hasREST != 1) {
#line 3020
        return (zaction);
      } else
#line 3021
      if (remotesize > localsize) {
#line 3023
        return (zaction);
      } else
#line 3024
      if (remotesize == localsize) {
#line 3026
        return (zaction);
      }
#line 3028
      *startPoint = remotesize;
    }
#line 3030
    return (gResumeAnswerAll);
  }
#line 3033
  if (gAutoResume != 0) {
#line 3034
    return (5);
  } else
#line 3033
  if (gIsTTYr == 0) {
#line 3034
    return (5);
  }
  {
#line 3036
  printf((char const   */* __restrict  */)"\nThe remote file \"%s\" already exists.\n",
         *remotepath);
  }
#line 3038
  if (localmtime != -1L) {
#line 3038
    if (localsize != -1LL) {
      {
#line 3039
      tmp = Localtime(localmtime, (struct tm */* const  */)(& t));
#line 3039
      strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
               (struct tm  const  */* __restrict  */)tmp);
#line 3040
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tLocal:  %12lld bytes, dated %s.\n",
              localsize, tstr);
      }
#line 3053
      if (remotemtime == localmtime) {
#line 3053
        if (remotesize == localsize) {
          {
#line 3054
          printf((char const   */* __restrict  */)"\t(Files are identical, skipped)\n\n");
          }
#line 3055
          return (1);
        }
      }
    } else {
#line 3038
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3057
  if (localsize != -1LL) {
    {
#line 3058
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tLocal:  %12lld bytes, date unknown.\n",
            localsize);
    }
  } else
#line 3070
  if (localmtime != -1L) {
    {
#line 3071
    tmp___0 = Localtime(localmtime, (struct tm */* const  */)(& t));
#line 3071
    strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
             (struct tm  const  */* __restrict  */)tmp___0);
#line 3072
    printf((char const   */* __restrict  */)"\tLocal:  size unknown, dated %s.\n",
           tstr);
    }
  }
#line 3078
  tstr[sizeof(tstr) - 1UL] = (char )'\000';
#line 3079
  if (remotemtime != -1L) {
#line 3079
    if (remotesize != -1LL) {
      {
#line 3080
      tmp___1 = Localtime(remotemtime, (struct tm */* const  */)(& t));
#line 3080
      strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
               (struct tm  const  */* __restrict  */)tmp___1);
#line 3081
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tRemote: %12lld bytes, dated %s.\n",
              remotesize, tstr);
      }
    } else {
#line 3079
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3094
  if (remotesize != -1LL) {
    {
#line 3095
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tRemote: %12lld bytes, date unknown.\n",
            remotesize);
    }
  } else
#line 3107
  if (remotemtime != -1L) {
    {
#line 3108
    tmp___2 = Localtime(remotemtime, (struct tm */* const  */)(& t));
#line 3108
    strftime((char */* __restrict  */)(tstr), sizeof(tstr) - 1UL, (char const   */* __restrict  */)"%c",
             (struct tm  const  */* __restrict  */)tmp___2);
#line 3109
    printf((char const   */* __restrict  */)"\tRemote: size unknown, dated %s.\n",
           tstr);
    }
  }
  {
#line 3115
  printf((char const   */* __restrict  */)"\n");
#line 3116
  fflush(stdin);
#line 3117
  memset((void *)(ans), 0, sizeof(ans));
  }
  {
#line 3118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3119
    printf((char const   */* __restrict  */)"\t[O]verwrite?");
    }
#line 3121
    if (remotesize < localsize) {
      {
#line 3122
      printf((char const   */* __restrict  */)"  [R]esume?");
      }
    }
    {
#line 3123
    printf((char const   */* __restrict  */)"  [A]ppend to?  [S]kip?  [N]ew Name?\n");
#line 3124
    printf((char const   */* __restrict  */)"\t[O!]verwrite all?");
    }
#line 3126
    if (remotesize < localsize) {
      {
#line 3127
      printf((char const   */* __restrict  */)"  [R!]esume all?");
      }
    }
    {
#line 3128
    printf((char const   */* __restrict  */)"  [S!]kip all?  [C]ancel  > ");
#line 3129
    fgets((char */* __restrict  */)(ans), (int )(sizeof(ans) - 1UL), (FILE */* __restrict  */)stdin);
    }
    {
#line 3132
    if ((int )ans[0] == 67) {
#line 3132
      goto case_67;
    }
#line 3132
    if ((int )ans[0] == 99) {
#line 3132
      goto case_67;
    }
#line 3138
    if ((int )ans[0] == 79) {
#line 3138
      goto case_79;
    }
#line 3138
    if ((int )ans[0] == 111) {
#line 3138
      goto case_79;
    }
#line 3143
    if ((int )ans[0] == 82) {
#line 3143
      goto case_82;
    }
#line 3143
    if ((int )ans[0] == 114) {
#line 3143
      goto case_82;
    }
#line 3165
    if ((int )ans[0] == 83) {
#line 3165
      goto case_83;
    }
#line 3165
    if ((int )ans[0] == 115) {
#line 3165
      goto case_83;
    }
#line 3170
    if ((int )ans[0] == 78) {
#line 3170
      goto case_78;
    }
#line 3170
    if ((int )ans[0] == 110) {
#line 3170
      goto case_78;
    }
#line 3176
    if ((int )ans[0] == 65) {
#line 3176
      goto case_65;
    }
#line 3176
    if ((int )ans[0] == 97) {
#line 3176
      goto case_65;
    }
#line 3182
    if ((int )ans[0] == 71) {
#line 3182
      goto case_71;
    }
#line 3182
    if ((int )ans[0] == 103) {
#line 3182
      goto case_71;
    }
#line 3186
    goto switch_default;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 3133
    ans[0] = (char )'C';
#line 3134
    ans[1] = (char )'\000';
#line 3135
    zaction = 6;
#line 3136
    goto switch_break;
    case_79: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 3139
    ans[0] = (char )'O';
#line 3140
    zaction = 3;
#line 3141
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 3148
    if (remotesize > localsize) {
      {
#line 3149
      printf((char const   */* __restrict  */)"\tCannot resume when remote file is already larger than the local file.\n\n");
#line 3150
      ans[0] = (char )'\000';
      }
#line 3151
      goto switch_break;
    } else
#line 3152
    if (remotesize == localsize) {
      {
#line 3153
      printf((char const   */* __restrict  */)"\tRemote file is already the same size as the local file.\n\n");
#line 3154
      ans[0] = (char )'\000';
      }
#line 3155
      goto switch_break;
    }
    {
#line 3157
    ans[0] = (char )'R';
#line 3158
    *startPoint = remotesize;
#line 3159
    zaction = 2;
#line 3160
    tmp___3 = OneTimeMessage((char const   */* const  */)"auto-resume");
    }
#line 3160
    if (tmp___3 != 0) {
      {
#line 3161
      printf((char const   */* __restrict  */)"\n\tNOTE: If you want NcFTP to guess automatically, \"set auto-resume yes\"\n\n");
      }
    }
#line 3163
    goto switch_break;
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 3166
    ans[0] = (char )'S';
#line 3167
    zaction = 1;
#line 3168
    goto switch_break;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 3171
    ans[0] = (char )'N';
#line 3172
    ans[1] = (char )'\000';
#line 3173
    zaction = 3;
#line 3174
    goto switch_break;
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 3177
    ans[0] = (char )'A';
#line 3178
    ans[1] = (char )'\000';
#line 3179
    zaction = 4;
#line 3180
    goto switch_break;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
#line 3183
    ans[0] = (char )'G';
#line 3184
    zaction = 5;
#line 3185
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3187
    ans[0] = (char )'\000';
    switch_break: /* CIL Label */ ;
    }
#line 3189
    if ((int )ans[0] != 0) {
#line 3190
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3193
  if ((int )ans[0] == 78) {
    {
#line 3194
    memset((void *)(newname___0), 0, sizeof(newname___0));
#line 3195
    printf((char const   */* __restrict  */)"\tSave as:  ");
#line 3196
    fflush(stdin);
#line 3197
    fgets((char */* __restrict  */)(newname___0), (int )(sizeof(newname___0) - 1UL),
          (FILE */* __restrict  */)stdin);
#line 3198
    tmp___4 = strlen((char const   *)(newname___0));
#line 3198
    newname___0[tmp___4 - 1UL] = (char )'\000';
    }
#line 3199
    if ((int )newname___0[0] == 0) {
      {
#line 3201
      printf((char const   */* __restrict  */)"Skipped %s.\n", localpath);
#line 3202
      zaction = 1;
      }
    } else {
#line 3204
      *remotepath = (char const   *)(newname___0);
    }
  }
#line 3208
  if ((int )ans[1] == 33) {
#line 3209
    gResumeAnswerAll = zaction;
  }
#line 3210
  return (zaction);
}
}
#line 3217 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void PutCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int optrc ;
  int renameMode ;
  int recurseFlag ;
  int appendFlag ;
  char const   *dstdir ;
  int rc ;
  int i___0 ;
  int doGlob ;
  int xtype ;
  int nD ;
  int deleteFlag ;
  int resumeFlag ;
  char pattern[256] ;
  void (* volatile  osigint)(int  ) ;
  int (*confirmProc)(FTPCIPtr const   cip , char const   *localpath , long long localsize ,
                     time_t localmtime , char const   **remotepath , long long remotesize ,
                     time_t remotetime , long long *startPoint ) ;
  GetoptInfo opt ;
  int tmp ;
  void (*tmp___0)(int  ) ;
  void (*tmp___1)(int  ) ;

  {
#line 3221
  renameMode = 0;
#line 3222
  recurseFlag = 0;
#line 3223
  appendFlag = 0;
#line 3224
  dstdir = (char const   *)((void *)0);
#line 3228
  xtype = gBm.xferType;
#line 3229
  nD = 0;
#line 3230
  deleteFlag = 0;
#line 3231
  resumeFlag = 1;
#line 3237
  confirmProc = & NcFTPConfirmResumeUploadProc;
#line 3238
  gResumeAnswerAll = 0;
#line 3239
  if (argc != 0) {
#line 3239
    tmp = 1;
  } else
#line 3239
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3239
    tmp = 1;
  } else
#line 3239
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3239
    tmp = 1;
  } else
#line 3239
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3239
    tmp = 1;
  } else {
#line 3239
    tmp = 0;
  }
  {
#line 3239
  gUnusedArg = tmp;
#line 3240
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 3241
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3241
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"AafZzrRD");
    }
#line 3241
    if (! (optrc >= 0)) {
#line 3241
      goto while_break;
    }
    {
#line 3242
    if (optrc == 97) {
#line 3242
      goto case_97;
    }
#line 3245
    if (optrc == 65) {
#line 3245
      goto case_65;
    }
#line 3252
    if (optrc == 90) {
#line 3252
      goto case_90;
    }
#line 3252
    if (optrc == 102) {
#line 3252
      goto case_90;
    }
#line 3260
    if (optrc == 122) {
#line 3260
      goto case_122;
    }
#line 3269
    if (optrc == 82) {
#line 3269
      goto case_82;
    }
#line 3269
    if (optrc == 114) {
#line 3269
      goto case_82;
    }
#line 3276
    if (optrc == 68) {
#line 3276
      goto case_68;
    }
#line 3285
    goto switch_default;
    case_97: /* CIL Label */ 
#line 3243
    xtype = 'A';
#line 3244
    goto switch_break;
    case_65: /* CIL Label */ 
#line 3249
    appendFlag = 1;
#line 3250
    goto switch_break;
    case_90: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 3257
    resumeFlag = 0;
#line 3258
    confirmProc = (int (*)(FTPCIPtr const   cip , char const   *localpath , long long localsize ,
                           time_t localmtime , char const   **remotepath , long long remotesize ,
                           time_t remotetime , long long *startPoint ))0;
#line 3259
    goto switch_break;
    case_122: /* CIL Label */ 
#line 3266
    renameMode = 1;
#line 3267
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 3270
    recurseFlag = 1;
#line 3274
    recurseFlag = 1;
#line 3275
    goto switch_break;
    case_68: /* CIL Label */ 
#line 3283
    nD ++;
#line 3284
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3286
    PrintCmdUsage((CommandPtr )cmdp);
    }
#line 3287
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3290
  if (nD >= 2) {
#line 3291
    deleteFlag = 1;
  }
#line 3293
  if (renameMode != 0) {
#line 3294
    if (opt.ind > (int )(argc - 2)) {
      {
#line 3295
      PrintCmdUsage((CommandPtr )cmdp);
#line 3296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFor put with rename, try \"put -z local-path-name remote-path-name\".\n");
      }
#line 3297
      return;
    }
    {
#line 3299
    tmp___0 = NcSignal(2, & XferCanceller);
#line 3299
    osigint = (void (*/* volatile  */)(int  ))tmp___0;
#line 3300
    rc = FTPPutOneFile3((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + opt.ind),
                        (char const   */* const  */)*(argv + (opt.ind + 1)), (int const   )xtype,
                        (int const   )-1, (int const   )appendFlag, (char const   */* const  */)((void *)0),
                        (char const   */* const  */)((void *)0), (int const   )resumeFlag,
                        (int const   )deleteFlag, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                       char const   *localpath ,
                                                                       long long localsize ,
                                                                       time_t localmtime ,
                                                                       char const   **remotepath ,
                                                                       long long remotesize ,
                                                                       time_t remotetime ,
                                                                       long long *startPoint ))confirmProc,
                        0);
    }
#line 3301
    if (rc < 0) {
      {
#line 3302
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-160,
                (char const   */* const  */)"put", (char const   */* const  */)*(argv + (opt.ind + 1)));
      }
    }
  } else {
    {
#line 3304
    tmp___1 = NcSignal(2, & XferCanceller);
#line 3304
    osigint = (void (*/* volatile  */)(int  ))tmp___1;
#line 3305
    i___0 = opt.ind;
    }
    {
#line 3305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3305
      if (! (i___0 < (int )argc)) {
#line 3305
        goto while_break___0;
      }
#line 3306
      if (aip->noglobargv[i___0] != 0) {
#line 3306
        doGlob = 0;
      } else {
#line 3306
        doGlob = 1;
      }
      {
#line 3307
      Strncpy((char */* const  */)(pattern), (char const   */* const  */)*(argv + i___0),
              (size_t const   )sizeof(pattern));
#line 3308
      StrRemoveTrailingSlashes(pattern);
#line 3309
      rc = FTPPutFiles3((FTPCIPtr const   )(& gConn), (char const   */* const  */)(pattern),
                        (char const   */* const  */)dstdir, (int const   )recurseFlag,
                        (int const   )doGlob, (int const   )xtype, appendFlag, (char const   */* const  */)((void *)0),
                        (char const   */* const  */)((void *)0), (int const   )resumeFlag,
                        (int const   )deleteFlag, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                       char const   *localpath ,
                                                                       long long localsize ,
                                                                       time_t localmtime ,
                                                                       char const   **remotepath ,
                                                                       long long remotesize ,
                                                                       time_t remotetime ,
                                                                       long long *startPoint ))confirmProc,
                        0);
      }
#line 3310
      if (rc < 0) {
        {
#line 3311
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-160,
                  (char const   */* const  */)"put", (char const   */* const  */)*(argv + i___0));
        }
      }
#line 3305
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 3316
  FlushLsCache();
#line 3318
  NcSignal(2, (void (*)(int  ))osigint);
#line 3319
  fflush(stdin);
  }
#line 3320
  return;
}
}
#line 3326 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void PwdCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int result ;
  char url[256] ;
  char olddir[256] ;
  int tmp ;
  int tmp___0 ;

  {
#line 3333
  if (argc != 0) {
#line 3333
    tmp = 1;
  } else
#line 3333
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3333
    tmp = 1;
  } else
#line 3333
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3333
    tmp = 1;
  } else
#line 3333
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3333
    tmp = 1;
  } else {
#line 3333
    tmp = 0;
  }
  {
#line 3333
  gUnusedArg = tmp;
#line 3347
  CurrentURL(url, sizeof(url), 0);
#line 3348
  Trace((int const   )-1, (char const   */* const  */)"  %s\n", url);
#line 3349
  olddir[sizeof(olddir) - 2UL] = (char )'\000';
#line 3350
  Strncpy((char */* const  */)(olddir), (char const   */* const  */)(gRemoteCWD),
          (size_t const   )sizeof(olddir));
#line 3356
  result = FTPGetCWD((FTPCIPtr const   )(& gConn), (char */* const  */)(gRemoteCWD),
                     (size_t const   )sizeof(gRemoteCWD));
  }
#line 3357
  if (result == 0) {
    {
#line 3357
    tmp___0 = strcmp((char const   *)(gRemoteCWD), (char const   *)(olddir));
    }
#line 3357
    if (tmp___0 != 0) {
      {
#line 3358
      Trace((int const   )-1, (char const   */* const  */)"This URL is also valid on this server:\n");
#line 3359
      CurrentURL(url, sizeof(url), 0);
#line 3360
      Trace((int const   )-1, (char const   */* const  */)"  %s\n", url);
      }
#line 3361
      if ((int )olddir[sizeof(olddir) - 2UL] == 0) {
        {
#line 3363
        Strncpy((char */* const  */)(gRemoteCWD), (char const   */* const  */)(olddir),
                (size_t const   )sizeof(gRemoteCWD));
        }
      }
    }
  }
#line 3367
  return;
}
}
#line 3373 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void QuitCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 3376
  if (argc != 0) {
#line 3376
    tmp = 1;
  } else
#line 3376
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3376
    tmp = 1;
  } else
#line 3376
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3376
    tmp = 1;
  } else
#line 3376
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3376
    tmp = 1;
  } else {
#line 3376
    tmp = 0;
  }
#line 3376
  gUnusedArg = tmp;
#line 3377
  gDoneApplication = 1;
#line 3378
  return;
}
}
#line 3384 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void QuoteCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  char cmdbuf[256] ;
  int i___0 ;
  int tmp ;

  {
#line 3390
  if (argc != 0) {
#line 3390
    tmp = 1;
  } else
#line 3390
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3390
    tmp = 1;
  } else
#line 3390
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3390
    tmp = 1;
  } else
#line 3390
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3390
    tmp = 1;
  } else {
#line 3390
    tmp = 0;
  }
  {
#line 3390
  gUnusedArg = tmp;
#line 3391
  Strncpy((char */* const  */)(cmdbuf), (char const   */* const  */)*(argv + 1), (size_t const   )sizeof(cmdbuf));
#line 3392
  i___0 = 2;
  }
  {
#line 3392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3392
    if (! (i___0 < (int )argc)) {
#line 3392
      goto while_break;
    }
    {
#line 3393
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)" ", (size_t const   )sizeof(cmdbuf));
#line 3394
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)*(argv + i___0),
            (size_t const   )sizeof(cmdbuf));
#line 3392
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3396
  FTPCmd((FTPCIPtr const   )(& gConn), (char const   */* const  */)"%s", cmdbuf);
#line 3397
  PrintResp(& gConn.lastFTPCmdResultLL);
  }
#line 3398
  return;
}
}
#line 3404 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void RGlobCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int result ;
  int np ;
  FTPLineList ll ;
  FTPLinePtr lp ;
  int tmp ;
  int tmp___0 ;

  {
#line 3409
  np = 0;
#line 3413
  if (argc != 0) {
#line 3413
    tmp = 1;
  } else
#line 3413
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3413
    tmp = 1;
  } else
#line 3413
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3413
    tmp = 1;
  } else
#line 3413
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3413
    tmp = 1;
  } else {
#line 3413
    tmp = 0;
  }
#line 3413
  gUnusedArg = tmp;
#line 3414
  i___0 = 1;
  {
#line 3414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3414
    if (! (i___0 < (int )argc)) {
#line 3414
      goto while_break;
    }
    {
#line 3415
    InitLineList(& ll);
    }
#line 3416
    if (aip->noglobargv[i___0] != 0) {
#line 3416
      tmp___0 = 0;
    } else {
#line 3416
      tmp___0 = 1;
    }
    {
#line 3416
    result = FTPRemoteGlob(& gConn, & ll, (char const   *)*(argv + i___0), tmp___0);
    }
#line 3417
    if (result < 0) {
      {
#line 3418
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-151,
                (char const   */* const  */)"remote glob", (char const   */* const  */)*(argv + i___0));
      }
    } else {
#line 3420
      lp = ll.first;
      {
#line 3420
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3420
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 3420
          goto while_break___0;
        }
#line 3421
        if ((unsigned long )lp->line != (unsigned long )((void *)0)) {
#line 3422
          if (np > 0) {
            {
#line 3423
            printf((char const   */* __restrict  */)" ");
            }
          }
          {
#line 3424
          printf((char const   */* __restrict  */)"%s", lp->line);
#line 3425
          np ++;
          }
        }
#line 3420
        lp = lp->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 3429
    DisposeLineListContents(& ll);
#line 3414
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3431
  printf((char const   */* __restrict  */)"\n");
  }
#line 3432
  return;
}
}
#line 3438 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void RenameCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
               ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int tmp ;

  {
#line 3443
  if (argc != 0) {
#line 3443
    tmp = 1;
  } else
#line 3443
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3443
    tmp = 1;
  } else
#line 3443
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3443
    tmp = 1;
  } else
#line 3443
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3443
    tmp = 1;
  } else {
#line 3443
    tmp = 0;
  }
  {
#line 3443
  gUnusedArg = tmp;
#line 3444
  result = FTPRename((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + 1),
                     (char const   */* const  */)*(argv + 2));
  }
#line 3445
  if (result < 0) {
    {
#line 3446
    FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-150,
              (char const   */* const  */)"rename", (char const   */* const  */)*(argv + 1));
    }
  } else {
    {
#line 3449
    FlushLsCache();
    }
  }
#line 3451
  return;
}
}
#line 3457 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void RmdirCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int i___0 ;
  int c ;
  int recursive ;
  GetoptInfo opt ;
  int tmp ;
  int tmp___0 ;

  {
#line 3462
  recursive = 0;
#line 3465
  if (argc != 0) {
#line 3465
    tmp = 1;
  } else
#line 3465
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3465
    tmp = 1;
  } else
#line 3465
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3465
    tmp = 1;
  } else
#line 3465
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3465
    tmp = 1;
  } else {
#line 3465
    tmp = 0;
  }
  {
#line 3465
  gUnusedArg = tmp;
#line 3466
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 3467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3467
    c = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"rf");
    }
#line 3467
    if (! (c > 0)) {
#line 3467
      goto while_break;
    }
    {
#line 3468
    if (c == 114) {
#line 3468
      goto case_114;
    }
#line 3471
    if (c == 102) {
#line 3471
      goto case_102;
    }
#line 3474
    goto switch_default;
    case_114: /* CIL Label */ 
#line 3469
    recursive = 1;
#line 3470
    goto switch_break;
    case_102: /* CIL Label */ 
#line 3473
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3475
    PrintCmdUsage((CommandPtr )cmdp);
    }
#line 3476
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3478
  i___0 = opt.ind;
  {
#line 3478
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3478
    if (! (i___0 < (int )argc)) {
#line 3478
      goto while_break___0;
    }
#line 3479
    if (aip->noglobargv[i___0] != 0) {
#line 3479
      tmp___0 = 0;
    } else {
#line 3479
      tmp___0 = 1;
    }
    {
#line 3479
    result = FTPRmdir((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                      (int const   )recursive, (int const   )tmp___0);
    }
#line 3480
    if (result < 0) {
      {
#line 3481
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-126,
                (char const   */* const  */)"rmdir", (char const   */* const  */)*(argv + i___0));
      }
    }
#line 3478
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3485
  FlushLsCache();
  }
#line 3486
  return;
}
}
#line 3492 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void RmtHelpCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int result ;
  FTPLineList ll ;
  FTPLinePtr lp ;
  int tmp ;

  {
#line 3499
  if (argc != 0) {
#line 3499
    tmp = 1;
  } else
#line 3499
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3499
    tmp = 1;
  } else
#line 3499
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3499
    tmp = 1;
  } else
#line 3499
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3499
    tmp = 1;
  } else {
#line 3499
    tmp = 0;
  }
#line 3499
  gUnusedArg = tmp;
#line 3500
  if (argc == 1) {
    {
#line 3501
    result = FTPRemoteHelp((FTPCIPtr const   )(& gConn), (char const   */* const  */)((void *)0),
                           (FTPLineListPtr const   )(& ll));
    }
#line 3502
    if (result < 0) {
      {
#line 3503
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-166,
                (char const   */* const  */)"HELP failed", (char const   */* const  */)((void *)0));
      }
    } else {
#line 3505
      lp = ll.first;
      {
#line 3505
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3505
        if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 3505
          goto while_break;
        }
        {
#line 3506
        printf((char const   */* __restrict  */)"%s\n", lp->line);
#line 3505
        lp = lp->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 3508
    DisposeLineListContents(& ll);
    }
  } else {
#line 3510
    i___0 = 1;
    {
#line 3510
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3510
      if (! (i___0 < (int )argc)) {
#line 3510
        goto while_break___0;
      }
      {
#line 3511
      result = FTPRemoteHelp((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + i___0),
                             (FTPLineListPtr const   )(& ll));
      }
#line 3512
      if (result < 0) {
        {
#line 3513
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-166,
                  (char const   */* const  */)"HELP failed for", (char const   */* const  */)*(argv + i___0));
        }
      } else {
#line 3515
        lp = ll.first;
        {
#line 3515
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3515
          if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 3515
            goto while_break___1;
          }
          {
#line 3516
          printf((char const   */* __restrict  */)"%s\n", lp->line);
#line 3515
          lp = lp->next;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 3518
      DisposeLineListContents(& ll);
#line 3510
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 3521
  return;
}
}
#line 3529 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SetCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 3532
  if (argc != 0) {
#line 3532
    tmp = 1;
  } else
#line 3532
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3532
    tmp = 1;
  } else
#line 3532
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3532
    tmp = 1;
  } else
#line 3532
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3532
    tmp = 1;
  } else {
#line 3532
    tmp = 0;
  }
#line 3532
  gUnusedArg = tmp;
#line 3533
  if (argc < 2) {
    {
#line 3534
    Set((char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0));
    }
  } else
#line 3535
  if (argc == 2) {
    {
#line 3536
    Set((char const   */* const  */)*(argv + 1), (char const   */* const  */)((void *)0));
    }
  } else {
    {
#line 3538
    Set((char const   */* const  */)*(argv + 1), (char const   */* const  */)*(argv + 2));
    }
  }
#line 3539
  return;
}
}
#line 3545 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void ShellCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  char const   *cp ;
  pid_t pid ;
  int status ;
  void (* volatile  osigint)(int  ) ;
  char **margv ;
  int margc ;
  void (*tmp)(int  ) ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  union __anonunion_64 __constr_expr_8 ;
  union __anonunion_65 __constr_expr_9 ;

  {
  {
#line 3557
  tmp = NcSignal(2, (void (*)(int  ))1);
#line 3557
  osigint = (void (*/* volatile  */)(int  ))tmp;
  }
#line 3558
  if (argc != 0) {
#line 3558
    tmp___0 = 1;
  } else
#line 3558
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3558
    tmp___0 = 1;
  } else
#line 3558
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3558
    tmp___0 = 1;
  } else
#line 3558
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3558
    tmp___0 = 1;
  } else {
#line 3558
    tmp___0 = 0;
  }
  {
#line 3558
  gUnusedArg = tmp___0;
#line 3559
  pid = fork();
  }
#line 3560
  if (pid < 0) {
    {
#line 3561
    perror("fork");
    }
  } else
#line 3562
  if (pid == 0) {
    {
#line 3563
    tmp___1 = strrchr((char const   *)(gShell), '/');
#line 3563
    cp = (char const   *)tmp___1;
    }
#line 3564
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 3565
      cp = (char const   *)(gShell);
    } else {
#line 3567
      cp ++;
    }
#line 3568
    if (argc == 1) {
      {
#line 3569
      execl((char const   *)(gShell), cp, (void *)0);
#line 3570
      perror((char const   *)(gShell));
#line 3571
      exit(1);
      }
    } else {
      {
#line 3573
      tmp___2 = calloc((size_t )(argc + 1), sizeof(char *));
#line 3573
      margv = (char **)tmp___2;
      }
#line 3574
      if ((unsigned long )margv == (unsigned long )((char **)0)) {
        {
#line 3575
        perror("malloc");
#line 3576
        exit(1);
        }
      }
#line 3578
      margc = 1;
      {
#line 3578
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3579
        if ((unsigned long )*(argv + margc) == (unsigned long )((void *)0)) {
#line 3580
          goto while_break;
        }
        {
#line 3581
        *(margv + (margc - 1)) = strdup((char const   *)*(argv + margc));
#line 3578
        margc ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3583
      execvp((char const   *)*(margv + 0), (char * const  *)margv);
#line 3584
      perror((char const   *)(gShell));
#line 3585
      exit(1);
      }
    }
  } else {
    {
#line 3589
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3591
      tmp___3 = waitpid(pid, & status, 0);
      }
#line 3591
      if (tmp___3 < 0) {
        {
#line 3591
        tmp___4 = __errno_location();
        }
#line 3591
        if (*tmp___4 != 4) {
#line 3592
          goto while_break___0;
        }
      }
#line 3597
      __constr_expr_8.__in = status;
#line 3597
      if ((__constr_expr_8.__i & 127) == 0) {
#line 3598
        goto while_break___0;
      } else {
#line 3597
        __constr_expr_9.__in = status;
#line 3597
        if ((int )((signed char )((__constr_expr_9.__i & 127) + 1)) >> 1 > 0) {
#line 3598
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 3601
  NcSignal(2, (void (*)(int  ))osigint);
  }
#line 3603
  return;
}
}
#line 3609 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SiteCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  char cmdbuf[256] ;
  int i___0 ;
  int tmp ;

  {
#line 3615
  if (argc != 0) {
#line 3615
    tmp = 1;
  } else
#line 3615
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3615
    tmp = 1;
  } else
#line 3615
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3615
    tmp = 1;
  } else
#line 3615
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3615
    tmp = 1;
  } else {
#line 3615
    tmp = 0;
  }
  {
#line 3615
  gUnusedArg = tmp;
#line 3616
  Strncpy((char */* const  */)(cmdbuf), (char const   */* const  */)"SITE", (size_t const   )sizeof(cmdbuf));
#line 3617
  i___0 = 1;
  }
  {
#line 3617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3617
    if (! (i___0 < (int )argc)) {
#line 3617
      goto while_break;
    }
    {
#line 3618
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)" ", (size_t const   )sizeof(cmdbuf));
#line 3619
    Strncat((char */* const  */)(cmdbuf), (char const   */* const  */)*(argv + i___0),
            (size_t const   )sizeof(cmdbuf));
#line 3617
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3621
  FTPCmd((FTPCIPtr const   )(& gConn), (char const   */* const  */)"%s", cmdbuf);
#line 3622
  PrintResp(& gConn.lastFTPCmdResultLL);
  }
#line 3623
  return;
}
}
#line 3628 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static time_t GetStartSpoolDate(char const   *s ) 
{ 
  char *cp ;
  char s2[64] ;
  time_t now ;
  time_t when ;
  int toff ;
  int n ;
  int c ;
  int hr ;
  int min ;
  struct tm lt ;
  struct tm *ltp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 3637
  Strncpy((char */* const  */)(s2), (char const   */* const  */)s, (size_t const   )sizeof(s2));
#line 3638
  cp = strchr((char const   *)(s2), ':');
  }
#line 3639
  if ((int )s2[0] == 110) {
#line 3639
    goto _L;
  } else
#line 3639
  if ((int )s2[0] == 43) {
    _L: /* CIL Label */ 
    {
#line 3643
    cp = strchr((char const   *)(s2), '+');
    }
#line 3644
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 3645
      return ((time_t )-1);
    }
    {
#line 3646
    cp ++;
#line 3647
    toff = 0;
#line 3648
    n = 0;
#line 3649
    sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"%d%n",
           & toff, & n);
    }
#line 3650
    if (n <= 0) {
#line 3651
      return ((time_t )-1);
    } else
#line 3650
    if (toff <= 0) {
#line 3651
      return ((time_t )-1);
    }
#line 3652
    cp += n;
    {
#line 3653
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3653
      if ((int )*cp != 0) {
        {
#line 3653
        tmp = __ctype_b_loc();
        }
#line 3653
        if ((int const   )*(*tmp + (int )*cp) & 1024) {
#line 3653
          goto while_break;
        }
      } else {
#line 3653
        goto while_break;
      }
#line 3654
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3655
    c = (int )*cp;
#line 3656
    tmp___0 = __ctype_b_loc();
    }
#line 3656
    if ((int const   )*(*tmp___0 + c) & 256) {
      {
#line 3657
      c = tolower(c);
      }
    }
#line 3658
    if (! (c == 115)) {
#line 3660
      if (c == 109) {
#line 3662
        toff *= 60;
      } else
#line 3663
      if (c == 104) {
#line 3665
        toff *= 3600;
      } else
#line 3666
      if (c == 100) {
#line 3668
        toff *= 86400;
      } else {
#line 3671
        return ((time_t )-1);
      }
    }
    {
#line 3673
    time(& now);
#line 3674
    when = now + (time_t )toff;
    }
  } else
#line 3675
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 3677
    tmp___1 = time(& now);
#line 3677
    ltp = Localtime(tmp___1, (struct tm */* const  */)(& lt));
    }
#line 3678
    if ((unsigned long )ltp == (unsigned long )((void *)0)) {
#line 3679
      return ((time_t )-1);
    }
    {
#line 3680
    *cp = (char )' ';
#line 3681
    hr = -1;
#line 3682
    min = -1;
#line 3683
    sscanf((char const   */* __restrict  */)(s2), (char const   */* __restrict  */)"%d%d",
           & hr, & min);
    }
#line 3684
    if (hr < 0) {
#line 3685
      return ((time_t )-1);
    } else
#line 3684
    if (min < 0) {
#line 3685
      return ((time_t )-1);
    }
    {
#line 3686
    lt.tm_hour = hr;
#line 3687
    lt.tm_min = min;
#line 3688
    when = mktime(& lt);
    }
#line 3689
    if (when == -1L) {
#line 3690
      return (when);
    } else
#line 3689
    if (when == 0L) {
#line 3690
      return (when);
    }
#line 3691
    if (when < now) {
#line 3692
      when += 86400L;
    }
  } else {
    {
#line 3694
    when = UnDate(s2);
    }
  }
#line 3696
  return (when);
}
}
#line 3701 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int SpoolCheck(void) 
{ 
  char ncftpbatch[256] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3704
  tmp___0 = CanSpool();
  }
#line 3704
  if (tmp___0 < 0) {
    {
#line 3708
    printf((char const   */* __restrict  */)"Sorry, spooling isn\'t allowed because this user requires that the NCFTPDIR\nenvironment variable be set to a directory to write datafiles to.\n");
    }
#line 3710
    return (-1);
  } else {
    {
#line 3711
    tmp = HaveSpool();
    }
#line 3711
    if (tmp == 0) {
      {
#line 3720
      Strncpy((char */* const  */)(ncftpbatch), (char const   */* const  */)"/usr/local/bin",
              (size_t const   )sizeof(ncftpbatch));
#line 3722
      Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"/", (size_t const   )sizeof(ncftpbatch));
#line 3723
      Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"ncftpbatch",
              (size_t const   )sizeof(ncftpbatch));
#line 3724
      printf((char const   */* __restrict  */)"Sorry, the \"ncftpbatch\" program could not be found.\nThis program must be installed as %s in order to use this feature.\n",
             ncftpbatch);
      }
#line 3732
      return (-1);
    }
  }
#line 3734
  return (0);
}
}
#line 3742 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void BGStartCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) 
{ 
  int i___0 ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 3747
  if (argc != 0) {
#line 3747
    tmp = 1;
  } else
#line 3747
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3747
    tmp = 1;
  } else
#line 3747
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3747
    tmp = 1;
  } else
#line 3747
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3747
    tmp = 1;
  } else {
#line 3747
    tmp = 0;
  }
  {
#line 3747
  gUnusedArg = tmp;
#line 3748
  tmp___0 = SpoolCheck();
  }
#line 3748
  if (tmp___0 < 0) {
#line 3749
    return;
  }
#line 3751
  if (argc < 2) {
    {
#line 3752
    RunBatch();
#line 3753
    printf((char const   */* __restrict  */)"Background process started.\n");
#line 3756
    printf((char const   */* __restrict  */)"Watch the \"%s/spool/log\" file to see how it is progressing.\n",
           gOurDirectoryPath);
    }
  } else {
    {
#line 3751
    n = atoi((char const   *)*(argv + 1));
    }
#line 3751
    if (n < 2) {
      {
#line 3752
      RunBatch();
#line 3753
      printf((char const   */* __restrict  */)"Background process started.\n");
#line 3756
      printf((char const   */* __restrict  */)"Watch the \"%s/spool/log\" file to see how it is progressing.\n",
             gOurDirectoryPath);
      }
    } else {
#line 3759
      i___0 = 0;
      {
#line 3759
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3759
        if (! (i___0 < n)) {
#line 3759
          goto while_break;
        }
        {
#line 3760
        RunBatch();
#line 3759
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3761
      printf((char const   */* __restrict  */)"Background processes started.\n");
#line 3764
      printf((char const   */* __restrict  */)"Watch the \"%s/spool/log\" file to see how it is progressing.\n",
             gOurDirectoryPath);
      }
    }
  }
#line 3767
  return;
}
}
#line 3771 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int BggetFtwProc(FtwInfoPtr const   ftwip ) 
{ 
  char const   *baserelpath ;
  char *curPath ;
  char *rdir ;
  char *ldir ;
  char *rdir1 ;
  char *ldir1 ;
  char *cp ;
  size_t len ;
  char *lpath ;
  char dirsep[2] ;
  int rc ;
  int toplevel ;
  SpoolCmdInfo *cinfop ;
  char preferredLocalAddrStr[64] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 3786
  preferredLocalAddrStr[0] = (char )'\000';
#line 3787
  if ((int )gConn.preferredLocalAddr.sin_family != 0) {
    {
#line 3788
    AddrToAddrStr((char */* const  */)(preferredLocalAddrStr), sizeof(preferredLocalAddrStr),
                  (struct sockaddr_in */* const  */)(& gConn.preferredLocalAddr),
                  0, "%h");
    }
  }
#line 3790
  if (ftwip->depth >= 50UL) {
    {
#line 3791
    Trace((int const   )-1, (char const   */* const  */)"Aborting -- recursion depth is %u.\nPerhaps an infinite loop exists on the remote filesystem?",
          (unsigned int )ftwip->depth);
    }
#line 3792
    return (-1);
  }
  {
#line 3795
  cinfop = (SpoolCmdInfo *)ftwip->userdata;
#line 3797
  baserelpath = (char const   *)(ftwip->curPath + cinfop->base);
#line 3798
  curPath = ftwip->curPath;
#line 3799
  tmp = strcmp((char const   *)curPath, (char const   *)(ftwip->rootDir));
  }
#line 3799
  if (tmp == 0) {
#line 3800
    return (0);
  }
  {
#line 3802
  lpath = (char *)((void *)0);
#line 3803
  dirsep[0] = (char )ftwip->dirSeparator;
#line 3804
  dirsep[1] = (char )'\000';
#line 3805
  toplevel = 0;
#line 3806
  tmp___8 = strrchr((char const   *)ftwip->curPath, '/');
  }
#line 3806
  if ((unsigned long )tmp___8 == (unsigned long )ftwip->curPath) {
#line 3806
    goto _L___2;
  } else {
    {
#line 3806
    tmp___9 = strrchr((char const   *)ftwip->curPath, '\\');
    }
#line 3806
    if ((unsigned long )tmp___9 == (unsigned long )ftwip->curPath) {
      _L___2: /* CIL Label */ 
      {
#line 3809
      toplevel = 1;
#line 3810
      tmp___0 = Dynscpy(& rdir1, gRemoteCWD, (char *)0);
      }
#line 3810
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 3811
        return (-1);
      }
      {
#line 3812
      tmp___1 = Dynscpy(& ldir1, gLocalCWD, (char *)0);
      }
#line 3812
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 3813
        return (-1);
      }
    } else
#line 3814
    if ((int )*(ftwip->curPath + 0) == 46) {
#line 3814
      if ((int )*(ftwip->curPath + 1) == 0) {
#line 3814
        goto _L___0;
      } else
#line 3814
      if ((int )*(ftwip->curPath + 1) == 47) {
#line 3814
        goto _L___1;
      } else
#line 3814
      if ((int )*(ftwip->curPath + 1) == 92) {
        _L___1: /* CIL Label */ 
        {
#line 3814
        tmp___6 = strchr((char const   *)(ftwip->curPath + 2), '/');
        }
#line 3814
        if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
          {
#line 3814
          tmp___7 = strchr((char const   *)(ftwip->curPath + 2), '\\');
          }
#line 3814
          if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
            _L___0: /* CIL Label */ 
            {
#line 3817
            toplevel = 1;
#line 3818
            tmp___2 = Dynscpy(& rdir1, gRemoteCWD, (char *)0);
            }
#line 3818
            if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3819
              return (-1);
            }
            {
#line 3820
            tmp___3 = Dynscpy(& ldir1, gLocalCWD, (char *)0);
            }
#line 3820
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 3821
              return (-1);
            }
          } else {
#line 3814
            goto _L;
          }
        } else {
#line 3814
          goto _L;
        }
      } else {
#line 3814
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 3823
      tmp___4 = Dynscpy(& rdir1, cinfop->rcwd, "/", curPath, (char *)0);
      }
#line 3823
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 3824
        return (-1);
      }
      {
#line 3825
      tmp___5 = Dynscpy(& ldir1, cinfop->lcwd, dirsep, baserelpath, (char *)0);
      }
#line 3825
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 3826
        return (-1);
      }
    }
  }
  {
#line 3829
  len = strlen((char const   *)rdir1);
#line 3830
  tmp___10 = malloc(len + 1UL);
#line 3830
  rdir = (char *)tmp___10;
  }
#line 3831
  if ((unsigned long )rdir == (unsigned long )((void *)0)) {
#line 3832
    return (-1);
  }
  {
#line 3833
  CompressPath((char */* const  */)rdir, (char const   */* const  */)rdir1, (size_t const   )(len + 1UL),
               1);
#line 3834
  StrFree(& rdir1);
#line 3835
  cp = strrchr((char const   *)rdir, '/');
  }
#line 3836
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 3836
    if ((unsigned long )cp != (unsigned long )rdir) {
#line 3836
      if (toplevel == 0) {
#line 3837
        *cp = (char )'\000';
      }
    }
  }
  {
#line 3839
  len = strlen((char const   *)ldir1);
#line 3840
  tmp___11 = malloc(len + 1UL);
#line 3840
  ldir = (char *)tmp___11;
  }
#line 3841
  if ((unsigned long )ldir == (unsigned long )((void *)0)) {
#line 3842
    return (-1);
  }
  {
#line 3843
  CompressPath((char */* const  */)ldir, (char const   */* const  */)ldir1, (size_t const   )(len + 1UL),
               0);
#line 3849
  StrFree(& ldir1);
#line 3850
  cp = strrchr((char const   *)ldir, '/');
  }
#line 3851
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 3851
    if ((unsigned long )cp != (unsigned long )ldir) {
#line 3851
      if (toplevel == 0) {
#line 3852
        *cp = (char )'\000';
      }
    }
  }
#line 3854
  if (ftwip->curType != 45) {
    {
#line 3855
    tmp___12 = Dynscpy(& lpath, ldir, "/", ftwip->curFile, (char *)0);
    }
#line 3855
    if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
#line 3856
      return (-1);
    }
    {
#line 3858
    Trace((int const   )0, (char const   */* const  */)"  // Lpath [%s] ([%s]/%s)\n",
          lpath, ldir, ftwip->curFile);
    }
  }
#line 3861
  if (ftwip->curType == 100) {
    {
#line 3865
    tmp___16 = MkDirs((char const   */* const  */)lpath, 493);
    }
#line 3865
    if (tmp___16 < 0) {
      {
#line 3867
      tmp___13 = __errno_location();
#line 3867
      tmp___14 = strerror(*tmp___13);
#line 3867
      Trace((int const   )-1, (char const   */* const  */)"  - Local Mkdir %s Failed: %s\n",
            lpath, tmp___14);
      }
    } else {
      {
#line 3871
      tmp___15 = __errno_location();
      }
#line 3871
      if (*tmp___15 != 17) {
        {
#line 3872
        Trace((int const   )0, (char const   */* const  */)"  + Mkdir %s\n", lpath);
        }
      } else {
        {
#line 3874
        Trace((int const   )0, (char const   */* const  */)"  + Mkdir %s (already existed)\n",
              lpath);
        }
      }
    }
  } else
#line 3877
  if (ftwip->curType == 108) {
#line 3879
    if ((unsigned long )ftwip->rlinkto != (unsigned long )((void *)0)) {
      {
#line 3880
      tmp___19 = symlink(ftwip->rlinkto, (char const   *)lpath);
      }
#line 3880
      if (tmp___19 == 0) {
        {
#line 3881
        Trace((int const   )0, (char const   */* const  */)"  + Linked: %s -> %s\n",
              lpath, ftwip->rlinkto);
        }
      } else {
        {
#line 3884
        tmp___17 = __errno_location();
#line 3884
        tmp___18 = strerror(*tmp___17);
#line 3884
        Trace((int const   )-1, (char const   */* const  */)"  - Link Failed: %s -> %s (%s)\n",
              lpath, ftwip->rlinkto, tmp___18);
        }
      }
    }
  } else
#line 3891
  if (ftwip->curType == 45) {
    {
#line 3893
    rc = SpoolX((FILE */* const  */)((void *)0), (char const   *)((void *)0), (char const   */* const  */)"get",
                (char const   */* const  */)ftwip->curFile, (char const   */* const  */)rdir,
                (char const   */* const  */)ftwip->curFile, (char const   */* const  */)ldir,
                (char const   */* const  */)(gConn.host), (char const   */* const  */)(gConn.ip),
                (unsigned int const   )gConn.port, (char const   */* const  */)(gConn.user),
                (char const   */* const  */)(gConn.pass), (char const   */* const  */)(gConn.acct),
                (int const   )cinfop->xtype, (int const   )0, (int const   )cinfop->deleteFlag,
                (int const   )gConn.dataPortMode, (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (time_t const   )cinfop->when, (unsigned int const   )0, (char const   */* const  */)gConn.manualOverrideFeatures,
                (char const   */* const  */)(preferredLocalAddrStr), (int const   )0);
    }
#line 3922
    if (rc == 0) {
      {
#line 3923
      Trace((int const   )-1, (char const   */* const  */)"  + Spooled: get %s/%s\n",
            rdir, ftwip->curFile);
#line 3924
      Trace((int const   )0, (char const   */* const  */)"  + Spooled: get [%s]/%s -> [%s]/%s\n",
            rdir, ftwip->curFile, ldir, ftwip->curFile);
      }
    }
  }
  {
#line 3928
  StrFree(& rdir);
#line 3929
  StrFree(& ldir);
#line 3930
  StrFree(& lpath);
  }
#line 3931
  return (0);
}
}
#line 3937 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SpoolGetCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) 
{ 
  int optrc ;
  int rc ;
  int i___0 ;
  int nD ;
  char pattern[256] ;
  char *lname ;
  char *base ;
  FTPLineList ll ;
  FTPLinePtr lp ;
  GetoptInfo opt ;
  FtwInfo ftwi ;
  SpoolCmdInfo cinfo ;
  char preferredLocalAddrStr[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3943
  nD = 0;
#line 3954
  preferredLocalAddrStr[0] = (char )'\000';
#line 3955
  if ((int )gConn.preferredLocalAddr.sin_family != 0) {
    {
#line 3956
    AddrToAddrStr((char */* const  */)(preferredLocalAddrStr), sizeof(preferredLocalAddrStr),
                  (struct sockaddr_in */* const  */)(& gConn.preferredLocalAddr),
                  0, "%h");
    }
  }
  {
#line 3958
  cinfo.xtype = gBm.xferType;
#line 3959
  cinfo.deleteFlag = 0;
#line 3960
  cinfo.recurseFlag = 0;
#line 3961
  cinfo.renameMode = 0;
#line 3962
  cinfo.when = (time_t )0;
#line 3963
  cinfo.base = 0;
#line 3965
  Trace((int const   )0, (char const   */* const  */)"Local CWD is: %s\n", gLocalCWD);
#line 3966
  Trace((int const   )0, (char const   */* const  */)"Remote CWD is: %s\n", gRemoteCWD);
#line 3968
  cinfo.rcwd = (char const   *)(gRemoteCWD);
  }
#line 3969
  if ((int const   )*(cinfo.rcwd + 0) == 47) {
#line 3969
    goto _L;
  } else
#line 3969
  if ((int const   )*(cinfo.rcwd + 0) == 92) {
    _L: /* CIL Label */ 
#line 3969
    if ((int const   )*(cinfo.rcwd + 1) == 0) {
#line 3970
      (cinfo.rcwd) ++;
    }
  }
  {
#line 3972
  cinfo.lcwd = (char const   *)(gLocalCWD);
#line 3973
  tmp = strcmp(cinfo.lcwd, "/");
  }
#line 3973
  if (tmp == 0) {
#line 3974
    (cinfo.lcwd) ++;
  }
#line 3976
  if (argc != 0) {
#line 3976
    tmp___0 = 1;
  } else
#line 3976
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 3976
    tmp___0 = 1;
  } else
#line 3976
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 3976
    tmp___0 = 1;
  } else
#line 3976
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 3976
    tmp___0 = 1;
  } else {
#line 3976
    tmp___0 = 0;
  }
#line 3976
  gUnusedArg = tmp___0;
#line 3978
  if (gSavePasswords <= 0) {
    {
#line 3978
    tmp___2 = strcmp((char const   *)(gConn.user), "anonymous");
    }
#line 3978
    if (tmp___2 != 0) {
      {
#line 3978
      tmp___3 = strcmp((char const   *)(gConn.user), "ftp");
      }
#line 3978
      if (tmp___3 != 0) {
        {
#line 3979
        printf((char const   */* __restrict  */)"Sorry, spooling isn\'t allowed when you\'re not logged in anonymously, because\nthe spool files would need to save your password.\n\nYou can override this by doing a \"set save-passwords yes\" if you\'re willing\nto live with the consequences.\n");
        }
#line 3980
        return;
      } else {
#line 3978
        goto _L___0;
      }
    } else {
#line 3978
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3981
    tmp___1 = SpoolCheck();
    }
#line 3981
    if (tmp___1 < 0) {
#line 3982
      return;
    }
  }
  {
#line 3985
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 3986
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3986
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"@:azfrRD");
    }
#line 3986
    if (! (optrc >= 0)) {
#line 3986
      goto while_break;
    }
    {
#line 3987
    if (optrc == 64) {
#line 3987
      goto case_64;
    }
#line 3994
    if (optrc == 97) {
#line 3994
      goto case_97;
    }
#line 3997
    if (optrc == 122) {
#line 3997
      goto case_122;
    }
#line 4005
    if (optrc == 68) {
#line 4005
      goto case_68;
    }
#line 4015
    if (optrc == 82) {
#line 4015
      goto case_82;
    }
#line 4015
    if (optrc == 114) {
#line 4015
      goto case_82;
    }
#line 4021
    goto switch_default;
    case_64: /* CIL Label */ 
    {
#line 3988
    cinfo.when = GetStartSpoolDate((char const   *)opt.arg);
    }
#line 3989
    if (cinfo.when == -1L) {
      {
#line 3990
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad date.  It must be expressed as one of the following:\n\tYYYYMMDDHHMMSS\t\n\t\"now + N hours|min|sec|days\"\n\tHH:MM\n\nNote:  Do not forget to quote the entire argument for the offset option.\nExample:  bgget -@ \"now + 15 min\" ...\n");
      }
#line 3991
      return;
    } else
#line 3989
    if (cinfo.when == 0L) {
      {
#line 3990
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad date.  It must be expressed as one of the following:\n\tYYYYMMDDHHMMSS\t\n\t\"now + N hours|min|sec|days\"\n\tHH:MM\n\nNote:  Do not forget to quote the entire argument for the offset option.\nExample:  bgget -@ \"now + 15 min\" ...\n");
      }
#line 3991
      return;
    }
#line 3993
    goto switch_break;
    case_97: /* CIL Label */ 
#line 3995
    cinfo.xtype = 'A';
#line 3996
    goto switch_break;
    case_122: /* CIL Label */ 
#line 4003
    cinfo.renameMode = 1;
#line 4004
    goto switch_break;
    case_68: /* CIL Label */ 
#line 4012
    nD ++;
#line 4013
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 4019
    cinfo.recurseFlag = 1;
#line 4020
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 4022
    PrintCmdUsage((CommandPtr )cmdp);
    }
#line 4023
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4026
  if (nD >= 2) {
#line 4027
    cinfo.deleteFlag = 1;
  }
#line 4029
  if (cinfo.renameMode != 0) {
#line 4030
    if (opt.ind > (int )(argc - 2)) {
      {
#line 4031
      PrintCmdUsage((CommandPtr )cmdp);
      }
#line 4032
      return;
    }
    {
#line 4034
    rc = SpoolX((FILE */* const  */)((void *)0), (char const   *)((void *)0), (char const   */* const  */)"get",
                (char const   */* const  */)*(argv + opt.ind), (char const   */* const  */)(gRemoteCWD),
                (char const   */* const  */)*(argv + (opt.ind + 1)), (char const   */* const  */)(gLocalCWD),
                (char const   */* const  */)(gConn.host), (char const   */* const  */)(gConn.ip),
                (unsigned int const   )gConn.port, (char const   */* const  */)(gConn.user),
                (char const   */* const  */)(gConn.pass), (char const   */* const  */)(gConn.acct),
                (int const   )cinfo.xtype, (int const   )0, (int const   )cinfo.deleteFlag,
                (int const   )gConn.dataPortMode, (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (time_t const   )cinfo.when, (unsigned int const   )0, (char const   */* const  */)gConn.manualOverrideFeatures,
                (char const   */* const  */)(preferredLocalAddrStr), (int const   )0);
    }
#line 4063
    if (rc == 0) {
      {
#line 4064
      Trace((int const   )-1, (char const   */* const  */)"  + Spooled: get %s as %s\n",
            *(argv + opt.ind), *(argv + (opt.ind + 1)));
      }
    }
#line 4066
    return;
  }
#line 4069
  if (cinfo.recurseFlag == 1) {
    {
#line 4070
    FtwInit((FtwInfo */* const  */)(& ftwi));
#line 4071
    ftwi.userdata = (void *)(& cinfo);
    }
  }
#line 4074
  i___0 = opt.ind;
  {
#line 4074
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4074
    if (! (i___0 < (int )argc)) {
#line 4074
      goto while_break___0;
    }
    {
#line 4075
    Strncpy((char */* const  */)(pattern), (char const   */* const  */)*(argv + i___0),
            (size_t const   )sizeof(pattern));
#line 4076
    StrRemoveTrailingSlashes(pattern);
#line 4077
    InitLineList(& ll);
    }
#line 4078
    if (aip->noglobargv[i___0] != 0) {
#line 4078
      tmp___4 = 0;
    } else {
#line 4078
      tmp___4 = 1;
    }
    {
#line 4078
    rc = FTPRemoteGlob(& gConn, & ll, (char const   *)(pattern), tmp___4);
    }
#line 4079
    if (rc < 0) {
      {
#line 4080
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-151,
                (char const   */* const  */)*(argv + 0), (char const   */* const  */)(pattern));
      }
#line 4081
      goto done;
    }
#line 4083
    lp = ll.first;
    {
#line 4083
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4083
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
#line 4083
        if (! ((unsigned long )lp->line != (unsigned long )((void *)0))) {
#line 4083
          goto while_break___1;
        }
      } else {
#line 4083
        goto while_break___1;
      }
#line 4084
      if (cinfo.recurseFlag == 0) {
        {
#line 4085
        lname = strrchr((char const   *)lp->line, '/');
        }
#line 4086
        if ((unsigned long )lname == (unsigned long )((void *)0)) {
#line 4087
          lname = lp->line;
        } else {
#line 4089
          lname ++;
        }
        {
#line 4090
        rc = SpoolX((FILE */* const  */)((void *)0), (char const   *)((void *)0),
                    (char const   */* const  */)"get", (char const   */* const  */)lp->line,
                    (char const   */* const  */)(gRemoteCWD), (char const   */* const  */)lname,
                    (char const   */* const  */)(gLocalCWD), (char const   */* const  */)(gConn.host),
                    (char const   */* const  */)(gConn.ip), (unsigned int const   )gConn.port,
                    (char const   */* const  */)(gConn.user), (char const   */* const  */)(gConn.pass),
                    (char const   */* const  */)(gConn.acct), (int const   )cinfo.xtype,
                    (int const   )cinfo.recurseFlag, (int const   )cinfo.deleteFlag,
                    (int const   )gConn.dataPortMode, (char const   */* const  */)((void *)0),
                    (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                    (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                    (time_t const   )cinfo.when, (unsigned int const   )0, (char const   */* const  */)gConn.manualOverrideFeatures,
                    (char const   */* const  */)(preferredLocalAddrStr), (int const   )0);
        }
#line 4119
        if (rc == 0) {
          {
#line 4120
          Trace((int const   )-1, (char const   */* const  */)"  + Spooled: get %s\n",
                lp->line);
          }
        }
      } else {
        {
#line 4123
        base = strrchr((char const   *)lp->line, '/');
        }
#line 4124
        if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 4125
          cinfo.base = 0;
        } else
#line 4126
        if ((unsigned long )base == (unsigned long )lp->line) {
#line 4127
          cinfo.base = 0;
        } else {
#line 4129
          base ++;
#line 4130
          cinfo.base = (int )(base - lp->line);
        }
        {
#line 4132
        rc = FTPFtw((FTPCIPtr const   )(& gConn), (FtwInfoPtr const   )(& ftwi), (char const   */* const  */)lp->line,
                    & BggetFtwProc);
        }
#line 4132
        if (rc != 0) {
          {
#line 4133
          FTPPerror((FTPCIPtr const   )(& gConn), (int const   )gConn.errNo, (int const   )-125,
                    (char const   */* const  */)lp->line, (char const   */* const  */)"Could not traverse directory");
          }
        }
      }
#line 4083
      lp = lp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4137
    DisposeLineListContents(& ll);
#line 4074
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
#line 4140
  if (cinfo.recurseFlag == 1) {
    {
#line 4141
    FtwDispose((FtwInfo */* const  */)(& ftwi));
    }
  }
#line 4142
  return;
}
}
#line 4146 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
static int BgputFtwProc(FtwInfoPtr const   ftwip ) 
{ 
  char const   *basererpath ;
  char *curPath ;
  char *rdir ;
  char *ldir ;
  char *rdir1 ;
  char *ldir1 ;
  char *cp ;
  size_t len ;
  char *rpath ;
  char dirsep[2] ;
  int rc ;
  int toplevel ;
  SpoolCmdInfo *cinfop ;
  char errStr[128] ;
  char preferredLocalAddrStr[64] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
#line 4162
  preferredLocalAddrStr[0] = (char )'\000';
#line 4163
  if ((int )gConn.preferredLocalAddr.sin_family != 0) {
    {
#line 4164
    AddrToAddrStr((char */* const  */)(preferredLocalAddrStr), sizeof(preferredLocalAddrStr),
                  (struct sockaddr_in */* const  */)(& gConn.preferredLocalAddr),
                  0, "%h");
    }
  }
  {
#line 4166
  cinfop = (SpoolCmdInfo *)ftwip->userdata;
#line 4168
  basererpath = (char const   *)(ftwip->curPath + cinfop->base);
#line 4169
  curPath = ftwip->curPath;
#line 4170
  tmp = strcmp((char const   *)curPath, (char const   *)(ftwip->rootDir));
  }
#line 4170
  if (tmp == 0) {
#line 4171
    return (0);
  }
  {
#line 4173
  rpath = (char *)((void *)0);
#line 4174
  dirsep[0] = (char )ftwip->dirSeparator;
#line 4175
  dirsep[1] = (char )'\000';
#line 4176
  toplevel = 0;
#line 4177
  tmp___9 = strrchr((char const   *)ftwip->curPath, '/');
  }
#line 4177
  if ((unsigned long )tmp___9 == (unsigned long )ftwip->curPath) {
#line 4177
    goto _L___2;
  } else {
    {
#line 4177
    tmp___10 = strrchr((char const   *)ftwip->curPath, '\\');
    }
#line 4177
    if ((unsigned long )tmp___10 == (unsigned long )ftwip->curPath) {
      _L___2: /* CIL Label */ 
      {
#line 4180
      toplevel = 1;
#line 4181
      tmp___0 = Dynscpy(& rdir1, gRemoteCWD, (char *)0);
      }
#line 4181
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 4182
        return (-1);
      }
      {
#line 4183
      tmp___1 = Dynscpy(& ldir1, gLocalCWD, (char *)0);
      }
#line 4183
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 4184
        return (-1);
      }
    } else
#line 4185
    if ((int )*(ftwip->curPath + 0) == 46) {
#line 4185
      if ((int )*(ftwip->curPath + 1) == 0) {
#line 4185
        goto _L___0;
      } else
#line 4185
      if ((int )*(ftwip->curPath + 1) == 47) {
#line 4185
        goto _L___1;
      } else
#line 4185
      if ((int )*(ftwip->curPath + 1) == 92) {
        _L___1: /* CIL Label */ 
        {
#line 4185
        tmp___7 = strchr((char const   *)(ftwip->curPath + 2), '/');
        }
#line 4185
        if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
          {
#line 4185
          tmp___8 = strchr((char const   *)(ftwip->curPath + 2), '\\');
          }
#line 4185
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
            _L___0: /* CIL Label */ 
            {
#line 4188
            toplevel = 1;
#line 4189
            tmp___2 = Dynscpy(& rdir1, gRemoteCWD, (char *)0);
            }
#line 4189
            if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 4190
              return (-1);
            }
            {
#line 4191
            tmp___3 = Dynscpy(& ldir1, gLocalCWD, (char *)0);
            }
#line 4191
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 4192
              return (-1);
            }
          } else {
#line 4185
            goto _L;
          }
        } else {
#line 4185
          goto _L;
        }
      } else {
#line 4185
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4194
      if ((int )*(curPath + 0) == 47) {
        {
#line 4195
        tmp___4 = Dynscpy(& ldir1, curPath, (char *)0);
        }
#line 4195
        if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 4196
          return (-1);
        }
      } else {
        {
#line 4198
        tmp___5 = Dynscpy(& ldir1, cinfop->lcwd, "/", curPath, (char *)0);
        }
#line 4198
        if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 4199
          return (-1);
        }
      }
      {
#line 4201
      tmp___6 = Dynscpy(& rdir1, cinfop->rcwd, dirsep, basererpath, (char *)0);
      }
#line 4201
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 4202
        return (-1);
      }
    }
  }
  {
#line 4205
  len = strlen((char const   *)rdir1);
#line 4206
  tmp___11 = malloc(len + 1UL);
#line 4206
  rdir = (char *)tmp___11;
  }
#line 4207
  if ((unsigned long )rdir == (unsigned long )((void *)0)) {
#line 4208
    return (-1);
  }
  {
#line 4209
  CompressPath((char */* const  */)rdir, (char const   */* const  */)rdir1, (size_t const   )(len + 1UL),
               1);
#line 4210
  StrFree(& rdir1);
#line 4211
  cp = strrchr((char const   *)rdir, '/');
  }
#line 4212
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 4212
    if ((unsigned long )cp != (unsigned long )rdir) {
#line 4212
      if (toplevel == 0) {
#line 4213
        *cp = (char )'\000';
      }
    }
  }
  {
#line 4215
  len = strlen((char const   *)ldir1);
#line 4216
  tmp___12 = malloc(len + 1UL);
#line 4216
  ldir = (char *)tmp___12;
  }
#line 4217
  if ((unsigned long )ldir == (unsigned long )((void *)0)) {
#line 4218
    return (-1);
  }
  {
#line 4219
  CompressPath((char */* const  */)ldir, (char const   */* const  */)ldir1, (size_t const   )(len + 1UL),
               0);
#line 4225
  StrFree(& ldir1);
#line 4226
  cp = strrchr((char const   *)ldir, '/');
  }
#line 4227
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 4227
    if ((unsigned long )cp != (unsigned long )ldir) {
#line 4227
      if (toplevel == 0) {
#line 4228
        *cp = (char )'\000';
      }
    }
  }
#line 4230
  if (ftwip->curType != 45) {
    {
#line 4231
    tmp___13 = Dynscpy(& rpath, rdir, "/", ftwip->curFile, (char *)0);
    }
#line 4231
    if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
#line 4232
      return (-1);
    }
    {
#line 4234
    Trace((int const   )0, (char const   */* const  */)"  // Rpath [%s] ([%s]/%s)\n",
          rpath, rdir, ftwip->curFile);
    }
  }
#line 4237
  if (ftwip->curType == 100) {
    {
#line 4241
    rc = FTPMkdir((FTPCIPtr const   )(& gConn), (char const   */* const  */)rpath,
                  (int const   )1);
    }
#line 4241
    if (rc < 0) {
      {
#line 4242
      tmp___14 = FTPStrError2((FTPCIPtr const   )(& gConn), gConn.errNo, (char */* const  */)(errStr),
                              (size_t const   )sizeof(errStr), -140);
#line 4242
      Trace((int const   )-1, (char const   */* const  */)"  - Remote Mkdir %s Failed: %s\n",
            rpath, tmp___14);
      }
#line 4243
      goto done;
    } else {
      {
#line 4245
      Trace((int const   )0, (char const   */* const  */)"  + Mkdir %s\n", rpath);
      }
    }
  } else
#line 4248
  if (ftwip->curType == 108) {
#line 4250
    if ((unsigned long )ftwip->rlinkto != (unsigned long )((void *)0)) {
      {
#line 4251
      tmp___16 = FTPSymlink((FTPCIPtr const   )(& gConn), (char const   */* const  */)ftwip->rlinkto,
                            (char const   */* const  */)rpath);
      }
#line 4251
      if (tmp___16 == 0) {
        {
#line 4252
        Trace((int const   )0, (char const   */* const  */)"  + Linked: %s -> %s\n",
              rpath, ftwip->rlinkto);
        }
      } else {
        {
#line 4254
        tmp___15 = FTPStrError2((FTPCIPtr const   )(& gConn), gConn.errNo, (char */* const  */)(errStr),
                                (size_t const   )sizeof(errStr), -170);
#line 4254
        Trace((int const   )-1, (char const   */* const  */)"  - Link Failed: %s -> %s (%s)\n",
              rpath, ftwip->rlinkto, tmp___15);
        }
      }
    }
  } else
#line 4258
  if (ftwip->curType == 45) {
    {
#line 4260
    rc = SpoolX((FILE */* const  */)((void *)0), (char const   *)((void *)0), (char const   */* const  */)"put",
                (char const   */* const  */)ftwip->curFile, (char const   */* const  */)rdir,
                (char const   */* const  */)ftwip->curFile, (char const   */* const  */)ldir,
                (char const   */* const  */)(gConn.host), (char const   */* const  */)(gConn.ip),
                (unsigned int const   )gConn.port, (char const   */* const  */)(gConn.user),
                (char const   */* const  */)(gConn.pass), (char const   */* const  */)(gConn.acct),
                (int const   )cinfop->xtype, (int const   )0, (int const   )cinfop->deleteFlag,
                (int const   )gConn.dataPortMode, (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (time_t const   )cinfop->when, (unsigned int const   )0, (char const   */* const  */)gConn.manualOverrideFeatures,
                (char const   */* const  */)(preferredLocalAddrStr), (int const   )0);
    }
#line 4289
    if (rc == 0) {
      {
#line 4290
      Trace((int const   )-1, (char const   */* const  */)"  + Spooled: put %s/%s\n",
            ldir, ftwip->curFile);
#line 4291
      Trace((int const   )0, (char const   */* const  */)"  + Spooled: put [%s]/%s -> [%s]/%s\n",
            ldir, ftwip->curFile, rdir, ftwip->curFile);
      }
    }
  }
#line 4294
  rc = 0;
  done: 
  {
#line 4296
  StrFree(& rdir);
#line 4297
  StrFree(& ldir);
#line 4298
  StrFree(& rpath);
  }
#line 4299
  return (rc);
}
}
#line 4306 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SpoolPutCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                 ArgvInfoPtr const   aip ) 
{ 
  int optrc ;
  int rc ;
  int i___0 ;
  int nD ;
  char pattern[256] ;
  FTPLineList ll ;
  FTPLinePtr lp ;
  char *rname ;
  char *base ;
  GetoptInfo opt ;
  FtwInfo ftwi ;
  SpoolCmdInfo cinfo ;
  char preferredLocalAddrStr[64] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 4312
  nD = 0;
#line 4323
  preferredLocalAddrStr[0] = (char )'\000';
#line 4324
  if ((int )gConn.preferredLocalAddr.sin_family != 0) {
    {
#line 4325
    AddrToAddrStr((char */* const  */)(preferredLocalAddrStr), sizeof(preferredLocalAddrStr),
                  (struct sockaddr_in */* const  */)(& gConn.preferredLocalAddr),
                  0, "%h");
    }
  }
  {
#line 4327
  cinfo.xtype = gBm.xferType;
#line 4328
  cinfo.deleteFlag = 0;
#line 4329
  cinfo.recurseFlag = 0;
#line 4330
  cinfo.renameMode = 0;
#line 4331
  cinfo.when = (time_t )0;
#line 4332
  cinfo.base = 0;
#line 4334
  Trace((int const   )0, (char const   */* const  */)"Local CWD is: %s\n", gLocalCWD);
#line 4335
  Trace((int const   )0, (char const   */* const  */)"Remote CWD is: %s\n", gRemoteCWD);
#line 4337
  cinfo.rcwd = (char const   *)(gRemoteCWD);
  }
#line 4338
  if ((int const   )*(cinfo.rcwd + 0) == 47) {
#line 4338
    goto _L;
  } else
#line 4338
  if ((int const   )*(cinfo.rcwd + 0) == 92) {
    _L: /* CIL Label */ 
#line 4338
    if ((int const   )*(cinfo.rcwd + 1) == 0) {
#line 4339
      (cinfo.rcwd) ++;
    }
  }
  {
#line 4341
  cinfo.lcwd = (char const   *)(gLocalCWD);
#line 4342
  tmp = strcmp(cinfo.lcwd, "/");
  }
#line 4342
  if (tmp == 0) {
#line 4343
    (cinfo.lcwd) ++;
  }
#line 4345
  if (argc != 0) {
#line 4345
    tmp___0 = 1;
  } else
#line 4345
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 4345
    tmp___0 = 1;
  } else
#line 4345
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 4345
    tmp___0 = 1;
  } else
#line 4345
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 4345
    tmp___0 = 1;
  } else {
#line 4345
    tmp___0 = 0;
  }
#line 4345
  gUnusedArg = tmp___0;
#line 4347
  if (gSavePasswords <= 0) {
    {
#line 4347
    tmp___2 = strcmp((char const   *)(gConn.user), "anonymous");
    }
#line 4347
    if (tmp___2 != 0) {
      {
#line 4347
      tmp___3 = strcmp((char const   *)(gConn.user), "ftp");
      }
#line 4347
      if (tmp___3 != 0) {
        {
#line 4348
        printf((char const   */* __restrict  */)"Sorry, spooling isn\'t allowed when you\'re not logged in anonymously, because\nthe spool files would need to save your password.\n\nYou can override this by doing a \"set save-passwords yes\" if you\'re willing\nto live with the consequences.\n");
        }
#line 4349
        return;
      } else {
#line 4347
        goto _L___0;
      }
    } else {
#line 4347
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 4350
    tmp___1 = SpoolCheck();
    }
#line 4350
    if (tmp___1 < 0) {
#line 4351
      return;
    }
  }
  {
#line 4354
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 4355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4355
    optrc = Getopt((GetoptInfo */* const  */)(& opt), (int )argc, argv, (char const   */* const  */)"@:azrRD");
    }
#line 4355
    if (! (optrc >= 0)) {
#line 4355
      goto while_break;
    }
    {
#line 4356
    if (optrc == 64) {
#line 4356
      goto case_64;
    }
#line 4363
    if (optrc == 97) {
#line 4363
      goto case_97;
    }
#line 4366
    if (optrc == 122) {
#line 4366
      goto case_122;
    }
#line 4374
    if (optrc == 68) {
#line 4374
      goto case_68;
    }
#line 4384
    if (optrc == 82) {
#line 4384
      goto case_82;
    }
#line 4384
    if (optrc == 114) {
#line 4384
      goto case_82;
    }
#line 4390
    goto switch_default;
    case_64: /* CIL Label */ 
    {
#line 4357
    cinfo.when = GetStartSpoolDate((char const   *)opt.arg);
    }
#line 4358
    if (cinfo.when == -1L) {
      {
#line 4359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad date.  It must be expressed as one of the following:\n\tYYYYMMDDHHMMSS\t\n\t\"now + N hours|min|sec|days\"\n\tHH:MM\n\nNote:  Do not forget to quote the entire argument for the offset option.\nExample:  bgget -@ \"now + 15 min\" ...\n");
      }
#line 4360
      return;
    } else
#line 4358
    if (cinfo.when == 0L) {
      {
#line 4359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad date.  It must be expressed as one of the following:\n\tYYYYMMDDHHMMSS\t\n\t\"now + N hours|min|sec|days\"\n\tHH:MM\n\nNote:  Do not forget to quote the entire argument for the offset option.\nExample:  bgget -@ \"now + 15 min\" ...\n");
      }
#line 4360
      return;
    }
#line 4362
    goto switch_break;
    case_97: /* CIL Label */ 
#line 4364
    cinfo.xtype = 'A';
#line 4365
    goto switch_break;
    case_122: /* CIL Label */ 
#line 4372
    cinfo.renameMode = 1;
#line 4373
    goto switch_break;
    case_68: /* CIL Label */ 
#line 4381
    nD ++;
#line 4382
    goto switch_break;
    case_82: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 4388
    cinfo.recurseFlag = 1;
#line 4389
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 4391
    PrintCmdUsage((CommandPtr )cmdp);
    }
#line 4392
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4395
  if (nD >= 2) {
#line 4396
    cinfo.deleteFlag = 1;
  }
#line 4398
  if (cinfo.renameMode != 0) {
#line 4399
    if (opt.ind > (int )(argc - 2)) {
      {
#line 4400
      PrintCmdUsage((CommandPtr )cmdp);
      }
#line 4401
      return;
    }
    {
#line 4403
    rc = SpoolX((FILE */* const  */)((void *)0), (char const   *)((void *)0), (char const   */* const  */)"put",
                (char const   */* const  */)*(argv + (opt.ind + 1)), (char const   */* const  */)(gRemoteCWD),
                (char const   */* const  */)*(argv + opt.ind), (char const   */* const  */)(gLocalCWD),
                (char const   */* const  */)(gConn.host), (char const   */* const  */)(gConn.ip),
                (unsigned int const   )gConn.port, (char const   */* const  */)(gConn.user),
                (char const   */* const  */)(gConn.pass), (char const   */* const  */)(gConn.acct),
                (int const   )cinfo.xtype, (int const   )0, (int const   )cinfo.deleteFlag,
                (int const   )gConn.dataPortMode, (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                (time_t const   )cinfo.when, (unsigned int const   )0, (char const   */* const  */)gConn.manualOverrideFeatures,
                (char const   */* const  */)(preferredLocalAddrStr), (int const   )0);
    }
#line 4432
    if (rc == 0) {
      {
#line 4433
      Trace((int const   )-1, (char const   */* const  */)"  + Spooled: put %s as %s\n",
            *(argv + opt.ind), *(argv + (opt.ind + 1)));
      }
    }
#line 4435
    return;
  }
#line 4438
  if (cinfo.recurseFlag == 1) {
    {
#line 4439
    FtwInit((FtwInfo */* const  */)(& ftwi));
#line 4440
    ftwi.userdata = (void *)(& cinfo);
    }
  }
#line 4443
  i___0 = opt.ind;
  {
#line 4443
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4443
    if (! (i___0 < (int )argc)) {
#line 4443
      goto while_break___0;
    }
    {
#line 4444
    Strncpy((char */* const  */)(pattern), (char const   */* const  */)*(argv + i___0),
            (size_t const   )sizeof(pattern));
#line 4445
    StrRemoveTrailingSlashes(pattern);
#line 4446
    InitLineList(& ll);
    }
#line 4447
    if (aip->noglobargv[i___0] != 0) {
#line 4447
      tmp___4 = 0;
    } else {
#line 4447
      tmp___4 = 1;
    }
    {
#line 4447
    rc = FTPLocalGlob(& gConn, & ll, (char const   *)(pattern), tmp___4);
    }
#line 4448
    if (rc < 0) {
      {
#line 4449
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )rc, (int const   )-151,
                (char const   */* const  */)"local glob", (char const   */* const  */)(pattern));
      }
#line 4450
      return;
    }
#line 4452
    lp = ll.first;
    {
#line 4452
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4452
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
#line 4452
        if (! ((unsigned long )lp->line != (unsigned long )((void *)0))) {
#line 4452
          goto while_break___1;
        }
      } else {
#line 4452
        goto while_break___1;
      }
#line 4453
      if (cinfo.recurseFlag == 0) {
        {
#line 4454
        rname = strrchr((char const   *)lp->line, '/');
        }
#line 4455
        if ((unsigned long )rname == (unsigned long )((void *)0)) {
#line 4456
          rname = lp->line;
        } else {
#line 4458
          rname ++;
        }
        {
#line 4459
        rc = SpoolX((FILE */* const  */)((void *)0), (char const   *)((void *)0),
                    (char const   */* const  */)"put", (char const   */* const  */)rname,
                    (char const   */* const  */)(gRemoteCWD), (char const   */* const  */)lp->line,
                    (char const   */* const  */)(gLocalCWD), (char const   */* const  */)(gConn.host),
                    (char const   */* const  */)(gConn.ip), (unsigned int const   )gConn.port,
                    (char const   */* const  */)(gConn.user), (char const   */* const  */)(gConn.pass),
                    (char const   */* const  */)(gConn.acct), (int const   )cinfo.xtype,
                    (int const   )cinfo.recurseFlag, (int const   )cinfo.deleteFlag,
                    (int const   )gConn.dataPortMode, (char const   */* const  */)((void *)0),
                    (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                    (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                    (time_t const   )cinfo.when, (unsigned int const   )0, (char const   */* const  */)gConn.manualOverrideFeatures,
                    (char const   */* const  */)(preferredLocalAddrStr), (int const   )0);
        }
#line 4488
        if (rc == 0) {
          {
#line 4489
          Trace((int const   )-1, (char const   */* const  */)"  + Spooled: put %s\n",
                lp->line);
          }
        }
      } else {
        {
#line 4492
        base = strrchr((char const   *)lp->line, '/');
        }
#line 4493
        if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 4494
          cinfo.base = 0;
        } else
#line 4495
        if ((unsigned long )base == (unsigned long )lp->line) {
#line 4496
          cinfo.base = 0;
        } else {
#line 4498
          base ++;
#line 4499
          cinfo.base = (int )(base - lp->line);
        }
        {
#line 4501
        rc = Ftw((FtwInfo */* const  */)(& ftwi), (char const   */* const  */)lp->line,
                 & BgputFtwProc);
        }
#line 4501
        if (rc != 0) {
          {
#line 4503
          tmp___5 = __errno_location();
#line 4503
          tmp___6 = strerror(*tmp___5);
#line 4503
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not traverse directory %s: %s\n",
                  lp->line, tmp___6);
          }
        }
      }
#line 4452
      lp = lp->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4510
    DisposeLineListContents(& ll);
#line 4443
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4512
  return;
}
}
#line 4518 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void SymlinkCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int tmp ;

  {
#line 4523
  if (argc != 0) {
#line 4523
    tmp = 1;
  } else
#line 4523
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 4523
    tmp = 1;
  } else
#line 4523
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 4523
    tmp = 1;
  } else
#line 4523
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 4523
    tmp = 1;
  } else {
#line 4523
    tmp = 0;
  }
  {
#line 4523
  gUnusedArg = tmp;
#line 4524
  result = FTPSymlink((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + 1),
                      (char const   */* const  */)*(argv + 2));
  }
#line 4525
  if (result < 0) {
    {
#line 4526
    FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-170,
              (char const   */* const  */)"symlink", (char const   */* const  */)*(argv + 1));
    }
  }
  {
#line 4529
  FlushLsCache();
  }
#line 4530
  return;
}
}
#line 4536 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void TypeCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int c ;
  int result ;
  char const   *cs ;
  int tmp ;

  {
#line 4543
  if (argc != 0) {
#line 4543
    tmp = 1;
  } else
#line 4543
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 4543
    tmp = 1;
  } else
#line 4543
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 4543
    tmp = 1;
  } else
#line 4543
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 4543
    tmp = 1;
  } else {
#line 4543
    tmp = 0;
  }
#line 4543
  gUnusedArg = tmp;
#line 4544
  if (argc < 2) {
#line 4545
    c = (int )*(*(argv + 0) + 0);
#line 4546
    if (c == 116) {
#line 4547
      if (gBm.xferType == 65) {
#line 4548
        c = 'A';
#line 4549
        cs = "ASCII";
      } else
#line 4550
      if (gBm.xferType == 69) {
#line 4551
        c = 'E';
#line 4552
        cs = "EBCDIC";
      } else {
#line 4554
        c = 'I';
#line 4555
        cs = "binary/image";
      }
      {
#line 4557
      Trace((int const   )-1, (char const   */* const  */)"Type is %c (%s).\n", c,
            cs);
      }
    } else {
      {
#line 4559
      result = FTPSetTransferType((FTPCIPtr const   )(& gConn), c);
      }
#line 4560
      if (result < 0) {
        {
#line 4561
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-147,
                  (char const   */* const  */)"Type", (char const   */* const  */)*(argv + 1));
        }
      } else {
#line 4563
        gBm.xferType = gConn.curTransferType;
      }
    }
  } else {
    {
#line 4567
    c = (int )*(*(argv + 1) + 0);
#line 4568
    result = FTPSetTransferType((FTPCIPtr const   )(& gConn), c);
    }
#line 4569
    if (result < 0) {
      {
#line 4570
      FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-147,
                (char const   */* const  */)"Type", (char const   */* const  */)*(argv + 1));
      }
    } else {
#line 4572
      gBm.xferType = gConn.curTransferType;
    }
  }
#line 4575
  return;
}
}
#line 4581 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void UmaskCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp , ArgvInfoPtr const   aip ) 
{ 
  int result ;
  int tmp ;

  {
#line 4586
  if (argc != 0) {
#line 4586
    tmp = 1;
  } else
#line 4586
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 4586
    tmp = 1;
  } else
#line 4586
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 4586
    tmp = 1;
  } else
#line 4586
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 4586
    tmp = 1;
  } else {
#line 4586
    tmp = 0;
  }
  {
#line 4586
  gUnusedArg = tmp;
#line 4587
  result = FTPUmask((FTPCIPtr const   )(& gConn), (char const   */* const  */)*(argv + 1));
  }
#line 4588
  if (result < 0) {
    {
#line 4589
    FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-143,
              (char const   */* const  */)"umask", (char const   */* const  */)*(argv + 1));
    }
  }
#line 4590
  return;
}
}
#line 4596 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmds.c"
void VersionCmd(int const   argc , char ** const  argv , CommandPtr const   cmdp ,
                ArgvInfoPtr const   aip ) 
{ 
  int tmp ;

  {
#line 4599
  if (argc != 0) {
#line 4599
    tmp = 1;
  } else
#line 4599
  if ((unsigned long )argv != (unsigned long )((char **/* const  */)0)) {
#line 4599
    tmp = 1;
  } else
#line 4599
  if ((unsigned long )cmdp != (unsigned long )((CommandPtr const   )0)) {
#line 4599
    tmp = 1;
  } else
#line 4599
  if ((unsigned long )aip != (unsigned long )((ArgvInfoPtr const   )0)) {
#line 4599
    tmp = 1;
  } else {
#line 4599
    tmp = 0;
  }
  {
#line 4599
  gUnusedArg = tmp;
#line 4600
  printf((char const   */* __restrict  */)"Version:          %s\n", gVersion + 5);
#line 4601
  printf((char const   */* __restrict  */)"Author:           Mike Gleason (http://www.NcFTP.com/ncftp/)\n");
#line 4603
  printf((char const   */* __restrict  */)"Archived at:      ftp://ftp.NcFTP.com/ncftp/\n");
#line 4605
  printf((char const   */* __restrict  */)"Library Version:  %s\n", gLibNcFTPVersion + 5);
#line 4607
  printf((char const   */* __restrict  */)"Compile Date:     %s\n", "Mar  3 2016");
  }
#line 4609
  if ((int )gOS[0] != 0) {
    {
#line 4610
    printf((char const   */* __restrict  */)"Platform:         %s\n", gOS);
    }
  }
#line 4611
  return;
}
}
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SWrite.c"
int SWrite(int sfd , char const   * const  buf0 , size_t size , int tlen , int swopts ) 
{ 
  char const   *buf ;
  ssize_t nwrote ;
  size_t nleft ;
  int tleft ;
  time_t done ;
  time_t now ;
  fd_set ss ;
  struct timeval tv ;
  int result ;
  int firstSelect ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int __d0 ;
  int __d1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 9
  buf = (char const   *)buf0;
#line 17
  sigpipe = (void (*)(int  ))0;
#line 19
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (size == 0UL) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  } else
#line 19
  if (tlen <= 0) {
    {
#line 20
    tmp = __errno_location();
#line 20
    *tmp = 22;
    }
#line 21
    return (-1);
  }
#line 24
  if (sio_sigpipe_ignored_already) {
#line 24
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 24
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 24
    sigpipe = tmp___0;
    }
  }
  {
#line 26
  nleft = size;
#line 27
  time(& now);
#line 28
  done = now + (time_t )tlen;
#line 29
  firstSelect = 1;
  }
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (done > now) {
#line 32
      tleft = (int )(done - now);
    } else {
#line 32
      tleft = 0;
    }
#line 33
    if (tleft < 1) {
#line 34
      nwrote = (ssize_t )size - (ssize_t )nleft;
#line 35
      if (nwrote == 0L) {
        {
#line 36
        nwrote = (ssize_t )-2;
#line 37
        tmp___1 = __errno_location();
#line 37
        *tmp___1 = 110;
        }
      }
#line 40
      goto done;
    }
#line 50
    if (! firstSelect) {
#line 50
      goto _L;
    } else
#line 50
    if ((swopts & 8) == 0) {
      _L: /* CIL Label */ 
      {
#line 51
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 52
        tmp___2 = __errno_location();
#line 52
        *tmp___2 = 0;
        }
        {
#line 53
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 53
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& ss.__fds_bits[0]): "memory");
#line 53
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 58
        ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 62
        tv.tv_sec = (__time_t )((long long )tlen);
#line 63
        tv.tv_usec = (__suseconds_t )0;
#line 64
        result = select(sfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 65
        if (result >= 1) {
#line 67
          goto while_break___0;
        } else
#line 68
        if (result == 0) {
#line 70
          nwrote = (ssize_t )size - (ssize_t )nleft;
#line 71
          if (nwrote > 0L) {
#line 72
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 72
              if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
                {
#line 72
                signal(13, sigpipe);
                }
              }
            }
#line 73
            return ((int )nwrote);
          }
          {
#line 75
          tmp___3 = __errno_location();
#line 75
          *tmp___3 = 110;
          }
#line 77
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 77
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 77
              signal(13, sigpipe);
              }
            }
          }
#line 78
          return (-2);
        } else {
          {
#line 79
          tmp___4 = __errno_location();
          }
#line 79
          if (*tmp___4 != 4) {
#line 80
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 80
              if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
                {
#line 80
                signal(13, sigpipe);
                }
              }
            }
#line 81
            return (-1);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 84
      firstSelect = 0;
    }
    {
#line 90
    nwrote = write(sfd, (void const   *)buf, nleft);
    }
#line 93
    if (nwrote < 0L) {
      {
#line 94
      tmp___6 = __errno_location();
      }
#line 94
      if (*tmp___6 != 4) {
#line 95
        nwrote = (ssize_t )size - (ssize_t )nleft;
#line 96
        if (nwrote == 0L) {
#line 97
          nwrote = (ssize_t )-1;
        }
#line 98
        goto done;
      } else {
        {
#line 100
        tmp___5 = __errno_location();
#line 100
        *tmp___5 = 0;
#line 101
        nwrote = (ssize_t )0;
        }
      }
    }
#line 105
    nleft -= (size_t )nwrote;
#line 106
    if (nleft == 0UL) {
#line 107
      goto while_break;
    }
    {
#line 108
    buf += nwrote;
#line 109
    time(& now);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  nwrote = (ssize_t )size - (ssize_t )nleft;
  done: 
#line 114
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 114
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 114
      signal(13, sigpipe);
      }
    }
  }
#line 115
  return ((int )nwrote);
}
}
#line 217 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SNewStreamClient(void) ;
#line 218
int SNewDatagramClient(void) ;
#line 219
int SNewStreamServer(int const   port , int const   nTries , int const   reuseFlag ,
                     int listenQueueSize ) ;
#line 220
int SNewDatagramServer(int const   port , int const   nTries , int const   reuseFlag ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SNew.c"
int SNewStreamClient(void) 
{ 
  int sfd ;

  {
  {
#line 11
  sfd = socket(2, 1, 0);
  }
#line 12
  if (sfd < 0) {
#line 13
    return (-6);
  }
#line 15
  return (sfd);
}
}
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SNew.c"
int SNewDatagramClient(void) 
{ 
  int sfd ;

  {
  {
#line 26
  sfd = socket(2, 2, 0);
  }
#line 27
  if (sfd < 0) {
#line 28
    return (-6);
  }
#line 30
  return (sfd);
}
}
#line 36 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SNew.c"
int SNewStreamServer(int const   port , int const   nTries , int const   reuseFlag ,
                     int listenQueueSize ) 
{ 
  int oerrno ;
  int sfd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 42
  sfd = socket(2, 1, 0);
  }
#line 43
  if (sfd < 0) {
#line 44
    return (-6);
  }
  {
#line 46
  tmp___1 = SBind(sfd, port, nTries, reuseFlag);
  }
#line 46
  if (tmp___1 < 0) {
    {
#line 47
    tmp = __errno_location();
#line 47
    oerrno = *tmp;
#line 48
    close(sfd);
#line 49
    tmp___0 = __errno_location();
#line 49
    *tmp___0 = oerrno;
    }
#line 50
    return (-7);
  }
  {
#line 53
  tmp___4 = SListen(sfd, listenQueueSize);
  }
#line 53
  if (tmp___4 < 0) {
    {
#line 54
    tmp___2 = __errno_location();
#line 54
    oerrno = *tmp___2;
#line 55
    close(sfd);
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = oerrno;
    }
#line 57
    return (-8);
  }
#line 60
  return (sfd);
}
}
#line 66 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SNew.c"
int SNewDatagramServer(int const   port , int const   nTries , int const   reuseFlag ) 
{ 
  int oerrno ;
  int sfd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 72
  sfd = socket(2, 2, 0);
  }
#line 73
  if (sfd < 0) {
#line 74
    return (-6);
  }
  {
#line 76
  tmp___1 = SBind(sfd, port, nTries, reuseFlag);
  }
#line 76
  if (tmp___1 < 0) {
    {
#line 77
    tmp = __errno_location();
#line 77
    oerrno = *tmp;
#line 78
    close(sfd);
#line 79
    tmp___0 = __errno_location();
#line 79
    *tmp___0 = oerrno;
    }
#line 80
    return (-7);
  }
#line 83
  return (sfd);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.h"
void GetScreenColumns(void) ;
#line 16
void InitTermcap(void) ;
#line 17
void InitReadline(void) ;
#line 21
void PrintStartupBanner(void) ;
#line 28
void SaveHistory(void) ;
#line 29
void LoadHistory(void) ;
#line 30
void DisposeReadline(void) ;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char const   *tcap_normal  =    "";
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char const   *tcap_boldface  =    "";
#line 28 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char const   *tcap_underline  =    "";
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char const   *tcap_reverse  =    "";
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char const   *gTerm  ;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
int gXterm  ;
#line 32 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
int gXtermTitle  ;
#line 33 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char gCurXtermTitleStr[256]  ;
#line 63 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void GetScreenColumns(void) 
{ 
  char ncftpbookmarks[256] ;
  FILE *infp ;
  void (*osigpipe)(int  ) ;
  int columns ;
  char *cp ;
  char *tmp ;
  struct winsize felix ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 83
  tmp = getenv("COLUMNS");
#line 83
  cp = tmp;
  }
#line 83
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 84
    gScreenColumns = 80;
  } else {
    {
#line 86
    gScreenColumns = atoi((char const   *)cp);
    }
#line 87
    return;
  }
  {
#line 94
  memset((void *)(& felix), 0, sizeof(felix));
#line 95
  tmp___0 = ioctl(0, 21523UL, & felix);
  }
#line 95
  if (tmp___0 == 0) {
#line 96
    columns = (int )felix.ws_col;
#line 97
    if (columns > 0) {
#line 97
      if (columns < 2048) {
#line 98
        gScreenColumns = columns;
      } else {
#line 100
        gScreenColumns = 80;
      }
    } else {
#line 100
      gScreenColumns = 80;
    }
#line 101
    return;
  }
#line 108
  if (gUid == 0) {
#line 109
    return;
  }
  {
#line 126
  Strncpy((char */* const  */)(ncftpbookmarks), (char const   */* const  */)"/usr/local/bin",
          (size_t const   )sizeof(ncftpbookmarks));
#line 127
  Strncat((char */* const  */)(ncftpbookmarks), (char const   */* const  */)"/", (size_t const   )sizeof(ncftpbookmarks));
#line 128
  Strncat((char */* const  */)(ncftpbookmarks), (char const   */* const  */)"ncftpbookmarks",
          (size_t const   )sizeof(ncftpbookmarks));
#line 130
  tmp___1 = access((char const   *)(ncftpbookmarks), 1);
  }
#line 130
  if (tmp___1 < 0) {
#line 131
    return;
  }
  {
#line 133
  Strncat((char */* const  */)(ncftpbookmarks), (char const   */* const  */)" --dimensions-terse",
          (size_t const   )sizeof(ncftpbookmarks));
#line 135
  osigpipe = NcSignal(13, (void (*)(int  ))1);
#line 136
  infp = popen((char const   *)(ncftpbookmarks), "r");
  }
#line 137
  if ((unsigned long )infp != (unsigned long )((void *)0)) {
    {
#line 138
    columns = 0;
#line 139
    fscanf((FILE */* __restrict  */)infp, (char const   */* __restrict  */)"%d", & columns);
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 140
      tmp___2 = _IO_getc(infp);
      }
#line 140
      if (! (tmp___2 != -1)) {
#line 140
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 141
    pclose(infp);
    }
#line 143
    if (columns > 0) {
#line 143
      if (columns < 2048) {
#line 144
        gScreenColumns = columns;
      }
    }
  }
  {
#line 146
  NcSignal(13, osigpipe);
  }
#line 149
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void InitTermcap(void) 
{ 
  char const   *term ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 176
  gXtermTitle = 0;
#line 176
  gXterm = gXtermTitle;
#line 177
  gCurXtermTitleStr[0] = (char )'\000';
#line 179
  tmp = getenv("TERM");
#line 179
  gTerm = (char const   *)tmp;
  }
#line 179
  if ((unsigned long )gTerm == (unsigned long )((void *)0)) {
#line 180
    tcap_normal = "";
#line 181
    tcap_boldface = "";
#line 182
    tcap_underline = "";
#line 183
    tcap_reverse = "";
#line 184
    return;
  }
  {
#line 187
  term = gTerm;
#line 188
  tmp___0 = strstr(term, "xterm");
  }
#line 188
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 193
    gXtermTitle = 1;
#line 193
    gXterm = gXtermTitle;
  } else {
    {
#line 188
    tmp___1 = strstr(term, "rxvt");
    }
#line 188
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 193
      gXtermTitle = 1;
#line 193
      gXterm = gXtermTitle;
    } else {
      {
#line 188
      tmp___2 = strstr(term, "dtterm");
      }
#line 188
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 193
        gXtermTitle = 1;
#line 193
        gXterm = gXtermTitle;
      } else {
        {
#line 188
        tmp___3 = strcasecmp(term, "scoterm");
        }
#line 188
        if (tmp___3 == 0) {
#line 193
          gXtermTitle = 1;
#line 193
          gXterm = gXtermTitle;
        }
      }
    }
  }
#line 196
  if (gXterm != 0) {
#line 203
    tcap_normal = "\033[0m";
#line 204
    tcap_boldface = "\033[1m";
#line 205
    tcap_underline = "\033[4m";
#line 206
    tcap_reverse = "\033[7m";
  } else {
    {
#line 196
    tmp___4 = strcmp(term, "vt100");
    }
#line 196
    if (tmp___4 == 0) {
#line 203
      tcap_normal = "\033[0m";
#line 204
      tcap_boldface = "\033[1m";
#line 205
      tcap_underline = "\033[4m";
#line 206
      tcap_reverse = "\033[7m";
    } else {
      {
#line 196
      tmp___5 = strcmp(term, "linux");
      }
#line 196
      if (tmp___5 == 0) {
#line 203
        tcap_normal = "\033[0m";
#line 204
        tcap_boldface = "\033[1m";
#line 205
        tcap_underline = "\033[4m";
#line 206
        tcap_reverse = "\033[7m";
      } else {
        {
#line 196
        tmp___6 = strcmp(term, "vt220");
        }
#line 196
        if (tmp___6 == 0) {
#line 203
          tcap_normal = "\033[0m";
#line 204
          tcap_boldface = "\033[1m";
#line 205
          tcap_underline = "\033[4m";
#line 206
          tcap_reverse = "\033[7m";
        } else {
          {
#line 196
          tmp___7 = strcmp(term, "cons25");
          }
#line 196
          if (tmp___7 == 0) {
#line 203
            tcap_normal = "\033[0m";
#line 204
            tcap_boldface = "\033[1m";
#line 205
            tcap_underline = "\033[4m";
#line 206
            tcap_reverse = "\033[7m";
          } else {
            {
#line 196
            tmp___8 = strcmp(term, "vt102");
            }
#line 196
            if (tmp___8 == 0) {
#line 203
              tcap_normal = "\033[0m";
#line 204
              tcap_boldface = "\033[1m";
#line 205
              tcap_underline = "\033[4m";
#line 206
              tcap_reverse = "\033[7m";
            } else {
#line 208
              tcap_normal = "";
#line 209
              tcap_boldface = "";
#line 210
              tcap_underline = "";
#line 211
              tcap_reverse = "";
            }
          }
        }
      }
    }
  }
#line 214
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *FindStartOfCurrentCommand(void) 
{ 
  char *scp ;
  char *start ;
  int qc ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 226
  scp = gl_buf;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    start = scp;
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 229
      if ((int )*scp == 0) {
#line 230
        goto done;
      }
      {
#line 231
      tmp = __ctype_b_loc();
      }
#line 231
      if (! ((int const   )*(*tmp + (int )*scp) & 8192)) {
#line 232
        goto while_break___0;
      }
#line 233
      scp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 235
    start = scp;
    {
#line 237
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 238
      if ((int )*scp == 0) {
#line 239
        goto done;
      } else
#line 240
      if ((int )*scp == 34) {
#line 240
        goto _L___0;
      } else
#line 240
      if ((int )*scp == 39) {
        _L___0: /* CIL Label */ 
#line 241
        tmp___0 = scp;
#line 241
        scp ++;
#line 241
        qc = (int )*tmp___0;
        {
#line 243
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 244
          if ((int )*scp == 0) {
#line 245
            goto done;
          } else
#line 246
          if ((int )*scp == 92) {
#line 247
            scp ++;
#line 248
            if ((int )*scp == 0) {
#line 249
              goto done;
            }
#line 250
            scp ++;
          } else
#line 251
          if ((int )*scp == qc) {
#line 252
            scp ++;
#line 253
            goto while_break___2;
          } else {
#line 255
            scp ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 258
      if ((int )*scp == 92) {
#line 259
        scp ++;
#line 260
        if ((int )*scp == 0) {
#line 261
          goto done;
        }
#line 262
        scp ++;
      } else
#line 263
      if ((int )*scp == 59) {
#line 263
        goto _L;
      } else
#line 263
      if ((int )*scp == 10) {
        _L: /* CIL Label */ 
#line 265
        scp ++;
#line 266
        if ((int )*scp == 0) {
#line 267
          goto done;
        }
#line 268
        goto while_break___1;
      } else {
#line 270
        scp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 275
  return (start);
}
}
#line 280 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static FTPFileInfoListPtr GetLsCacheFileList(char const   * const  item ) 
{ 
  int ci ;
  int sortBy ;
  int sortOrder ;
  FTPFileInfoListPtr filp ;

  {
  {
#line 288
  ci = LsCacheLookup(item);
  }
#line 289
  if (ci < 0) {
    {
#line 293
    Ls(item, 'l', (char const   */* const  */)"", (FILE *)((void *)0));
#line 294
    ci = LsCacheLookup(item);
    }
#line 295
    if (ci < 0) {
#line 296
      return ((FTPFileInfoListPtr )((void *)0));
    }
  }
  {
#line 299
  sortBy = 'n';
#line 300
  sortOrder = 'a';
#line 301
  filp = & gLsCache[ci].fil;
#line 302
  SortFileInfoList(filp, sortBy, sortOrder);
  }
#line 303
  return (filp);
}
}
#line 322 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static FTPFileInfoVec diritemv  ;
#line 323 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static int i  ;
#line 309 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *RemoteCompletionFunction(char const   *text , int state , int fTypeFilter ) 
{ 
  char rpath[256] ;
  char *cp ;
  char *cp2 ;
  char const   *textbasename ;
  int fType ;
  FTPFileInfoPtr diritemp ;
  FTPFileInfoListPtr filp ;
  int textdirlen ;
  size_t tbnlen ;
  size_t flen ;
  size_t mlen ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 325
  tmp = strrchr(text, '/');
#line 325
  textbasename = (char const   *)tmp;
  }
#line 326
  if ((unsigned long )textbasename == (unsigned long )((void *)0)) {
#line 327
    textbasename = text;
#line 328
    textdirlen = -1;
  } else {
#line 330
    textdirlen = (int )(textbasename - text);
#line 331
    textbasename ++;
  }
  {
#line 333
  tbnlen = strlen(textbasename);
  }
#line 335
  if (state == 0) {
#line 336
    if ((int const   )*(text + 0) == 0) {
      {
#line 338
      Strncpy((char */* const  */)(rpath), (char const   */* const  */)(gRemoteCWD),
              (size_t const   )sizeof(rpath));
      }
    } else {
      {
#line 340
      PathCat((char */* const  */)(rpath), (size_t const   )sizeof(rpath), (char const   */* const  */)(gRemoteCWD),
              (char const   */* const  */)text, gServerUsesMSDOSPaths);
#line 341
      tmp___0 = strlen(text);
      }
#line 341
      if ((int const   )*(text + (tmp___0 - 1UL)) == 47) {
        {
#line 343
        Strncat((char */* const  */)(rpath), (char const   */* const  */)"/", (size_t const   )sizeof(rpath));
        }
      }
      {
#line 345
      cp2 = strrchr((char const   *)(rpath), '/');
      }
#line 346
      if ((unsigned long )cp2 == (unsigned long )((void *)0)) {
#line 347
        return ((char *)((void *)0));
      } else
#line 348
      if ((unsigned long )cp2 == (unsigned long )(rpath)) {
#line 350
        cp2 ++;
      }
#line 352
      *cp2 = (char )'\000';
    }
    {
#line 355
    filp = GetLsCacheFileList((char const   */* const  */)(rpath));
    }
#line 356
    if ((unsigned long )filp == (unsigned long )((void *)0)) {
#line 357
      return ((char *)((void *)0));
    }
#line 359
    diritemv = filp->vec;
#line 360
    if ((unsigned long )diritemv == (unsigned long )((void *)0)) {
#line 361
      return ((char *)((void *)0));
    }
#line 363
    i = 0;
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    diritemp = *(diritemv + i);
#line 368
    if ((unsigned long )diritemp == (unsigned long )((void *)0)) {
#line 369
      goto while_break;
    }
#line 371
    i ++;
#line 372
    fType = diritemp->type;
#line 373
    if (fTypeFilter == 0) {
#line 373
      goto _L;
    } else
#line 373
    if (fType == fTypeFilter) {
#line 373
      goto _L;
    } else
#line 373
    if (fType == 108) {
      _L: /* CIL Label */ 
      {
#line 374
      tmp___3 = strncmp(textbasename, (char const   *)diritemp->relname, tbnlen);
      }
#line 374
      if (tmp___3 == 0) {
        {
#line 375
        flen = strlen((char const   *)diritemp->relname);
        }
#line 376
        if (textdirlen < 0) {
          {
#line 377
          mlen = flen + 2UL;
#line 378
          tmp___1 = malloc(mlen);
#line 378
          cp = (char *)tmp___1;
          }
#line 379
          if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 380
            return ((char *)((void *)0));
          }
          {
#line 381
          memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)diritemp->relname,
                 mlen);
          }
        } else {
          {
#line 383
          mlen = ((size_t )(textdirlen + 1) + flen) + 2UL;
#line 384
          tmp___2 = malloc(mlen);
#line 384
          cp = (char *)tmp___2;
          }
#line 385
          if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 386
            return ((char *)((void *)0));
          }
          {
#line 387
          memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)text,
                 (size_t )textdirlen);
#line 388
          *(cp + textdirlen) = (char )'/';
#line 389
          strcpy((char */* __restrict  */)((cp + textdirlen) + 1), (char const   */* __restrict  */)diritemp->relname);
          }
        }
#line 391
        if (fType == 100) {
#line 392
          gl_completion_exact_match_extra_char = '/';
        } else {
#line 394
          gl_completion_exact_match_extra_char = ' ';
        }
#line 396
        return (cp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return ((char *)((void *)0));
}
}
#line 406 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *RemoteFileCompletionFunction(char const   *text , int state ) 
{ 
  char *cp ;

  {
  {
#line 411
  cp = RemoteCompletionFunction(text, state, 0);
  }
#line 412
  return (cp);
}
}
#line 418 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *RemoteDirCompletionFunction(char const   *text , int state ) 
{ 
  char *cp ;

  {
  {
#line 423
  cp = RemoteCompletionFunction(text, state, 'd');
  }
#line 424
  return (cp);
}
}
#line 430 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *BookmarkCompletionFunction(char const   *text , int state ) 
{ 
  char *cp ;
  size_t textlen ;
  int i___0 ;
  int matches ;
  int tmp ;

  {
#line 437
  if ((unsigned long )gBookmarkTable == (unsigned long )((void *)0)) {
#line 438
    return ((char *)((void *)0));
  } else
#line 437
  if (state >= gNumBookmarks) {
#line 438
    return ((char *)((void *)0));
  }
  {
#line 440
  textlen = strlen(text);
  }
#line 441
  if (textlen == 0UL) {
    {
#line 442
    cp = StrDup((char const   *)((gBookmarkTable + state)->bookmarkName));
    }
  } else {
#line 444
    cp = (char *)((void *)0);
#line 445
    i___0 = 0;
#line 445
    matches = 0;
    {
#line 445
    while (1) {
      while_continue: /* CIL Label */ ;
#line 445
      if (! (i___0 < gNumBookmarks)) {
#line 445
        goto while_break;
      }
      {
#line 446
      tmp = strncasecmp((char const   *)((gBookmarkTable + i___0)->bookmarkName),
                        text, textlen);
      }
#line 446
      if (tmp == 0) {
#line 447
        if (matches >= state) {
          {
#line 448
          cp = StrDup((char const   *)((gBookmarkTable + i___0)->bookmarkName));
          }
#line 449
          goto while_break;
        }
#line 451
        matches ++;
      }
#line 445
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 455
  return (cp);
}
}
#line 461 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *CommandCompletionFunction(char const   *text , int state ) 
{ 
  char *cp ;
  size_t textlen ;
  int i___0 ;
  int matches ;
  CommandPtr cmdp ;
  int tmp ;

  {
  {
#line 469
  textlen = strlen(text);
  }
#line 470
  if (textlen == 0UL) {
#line 471
    cp = (char *)((void *)0);
  } else {
#line 473
    cp = (char *)((void *)0);
#line 474
    i___0 = 0;
#line 474
    matches = 0;
    {
#line 474
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 475
      cmdp = GetCommandByIndex((int const   )i___0);
      }
#line 476
      if ((unsigned long )cmdp == (unsigned long )((CommandPtr )0)) {
#line 477
        goto while_break;
      }
      {
#line 478
      tmp = strncasecmp(cmdp->name, text, textlen);
      }
#line 478
      if (tmp == 0) {
#line 479
        if (matches >= state) {
          {
#line 480
          cp = StrDup(cmdp->name);
          }
#line 481
          goto while_break;
        }
#line 483
        matches ++;
      }
#line 474
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 487
  return (cp);
}
}
#line 493 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *PrefOptCompletionFunction(char const   *text , int state ) 
{ 
  char *cp ;
  size_t textlen ;
  int i___0 ;
  int matches ;
  int tmp ;

  {
#line 500
  if (state >= gNumPrefOpts) {
#line 501
    return ((char *)((void *)0));
  }
  {
#line 503
  textlen = strlen(text);
  }
#line 504
  if (textlen == 0UL) {
    {
#line 505
    cp = StrDup(gPrefOpts[state].varname);
    }
  } else {
#line 507
    cp = (char *)((void *)0);
#line 508
    i___0 = 0;
#line 508
    matches = 0;
    {
#line 508
    while (1) {
      while_continue: /* CIL Label */ ;
#line 508
      if (! (i___0 < gNumPrefOpts)) {
#line 508
        goto while_break;
      }
      {
#line 509
      tmp = strncasecmp(gPrefOpts[i___0].varname, text, textlen);
      }
#line 509
      if (tmp == 0) {
#line 510
        if (matches >= state) {
          {
#line 511
          cp = StrDup(gPrefOpts[i___0].varname);
          }
#line 512
          goto while_break;
        }
#line 514
        matches ++;
      }
#line 508
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 518
  return (cp);
}
}
#line 524 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void ReCacheBookmarks(void) 
{ 


  {
  {
#line 527
  LoadBookmarkTable();
  }
#line 528
  return;
}
}
#line 532 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static int HaveCommandNameOnly(char *cmdstart ) 
{ 
  char *cp ;
  unsigned short const   **tmp ;

  {
#line 536
  cp = cmdstart;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! ((int )*cp != 0)) {
#line 536
      goto while_break;
    }
    {
#line 537
    tmp = __ctype_b_loc();
    }
#line 537
    if ((int const   )*(*tmp + (int )*cp) & 8192) {
#line 538
      return (0);
    }
#line 536
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  return (1);
}
}
#line 554 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static int flags  ;
#line 546 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *CompletionFunction(char const   *text , int state ) 
{ 
  char *cp ;
  char *cmdstart ;
  ArgvInfo ai ;
  int bUsed ;
  CommandPtr cmdp ;
  int tmp ;

  {
#line 556
  if (state == 0) {
    {
#line 557
    flags = -1;
#line 558
    cmdstart = FindStartOfCurrentCommand();
    }
#line 559
    if ((unsigned long )cmdstart == (unsigned long )((void *)0)) {
#line 560
      return ((char *)((void *)0));
    }
    {
#line 561
    tmp = HaveCommandNameOnly(cmdstart);
    }
#line 561
    if (tmp) {
      {
#line 562
      flags = -2;
#line 563
      cp = CommandCompletionFunction(text, state);
      }
#line 564
      return (cp);
    }
    {
#line 567
    memset((void *)(& ai), 0, sizeof(ai));
#line 568
    bUsed = MakeArgv(cmdstart, & ai.cargc, ai.cargv, (int )(sizeof(ai.cargv) / sizeof(char *)),
                     ai.argbuf, sizeof(ai.argbuf), ai.noglobargv, 1, 1);
    }
#line 572
    if (bUsed <= 0) {
#line 573
      return ((char *)((void *)0));
    }
#line 574
    if (ai.cargc == 0) {
#line 575
      return ((char *)((void *)0));
    }
    {
#line 577
    cmdp = GetCommandByName((char const   */* const  */)ai.cargv[0], 0);
    }
#line 578
    if ((unsigned long )cmdp == (unsigned long )((CommandPtr )-1)) {
#line 579
      return ((char *)((void *)0));
    } else
#line 580
    if ((unsigned long )cmdp == (unsigned long )((CommandPtr )0)) {
#line 581
      return ((char *)((void *)0));
    }
#line 583
    flags = cmdp->flags;
  }
#line 585
  if (flags == -2) {
    {
#line 586
    cp = CommandCompletionFunction(text, state);
    }
#line 587
    return (cp);
  }
#line 589
  if (flags < 0) {
#line 590
    return ((char *)((void *)0));
  }
#line 591
  if ((flags & 96) != 0) {
    {
#line 592
    cp = gl_local_filename_completion_proc(text, state);
    }
#line 593
    return (cp);
  } else
#line 594
  if ((flags & 8) != 0) {
    {
#line 595
    gl_filename_quoting_desired = 1;
#line 596
    cp = RemoteFileCompletionFunction(text, state);
    }
#line 597
    return (cp);
  } else
#line 598
  if ((flags & 16) != 0) {
    {
#line 599
    gl_filename_quoting_desired = 1;
#line 600
    cp = RemoteDirCompletionFunction(text, state);
    }
#line 601
    return (cp);
  } else
#line 602
  if ((flags & 128) != 0) {
    {
#line 603
    gl_filename_quoting_desired = 1;
#line 604
    cp = BookmarkCompletionFunction(text, state);
    }
#line 605
    return (cp);
  } else
#line 606
  if ((flags & 256) != 0) {
    {
#line 607
    cp = PrefOptCompletionFunction(text, state);
    }
#line 608
    return (cp);
  }
#line 610
  return ((char *)((void *)0));
}
}
#line 616 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void LoadHistory(void) 
{ 
  char pathName[256] ;

  {
#line 621
  if ((int )gOurDirectoryPath[0] == 0) {
#line 622
    return;
  }
  {
#line 623
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"history");
#line 625
  gl_histloadfile((char const   */* const  */)(pathName));
  }
#line 626
  return;
}
}
#line 630 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static size_t Vt100VisibleStrlen(char const   *src ) 
{ 
  char const   *cp ;
  size_t esc ;

  {
#line 636
  esc = (size_t )0;
#line 636
  cp = src;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! ((int const   )*cp != 0)) {
#line 636
      goto while_break;
    }
#line 637
    if ((int const   )*cp == 27) {
#line 638
      esc ++;
    }
#line 636
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  return ((size_t )(cp - src) - esc * 4UL);
}
}
#line 652 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void SaveHistory(void) 
{ 
  char pathName[256] ;

  {
#line 657
  if ((int )gOurDirectoryPath[0] == 0) {
#line 658
    return;
  }
  {
#line 659
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"history");
#line 661
  gl_histsavefile((char const   */* const  */)(pathName));
#line 664
  chmod((char const   *)(pathName), (__mode_t )384);
  }
#line 666
  return;
}
}
#line 671 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void InitReadline(void) 
{ 


  {
  {
#line 674
  gl_completion_proc = & CompletionFunction;
#line 675
  gl_setwidth(gScreenColumns);
#line 676
  gl_strlen = & Vt100VisibleStrlen;
#line 677
  LoadHistory();
#line 678
  ReCacheBookmarks();
  }
#line 679
  return;
}
}
#line 688 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
static char *lbuf  =    (char *)((void *)0);
#line 684 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
char *Readline(char *prompt ) 
{ 
  char *linecopy ;
  char *line ;
  char *cp ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 691
    if (gIsTTYr) {
      {
#line 692
      line = gl_getline(prompt);
      }
    } else {
#line 694
      if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
        {
#line 695
        tmp = calloc((size_t )512, (size_t )1);
#line 695
        lbuf = (char *)tmp;
        }
#line 696
        if ((unsigned long )lbuf == (unsigned long )((void *)0)) {
#line 697
          return ((char *)((void *)0));
        }
      }
      {
#line 699
      line = fgets((char */* __restrict  */)lbuf, (int )((size_t )511), (FILE */* __restrict  */)stdin);
      }
#line 700
      if ((unsigned long )line != (unsigned long )((void *)0)) {
        {
#line 701
        tmp___0 = strlen((char const   *)line);
#line 701
        cp = (line + tmp___0) - 1;
        }
#line 702
        if ((int )*cp == 10) {
#line 703
          *cp = (char )'\000';
        }
      }
    }
#line 707
    if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 708
      return ((char *)((void *)0));
    }
#line 711
    if ((int )*(line + 0) != 0) {
#line 712
      goto while_break;
    }
    {
#line 714
    tmp___1 = gl_get_result();
    }
#line 714
    if (tmp___1 == -1) {
#line 715
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 720
  linecopy = StrDup((char const   *)line);
#line 721
  line = linecopy;
  }
#line 722
  return (line);
}
}
#line 727 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void AddHistory(char const   * const  line ) 
{ 


  {
  {
#line 730
  gl_histadd(line);
  }
#line 731
  return;
}
}
#line 735 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void DisposeReadline(void) 
{ 


  {
  {
#line 738
  SaveHistory();
#line 739
  gl_dispose();
  }
#line 740
  return;
}
}
#line 747 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void ( /* format attribute */  SetXtermTitle)(char const   * const  fmt  , ...) 
{ 
  va_list ap ;
  char buf[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 753
  if (gXtermTitle != 0) {
#line 753
    if (gMaySetXtermTitle != 0) {
#line 754
      if ((unsigned long )fmt == (unsigned long )((void *)0)) {
        {
#line 758
        Strncpy((char */* const  */)(buf), (char const   */* const  */)gTerm, (size_t const   )sizeof(buf));
        }
      } else {
        {
#line 754
        tmp___0 = strcasecmp((char const   *)fmt, "RESTORE");
        }
#line 754
        if (tmp___0 == 0) {
          {
#line 758
          Strncpy((char */* const  */)(buf), (char const   */* const  */)gTerm, (size_t const   )sizeof(buf));
          }
        } else {
          {
#line 760
          tmp = strcasecmp((char const   *)fmt, "DEFAULT");
          }
#line 760
          if (tmp == 0) {
            {
#line 761
            Strncpy((char */* const  */)(buf), (char const   */* const  */)(gVersion + 5),
                    (size_t const   )12);
            }
          } else {
            {
#line 763
            __builtin_va_start(ap, fmt);
#line 765
            vsnprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)fmt,
                      ap);
#line 766
            buf[sizeof(buf) - 1UL] = (char )'\000';
#line 770
            __builtin_va_end(ap);
            }
          }
        }
      }
#line 772
      if ((int )buf[0] != 0) {
        {
#line 776
        tmp___1 = strcmp((char const   *)(gCurXtermTitleStr), (char const   *)(buf));
        }
#line 776
        if (tmp___1 != 0) {
          {
#line 777
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033]0;%s\a",
                  buf);
#line 778
          Strncpy((char */* const  */)(gCurXtermTitleStr), (char const   */* const  */)(buf),
                  (size_t const   )sizeof(gCurXtermTitleStr));
          }
        }
      }
    }
  }
#line 783
  return;
}
}
#line 788 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void PrintStartupBanner(void) 
{ 
  char v[80] ;
  char *cp ;
  char vdate[32] ;

  {
  {
#line 795
  vdate[0] = (char )'\000';
#line 796
  Strncpy((char */* const  */)(v), (char const   */* const  */)(gVersion + 5), (size_t const   )sizeof(v));
#line 797
  cp = strchr((char const   *)(v), ',');
  }
#line 798
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 799
    *cp = (char )'\000';
#line 800
    *(cp + -5) = (char )'\000';
#line 801
    Strncpy((char */* const  */)(vdate), (char const   */* const  */)" (", (size_t const   )sizeof(vdate));
#line 802
    Strncat((char */* const  */)(vdate), (char const   */* const  */)(v + 16), (size_t const   )sizeof(vdate));
#line 803
    Strncat((char */* const  */)(vdate), (char const   */* const  */)", ", (size_t const   )sizeof(vdate));
#line 804
    Strncat((char */* const  */)(vdate), (char const   */* const  */)(cp - 4), (size_t const   )sizeof(vdate));
#line 805
    Strncat((char */* const  */)(vdate), (char const   */* const  */)")", (size_t const   )sizeof(vdate));
    }
  }
  {
#line 840
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s%.11s%s%s by Mike Gleason (http://www.NcFTP.com/contact/).\n",
          tcap_boldface, gVersion + 5, tcap_normal, vdate);
#line 848
  fflush(stdout);
  }
#line 849
  return;
}
}
#line 855 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/readln.c"
void MakePrompt(char *dst , size_t dsize ) 
{ 
  char acwd[64] ;

  {
#line 861
  if (gConn.loggedIn != 0) {
    {
#line 862
    AbbrevStr(acwd, (char const   *)(gRemoteCWD), (size_t )25, 0);
#line 863
    snprintf((char */* __restrict  */)dst, dsize, (char const   */* __restrict  */)"%sncftp%s %s %s>%s ",
             tcap_boldface, tcap_normal, acwd, tcap_boldface, tcap_normal);
    }
  } else {
    {
#line 867
    snprintf((char */* __restrict  */)dst, dsize, (char const   */* __restrict  */)"%sncftp%s> ",
             tcap_boldface, tcap_normal);
    }
  }
#line 885
  return;
}
}
#line 949 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void InitWinsock(void) ;
#line 950
void DisposeWinsock(void) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_misc.c"
static int wsaInit  =    0;
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_misc.c"
void InitWinsock(void) 
{ 


  {
#line 31
  wsaInit ++;
#line 32
  return;
}
}
#line 36 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_misc.c"
void DisposeWinsock(void) 
{ 


  {
#line 42
  wsaInit --;
#line 44
  return;
}
}
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SConnect.c"
int SConnect(int sfd , struct sockaddr_in  const  * const  addr , int tlen ) 
{ 
  int result ;

  {
  {
#line 13
  result = _SConnect((int const   )sfd, addr, (size_t const   )sizeof(struct sockaddr_in ),
                     (int const   )tlen);
  }
#line 14
  return (result);
}
}
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SConnect.c"
static int SSetFIONBIO(int sfd , int onoff ) 
{ 
  int rc ;

  {
  {
#line 46
  rc = ioctl(sfd, 21537UL, & onoff);
  }
#line 49
  return (rc);
}
}
#line 56 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SConnect.c"
int _SConnect(int const   sfd , struct sockaddr_in  const  * const  addr , size_t const   saddrsiz ,
              int const   tlen ) 
{ 
  fd_set ss ;
  fd_set xx ;
  struct timeval tv ;
  int result ;
  int cErrno ;
  int optval ;
  socklen_t optlen ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  int *tmp___0 ;
  __sighandler_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  __sighandler_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 74
  sigpipe = (void (*)(int  ))0;
#line 76
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 77
    tmp = __errno_location();
#line 77
    *tmp = 22;
    }
#line 78
    return (-1);
  }
  {
#line 81
  tmp___0 = __errno_location();
#line 81
  *tmp___0 = 0;
  }
#line 82
  if (tlen <= 0) {
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (sio_sigpipe_ignored_already) {
#line 84
        sigpipe = (void (*)(int  ))0;
      } else {
        {
#line 84
        tmp___1 = signal(13, (void (*)(int  ))1);
#line 84
        sigpipe = tmp___1;
        }
      }
      {
#line 85
      result = connect((int )sfd, (struct sockaddr  const  *)addr, (socklen_t )saddrsiz);
      }
#line 88
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 88
        if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
          {
#line 88
          signal(13, sigpipe);
          }
        }
      }
#line 83
      if (result < 0) {
        {
#line 83
        tmp___2 = __errno_location();
        }
#line 83
        if (! (*tmp___2 == 4)) {
#line 83
          goto while_break;
        }
      } else {
#line 83
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    return (result);
  }
  {
#line 94
  tmp___3 = SSetFIONBIO((int )sfd, 1);
  }
#line 94
  if (tmp___3 < 0) {
#line 96
    return (-1);
  }
  {
#line 108
  tmp___4 = __errno_location();
#line 108
  *tmp___4 = 0;
  }
#line 109
  if (sio_sigpipe_ignored_already) {
#line 109
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 109
    tmp___5 = signal(13, (void (*)(int  ))1);
#line 109
    sigpipe = tmp___5;
    }
  }
  {
#line 110
  result = connect((int )sfd, (struct sockaddr  const  *)addr, (socklen_t )saddrsiz);
  }
#line 112
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 112
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 112
      signal(13, sigpipe);
      }
    }
  }
#line 113
  if (result == 0) {
#line 114
    goto connected;
  }
#line 116
  if (result < 0) {
    {
#line 116
    tmp___8 = __errno_location();
    }
#line 116
    if (*tmp___8 != 11) {
      {
#line 116
      tmp___9 = __errno_location();
      }
#line 116
      if (*tmp___9 != 115) {
        {
#line 124
        tmp___6 = __errno_location();
#line 124
        cErrno = *tmp___6;
#line 126
        shutdown((int )sfd, 2);
#line 127
        tmp___7 = __errno_location();
#line 127
        *tmp___7 = cErrno;
        }
#line 128
        return (-1);
      }
    }
  }
  {
#line 130
  tmp___10 = __errno_location();
#line 130
  cErrno = *tmp___10;
  }
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 136
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 136
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 136
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 141
    ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
    {
#line 145
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 145
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& xx.__fds_bits[0]): "memory");
#line 145
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 150
    xx.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 154
    tv.tv_sec = (__time_t )((long long )tlen);
#line 155
    tv.tv_usec = (__suseconds_t )0;
#line 156
    result = select((int )(sfd + 1), (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                    (fd_set */* __restrict  */)(& xx), (struct timeval */* __restrict  */)(& tv));
    }
#line 157
    if (result >= 1) {
#line 159
      goto while_break___0;
    } else
#line 160
    if (result == 0) {
      {
#line 162
      tmp___11 = __errno_location();
#line 162
      *tmp___11 = 110;
      }
#line 165
      return (-2);
    } else {
      {
#line 166
      tmp___12 = __errno_location();
      }
#line 166
      if (*tmp___12 != 4) {
#line 169
        return (-1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 184
  if ((xx.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] & (1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 201
    tmp___13 = __errno_location();
#line 201
    *tmp___13 = 0;
#line 202
    send((int )sfd, (void const   *)"\000", (size_t )1, 0);
#line 204
    tmp___14 = __errno_location();
#line 204
    result = *tmp___14;
#line 205
    shutdown((int )sfd, 2);
#line 206
    tmp___15 = __errno_location();
#line 206
    *tmp___15 = result;
    }
#line 207
    return (-1);
  }
#line 212
  if (cErrno == 115) {
    {
#line 229
    optval = 0;
#line 230
    optlen = (socklen_t )sizeof(optval);
#line 231
    tmp___18 = getsockopt((int )sfd, 1, 4, (void */* __restrict  */)(& optval), (socklen_t */* __restrict  */)(& optlen));
    }
#line 231
    if (tmp___18 == 0) {
      {
#line 232
      tmp___16 = __errno_location();
#line 232
      *tmp___16 = optval;
#line 233
      tmp___17 = __errno_location();
      }
#line 233
      if (*tmp___17 != 0) {
#line 234
        return (-1);
      }
    }
  }
  connected: 
  {
#line 243
  tmp___19 = SSetFIONBIO((int )sfd, 0);
  }
#line 243
  if (tmp___19 < 0) {
    {
#line 245
    shutdown((int )sfd, 2);
    }
#line 246
    return (-1);
  }
#line 256
  return (0);
}
}
#line 996 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPPutFiles(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                int const   recurse , int const   doGlob ) ;
#line 997
int FTPPutFiles2(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                 int const   recurse , int const   doGlob , int const   xtype , int const   appendflag ,
                 char const   * const  tmppfx , char const   * const  tmpsfx ) ;
#line 999
int FTPPutFilesAscii(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                     int const   recurse , int const   doGlob ) ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putfiles.c"
int FTPPutFiles3(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir1 ,
                 int const   recurse , int const   doGlob , int const   xtype , int appendflag ,
                 char const   * const  tmppfx , char const   * const  tmpsfx , int const   resumeflag ,
                 int const   deleteflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                    char const   *localpath ,
                                                                    long long localsize ,
                                                                    time_t localmtime ,
                                                                    char const   **remotepath ,
                                                                    long long remotesize ,
                                                                    time_t remotetime ,
                                                                    long long *startPoint ) ,
                 int reserved  __attribute__((__unused__)) ) 
{ 
  FTPLineList globList ;
  FTPFileInfoList files ;
  FTPFileInfoPtr filePtr ;
  int batchResult ;
  int result ;
  char const   *dstdir ;
  char dstdir2[512] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 59
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 60
    return (-139);
  }
  {
#line 61
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 61
  if (tmp) {
#line 62
    return (-138);
  }
#line 64
  if ((unsigned long )dstdir1 == (unsigned long )((void *)0)) {
#line 65
    dstdir = (char const   *)((void *)0);
  } else {
    {
#line 67
    tmp___0 = Strncpy((char */* const  */)(dstdir2), dstdir1, (size_t const   )sizeof(dstdir2));
#line 67
    dstdir = (char const   *)tmp___0;
#line 68
    StrRemoveTrailingSlashes(dstdir2);
    }
  }
  {
#line 71
  FTPLocalGlob((FTPCIPtr )cip, & globList, (char const   *)pattern, (int )doGlob);
  }
#line 72
  if (recurse == 1) {
    {
#line 73
    appendflag = 0;
#line 74
    FTPLocalRecursiveFileList((FTPCIPtr )cip, & globList, & files);
    }
#line 75
    if ((unsigned long )files.first == (unsigned long )((void *)0)) {
#line 76
      cip->errNo = -174;
#line 77
      return (-174);
    }
    {
#line 79
    ComputeRNames(& files, dstdir, 0, 1);
    }
  } else {
    {
#line 81
    LineListToFileInfoList(& globList, & files);
#line 82
    ComputeLNames(& files, (char const   *)((void *)0), (char const   *)((void *)0),
                  1);
#line 83
    ComputeRNames(& files, dstdir, 0, 0);
    }
  }
  {
#line 85
  DisposeLineListContents(& globList);
#line 100
  batchResult = 0;
#line 101
  filePtr = files.first;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 101
      goto while_break;
    }
#line 102
    if (cip->connected == 0) {
#line 103
      if (batchResult == 0) {
#line 104
        batchResult = -158;
      }
#line 105
      goto while_break;
    }
#line 107
    if (filePtr->type == 100) {
      {
#line 109
      StrRemoveTrailingSlashes(filePtr->rname);
#line 110
      result = FTPMkdir(cip, (char const   */* const  */)filePtr->rname, (int const   )0);
      }
#line 111
      if (result != 0) {
#line 112
        batchResult = result;
      }
    } else
#line 114
    if (filePtr->type == 108) {
#line 117
      if ((unsigned long )filePtr->rlinkto != (unsigned long )((void *)0)) {
#line 117
        if ((int )*(filePtr->rlinkto + 0) != 0) {
          {
#line 118
          FTPSymlink(cip, (char const   */* const  */)filePtr->rname, (char const   */* const  */)filePtr->rlinkto);
          }
        }
      }
    } else
#line 120
    if (recurse != 1) {
      {
#line 121
      result = FTPPutOneF(cip, (char const   */* const  */)filePtr->lname, (char const   */* volatile  */)filePtr->rname,
                          (int )xtype, (int const   )-1, (int const   )appendflag,
                          (char const   */* volatile  */)tmppfx, (char const   */* volatile  */)tmpsfx,
                          resumeflag, deleteflag, resumeProc);
      }
#line 122
      if (files.nFileInfos == 1) {
#line 123
        if (result != 0) {
#line 124
          batchResult = result;
        }
      } else
#line 126
      if (result != 0) {
#line 126
        if (result != -176) {
#line 126
          if (result != -177) {
#line 126
            if (result != -197) {
#line 127
              batchResult = result;
            }
          }
        }
      }
#line 129
      if (result == -195) {
#line 130
        cip->cancelXfer = 1;
      }
#line 131
      if (cip->cancelXfer > 0) {
#line 132
        goto while_break;
      }
    } else {
      {
#line 134
      result = FTPPutOneF(cip, (char const   */* const  */)filePtr->lname, (char const   */* volatile  */)filePtr->rname,
                          (int )xtype, (int const   )-1, (int const   )appendflag,
                          (char const   */* volatile  */)tmppfx, (char const   */* volatile  */)tmpsfx,
                          resumeflag, deleteflag, resumeProc);
      }
#line 135
      if (files.nFileInfos == 1) {
#line 136
        if (result != 0) {
#line 137
          batchResult = result;
        }
      } else
#line 139
      if (result != 0) {
#line 139
        if (result != -176) {
#line 139
          if (result != -177) {
#line 139
            if (result != -197) {
#line 140
              batchResult = result;
            }
          }
        }
      }
#line 142
      if (result == -195) {
#line 143
        cip->cancelXfer = 1;
      }
#line 144
      if (cip->cancelXfer > 0) {
#line 145
        goto while_break;
      }
    }
#line 101
    filePtr = filePtr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  DisposeFileInfoListContents(& files);
  }
#line 149
  if (batchResult < 0) {
#line 150
    cip->errNo = batchResult;
  }
#line 151
  return (batchResult);
}
}
#line 157 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putfiles.c"
int FTPPutFiles(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                int const   recurse , int const   doGlob ) 
{ 
  int tmp ;

  {
  {
#line 160
  tmp = FTPPutFiles3(cip, pattern, dstdir, recurse, doGlob, (int const   )'I', 0,
                     (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                     (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                            char const   *localpath ,
                                                                            long long localsize ,
                                                                            time_t localmtime ,
                                                                            char const   **remotepath ,
                                                                            long long remotesize ,
                                                                            time_t remotetime ,
                                                                            long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                              char const   *localpath ,
                                                                                                              long long localsize ,
                                                                                                              time_t localmtime ,
                                                                                                              char const   **remotepath ,
                                                                                                              long long remotesize ,
                                                                                                              time_t remotetime ,
                                                                                                              long long *startPoint ))0),
                     0);
  }
#line 160
  return (tmp);
}
}
#line 166 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putfiles.c"
int FTPPutFiles2(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                 int const   recurse , int const   doGlob , int const   xtype , int const   appendflag ,
                 char const   * const  tmppfx , char const   * const  tmpsfx ) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = FTPPutFiles3(cip, pattern, dstdir, recurse, doGlob, xtype, (int )appendflag,
                     tmppfx, tmpsfx, (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                                            char const   *localpath ,
                                                                                            long long localsize ,
                                                                                            time_t localmtime ,
                                                                                            char const   **remotepath ,
                                                                                            long long remotesize ,
                                                                                            time_t remotetime ,
                                                                                            long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                              char const   *localpath ,
                                                                                                                              long long localsize ,
                                                                                                                              time_t localmtime ,
                                                                                                                              char const   **remotepath ,
                                                                                                                              long long remotesize ,
                                                                                                                              time_t remotetime ,
                                                                                                                              long long *startPoint ))0),
                     0);
  }
#line 169
  return (tmp);
}
}
#line 175 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_putfiles.c"
int FTPPutFilesAscii(FTPCIPtr const   cip , char const   * const  pattern , char const   * const  dstdir ,
                     int const   recurse , int const   doGlob ) 
{ 
  int tmp ;

  {
  {
#line 178
  tmp = FTPPutFiles3(cip, pattern, dstdir, recurse, doGlob, (int const   )'A', 0,
                     (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0),
                     (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                            char const   *localpath ,
                                                                            long long localsize ,
                                                                            time_t localmtime ,
                                                                            char const   **remotepath ,
                                                                            long long remotesize ,
                                                                            time_t remotetime ,
                                                                            long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                              char const   *localpath ,
                                                                                                              long long localsize ,
                                                                                                              time_t localmtime ,
                                                                                                              char const   **remotepath ,
                                                                                                              long long remotesize ,
                                                                                                              time_t remotetime ,
                                                                                                              long long *startPoint ))0),
                     0);
  }
#line 178
  return (tmp);
}
}
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 16 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.h"
void TruncBatchLog(void) ;
#line 52
void RunBatchIfNeeded(FTPCIPtr const   cip ) ;
#line 25 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gStartupUrlParameterGiven  =    0;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gIsTTY  ;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gIsTTYr  ;
#line 27 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gScreenColumns  ;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
FTPLibraryInfo gLib  ;
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
FTPConnectionInfo gConn  ;
#line 31 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
FTPLineList gStartupURLCdList  ;
#line 32 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
char *gXBuf  =    (char *)((void *)0);
#line 33 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
size_t gXBufSize  =    (size_t )0;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gTransferTypeInitialized  =    0;
#line 35 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gTransferType  ;
#line 36 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int gURLMode  =    0;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
char gLocalCWD[512]  ;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
char gPrevLocalCWD[512]  ;
#line 61 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void Usage(void) 
{ 
  FILE *fp ;
  char s[80] ;

  {
  {
#line 69
  fp = stderr;
#line 70
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nUsage:  ncftp [flags] [<host> | <directory URL to browse>]\n");
#line 71
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nFlags:\n  -u XX  Use username XX instead of anonymous.\n  -p XX  Use password XX with the username.\n  -P XX  Use port number XX instead of the default FTP service port (21).\n  -j XX  Use account XX with the username (rarely needed).\n  -F     Dump a sample $HOME/.ncftp/firewall prefs file to stdout and exit.\n");
#line 78
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nProgram version:  %s\nLibrary version:  %s\n",
          gVersion + 5, gLibNcFTPVersion + 5);
#line 80
  AbbrevStr(s, "Linux GLaDOS 3.19.0-51-generic #57~14.04.1-Ubuntu SMP Fri Feb 19 14:36:55 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux",
            (size_t )60, 1);
#line 81
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Build system:     %s\n",
          s);
#line 83
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\nThis is a freeware program by Mike Gleason (http://www.NcFTP.com).\n");
#line 84
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"A directory URL ends in a slash, i.e. ftp://ftp.freebsd.org/pub/FreeBSD/\n");
#line 85
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Use ncftpget and ncftpput for command-line FTP and file URLs.\n\n");
#line 86
  exit(2);
  }
}
}
#line 92 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void DumpFirewallPrefsTemplate(void) 
{ 


  {
  {
#line 95
  WriteDefaultFirewallPrefs(stdout);
  }
#line 96
  return;
}
}
#line 104 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
void InitConnectionInfo(void) 
{ 
  int result ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 109
  result = FTPInitConnectionInfo2((FTPLIPtr const   )(& gLib), (FTPCIPtr const   )(& gConn),
                                  (char */* const  */)gXBuf, gXBufSize);
  }
#line 110
  if (result < 0) {
    {
#line 111
    tmp = FTPStrError(result);
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ncftp: init connection info error %d (%s).\n",
            result, tmp);
#line 112
    exit(1);
    }
  }
  {
#line 115
  gConn.debugLog = (FILE *)((void *)0);
#line 116
  gConn.errLog = stderr;
#line 117
  SetDebug(gDebug);
#line 118
  UseTrace();
#line 119
  Strncpy((char */* const  */)(gConn.user), (char const   */* const  */)"anonymous",
          (size_t const   )sizeof(gConn.user));
#line 120
  gConn.host[0] = (char )'\000';
#line 121
  gConn.progress = gProgressMeter;
#line 122
  gTransferTypeInitialized = 0;
#line 123
  gTransferType = 'I';
#line 124
  gConn.leavePass = 1;
#line 125
  gConn.connTimeout = (unsigned int )gConnTimeout;
#line 126
  gConn.xferTimeout = (unsigned int )gXferTimeout;
#line 127
  gConn.ctrlTimeout = (unsigned int )gCtrlTimeout;
#line 128
  gConn.dataPortMode = gDataPortMode;
#line 129
  gConn.maxDials = -1;
#line 130
  gUnprocessedJobs = 0;
#line 131
  gPrevRemoteCWD[0] = (char )'\000';
#line 132
  gStartDir[0] = (char )'\000';
#line 133
  gConn.dataSocketSBufSize = (size_t )gSOBufsize;
#line 133
  gConn.dataSocketRBufSize = gConn.dataSocketSBufSize;
  }
#line 134
  if (gRedialDelay >= 10) {
#line 135
    gConn.redialDelay = gRedialDelay;
  }
#line 136
  if ((int )gAutoAscii[0] == 0) {
#line 137
    gConn.asciiFilenameExtensions = (char const   *)((void *)0);
  } else {
    {
#line 136
    tmp___0 = strcasecmp((char const   *)(gAutoAscii), "no");
    }
#line 136
    if (tmp___0 == 0) {
#line 137
      gConn.asciiFilenameExtensions = (char const   *)((void *)0);
    } else {
      {
#line 136
      tmp___1 = strcasecmp((char const   *)(gAutoAscii), "off");
      }
#line 136
      if (tmp___1 == 0) {
#line 137
        gConn.asciiFilenameExtensions = (char const   *)((void *)0);
      } else {
        {
#line 136
        tmp___2 = strcasecmp((char const   *)(gAutoAscii), "false");
        }
#line 136
        if (tmp___2 == 0) {
#line 137
          gConn.asciiFilenameExtensions = (char const   *)((void *)0);
        } else {
#line 139
          gConn.asciiFilenameExtensions = (char const   *)(gAutoAscii);
        }
      }
    }
  }
#line 141
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
void CloseHost(void) 
{ 


  {
#line 152
  if (gConn.connected != 0) {
#line 153
    if (gConn.loggedIn != 0) {
      {
#line 154
      SaveUnsavedBookmark();
      }
    }
    {
#line 156
    RunBatchIfNeeded((FTPCIPtr const   )(& gConn));
    }
  }
  {
#line 158
  gConn.ctrlTimeout = 3U;
#line 159
  FTPCloseHost((FTPCIPtr const   )(& gConn));
#line 160
  gPrevRemoteCWD[0] = (char )'\000';
#line 161
  gStartDir[0] = (char )'\000';
  }
#line 162
  return;
}
}
#line 170 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void SetStartupURL(char const   * const  urlgiven ) 
{ 
  int rc ;
  char url[256] ;
  char urlfile[128] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  gLoadedBm = 0;
#line 178
  Strncpy((char */* const  */)(url), urlgiven, (size_t const   )sizeof(url));
#line 180
  rc = DecodeDirectoryURL((FTPCIPtr const   )(& gConn), url, & gStartupURLCdList,
                          urlfile, sizeof(urlfile));
  }
#line 181
  if (rc == -2) {
    {
#line 182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Malformed URL: %s\n",
            url);
#line 183
    exit(1);
    }
  } else
#line 184
  if (rc == -1) {
    {
#line 186
    Strncpy((char */* const  */)(gConn.host), urlgiven, (size_t const   )sizeof(gConn.host));
#line 187
    gURLMode = 2;
#line 188
    tmp = GetBookmark((char const   */* const  */)(gConn.host), & gBm);
    }
#line 188
    if (tmp >= 0) {
      {
#line 189
      gLoadedBm = 1;
#line 190
      Strncpy((char */* const  */)(gConn.host), (char const   */* const  */)(gBm.name),
              (size_t const   )sizeof(gConn.host));
#line 191
      Strncpy((char */* const  */)(gConn.user), (char const   */* const  */)(gBm.user),
              (size_t const   )sizeof(gConn.user));
#line 192
      Strncpy((char */* const  */)(gConn.pass), (char const   */* const  */)(gBm.pass),
              (size_t const   )sizeof(gConn.pass));
#line 193
      Strncpy((char */* const  */)(gConn.acct), (char const   */* const  */)(gBm.acct),
              (size_t const   )sizeof(gConn.acct));
#line 194
      gConn.hasSIZE = gBm.hasSIZE;
#line 195
      gConn.hasMDTM = gBm.hasMDTM;
#line 196
      gConn.hasPASV = gBm.hasPASV;
#line 197
      gConn.hasSITE_UTIME = gBm.hasUTIME;
#line 198
      gConn.port = gBm.port;
      }
    } else {
      {
#line 200
      SetBookmarkDefaults(& gBm);
      }
    }
    {
#line 203
    tmp___0 = MayUseFirewall((char const   */* const  */)(gConn.host), gFirewallType,
                             (char const   */* const  */)(gFirewallExceptionList));
    }
#line 203
    if (tmp___0 != 0) {
      {
#line 204
      gConn.firewallType = gFirewallType;
#line 205
      Strncpy((char */* const  */)(gConn.firewallHost), (char const   */* const  */)(gFirewallHost),
              (size_t const   )sizeof(gConn.firewallHost));
#line 206
      Strncpy((char */* const  */)(gConn.firewallUser), (char const   */* const  */)(gFirewallUser),
              (size_t const   )sizeof(gConn.firewallUser));
#line 207
      Strncpy((char */* const  */)(gConn.firewallPass), (char const   */* const  */)(gFirewallPass),
              (size_t const   )sizeof(gConn.firewallPass));
#line 208
      gConn.firewallPort = gFirewallPort;
      }
    }
  } else {
#line 212
    if ((int )urlfile[0] != 0) {
      {
#line 214
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use ncftpget or ncftpput to handle file URLs.\n");
#line 215
      exit(1);
      }
    }
    {
#line 217
    gURLMode = 1;
#line 218
    tmp___1 = MayUseFirewall((char const   */* const  */)(gConn.host), gFirewallType,
                             (char const   */* const  */)(gFirewallExceptionList));
    }
#line 218
    if (tmp___1 != 0) {
      {
#line 219
      gConn.firewallType = gFirewallType;
#line 220
      Strncpy((char */* const  */)(gConn.firewallHost), (char const   */* const  */)(gFirewallHost),
              (size_t const   )sizeof(gConn.firewallHost));
#line 221
      Strncpy((char */* const  */)(gConn.firewallUser), (char const   */* const  */)(gFirewallUser),
              (size_t const   )sizeof(gConn.firewallUser));
#line 222
      Strncpy((char */* const  */)(gConn.firewallPass), (char const   */* const  */)(gFirewallPass),
              (size_t const   )sizeof(gConn.firewallPass));
#line 223
      gConn.firewallPort = gFirewallPort;
      }
    }
  }
#line 226
  return;
}
}
#line 231 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void OpenURL(void) 
{ 
  int result ;
  int tmp ;

  {
#line 236
  if (gURLMode == 1) {
    {
#line 237
    SetBookmarkDefaults(& gBm);
#line 238
    tmp = DoOpen();
    }
#line 238
    if (tmp >= 0) {
      {
#line 239
      result = FTPChdirList(& gConn, (FTPLineListPtr const   )(& gStartupURLCdList),
                            (char */* const  */)((void *)0), (size_t const   )0, 12);
      }
#line 239
      if (result != 0) {
        {
#line 240
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-125,
                  (char const   */* const  */)"Could not change directory", (char const   */* const  */)((void *)0));
        }
      }
      {
#line 242
      result = FTPGetCWD((FTPCIPtr const   )(& gConn), (char */* const  */)(gRemoteCWD),
                         (size_t const   )sizeof(gRemoteCWD));
      }
#line 243
      if (result != 0) {
        {
#line 244
        FTPPerror((FTPCIPtr const   )(& gConn), (int const   )result, (int const   )-124,
                  (char const   */* const  */)((void *)0), (char const   */* const  */)((void *)0));
        }
      } else {
        {
#line 246
        printf((char const   */* __restrict  */)"Current remote directory is %s.\n",
               gRemoteCWD);
        }
      }
    }
  } else
#line 249
  if (gURLMode == 2) {
    {
#line 250
    DoOpen();
    }
  }
#line 252
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void PreInit(void) 
{ 
  int result ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  __pid_t tmp___9 ;

  {
  {
#line 265
  InitWinsock();
#line 267
  setlocale(6, "");
#line 276
  tmp___1 = isatty(2);
  }
#line 276
  if (tmp___1 != 0) {
    {
#line 276
    tmp___2 = getppid();
    }
#line 276
    if (tmp___2 > 1) {
#line 276
      gIsTTY = 1;
    } else {
#line 276
      gIsTTY = 0;
    }
  } else {
#line 276
    gIsTTY = 0;
  }
  {
#line 277
  tmp___5 = isatty(0);
  }
#line 277
  if (tmp___5 != 0) {
    {
#line 277
    tmp___6 = getppid();
    }
#line 277
    if (tmp___6 > 1) {
#line 277
      gIsTTYr = 1;
    } else {
#line 277
      gIsTTYr = 0;
    }
  } else {
#line 277
    gIsTTYr = 0;
  }
  {
#line 280
  NcSignal(29, (void (*)(int  ))1);
#line 282
  gXBufSize = (size_t )32768;
#line 283
  tmp___7 = malloc(gXBufSize);
#line 283
  gXBuf = (char *)tmp___7;
  }
#line 284
  if ((unsigned long )gXBuf == (unsigned long )((void *)0)) {
    {
#line 285
    perror("malloc");
#line 286
    exit(1);
    }
  }
  {
#line 288
  InitUserInfo();
#line 289
  result = FTPInitLibrary((FTPLIPtr const   )(& gLib));
  }
#line 290
  if (result < 0) {
    {
#line 291
    tmp___8 = FTPStrError(result);
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ncftp: init library error %d (%s).\n",
            result, tmp___8);
#line 292
    exit(1);
    }
  }
  {
#line 297
  tmp___9 = getpid();
#line 297
  srand((unsigned int )tmp___9);
#line 299
  InitLineList(& gStartupURLCdList);
#line 300
  CheckForNewV3User();
#line 301
  InitLog();
#line 302
  InitPrefs();
#line 303
  LoadFirewallPrefs(0);
#line 304
  LoadPrefs();
#line 305
  InitConnectionInfo();
#line 306
  InitCommandList();
#line 307
  InitLs();
#line 308
  TruncBatchLog();
#line 309
  GetScreenColumns();
  }
#line 310
  return;
}
}
#line 319 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void PostInit(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
#line 322
  PostInitPrefs();
  }
#line 323
  if (gGetOurHostNameResult == 100) {
    {
#line 324
    gGetOurHostNameResult = GetOurHostName((char */* const  */)(gOurHostName), (size_t const   )sizeof(gOurHostName));
    }
  }
  {
#line 325
  OpenTrace();
#line 326
  InitTermcap();
#line 327
  InitReadline();
#line 328
  FTPGetLocalCWD(gLocalCWD, sizeof(gLocalCWD));
#line 329
  gPrevLocalCWD[0] = (char )'\000';
#line 330
  PrintStartupBanner();
  }
#line 331
  if (gNumProgramRuns <= 1) {
    {
#line 332
    printf((char const   */* __restrict  */)"\n%s\n", gCopyright + 5);
    }
  }
#line 334
  if ((int )gFirewallPass[0] == 0) {
#line 334
    tmp = "(none)";
  } else {
#line 334
    tmp = "********";
  }
  {
#line 334
  Trace((int const   )0, (char const   */* const  */)"Fw: %s  Type: %d  User: %s  Pass: %s  Port: %u\n",
        gFirewallHost, gFirewallType, gFirewallUser, tmp, gFirewallPort);
#line 341
  Trace((int const   )0, (char const   */* const  */)"FwExceptions: %s\n", gFirewallExceptionList);
#line 342
  tmp___0 = strchr((char const   *)(gOurHostName), '.');
  }
#line 342
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 343
    Trace((int const   )0, (char const   */* const  */)"NOTE:  Your domain name could not be detected.\n");
    }
#line 344
    if (gConn.firewallType != 0) {
      {
#line 345
      Trace((int const   )0, (char const   */* const  */)"       Make sure you manually add your domain name to firewall-exception-list.\n");
      }
    }
  }
#line 348
  return;
}
}
#line 354 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void Plug(void) 
{ 
  int tmp ;

  {
#line 360
  if (gDoNotDisplayAds == 0) {
#line 361
    if (gNumProgramRuns % 4 == 3) {
      {
#line 362
      tmp = rand();
      }
#line 362
      if (tmp % 3 == 2) {
        {
#line 363
        printf((char const   */* __restrict  */)"\n\n\n\tThank you for using NcFTP Client.\n\tAsk your system administrator to try NcFTPd Server!\n\thttp://www.ncftp.com/ncftpd/\n\n\n\n");
        }
      } else {
        {
#line 365
        printf((char const   */* __restrict  */)"\n\n\n\tThank you for using NcFTP Client.\n\tIf you find it useful, please consider making a donation!\n\thttp://www.ncftp.com/ncftp/donate.html\n\n\n\n");
        }
      }
    }
  }
#line 370
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
static void PostShell(void) 
{ 


  {
  {
#line 379
  SetXtermTitle((char const   */* const  */)"RESTORE");
#line 380
  CloseHost();
#line 381
  FlushLsCache();
#line 382
  DisposeReadline();
#line 383
  CloseTrace();
#line 384
  SavePrefs();
#line 385
  DisposeBookmarkTable();
#line 386
  EndLog();
#line 387
  Plug();
  }
#line 388
  if ((unsigned long )gXBuf != (unsigned long )((void *)0)) {
    {
#line 389
    free((void *)gXBuf);
    }
  }
  {
#line 390
  DisposeWinsock();
  }
#line 391
  return;
}
}
#line 396 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/main.c"
int main(int argc , char ** const  argv ) 
{ 
  int c ;
  int n ;
  GetoptInfo opt ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 403
  PreInit();
#line 404
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 405
    c = Getopt((GetoptInfo */* const  */)(& opt), argc, argv, (char const   */* const  */)"P:u:p:j:rd:eg:o:FVLD");
    }
#line 405
    if (! (c > 0)) {
#line 405
      goto while_break;
    }
    {
#line 409
    if (c == 106) {
#line 409
      goto case_106;
    }
#line 409
    if (c == 112) {
#line 409
      goto case_106;
    }
#line 409
    if (c == 117) {
#line 409
      goto case_106;
    }
#line 409
    if (c == 80) {
#line 409
      goto case_106;
    }
#line 420
    if (c == 70) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 68) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 76) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 86) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 111) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 101) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 100) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 103) {
#line 420
      goto case_70;
    }
#line 420
    if (c == 114) {
#line 420
      goto case_70;
    }
#line 422
    goto switch_default;
    case_106: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 410
    gStartupUrlParameterGiven = 1;
#line 411
    goto switch_break;
    case_70: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 421
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 423
    Usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if (opt.ind < argc) {
    {
#line 427
    LoadFirewallPrefs(0);
#line 428
    SetStartupURL((char const   */* const  */)*(argv + opt.ind));
    }
  } else
#line 429
  if (gStartupUrlParameterGiven != 0) {
    {
#line 434
    Usage();
    }
  }
  {
#line 440
  GetoptReset((GetoptInfo */* const  */)(& opt));
  }
  {
#line 441
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 441
    c = Getopt((GetoptInfo */* const  */)(& opt), argc, argv, (char const   */* const  */)"P:u:p:j:rd:eg:o:FVLD");
    }
#line 441
    if (! (c > 0)) {
#line 441
      goto while_break___0;
    }
    {
#line 442
    if (c == 80) {
#line 442
      goto case_80___0;
    }
#line 445
    if (c == 117) {
#line 445
      goto case_117___0;
    }
#line 449
    if (c == 112) {
#line 449
      goto case_112___0;
    }
#line 453
    if (c == 106) {
#line 453
      goto case_106___0;
    }
#line 457
    if (c == 101) {
#line 457
      goto case_101___0;
    }
#line 462
    if (c == 114) {
#line 462
      goto case_114___0;
    }
#line 465
    if (c == 103) {
#line 465
      goto case_103___0;
    }
#line 468
    if (c == 100) {
#line 468
      goto case_100___0;
    }
#line 473
    if (c == 111) {
#line 473
      goto case_111___0;
    }
#line 476
    if (c == 70) {
#line 476
      goto case_70___0;
    }
#line 485
    if (c == 68) {
#line 485
      goto case_68___0;
    }
#line 485
    if (c == 76) {
#line 485
      goto case_68___0;
    }
#line 485
    if (c == 86) {
#line 485
      goto case_68___0;
    }
#line 488
    goto switch_default___0;
    case_80___0: /* CIL Label */ 
    {
#line 443
    tmp = atoi((char const   *)opt.arg);
#line 443
    gConn.port = (unsigned int )tmp;
    }
#line 444
    goto switch_break___0;
    case_117___0: /* CIL Label */ 
    {
#line 446
    Strncpy((char */* const  */)(gConn.user), (char const   */* const  */)opt.arg,
            (size_t const   )sizeof(gConn.user));
#line 447
    tmp___0 = strlen((char const   *)opt.arg);
#line 447
    memset((void *)opt.arg, '*', tmp___0);
    }
#line 448
    goto switch_break___0;
    case_112___0: /* CIL Label */ 
    {
#line 450
    Strncpy((char */* const  */)(gConn.pass), (char const   */* const  */)opt.arg,
            (size_t const   )sizeof(gConn.pass));
#line 451
    tmp___1 = strlen((char const   *)opt.arg);
#line 451
    memset((void *)opt.arg, '*', tmp___1);
    }
#line 452
    goto switch_break___0;
    case_106___0: /* CIL Label */ 
    {
#line 454
    Strncpy((char */* const  */)(gConn.acct), (char const   */* const  */)opt.arg,
            (size_t const   )sizeof(gConn.acct));
#line 455
    tmp___2 = strlen((char const   *)opt.arg);
#line 455
    memset((void *)opt.arg, '*', tmp___2);
    }
#line 456
    goto switch_break___0;
    case_101___0: /* CIL Label */ 
    {
#line 458
    gGetOurHostNameResult = GetOurHostName((char */* const  */)(gOurHostName), (size_t const   )sizeof(gOurHostName));
#line 459
    printf((char const   */* __restrict  */)"%s\n", gOurHostName);
#line 460
    exit(0);
    }
#line 461
    goto switch_break___0;
    case_114___0: /* CIL Label */ 
#line 464
    goto switch_break___0;
    case_103___0: /* CIL Label */ 
    {
#line 466
    gConn.maxDials = atoi((char const   *)opt.arg);
    }
#line 467
    goto switch_break___0;
    case_100___0: /* CIL Label */ 
    {
#line 469
    n = atoi((char const   *)opt.arg);
    }
#line 470
    if (n >= 10) {
#line 471
      gConn.redialDelay = n;
    }
#line 472
    goto switch_break___0;
    case_111___0: /* CIL Label */ 
#line 474
    gConn.manualOverrideFeatures = (char const   *)opt.arg;
#line 475
    goto switch_break___0;
    case_70___0: /* CIL Label */ 
    {
#line 477
    DumpFirewallPrefsTemplate();
#line 478
    exit(0);
    }
#line 480
    goto switch_break___0;
    case_68___0: /* CIL Label */ 
    case_76___0: /* CIL Label */ 
    case_86___0: /* CIL Label */ 
#line 487
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 489
    Usage();
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 495
  PostInit();
#line 496
  OpenURL();
#line 497
  CommandShell();
#line 498
  PostShell();
#line 499
  exit(0);
  }
}
}
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_rmdirr.c"
static int FTPRmdirRecursiveL2(FTPCIPtr const   cip ) 
{ 
  FTPLineList fileList ;
  FTPLinePtr filePtr ;
  char *file ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 21
  result = FTPRemoteGlob((FTPCIPtr )cip, & fileList, "**", 1);
  }
#line 22
  if (result != 0) {
#line 23
    return (result);
  }
#line 26
  filePtr = fileList.first;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! ((unsigned long )filePtr != (unsigned long )((void *)0))) {
#line 26
      goto while_break;
    }
#line 30
    file = filePtr->line;
#line 31
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 32
      cip->errNo = -127;
#line 33
      goto while_break;
    }
#line 36
    if ((int )*(file + 0) == 46) {
#line 36
      if ((int )*(file + 1) == 0) {
#line 37
        goto __Cont;
      } else
#line 36
      if ((int )*(file + 1) == 46) {
#line 36
        if ((int )*(file + 2) == 0) {
#line 37
          goto __Cont;
        }
      }
    }
    {
#line 39
    tmp___0 = FTPChdir(cip, (char const   */* const  */)file);
    }
#line 39
    if (tmp___0 == 0) {
      {
#line 43
      result = FTPRmdirRecursiveL2(cip);
#line 45
      tmp = FTPChdir(cip, (char const   */* const  */)"..");
      }
#line 45
      if (tmp != 0) {
#line 50
        result = -141;
#line 51
        cip->errNo = -141;
#line 52
        return (result);
      }
#line 55
      if (result < 0) {
#line 55
        if (result != -172) {
#line 56
          return (result);
        }
      }
      {
#line 58
      result = FTPRmdir(cip, (char const   */* const  */)file, (int const   )0, (int const   )0);
      }
#line 59
      if (result != 0) {
#line 64
        return (result);
      }
    } else {
      {
#line 68
      result = FTPDelete(cip, (char const   */* const  */)file, (int const   )0, (int const   )0);
      }
    }
    __Cont: /* CIL Label */ 
#line 26
    filePtr = filePtr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  DisposeLineListContents(& fileList);
  }
#line 76
  return (result);
}
}
#line 81 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/c_rmdirr.c"
int FTPRmdirRecursive(FTPCIPtr const   cip , char const   * const  dir___3 ) 
{ 
  int result ;
  int result2 ;
  int tmp ;

  {
  {
#line 87
  FTPGetCWD(cip, (char */* const  */)cip->buf, (size_t const   )cip->bufSize);
#line 89
  result = FTPChdir(cip, dir___3);
  }
#line 90
  if (result != 0) {
#line 91
    return (result);
  }
  {
#line 94
  result = FTPRmdirRecursiveL2(cip);
#line 96
  tmp = FTPChdir(cip, (char const   */* const  */)cip->buf);
  }
#line 96
  if (tmp != 0) {
#line 98
    if (result != 0) {
#line 99
      result = -141;
#line 100
      cip->errNo = -141;
    }
#line 102
    return (result);
  }
  {
#line 108
  result2 = FTPRmdir(cip, dir___3, (int const   )0, (int const   )0);
  }
#line 109
  if (result2 != 0) {
#line 109
    if (result == 0) {
#line 110
      result = result2;
    }
  }
#line 112
  return (result);
}
}
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_signal.c"
void (*NcSignal(int signum , void (*handler)(int  ) ))(int  ) 
{ 
  struct sigaction sa ;
  struct sigaction osa ;
  int tmp ;

  {
  {
#line 19
  sigemptyset(& sa.sa_mask);
#line 20
  sa.sa_flags = 0;
#line 21
  sa.__sigaction_handler.sa_handler = handler;
  }
#line 22
  if (signum == 14) {
#line 24
    sa.sa_flags |= 536870912;
  } else {
#line 28
    sa.sa_flags |= 268435456;
  }
  {
#line 31
  tmp = sigaction(signum, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)(& osa));
  }
#line 31
  if (tmp < 0) {
#line 32
    return ((void (*)(int  ))-1);
  }
#line 33
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 953 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
void GetHomeDir(char * const  dst , size_t const   size ) ;
#line 18 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_gethome.c"
void GetHomeDir(char * const  dst , size_t const   size ) 
{ 
  struct passwd pw ;
  char pwbuf[256] ;
  int tmp ;

  {
  {
#line 53
  tmp = GetMyPwEnt(& pw, (char */* const  */)(pwbuf), sizeof(pwbuf));
  }
#line 53
  if (tmp == 0) {
    {
#line 54
    Strncpy(dst, (char const   */* const  */)pw.pw_dir, size);
    }
  } else {
    {
#line 56
    Strncpy(dst, (char const   */* const  */)".", size);
    }
  }
#line 59
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_gethome.c"
static char const   *envvars[4]  = {      "TMPDIR",      "TMP",      "TEMP",      (char const   *)((void *)0)};
#line 64 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_gethome.c"
void GetTmpDir(char * const  dst , size_t const   size ) 
{ 
  char const   *tdir ;
  int i___0 ;
  struct stat st ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 72
  memset((void *)dst, 0, (size_t )size);
#line 74
  i___0 = 0;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )envvars[i___0] != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
    {
#line 75
    tmp = getenv(envvars[i___0]);
#line 75
    tdir = (char const   *)tmp;
    }
#line 76
    if ((unsigned long )tdir == (unsigned long )((void *)0)) {
#line 77
      goto __Cont;
    } else
#line 76
    if ((int const   )*(tdir + 0) == 0) {
#line 77
      goto __Cont;
    }
#line 80
    if ((int const   )*(tdir + 0) != 47) {
#line 81
      goto __Cont;
    }
    {
#line 83
    tmp___0 = stat((char const   */* __restrict  */)tdir, (struct stat */* __restrict  */)(& st));
    }
#line 83
    if (tmp___0 >= 0) {
#line 83
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 84
        Strncpy(dst, (char const   */* const  */)tdir, size);
        }
#line 85
        return;
      }
    }
    __Cont: /* CIL Label */ 
#line 74
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  Strncpy(dst, (char const   */* const  */)"/tmp", size);
#line 121
  tmp___1 = stat((char const   */* __restrict  */)dst, (struct stat */* __restrict  */)(& st));
  }
#line 121
  if (tmp___1 >= 0) {
#line 121
    if ((st.st_mode & 61440U) == 16384U) {
#line 122
      return;
    }
  }
  {
#line 124
  memset((void *)dst, 0, (size_t )size);
  }
#line 125
  return;
}
}
#line 24 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/util.c"
static int gResolveSig  ;
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/util.c"
static unsigned char const   B64EncodeTable___2[64]  = 
#line 38
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/util.c"
static unsigned char const   B64DecodeTable___2[256]  = 
#line 50
  {      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'>', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'?', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'@',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\002', 
        (unsigned char const   )'\003',      (unsigned char const   )'\004',      (unsigned char const   )'\005',      (unsigned char const   )'\006', 
        (unsigned char const   )'\a',      (unsigned char const   )'\b',      (unsigned char const   )'\t',      (unsigned char const   )'\n', 
        (unsigned char const   )'\v',      (unsigned char const   )'\f',      (unsigned char const   )'\r',      (unsigned char const   )'\016', 
        (unsigned char const   )'\017',      (unsigned char const   )'\020',      (unsigned char const   )'\021',      (unsigned char const   )'\022', 
        (unsigned char const   )'\023',      (unsigned char const   )'\024',      (unsigned char const   )'\025',      (unsigned char const   )'\026', 
        (unsigned char const   )'\027',      (unsigned char const   )'\030',      (unsigned char const   )'\031',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\032',      (unsigned char const   )'\033',      (unsigned char const   )'\034', 
        (unsigned char const   )'\035',      (unsigned char const   )'\036',      (unsigned char const   )'\037',      (unsigned char const   )' ', 
        (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#',      (unsigned char const   )'$', 
        (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )'\'',      (unsigned char const   )'(', 
        (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+',      (unsigned char const   )',', 
        (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/',      (unsigned char const   )'0', 
        (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177'};
#line 648 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/util.c"
static void CancelGetHostByName___2(int sigNum ) 
{ 
  int tmp ;

  {
#line 652
  gResolveSig = sigNum;
#line 655
  if (sigNum != 0) {
#line 655
    tmp = 1;
  } else {
#line 655
    tmp = 0;
  }
  {
#line 655
  siglongjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), tmp);
  }
}
}
#line 14 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strncat.c"
char *Strncat(char * const  dst , char const   * const  src , size_t const   n ) 
{ 
  register size_t i___0 ;
  register char *d ;
  register char const   *s ;
  char *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 21
  if (n != 0UL) {
    {
#line 21
    i___0 = strlen((char const   *)dst);
    }
#line 21
    if (i___0 < (size_t )(n - 1UL)) {
#line 22
      d = (char *)(dst + i___0);
#line 23
      s = (char const   *)src;
#line 30
      i___0 ++;
      {
#line 30
      while (1) {
        while_continue: /* CIL Label */ ;
#line 30
        if (! (i___0 < (size_t )n)) {
#line 30
          goto while_break;
        }
#line 31
        tmp___0 = d;
#line 31
        d ++;
#line 31
        tmp___2 = s;
#line 31
        s ++;
#line 31
        tmp___1 = (char )*tmp___2;
#line 31
        *tmp___0 = tmp___1;
#line 31
        if ((int )tmp___1 == 0) {
          {
#line 34
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 34
            if (! (i___0 < (size_t )n)) {
#line 34
              goto while_break___0;
            }
#line 35
            tmp = d;
#line 35
            d ++;
#line 35
            *tmp = (char)0;
#line 34
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 37
          return ((char *)dst);
        }
#line 30
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 43
      *d = (char)0;
    }
  }
#line 45
  return ((char *)dst);
}
}
#line 32 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
static char const   gCopyright___1[74]  = 
#line 32 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
  {      (char const   )'@',      (char const   )'(',      (char const   )'#',      (char const   )')', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'b', 
        (char const   )'N',      (char const   )'c',      (char const   )'F',      (char const   )'T', 
        (char const   )'P',      (char const   )' ',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'1',      (char const   )'9',      (char const   )'9',      (char const   )'5', 
        (char const   )'-',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'1',      (char const   )',',      (char const   )' ',      (char const   )'b', 
        (char const   )'y',      (char const   )' ',      (char const   )'M',      (char const   )'i', 
        (char const   )'k',      (char const   )'e',      (char const   )' ',      (char const   )'G', 
        (char const   )'l',      (char const   )'e',      (char const   )'a',      (char const   )'s', 
        (char const   )'o',      (char const   )'n',      (char const   )'.',      (char const   )' ', 
        (char const   )' ',      (char const   )'A',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )'v',      (char const   )'e',      (char const   )'d', 
        (char const   )'.',      (char const   )'\000'};
#line 53 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
static char const   *gPrivateNetworks___0[19]  = 
#line 53
  {      "192.168.",      "10.",      "172.16.",      "172.17.", 
        "172.18.",      "172.19.",      "172.20.",      "172.21.", 
        "172.22.",      "172.23.",      "172.24.",      "172.25.", 
        "172.26.",      "172.27.",      "172.28.",      "172.29.", 
        "172.30.",      "172.31.",      (char const   *)((void *)0)};
#line 103 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftp.c"
static int GetSocketAddress___0(FTPCIPtr const   cip , int sockfd , struct sockaddr_in *saddr ) 
{ 
  socklen_t len ;
  int result ;
  int tmp ;

  {
  {
#line 106
  len = (socklen_t )sizeof(struct sockaddr_in );
#line 107
  result = 0;
#line 109
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)saddr),
                    (socklen_t */* __restrict  */)(& len));
  }
#line 109
  if (tmp < 0) {
    {
#line 110
    FTPLogError(cip, (int const   )1, (char const   */* const  */)"Could not get socket name.\n");
#line 111
    cip->errNo = -110;
#line 112
    result = -110;
    }
  }
#line 114
  return (result);
}
}
#line 39 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strn.h"
size_t strntokc(char *dstTokenStart , size_t tokenSize , char *parsestr , char const   *delims ,
                char **context ) ;
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/strtokc.c"
char *strtokc(char *parsestr , char const   *delims , char **context ) 
{ 
  char *cp ;
  char const   *cp2 ;
  char c ;
  char c2 ;
  char *start ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 14
  if ((unsigned long )parsestr == (unsigned long )((void *)0)) {
#line 15
    start = *context;
  } else {
#line 17
    start = parsestr;
  }
#line 19
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 20
    *context = (char *)((void *)0);
#line 21
    return ((char *)((void *)0));
  } else
#line 19
  if ((unsigned long )delims == (unsigned long )((void *)0)) {
#line 20
    *context = (char *)((void *)0);
#line 21
    return ((char *)((void *)0));
  }
#line 25
  cp = start;
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
    next1: 
#line 27
    tmp = cp;
#line 27
    cp ++;
#line 27
    c = *tmp;
#line 28
    if ((int )c == 0) {
#line 30
      *context = (char *)((void *)0);
#line 31
      return ((char *)((void *)0));
    }
#line 33
    cp2 = delims;
    {
#line 33
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 34
      tmp___0 = cp2;
#line 34
      cp2 ++;
#line 34
      c2 = (char )*tmp___0;
#line 35
      if ((int )c2 == 0) {
#line 39
        start = cp - 1;
#line 40
        goto starttok;
      }
#line 42
      if ((int )c2 == (int )c) {
#line 45
        goto next1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  starttok: 
  {
#line 52
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 53
    c = *cp;
#line 54
    if ((int )c == 0) {
#line 56
      *context = cp;
#line 57
      goto while_break___1;
    }
#line 59
    cp2 = delims;
    {
#line 59
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 60
      tmp___1 = cp2;
#line 60
      cp2 ++;
#line 60
      c2 = (char )*tmp___1;
#line 61
      if ((int )c2 == 0) {
#line 65
        goto while_break___2;
      }
#line 67
      if ((int )c2 == (int )c) {
#line 70
        tmp___2 = cp;
#line 70
        cp ++;
#line 70
        *tmp___2 = (char )'\000';
#line 71
        *context = cp;
#line 72
        return (start);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 52
    cp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 76
  return (start);
}
}
#line 91 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/strtokc.c"
size_t strntokc(char *dstTokenStart , size_t tokenSize , char *parsestr , char const   *delims ,
                char **context ) 
{ 
  char *cp ;
  char const   *cp2 ;
  char c ;
  char c2 ;
  char *start ;
  size_t len ;
  char *dst ;
  char *lim ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 101
  dst = dstTokenStart;
#line 102
  lim = (dst + tokenSize) - 1;
#line 104
  if ((unsigned long )parsestr == (unsigned long )((void *)0)) {
#line 105
    start = *context;
  } else {
#line 107
    start = parsestr;
  }
#line 109
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 110
    *context = (char *)((void *)0);
#line 111
    goto done;
  } else
#line 109
  if ((unsigned long )delims == (unsigned long )((void *)0)) {
#line 110
    *context = (char *)((void *)0);
#line 111
    goto done;
  }
#line 115
  cp = start;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    next1: 
#line 117
    tmp = cp;
#line 117
    cp ++;
#line 117
    c = *tmp;
#line 118
    if ((int )c == 0) {
#line 120
      *context = (char *)((void *)0);
#line 121
      goto done;
    }
#line 123
    cp2 = delims;
    {
#line 123
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      tmp___0 = cp2;
#line 124
      cp2 ++;
#line 124
      c2 = (char )*tmp___0;
#line 125
      if ((int )c2 == 0) {
#line 129
        start = cp - 1;
#line 130
        if ((unsigned long )dst < (unsigned long )lim) {
#line 131
          tmp___1 = dst;
#line 131
          dst ++;
#line 131
          *tmp___1 = c;
        }
#line 132
        goto starttok;
      }
#line 134
      if ((int )c2 == (int )c) {
#line 137
        goto next1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  starttok: 
  {
#line 144
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 145
    c = *cp;
#line 146
    if ((int )c == 0) {
#line 148
      *context = cp;
#line 149
      goto while_break___1;
    }
#line 151
    cp2 = delims;
    {
#line 151
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 152
      tmp___2 = cp2;
#line 152
      cp2 ++;
#line 152
      c2 = (char )*tmp___2;
#line 153
      if ((int )c2 == 0) {
#line 157
        goto while_break___2;
      }
#line 159
      if ((int )c2 == (int )c) {
#line 162
        tmp___3 = cp;
#line 162
        cp ++;
#line 162
        *tmp___3 = (char )'\000';
#line 163
        *context = cp;
#line 164
        goto done;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 167
    if ((unsigned long )dst < (unsigned long )lim) {
#line 168
      tmp___4 = dst;
#line 168
      dst ++;
#line 168
      *tmp___4 = c;
    }
#line 144
    cp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
#line 172
  *dst = (char )'\000';
#line 173
  len = (size_t )(dst - dstTokenStart);
#line 177
  dst ++;
  {
#line 177
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 177
    if (! ((unsigned long )dst <= (unsigned long )lim)) {
#line 177
      goto while_break___3;
    }
#line 178
    tmp___5 = dst;
#line 178
    dst ++;
#line 178
    *tmp___5 = (char)0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 181
  return (len);
}
}
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SAccept.c"
int SAccept(int sfd , struct sockaddr_in * const  addr , int tlen ) 
{ 
  int result ;
  fd_set ss ;
  struct timeval tv ;
  socklen_t size ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0 ;
  int __d1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 13
  sigpipe = (void (*)(int  ))0;
#line 15
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 16
    tmp = __errno_location();
#line 16
    *tmp = 22;
    }
#line 17
    return (-1);
  }
#line 20
  if (sio_sigpipe_ignored_already) {
#line 20
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 20
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 20
    sigpipe = tmp___0;
    }
  }
#line 22
  if (tlen <= 0) {
    {
#line 23
    tmp___1 = __errno_location();
#line 23
    *tmp___1 = 0;
    }
    {
#line 24
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 25
      size = (socklen_t )sizeof(struct sockaddr_in );
#line 26
      result = accept(sfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)addr),
                      (socklen_t */* __restrict  */)(& size));
      }
#line 27
      if (result >= 0) {
#line 27
        goto _L;
      } else {
        {
#line 27
        tmp___2 = __errno_location();
        }
#line 27
        if (*tmp___2 != 4) {
          _L: /* CIL Label */ 
#line 28
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 28
            if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
              {
#line 28
              signal(13, sigpipe);
              }
            }
          }
#line 29
          return (result);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 34
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 35
    tmp___3 = __errno_location();
#line 35
    *tmp___3 = 0;
    }
    {
#line 36
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 36
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 36
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 41
    ss.__fds_bits[sfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (8 * (int )sizeof(__fd_mask ));
#line 45
    tv.tv_sec = (__time_t )((long long )tlen);
#line 46
    tv.tv_usec = (__suseconds_t )0;
#line 47
    result = select(sfd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 48
    if (result >= 1) {
#line 50
      goto while_break___0;
    } else
#line 51
    if (result == 0) {
      {
#line 53
      tmp___4 = __errno_location();
#line 53
      *tmp___4 = 110;
      }
#line 55
      if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 55
        if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
          {
#line 55
          signal(13, sigpipe);
          }
        }
      }
#line 56
      return (-2);
    } else {
      {
#line 57
      tmp___5 = __errno_location();
      }
#line 57
      if (*tmp___5 != 4) {
#line 58
        if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 58
          if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
            {
#line 58
            signal(13, sigpipe);
            }
          }
        }
#line 59
        return (-1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 64
    size = (socklen_t )sizeof(struct sockaddr_in );
#line 65
    result = accept(sfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)addr),
                    (socklen_t */* __restrict  */)(& size));
    }
#line 63
    if (result < 0) {
      {
#line 63
      tmp___6 = __errno_location();
      }
#line 63
      if (! (*tmp___6 == 4)) {
#line 63
        goto while_break___2;
      }
    } else {
#line 63
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 68
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 68
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 68
      signal(13, sigpipe);
      }
    }
  }
#line 69
  return (result);
}
}
#line 988 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPGetOneFile(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) ;
#line 992
int FTPGetOneFileAscii(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) ;
#line 34 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getonefile.c"
int FTPGetOneFile3(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   resumeflag ,
                   int const   appendflag , int const   deleteflag , int (* const  resumeProc)(FTPCIPtr const   cip ,
                                                                                               char const   **localpath ,
                                                                                               long long localsize ,
                                                                                               time_t localmtime ,
                                                                                               char const   *remotepath ,
                                                                                               long long remotesize ,
                                                                                               time_t remotetime ,
                                                                                               long long *startPoint ) ,
                   int reserved  __attribute__((__unused__)) ) 
{ 
  int result ;
  int tmp ;

  {
#line 50
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 51
    return (-139);
  }
  {
#line 52
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 52
  if (tmp) {
#line 53
    return (-138);
  }
#line 55
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 56
    return (-139);
  } else
#line 55
  if ((int const   )*(file + 0) == 0) {
#line 56
    return (-139);
  }
#line 57
  if (fdtouse < 0) {
#line 58
    if ((unsigned long )dstfile == (unsigned long )((void *)0)) {
#line 59
      return (-139);
    } else
#line 58
    if ((int const   )*(dstfile + 0) == 0) {
#line 59
      return (-139);
    }
  }
  {
#line 62
  result = FTPGetOneF(cip, file, (char const   *)dstfile, (int )xtype, fdtouse, -1LL,
                      (time_t )-1, resumeflag, appendflag, deleteflag, resumeProc);
  }
#line 63
  return (result);
}
}
#line 68 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getonefile.c"
int FTPGetOneFile(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) 
{ 
  int tmp ;

  {
  {
#line 71
  tmp = FTPGetOneFile3(cip, file, dstfile, (int const   )'I', (int const   )-1, (int const   )0,
                       (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                              char const   **localpath ,
                                                                              long long localsize ,
                                                                              time_t localmtime ,
                                                                              char const   *remotepath ,
                                                                              long long remotesize ,
                                                                              time_t remotetime ,
                                                                              long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                char const   **localpath ,
                                                                                                                long long localsize ,
                                                                                                                time_t localmtime ,
                                                                                                                char const   *remotepath ,
                                                                                                                long long remotesize ,
                                                                                                                time_t remotetime ,
                                                                                                                long long *startPoint ))0),
                       0);
  }
#line 71
  return (tmp);
}
}
#line 77 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getonefile.c"
int FTPGetOneFile2(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ,
                   int const   xtype , int const   fdtouse , int const   resumeflag ,
                   int const   appendflag ) 
{ 
  int tmp ;

  {
  {
#line 80
  tmp = FTPGetOneFile3(cip, file, dstfile, xtype, fdtouse, resumeflag, appendflag,
                       (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                             char const   **localpath ,
                                                             long long localsize ,
                                                             time_t localmtime , char const   *remotepath ,
                                                             long long remotesize ,
                                                             time_t remotetime , long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                   char const   **localpath ,
                                                                                                                   long long localsize ,
                                                                                                                   time_t localmtime ,
                                                                                                                   char const   *remotepath ,
                                                                                                                   long long remotesize ,
                                                                                                                   time_t remotetime ,
                                                                                                                   long long *startPoint ))0),
                       0);
  }
#line 80
  return (tmp);
}
}
#line 86 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_getonefile.c"
int FTPGetOneFileAscii(FTPCIPtr const   cip , char const   * const  file , char const   * const  dstfile ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = FTPGetOneFile3(cip, file, dstfile, (int const   )'A', (int const   )-1, (int const   )0,
                       (int const   )0, (int const   )0, (int (*/* const  */)(FTPCIPtr const   cip ,
                                                                              char const   **localpath ,
                                                                              long long localsize ,
                                                                              time_t localmtime ,
                                                                              char const   *remotepath ,
                                                                              long long remotesize ,
                                                                              time_t remotetime ,
                                                                              long long *startPoint ))((int (*)(FTPCIPtr const   cip ,
                                                                                                                char const   **localpath ,
                                                                                                                long long localsize ,
                                                                                                                time_t localmtime ,
                                                                                                                char const   *remotepath ,
                                                                                                                long long remotesize ,
                                                                                                                time_t remotetime ,
                                                                                                                long long *startPoint ))0),
                       0);
  }
#line 89
  return (tmp);
}
}
#line 37 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
static char *p___1  =    (char *)((void *)0);
#line 82 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
static char *p___2  =    (char *)((void *)0);
#line 260 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int SWaitUntilReadyForWriting(int const   sfd , int const   tlen ) ;
#line 9 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SWait.c"
int SWaitUntilReadyForReading(int const   sfd , int const   tlen ) 
{ 
  fd_set ss ;
  fd_set ss2 ;
  struct timeval tv ;
  int result ;
  int tleft ;
  time_t now ;
  time_t done ;
  int *tmp ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0___1 ;
  int __d1___1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 18
  if (sfd < 0) {
    {
#line 19
    tmp = __errno_location();
#line 19
    *tmp = 9;
    }
#line 20
    return (0);
  }
  {
#line 22
  tmp___0 = __errno_location();
#line 22
  *tmp___0 = 0;
  }
#line 24
  if (tlen < 0) {
    {
#line 25
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 26
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 26
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 26
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 31
      ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 35
      ss2 = ss;
#line 36
      result = select((int )(sfd + 1), (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)((void *)0));
      }
#line 37
      if (result >= 1) {
#line 39
        return (1);
      } else
#line 40
      if (result < 0) {
        {
#line 40
        tmp___1 = __errno_location();
        }
#line 40
        if (*tmp___1 != 4) {
#line 42
          return (0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 47
  if (tlen == 0) {
    {
#line 48
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 49
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 49
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 49
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 54
      ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 58
      ss2 = ss;
#line 59
      tv.tv_sec = (__time_t )0;
#line 60
      tv.tv_usec = (__suseconds_t )0;
#line 61
      result = select((int )(sfd + 1), (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)(& tv));
      }
#line 62
      if (result >= 1) {
#line 64
        return (1);
      } else
#line 65
      if (result == 0) {
        {
#line 67
        tmp___2 = __errno_location();
#line 67
        *tmp___2 = 110;
        }
#line 68
        return (0);
      } else
#line 69
      if (result < 0) {
        {
#line 69
        tmp___3 = __errno_location();
        }
#line 69
        if (*tmp___3 != 4) {
#line 71
          return (0);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 78
  time(& now);
#line 79
  done = now + (time_t )tlen;
#line 80
  tleft = (int )tlen;
  }
  {
#line 82
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 83
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 83
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 83
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 88
    ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 92
    ss2 = ss;
#line 93
    tv.tv_sec = (__time_t )((long long )tleft);
#line 94
    tv.tv_usec = (__suseconds_t )0;
#line 95
    result = select((int )(sfd + 1), (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)(& tv));
    }
#line 96
    if (result >= 1) {
#line 98
      return (1);
    } else
#line 99
    if (result < 0) {
      {
#line 100
      tmp___4 = __errno_location();
      }
#line 100
      if (*tmp___4 != 4) {
#line 102
        goto while_break___3;
      }
      {
#line 105
      time(& now);
      }
#line 106
      if (now > done) {
        {
#line 108
        tmp___5 = __errno_location();
#line 108
        *tmp___5 = 110;
        }
#line 109
        goto while_break___3;
      }
#line 111
      tleft = (int )(done - now);
    } else {
      {
#line 114
      tmp___6 = __errno_location();
#line 114
      *tmp___6 = 110;
      }
#line 115
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 128 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/SWait.c"
int SWaitUntilReadyForWriting(int const   sfd , int const   tlen ) 
{ 
  fd_set ss ;
  fd_set ss2 ;
  struct timeval tv ;
  int result ;
  int tleft ;
  time_t now ;
  time_t done ;
  int *tmp ;
  int *tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int __d0___1 ;
  int __d1___1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 137
  if (sfd < 0) {
    {
#line 138
    tmp = __errno_location();
#line 138
    *tmp = 9;
    }
#line 139
    return (0);
  }
  {
#line 141
  tmp___0 = __errno_location();
#line 141
  *tmp___0 = 0;
  }
#line 143
  if (tlen < 0) {
    {
#line 144
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 145
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 145
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 145
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 150
      ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 154
      ss2 = ss;
#line 155
      result = select((int )(sfd + 1), (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                      (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)((void *)0));
      }
#line 156
      if (result >= 1) {
#line 158
        return (1);
      } else
#line 159
      if (result < 0) {
        {
#line 159
        tmp___1 = __errno_location();
        }
#line 159
        if (*tmp___1 != 4) {
#line 161
          return (0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 166
  if (tlen == 0) {
    {
#line 167
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 168
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 168
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& ss.__fds_bits[0]): "memory");
#line 168
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 173
      ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 177
      ss2 = ss;
#line 178
      tv.tv_sec = (__time_t )0;
#line 179
      tv.tv_usec = (__suseconds_t )0;
#line 180
      result = select((int )(sfd + 1), (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                      (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)(& tv));
      }
#line 181
      if (result >= 1) {
#line 183
        return (1);
      } else
#line 184
      if (result == 0) {
        {
#line 186
        tmp___2 = __errno_location();
#line 186
        *tmp___2 = 110;
        }
#line 187
        return (0);
      } else
#line 188
      if (result < 0) {
        {
#line 188
        tmp___3 = __errno_location();
        }
#line 188
        if (*tmp___3 != 4) {
#line 190
          return (0);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 197
  time(& now);
#line 198
  done = now + (time_t )tlen;
#line 199
  tleft = (int )tlen;
  }
  {
#line 201
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 202
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 202
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 202
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 207
    ss.__fds_bits[sfd / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sfd % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 211
    ss2 = ss;
#line 212
    tv.tv_sec = (__time_t )((long long )tleft);
#line 213
    tv.tv_usec = (__suseconds_t )0;
#line 214
    result = select((int )(sfd + 1), (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                    (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)(& tv));
    }
#line 215
    if (result >= 1) {
#line 217
      return (1);
    } else
#line 218
    if (result < 0) {
      {
#line 219
      tmp___4 = __errno_location();
      }
#line 219
      if (*tmp___4 != 4) {
#line 221
        goto while_break___3;
      }
      {
#line 224
      time(& now);
      }
#line 225
      if (now > done) {
        {
#line 227
        tmp___5 = __errno_location();
#line 227
        *tmp___5 = 110;
        }
#line 228
        goto while_break___3;
      }
#line 230
      tleft = (int )(done - now);
    } else {
      {
#line 233
      tmp___6 = __errno_location();
#line 233
      *tmp___6 = 110;
      }
#line 234
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 238
  return (0);
}
}
#line 15 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_mkdirs.c"
int MkDirs(char const   * const  newdir , int mode1 ) 
{ 
  char s[512] ;
  int rc ;
  char *cp ;
  char *sl ;
  struct stat st ;
  mode_t mode ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 30
  mode = (mode_t )mode1;
#line 33
  tmp = __errno_location();
#line 33
  *tmp = 0;
#line 69
  tmp___3 = access((char const   *)newdir, 0);
  }
#line 69
  if (tmp___3 == 0) {
    {
#line 70
    tmp___0 = stat((char const   */* __restrict  */)newdir, (struct stat */* __restrict  */)(& st));
    }
#line 70
    if (tmp___0 < 0) {
#line 71
      return (-1);
    }
#line 72
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
#line 73
      tmp___1 = __errno_location();
#line 73
      *tmp___1 = 20;
      }
#line 74
      return (-1);
    }
    {
#line 76
    tmp___2 = __errno_location();
#line 76
    *tmp___2 = 17;
    }
#line 77
    return (0);
  }
  {
#line 81
  strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)newdir, sizeof(s));
  }
#line 82
  if ((int )s[sizeof(s) - 1UL] != 0) {
    {
#line 84
    tmp___4 = __errno_location();
#line 84
    *tmp___4 = 36;
    }
  }
  {
#line 91
  cp = strrchr((char const   *)(s), '/');
  }
#line 92
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 98
    rc = mkdir((char const   *)newdir, mode);
    }
#line 99
    return (rc);
  } else
#line 101
  if ((int )*(cp + 1) == 0) {
#line 103
    cp --;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! ((unsigned long )cp > (unsigned long )(s))) {
#line 104
        goto while_break;
      }
#line 105
      if (! ((int )*cp == 47)) {
#line 106
        goto while_break;
      }
#line 107
      cp --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 109
    *(cp + 1) = (char )'\000';
#line 110
    cp = strrchr((char const   *)(s), '/');
    }
#line 111
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 116
      rc = mkdir((char const   *)(s), mode);
      }
#line 117
      return (rc);
    }
  }
#line 130
  sl = (char *)((void *)0);
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 132
    *cp = (char )'\000';
#line 136
    rc = access((char const   *)(s), 0);
    }
#line 138
    if ((unsigned long )sl != (unsigned long )((void *)0)) {
#line 139
      *sl = (char )'/';
    }
#line 140
    if (rc == 0) {
#line 141
      *cp = (char )'/';
#line 142
      goto while_break___0;
    }
    {
#line 144
    sl = cp;
#line 145
    cp = strrchr((char const   *)(s), '/');
    }
#line 146
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 154
      if ((unsigned long )sl != (unsigned long )((void *)0)) {
#line 155
        *sl = (char )'/';
      }
#line 162
      cp = s;
#line 163
      cp --;
#line 164
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 173
    sl = strchr((char const   *)(cp + 1), '/');
    }
#line 174
    if ((unsigned long )sl == (unsigned long )(s)) {
      {
#line 182
      cp ++;
#line 183
      sl = strchr((char const   *)(cp + 1), '/');
      }
    }
#line 185
    if ((unsigned long )sl != (unsigned long )((void *)0)) {
#line 186
      *sl = (char )'\000';
    }
    {
#line 192
    rc = mkdir((char const   *)(s), mode);
    }
#line 193
    if (rc < 0) {
#line 194
      return (rc);
    }
#line 196
    if ((unsigned long )sl == (unsigned long )((void *)0)) {
#line 197
      goto while_break___1;
    }
#line 198
    *sl = (char )'/';
#line 199
    cp = sl;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 201
  return (0);
}
}
#line 8 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UBind.c"
int UBind(int sockfd , char const   * const  astr , int const   nTries , int const   reuseFlag ) 
{ 
  unsigned int i___0 ;
  int on ;
  socklen_t onsize ;
  struct sockaddr_un localAddr ;
  socklen_t ualen ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 17
  if ((unsigned long )astr == (unsigned long )((void *)0)) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  } else
#line 17
  if ((int const   )*(astr + 0) == 0) {
    {
#line 18
    tmp = __errno_location();
#line 18
    *tmp = 22;
    }
#line 19
    return (-1);
  }
  {
#line 22
  tmp___0 = MakeSockAddrUn(& localAddr, astr);
#line 22
  ualen = (socklen_t )tmp___0;
#line 23
  unlink((char const   *)(localAddr.sun_path));
  }
#line 25
  if (reuseFlag != 0) {
    {
#line 30
    on = 1;
#line 31
    onsize = (socklen_t )sizeof(on);
#line 32
    setsockopt(sockfd, 1, 2, (void const   *)(& on), onsize);
    }
  }
#line 36
  i___0 = 1U;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    tmp___1 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& localAddr)),
                   ualen);
    }
#line 40
    if (tmp___1 == 0) {
#line 41
      goto while_break;
    }
#line 43
    if (i___0 == (unsigned int )nTries) {
#line 44
      return (-1);
    }
    {
#line 49
    sleep(i___0 * 3U);
#line 36
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (0);
}
}
#line 58 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/UBind.c"
int UListen(int sfd , int backlog ) 
{ 
  int tmp ;

  {
  {
#line 61
  tmp = listen(sfd, backlog);
  }
#line 61
  return (tmp);
}
}
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglob.c"
static void ExpandTilde(char *pattern , size_t siz ) 
{ 
  char pat[512] ;
  char *cp ;
  char *rest ;
  char *firstent ;
  struct passwd pw ;
  char pwbuf[256] ;
  char hdir[512] ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 29
  if ((int )*(pattern + 0) == 126) {
    {
#line 29
    tmp___0 = __ctype_b_loc();
    }
#line 29
    if ((int const   )*(*tmp___0 + (int )*(pattern + 1)) & 8) {
#line 29
      goto _L;
    } else
#line 29
    if ((int )*(pattern + 1) == 47) {
#line 29
      goto _L;
    } else
#line 29
    if ((int )*(pattern + 1) == 0) {
      _L: /* CIL Label */ 
      {
#line 31
      Strncpy((char */* const  */)(pat), (char const   */* const  */)pattern, (size_t const   )sizeof(pat));
#line 32
      cp = strchr((char const   *)(pat), '/');
      }
#line 32
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 33
        *cp = (char)0;
#line 34
        rest = cp + 1;
      } else {
#line 36
        rest = (char *)((void *)0);
      }
#line 38
      if ((int )pat[1] == 0) {
        {
#line 40
        GetHomeDir((char */* const  */)(hdir), (size_t const   )sizeof(hdir));
#line 41
        firstent = hdir;
        }
      } else {
        {
#line 47
        tmp = GetPwNam(& pw, (char const   */* const  */)(pat + 1), (char */* const  */)(pwbuf),
                       sizeof(pwbuf));
        }
#line 47
        if (tmp == 0) {
#line 48
          firstent = pw.pw_dir;
        } else {
#line 50
          return;
        }
      }
      {
#line 54
      Strncpy((char */* const  */)pattern, (char const   */* const  */)firstent, (size_t const   )siz);
      }
#line 55
      if ((unsigned long )rest != (unsigned long )((void *)0)) {
        {
#line 56
        Strncat((char */* const  */)pattern, (char const   */* const  */)"/", (size_t const   )siz);
#line 57
        Strncat((char */* const  */)pattern, (char const   */* const  */)rest, (size_t const   )siz);
        }
      }
    }
  }
#line 60
  return;
}
}
#line 128 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglob.c"
static int LazyUnixLocalGlob(FTPCIPtr cip , FTPLineListPtr fileList , char const   * const  pattern ) 
{ 
  char cmd[512] ;
  longstring gfile ;
  FILE *fp ;
  void (*sp)(int  ) ;
  FILE *tmp ;
  char *tmp___0 ;

  {
  {
#line 140
  snprintf((char */* __restrict  */)(cmd), sizeof(cmd) - 1UL, (char const   */* __restrict  */)"%s -c \"%s %s %s\"",
           "/bin/sh", "/bin/ls", "-d", pattern);
#line 142
  cmd[sizeof(cmd) - 1UL] = (char )'\000';
#line 148
  tmp = popen((char const   *)(cmd), "r");
#line 148
  fp = tmp;
  }
#line 149
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 150
    FTPLogError((FTPCIPtr const   )cip, (int const   )1, (char const   */* const  */)"Could not Lglob: [%s]\n",
                cmd);
#line 151
    cip->errNo = -151;
    }
#line 152
    return (-151);
  }
  {
#line 154
  sp = NcSignal(13, (void (*)(int  ))1);
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    tmp___0 = FGets(gfile, sizeof(gfile), fp);
    }
#line 155
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 155
      goto while_break;
    }
    {
#line 156
    PrintF((FTPCIPtr const   )cip, (char const   */* const  */)"  Lglob [%s]\n", gfile);
#line 157
    AddLine(fileList, (char const   *)(gfile));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  pclose(fp);
#line 160
  NcSignal(13, sp);
  }
#line 161
  return (0);
}
}
#line 169 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/lglob.c"
int FTPLocalGlob(FTPCIPtr cip , FTPLineListPtr fileList , char const   *pattern ,
                 int doGlob ) 
{ 
  char pattern2[512] ;
  int result ;
  int tmp ;
  char *tmp___0 ;

  {
#line 175
  if ((unsigned long )cip == (unsigned long )((void *)0)) {
#line 176
    return (-139);
  }
  {
#line 177
  tmp = strcmp((char const   *)(cip->magic), "LibNcFTP 3.2.5");
  }
#line 177
  if (tmp) {
#line 178
    return (-138);
  }
#line 180
  if ((unsigned long )fileList == (unsigned long )((void *)0)) {
#line 181
    return (-139);
  }
  {
#line 182
  InitLineList(fileList);
  }
#line 184
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
#line 185
    return (-139);
  } else
#line 184
  if ((int const   )*(pattern + 0) == 0) {
#line 185
    return (-139);
  }
  {
#line 187
  Strncpy((char */* const  */)(pattern2), (char const   */* const  */)pattern, (size_t const   )sizeof(pattern2));
#line 190
  ExpandTilde(pattern2, sizeof(pattern2));
#line 191
  InitLineList(fileList);
#line 192
  result = 0;
  }
#line 194
  if (doGlob == 1) {
    {
#line 194
    tmp___0 = strpbrk((char const   *)(pattern2), "[*?");
    }
#line 194
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
#line 198
      result = LazyUnixLocalGlob(cip, fileList, (char const   */* const  */)(pattern2));
      }
    } else {
      {
#line 204
      AddLine(fileList, (char const   *)(pattern2));
      }
    }
  } else {
    {
#line 204
    AddLine(fileList, (char const   *)(pattern2));
    }
  }
#line 207
  return (result);
}
}
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.h"
void RunBatchWithCore(FTPCIPtr const   cip ) ;
#line 21 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
int gUnprocessedJobs  =    0;
#line 22 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
int gJobs  =    0;
#line 23 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
int gHaveSpool  =    -1;
#line 30 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
void TruncBatchLog(void) 
{ 
  char f[256] ;
  struct stat st ;
  time_t t ;
  int fd ;
  int tmp ;

  {
#line 38
  if ((int )gOurDirectoryPath[0] != 0) {
    {
#line 39
    time(& t);
#line 40
    t -= 86400L;
#line 41
    OurDirectoryPath((char */* const  */)(f), (size_t const   )sizeof(f), (char const   */* const  */)"log");
#line 42
    tmp = stat((char const   */* __restrict  */)(f), (struct stat */* __restrict  */)(& st));
    }
#line 42
    if (tmp == 0) {
#line 42
      if (st.st_mtim.tv_sec < t) {
        {
#line 47
        fd = open((char const   *)(f), 513, 384);
        }
#line 48
        if (fd >= 0) {
          {
#line 49
          close(fd);
          }
        }
      }
    }
  }
#line 52
  return;
}
}
#line 57 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
int HaveSpool(void) 
{ 
  char ncftpbatch[256] ;
  int tmp___0 ;

  {
#line 73
  if (gHaveSpool < 0) {
    {
#line 77
    Strncpy((char */* const  */)(ncftpbatch), (char const   */* const  */)"/usr/local/bin",
            (size_t const   )sizeof(ncftpbatch));
#line 79
    Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"/", (size_t const   )sizeof(ncftpbatch));
#line 80
    Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"ncftpbatch",
            (size_t const   )sizeof(ncftpbatch));
#line 81
    tmp___0 = access((char const   *)(ncftpbatch), 1);
    }
#line 81
    if (tmp___0 == 0) {
#line 81
      gHaveSpool = 1;
    } else {
#line 81
      gHaveSpool = 0;
    }
  }
#line 93
  return (gHaveSpool);
}
}
#line 99 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
int CanSpool(void) 
{ 
  char sdir[256] ;
  int tmp ;

  {
#line 104
  if ((int )gOurDirectoryPath[0] == 0) {
#line 105
    return (-1);
  }
  {
#line 107
  tmp = MkSpoolDir(sdir, sizeof(sdir));
  }
#line 107
  if (tmp < 0) {
#line 108
    return (-1);
  }
#line 109
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
void Jobs(void) 
{ 
  char *argv[8] ;
  pid_t pid ;
  char ncftpbatch[256] ;

  {
  {
#line 127
  Strncpy((char */* const  */)(ncftpbatch), (char const   */* const  */)"/usr/local/bin",
          (size_t const   )sizeof(ncftpbatch));
#line 131
  Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"/", (size_t const   )sizeof(ncftpbatch));
#line 132
  Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"ncftpbatch",
          (size_t const   )sizeof(ncftpbatch));
#line 135
  pid = fork();
  }
#line 136
  if (pid < 0) {
    {
#line 137
    perror("fork");
    }
  } else
#line 138
  if (pid == 0) {
    {
#line 139
    argv[0] = strdup("ncftpbatch");
#line 140
    argv[1] = strdup("-l");
#line 141
    argv[2] = (char *)((void *)0);
#line 144
    execv((char const   *)(ncftpbatch), (char * const  *)(argv));
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not run %s.  Is it in installed as %s?\n",
            argv[0], ncftpbatch);
#line 150
    perror((char const   *)argv[0]);
#line 151
    exit(1);
    }
  } else {
    {
#line 154
    waitpid(pid, (int *)((void *)0), 0);
    }
  }
#line 160
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
void RunBatchWithCore(FTPCIPtr const   cip ) 
{ 
  int pfd[2] ;
  char pfdstr[32] ;
  char *argv[8] ;
  pid_t pid ;
  char ncftpbatch[256] ;
  int tmp ;

  {
  {
#line 174
  pid = 0;
#line 179
  Strncpy((char */* const  */)(ncftpbatch), (char const   */* const  */)"/usr/local/bin",
          (size_t const   )sizeof(ncftpbatch));
#line 183
  Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"/", (size_t const   )sizeof(ncftpbatch));
#line 184
  Strncat((char */* const  */)(ncftpbatch), (char const   */* const  */)"ncftpbatch",
          (size_t const   )sizeof(ncftpbatch));
#line 187
  tmp = pipe((int *)(pfd));
  }
#line 187
  if (tmp < 0) {
    {
#line 188
    perror("pipe");
    }
  }
  {
#line 191
  sprintf((char */* __restrict  */)(pfdstr), (char const   */* __restrict  */)"%d",
          pfd[0]);
#line 192
  pid = fork();
  }
#line 193
  if (pid < 0) {
    {
#line 194
    close(pfd[0]);
#line 195
    close(pfd[1]);
#line 196
    perror("fork");
    }
  } else
#line 197
  if (pid == 0) {
    {
#line 198
    close(pfd[1]);
#line 199
    argv[0] = strdup("ncftpbatch");
#line 208
    argv[1] = strdup("-d");
#line 209
    argv[2] = strdup("-|");
#line 210
    argv[3] = strdup((char const   *)(pfdstr));
#line 211
    argv[4] = (char *)((void *)0);
#line 215
    execv((char const   *)(ncftpbatch), (char * const  *)(argv));
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not run %s.  Is it in installed as %s?\n",
            argv[0], ncftpbatch);
#line 221
    perror((char const   *)argv[0]);
#line 222
    exit(1);
    }
  }
  {
#line 224
  close(pfd[0]);
#line 225
  PWrite(pfd[1], (char const   */* const  */)((char const   *)cip->lip), sizeof(FTPLibraryInfo ));
#line 226
  PWrite(pfd[1], (char const   */* const  */)((char const   *)cip), sizeof(FTPConnectionInfo ));
#line 227
  close(pfd[1]);
#line 233
  FTPCloseControlConnection(cip);
  }
#line 235
  if (pid > 1) {
    {
#line 237
    waitpid(pid, (int *)((void *)0), 0);
    }
  }
#line 243
  return;
}
}
#line 247 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/spool.c"
void RunBatchIfNeeded(FTPCIPtr const   cip ) 
{ 
  char const   *tmp ;

  {
#line 250
  if (gUnprocessedJobs > 0) {
#line 252
    if (gUnprocessedJobs > 0) {
#line 252
      tmp = "s";
    } else {
#line 252
      tmp = "";
    }
    {
#line 252
    Trace((int const   )0, (char const   */* const  */)"Running ncftp_batch for %d job%s.\n",
          gUnprocessedJobs, tmp);
#line 253
    gUnprocessedJobs = 0;
#line 254
    RunBatchWithCore(cip);
    }
  }
#line 260
  return;
}
}
#line 957 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
double FTPDuration(struct timeval *t0 ) ;
#line 26 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
double FTPDuration(struct timeval *t0 ) 
{ 
  struct timeval t1 ;
  double sec ;

  {
  {
#line 32
  gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
  }
#line 33
  if (t0->tv_usec > t1.tv_usec) {
#line 34
    t1.tv_usec += 1000000L;
#line 35
    (t1.tv_sec) --;
  }
#line 37
  sec = (double )(t1.tv_usec - t0->tv_usec) * 0.000001 + (double )(t1.tv_sec - t0->tv_sec);
#line 40
  return (sec);
}
}
#line 46 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void FTPInitIOTimer(FTPCIPtr const   cip ) 
{ 


  {
  {
#line 49
  cip->bytesTransferred = 0LL;
#line 50
  cip->expectedSize = -1LL;
#line 51
  cip->mdtm = (time_t )-1;
#line 52
  cip->rname = (char const   *)((void *)0);
#line 53
  cip->lname = (char const   *)((void *)0);
#line 54
  cip->kBytesPerSec = - 1.0;
#line 55
  cip->percentCompleted = - 1.0;
#line 56
  cip->sec = - 1.0;
#line 57
  cip->secLeft = - 1.0;
#line 58
  cip->nextProgressUpdate = (time_t )0;
#line 59
  cip->stalled = 0;
#line 60
  cip->dataTimedOut = 0;
#line 61
  cip->useProgressMeter = 1;
#line 62
  gettimeofday((struct timeval */* __restrict  */)(& cip->t0), (__timezone_ptr_t )((void *)0));
  }
#line 63
  return;
}
}
#line 68 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void FTPStartIOTimer(FTPCIPtr const   cip ) 
{ 


  {
  {
#line 71
  gettimeofday((struct timeval */* __restrict  */)(& cip->t0), (__timezone_ptr_t )((void *)0));
  }
#line 72
  if ((unsigned long )cip->progress != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                  int  ))0)) {
    {
#line 73
    (*(cip->progress))(cip, 1);
    }
  }
#line 74
  return;
}
}
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void FTPUpdateIOTimer(FTPCIPtr const   cip ) 
{ 
  double sec ;
  struct timeval *t0 ;
  struct timeval t1 ;
  time_t now ;

  {
  {
#line 86
  time(& now);
  }
#line 87
  if (now < cip->nextProgressUpdate) {
#line 87
    if (cip->canceling == 0) {
#line 88
      return;
    }
  }
  {
#line 89
  now ++;
#line 90
  cip->nextProgressUpdate = now;
#line 92
  gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
#line 93
  t0 = & cip->t0;
  }
#line 95
  if (t0->tv_usec > t1.tv_usec) {
#line 96
    t1.tv_usec += 1000000L;
#line 97
    (t1.tv_sec) --;
  }
#line 99
  sec = (double )(t1.tv_usec - t0->tv_usec) * 0.000001 + (double )(t1.tv_sec - t0->tv_sec);
#line 101
  if (sec > 0.0) {
#line 102
    cip->kBytesPerSec = (double )cip->bytesTransferred / (1024.0 * sec);
  } else {
#line 104
    cip->kBytesPerSec = - 1.0;
  }
#line 106
  if (cip->expectedSize == -1LL) {
#line 107
    cip->percentCompleted = - 1.0;
#line 108
    cip->secLeft = - 1.0;
  } else
#line 109
  if (cip->expectedSize <= 0LL) {
#line 110
    cip->percentCompleted = 100.0;
#line 111
    cip->secLeft = 0.0;
  } else {
#line 113
    cip->percentCompleted = (100.0 * (double )(cip->bytesTransferred + cip->startPoint)) / (double )cip->expectedSize;
#line 114
    if (cip->percentCompleted >= 100.0) {
#line 115
      cip->percentCompleted = 100.0;
#line 116
      cip->secLeft = 0.0;
    } else
#line 117
    if (cip->percentCompleted <= 0.0) {
#line 118
      cip->secLeft = 999.0;
    }
#line 120
    if (cip->kBytesPerSec > 0.0) {
#line 121
      cip->secLeft = ((double )((cip->expectedSize - cip->bytesTransferred) - cip->startPoint) / 1024.0) / cip->kBytesPerSec;
#line 122
      if (cip->secLeft < 0.0) {
#line 123
        cip->secLeft = 0.0;
      }
    }
  }
#line 126
  cip->sec = sec;
#line 127
  if ((unsigned long )cip->progress != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                  int  ))0)) {
#line 127
    if (cip->useProgressMeter != 0) {
      {
#line 128
      (*(cip->progress))(cip, 2);
      }
    }
  }
#line 129
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void FTPStopIOTimer(FTPCIPtr const   cip ) 
{ 


  {
  {
#line 137
  cip->nextProgressUpdate = (time_t )0;
#line 138
  FTPUpdateIOTimer(cip);
  }
#line 139
  if ((unsigned long )cip->progress != (unsigned long )((void (*)(FTPCIPtr const    ,
                                                                  int  ))0)) {
    {
#line 140
    (*(cip->progress))(cip, 3);
    }
  }
#line 141
  return;
}
}
#line 149 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
int WaitForRemoteInput(FTPCIPtr const   cip ) 
{ 
  fd_set ss ;
  fd_set ss2 ;
  struct timeval tv ;
  int result ;
  int fd ;
  int wsecs ;
  int xferTimeout ;
  int ocancelXfer ;
  int __d0 ;
  int __d1 ;
  int *tmp ;

  {
#line 160
  xferTimeout = (int )cip->xferTimeout;
#line 161
  if (xferTimeout < 1) {
#line 162
    return (1);
  }
#line 164
  fd = cip->dataSocket;
#line 165
  if (fd < 0) {
#line 166
    return (1);
  }
#line 168
  if (cip->dataTimedOut > 0) {
#line 169
    (cip->dataTimedOut) ++;
#line 170
    return (0);
  }
#line 173
  ocancelXfer = cip->cancelXfer;
#line 174
  wsecs = 0;
#line 175
  cip->stalled = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (xferTimeout <= 0)) {
#line 177
      if (! (wsecs < xferTimeout)) {
#line 177
        goto while_break;
      }
    }
#line 178
    if (cip->cancelXfer != 0) {
#line 178
      if (ocancelXfer == 0) {
#line 180
        return (1);
      }
    }
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 182
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 187
    ss.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 191
    ss2 = ss;
#line 192
    tv.tv_sec = (__time_t )1;
#line 193
    tv.tv_usec = (__suseconds_t )0;
#line 194
    result = select(fd + 1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)(& tv));
    }
#line 195
    if (result >= 1) {
#line 197
      cip->stalled = 0;
#line 198
      return (1);
    } else
#line 199
    if (result < 0) {
      {
#line 200
      tmp = __errno_location();
      }
#line 200
      if (*tmp != 4) {
#line 201
        cip->stalled = 0;
#line 202
        return (1);
      }
    } else {
#line 205
      wsecs ++;
#line 206
      cip->stalled = wsecs;
    }
    {
#line 208
    FTPUpdateIOTimer(cip);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  (cip->dataTimedOut) ++;
#line 219
  return (0);
}
}
#line 228 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
int WaitForRemoteOutput(FTPCIPtr const   cip ) 
{ 
  fd_set ss ;
  fd_set ss2 ;
  struct timeval tv ;
  int result ;
  int fd ;
  int wsecs ;
  int xferTimeout ;
  int ocancelXfer ;
  int __d0 ;
  int __d1 ;
  int *tmp ;

  {
#line 239
  xferTimeout = (int )cip->xferTimeout;
#line 240
  if (xferTimeout < 1) {
#line 241
    return (1);
  }
#line 243
  fd = cip->dataSocket;
#line 244
  if (fd < 0) {
#line 245
    return (1);
  }
#line 247
  if (cip->dataTimedOut > 0) {
#line 248
    (cip->dataTimedOut) ++;
#line 249
    return (0);
  }
#line 252
  ocancelXfer = cip->cancelXfer;
#line 253
  wsecs = 0;
#line 254
  cip->stalled = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (xferTimeout <= 0)) {
#line 256
      if (! (wsecs < xferTimeout)) {
#line 256
        goto while_break;
      }
    }
#line 257
    if (cip->cancelXfer != 0) {
#line 257
      if (ocancelXfer == 0) {
#line 259
        return (1);
      }
    }
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 261
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 266
    ss.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 270
    ss2 = ss;
#line 271
    tv.tv_sec = (__time_t )1;
#line 272
    tv.tv_usec = (__suseconds_t )0;
#line 273
    result = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& ss),
                    (fd_set */* __restrict  */)(& ss2), (struct timeval */* __restrict  */)(& tv));
    }
#line 274
    if (result >= 1) {
#line 276
      cip->stalled = 0;
#line 277
      return (1);
    } else
#line 278
    if (result < 0) {
      {
#line 279
      tmp = __errno_location();
      }
#line 279
      if (*tmp != 4) {
#line 280
        cip->stalled = 0;
#line 281
        return (1);
      }
    } else {
#line 284
      wsecs ++;
#line 285
      cip->stalled = wsecs;
    }
    {
#line 287
    FTPUpdateIOTimer(cip);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  (cip->dataTimedOut) ++;
#line 298
  return (0);
}
}
#line 304 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void AutomaticallyUseASCIIModeDependingOnExtension(FTPCIPtr const   cip , char const   * const  pathName ,
                                                   int * const  xtype ) 
{ 
  int tmp ;

  {
#line 307
  if (*xtype == 73) {
#line 307
    if ((unsigned long )cip->asciiFilenameExtensions != (unsigned long )((void *)0)) {
      {
#line 308
      tmp = FilenameExtensionIndicatesASCII(pathName, (char const   */* const  */)cip->asciiFilenameExtensions);
      }
#line 308
      if (tmp) {
#line 313
        *xtype = 'A';
      }
    }
  }
#line 316
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void FTPCheckForRestartModeAvailability(FTPCIPtr const   cip ) 
{ 
  int tmp ;

  {
#line 323
  if (cip->hasREST == -1) {
    {
#line 324
    FTPSetTransferType(cip, 'I');
#line 325
    tmp = FTPSetStartOffset(cip, 1LL);
    }
#line 325
    if (tmp == 0) {
      {
#line 329
      FTPSetStartOffset(cip, -1LL);
      }
    }
  }
#line 332
  return;
}
}
#line 336 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/io_util.c"
void FTPSetUploadSocketBufferSize(FTPCIPtr const   cip ) 
{ 


  {
#line 352
  if (cip->numUploads == 0) {
#line 352
    if (cip->dataSocketSBufSize != 0UL) {
#line 353
      if (cip->hasSITE_STORBUFSIZE == 1) {
        {
#line 354
        FTPCmd(cip, (char const   */* const  */)"SITE STORBUFSIZE %lu", cip->dataSocketSBufSize);
        }
      } else
#line 355
      if (cip->hasSITE_SBUFSIZ == 1) {
        {
#line 356
        FTPCmd(cip, (char const   */* const  */)"SITE SBUFSIZ %lu", cip->dataSocketSBufSize);
        }
      } else
#line 357
      if (cip->hasSITE_SBUFSZ == 1) {
        {
#line 358
        FTPCmd(cip, (char const   */* const  */)"SITE SBUFSZ %lu", cip->dataSocketSBufSize);
        }
      } else
#line 362
      if (cip->hasSITE_SBUFSZ != 1) {
#line 362
        if (cip->hasSITE_RBUFSZ == 1) {
          {
#line 363
          FTPCmd(cip, (char const   */* const  */)"SITE RBUFSZ %lu", cip->dataSocketSBufSize);
          }
        } else {
#line 362
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 364
      if (cip->hasSITE_BUFSIZE == 1) {
        {
#line 365
        FTPCmd(cip, (char const   */* const  */)"SITE BUFSIZE %lu", cip->dataSocketSBufSize);
        }
      }
    }
  }
#line 367
  return;
}
}
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmdlist.c"
Command gCommands[65]  = 
#line 20 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmdlist.c"
  {      {"!", & ShellCmd, "[arguments]", "Runs a subshell", 1, -1, -1}, 
        {"?", & HelpCmd, "[optional commands]", "shows commands, or detailed help on specified commands",
      1, -1, -1}, 
        {"ascii", & TypeCmd, "", "sets the file transfer type to ASCII text", 2, 0, 0}, 
        {"bgget",
      & SpoolGetCmd, "[-flags] file1 [file2...]\nFlags:\n  -z   : Get the remote file file1, and name it to file2.\n  -@ <time> : Wait until <time> to do the transfer.\n              It must be expressed as one of the following:\n\t          YYYYMMDDHHMMSS\n\t          \"now + N hours|min|sec|days\"\n\t          HH:MM",
      "collects items to download later from the remote host", 10, 1, -1}, 
        {"bgput", & SpoolPutCmd, "[-flags] file1 [file2...]\nFlags:\n  -z   : Send the local file file1, and name the remote copy to file2.\n  -@ <time> : Wait until <time> to do the transfer.\n              It must be expressed as one of the following:\n\t          YYYYMMDDHHMMSS\n\t          \"now + N hours|min|sec|days\"\n\t          HH:MM",
      "collects items to upload later to the remote host", 34, 1, -1}, 
        {"bgstart", & BGStartCmd, "[n]", "starts a ncftpbatch process to process spooled files",
      0, 0, 1}, 
        {"binary", & TypeCmd, "", "sets the file transfer type to binary/image", 2, 0,
      0}, 
        {"bookmark", & BookmarkCmd, "[bookmark-name-to-save-as]", "Creates or updates a bookmark using the current host and directory",
      130, 0, 1}, 
        {"bookmarks", & HostsCmd, "[-l]", "lets you edit the settings for each bookmark",
      0, -1, -1}, 
        {"bye", & QuitCmd, "", "exits NcFTP", 1, 0, 0}, 
        {"cat", & CatCmd, "file1 [file2...]", "views a file from the remote host", 10,
      1, -1}, 
        {"cd", & ChdirCmd, "<directory>", "changes remote working directory", 18, 0,
      1}, 
        {"chmod", & ChmodCmd, "mode file1 [file2...]", "changes permissions for files on the remote host",
      10, 2, -1}, 
        {"close", & CloseCmd, "", "closes the connection to the remote host", 2, 0, 0}, 
        {"debug",
      & DebugCmd, "[debug level]", "sets debug mode to level x", 0, -1, -1}, 
        {"delete", & DeleteCmd, "file1 [file2...]", "deletes files from the remote host",
      11, 1, -1}, 
        {"dir", & ListCmd, "[items to list]", "prints a verbose directory listing", 26,
      -1, -1}, 
        {"echo", & EchoCmd, "[items to echo]", "echos back to screen", 97, -1, -1}, 
        {"edit", & EditCmd, "file1 [file2...]", "edit remote files", 10, 1, -1}, 
        {"exit", & QuitCmd, "", "quits NcFTP", 1, 0, 0}, 
        {"get", & GetCmd, "[-flags] file1 [file2...]\nFlags:\n  -R   : Recursive.  Useful for fetching whole directories.\n  -z   : Get the remote file file1, and name it to file2.\n  -a   : Get files using ASCII mode.\n  -A   : Append entire remote file to the local file.\n  -f   : Force overwrite (do not try to auto-resume transfers).\nExamples:\n  get README\n  get README.*\n  get \"**Name with stars and spaces in it**\"\n  get -R new-files-directory\n  get -z WIN.INI ~/junk/windows-init-file",
      "fetches files from the remote host", 10, 1, -1}, 
        {"help", & HelpCmd, "[optional commands]", "shows commands, or detailed help on specified commands",
      0, -1, -1}, 
        {"hosts", & HostsCmd, "", "lets you edit the settings for each remote host",
      5, -1, -1}, 
        {"jobs", & JobsCmd, "", "shows status of background NcFTP tasks", 0, 0, 0}, 
        {"lcd", & LocalChdirCmd, "<directory>", "changes local working directory", 64,
      -1, 1}, 
        {"lchmod", & LocalChmodCmd, "mode file1 [file2...]", "changes permissions for files on the local host",
      96, 2, -1}, 
        {"less", & PageCmd, "file1 [file2...]", "views a file from the remote host one page at a time",
      11, 1, -1}, 
        {"lls", & LocalListCmd, "[items to list]", "prints a local directory listing",
      64, -1, -1}, 
        {"lmkdir", & LocalMkdirCmd, "[directories]", "creates directories on the local host",
      0, 1, -1}, 
        {"lookup", & LookupCmd, "[-v|-V] <host or IP number> [<more hosts or IP numbers>]",
      "looks up information in the host database", 0, 1, -1}, 
        {"lpage", & LocalPageCmd, "file1 [file2...]", "views a file on the local host one page at a time",
      32, 1, -1}, 
        {"lpwd", & LocalPwdCmd, "", "Prints the current local working directory", 0,
      0, 0}, 
        {"lrename", & LocalRenameCmd, "oldname newname", "changes the name of a file on the local host",
      96, 2, 2}, 
        {"lrm", & LocalRmCmd, "[files]", "removes files on the local host", 96, 1, -1}, 
        {"lrmdir",
      & LocalRmdirCmd, "[directories]", "removes directories on the local host", 64,
      1, -1}, 
        {"ll", & ListCmd, "[items to list]", "prints a verbose directory listing", 27,
      -1, -1}, 
        {"ls", & ListCmd, "[items to list]", "prints a remote directory listing", 26,
      -1, -1}, 
        {"mget", & GetCmd, "[-flags] file1 [file2...]\nFlags:\n  -R   : Recursive.  Useful for fetching whole directories.\n  -z   : Get the remote file file1, and name it to file2.\n  -a   : Get files using ASCII mode.\n  -A   : Append entire remote file to the local file.\n  -f   : Force overwrite (do not try to auto-resume transfers).\nExamples:\n  get README\n  get README.*\n  get \"**Name with stars and spaces in it**\"\n  get -R new-files-directory\n  get -z WIN.INI ~/junk/windows-init-file",
      "fetches files from the remote host", 11, 1, -1}, 
        {"mkdir", & MkdirCmd, "dir1 [dir2...]", "creates directories on the remote host",
      2, 1, -1}, 
        {"mls", & MlsCmd, "[<directory to list> | -d <single item to list>]", "prints a machine-readable directory listing",
      19, -1, -1}, 
        {"more", & PageCmd, "file1 [file2...]", "views a file from the remote host one page at a time",
      11, 1, -1}, 
        {"mput", & PutCmd, "[-flags] file1 [file2...]\nFlags:\n  -z   : Send the local file file1, and name the remote copy to file2.\n  -f   : Force overwrite (do not try to auto-resume transfers).\n  -a   : Send files using ASCII mode.\n  -A   : Append entire local file to the remote file.\n  -R   : Recursive.  Useful for sending whole directories.\nExamples:\n  put README\n  put -z ~/junk/windows-init-file WIN.INI",
      "sends files to the remote host", 35, 1, -1}, 
        {"mv", & RenameCmd, "oldname newname", "changes the name of a file on the remote host",
      11, 2, 2}, 
        {"page", & PageCmd, "file1 [file2...]", "views a file from the remote host one page at a time",
      10, 1, -1}, 
        {"passive", & PassiveCmd, "", "Toggles passive transfer mode", 0, 0, 0}, 
        {"open", & OpenCmd, "[-flags] [sitename]\nFlags:\n  -a    : Open anonymously.\n  -u XX : Login with username XX.\n  -p XX : Login with password XX.\n  -j XX : Login with account XX.\n  -P XX : Use port number X when opening.\nExamples:\n  open sphygmomanometer.unl.edu\n  open -u mario bowser.nintendo.co.jp\n",
      "connects to a remote host", 128, -1, -1}, 
        {"pdir", & ListCmd, "[items to list]", "views a directory listing through your pager",
      18, -1, -1}, 
        {"pls", & ListCmd, "[items to list]", "views a directory listing through your pager",
      18, -1, -1}, 
        {"prefs", & SetCmd, "", "shows the program\'s settings", 1, 0, 0}, 
        {"put", & PutCmd, "[-flags] file1 [file2...]\nFlags:\n  -z   : Send the local file file1, and name the remote copy to file2.\n  -f   : Force overwrite (do not try to auto-resume transfers).\n  -a   : Send files using ASCII mode.\n  -A   : Append entire local file to the remote file.\n  -R   : Recursive.  Useful for sending whole directories.\nExamples:\n  put README\n  put -z ~/junk/windows-init-file WIN.INI",
      "sends a file to the remote host", 34, 1, -1}, 
        {"pwd", & PwdCmd, "", "Prints the current remote working directory", 2, 0, 0}, 
        {"quit",
      & QuitCmd, "", "take a wild guess", 0, 0, 0}, 
        {"quote", & QuoteCmd, "command-string", "sends an FTP command to the remote server",
      2, 1, -1}, 
        {"rename", & RenameCmd, "oldname newname", "changes the name of a file on the remote host",
      10, 2, 2}, 
        {"rglob", & RGlobCmd, "regex", "tests remote filename wildcard matching", 3,
      1, -1}, 
        {"rhelp", & RmtHelpCmd, "[help string]", "requests help from the remote server",
      2, -1, -1}, 
        {"rm", & DeleteCmd, "[-r] file1 [file2...]", "deletes files from the remote host",
      10, 1, -1}, 
        {"rmdir", & RmdirCmd, "dir1 [dir2...]", "deletes directories from the remote host",
      18, 1, -1}, 
        {"set", & SetCmd, "[option [newvalue]]", "lets you configure a program setting from the command line",
      256, 0, 2}, 
        {"show", & SetCmd, "[option]", "shows one or more the program\'s settings", 256,
      0, 1}, 
        {"site", & SiteCmd, "command-string", "sends a host-specific FTP command to the remote server",
      2, 1, -1}, 
        {"symlink", & SymlinkCmd, "existing-item link-item", "creates a symbolic link on the remote host",
      11, 2, 2}, 
        {"type", & TypeCmd, "[ascii | binary | image]", "sets file transfer type (one of \'ascii\' or \'binary\')",
      2, 0, 1}, 
        {"umask", & UmaskCmd, "mask", "sets the process umask on remote host", 2, 1,
      1}, 
        {"version", & VersionCmd, "", "prints version information", 0, -1, -1}};
#line 562 "/home/wheatley/newnew/temp/ncftp-3.2.5/ncftp/cmdlist.c"
size_t gNumCommands  =    sizeof(gCommands) / sizeof(Command );
#line 194 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/sio.h"
int PRead(int sfd , char * const  buf0 , size_t size , int retry ) ;
#line 17 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/PRead.c"
int PRead(int sfd , char * const  buf0 , size_t size , int retry ) 
{ 
  ssize_t nread ;
  size_t nleft ;
  char *buf ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 22
  buf = (char *)buf0;
#line 23
  sigpipe = (void (*)(int  ))0;
#line 25
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 26
    tmp = __errno_location();
#line 26
    *tmp = 22;
    }
#line 27
    return (-1);
  } else
#line 25
  if (size == 0UL) {
    {
#line 26
    tmp = __errno_location();
#line 26
    *tmp = 22;
    }
#line 27
    return (-1);
  }
#line 30
  if (sio_sigpipe_ignored_already) {
#line 30
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 30
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 30
    sigpipe = tmp___0;
    }
  }
  {
#line 31
  tmp___1 = __errno_location();
#line 31
  *tmp___1 = 0;
#line 32
  nleft = size;
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 34
    nread = read(sfd, (void *)buf, nleft);
    }
#line 35
    if (nread <= 0L) {
#line 36
      if (nread == 0L) {
#line 38
        nread = (ssize_t )size - (ssize_t )nleft;
#line 39
        goto done;
      } else {
        {
#line 40
        tmp___3 = __errno_location();
        }
#line 40
        if (*tmp___3 != 4) {
#line 41
          nread = (ssize_t )size - (ssize_t )nleft;
#line 42
          if (nread == 0L) {
#line 43
            nread = (ssize_t )-1;
          }
#line 44
          goto done;
        } else {
          {
#line 46
          tmp___2 = __errno_location();
#line 46
          *tmp___2 = 0;
#line 47
          nread = (ssize_t )0;
          }
        }
      }
    }
#line 51
    nleft -= (size_t )nread;
#line 52
    if (nleft == 0UL) {
#line 53
      goto while_break;
    } else
#line 52
    if (retry == 0) {
#line 53
      goto while_break;
    }
#line 54
    buf += nread;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  nread = (ssize_t )size - (ssize_t )nleft;
  done: 
#line 59
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 59
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 59
      signal(13, sigpipe);
      }
    }
  }
#line 60
  return ((int )nread);
}
}
#line 6 "/home/wheatley/newnew/temp/ncftp-3.2.5/sio/PWrite.c"
int PWrite(int sfd , char const   * const  buf0 , size_t size ) 
{ 
  ssize_t nwrote ;
  size_t nleft ;
  char const   *buf ;
  void (*sigpipe)(int  ) ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 11
  buf = (char const   *)buf0;
#line 12
  sigpipe = (void (*)(int  ))0;
#line 14
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 15
    tmp = __errno_location();
#line 15
    *tmp = 22;
    }
#line 16
    return (-1);
  } else
#line 14
  if (size == 0UL) {
    {
#line 15
    tmp = __errno_location();
#line 15
    *tmp = 22;
    }
#line 16
    return (-1);
  }
#line 19
  if (sio_sigpipe_ignored_already) {
#line 19
    sigpipe = (void (*)(int  ))0;
  } else {
    {
#line 19
    tmp___0 = signal(13, (void (*)(int  ))1);
#line 19
    sigpipe = tmp___0;
    }
  }
#line 20
  nleft = size;
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 22
    nwrote = write(sfd, (void const   *)buf, nleft);
    }
#line 23
    if (nwrote < 0L) {
      {
#line 24
      tmp___2 = __errno_location();
      }
#line 24
      if (*tmp___2 != 4) {
#line 25
        nwrote = (ssize_t )size - (ssize_t )nleft;
#line 26
        if (nwrote == 0L) {
#line 27
          nwrote = (ssize_t )-1;
        }
#line 28
        goto done;
      } else {
        {
#line 30
        tmp___1 = __errno_location();
#line 30
        *tmp___1 = 0;
#line 31
        nwrote = (ssize_t )0;
        }
      }
    }
#line 35
    nleft -= (size_t )nwrote;
#line 36
    if (nleft == 0UL) {
#line 37
      goto while_break;
    }
#line 38
    buf += nwrote;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  nwrote = (ssize_t )size - (ssize_t )nleft;
  done: 
#line 43
  if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))0)) {
#line 43
    if ((unsigned long )sigpipe != (unsigned long )((void (*)(int  ))1)) {
      {
#line 43
      signal(13, sigpipe);
      }
    }
  }
#line 44
  return ((int )nwrote);
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 1060 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ncftp.h"
int FTPRebuildConnectionInfo(FTPLIPtr const   lip , FTPCIPtr const   cip ) ;
#line 13 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/u_rebuildci.c"
int FTPRebuildConnectionInfo(FTPLIPtr const   lip , FTPCIPtr const   cip ) 
{ 
  char *buf ;
  void *tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 18
  cip->lip = (FTPLIPtr )lip;
#line 19
  cip->debugLog = (FILE *)((void *)0);
#line 20
  cip->errLog = (FILE *)((void *)0);
#line 21
  cip->debugLogProc = (void (*)(FTPCIPtr const    , char * ))((void *)0);
#line 22
  cip->errLogProc = (void (*)(FTPCIPtr const    , char * ))((void *)0);
#line 23
  cip->buf = (char *)((void *)0);
#line 24
  cip->cin = (FILE *)((void *)0);
#line 25
  cip->cout = (FILE *)((void *)0);
#line 26
  cip->errNo = 0;
#line 27
  cip->progress = (void (*)(FTPCIPtr const    , int  ))((void *)0);
#line 28
  cip->rname = (char const   *)((void *)0);
#line 29
  cip->lname = (char const   *)((void *)0);
#line 30
  cip->onConnectMsgProc = (void (*)(FTPCIPtr const    , ResponsePtr  ))((void *)0);
#line 31
  cip->redialStatusProc = (void (*)(FTPCIPtr const    , int  , int  ))((void *)0);
#line 32
  cip->printResponseProc = (void (*)(FTPCIPtr const    , ResponsePtr  ))((void *)0);
#line 33
  cip->onLoginMsgProc = (void (*)(FTPCIPtr const    , ResponsePtr  ))((void *)0);
#line 34
  cip->passphraseProc = (void (*)(FTPCIPtr const    , FTPLineListPtr pwPrompt , char *pass ,
                                  size_t dsize ))((void *)0);
#line 35
  cip->startingWorkingDirectory = (char *)((void *)0);
#line 36
  cip->asciiFilenameExtensions = (char const   *)((void *)0);
#line 37
  cip->dataTimedOut = 0;
#line 39
  memset((void *)(& cip->lastFTPCmdResultLL), 0, sizeof(FTPLineList ));
#line 42
  tmp = calloc((size_t )1, cip->bufSize);
#line 42
  buf = (char *)tmp;
  }
#line 43
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 44
    cip->errNo = -123;
#line 45
    return (-123);
  }
  {
#line 47
  cip->buf = buf;
#line 52
  tmp___0 = fdopen(cip->ctrlSocketR, "r");
#line 52
  cip->cin = tmp___0;
  }
#line 52
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 53
    cip->errNo = -108;
#line 54
    cip->ctrlSocketR = -1;
#line 55
    cip->ctrlSocketW = -1;
#line 56
    return (-108);
  }
  {
#line 59
  tmp___1 = fdopen(cip->ctrlSocketW, "w");
#line 59
  cip->cout = tmp___1;
  }
#line 59
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 60
    CloseFile(& cip->cin);
#line 61
    cip->errNo = -109;
#line 62
    cip->ctrlSocketR = -1;
#line 63
    cip->ctrlSocketW = -1;
    }
#line 64
    return (-109);
  }
  {
#line 68
  tmp___2 = InitSReadlineInfo(& cip->ctrlSrl, cip->ctrlSocketR, cip->srlBuf, sizeof(cip->srlBuf),
                              (int )cip->ctrlTimeout, 1);
  }
#line 68
  if (tmp___2 < 0) {
    {
#line 69
    cip->errNo = -109;
#line 70
    CloseFile(& cip->cin);
#line 71
    cip->errNo = -109;
#line 72
    cip->ctrlSocketR = -1;
#line 73
    cip->ctrlSocketW = -1;
    }
#line 74
    return (-109);
  }
#line 77
  return (0);
}
}
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64EncodeTable___3[64]  = 
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64DecodeTable___3[256]  = 
#line 50
  {      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'>', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'?', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'@',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\002', 
        (unsigned char const   )'\003',      (unsigned char const   )'\004',      (unsigned char const   )'\005',      (unsigned char const   )'\006', 
        (unsigned char const   )'\a',      (unsigned char const   )'\b',      (unsigned char const   )'\t',      (unsigned char const   )'\n', 
        (unsigned char const   )'\v',      (unsigned char const   )'\f',      (unsigned char const   )'\r',      (unsigned char const   )'\016', 
        (unsigned char const   )'\017',      (unsigned char const   )'\020',      (unsigned char const   )'\021',      (unsigned char const   )'\022', 
        (unsigned char const   )'\023',      (unsigned char const   )'\024',      (unsigned char const   )'\025',      (unsigned char const   )'\026', 
        (unsigned char const   )'\027',      (unsigned char const   )'\030',      (unsigned char const   )'\031',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\032',      (unsigned char const   )'\033',      (unsigned char const   )'\034', 
        (unsigned char const   )'\035',      (unsigned char const   )'\036',      (unsigned char const   )'\037',      (unsigned char const   )' ', 
        (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#',      (unsigned char const   )'$', 
        (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )'\'',      (unsigned char const   )'(', 
        (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+',      (unsigned char const   )',', 
        (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/',      (unsigned char const   )'0', 
        (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177'};
#line 648 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static void CancelGetHostByName___3(int sigNum ) 
{ 
  int tmp ;

  {
#line 655
  if (sigNum != 0) {
#line 655
    tmp = 1;
  } else {
#line 655
    tmp = 0;
  }
  {
#line 655
  siglongjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), tmp);
  }
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int HexCharToNibble___3(int c ) 
{ 


  {
  {
#line 109
  if (c == 57) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 56) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 55) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 54) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 53) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 52) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 51) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 50) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 49) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 48) {
#line 109
    goto case_57;
  }
#line 116
  if (c == 102) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 101) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 100) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 99) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 98) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 97) {
#line 116
    goto case_102;
  }
#line 123
  if (c == 70) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 69) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 68) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 67) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 66) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 65) {
#line 123
    goto case_70;
  }
#line 99
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 110
  return (c - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 117
  return ((c - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 124
  return ((c - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
#line 127
  return (-1);
}
}
#line 495 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSortProc___3(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = strcasecmp((char const   *)(((Bookmark const   *)a)->bookmarkName), (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 498
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSearchProc___3(void const   *key , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = strcasecmp((char const   *)key, (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 506
  return (tmp);
}
}
#line 578 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static char *BmEscapeTok___3(char *dst , size_t dsize , char *src ) 
{ 
  char *dlim ;
  char *dst0 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 581
  dlim = (dst + dsize) - 1;
#line 582
  dst0 = dst;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    c = (int )*src;
#line 585
    if (! (c != 0)) {
#line 585
      goto while_break;
    }
#line 586
    src ++;
#line 587
    if (c == 92) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 44) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 36) {
      _L: /* CIL Label */ 
#line 589
      if ((unsigned long )(dst + 1) < (unsigned long )dlim) {
#line 590
        tmp = dst;
#line 590
        dst ++;
#line 590
        *tmp = (char )'\\';
#line 591
        tmp___0 = dst;
#line 591
        dst ++;
#line 591
        *tmp___0 = (char )c;
      }
    } else {
      {
#line 593
      tmp___2 = __ctype_b_loc();
      }
#line 593
      if ((int const   )*(*tmp___2 + c) & 16384) {
#line 600
        if ((unsigned long )dst < (unsigned long )dlim) {
#line 601
          tmp___1 = dst;
#line 601
          dst ++;
#line 601
          *tmp___1 = (char )c;
        }
      } else
#line 595
      if ((unsigned long )(dst + 2) < (unsigned long )dlim) {
        {
#line 596
        sprintf((char */* __restrict  */)dst, (char const   */* __restrict  */)"$%02x",
                c);
#line 597
        dst += 3;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *dst = (char )'\000';
#line 605
  return (dst0);
}
}
#line 614 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int WriteBmLine___3(Bookmark *bmp , FILE *outfp , int savePassword ) 
{ 
  char tok[256] ;
  char pass[160] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 620
  tmp = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s",
                bmp->bookmarkName);
  }
#line 620
  if (tmp < 0) {
#line 620
    return (-1);
  }
  {
#line 621
  tmp___0 = BmEscapeTok___3(tok, sizeof(tok), bmp->name);
#line 621
  tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___0);
  }
#line 621
  if (tmp___1 < 0) {
#line 621
    return (-1);
  }
  {
#line 622
  tmp___2 = BmEscapeTok___3(tok, sizeof(tok), bmp->user);
#line 622
  tmp___3 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___2);
  }
#line 622
  if (tmp___3 < 0) {
#line 622
    return (-1);
  }
#line 623
  if ((int )bmp->pass[0] != 0) {
#line 623
    if (savePassword == 1) {
      {
#line 624
      memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
             (size_t )9);
#line 625
      tmp___4 = strlen((char const   *)(bmp->pass));
#line 625
      ToBase64((void *)(pass + 9), (void const   *)(bmp->pass), tmp___4, 1);
#line 626
      tmp___5 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                        pass);
      }
#line 626
      if (tmp___5 < 0) {
#line 626
        return (-1);
      }
    } else {
#line 623
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 628
    tmp___6 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                      "");
    }
#line 628
    if (tmp___6 < 0) {
#line 628
      return (-1);
    }
  }
  {
#line 630
  tmp___7 = BmEscapeTok___3(tok, sizeof(tok), bmp->acct);
#line 630
  tmp___8 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___7);
  }
#line 630
  if (tmp___8 < 0) {
#line 630
    return (-1);
  }
  {
#line 631
  tmp___9 = BmEscapeTok___3(tok, sizeof(tok), bmp->dir);
#line 631
  tmp___10 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___9);
  }
#line 631
  if (tmp___10 < 0) {
#line 631
    return (-1);
  }
  {
#line 632
  tmp___11 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferType);
  }
#line 632
  if (tmp___11 < 0) {
#line 632
    return (-1);
  }
  {
#line 633
  tmp___12 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%u",
                     bmp->port);
  }
#line 633
  if (tmp___12 < 0) {
#line 633
    return (-1);
  }
  {
#line 634
  tmp___13 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%lu",
                     (unsigned long )bmp->lastCall);
  }
#line 634
  if (tmp___13 < 0) {
#line 634
    return (-1);
  }
  {
#line 635
  tmp___14 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasSIZE);
  }
#line 635
  if (tmp___14 < 0) {
#line 635
    return (-1);
  }
  {
#line 636
  tmp___15 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasMDTM);
  }
#line 636
  if (tmp___15 < 0) {
#line 636
    return (-1);
  }
  {
#line 637
  tmp___16 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasPASV);
  }
#line 637
  if (tmp___16 < 0) {
#line 637
    return (-1);
  }
  {
#line 638
  tmp___17 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->isUnix);
  }
#line 638
  if (tmp___17 < 0) {
#line 638
    return (-1);
  }
  {
#line 639
  tmp___18 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     bmp->lastIP);
  }
#line 639
  if (tmp___18 < 0) {
#line 639
    return (-1);
  }
  {
#line 640
  tmp___19 = BmEscapeTok___3(tok, sizeof(tok), bmp->comment);
#line 640
  tmp___20 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___19);
  }
#line 640
  if (tmp___20 < 0) {
#line 640
    return (-1);
  }
  {
#line 641
  tmp___21 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 641
  if (tmp___21 < 0) {
#line 641
    return (-1);
  }
  {
#line 642
  tmp___22 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 642
  if (tmp___22 < 0) {
#line 642
    return (-1);
  }
  {
#line 643
  tmp___23 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 643
  if (tmp___23 < 0) {
#line 643
    return (-1);
  }
  {
#line 644
  tmp___24 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 644
  if (tmp___24 < 0) {
#line 644
    return (-1);
  }
  {
#line 645
  tmp___25 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferMode);
  }
#line 645
  if (tmp___25 < 0) {
#line 645
    return (-1);
  }
  {
#line 646
  tmp___26 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasUTIME);
  }
#line 646
  if (tmp___26 < 0) {
#line 646
    return (-1);
  }
  {
#line 647
  tmp___27 = BmEscapeTok___3(tok, sizeof(tok), bmp->ldir);
#line 647
  tmp___28 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___27);
  }
#line 647
  if (tmp___28 < 0) {
#line 647
    return (-1);
  }
  {
#line 648
  tmp___29 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n");
  }
#line 648
  if (tmp___29 < 0) {
#line 648
    return (-1);
  }
  {
#line 649
  tmp___30 = fflush(outfp);
  }
#line 649
  if (tmp___30 < 0) {
#line 649
    return (-1);
  }
#line 650
  return (0);
}
}
#line 655 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int SwapBookmarkFiles___3(void) 
{ 
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 661
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 662
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 666
  tmp = getpid();
#line 666
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 667
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 669
  remove((char const   *)(path2));
#line 670
  tmp___0 = rename((char const   *)(pathName), (char const   *)(path2));
  }
#line 670
  if (tmp___0 < 0) {
#line 671
    return (-1);
  }
#line 673
  return (0);
}
}
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty1___1  =    1;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty2___1  =    1;
#line 78 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___6  ;
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___6  ;
#line 183 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___7  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uTotal___2  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___7  ;
#line 542 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gUsrBinFTPCommands___1[25]  = 
#line 542
  {      "cd ..",      "cd",      "mkdir",      "md", 
        "rmdir",      "rm",      "del",      "delete", 
        "ascii",      "binary",      "bye",      "quit", 
        "exit",      "close",      "dir",      "ls", 
        "mls",      "chmod",      "chown",      "chgrp", 
        "pwd",      "quote",      "ln -s",      "umask", 
        (char const   *)((void *)0)};
#line 570 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gValidFTPProtocolCommands___1[25]  = 
#line 570
  {      "CDUP",      "CWD",      "MKD",      "MKD", 
        "RMD",      "DELE",      "DELE",      "DELE", 
        "TYPE A",      "TYPE I",      "QUIT",      "QUIT", 
        "QUIT",      "QUIT",      "STAT",      "STAT", 
        "MLST",      "SITE CHMOD",      "SITE CHOWN",      "SITE CHGRP", 
        "PWD",      "",      "SITE SYMLINK",      "SITE UMASK", 
        (char const   *)((void *)0)};
#line 37 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
static char *p___3  =    (char *)((void *)0);
#line 82 "/home/wheatley/newnew/temp/ncftp-3.2.5/Strn/Strntok.c"
static char *p___4  =    (char *)((void *)0);
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char const   copyright___1[59]  = 
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
  {      (char const   )'g',      (char const   )'l',      (char const   )'_',      (char const   )'g', 
        (char const   )'e',      (char const   )'t',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'1',      (char const   )',', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'2',      (char const   )',',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'3',      (char const   )',', 
        (char const   )' ',      (char const   )'C',      (char const   )'h',      (char const   )'r', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'e',      (char const   )'w',      (char const   )'a', 
        (char const   )'l',      (char const   )'t',      (char const   )'\000'};
#line 167
static int gl_tab___1(char *buf , int offset , int *loc , size_t bufsize ) ;
#line 185 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_killbuf___1[256]  ;
#line 186 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_init_done___1  =    -1;
#line 187 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_termw___1  =    80;
#line 188 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_termh___1  =    24;
#line 189 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_scroll___1  =    27;
#line 190 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_width___1  =    0;
#line 191 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_extent___1  =    0;
#line 192 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_overwrite___1  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_pos___1  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_cnt___1  =    0;
#line 194 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char const   *gl_prompt___1  ;
#line 195 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_intrc___1  =    (char)0;
#line 196 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_quitc___1  =    (char)0;
#line 197 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_suspc___1  =    (char)0;
#line 198 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_dsuspc___1  =    (char)0;
#line 199 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_search_mode___1  =    0;
#line 200 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char **gl_matchlist___1  =    (char **)0;
#line 201 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *gl_home_dir___1  =    (char *)((void *)0);
#line 202 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_vi_preferred___1  =    -1;
#line 203 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_vi_mode___1  =    0;
#line 204 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_result___1  =    0;
#line 206
static void gl_init___1(void) ;
#line 207
static void gl_cleanup___1(void) ;
#line 208
static void gl_char_init___1(void) ;
#line 209
static void gl_char_cleanup___1(void) ;
#line 212
static void gl_addchar___1(int c ) ;
#line 213
static void gl_del___1(int loc , int killsave ) ;
#line 214
static void gl_error___1(char const   * const  buf ) ;
#line 215
static void gl_fixup___1(char const   *prompt , int change , int cursor ) ;
#line 216
static int gl_getc___1(void) ;
#line 217
static int gl_getcx___1(int tlen ) ;
#line 218
static void gl_kill___1(int pos ) ;
#line 219
static void gl_newline___1(void) ;
#line 220
static void gl_putc___1(int c ) ;
#line 221
static void gl_puts___1(char const   *buf ) ;
#line 222
static void gl_redraw___1(void) ;
#line 223
static void gl_transpose___1(void) ;
#line 224
static void gl_yank___1(void) ;
#line 225
static void gl_word___1(int direction ) ;
#line 226
static void gl_killword___1(int direction ) ;
#line 228
static void hist_init___1(void) ;
#line 229
static void hist_dispose___1(void) ;
#line 230
static char *hist_next___1(void) ;
#line 231
static char *hist_prev___1(void) ;
#line 232
static char *hist_save___1(char const   * const  p___5 ) ;
#line 234
static void search_addchar___1(int c ) ;
#line 235
static void search_term___1(void) ;
#line 236
static void search_back___1(int new_search ) ;
#line 237
static void search_forw___1(int new_search ) ;
#line 238
static void gl_beep___1(void) ;
#line 240
static int gl_do_tab_completion___1(char *buf , int *loc , size_t bufsize , int tabtab ) ;
#line 248 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_char_init___1(void) 
{ 
  int tmp ;

  {
  {
#line 253
  tmp = tcgetattr(0, & old_termios);
  }
#line 253
  if (tmp == 0) {
#line 254
    gl_intrc___1 = (char )old_termios.c_cc[0];
#line 255
    gl_quitc___1 = (char )old_termios.c_cc[1];
#line 257
    gl_suspc___1 = (char )old_termios.c_cc[10];
  }
  {
#line 263
  new_termios = old_termios;
#line 264
  new_termios.c_iflag &= 4294962141U;
#line 265
  new_termios.c_iflag |= 5U;
#line 266
  new_termios.c_lflag &= 4294934516U;
#line 267
  new_termios.c_cc[6] = (cc_t )1;
#line 268
  new_termios.c_cc[5] = (cc_t )0;
#line 269
  tcsetattr(0, 0, (struct termios  const  *)(& new_termios));
  }
#line 297
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_char_cleanup___1(void) 
{ 


  {
  {
#line 304
  tcsetattr(0, 0, (struct termios  const  *)(& old_termios));
  }
#line 311
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_getc___1(void) 
{ 
  int c ;
  unsigned char ch ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 383
  ch = (unsigned char )'\000';
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 384
    tmp___0 = read(0, (void *)(& ch), (size_t )1);
#line 384
    c = (int )tmp___0;
    }
#line 384
    if (! (c == -1)) {
#line 384
      goto while_break;
    }
    {
#line 385
    tmp = __errno_location();
    }
#line 385
    if (*tmp != 4) {
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  if (c != -1) {
#line 389
    c = (int )ch;
  }
#line 412
  return (c);
}
}
#line 419 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_getcx___1(int tlen ) 
{ 
  int c ;
  int result ;
  char ch ;
  fd_set ss ;
  struct timeval tv ;
  int *tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 430
  tmp = __errno_location();
#line 430
  *tmp = 0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 431
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 436
    ss.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 440
    tv.tv_sec = (__time_t )((long long )(tlen / 10));
#line 441
    tv.tv_usec = (__suseconds_t )((long long )((tlen % 10) * 100000));
#line 442
    result = select(1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 443
    if (result == 1) {
#line 445
      goto while_break;
    } else
#line 446
    if (result == 0) {
      {
#line 447
      tmp___0 = __errno_location();
#line 447
      *tmp___0 = 110;
      }
#line 448
      return (-2);
    } else {
      {
#line 449
      tmp___1 = __errno_location();
      }
#line 449
      if (*tmp___1 != 4) {
#line 450
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp___2 = __errno_location();
#line 454
  *tmp___2 = 0;
  }
  {
#line 454
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 455
    tmp___3 = read(0, (void *)(& ch), (size_t )1);
#line 455
    c = (int )tmp___3;
    }
#line 456
    if (c == 1) {
#line 457
      return ((int )ch);
    }
    {
#line 458
    tmp___4 = __errno_location();
    }
#line 458
    if (*tmp___4 != 4) {
#line 459
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 462
  return (-1);
}
}
#line 501 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_putc___1(int c ) 
{ 
  char ch ;

  {
  {
#line 504
  ch = (char )((unsigned char )c);
#line 506
  write(1, (void const   *)(& ch), (size_t )1);
  }
#line 507
  if ((int )ch == 10) {
    {
#line 508
    ch = (char )'\r';
#line 509
    write(1, (void const   *)(& ch), (size_t )1);
    }
  }
#line 511
  return;
}
}
#line 515 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_puts___1(char const   *buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
#line 554
  if (buf) {
    {
#line 555
    tmp = strlen(buf);
#line 555
    len = tmp;
#line 556
    write(1, (void const   *)buf, len);
    }
  }
#line 559
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_error___1(char const   * const  buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 564
  tmp = strlen((char const   *)buf);
#line 564
  len = tmp;
#line 566
  gl_cleanup___1();
#line 567
  write(2, (void const   *)buf, len);
#line 568
  exit(1);
  }
}
}
#line 571 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_init___1(void) 
{ 
  char const   *cp ;
  int w ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 579
  tmp = strncmp(copyright___1, "gl_getline", (size_t )7);
  }
#line 579
  if (tmp != 0) {
    {
#line 580
    exit(1);
    }
  }
#line 582
  if (gl_init_done___1 < 0) {
    {
#line 583
    tmp___0 = getenv("COLUMNS");
#line 583
    cp = (char const   *)tmp___0;
    }
#line 584
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 585
      w = atoi(cp);
      }
#line 586
      if (w > 20) {
        {
#line 587
        gl_setwidth(w);
        }
      }
    }
    {
#line 589
    tmp___1 = getenv("ROWS");
#line 589
    cp = (char const   *)tmp___1;
    }
#line 590
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 591
      w = atoi(cp);
      }
#line 592
      if (w > 10) {
        {
#line 593
        gl_setheight(w);
        }
      }
    }
    {
#line 595
    hist_init___1();
    }
  }
  {
#line 597
  tmp___2 = isatty(0);
  }
#line 597
  if (tmp___2 == 0) {
    {
#line 598
    gl_error___1((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
    }
  } else {
    {
#line 597
    tmp___3 = isatty(1);
    }
#line 597
    if (tmp___3 == 0) {
      {
#line 598
      gl_error___1((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
      }
    }
  }
  {
#line 599
  gl_char_init___1();
#line 600
  gl_init_done___1 = 1;
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_cleanup___1(void) 
{ 


  {
#line 607
  if (gl_init_done___1 > 0) {
    {
#line 608
    gl_char_cleanup___1();
    }
  }
#line 609
  gl_init_done___1 = 0;
#line 614
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_check_inputrc_for_vi___1(void) 
{ 
  FILE *fp ;
  char path[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 644
  gl_set_home_dir((char const   *)((void *)0));
  }
#line 645
  if ((unsigned long )gl_home_dir___1 == (unsigned long )((void *)0)) {
#line 646
    return;
  }
  {
#line 649
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s",
           gl_home_dir___1, ".inputrc");
#line 657
  fp = fopen((char const   */* __restrict  */)(path), (char const   */* __restrict  */)"r");
  }
#line 666
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 667
    return;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 669
    tmp___1 = fgets((char */* __restrict  */)(path), (int )(sizeof(path) - 1UL), (FILE */* __restrict  */)fp);
    }
#line 669
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 669
      goto while_break;
    }
    {
#line 670
    tmp = strstr((char const   *)(path), "editing-mode");
    }
#line 670
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 670
      tmp___0 = strstr((char const   *)(path), "vi");
      }
#line 670
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 671
        gl_vi_preferred___1 = 1;
#line 672
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  fclose(fp);
  }
#line 677
  return;
}
}
#line 1122 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_addchar___1(int c ) 
{ 
  int i___0 ;

  {
#line 1128
  if (gl_cnt___1 >= 2047) {
    {
#line 1129
    gl_error___1((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1130
  if (gl_overwrite___1 == 0) {
#line 1130
    goto _L;
  } else
#line 1130
  if (gl_pos___1 == gl_cnt___1) {
    _L: /* CIL Label */ 
#line 1131
    i___0 = gl_cnt___1;
    {
#line 1131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1131
      if (! (i___0 >= gl_pos___1)) {
#line 1131
        goto while_break;
      }
#line 1132
      gl_buf[i___0 + 1] = gl_buf[i___0];
#line 1131
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1133
    gl_buf[gl_pos___1] = (char )c;
#line 1134
    gl_fixup___1(gl_prompt___1, gl_pos___1, gl_pos___1 + 1);
    }
  } else {
    {
#line 1136
    gl_buf[gl_pos___1] = (char )c;
#line 1137
    gl_extent___1 = 1;
#line 1138
    gl_fixup___1(gl_prompt___1, gl_pos___1, gl_pos___1 + 1);
    }
  }
#line 1140
  return;
}
}
#line 1142 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_yank___1(void) 
{ 
  int i___0 ;
  int len ;
  size_t tmp ;

  {
  {
#line 1148
  tmp = strlen((char const   *)(gl_killbuf___1));
#line 1148
  len = (int )tmp;
  }
#line 1149
  if (len > 0) {
#line 1150
    if (gl_overwrite___1 == 0) {
#line 1151
      if (gl_cnt___1 + len >= 2047) {
        {
#line 1152
        gl_error___1((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
        }
      }
#line 1153
      i___0 = gl_cnt___1;
      {
#line 1153
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1153
        if (! (i___0 >= gl_pos___1)) {
#line 1153
          goto while_break;
        }
#line 1154
        gl_buf[i___0 + len] = gl_buf[i___0];
#line 1153
        i___0 --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1155
      i___0 = 0;
      {
#line 1155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1155
        if (! (i___0 < len)) {
#line 1155
          goto while_break___0;
        }
#line 1156
        gl_buf[gl_pos___1 + i___0] = gl_killbuf___1[i___0];
#line 1155
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1157
      gl_fixup___1(gl_prompt___1, gl_pos___1, gl_pos___1 + len);
      }
    } else {
#line 1159
      if (gl_pos___1 + len > gl_cnt___1) {
#line 1160
        if (gl_pos___1 + len >= 2047) {
          {
#line 1161
          gl_error___1((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
          }
        }
#line 1162
        gl_buf[gl_pos___1 + len] = (char)0;
      }
#line 1164
      i___0 = 0;
      {
#line 1164
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1164
        if (! (i___0 < len)) {
#line 1164
          goto while_break___1;
        }
#line 1165
        gl_buf[gl_pos___1 + i___0] = gl_killbuf___1[i___0];
#line 1164
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1166
      gl_extent___1 = len;
#line 1167
      gl_fixup___1(gl_prompt___1, gl_pos___1, gl_pos___1 + len);
      }
    }
  } else {
    {
#line 1170
    gl_beep___1();
    }
  }
#line 1171
  return;
}
}
#line 1173 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_transpose___1(void) 
{ 
  int c ;

  {
#line 1179
  if (gl_pos___1 > 0) {
#line 1179
    if (gl_cnt___1 > gl_pos___1) {
      {
#line 1180
      c = (int )gl_buf[gl_pos___1 - 1];
#line 1181
      gl_buf[gl_pos___1 - 1] = gl_buf[gl_pos___1];
#line 1182
      gl_buf[gl_pos___1] = (char )c;
#line 1183
      gl_extent___1 = 2;
#line 1184
      gl_fixup___1(gl_prompt___1, gl_pos___1 - 1, gl_pos___1);
      }
    } else {
      {
#line 1186
      gl_beep___1();
      }
    }
  } else {
    {
#line 1186
    gl_beep___1();
    }
  }
#line 1187
  return;
}
}
#line 1189 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_newline___1(void) 
{ 
  int change ;
  int len ;
  int loc ;
  size_t tmp ;

  {
#line 1196
  change = gl_cnt___1;
#line 1197
  len = gl_cnt___1;
#line 1198
  loc = gl_width___1 - 5;
#line 1200
  if (gl_cnt___1 >= 2047) {
    {
#line 1201
    gl_error___1((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1202
  if (gl_out_hook) {
    {
#line 1203
    change = (*gl_out_hook)(gl_buf);
#line 1204
    tmp = strlen((char const   *)(gl_buf));
#line 1204
    len = (int )tmp;
    }
  }
#line 1206
  if (loc > len) {
#line 1207
    loc = len;
  }
  {
#line 1208
  gl_fixup___1(gl_prompt___1, change, loc);
#line 1209
  gl_buf[len] = (char )'\n';
#line 1210
  gl_buf[len + 1] = (char )'\000';
#line 1211
  gl_putc___1('\n');
  }
#line 1212
  return;
}
}
#line 1214 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_del___1(int loc , int killsave ) 
{ 
  int i___0 ;
  int j ;

  {
#line 1225
  if (loc == -1) {
#line 1225
    if (gl_pos___1 > 0) {
#line 1225
      goto _L;
    } else {
#line 1225
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1225
  if (loc == 0) {
#line 1225
    if (gl_pos___1 < gl_cnt___1) {
      _L: /* CIL Label */ 
#line 1226
      j = 0;
#line 1226
      i___0 = gl_pos___1 + loc;
      {
#line 1226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1226
        if (! (i___0 < gl_cnt___1)) {
#line 1226
          goto while_break;
        }
#line 1227
        if (j == 0) {
#line 1227
          if (killsave != 0) {
#line 1227
            if (gl_vi_mode___1 != 0) {
#line 1228
              gl_killbuf___1[0] = gl_buf[i___0];
#line 1229
              gl_killbuf___1[1] = (char )'\000';
#line 1230
              j = 1;
            }
          }
        }
#line 1232
        gl_buf[i___0] = gl_buf[i___0 + 1];
#line 1226
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1234
      gl_fixup___1(gl_prompt___1, gl_pos___1 + loc, gl_pos___1 + loc);
      }
    } else {
      {
#line 1236
      gl_beep___1();
      }
    }
  } else {
    {
#line 1236
    gl_beep___1();
    }
  }
#line 1237
  return;
}
}
#line 1239 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_kill___1(int pos ) 
{ 
  size_t tmp ;

  {
#line 1244
  if (pos < gl_cnt___1) {
    {
#line 1244
    tmp = strlen((char const   *)(gl_buf + pos));
    }
#line 1244
    if (tmp < sizeof(gl_killbuf___1)) {
      {
#line 1245
      strcpy((char */* __restrict  */)(gl_killbuf___1), (char const   */* __restrict  */)(gl_buf + pos));
#line 1246
      gl_buf[pos] = (char )'\000';
#line 1247
      gl_fixup___1(gl_prompt___1, pos, pos);
      }
    } else {
      {
#line 1249
      gl_beep___1();
      }
    }
  } else {
    {
#line 1249
    gl_beep___1();
    }
  }
#line 1250
  return;
}
}
#line 1252 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_killword___1(int direction ) 
{ 
  int pos ;
  int startpos ;
  int tmp ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1255
  pos = gl_pos___1;
#line 1256
  startpos = gl_pos___1;
#line 1260
  if (direction > 0) {
    {
#line 1261
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1261
      tmp___0 = __ctype_b_loc();
      }
#line 1261
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1261
        goto while_break;
      } else
#line 1261
      if (! (pos < gl_cnt___1)) {
#line 1261
        goto while_break;
      }
#line 1262
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1263
      tmp___1 = __ctype_b_loc();
      }
#line 1263
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1263
        if (! (pos < gl_cnt___1)) {
#line 1263
          goto while_break___0;
        }
      } else {
#line 1263
        goto while_break___0;
      }
#line 1264
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1266
    if (pos > 0) {
#line 1267
      pos --;
    }
    {
#line 1268
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1268
      tmp___2 = __ctype_b_loc();
      }
#line 1268
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1268
        if (! (pos > 0)) {
#line 1268
          goto while_break___1;
        }
      } else {
#line 1268
        goto while_break___1;
      }
#line 1269
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1270
      tmp___3 = __ctype_b_loc();
      }
#line 1270
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1270
        goto while_break___2;
      } else
#line 1270
      if (! (pos > 0)) {
#line 1270
        goto while_break___2;
      }
#line 1271
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1272
    if (pos < gl_cnt___1) {
      {
#line 1272
      tmp___4 = __ctype_b_loc();
      }
#line 1272
      if ((int const   )*(*tmp___4 + (int )gl_buf[pos]) & 8192) {
#line 1273
        pos ++;
      }
    }
  }
#line 1275
  if (pos < startpos) {
#line 1276
    tmp = pos;
#line 1277
    pos = startpos;
#line 1278
    startpos = tmp;
  }
#line 1280
  if ((size_t )(pos - startpos) >= sizeof(gl_killbuf___1)) {
    {
#line 1281
    gl_beep___1();
    }
#line 1282
    return;
  }
  {
#line 1284
  memcpy((void */* __restrict  */)(gl_killbuf___1), (void const   */* __restrict  */)(gl_buf + startpos),
         (size_t )(pos - startpos));
#line 1285
  gl_killbuf___1[pos - startpos] = (char )'\000';
#line 1286
  tmp___5 = __ctype_b_loc();
  }
#line 1286
  if ((int const   )*(*tmp___5 + (int )gl_killbuf___1[(pos - startpos) - 1]) & 8192) {
#line 1287
    gl_killbuf___1[(pos - startpos) - 1] = (char )'\000';
  }
  {
#line 1288
  gl_fixup___1(gl_prompt___1, -1, startpos);
#line 1289
  i___0 = 0;
#line 1289
  tmp = pos - startpos;
  }
  {
#line 1289
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1289
    if (! (i___0 < tmp)) {
#line 1289
      goto while_break___3;
    }
    {
#line 1290
    gl_del___1(0, 0);
#line 1289
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1291
  return;
}
}
#line 1293 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_word___1(int direction ) 
{ 
  int pos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1298
  pos = gl_pos___1;
#line 1300
  if (direction > 0) {
    {
#line 1301
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1301
      tmp = __ctype_b_loc();
      }
#line 1301
      if ((int const   )*(*tmp + (int )gl_buf[pos]) & 8192) {
#line 1301
        goto while_break;
      } else
#line 1301
      if (! (pos < gl_cnt___1)) {
#line 1301
        goto while_break;
      }
#line 1302
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1303
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1303
      tmp___0 = __ctype_b_loc();
      }
#line 1303
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1303
        if (! (pos < gl_cnt___1)) {
#line 1303
          goto while_break___0;
        }
      } else {
#line 1303
        goto while_break___0;
      }
#line 1304
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1306
    if (pos > 0) {
#line 1307
      pos --;
    }
    {
#line 1308
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1308
      tmp___1 = __ctype_b_loc();
      }
#line 1308
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1308
        if (! (pos > 0)) {
#line 1308
          goto while_break___1;
        }
      } else {
#line 1308
        goto while_break___1;
      }
#line 1309
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1310
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1310
      tmp___2 = __ctype_b_loc();
      }
#line 1310
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1310
        goto while_break___2;
      } else
#line 1310
      if (! (pos > 0)) {
#line 1310
        goto while_break___2;
      }
#line 1311
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1312
    if (pos < gl_cnt___1) {
      {
#line 1312
      tmp___3 = __ctype_b_loc();
      }
#line 1312
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1313
        pos ++;
      }
    }
  }
  {
#line 1315
  gl_fixup___1(gl_prompt___1, -1, pos);
  }
#line 1316
  return;
}
}
#line 1318 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_redraw___1(void) 
{ 


  {
#line 1322
  if (gl_init_done___1 > 0) {
    {
#line 1323
    gl_putc___1('\n');
#line 1324
    gl_fixup___1(gl_prompt___1, -2, gl_pos___1);
    }
  }
#line 1326
  return;
}
}
#line 1344 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_shift___1  ;
#line 1345 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int off_right___1  ;
#line 1346 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int off_left___1  ;
#line 1347 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char last_prompt___1[80]  = {      (char )'\000'};
#line 1328 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_fixup___1(char const   *prompt , int change , int cursor ) 
{ 
  int left ;
  int right ;
  int pad ;
  int backup ;
  int new_shift ;
  int extra ;
  int i___0 ;
  int new_right ;
  int l1 ;
  int l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1348
  left = 0;
#line 1348
  right = -1;
#line 1354
  new_right = -1;
#line 1357
  if (change == -2) {
    {
#line 1358
    off_left___1 = 0;
#line 1358
    off_right___1 = off_left___1;
#line 1358
    gl_shift___1 = off_right___1;
#line 1358
    gl_cnt___1 = gl_shift___1;
#line 1358
    gl_pos___1 = gl_cnt___1;
#line 1359
    gl_putc___1('\r');
#line 1360
    gl_puts___1(prompt);
#line 1361
    strncpy((char */* __restrict  */)(last_prompt___1), (char const   */* __restrict  */)prompt,
            sizeof(last_prompt___1) - 1UL);
#line 1362
    last_prompt___1[sizeof(last_prompt___1) - 1UL] = (char )'\000';
#line 1363
    change = 0;
#line 1364
    tmp = (*gl_strlen)(prompt);
#line 1364
    l2 = (int )tmp;
#line 1365
    gl_width___1 = gl_termw___1 - l2;
    }
  } else {
    {
#line 1366
    tmp___2 = strcmp(prompt, (char const   *)(last_prompt___1));
    }
#line 1366
    if (tmp___2 != 0) {
      {
#line 1367
      tmp___0 = (*gl_strlen)((char const   *)(last_prompt___1));
#line 1367
      l1 = (int )tmp___0;
#line 1368
      tmp___1 = (*gl_strlen)(prompt);
#line 1368
      l2 = (int )tmp___1;
#line 1369
      gl_cnt___1 = (gl_cnt___1 + l1) - l2;
#line 1370
      strcpy((char */* __restrict  */)(last_prompt___1), (char const   */* __restrict  */)prompt);
#line 1371
      gl_putc___1('\r');
#line 1372
      gl_puts___1(prompt);
#line 1373
      gl_pos___1 = gl_shift___1;
#line 1374
      gl_width___1 = gl_termw___1 - l2;
#line 1375
      change = 0;
      }
    }
  }
#line 1377
  if (off_right___1) {
#line 1377
    pad = gl_width___1 - 1;
  } else {
#line 1377
    pad = gl_cnt___1 - gl_shift___1;
  }
#line 1378
  backup = gl_pos___1 - gl_shift___1;
#line 1379
  if (change >= 0) {
    {
#line 1380
    tmp___3 = strlen((char const   *)(gl_buf));
#line 1380
    gl_cnt___1 = (int )tmp___3;
    }
#line 1381
    if (change > gl_cnt___1) {
#line 1382
      change = gl_cnt___1;
    }
  }
#line 1384
  if (cursor > gl_cnt___1) {
#line 1385
    if (cursor != 2048) {
#line 1386
      if (gl_ellipses_during_completion == 0) {
        {
#line 1387
        gl_beep___1();
        }
      }
    }
#line 1390
    cursor = gl_cnt___1;
  }
#line 1392
  if (cursor < 0) {
    {
#line 1393
    gl_beep___1();
#line 1394
    cursor = 0;
    }
  }
#line 1396
  if (off_right___1) {
#line 1397
    extra = 2;
  } else
#line 1396
  if (off_left___1) {
#line 1396
    if (cursor < (gl_shift___1 + gl_width___1) - gl_scroll___1 / 2) {
#line 1397
      extra = 2;
    } else {
#line 1399
      extra = 0;
    }
  } else {
#line 1399
    extra = 0;
  }
#line 1400
  new_shift = ((cursor + extra) + gl_scroll___1) - gl_width___1;
#line 1401
  if (new_shift > 0) {
#line 1402
    new_shift /= gl_scroll___1;
#line 1403
    new_shift *= gl_scroll___1;
  } else {
#line 1405
    new_shift = 0;
  }
#line 1406
  if (new_shift != gl_shift___1) {
#line 1407
    gl_shift___1 = new_shift;
#line 1408
    if (gl_shift___1) {
#line 1408
      off_left___1 = 1;
    } else {
#line 1408
      off_left___1 = 0;
    }
#line 1409
    if (gl_cnt___1 > (gl_shift___1 + gl_width___1) - 1) {
#line 1409
      off_right___1 = 1;
    } else {
#line 1409
      off_right___1 = 0;
    }
#line 1410
    left = gl_shift___1;
#line 1411
    if (off_right___1) {
#line 1411
      right = (gl_shift___1 + gl_width___1) - 2;
    } else {
#line 1411
      right = gl_cnt___1;
    }
#line 1411
    new_right = right;
  } else
#line 1412
  if (change >= 0) {
#line 1413
    if (change < gl_shift___1 + off_left___1) {
#line 1414
      left = gl_shift___1;
    } else {
#line 1416
      left = change;
#line 1417
      backup = gl_pos___1 - change;
    }
#line 1419
    if (gl_cnt___1 > (gl_shift___1 + gl_width___1) - 1) {
#line 1419
      off_right___1 = 1;
    } else {
#line 1419
      off_right___1 = 0;
    }
#line 1420
    if (off_right___1) {
#line 1420
      right = (gl_shift___1 + gl_width___1) - 2;
    } else {
#line 1420
      right = gl_cnt___1;
    }
#line 1421
    if (gl_extent___1) {
#line 1421
      if (right > left + gl_extent___1) {
#line 1421
        new_right = left + gl_extent___1;
      } else {
#line 1421
        new_right = right;
      }
    } else {
#line 1421
      new_right = right;
    }
  }
#line 1424
  if (off_right___1) {
#line 1424
    tmp___4 = gl_width___1 - 1;
  } else {
#line 1424
    tmp___4 = gl_cnt___1 - gl_shift___1;
  }
#line 1424
  pad -= tmp___4;
#line 1425
  if (pad < 0) {
#line 1425
    pad = 0;
  } else {
#line 1425
    pad = pad;
  }
#line 1426
  if (left <= right) {
#line 1427
    i___0 = 0;
    {
#line 1427
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1427
      if (! (i___0 < backup)) {
#line 1427
        goto while_break;
      }
      {
#line 1428
      gl_putc___1('\b');
#line 1427
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1429
    if (left == gl_shift___1) {
#line 1429
      if (off_left___1) {
        {
#line 1430
        gl_putc___1('$');
#line 1431
        left ++;
        }
      }
    }
#line 1433
    i___0 = left;
    {
#line 1433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1433
      if (! (i___0 < new_right)) {
#line 1433
        goto while_break___0;
      }
      {
#line 1434
      gl_putc___1((int )gl_buf[i___0]);
#line 1433
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1435
    gl_pos___1 = new_right;
#line 1436
    if (off_right___1) {
#line 1436
      if (new_right == right) {
        {
#line 1437
        gl_putc___1('$');
#line 1438
        gl_pos___1 ++;
        }
      } else {
#line 1436
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1440
      i___0 = 0;
      {
#line 1440
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1440
        if (! (i___0 < pad)) {
#line 1440
          goto while_break___1;
        }
        {
#line 1441
        gl_putc___1(' ');
#line 1440
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1442
      gl_pos___1 += pad;
    }
  }
#line 1445
  i___0 = gl_pos___1 - cursor;
#line 1446
  if (i___0 > 0) {
    {
#line 1447
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1447
      tmp___5 = i___0;
#line 1447
      i___0 --;
#line 1447
      if (! tmp___5) {
#line 1447
        goto while_break___2;
      }
      {
#line 1448
      gl_putc___1('\b');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1450
    i___0 = gl_pos___1;
    {
#line 1450
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1450
      if (! (i___0 < cursor)) {
#line 1450
        goto while_break___3;
      }
      {
#line 1451
      gl_putc___1((int )gl_buf[i___0]);
#line 1450
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1453
  gl_pos___1 = cursor;
#line 1454
  return;
}
}
#line 1456 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_tab___1(char *buf , int offset , int *loc , size_t bufsize ) 
{ 
  int i___0 ;
  int count ;
  int len ;
  size_t tmp ;

  {
  {
#line 1462
  tmp = strlen((char const   *)buf);
#line 1462
  len = (int )tmp;
#line 1463
  count = 8 - (offset + *loc) % 8;
#line 1464
  i___0 = len;
  }
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    if (! (i___0 >= *loc)) {
#line 1464
      goto while_break;
    }
#line 1465
    if (i___0 + count < (int )bufsize) {
#line 1466
      *(buf + (i___0 + count)) = *(buf + i___0);
    }
#line 1464
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1467
  i___0 = 0;
  {
#line 1467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1467
    if (! (i___0 < count)) {
#line 1467
      goto while_break___0;
    }
#line 1468
    if (*loc + i___0 < (int )bufsize) {
#line 1469
      *(buf + (*loc + i___0)) = (char )' ';
    }
#line 1467
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1470
  i___0 = *loc;
#line 1471
  *loc = i___0 + count;
#line 1472
  return (i___0);
}
}
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int hist_pos___1  =    0;
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int hist_last___1  =    0;
#line 1482 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_buf___1[100]  ;
#line 1483 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char hist_empty_elem___1[2]  = {      (char )'\000'};
#line 1485 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void hist_init___1(void) 
{ 
  int i___0 ;

  {
#line 1490
  hist_buf___1[0] = hist_empty_elem___1;
#line 1491
  i___0 = 1;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if (! (i___0 < 100)) {
#line 1491
      goto while_break;
    }
#line 1492
    hist_buf___1[i___0] = (char *)0;
#line 1491
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1493
  hist_last___1 = 0;
#line 1493
  hist_pos___1 = hist_last___1;
#line 1494
  return;
}
}
#line 1496 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void hist_dispose___1(void) 
{ 
  int i___0 ;

  {
#line 1501
  i___0 = 0;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! (i___0 < 100)) {
#line 1501
      goto while_break;
    }
#line 1502
    if ((unsigned long )hist_buf___1[i___0] != (unsigned long )(hist_empty_elem___1)) {
#line 1502
      if ((unsigned long )hist_buf___1[i___0] != (unsigned long )((char *)0)) {
        {
#line 1503
        free((void *)hist_buf___1[i___0]);
#line 1504
        hist_buf___1[i___0] = (char *)0;
        }
      }
    }
#line 1501
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1509
  hist_buf___1[0] = hist_empty_elem___1;
#line 1510
  hist_last___1 = 0;
#line 1510
  hist_pos___1 = hist_last___1;
#line 1511
  return;
}
}
#line 1516 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *prev___1  =    (char *)0;
#line 1545 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_prev___1(void) 
{ 
  char *p___5 ;
  int next ;

  {
#line 1549
  p___5 = (char *)0;
#line 1550
  next = ((hist_pos___1 - 1) + 100) % 100;
#line 1552
  if ((unsigned long )hist_buf___1[hist_pos___1] != (unsigned long )((char *)0)) {
#line 1552
    if (next != hist_last___1) {
#line 1553
      hist_pos___1 = next;
#line 1554
      p___5 = hist_buf___1[hist_pos___1];
    }
  }
#line 1556
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1557
    p___5 = hist_empty_elem___1;
#line 1558
    gl_beep___1();
    }
  }
#line 1560
  return (p___5);
}
}
#line 1563 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_next___1(void) 
{ 
  char *p___5 ;

  {
#line 1567
  p___5 = (char *)0;
#line 1569
  if (hist_pos___1 != hist_last___1) {
#line 1570
    hist_pos___1 = (hist_pos___1 + 1) % 100;
#line 1571
    p___5 = hist_buf___1[hist_pos___1];
  }
#line 1573
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1574
    p___5 = hist_empty_elem___1;
#line 1575
    gl_beep___1();
    }
  }
#line 1577
  return (p___5);
}
}
#line 1580 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_save___1(char const   * const  p___5 ) 
{ 
  char *s ;
  size_t len ;
  size_t tmp ;
  char *nl___0 ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1584
  s = (char *)0;
#line 1585
  tmp = strlen((char const   *)p___5);
#line 1585
  len = tmp;
#line 1586
  tmp___0 = strpbrk((char const   *)p___5, "\n\r");
#line 1586
  nl___0 = tmp___0;
  }
#line 1588
  if (nl___0) {
    {
#line 1589
    tmp___1 = malloc(len);
#line 1589
    s = (char *)tmp___1;
    }
#line 1589
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1590
      strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5,
              len - 1UL);
#line 1591
      *(s + (len - 1UL)) = (char)0;
      }
    }
  } else {
    {
#line 1594
    tmp___2 = malloc(len + 1UL);
#line 1594
    s = (char *)tmp___2;
    }
#line 1594
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1595
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5);
      }
    }
  }
#line 1598
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 1599
    gl_error___1((char const   */* const  */)"\n*** Error: hist_save() failed on malloc\n");
    }
  }
#line 1600
  return (s);
}
}
#line 1662 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char search_prompt___1[101]  ;
#line 1663 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char search_string___1[100]  ;
#line 1664 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_pos___1  =    0;
#line 1665 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_forw_flg___1  =    0;
#line 1666 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_last___1  =    0;
#line 1668 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_update___1(int c ) 
{ 


  {
#line 1671
  if (c == 0) {
#line 1672
    search_pos___1 = 0;
#line 1673
    search_string___1[0] = (char)0;
#line 1674
    search_prompt___1[0] = (char )'?';
#line 1675
    search_prompt___1[1] = (char )' ';
#line 1676
    search_prompt___1[2] = (char)0;
  } else
#line 1677
  if (c > 0) {
#line 1678
    search_string___1[search_pos___1] = (char )c;
#line 1679
    search_string___1[search_pos___1 + 1] = (char)0;
#line 1680
    search_prompt___1[search_pos___1] = (char )c;
#line 1681
    search_prompt___1[search_pos___1 + 1] = (char )'?';
#line 1682
    search_prompt___1[search_pos___1 + 2] = (char )' ';
#line 1683
    search_prompt___1[search_pos___1 + 3] = (char)0;
#line 1684
    search_pos___1 ++;
  } else
#line 1686
  if (search_pos___1 > 0) {
#line 1687
    search_pos___1 --;
#line 1688
    search_string___1[search_pos___1] = (char)0;
#line 1689
    search_prompt___1[search_pos___1] = (char )'?';
#line 1690
    search_prompt___1[search_pos___1 + 1] = (char )' ';
#line 1691
    search_prompt___1[search_pos___1 + 2] = (char)0;
  } else {
    {
#line 1693
    gl_beep___1();
#line 1694
    hist_pos___1 = hist_last___1;
    }
  }
#line 1697
  return;
}
}
#line 1699 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_addchar___1(int c ) 
{ 
  char *loc ;

  {
  {
#line 1704
  search_update___1(c);
  }
#line 1705
  if (c < 0) {
#line 1706
    if (search_pos___1 > 0) {
#line 1707
      hist_pos___1 = search_last___1;
    } else {
#line 1709
      gl_buf[0] = (char)0;
#line 1710
      hist_pos___1 = hist_last___1;
    }
    {
#line 1712
    strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)hist_buf___1[hist_pos___1]);
    }
  }
  {
#line 1714
  loc = strstr((char const   *)(gl_buf), (char const   *)(search_string___1));
  }
#line 1714
  if ((unsigned long )loc != (unsigned long )((char *)0)) {
    {
#line 1715
    gl_fixup___1((char const   *)(search_prompt___1), 0, (int )(loc - gl_buf));
    }
  } else
#line 1716
  if (search_pos___1 > 0) {
#line 1717
    if (search_forw_flg___1) {
      {
#line 1718
      search_forw___1(0);
      }
    } else {
      {
#line 1720
      search_back___1(0);
      }
    }
  } else {
    {
#line 1723
    gl_fixup___1((char const   *)(search_prompt___1), 0, 0);
    }
  }
#line 1725
  return;
}
}
#line 1727 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_term___1(void) 
{ 


  {
#line 1730
  gl_search_mode___1 = 0;
#line 1731
  if ((int )gl_buf[0] == 0) {
#line 1732
    hist_pos___1 = hist_last___1;
  }
#line 1733
  if (gl_in_hook) {
    {
#line 1734
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 1735
  gl_fixup___1(gl_prompt___1, 0, gl_pos___1);
  }
#line 1736
  return;
}
}
#line 1738 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_back___1(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1741
  found = 0;
#line 1744
  search_forw_flg___1 = 0;
#line 1745
  if (gl_search_mode___1 == 0) {
    {
#line 1746
    hist_pos___1 = hist_last___1;
#line 1746
    search_last___1 = hist_pos___1;
#line 1747
    search_update___1(0);
#line 1748
    gl_search_mode___1 = 1;
#line 1749
    gl_buf[0] = (char)0;
#line 1750
    gl_fixup___1((char const   *)(search_prompt___1), 0, 0);
    }
  } else
#line 1751
  if (search_pos___1 > 0) {
    {
#line 1752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1752
      if (! (! found)) {
#line 1752
        goto while_break;
      }
      {
#line 1753
      p___5 = hist_prev___1();
      }
#line 1754
      if ((int )*p___5 == 0) {
        {
#line 1755
        gl_buf[0] = (char)0;
#line 1756
        gl_fixup___1((char const   *)(search_prompt___1), 0, 0);
#line 1757
        found = 1;
        }
      } else {
        {
#line 1758
        loc = strstr((char const   *)p___5, (char const   *)(search_string___1));
        }
#line 1758
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1759
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1760
          gl_fixup___1((char const   *)(search_prompt___1), 0, (int )(loc - p___5));
          }
#line 1761
          if (new_search) {
#line 1762
            search_last___1 = hist_pos___1;
          }
#line 1763
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1768
    gl_beep___1();
    }
  }
#line 1770
  return;
}
}
#line 1772 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_forw___1(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1775
  found = 0;
#line 1778
  search_forw_flg___1 = 1;
#line 1779
  if (gl_search_mode___1 == 0) {
    {
#line 1780
    hist_pos___1 = hist_last___1;
#line 1780
    search_last___1 = hist_pos___1;
#line 1781
    search_update___1(0);
#line 1782
    gl_search_mode___1 = 1;
#line 1783
    gl_buf[0] = (char)0;
#line 1784
    gl_fixup___1((char const   *)(search_prompt___1), 0, 0);
    }
  } else
#line 1785
  if (search_pos___1 > 0) {
    {
#line 1786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1786
      if (! (! found)) {
#line 1786
        goto while_break;
      }
      {
#line 1787
      p___5 = hist_next___1();
      }
#line 1788
      if ((int )*p___5 == 0) {
        {
#line 1789
        gl_buf[0] = (char)0;
#line 1790
        gl_fixup___1((char const   *)(search_prompt___1), 0, 0);
#line 1791
        found = 1;
        }
      } else {
        {
#line 1792
        loc = strstr((char const   *)p___5, (char const   *)(search_string___1));
        }
#line 1792
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1793
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1794
          gl_fixup___1((char const   *)(search_prompt___1), 0, (int )(loc - p___5));
          }
#line 1795
          if (new_search) {
#line 1796
            search_last___1 = hist_pos___1;
          }
#line 1797
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1801
    gl_beep___1();
    }
  }
#line 1803
  return;
}
}
#line 1806 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_beep___1(void) 
{ 


  {
  {
#line 1812
  gl_putc___1('\a');
  }
#line 1814
  return;
}
}
#line 1818 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_display_matches_sort_proc___1(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 1821
  tmp = strcasecmp((char const   *)*((char const   * const  *)a), (char const   *)*((char const   * const  *)b));
  }
#line 1821
  return (tmp);
}
}
#line 1829 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_display_matches___1(int nused ) 
{ 
  char buf[256] ;
  char buf2[256] ;
  size_t ilen ;
  size_t imaxlen ;
  int i___0 ;
  int j ;
  int k ;
  int l ;
  int glen ;
  int allmatch ;
  int nmax ;
  int ncol ;
  int colw ;
  int nrow ;
  char *cp1 ;
  char *cp2 ;
  char *lim ;
  char *itemp ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1840
  gl_putc___1('\n');
  }
#line 1841
  if (nused == 0) {
    {
#line 1842
    gl_beep___1();
#line 1843
    gl_puts___1("    (no matches)");
#line 1844
    gl_putc___1('\n');
    }
  } else {
    {
#line 1846
    qsort((void *)gl_matchlist___1, (size_t )nused, sizeof(char *), & gl_display_matches_sort_proc___1);
#line 1849
    glen = 0;
    }
    {
#line 1849
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1850
      allmatch = 1;
#line 1851
      if ((int )*(*(gl_matchlist___1 + 0) + glen) == 0) {
        {
#line 1852
        gl_beep___1();
#line 1853
        gl_putc___1('\n');
        }
#line 1854
        return;
      }
#line 1856
      i___0 = 1;
      {
#line 1856
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1856
        if (! (i___0 < nused)) {
#line 1856
          goto while_break___0;
        }
#line 1857
        if ((int )*(*(gl_matchlist___1 + 0) + glen) != (int )*(*(gl_matchlist___1 + i___0) + glen)) {
#line 1858
          allmatch = 0;
#line 1859
          goto while_break___0;
        }
#line 1856
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1862
      if (allmatch == 0) {
#line 1863
        goto while_break;
      }
#line 1849
      glen ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1866
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1866
      if (! (glen > 0)) {
#line 1866
        goto while_break___1;
      }
      {
#line 1867
      tmp = __ctype_b_loc();
      }
#line 1867
      if (! ((int const   )*(*tmp + (int )*(*(gl_matchlist___1 + 0) + (glen - 1))) & 8)) {
#line 1868
        goto while_break___1;
      }
#line 1869
      glen --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1872
    nmax = nused;
#line 1873
    imaxlen = strlen((char const   *)*(gl_matchlist___1 + 0));
#line 1874
    i___0 = 1;
    }
    {
#line 1874
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1874
      if (! (i___0 < nused)) {
#line 1874
        goto while_break___2;
      }
      {
#line 1875
      ilen = strlen((char const   *)*(gl_matchlist___1 + i___0));
      }
#line 1876
      if (ilen > imaxlen) {
#line 1877
        imaxlen = ilen;
      }
#line 1874
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1881
    if (imaxlen == (size_t )((unsigned int )glen)) {
      {
#line 1882
      gl_beep___1();
#line 1883
      gl_putc___1('\n');
      }
#line 1884
      return;
    }
#line 1886
    imaxlen -= (size_t )glen;
#line 1888
    ncol = (gl_termw___1 - 8) / ((int )imaxlen + 2);
#line 1889
    if (ncol < 1) {
#line 1890
      ncol = 1;
    }
#line 1892
    colw = (gl_termw___1 - 8) / ncol;
#line 1893
    nrow = nmax / ncol;
#line 1894
    if (nused % ncol != 0) {
#line 1895
      nrow ++;
    }
#line 1897
    if (nrow > gl_termh___1 - 4) {
#line 1898
      nrow = gl_termh___1 - 4;
#line 1899
      nmax = ncol * nrow;
    }
#line 1902
    i___0 = 0;
    {
#line 1902
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1902
      if (! (i___0 < (int )sizeof(buf2))) {
#line 1902
        goto while_break___3;
      }
#line 1903
      buf2[i___0] = (char )' ';
#line 1902
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1905
    j = 0;
    {
#line 1905
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1905
      if (! (j < nrow)) {
#line 1905
        goto while_break___4;
      }
      {
#line 1906
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(buf2),
             sizeof(buf));
#line 1907
      i___0 = 0;
#line 1907
      k = j;
#line 1907
      l = 4;
      }
      {
#line 1907
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1907
        if (! (i___0 < ncol)) {
#line 1907
          goto while_break___5;
        }
#line 1908
        if (k >= nmax) {
#line 1909
          goto __Cont;
        }
        {
#line 1910
        itemp = *(gl_matchlist___1 + k) + glen;
#line 1911
        cp1 = buf + l;
#line 1912
        tmp___0 = strlen((char const   *)itemp);
#line 1912
        lim = cp1 + (int )tmp___0;
        }
#line 1913
        if ((unsigned long )lim >= (unsigned long )(buf + sizeof(buf))) {
#line 1914
          goto __Cont;
        }
#line 1915
        cp2 = itemp;
        {
#line 1916
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1916
          if (! ((unsigned long )cp1 < (unsigned long )lim)) {
#line 1916
            goto while_break___6;
          }
#line 1917
          tmp___1 = cp1;
#line 1917
          cp1 ++;
#line 1917
          tmp___2 = cp2;
#line 1917
          cp2 ++;
#line 1917
          *tmp___1 = *tmp___2;
        }
        while_break___6: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 1907
        i___0 ++;
#line 1907
        k += nrow;
#line 1907
        l += colw;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1919
      cp1 = buf;
#line 1920
      cp1 += sizeof(buf);
#line 1921
      cp1 --;
      {
#line 1922
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1922
        if (! ((int )*cp1 == 32)) {
#line 1922
          goto while_break___7;
        }
#line 1923
        cp1 --;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1924
      cp1 ++;
#line 1925
      *cp1 = (char )'\000';
#line 1926
      gl_puts___1((char const   *)(buf));
#line 1927
      gl_putc___1('\n');
#line 1905
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1930
    if (nused > nmax) {
      {
#line 1931
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"    ... %d others omitted ...",
              nused - nmax);
#line 1932
      gl_puts___1((char const   *)(buf));
#line 1933
      gl_putc___1('\n');
      }
    }
  }
  {
#line 1936
  gl_fixup___1(gl_prompt___1, -2, 2048);
  }
#line 1937
  return;
}
}
#line 1942 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_do_tab_completion___1(char *buf , int *loc , size_t bufsize , int tabtab ) 
{ 
  char *startp ;
  size_t startoff ;
  size_t amt ;
  int c ;
  int qmode ;
  char *qstart ;
  char *lastspacestart ;
  char *cp ;
  int ntoalloc ;
  int nused ;
  int nprocused ;
  int nalloced ;
  int i___0 ;
  char **newgl_matchlist ;
  char *strtoadd ;
  char *strtoadd1 ;
  int addquotes ;
  size_t llen ;
  size_t mlen ;
  size_t glen ;
  int allmatch ;
  char *curposp ;
  size_t lenaftercursor ;
  char *matchpfx ;
  int wasateol ;
  char ellipsessave[4] ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
  {
#line 1967
  llen = strlen((char const   *)buf);
#line 1968
  memset((void *)(buf + llen), 0, bufsize - llen);
#line 1969
  bufsize -= 4UL;
#line 1970
  curposp = buf + *loc;
#line 1971
  wasateol = (int )*curposp == 0;
#line 1972
  lenaftercursor = llen - (size_t )(curposp - buf);
  }
#line 1973
  if (gl_ellipses_during_completion != 0) {
    {
#line 1974
    memcpy((void */* __restrict  */)(ellipsessave), (void const   */* __restrict  */)curposp,
           (size_t )4);
#line 1975
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)"... ",
           (size_t )4);
#line 1976
    gl_fixup___1(gl_prompt___1, gl_pos___1, gl_pos___1 + 3);
#line 1977
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)(ellipsessave),
           (size_t )4);
    }
  }
#line 1980
  qmode = 0;
#line 1981
  qstart = (char *)((void *)0);
#line 1982
  lastspacestart = (char *)((void *)0);
#line 1983
  matchpfx = (char *)((void *)0);
#line 1985
  cp = buf;
  {
#line 1986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1986
    if (! ((unsigned long )cp < (unsigned long )curposp)) {
#line 1986
      goto while_break;
    }
#line 1987
    tmp = cp;
#line 1987
    cp ++;
#line 1987
    c = (int )*tmp;
#line 1988
    if (c == 0) {
#line 1989
      goto while_break;
    }
#line 1990
    if (c == 34) {
#line 1990
      goto _L;
    } else
#line 1990
    if (c == 39) {
      _L: /* CIL Label */ 
#line 1991
      if (qmode == c) {
#line 1993
        qstart = (char *)((void *)0);
#line 1994
        qmode = 0;
      } else
#line 1995
      if (! (qmode != 0)) {
#line 1999
        qmode = c;
#line 2000
        qstart = cp - 1;
      }
    } else {
      {
#line 2002
      tmp___0 = __ctype_b_loc();
      }
#line 2002
      if ((int const   )*(*tmp___0 + c) & 8192) {
#line 2002
        if (qmode == 0) {
#line 2004
          lastspacestart = cp - 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  if ((unsigned long )qstart != (unsigned long )((void *)0)) {
#line 2011
    startp = qstart + 1;
  } else
#line 2012
  if ((unsigned long )lastspacestart != (unsigned long )((void *)0)) {
#line 2013
    startp = lastspacestart + 1;
  } else {
#line 2015
    startp = buf;
  }
  {
#line 2017
  cp = startp;
#line 2018
  mlen = (size_t )(curposp - cp);
#line 2020
  tmp___1 = malloc(mlen + 1UL);
#line 2020
  matchpfx = (char *)tmp___1;
#line 2021
  memcpy((void */* __restrict  */)matchpfx, (void const   */* __restrict  */)cp, mlen);
#line 2022
  *(matchpfx + mlen) = (char )'\000';
#line 2026
  nused = 0;
#line 2027
  ntoalloc = 64;
#line 2028
  tmp___2 = malloc(sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2028
  newgl_matchlist = (char **)tmp___2;
  }
#line 2029
  if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
    {
#line 2030
    free((void *)matchpfx);
#line 2031
    gl_beep___1();
    }
#line 2032
    return (0);
  }
#line 2034
  gl_matchlist___1 = newgl_matchlist;
#line 2035
  nalloced = ntoalloc;
#line 2036
  i___0 = nused;
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i___0 <= nalloced)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(gl_matchlist___1 + i___0) = (char *)((void *)0);
#line 2036
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2039
  gl_completion_exact_match_extra_char = ' ';
#line 2040
  nprocused = 0;
  {
#line 2040
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2041
    if (nused == nalloced) {
      {
#line 2042
      ntoalloc += 64;
#line 2043
      tmp___3 = realloc((void *)((char *)gl_matchlist___1), sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2043
      newgl_matchlist = (char **)tmp___3;
      }
#line 2044
      if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
#line 2046
        i___0 = 0;
        {
#line 2046
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2046
          if (! (i___0 < nused)) {
#line 2046
            goto while_break___2;
          }
          {
#line 2047
          free((void *)*(gl_matchlist___1 + i___0));
#line 2046
          i___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2048
        free((void *)gl_matchlist___1);
#line 2049
        gl_matchlist___1 = (char **)((void *)0);
#line 2050
        gl_beep___1();
#line 2051
        free((void *)matchpfx);
        }
#line 2052
        return (0);
      }
#line 2054
      gl_matchlist___1 = newgl_matchlist;
#line 2055
      nalloced = ntoalloc;
#line 2056
      i___0 = nused;
      {
#line 2056
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2056
        if (! (i___0 <= nalloced)) {
#line 2056
          goto while_break___3;
        }
#line 2057
        *(gl_matchlist___1 + i___0) = (char *)((void *)0);
#line 2056
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2059
    cp = (*gl_completion_proc)((char const   *)matchpfx, nprocused);
    }
#line 2060
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2061
      goto while_break___1;
    }
#line 2062
    if ((int )*(cp + 0) == 46) {
#line 2062
      if ((int )*(cp + 1) == 0) {
#line 2063
        goto __Cont;
      } else
#line 2062
      if ((int )*(cp + 1) == 46) {
#line 2062
        if ((int )*(cp + 2) == 0) {
#line 2063
          goto __Cont;
        }
      }
    }
#line 2064
    tmp___4 = nused;
#line 2064
    nused ++;
#line 2064
    *(gl_matchlist___1 + tmp___4) = cp;
    __Cont: /* CIL Label */ 
#line 2040
    nprocused ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2067
  if (gl_ellipses_during_completion != 0) {
    {
#line 2068
    gl_fixup___1(gl_prompt___1, gl_pos___1, gl_pos___1);
#line 2069
    gl_puts___1("    ");
    }
  }
#line 2073
  strtoadd = (char *)((void *)0);
#line 2074
  strtoadd1 = (char *)((void *)0);
#line 2075
  amt = (size_t )0;
#line 2077
  if (gl_filename_quoting_desired > 0) {
#line 2077
    tmp___5 = 1;
  } else
#line 2077
  if (gl_filename_quoting_desired < 0) {
#line 2077
    if ((unsigned long )gl_completion_proc == (unsigned long )(& gl_local_filename_completion_proc)) {
#line 2077
      tmp___5 = 1;
    } else {
#line 2077
      tmp___5 = 0;
    }
  } else {
#line 2077
    tmp___5 = 0;
  }
#line 2077
  addquotes = tmp___5;
#line 2079
  if (nused == 1) {
#line 2081
    strtoadd = *(gl_matchlist___1 + 0);
  } else
#line 2082
  if (tabtab != 0) {
    {
#line 2084
    gl_display_matches___1(nused);
    }
  } else
#line 2085
  if (nused > 1) {
#line 2085
    if (mlen != 0UL) {
      {
#line 2087
      glen = strlen((char const   *)matchpfx);
      }
      {
#line 2087
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2088
        allmatch = 1;
#line 2089
        i___0 = 1;
        {
#line 2089
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2089
          if (! (i___0 < nused)) {
#line 2089
            goto while_break___5;
          }
#line 2090
          if ((int )*(*(gl_matchlist___1 + 0) + glen) != (int )*(*(gl_matchlist___1 + i___0) + glen)) {
#line 2091
            allmatch = 0;
#line 2092
            goto while_break___5;
          }
#line 2089
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2095
        if (allmatch == 0) {
#line 2096
          goto while_break___4;
        }
#line 2087
        glen ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2098
      tmp___6 = malloc(glen + 1UL);
#line 2098
      strtoadd1 = (char *)tmp___6;
      }
#line 2099
      if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
        {
#line 2100
        memcpy((void */* __restrict  */)strtoadd1, (void const   */* __restrict  */)*(gl_matchlist___1 + 0),
               glen);
#line 2101
        *(strtoadd1 + glen) = (char )'\000';
#line 2102
        strtoadd = strtoadd1;
        }
      }
    }
  }
#line 2106
  if ((unsigned long )strtoadd != (unsigned long )((void *)0)) {
#line 2107
    if (qmode == 0) {
#line 2107
      if (addquotes != 0) {
        {
#line 2108
        tmp___10 = strpbrk((char const   *)strtoadd, gl_filename_quote_characters);
        }
#line 2108
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          {
#line 2109
          tmp___8 = strchr((char const   *)strtoadd, '\"');
          }
#line 2109
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 2109
            qmode = '\"';
          } else {
#line 2109
            qmode = '\'';
          }
          {
#line 2110
          memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2111
          curposp ++;
#line 2112
          tmp___9 = startp;
#line 2112
          startp ++;
#line 2112
          *tmp___9 = (char )qmode;
          }
        }
      }
    }
    {
#line 2115
    startoff = (size_t )(startp - buf);
#line 2116
    amt = strlen((char const   *)strtoadd);
    }
#line 2117
    if ((amt + startoff) + lenaftercursor >= bufsize) {
#line 2118
      amt = bufsize - ((amt + startoff) + lenaftercursor);
    }
    {
#line 2119
    memmove((void *)((curposp + amt) - mlen), (void const   *)curposp, lenaftercursor + 1UL);
#line 2120
    curposp += amt - mlen;
#line 2121
    memcpy((void */* __restrict  */)startp, (void const   */* __restrict  */)strtoadd,
           amt);
    }
#line 2122
    if (nused == 1) {
#line 2124
      if (qmode != 0) {
        {
#line 2126
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2127
        curposp ++;
#line 2128
        *(buf + (amt + startoff)) = (char )qmode;
#line 2129
        amt ++;
        }
      }
      {
#line 2131
      memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2132
      curposp ++;
#line 2133
      *(buf + (amt + startoff)) = (char )gl_completion_exact_match_extra_char;
#line 2134
      amt ++;
      }
    } else
#line 2135
    if (! wasateol) {
      {
#line 2135
      tmp___11 = __ctype_b_loc();
      }
#line 2135
      if (! ((int const   )*(*tmp___11 + (int )*curposp) & 8192)) {
        {
#line 2139
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2140
        curposp ++;
#line 2141
        *(buf + (amt + startoff)) = (char )' ';
        }
      }
    }
#line 2143
    *loc = (int )(startoff + amt);
#line 2145
    if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
      {
#line 2146
      free((void *)strtoadd1);
      }
    }
  }
#line 2150
  i___0 = 0;
  {
#line 2150
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2150
    if (! (i___0 < nused)) {
#line 2150
      goto while_break___6;
    }
    {
#line 2151
    free((void *)*(gl_matchlist___1 + i___0));
#line 2150
    i___0 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2152
  free((void *)gl_matchlist___1);
#line 2153
  gl_matchlist___1 = (char **)((void *)0);
#line 2154
  free((void *)matchpfx);
  }
#line 2156
  return (0);
}
}
#line 2354 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static DIR *dir___1  =    (DIR *)((void *)0);
#line 2355 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int filepfxoffset___1  ;
#line 2356 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static size_t filepfxlen___1  ;
#line 73 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/rcmd.c"
static void SaveLastResponse___1(FTPCIPtr const   cip , ResponsePtr rp ) 
{ 


  {
#line 76
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    {
#line 77
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 78
    cip->lastFTPCmdResultNum = -1;
#line 79
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else
#line 80
  if ((unsigned long )rp->msg.first == (unsigned long )((void *)0)) {
    {
#line 81
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 82
    cip->lastFTPCmdResultNum = rp->code;
#line 83
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else
#line 80
  if ((unsigned long )(rp->msg.first)->line == (unsigned long )((void *)0)) {
    {
#line 81
    cip->lastFTPCmdResultStr[0] = (char )'\000';
#line 82
    cip->lastFTPCmdResultNum = rp->code;
#line 83
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
    }
  } else {
    {
#line 85
    Strncpy((char */* const  */)(cip->lastFTPCmdResultStr), (char const   */* const  */)(rp->msg.first)->line,
            (size_t const   )sizeof(cip->lastFTPCmdResultStr));
#line 86
    cip->lastFTPCmdResultNum = rp->code;
#line 89
    DisposeLineListContents(& cip->lastFTPCmdResultLL);
#line 92
    cip->lastFTPCmdResultLL = rp->msg;
    }
  }
#line 94
  return;
}
}
#line 174 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/ftw.c"
static int FtwTraverse___1(FtwInfoPtr const   ftwip , size_t dirPathLen , int depth ) 
{ 
  DIR *DIRp ;
  char *cp ;
  size_t fnLen ;
  struct dirent *dentp ;
  mode_t m ;
  char *filename ;
  char *newBuf ;
  char *path ;
  int nSubdirs ;
  FtwSubDirListPtr head ;
  FtwSubDirListPtr tail ;
  FtwSubDirListPtr sdp ;
  FtwSubDirListPtr nextsdp ;
  int rc ;
  int isRootDir ;
  char const   *tmp ;
  char *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 184
  path = ftwip->curPath;
#line 186
  head = (FtwSubDirListPtr )((void *)0);
#line 186
  tail = (FtwSubDirListPtr )((void *)0);
#line 187
  rc = -1;
#line 190
  if (dirPathLen == 1UL) {
#line 190
    if ((int )*(path + 0) == 47) {
#line 190
      isRootDir = 1;
    } else {
#line 190
      isRootDir = 0;
    }
  } else {
#line 190
    isRootDir = 0;
  }
#line 191
  if (dirPathLen) {
#line 191
    tmp = (char const   *)path;
  } else {
#line 191
    tmp = ".";
  }
  {
#line 191
  DIRp = opendir(tmp);
  }
#line 191
  if ((unsigned long )DIRp == (unsigned long )((void *)0)) {
#line 193
    return (0);
  }
#line 196
  nSubdirs = 0;
#line 197
  (ftwip->numDirs) ++;
#line 198
  ftwip->depth = (size_t )depth;
#line 199
  if (ftwip->maxDepth < ftwip->depth) {
#line 200
    ftwip->maxDepth = ftwip->depth;
  }
#line 202
  filename = path + dirPathLen;
#line 203
  if (isRootDir == 0) {
#line 204
    tmp___0 = filename;
#line 204
    filename ++;
#line 204
    *tmp___0 = (char )ftwip->dirSeparator;
#line 205
    dirPathLen ++;
  }
#line 207
  *filename = (char )'\000';
#line 210
  dentp = (struct dirent *)ftwip->direntbuf;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    tmp___1 = Readdir((DIR */* const  */)DIRp, (struct dirent */* const  */)dentp,
                      (size_t const   )ftwip->direntbufSize);
    }
#line 212
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 213
      goto while_break;
    }
#line 214
    cp = dentp->d_name;
#line 215
    if ((int )*(cp + 0) == 46) {
#line 215
      if ((int )*(cp + 1) == 0) {
#line 216
        goto __Cont;
      } else
#line 215
      if ((int )*(cp + 1) == 46) {
#line 215
        if ((int )*(cp + 2) == 0) {
#line 216
          goto __Cont;
        }
      }
    }
    {
#line 218
    *filename = (char )'\000';
#line 219
    tmp___2 = strlen((char const   *)cp);
#line 219
    fnLen = tmp___2 + 1UL;
    }
#line 220
    if (fnLen + dirPathLen > ftwip->curPathAllocSize) {
#line 221
      if (ftwip->autoGrow == 0) {
#line 222
        goto panic;
      } else
#line 223
      if (ftwip->autoGrow == -1) {
#line 224
        goto __Cont;
      }
      {
#line 226
      tmp___3 = realloc((void *)ftwip->curPath, ((fnLen + dirPathLen) + 30UL) + 2UL);
#line 226
      newBuf = (char *)tmp___3;
      }
#line 227
      if ((unsigned long )newBuf == (unsigned long )((void *)0)) {
#line 228
        goto panic;
      }
#line 229
      ftwip->curPath = newBuf;
#line 230
      ftwip->curPathAllocSize = (fnLen + dirPathLen) + 30UL;
#line 231
      path = ftwip->curPath;
#line 232
      filename = path + dirPathLen;
#line 233
      if (isRootDir == 0) {
#line 234
        tmp___4 = filename;
#line 234
        filename ++;
#line 234
        *tmp___4 = (char )ftwip->dirSeparator;
      }
#line 235
      *filename = (char )'\000';
    }
    {
#line 237
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)cp,
           fnLen);
#line 238
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 239
    ftwip->curFile = filename;
#line 240
    ftwip->curFileLen = fnLen - 1UL;
#line 241
    tmp___8 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& ftwip->curStat));
    }
#line 241
    if (tmp___8 == 0) {
#line 242
      m = ftwip->curStat.st_mode;
#line 243
      if ((m & 61440U) == 32768U) {
        {
#line 244
        (ftwip->numFiles) ++;
#line 245
        ftwip->curType = '-';
#line 246
        tmp___5 = (*(ftwip->proc))(ftwip);
        }
#line 246
        if (tmp___5 < 0) {
#line 247
          goto panic;
        }
      } else
#line 250
      if ((m & 61440U) == 40960U) {
        {
#line 251
        ftwip->curType = 'l';
#line 252
        (ftwip->numLinks) ++;
#line 253
        tmp___6 = (*(ftwip->proc))(ftwip);
        }
#line 253
        if (tmp___6 < 0) {
#line 254
          goto panic;
        }
      } else
#line 257
      if ((m & 61440U) == 16384U) {
        {
#line 264
        tmp___7 = malloc(sizeof(FtwSubDirList ) + fnLen);
#line 264
        sdp = (FtwSubDirListPtr )tmp___7;
        }
#line 265
        if ((unsigned long )sdp == (unsigned long )((void *)0)) {
#line 266
          goto panic;
        }
        {
#line 267
        memcpy((void */* __restrict  */)(& sdp->st), (void const   */* __restrict  */)(& ftwip->curStat),
               sizeof(sdp->st));
#line 268
        memcpy((void */* __restrict  */)(sdp->name), (void const   */* __restrict  */)cp,
               fnLen);
#line 269
        sdp->fnLen = fnLen;
#line 270
        sdp->next = (FtwSubDirListPtr )((void *)0);
        }
#line 271
        if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 272
          tail = sdp;
#line 272
          head = tail;
        } else {
#line 274
          tail->next = sdp;
#line 275
          tail = sdp;
        }
#line 277
        nSubdirs ++;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  closedir(DIRp);
#line 282
  DIRp = (DIR *)((void *)0);
#line 285
  sdp = head;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 285
      goto while_break___0;
    }
    {
#line 286
    nextsdp = sdp->next;
#line 287
    memcpy((void */* __restrict  */)(& ftwip->curStat), (void const   */* __restrict  */)(& sdp->st),
           sizeof(ftwip->curStat));
#line 288
    fnLen = sdp->fnLen;
#line 289
    memcpy((void */* __restrict  */)filename, (void const   */* __restrict  */)(sdp->name),
           fnLen);
#line 290
    ftwip->curPathLen = (dirPathLen + fnLen) - 1UL;
#line 291
    ftwip->curFile = filename;
#line 292
    ftwip->curFileLen = fnLen - 1UL;
#line 293
    head = nextsdp;
#line 294
    free((void *)sdp);
#line 296
    ftwip->curType = 'd';
#line 297
    tmp___9 = (*(ftwip->proc))(ftwip);
    }
#line 297
    if (tmp___9 < 0) {
#line 298
      goto panic;
    }
    {
#line 300
    tmp___10 = FtwTraverse___1(ftwip, (dirPathLen + fnLen) - 1UL, depth + 1);
    }
#line 300
    if (tmp___10 < 0) {
#line 301
      goto panic;
    }
#line 306
    path = ftwip->curPath;
#line 307
    filename = path + dirPathLen;
#line 308
    *filename = (char )'\000';
#line 285
    sdp = nextsdp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  head = (FtwSubDirListPtr )((void *)0);
#line 311
  rc = 0;
  panic: 
#line 314
  if ((unsigned long )DIRp != (unsigned long )((void *)0)) {
    {
#line 315
    closedir(DIRp);
    }
  }
#line 317
  sdp = head;
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )sdp != (unsigned long )((void *)0))) {
#line 317
      goto while_break___1;
    }
    {
#line 318
    nextsdp = sdp->next;
#line 319
    free((void *)sdp);
#line 317
    sdp = nextsdp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (rc);
}
}
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64EncodeTable___4[64]  = 
#line 38 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 50 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static unsigned char const   B64DecodeTable___4[256]  = 
#line 50
  {      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'>', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'?', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )':',      (unsigned char const   )';', 
        (unsigned char const   )'<',      (unsigned char const   )'=',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'@',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\000',      (unsigned char const   )'\001',      (unsigned char const   )'\002', 
        (unsigned char const   )'\003',      (unsigned char const   )'\004',      (unsigned char const   )'\005',      (unsigned char const   )'\006', 
        (unsigned char const   )'\a',      (unsigned char const   )'\b',      (unsigned char const   )'\t',      (unsigned char const   )'\n', 
        (unsigned char const   )'\v',      (unsigned char const   )'\f',      (unsigned char const   )'\r',      (unsigned char const   )'\016', 
        (unsigned char const   )'\017',      (unsigned char const   )'\020',      (unsigned char const   )'\021',      (unsigned char const   )'\022', 
        (unsigned char const   )'\023',      (unsigned char const   )'\024',      (unsigned char const   )'\025',      (unsigned char const   )'\026', 
        (unsigned char const   )'\027',      (unsigned char const   )'\030',      (unsigned char const   )'\031',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\032',      (unsigned char const   )'\033',      (unsigned char const   )'\034', 
        (unsigned char const   )'\035',      (unsigned char const   )'\036',      (unsigned char const   )'\037',      (unsigned char const   )' ', 
        (unsigned char const   )'!',      (unsigned char const   )'\"',      (unsigned char const   )'#',      (unsigned char const   )'$', 
        (unsigned char const   )'%',      (unsigned char const   )'&',      (unsigned char const   )'\'',      (unsigned char const   )'(', 
        (unsigned char const   )')',      (unsigned char const   )'*',      (unsigned char const   )'+',      (unsigned char const   )',', 
        (unsigned char const   )'-',      (unsigned char const   )'.',      (unsigned char const   )'/',      (unsigned char const   )'0', 
        (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177', 
        (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177',      (unsigned char const   )'\177'};
#line 648 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/util.c"
static void CancelGetHostByName___4(int sigNum ) 
{ 
  int tmp ;

  {
#line 655
  if (sigNum != 0) {
#line 655
    tmp = 1;
  } else {
#line 655
    tmp = 0;
  }
  {
#line 655
  siglongjmp((struct __jmp_buf_tag *)(gGetHostByNameJmp), tmp);
  }
}
}
#line 96 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int HexCharToNibble___4(int c ) 
{ 


  {
  {
#line 109
  if (c == 57) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 56) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 55) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 54) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 53) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 52) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 51) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 50) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 49) {
#line 109
    goto case_57;
  }
#line 109
  if (c == 48) {
#line 109
    goto case_57;
  }
#line 116
  if (c == 102) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 101) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 100) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 99) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 98) {
#line 116
    goto case_102;
  }
#line 116
  if (c == 97) {
#line 116
    goto case_102;
  }
#line 123
  if (c == 70) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 69) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 68) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 67) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 66) {
#line 123
    goto case_70;
  }
#line 123
  if (c == 65) {
#line 123
    goto case_70;
  }
#line 99
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 110
  return (c - 48);
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 117
  return ((c - 97) + 10);
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 124
  return ((c - 65) + 10);
  switch_break: /* CIL Label */ ;
  }
#line 127
  return (-1);
}
}
#line 495 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSortProc___4(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 498
  tmp = strcasecmp((char const   *)(((Bookmark const   *)a)->bookmarkName), (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 498
  return (tmp);
}
}
#line 503 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int BookmarkSearchProc___4(void const   *key , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = strcasecmp((char const   *)key, (char const   *)(((Bookmark const   *)b)->bookmarkName));
  }
#line 506
  return (tmp);
}
}
#line 578 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static char *BmEscapeTok___4(char *dst , size_t dsize , char *src ) 
{ 
  char *dlim ;
  char *dst0 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 581
  dlim = (dst + dsize) - 1;
#line 582
  dst0 = dst;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    c = (int )*src;
#line 585
    if (! (c != 0)) {
#line 585
      goto while_break;
    }
#line 586
    src ++;
#line 587
    if (c == 92) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 44) {
#line 587
      goto _L;
    } else
#line 587
    if (c == 36) {
      _L: /* CIL Label */ 
#line 589
      if ((unsigned long )(dst + 1) < (unsigned long )dlim) {
#line 590
        tmp = dst;
#line 590
        dst ++;
#line 590
        *tmp = (char )'\\';
#line 591
        tmp___0 = dst;
#line 591
        dst ++;
#line 591
        *tmp___0 = (char )c;
      }
    } else {
      {
#line 593
      tmp___2 = __ctype_b_loc();
      }
#line 593
      if ((int const   )*(*tmp___2 + c) & 16384) {
#line 600
        if ((unsigned long )dst < (unsigned long )dlim) {
#line 601
          tmp___1 = dst;
#line 601
          dst ++;
#line 601
          *tmp___1 = (char )c;
        }
      } else
#line 595
      if ((unsigned long )(dst + 2) < (unsigned long )dlim) {
        {
#line 596
        sprintf((char */* __restrict  */)dst, (char const   */* __restrict  */)"$%02x",
                c);
#line 597
        dst += 3;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *dst = (char )'\000';
#line 605
  return (dst0);
}
}
#line 614 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int WriteBmLine___4(Bookmark *bmp , FILE *outfp , int savePassword ) 
{ 
  char tok[256] ;
  char pass[160] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 620
  tmp = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"%s",
                bmp->bookmarkName);
  }
#line 620
  if (tmp < 0) {
#line 620
    return (-1);
  }
  {
#line 621
  tmp___0 = BmEscapeTok___4(tok, sizeof(tok), bmp->name);
#line 621
  tmp___1 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___0);
  }
#line 621
  if (tmp___1 < 0) {
#line 621
    return (-1);
  }
  {
#line 622
  tmp___2 = BmEscapeTok___4(tok, sizeof(tok), bmp->user);
#line 622
  tmp___3 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___2);
  }
#line 622
  if (tmp___3 < 0) {
#line 622
    return (-1);
  }
#line 623
  if ((int )bmp->pass[0] != 0) {
#line 623
    if (savePassword == 1) {
      {
#line 624
      memcpy((void */* __restrict  */)(pass), (void const   */* __restrict  */)"*encoded*",
             (size_t )9);
#line 625
      tmp___4 = strlen((char const   *)(bmp->pass));
#line 625
      ToBase64((void *)(pass + 9), (void const   *)(bmp->pass), tmp___4, 1);
#line 626
      tmp___5 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                        pass);
      }
#line 626
      if (tmp___5 < 0) {
#line 626
        return (-1);
      }
    } else {
#line 623
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 628
    tmp___6 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                      "");
    }
#line 628
    if (tmp___6 < 0) {
#line 628
      return (-1);
    }
  }
  {
#line 630
  tmp___7 = BmEscapeTok___4(tok, sizeof(tok), bmp->acct);
#line 630
  tmp___8 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                    tmp___7);
  }
#line 630
  if (tmp___8 < 0) {
#line 630
    return (-1);
  }
  {
#line 631
  tmp___9 = BmEscapeTok___4(tok, sizeof(tok), bmp->dir);
#line 631
  tmp___10 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___9);
  }
#line 631
  if (tmp___10 < 0) {
#line 631
    return (-1);
  }
  {
#line 632
  tmp___11 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferType);
  }
#line 632
  if (tmp___11 < 0) {
#line 632
    return (-1);
  }
  {
#line 633
  tmp___12 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%u",
                     bmp->port);
  }
#line 633
  if (tmp___12 < 0) {
#line 633
    return (-1);
  }
  {
#line 634
  tmp___13 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%lu",
                     (unsigned long )bmp->lastCall);
  }
#line 634
  if (tmp___13 < 0) {
#line 634
    return (-1);
  }
  {
#line 635
  tmp___14 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasSIZE);
  }
#line 635
  if (tmp___14 < 0) {
#line 635
    return (-1);
  }
  {
#line 636
  tmp___15 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasMDTM);
  }
#line 636
  if (tmp___15 < 0) {
#line 636
    return (-1);
  }
  {
#line 637
  tmp___16 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasPASV);
  }
#line 637
  if (tmp___16 < 0) {
#line 637
    return (-1);
  }
  {
#line 638
  tmp___17 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->isUnix);
  }
#line 638
  if (tmp___17 < 0) {
#line 638
    return (-1);
  }
  {
#line 639
  tmp___18 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     bmp->lastIP);
  }
#line 639
  if (tmp___18 < 0) {
#line 639
    return (-1);
  }
  {
#line 640
  tmp___19 = BmEscapeTok___4(tok, sizeof(tok), bmp->comment);
#line 640
  tmp___20 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___19);
  }
#line 640
  if (tmp___20 < 0) {
#line 640
    return (-1);
  }
  {
#line 641
  tmp___21 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 641
  if (tmp___21 < 0) {
#line 641
    return (-1);
  }
  {
#line 642
  tmp___22 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 642
  if (tmp___22 < 0) {
#line 642
    return (-1);
  }
  {
#line 643
  tmp___23 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 643
  if (tmp___23 < 0) {
#line 643
    return (-1);
  }
  {
#line 644
  tmp___24 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     "");
  }
#line 644
  if (tmp___24 < 0) {
#line 644
    return (-1);
  }
  {
#line 645
  tmp___25 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%c",
                     bmp->xferMode);
  }
#line 645
  if (tmp___25 < 0) {
#line 645
    return (-1);
  }
  {
#line 646
  tmp___26 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%d",
                     bmp->hasUTIME);
  }
#line 646
  if (tmp___26 < 0) {
#line 646
    return (-1);
  }
  {
#line 647
  tmp___27 = BmEscapeTok___4(tok, sizeof(tok), bmp->ldir);
#line 647
  tmp___28 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)",%s",
                     tmp___27);
  }
#line 647
  if (tmp___28 < 0) {
#line 647
    return (-1);
  }
  {
#line 648
  tmp___29 = fprintf((FILE */* __restrict  */)outfp, (char const   */* __restrict  */)"\n");
  }
#line 648
  if (tmp___29 < 0) {
#line 648
    return (-1);
  }
  {
#line 649
  tmp___30 = fflush(outfp);
  }
#line 649
  if (tmp___30 < 0) {
#line 649
    return (-1);
  }
#line 650
  return (0);
}
}
#line 655 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/bookmark.c"
static int SwapBookmarkFiles___4(void) 
{ 
  char pidStr[32] ;
  char pathName[256] ;
  char path2[256] ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 661
  OurDirectoryPath((char */* const  */)(path2), (size_t const   )sizeof(path2), (char const   */* const  */)"bookmarks");
#line 662
  OurDirectoryPath((char */* const  */)(pathName), (size_t const   )sizeof(pathName),
                   (char const   */* const  */)"bookmarks-tmp");
#line 666
  tmp = getpid();
#line 666
  sprintf((char */* __restrict  */)(pidStr), (char const   */* __restrict  */)"-%u.txt",
          (unsigned int )tmp);
#line 667
  Strncat((char */* const  */)(pathName), (char const   */* const  */)(pidStr), (size_t const   )sizeof(pathName));
#line 669
  remove((char const   *)(path2));
#line 670
  tmp___0 = rename((char const   *)(pathName), (char const   *)(path2));
  }
#line 670
  if (tmp___0 < 0) {
#line 671
    return (-1);
  }
#line 673
  return (0);
}
}
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty1___2  =    1;
#line 29 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static int gIsAtty2___2  =    1;
#line 78 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___8  ;
#line 79 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___8  ;
#line 183 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *uStr___9  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uTotal___3  ;
#line 184 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static double uMult___9  ;
#line 542 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gUsrBinFTPCommands___2[25]  = 
#line 542
  {      "cd ..",      "cd",      "mkdir",      "md", 
        "rmdir",      "rm",      "del",      "delete", 
        "ascii",      "binary",      "bye",      "quit", 
        "exit",      "close",      "dir",      "ls", 
        "mls",      "chmod",      "chown",      "chgrp", 
        "pwd",      "quote",      "ln -s",      "umask", 
        (char const   *)((void *)0)};
#line 570 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/gpshare.c"
static char const   *gValidFTPProtocolCommands___2[25]  = 
#line 570
  {      "CDUP",      "CWD",      "MKD",      "MKD", 
        "RMD",      "DELE",      "DELE",      "DELE", 
        "TYPE A",      "TYPE I",      "QUIT",      "QUIT", 
        "QUIT",      "QUIT",      "STAT",      "STAT", 
        "MLST",      "SITE CHMOD",      "SITE CHOWN",      "SITE CHGRP", 
        "PWD",      "",      "SITE SYMLINK",      "SITE UMASK", 
        (char const   *)((void *)0)};
#line 89 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/spoolutil.c"
static int WriteSpoolLine___2(FILE * const  ofp , char const   * const  line ) 
{ 
  int c ;
  char const   *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 95
  c = 0;
#line 96
  cp = (char const   *)line;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! *cp) {
#line 96
      goto while_break;
    }
#line 97
    c = (int )*cp;
#line 98
    if (c == 10) {
#line 98
      if ((int const   )*(cp + 1) != 0) {
        {
#line 99
        tmp = _IO_putc('\\', (_IO_FILE *)ofp);
        }
#line 99
        if (tmp == -1) {
#line 100
          return (-1);
        }
      }
    }
    {
#line 102
    tmp___0 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 102
    if (tmp___0 == -1) {
#line 103
      return (-1);
    }
#line 96
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (c != 10) {
    {
#line 106
    c = '\n';
#line 107
    tmp___1 = _IO_putc(c, (_IO_FILE *)ofp);
    }
#line 107
    if (tmp___1 == -1) {
#line 108
      return (-1);
    }
  }
#line 110
  return (0);
}
}
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char const   copyright___2[59]  = 
#line 2 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
  {      (char const   )'g',      (char const   )'l',      (char const   )'_',      (char const   )'g', 
        (char const   )'e',      (char const   )'t',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )' ',      (char const   )'C',      (char const   )'o',      (char const   )'p', 
        (char const   )'y',      (char const   )'r',      (char const   )'i',      (char const   )'g', 
        (char const   )'h',      (char const   )'t',      (char const   )' ',      (char const   )'(', 
        (char const   )'C',      (char const   )')',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'1',      (char const   )',', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'2',      (char const   )',',      (char const   )' ',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'3',      (char const   )',', 
        (char const   )' ',      (char const   )'C',      (char const   )'h',      (char const   )'r', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'T', 
        (char const   )'h',      (char const   )'e',      (char const   )'w',      (char const   )'a', 
        (char const   )'l',      (char const   )'t',      (char const   )'\000'};
#line 167
static int gl_tab___2(char *buf , int offset , int *loc , size_t bufsize ) ;
#line 185 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_killbuf___2[256]  ;
#line 186 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_init_done___2  =    -1;
#line 187 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_termw___2  =    80;
#line 188 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_termh___2  =    24;
#line 189 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_scroll___2  =    27;
#line 190 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_width___2  =    0;
#line 191 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_extent___2  =    0;
#line 192 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_overwrite___2  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_pos___2  =    0;
#line 193 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_cnt___2  =    0;
#line 194 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char const   *gl_prompt___2  ;
#line 195 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_intrc___2  =    (char)0;
#line 196 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_quitc___2  =    (char)0;
#line 197 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_suspc___2  =    (char)0;
#line 198 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char gl_dsuspc___2  =    (char)0;
#line 199 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_search_mode___2  =    0;
#line 200 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char **gl_matchlist___2  =    (char **)0;
#line 201 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *gl_home_dir___2  =    (char *)((void *)0);
#line 202 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_vi_preferred___2  =    -1;
#line 203 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_vi_mode___2  =    0;
#line 204 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_result___2  =    0;
#line 206
static void gl_init___2(void) ;
#line 207
static void gl_cleanup___2(void) ;
#line 208
static void gl_char_init___2(void) ;
#line 209
static void gl_char_cleanup___2(void) ;
#line 212
static void gl_addchar___2(int c ) ;
#line 213
static void gl_del___2(int loc , int killsave ) ;
#line 214
static void gl_error___2(char const   * const  buf ) ;
#line 215
static void gl_fixup___2(char const   *prompt , int change , int cursor ) ;
#line 216
static int gl_getc___2(void) ;
#line 217
static int gl_getcx___2(int tlen ) ;
#line 218
static void gl_kill___2(int pos ) ;
#line 219
static void gl_newline___2(void) ;
#line 220
static void gl_putc___2(int c ) ;
#line 221
static void gl_puts___2(char const   *buf ) ;
#line 222
static void gl_redraw___2(void) ;
#line 223
static void gl_transpose___2(void) ;
#line 224
static void gl_yank___2(void) ;
#line 225
static void gl_word___2(int direction ) ;
#line 226
static void gl_killword___2(int direction ) ;
#line 228
static void hist_init___2(void) ;
#line 229
static void hist_dispose___2(void) ;
#line 230
static char *hist_next___2(void) ;
#line 231
static char *hist_prev___2(void) ;
#line 232
static char *hist_save___2(char const   * const  p___5 ) ;
#line 234
static void search_addchar___2(int c ) ;
#line 235
static void search_term___2(void) ;
#line 236
static void search_back___2(int new_search ) ;
#line 237
static void search_forw___2(int new_search ) ;
#line 238
static void gl_beep___2(void) ;
#line 240
static int gl_do_tab_completion___2(char *buf , int *loc , size_t bufsize , int tabtab ) ;
#line 248 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_char_init___2(void) 
{ 
  int tmp ;

  {
  {
#line 253
  tmp = tcgetattr(0, & old_termios);
  }
#line 253
  if (tmp == 0) {
#line 254
    gl_intrc___2 = (char )old_termios.c_cc[0];
#line 255
    gl_quitc___2 = (char )old_termios.c_cc[1];
#line 257
    gl_suspc___2 = (char )old_termios.c_cc[10];
  }
  {
#line 263
  new_termios = old_termios;
#line 264
  new_termios.c_iflag &= 4294962141U;
#line 265
  new_termios.c_iflag |= 5U;
#line 266
  new_termios.c_lflag &= 4294934516U;
#line 267
  new_termios.c_cc[6] = (cc_t )1;
#line 268
  new_termios.c_cc[5] = (cc_t )0;
#line 269
  tcsetattr(0, 0, (struct termios  const  *)(& new_termios));
  }
#line 297
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_char_cleanup___2(void) 
{ 


  {
  {
#line 304
  tcsetattr(0, 0, (struct termios  const  *)(& old_termios));
  }
#line 311
  return;
}
}
#line 373 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_getc___2(void) 
{ 
  int c ;
  unsigned char ch ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 383
  ch = (unsigned char )'\000';
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 384
    tmp___0 = read(0, (void *)(& ch), (size_t )1);
#line 384
    c = (int )tmp___0;
    }
#line 384
    if (! (c == -1)) {
#line 384
      goto while_break;
    }
    {
#line 385
    tmp = __errno_location();
    }
#line 385
    if (*tmp != 4) {
#line 386
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  if (c != -1) {
#line 389
    c = (int )ch;
  }
#line 412
  return (c);
}
}
#line 419 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_getcx___2(int tlen ) 
{ 
  int c ;
  int result ;
  char ch ;
  fd_set ss ;
  struct timeval tv ;
  int *tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 430
  tmp = __errno_location();
#line 430
  *tmp = 0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ss.__fds_bits[0]): "memory");
#line 431
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 436
    ss.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 440
    tv.tv_sec = (__time_t )((long long )(tlen / 10));
#line 441
    tv.tv_usec = (__suseconds_t )((long long )((tlen % 10) * 100000));
#line 442
    result = select(1, (fd_set */* __restrict  */)(& ss), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 443
    if (result == 1) {
#line 445
      goto while_break;
    } else
#line 446
    if (result == 0) {
      {
#line 447
      tmp___0 = __errno_location();
#line 447
      *tmp___0 = 110;
      }
#line 448
      return (-2);
    } else {
      {
#line 449
      tmp___1 = __errno_location();
      }
#line 449
      if (*tmp___1 != 4) {
#line 450
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  tmp___2 = __errno_location();
#line 454
  *tmp___2 = 0;
  }
  {
#line 454
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 455
    tmp___3 = read(0, (void *)(& ch), (size_t )1);
#line 455
    c = (int )tmp___3;
    }
#line 456
    if (c == 1) {
#line 457
      return ((int )ch);
    }
    {
#line 458
    tmp___4 = __errno_location();
    }
#line 458
    if (*tmp___4 != 4) {
#line 459
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 462
  return (-1);
}
}
#line 501 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_putc___2(int c ) 
{ 
  char ch ;

  {
  {
#line 504
  ch = (char )((unsigned char )c);
#line 506
  write(1, (void const   *)(& ch), (size_t )1);
  }
#line 507
  if ((int )ch == 10) {
    {
#line 508
    ch = (char )'\r';
#line 509
    write(1, (void const   *)(& ch), (size_t )1);
    }
  }
#line 511
  return;
}
}
#line 515 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_puts___2(char const   *buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
#line 554
  if (buf) {
    {
#line 555
    tmp = strlen(buf);
#line 555
    len = tmp;
#line 556
    write(1, (void const   *)buf, len);
    }
  }
#line 559
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_error___2(char const   * const  buf ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 564
  tmp = strlen((char const   *)buf);
#line 564
  len = tmp;
#line 566
  gl_cleanup___2();
#line 567
  write(2, (void const   *)buf, len);
#line 568
  exit(1);
  }
}
}
#line 571 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_init___2(void) 
{ 
  char const   *cp ;
  int w ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 579
  tmp = strncmp(copyright___2, "gl_getline", (size_t )7);
  }
#line 579
  if (tmp != 0) {
    {
#line 580
    exit(1);
    }
  }
#line 582
  if (gl_init_done___2 < 0) {
    {
#line 583
    tmp___0 = getenv("COLUMNS");
#line 583
    cp = (char const   *)tmp___0;
    }
#line 584
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 585
      w = atoi(cp);
      }
#line 586
      if (w > 20) {
        {
#line 587
        gl_setwidth(w);
        }
      }
    }
    {
#line 589
    tmp___1 = getenv("ROWS");
#line 589
    cp = (char const   *)tmp___1;
    }
#line 590
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 591
      w = atoi(cp);
      }
#line 592
      if (w > 10) {
        {
#line 593
        gl_setheight(w);
        }
      }
    }
    {
#line 595
    hist_init___2();
    }
  }
  {
#line 597
  tmp___2 = isatty(0);
  }
#line 597
  if (tmp___2 == 0) {
    {
#line 598
    gl_error___2((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
    }
  } else {
    {
#line 597
    tmp___3 = isatty(1);
    }
#line 597
    if (tmp___3 == 0) {
      {
#line 598
      gl_error___2((char const   */* const  */)"\n*** Error: gl_getline(): not interactive, use stdio.\n");
      }
    }
  }
  {
#line 599
  gl_char_init___2();
#line 600
  gl_init_done___2 = 1;
  }
#line 601
  return;
}
}
#line 603 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_cleanup___2(void) 
{ 


  {
#line 607
  if (gl_init_done___2 > 0) {
    {
#line 608
    gl_char_cleanup___2();
    }
  }
#line 609
  gl_init_done___2 = 0;
#line 614
  return;
}
}
#line 629 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_check_inputrc_for_vi___2(void) 
{ 
  FILE *fp ;
  char path[256] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 644
  gl_set_home_dir((char const   *)((void *)0));
  }
#line 645
  if ((unsigned long )gl_home_dir___2 == (unsigned long )((void *)0)) {
#line 646
    return;
  }
  {
#line 649
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s",
           gl_home_dir___2, ".inputrc");
#line 657
  fp = fopen((char const   */* __restrict  */)(path), (char const   */* __restrict  */)"r");
  }
#line 666
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 667
    return;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 669
    tmp___1 = fgets((char */* __restrict  */)(path), (int )(sizeof(path) - 1UL), (FILE */* __restrict  */)fp);
    }
#line 669
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 669
      goto while_break;
    }
    {
#line 670
    tmp = strstr((char const   *)(path), "editing-mode");
    }
#line 670
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 670
      tmp___0 = strstr((char const   *)(path), "vi");
      }
#line 670
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 671
        gl_vi_preferred___2 = 1;
#line 672
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  fclose(fp);
  }
#line 677
  return;
}
}
#line 1122 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_addchar___2(int c ) 
{ 
  int i___0 ;

  {
#line 1128
  if (gl_cnt___2 >= 2047) {
    {
#line 1129
    gl_error___2((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1130
  if (gl_overwrite___2 == 0) {
#line 1130
    goto _L;
  } else
#line 1130
  if (gl_pos___2 == gl_cnt___2) {
    _L: /* CIL Label */ 
#line 1131
    i___0 = gl_cnt___2;
    {
#line 1131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1131
      if (! (i___0 >= gl_pos___2)) {
#line 1131
        goto while_break;
      }
#line 1132
      gl_buf[i___0 + 1] = gl_buf[i___0];
#line 1131
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1133
    gl_buf[gl_pos___2] = (char )c;
#line 1134
    gl_fixup___2(gl_prompt___2, gl_pos___2, gl_pos___2 + 1);
    }
  } else {
    {
#line 1136
    gl_buf[gl_pos___2] = (char )c;
#line 1137
    gl_extent___2 = 1;
#line 1138
    gl_fixup___2(gl_prompt___2, gl_pos___2, gl_pos___2 + 1);
    }
  }
#line 1140
  return;
}
}
#line 1142 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_yank___2(void) 
{ 
  int i___0 ;
  int len ;
  size_t tmp ;

  {
  {
#line 1148
  tmp = strlen((char const   *)(gl_killbuf___2));
#line 1148
  len = (int )tmp;
  }
#line 1149
  if (len > 0) {
#line 1150
    if (gl_overwrite___2 == 0) {
#line 1151
      if (gl_cnt___2 + len >= 2047) {
        {
#line 1152
        gl_error___2((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
        }
      }
#line 1153
      i___0 = gl_cnt___2;
      {
#line 1153
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1153
        if (! (i___0 >= gl_pos___2)) {
#line 1153
          goto while_break;
        }
#line 1154
        gl_buf[i___0 + len] = gl_buf[i___0];
#line 1153
        i___0 --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1155
      i___0 = 0;
      {
#line 1155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1155
        if (! (i___0 < len)) {
#line 1155
          goto while_break___0;
        }
#line 1156
        gl_buf[gl_pos___2 + i___0] = gl_killbuf___2[i___0];
#line 1155
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1157
      gl_fixup___2(gl_prompt___2, gl_pos___2, gl_pos___2 + len);
      }
    } else {
#line 1159
      if (gl_pos___2 + len > gl_cnt___2) {
#line 1160
        if (gl_pos___2 + len >= 2047) {
          {
#line 1161
          gl_error___2((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
          }
        }
#line 1162
        gl_buf[gl_pos___2 + len] = (char)0;
      }
#line 1164
      i___0 = 0;
      {
#line 1164
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1164
        if (! (i___0 < len)) {
#line 1164
          goto while_break___1;
        }
#line 1165
        gl_buf[gl_pos___2 + i___0] = gl_killbuf___2[i___0];
#line 1164
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1166
      gl_extent___2 = len;
#line 1167
      gl_fixup___2(gl_prompt___2, gl_pos___2, gl_pos___2 + len);
      }
    }
  } else {
    {
#line 1170
    gl_beep___2();
    }
  }
#line 1171
  return;
}
}
#line 1173 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_transpose___2(void) 
{ 
  int c ;

  {
#line 1179
  if (gl_pos___2 > 0) {
#line 1179
    if (gl_cnt___2 > gl_pos___2) {
      {
#line 1180
      c = (int )gl_buf[gl_pos___2 - 1];
#line 1181
      gl_buf[gl_pos___2 - 1] = gl_buf[gl_pos___2];
#line 1182
      gl_buf[gl_pos___2] = (char )c;
#line 1183
      gl_extent___2 = 2;
#line 1184
      gl_fixup___2(gl_prompt___2, gl_pos___2 - 1, gl_pos___2);
      }
    } else {
      {
#line 1186
      gl_beep___2();
      }
    }
  } else {
    {
#line 1186
    gl_beep___2();
    }
  }
#line 1187
  return;
}
}
#line 1189 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_newline___2(void) 
{ 
  int change ;
  int len ;
  int loc ;
  size_t tmp ;

  {
#line 1196
  change = gl_cnt___2;
#line 1197
  len = gl_cnt___2;
#line 1198
  loc = gl_width___2 - 5;
#line 1200
  if (gl_cnt___2 >= 2047) {
    {
#line 1201
    gl_error___2((char const   */* const  */)"\n*** Error: gl_getline(): input buffer overflow\n");
    }
  }
#line 1202
  if (gl_out_hook) {
    {
#line 1203
    change = (*gl_out_hook)(gl_buf);
#line 1204
    tmp = strlen((char const   *)(gl_buf));
#line 1204
    len = (int )tmp;
    }
  }
#line 1206
  if (loc > len) {
#line 1207
    loc = len;
  }
  {
#line 1208
  gl_fixup___2(gl_prompt___2, change, loc);
#line 1209
  gl_buf[len] = (char )'\n';
#line 1210
  gl_buf[len + 1] = (char )'\000';
#line 1211
  gl_putc___2('\n');
  }
#line 1212
  return;
}
}
#line 1214 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_del___2(int loc , int killsave ) 
{ 
  int i___0 ;
  int j ;

  {
#line 1225
  if (loc == -1) {
#line 1225
    if (gl_pos___2 > 0) {
#line 1225
      goto _L;
    } else {
#line 1225
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1225
  if (loc == 0) {
#line 1225
    if (gl_pos___2 < gl_cnt___2) {
      _L: /* CIL Label */ 
#line 1226
      j = 0;
#line 1226
      i___0 = gl_pos___2 + loc;
      {
#line 1226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1226
        if (! (i___0 < gl_cnt___2)) {
#line 1226
          goto while_break;
        }
#line 1227
        if (j == 0) {
#line 1227
          if (killsave != 0) {
#line 1227
            if (gl_vi_mode___2 != 0) {
#line 1228
              gl_killbuf___2[0] = gl_buf[i___0];
#line 1229
              gl_killbuf___2[1] = (char )'\000';
#line 1230
              j = 1;
            }
          }
        }
#line 1232
        gl_buf[i___0] = gl_buf[i___0 + 1];
#line 1226
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1234
      gl_fixup___2(gl_prompt___2, gl_pos___2 + loc, gl_pos___2 + loc);
      }
    } else {
      {
#line 1236
      gl_beep___2();
      }
    }
  } else {
    {
#line 1236
    gl_beep___2();
    }
  }
#line 1237
  return;
}
}
#line 1239 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_kill___2(int pos ) 
{ 
  size_t tmp ;

  {
#line 1244
  if (pos < gl_cnt___2) {
    {
#line 1244
    tmp = strlen((char const   *)(gl_buf + pos));
    }
#line 1244
    if (tmp < sizeof(gl_killbuf___2)) {
      {
#line 1245
      strcpy((char */* __restrict  */)(gl_killbuf___2), (char const   */* __restrict  */)(gl_buf + pos));
#line 1246
      gl_buf[pos] = (char )'\000';
#line 1247
      gl_fixup___2(gl_prompt___2, pos, pos);
      }
    } else {
      {
#line 1249
      gl_beep___2();
      }
    }
  } else {
    {
#line 1249
    gl_beep___2();
    }
  }
#line 1250
  return;
}
}
#line 1252 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_killword___2(int direction ) 
{ 
  int pos ;
  int startpos ;
  int tmp ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 1255
  pos = gl_pos___2;
#line 1256
  startpos = gl_pos___2;
#line 1260
  if (direction > 0) {
    {
#line 1261
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1261
      tmp___0 = __ctype_b_loc();
      }
#line 1261
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1261
        goto while_break;
      } else
#line 1261
      if (! (pos < gl_cnt___2)) {
#line 1261
        goto while_break;
      }
#line 1262
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1263
      tmp___1 = __ctype_b_loc();
      }
#line 1263
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1263
        if (! (pos < gl_cnt___2)) {
#line 1263
          goto while_break___0;
        }
      } else {
#line 1263
        goto while_break___0;
      }
#line 1264
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1266
    if (pos > 0) {
#line 1267
      pos --;
    }
    {
#line 1268
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1268
      tmp___2 = __ctype_b_loc();
      }
#line 1268
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1268
        if (! (pos > 0)) {
#line 1268
          goto while_break___1;
        }
      } else {
#line 1268
        goto while_break___1;
      }
#line 1269
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1270
      tmp___3 = __ctype_b_loc();
      }
#line 1270
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1270
        goto while_break___2;
      } else
#line 1270
      if (! (pos > 0)) {
#line 1270
        goto while_break___2;
      }
#line 1271
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1272
    if (pos < gl_cnt___2) {
      {
#line 1272
      tmp___4 = __ctype_b_loc();
      }
#line 1272
      if ((int const   )*(*tmp___4 + (int )gl_buf[pos]) & 8192) {
#line 1273
        pos ++;
      }
    }
  }
#line 1275
  if (pos < startpos) {
#line 1276
    tmp = pos;
#line 1277
    pos = startpos;
#line 1278
    startpos = tmp;
  }
#line 1280
  if ((size_t )(pos - startpos) >= sizeof(gl_killbuf___2)) {
    {
#line 1281
    gl_beep___2();
    }
#line 1282
    return;
  }
  {
#line 1284
  memcpy((void */* __restrict  */)(gl_killbuf___2), (void const   */* __restrict  */)(gl_buf + startpos),
         (size_t )(pos - startpos));
#line 1285
  gl_killbuf___2[pos - startpos] = (char )'\000';
#line 1286
  tmp___5 = __ctype_b_loc();
  }
#line 1286
  if ((int const   )*(*tmp___5 + (int )gl_killbuf___2[(pos - startpos) - 1]) & 8192) {
#line 1287
    gl_killbuf___2[(pos - startpos) - 1] = (char )'\000';
  }
  {
#line 1288
  gl_fixup___2(gl_prompt___2, -1, startpos);
#line 1289
  i___0 = 0;
#line 1289
  tmp = pos - startpos;
  }
  {
#line 1289
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1289
    if (! (i___0 < tmp)) {
#line 1289
      goto while_break___3;
    }
    {
#line 1290
    gl_del___2(0, 0);
#line 1289
    i___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1291
  return;
}
}
#line 1293 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_word___2(int direction ) 
{ 
  int pos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1298
  pos = gl_pos___2;
#line 1300
  if (direction > 0) {
    {
#line 1301
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1301
      tmp = __ctype_b_loc();
      }
#line 1301
      if ((int const   )*(*tmp + (int )gl_buf[pos]) & 8192) {
#line 1301
        goto while_break;
      } else
#line 1301
      if (! (pos < gl_cnt___2)) {
#line 1301
        goto while_break;
      }
#line 1302
      pos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1303
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1303
      tmp___0 = __ctype_b_loc();
      }
#line 1303
      if ((int const   )*(*tmp___0 + (int )gl_buf[pos]) & 8192) {
#line 1303
        if (! (pos < gl_cnt___2)) {
#line 1303
          goto while_break___0;
        }
      } else {
#line 1303
        goto while_break___0;
      }
#line 1304
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1306
    if (pos > 0) {
#line 1307
      pos --;
    }
    {
#line 1308
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1308
      tmp___1 = __ctype_b_loc();
      }
#line 1308
      if ((int const   )*(*tmp___1 + (int )gl_buf[pos]) & 8192) {
#line 1308
        if (! (pos > 0)) {
#line 1308
          goto while_break___1;
        }
      } else {
#line 1308
        goto while_break___1;
      }
#line 1309
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1310
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1310
      tmp___2 = __ctype_b_loc();
      }
#line 1310
      if ((int const   )*(*tmp___2 + (int )gl_buf[pos]) & 8192) {
#line 1310
        goto while_break___2;
      } else
#line 1310
      if (! (pos > 0)) {
#line 1310
        goto while_break___2;
      }
#line 1311
      pos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1312
    if (pos < gl_cnt___2) {
      {
#line 1312
      tmp___3 = __ctype_b_loc();
      }
#line 1312
      if ((int const   )*(*tmp___3 + (int )gl_buf[pos]) & 8192) {
#line 1313
        pos ++;
      }
    }
  }
  {
#line 1315
  gl_fixup___2(gl_prompt___2, -1, pos);
  }
#line 1316
  return;
}
}
#line 1318 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_redraw___2(void) 
{ 


  {
#line 1322
  if (gl_init_done___2 > 0) {
    {
#line 1323
    gl_putc___2('\n');
#line 1324
    gl_fixup___2(gl_prompt___2, -2, gl_pos___2);
    }
  }
#line 1326
  return;
}
}
#line 1344 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_shift___2  ;
#line 1345 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int off_right___2  ;
#line 1346 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int off_left___2  ;
#line 1347 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char last_prompt___2[80]  = {      (char )'\000'};
#line 1328 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_fixup___2(char const   *prompt , int change , int cursor ) 
{ 
  int left ;
  int right ;
  int pad ;
  int backup ;
  int new_shift ;
  int extra ;
  int i___0 ;
  int new_right ;
  int l1 ;
  int l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1348
  left = 0;
#line 1348
  right = -1;
#line 1354
  new_right = -1;
#line 1357
  if (change == -2) {
    {
#line 1358
    off_left___2 = 0;
#line 1358
    off_right___2 = off_left___2;
#line 1358
    gl_shift___2 = off_right___2;
#line 1358
    gl_cnt___2 = gl_shift___2;
#line 1358
    gl_pos___2 = gl_cnt___2;
#line 1359
    gl_putc___2('\r');
#line 1360
    gl_puts___2(prompt);
#line 1361
    strncpy((char */* __restrict  */)(last_prompt___2), (char const   */* __restrict  */)prompt,
            sizeof(last_prompt___2) - 1UL);
#line 1362
    last_prompt___2[sizeof(last_prompt___2) - 1UL] = (char )'\000';
#line 1363
    change = 0;
#line 1364
    tmp = (*gl_strlen)(prompt);
#line 1364
    l2 = (int )tmp;
#line 1365
    gl_width___2 = gl_termw___2 - l2;
    }
  } else {
    {
#line 1366
    tmp___2 = strcmp(prompt, (char const   *)(last_prompt___2));
    }
#line 1366
    if (tmp___2 != 0) {
      {
#line 1367
      tmp___0 = (*gl_strlen)((char const   *)(last_prompt___2));
#line 1367
      l1 = (int )tmp___0;
#line 1368
      tmp___1 = (*gl_strlen)(prompt);
#line 1368
      l2 = (int )tmp___1;
#line 1369
      gl_cnt___2 = (gl_cnt___2 + l1) - l2;
#line 1370
      strcpy((char */* __restrict  */)(last_prompt___2), (char const   */* __restrict  */)prompt);
#line 1371
      gl_putc___2('\r');
#line 1372
      gl_puts___2(prompt);
#line 1373
      gl_pos___2 = gl_shift___2;
#line 1374
      gl_width___2 = gl_termw___2 - l2;
#line 1375
      change = 0;
      }
    }
  }
#line 1377
  if (off_right___2) {
#line 1377
    pad = gl_width___2 - 1;
  } else {
#line 1377
    pad = gl_cnt___2 - gl_shift___2;
  }
#line 1378
  backup = gl_pos___2 - gl_shift___2;
#line 1379
  if (change >= 0) {
    {
#line 1380
    tmp___3 = strlen((char const   *)(gl_buf));
#line 1380
    gl_cnt___2 = (int )tmp___3;
    }
#line 1381
    if (change > gl_cnt___2) {
#line 1382
      change = gl_cnt___2;
    }
  }
#line 1384
  if (cursor > gl_cnt___2) {
#line 1385
    if (cursor != 2048) {
#line 1386
      if (gl_ellipses_during_completion == 0) {
        {
#line 1387
        gl_beep___2();
        }
      }
    }
#line 1390
    cursor = gl_cnt___2;
  }
#line 1392
  if (cursor < 0) {
    {
#line 1393
    gl_beep___2();
#line 1394
    cursor = 0;
    }
  }
#line 1396
  if (off_right___2) {
#line 1397
    extra = 2;
  } else
#line 1396
  if (off_left___2) {
#line 1396
    if (cursor < (gl_shift___2 + gl_width___2) - gl_scroll___2 / 2) {
#line 1397
      extra = 2;
    } else {
#line 1399
      extra = 0;
    }
  } else {
#line 1399
    extra = 0;
  }
#line 1400
  new_shift = ((cursor + extra) + gl_scroll___2) - gl_width___2;
#line 1401
  if (new_shift > 0) {
#line 1402
    new_shift /= gl_scroll___2;
#line 1403
    new_shift *= gl_scroll___2;
  } else {
#line 1405
    new_shift = 0;
  }
#line 1406
  if (new_shift != gl_shift___2) {
#line 1407
    gl_shift___2 = new_shift;
#line 1408
    if (gl_shift___2) {
#line 1408
      off_left___2 = 1;
    } else {
#line 1408
      off_left___2 = 0;
    }
#line 1409
    if (gl_cnt___2 > (gl_shift___2 + gl_width___2) - 1) {
#line 1409
      off_right___2 = 1;
    } else {
#line 1409
      off_right___2 = 0;
    }
#line 1410
    left = gl_shift___2;
#line 1411
    if (off_right___2) {
#line 1411
      right = (gl_shift___2 + gl_width___2) - 2;
    } else {
#line 1411
      right = gl_cnt___2;
    }
#line 1411
    new_right = right;
  } else
#line 1412
  if (change >= 0) {
#line 1413
    if (change < gl_shift___2 + off_left___2) {
#line 1414
      left = gl_shift___2;
    } else {
#line 1416
      left = change;
#line 1417
      backup = gl_pos___2 - change;
    }
#line 1419
    if (gl_cnt___2 > (gl_shift___2 + gl_width___2) - 1) {
#line 1419
      off_right___2 = 1;
    } else {
#line 1419
      off_right___2 = 0;
    }
#line 1420
    if (off_right___2) {
#line 1420
      right = (gl_shift___2 + gl_width___2) - 2;
    } else {
#line 1420
      right = gl_cnt___2;
    }
#line 1421
    if (gl_extent___2) {
#line 1421
      if (right > left + gl_extent___2) {
#line 1421
        new_right = left + gl_extent___2;
      } else {
#line 1421
        new_right = right;
      }
    } else {
#line 1421
      new_right = right;
    }
  }
#line 1424
  if (off_right___2) {
#line 1424
    tmp___4 = gl_width___2 - 1;
  } else {
#line 1424
    tmp___4 = gl_cnt___2 - gl_shift___2;
  }
#line 1424
  pad -= tmp___4;
#line 1425
  if (pad < 0) {
#line 1425
    pad = 0;
  } else {
#line 1425
    pad = pad;
  }
#line 1426
  if (left <= right) {
#line 1427
    i___0 = 0;
    {
#line 1427
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1427
      if (! (i___0 < backup)) {
#line 1427
        goto while_break;
      }
      {
#line 1428
      gl_putc___2('\b');
#line 1427
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1429
    if (left == gl_shift___2) {
#line 1429
      if (off_left___2) {
        {
#line 1430
        gl_putc___2('$');
#line 1431
        left ++;
        }
      }
    }
#line 1433
    i___0 = left;
    {
#line 1433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1433
      if (! (i___0 < new_right)) {
#line 1433
        goto while_break___0;
      }
      {
#line 1434
      gl_putc___2((int )gl_buf[i___0]);
#line 1433
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1435
    gl_pos___2 = new_right;
#line 1436
    if (off_right___2) {
#line 1436
      if (new_right == right) {
        {
#line 1437
        gl_putc___2('$');
#line 1438
        gl_pos___2 ++;
        }
      } else {
#line 1436
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1440
      i___0 = 0;
      {
#line 1440
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1440
        if (! (i___0 < pad)) {
#line 1440
          goto while_break___1;
        }
        {
#line 1441
        gl_putc___2(' ');
#line 1440
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1442
      gl_pos___2 += pad;
    }
  }
#line 1445
  i___0 = gl_pos___2 - cursor;
#line 1446
  if (i___0 > 0) {
    {
#line 1447
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1447
      tmp___5 = i___0;
#line 1447
      i___0 --;
#line 1447
      if (! tmp___5) {
#line 1447
        goto while_break___2;
      }
      {
#line 1448
      gl_putc___2('\b');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1450
    i___0 = gl_pos___2;
    {
#line 1450
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1450
      if (! (i___0 < cursor)) {
#line 1450
        goto while_break___3;
      }
      {
#line 1451
      gl_putc___2((int )gl_buf[i___0]);
#line 1450
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1453
  gl_pos___2 = cursor;
#line 1454
  return;
}
}
#line 1456 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_tab___2(char *buf , int offset , int *loc , size_t bufsize ) 
{ 
  int i___0 ;
  int count ;
  int len ;
  size_t tmp ;

  {
  {
#line 1462
  tmp = strlen((char const   *)buf);
#line 1462
  len = (int )tmp;
#line 1463
  count = 8 - (offset + *loc) % 8;
#line 1464
  i___0 = len;
  }
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    if (! (i___0 >= *loc)) {
#line 1464
      goto while_break;
    }
#line 1465
    if (i___0 + count < (int )bufsize) {
#line 1466
      *(buf + (i___0 + count)) = *(buf + i___0);
    }
#line 1464
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1467
  i___0 = 0;
  {
#line 1467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1467
    if (! (i___0 < count)) {
#line 1467
      goto while_break___0;
    }
#line 1468
    if (*loc + i___0 < (int )bufsize) {
#line 1469
      *(buf + (*loc + i___0)) = (char )' ';
    }
#line 1467
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1470
  i___0 = *loc;
#line 1471
  *loc = i___0 + count;
#line 1472
  return (i___0);
}
}
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int hist_pos___2  =    0;
#line 1481 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int hist_last___2  =    0;
#line 1482 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_buf___2[100]  ;
#line 1483 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char hist_empty_elem___2[2]  = {      (char )'\000'};
#line 1485 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void hist_init___2(void) 
{ 
  int i___0 ;

  {
#line 1490
  hist_buf___2[0] = hist_empty_elem___2;
#line 1491
  i___0 = 1;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if (! (i___0 < 100)) {
#line 1491
      goto while_break;
    }
#line 1492
    hist_buf___2[i___0] = (char *)0;
#line 1491
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1493
  hist_last___2 = 0;
#line 1493
  hist_pos___2 = hist_last___2;
#line 1494
  return;
}
}
#line 1496 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void hist_dispose___2(void) 
{ 
  int i___0 ;

  {
#line 1501
  i___0 = 0;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! (i___0 < 100)) {
#line 1501
      goto while_break;
    }
#line 1502
    if ((unsigned long )hist_buf___2[i___0] != (unsigned long )(hist_empty_elem___2)) {
#line 1502
      if ((unsigned long )hist_buf___2[i___0] != (unsigned long )((char *)0)) {
        {
#line 1503
        free((void *)hist_buf___2[i___0]);
#line 1504
        hist_buf___2[i___0] = (char *)0;
        }
      }
    }
#line 1501
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1509
  hist_buf___2[0] = hist_empty_elem___2;
#line 1510
  hist_last___2 = 0;
#line 1510
  hist_pos___2 = hist_last___2;
#line 1511
  return;
}
}
#line 1516 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *prev___2  =    (char *)0;
#line 1545 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_prev___2(void) 
{ 
  char *p___5 ;
  int next ;

  {
#line 1549
  p___5 = (char *)0;
#line 1550
  next = ((hist_pos___2 - 1) + 100) % 100;
#line 1552
  if ((unsigned long )hist_buf___2[hist_pos___2] != (unsigned long )((char *)0)) {
#line 1552
    if (next != hist_last___2) {
#line 1553
      hist_pos___2 = next;
#line 1554
      p___5 = hist_buf___2[hist_pos___2];
    }
  }
#line 1556
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1557
    p___5 = hist_empty_elem___2;
#line 1558
    gl_beep___2();
    }
  }
#line 1560
  return (p___5);
}
}
#line 1563 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_next___2(void) 
{ 
  char *p___5 ;

  {
#line 1567
  p___5 = (char *)0;
#line 1569
  if (hist_pos___2 != hist_last___2) {
#line 1570
    hist_pos___2 = (hist_pos___2 + 1) % 100;
#line 1571
    p___5 = hist_buf___2[hist_pos___2];
  }
#line 1573
  if ((unsigned long )p___5 == (unsigned long )((char *)0)) {
    {
#line 1574
    p___5 = hist_empty_elem___2;
#line 1575
    gl_beep___2();
    }
  }
#line 1577
  return (p___5);
}
}
#line 1580 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char *hist_save___2(char const   * const  p___5 ) 
{ 
  char *s ;
  size_t len ;
  size_t tmp ;
  char *nl___0 ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1584
  s = (char *)0;
#line 1585
  tmp = strlen((char const   *)p___5);
#line 1585
  len = tmp;
#line 1586
  tmp___0 = strpbrk((char const   *)p___5, "\n\r");
#line 1586
  nl___0 = tmp___0;
  }
#line 1588
  if (nl___0) {
    {
#line 1589
    tmp___1 = malloc(len);
#line 1589
    s = (char *)tmp___1;
    }
#line 1589
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1590
      strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5,
              len - 1UL);
#line 1591
      *(s + (len - 1UL)) = (char)0;
      }
    }
  } else {
    {
#line 1594
    tmp___2 = malloc(len + 1UL);
#line 1594
    s = (char *)tmp___2;
    }
#line 1594
    if ((unsigned long )s != (unsigned long )((char *)0)) {
      {
#line 1595
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)p___5);
      }
    }
  }
#line 1598
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 1599
    gl_error___2((char const   */* const  */)"\n*** Error: hist_save() failed on malloc\n");
    }
  }
#line 1600
  return (s);
}
}
#line 1662 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char search_prompt___2[101]  ;
#line 1663 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static char search_string___2[100]  ;
#line 1664 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_pos___2  =    0;
#line 1665 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_forw_flg___2  =    0;
#line 1666 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int search_last___2  =    0;
#line 1668 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_update___2(int c ) 
{ 


  {
#line 1671
  if (c == 0) {
#line 1672
    search_pos___2 = 0;
#line 1673
    search_string___2[0] = (char)0;
#line 1674
    search_prompt___2[0] = (char )'?';
#line 1675
    search_prompt___2[1] = (char )' ';
#line 1676
    search_prompt___2[2] = (char)0;
  } else
#line 1677
  if (c > 0) {
#line 1678
    search_string___2[search_pos___2] = (char )c;
#line 1679
    search_string___2[search_pos___2 + 1] = (char)0;
#line 1680
    search_prompt___2[search_pos___2] = (char )c;
#line 1681
    search_prompt___2[search_pos___2 + 1] = (char )'?';
#line 1682
    search_prompt___2[search_pos___2 + 2] = (char )' ';
#line 1683
    search_prompt___2[search_pos___2 + 3] = (char)0;
#line 1684
    search_pos___2 ++;
  } else
#line 1686
  if (search_pos___2 > 0) {
#line 1687
    search_pos___2 --;
#line 1688
    search_string___2[search_pos___2] = (char)0;
#line 1689
    search_prompt___2[search_pos___2] = (char )'?';
#line 1690
    search_prompt___2[search_pos___2 + 1] = (char )' ';
#line 1691
    search_prompt___2[search_pos___2 + 2] = (char)0;
  } else {
    {
#line 1693
    gl_beep___2();
#line 1694
    hist_pos___2 = hist_last___2;
    }
  }
#line 1697
  return;
}
}
#line 1699 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_addchar___2(int c ) 
{ 
  char *loc ;

  {
  {
#line 1704
  search_update___2(c);
  }
#line 1705
  if (c < 0) {
#line 1706
    if (search_pos___2 > 0) {
#line 1707
      hist_pos___2 = search_last___2;
    } else {
#line 1709
      gl_buf[0] = (char)0;
#line 1710
      hist_pos___2 = hist_last___2;
    }
    {
#line 1712
    strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)hist_buf___2[hist_pos___2]);
    }
  }
  {
#line 1714
  loc = strstr((char const   *)(gl_buf), (char const   *)(search_string___2));
  }
#line 1714
  if ((unsigned long )loc != (unsigned long )((char *)0)) {
    {
#line 1715
    gl_fixup___2((char const   *)(search_prompt___2), 0, (int )(loc - gl_buf));
    }
  } else
#line 1716
  if (search_pos___2 > 0) {
#line 1717
    if (search_forw_flg___2) {
      {
#line 1718
      search_forw___2(0);
      }
    } else {
      {
#line 1720
      search_back___2(0);
      }
    }
  } else {
    {
#line 1723
    gl_fixup___2((char const   *)(search_prompt___2), 0, 0);
    }
  }
#line 1725
  return;
}
}
#line 1727 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_term___2(void) 
{ 


  {
#line 1730
  gl_search_mode___2 = 0;
#line 1731
  if ((int )gl_buf[0] == 0) {
#line 1732
    hist_pos___2 = hist_last___2;
  }
#line 1733
  if (gl_in_hook) {
    {
#line 1734
    (*gl_in_hook)(gl_buf);
    }
  }
  {
#line 1735
  gl_fixup___2(gl_prompt___2, 0, gl_pos___2);
  }
#line 1736
  return;
}
}
#line 1738 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_back___2(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1741
  found = 0;
#line 1744
  search_forw_flg___2 = 0;
#line 1745
  if (gl_search_mode___2 == 0) {
    {
#line 1746
    hist_pos___2 = hist_last___2;
#line 1746
    search_last___2 = hist_pos___2;
#line 1747
    search_update___2(0);
#line 1748
    gl_search_mode___2 = 1;
#line 1749
    gl_buf[0] = (char)0;
#line 1750
    gl_fixup___2((char const   *)(search_prompt___2), 0, 0);
    }
  } else
#line 1751
  if (search_pos___2 > 0) {
    {
#line 1752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1752
      if (! (! found)) {
#line 1752
        goto while_break;
      }
      {
#line 1753
      p___5 = hist_prev___2();
      }
#line 1754
      if ((int )*p___5 == 0) {
        {
#line 1755
        gl_buf[0] = (char)0;
#line 1756
        gl_fixup___2((char const   *)(search_prompt___2), 0, 0);
#line 1757
        found = 1;
        }
      } else {
        {
#line 1758
        loc = strstr((char const   *)p___5, (char const   *)(search_string___2));
        }
#line 1758
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1759
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1760
          gl_fixup___2((char const   *)(search_prompt___2), 0, (int )(loc - p___5));
          }
#line 1761
          if (new_search) {
#line 1762
            search_last___2 = hist_pos___2;
          }
#line 1763
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1768
    gl_beep___2();
    }
  }
#line 1770
  return;
}
}
#line 1772 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void search_forw___2(int new_search ) 
{ 
  int found ;
  char *p___5 ;
  char *loc ;

  {
#line 1775
  found = 0;
#line 1778
  search_forw_flg___2 = 1;
#line 1779
  if (gl_search_mode___2 == 0) {
    {
#line 1780
    hist_pos___2 = hist_last___2;
#line 1780
    search_last___2 = hist_pos___2;
#line 1781
    search_update___2(0);
#line 1782
    gl_search_mode___2 = 1;
#line 1783
    gl_buf[0] = (char)0;
#line 1784
    gl_fixup___2((char const   *)(search_prompt___2), 0, 0);
    }
  } else
#line 1785
  if (search_pos___2 > 0) {
    {
#line 1786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1786
      if (! (! found)) {
#line 1786
        goto while_break;
      }
      {
#line 1787
      p___5 = hist_next___2();
      }
#line 1788
      if ((int )*p___5 == 0) {
        {
#line 1789
        gl_buf[0] = (char)0;
#line 1790
        gl_fixup___2((char const   *)(search_prompt___2), 0, 0);
#line 1791
        found = 1;
        }
      } else {
        {
#line 1792
        loc = strstr((char const   *)p___5, (char const   *)(search_string___2));
        }
#line 1792
        if ((unsigned long )loc != (unsigned long )((char *)0)) {
          {
#line 1793
          strcpy((char */* __restrict  */)(gl_buf), (char const   */* __restrict  */)p___5);
#line 1794
          gl_fixup___2((char const   *)(search_prompt___2), 0, (int )(loc - p___5));
          }
#line 1795
          if (new_search) {
#line 1796
            search_last___2 = hist_pos___2;
          }
#line 1797
          found = 1;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1801
    gl_beep___2();
    }
  }
#line 1803
  return;
}
}
#line 1806 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_beep___2(void) 
{ 


  {
  {
#line 1812
  gl_putc___2('\a');
  }
#line 1814
  return;
}
}
#line 1818 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_display_matches_sort_proc___2(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 1821
  tmp = strcasecmp((char const   *)*((char const   * const  *)a), (char const   *)*((char const   * const  *)b));
  }
#line 1821
  return (tmp);
}
}
#line 1829 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static void gl_display_matches___2(int nused ) 
{ 
  char buf[256] ;
  char buf2[256] ;
  size_t ilen ;
  size_t imaxlen ;
  int i___0 ;
  int j ;
  int k ;
  int l ;
  int glen ;
  int allmatch ;
  int nmax ;
  int ncol ;
  int colw ;
  int nrow ;
  char *cp1 ;
  char *cp2 ;
  char *lim ;
  char *itemp ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1840
  gl_putc___2('\n');
  }
#line 1841
  if (nused == 0) {
    {
#line 1842
    gl_beep___2();
#line 1843
    gl_puts___2("    (no matches)");
#line 1844
    gl_putc___2('\n');
    }
  } else {
    {
#line 1846
    qsort((void *)gl_matchlist___2, (size_t )nused, sizeof(char *), & gl_display_matches_sort_proc___2);
#line 1849
    glen = 0;
    }
    {
#line 1849
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1850
      allmatch = 1;
#line 1851
      if ((int )*(*(gl_matchlist___2 + 0) + glen) == 0) {
        {
#line 1852
        gl_beep___2();
#line 1853
        gl_putc___2('\n');
        }
#line 1854
        return;
      }
#line 1856
      i___0 = 1;
      {
#line 1856
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1856
        if (! (i___0 < nused)) {
#line 1856
          goto while_break___0;
        }
#line 1857
        if ((int )*(*(gl_matchlist___2 + 0) + glen) != (int )*(*(gl_matchlist___2 + i___0) + glen)) {
#line 1858
          allmatch = 0;
#line 1859
          goto while_break___0;
        }
#line 1856
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1862
      if (allmatch == 0) {
#line 1863
        goto while_break;
      }
#line 1849
      glen ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1866
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1866
      if (! (glen > 0)) {
#line 1866
        goto while_break___1;
      }
      {
#line 1867
      tmp = __ctype_b_loc();
      }
#line 1867
      if (! ((int const   )*(*tmp + (int )*(*(gl_matchlist___2 + 0) + (glen - 1))) & 8)) {
#line 1868
        goto while_break___1;
      }
#line 1869
      glen --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1872
    nmax = nused;
#line 1873
    imaxlen = strlen((char const   *)*(gl_matchlist___2 + 0));
#line 1874
    i___0 = 1;
    }
    {
#line 1874
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1874
      if (! (i___0 < nused)) {
#line 1874
        goto while_break___2;
      }
      {
#line 1875
      ilen = strlen((char const   *)*(gl_matchlist___2 + i___0));
      }
#line 1876
      if (ilen > imaxlen) {
#line 1877
        imaxlen = ilen;
      }
#line 1874
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1881
    if (imaxlen == (size_t )((unsigned int )glen)) {
      {
#line 1882
      gl_beep___2();
#line 1883
      gl_putc___2('\n');
      }
#line 1884
      return;
    }
#line 1886
    imaxlen -= (size_t )glen;
#line 1888
    ncol = (gl_termw___2 - 8) / ((int )imaxlen + 2);
#line 1889
    if (ncol < 1) {
#line 1890
      ncol = 1;
    }
#line 1892
    colw = (gl_termw___2 - 8) / ncol;
#line 1893
    nrow = nmax / ncol;
#line 1894
    if (nused % ncol != 0) {
#line 1895
      nrow ++;
    }
#line 1897
    if (nrow > gl_termh___2 - 4) {
#line 1898
      nrow = gl_termh___2 - 4;
#line 1899
      nmax = ncol * nrow;
    }
#line 1902
    i___0 = 0;
    {
#line 1902
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1902
      if (! (i___0 < (int )sizeof(buf2))) {
#line 1902
        goto while_break___3;
      }
#line 1903
      buf2[i___0] = (char )' ';
#line 1902
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1905
    j = 0;
    {
#line 1905
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1905
      if (! (j < nrow)) {
#line 1905
        goto while_break___4;
      }
      {
#line 1906
      memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(buf2),
             sizeof(buf));
#line 1907
      i___0 = 0;
#line 1907
      k = j;
#line 1907
      l = 4;
      }
      {
#line 1907
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1907
        if (! (i___0 < ncol)) {
#line 1907
          goto while_break___5;
        }
#line 1908
        if (k >= nmax) {
#line 1909
          goto __Cont;
        }
        {
#line 1910
        itemp = *(gl_matchlist___2 + k) + glen;
#line 1911
        cp1 = buf + l;
#line 1912
        tmp___0 = strlen((char const   *)itemp);
#line 1912
        lim = cp1 + (int )tmp___0;
        }
#line 1913
        if ((unsigned long )lim >= (unsigned long )(buf + sizeof(buf))) {
#line 1914
          goto __Cont;
        }
#line 1915
        cp2 = itemp;
        {
#line 1916
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1916
          if (! ((unsigned long )cp1 < (unsigned long )lim)) {
#line 1916
            goto while_break___6;
          }
#line 1917
          tmp___1 = cp1;
#line 1917
          cp1 ++;
#line 1917
          tmp___2 = cp2;
#line 1917
          cp2 ++;
#line 1917
          *tmp___1 = *tmp___2;
        }
        while_break___6: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 1907
        i___0 ++;
#line 1907
        k += nrow;
#line 1907
        l += colw;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1919
      cp1 = buf;
#line 1920
      cp1 += sizeof(buf);
#line 1921
      cp1 --;
      {
#line 1922
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1922
        if (! ((int )*cp1 == 32)) {
#line 1922
          goto while_break___7;
        }
#line 1923
        cp1 --;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1924
      cp1 ++;
#line 1925
      *cp1 = (char )'\000';
#line 1926
      gl_puts___2((char const   *)(buf));
#line 1927
      gl_putc___2('\n');
#line 1905
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1930
    if (nused > nmax) {
      {
#line 1931
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"    ... %d others omitted ...",
              nused - nmax);
#line 1932
      gl_puts___2((char const   *)(buf));
#line 1933
      gl_putc___2('\n');
      }
    }
  }
  {
#line 1936
  gl_fixup___2(gl_prompt___2, -2, 2048);
  }
#line 1937
  return;
}
}
#line 1942 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int gl_do_tab_completion___2(char *buf , int *loc , size_t bufsize , int tabtab ) 
{ 
  char *startp ;
  size_t startoff ;
  size_t amt ;
  int c ;
  int qmode ;
  char *qstart ;
  char *lastspacestart ;
  char *cp ;
  int ntoalloc ;
  int nused ;
  int nprocused ;
  int nalloced ;
  int i___0 ;
  char **newgl_matchlist ;
  char *strtoadd ;
  char *strtoadd1 ;
  int addquotes ;
  size_t llen ;
  size_t mlen ;
  size_t glen ;
  int allmatch ;
  char *curposp ;
  size_t lenaftercursor ;
  char *matchpfx ;
  int wasateol ;
  char ellipsessave[4] ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;

  {
  {
#line 1967
  llen = strlen((char const   *)buf);
#line 1968
  memset((void *)(buf + llen), 0, bufsize - llen);
#line 1969
  bufsize -= 4UL;
#line 1970
  curposp = buf + *loc;
#line 1971
  wasateol = (int )*curposp == 0;
#line 1972
  lenaftercursor = llen - (size_t )(curposp - buf);
  }
#line 1973
  if (gl_ellipses_during_completion != 0) {
    {
#line 1974
    memcpy((void */* __restrict  */)(ellipsessave), (void const   */* __restrict  */)curposp,
           (size_t )4);
#line 1975
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)"... ",
           (size_t )4);
#line 1976
    gl_fixup___2(gl_prompt___2, gl_pos___2, gl_pos___2 + 3);
#line 1977
    memcpy((void */* __restrict  */)curposp, (void const   */* __restrict  */)(ellipsessave),
           (size_t )4);
    }
  }
#line 1980
  qmode = 0;
#line 1981
  qstart = (char *)((void *)0);
#line 1982
  lastspacestart = (char *)((void *)0);
#line 1983
  matchpfx = (char *)((void *)0);
#line 1985
  cp = buf;
  {
#line 1986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1986
    if (! ((unsigned long )cp < (unsigned long )curposp)) {
#line 1986
      goto while_break;
    }
#line 1987
    tmp = cp;
#line 1987
    cp ++;
#line 1987
    c = (int )*tmp;
#line 1988
    if (c == 0) {
#line 1989
      goto while_break;
    }
#line 1990
    if (c == 34) {
#line 1990
      goto _L;
    } else
#line 1990
    if (c == 39) {
      _L: /* CIL Label */ 
#line 1991
      if (qmode == c) {
#line 1993
        qstart = (char *)((void *)0);
#line 1994
        qmode = 0;
      } else
#line 1995
      if (! (qmode != 0)) {
#line 1999
        qmode = c;
#line 2000
        qstart = cp - 1;
      }
    } else {
      {
#line 2002
      tmp___0 = __ctype_b_loc();
      }
#line 2002
      if ((int const   )*(*tmp___0 + c) & 8192) {
#line 2002
        if (qmode == 0) {
#line 2004
          lastspacestart = cp - 1;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  if ((unsigned long )qstart != (unsigned long )((void *)0)) {
#line 2011
    startp = qstart + 1;
  } else
#line 2012
  if ((unsigned long )lastspacestart != (unsigned long )((void *)0)) {
#line 2013
    startp = lastspacestart + 1;
  } else {
#line 2015
    startp = buf;
  }
  {
#line 2017
  cp = startp;
#line 2018
  mlen = (size_t )(curposp - cp);
#line 2020
  tmp___1 = malloc(mlen + 1UL);
#line 2020
  matchpfx = (char *)tmp___1;
#line 2021
  memcpy((void */* __restrict  */)matchpfx, (void const   */* __restrict  */)cp, mlen);
#line 2022
  *(matchpfx + mlen) = (char )'\000';
#line 2026
  nused = 0;
#line 2027
  ntoalloc = 64;
#line 2028
  tmp___2 = malloc(sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2028
  newgl_matchlist = (char **)tmp___2;
  }
#line 2029
  if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
    {
#line 2030
    free((void *)matchpfx);
#line 2031
    gl_beep___2();
    }
#line 2032
    return (0);
  }
#line 2034
  gl_matchlist___2 = newgl_matchlist;
#line 2035
  nalloced = ntoalloc;
#line 2036
  i___0 = nused;
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if (! (i___0 <= nalloced)) {
#line 2036
      goto while_break___0;
    }
#line 2037
    *(gl_matchlist___2 + i___0) = (char *)((void *)0);
#line 2036
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2039
  gl_completion_exact_match_extra_char = ' ';
#line 2040
  nprocused = 0;
  {
#line 2040
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2041
    if (nused == nalloced) {
      {
#line 2042
      ntoalloc += 64;
#line 2043
      tmp___3 = realloc((void *)((char *)gl_matchlist___2), sizeof(char *) * (unsigned long )(ntoalloc + 1));
#line 2043
      newgl_matchlist = (char **)tmp___3;
      }
#line 2044
      if ((unsigned long )newgl_matchlist == (unsigned long )((void *)0)) {
#line 2046
        i___0 = 0;
        {
#line 2046
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2046
          if (! (i___0 < nused)) {
#line 2046
            goto while_break___2;
          }
          {
#line 2047
          free((void *)*(gl_matchlist___2 + i___0));
#line 2046
          i___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2048
        free((void *)gl_matchlist___2);
#line 2049
        gl_matchlist___2 = (char **)((void *)0);
#line 2050
        gl_beep___2();
#line 2051
        free((void *)matchpfx);
        }
#line 2052
        return (0);
      }
#line 2054
      gl_matchlist___2 = newgl_matchlist;
#line 2055
      nalloced = ntoalloc;
#line 2056
      i___0 = nused;
      {
#line 2056
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2056
        if (! (i___0 <= nalloced)) {
#line 2056
          goto while_break___3;
        }
#line 2057
        *(gl_matchlist___2 + i___0) = (char *)((void *)0);
#line 2056
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2059
    cp = (*gl_completion_proc)((char const   *)matchpfx, nprocused);
    }
#line 2060
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2061
      goto while_break___1;
    }
#line 2062
    if ((int )*(cp + 0) == 46) {
#line 2062
      if ((int )*(cp + 1) == 0) {
#line 2063
        goto __Cont;
      } else
#line 2062
      if ((int )*(cp + 1) == 46) {
#line 2062
        if ((int )*(cp + 2) == 0) {
#line 2063
          goto __Cont;
        }
      }
    }
#line 2064
    tmp___4 = nused;
#line 2064
    nused ++;
#line 2064
    *(gl_matchlist___2 + tmp___4) = cp;
    __Cont: /* CIL Label */ 
#line 2040
    nprocused ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2067
  if (gl_ellipses_during_completion != 0) {
    {
#line 2068
    gl_fixup___2(gl_prompt___2, gl_pos___2, gl_pos___2);
#line 2069
    gl_puts___2("    ");
    }
  }
#line 2073
  strtoadd = (char *)((void *)0);
#line 2074
  strtoadd1 = (char *)((void *)0);
#line 2075
  amt = (size_t )0;
#line 2077
  if (gl_filename_quoting_desired > 0) {
#line 2077
    tmp___5 = 1;
  } else
#line 2077
  if (gl_filename_quoting_desired < 0) {
#line 2077
    if ((unsigned long )gl_completion_proc == (unsigned long )(& gl_local_filename_completion_proc)) {
#line 2077
      tmp___5 = 1;
    } else {
#line 2077
      tmp___5 = 0;
    }
  } else {
#line 2077
    tmp___5 = 0;
  }
#line 2077
  addquotes = tmp___5;
#line 2079
  if (nused == 1) {
#line 2081
    strtoadd = *(gl_matchlist___2 + 0);
  } else
#line 2082
  if (tabtab != 0) {
    {
#line 2084
    gl_display_matches___2(nused);
    }
  } else
#line 2085
  if (nused > 1) {
#line 2085
    if (mlen != 0UL) {
      {
#line 2087
      glen = strlen((char const   *)matchpfx);
      }
      {
#line 2087
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2088
        allmatch = 1;
#line 2089
        i___0 = 1;
        {
#line 2089
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2089
          if (! (i___0 < nused)) {
#line 2089
            goto while_break___5;
          }
#line 2090
          if ((int )*(*(gl_matchlist___2 + 0) + glen) != (int )*(*(gl_matchlist___2 + i___0) + glen)) {
#line 2091
            allmatch = 0;
#line 2092
            goto while_break___5;
          }
#line 2089
          i___0 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2095
        if (allmatch == 0) {
#line 2096
          goto while_break___4;
        }
#line 2087
        glen ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2098
      tmp___6 = malloc(glen + 1UL);
#line 2098
      strtoadd1 = (char *)tmp___6;
      }
#line 2099
      if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
        {
#line 2100
        memcpy((void */* __restrict  */)strtoadd1, (void const   */* __restrict  */)*(gl_matchlist___2 + 0),
               glen);
#line 2101
        *(strtoadd1 + glen) = (char )'\000';
#line 2102
        strtoadd = strtoadd1;
        }
      }
    }
  }
#line 2106
  if ((unsigned long )strtoadd != (unsigned long )((void *)0)) {
#line 2107
    if (qmode == 0) {
#line 2107
      if (addquotes != 0) {
        {
#line 2108
        tmp___10 = strpbrk((char const   *)strtoadd, gl_filename_quote_characters);
        }
#line 2108
        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
          {
#line 2109
          tmp___8 = strchr((char const   *)strtoadd, '\"');
          }
#line 2109
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 2109
            qmode = '\"';
          } else {
#line 2109
            qmode = '\'';
          }
          {
#line 2110
          memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2111
          curposp ++;
#line 2112
          tmp___9 = startp;
#line 2112
          startp ++;
#line 2112
          *tmp___9 = (char )qmode;
          }
        }
      }
    }
    {
#line 2115
    startoff = (size_t )(startp - buf);
#line 2116
    amt = strlen((char const   *)strtoadd);
    }
#line 2117
    if ((amt + startoff) + lenaftercursor >= bufsize) {
#line 2118
      amt = bufsize - ((amt + startoff) + lenaftercursor);
    }
    {
#line 2119
    memmove((void *)((curposp + amt) - mlen), (void const   *)curposp, lenaftercursor + 1UL);
#line 2120
    curposp += amt - mlen;
#line 2121
    memcpy((void */* __restrict  */)startp, (void const   */* __restrict  */)strtoadd,
           amt);
    }
#line 2122
    if (nused == 1) {
#line 2124
      if (qmode != 0) {
        {
#line 2126
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2127
        curposp ++;
#line 2128
        *(buf + (amt + startoff)) = (char )qmode;
#line 2129
        amt ++;
        }
      }
      {
#line 2131
      memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2132
      curposp ++;
#line 2133
      *(buf + (amt + startoff)) = (char )gl_completion_exact_match_extra_char;
#line 2134
      amt ++;
      }
    } else
#line 2135
    if (! wasateol) {
      {
#line 2135
      tmp___11 = __ctype_b_loc();
      }
#line 2135
      if (! ((int const   )*(*tmp___11 + (int )*curposp) & 8192)) {
        {
#line 2139
        memmove((void *)(curposp + 1), (void const   *)curposp, lenaftercursor + 1UL);
#line 2140
        curposp ++;
#line 2141
        *(buf + (amt + startoff)) = (char )' ';
        }
      }
    }
#line 2143
    *loc = (int )(startoff + amt);
#line 2145
    if ((unsigned long )strtoadd1 != (unsigned long )((void *)0)) {
      {
#line 2146
      free((void *)strtoadd1);
      }
    }
  }
#line 2150
  i___0 = 0;
  {
#line 2150
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2150
    if (! (i___0 < nused)) {
#line 2150
      goto while_break___6;
    }
    {
#line 2151
    free((void *)*(gl_matchlist___2 + i___0));
#line 2150
    i___0 ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2152
  free((void *)gl_matchlist___2);
#line 2153
  gl_matchlist___2 = (char **)((void *)0);
#line 2154
  free((void *)matchpfx);
  }
#line 2156
  return (0);
}
}
#line 2354 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static DIR *dir___2  =    (DIR *)((void *)0);
#line 2355 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static int filepfxoffset___2  ;
#line 2356 "/home/wheatley/newnew/temp/ncftp-3.2.5/sh_util/../ncftp/gl_getline.c"
static size_t filepfxlen___2  ;
#line 377 "/home/wheatley/newnew/temp/ncftp-3.2.5/libncftp/open.c"
static void FTPExamineMlstFeatures___1(FTPCIPtr const   cip , char const   *features ) 
{ 
  char buf[256] ;
  char *feat ;
  int flags___0 ;
  char *ctext ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 384
  flags___0 = 0;
#line 385
  Strncpy((char */* const  */)(buf), (char const   */* const  */)features, (size_t const   )sizeof(buf));
#line 386
  ctext = (char *)((void *)0);
#line 387
  feat = strtokc(buf, ";*", & ctext);
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )feat != (unsigned long )((void *)0))) {
#line 388
      goto while_break;
    }
    {
#line 389
    tmp = strncasecmp((char const   *)feat, "OS.", (size_t )3);
    }
#line 389
    if (tmp == 0) {
#line 390
      feat += 3;
    }
    {
#line 391
    tmp___9 = strcasecmp((char const   *)feat, "type");
    }
#line 391
    if (tmp___9 == 0) {
#line 392
      flags___0 |= 1;
    } else {
      {
#line 393
      tmp___8 = strcasecmp((char const   *)feat, "size");
      }
#line 393
      if (tmp___8 == 0) {
#line 394
        flags___0 |= 2;
      } else {
        {
#line 395
        tmp___7 = strcasecmp((char const   *)feat, "modify");
        }
#line 395
        if (tmp___7 == 0) {
#line 396
          flags___0 |= 4;
        } else {
          {
#line 397
          tmp___6 = strcasecmp((char const   *)feat, "UNIX.mode");
          }
#line 397
          if (tmp___6 == 0) {
#line 398
            flags___0 |= 8;
          } else {
            {
#line 399
            tmp___5 = strcasecmp((char const   *)feat, "UNIX.owner");
            }
#line 399
            if (tmp___5 == 0) {
#line 400
              flags___0 |= 16;
            } else {
              {
#line 401
              tmp___4 = strcasecmp((char const   *)feat, "UNIX.group");
              }
#line 401
              if (tmp___4 == 0) {
#line 402
                flags___0 |= 32;
              } else {
                {
#line 403
                tmp___3 = strcasecmp((char const   *)feat, "perm");
                }
#line 403
                if (tmp___3 == 0) {
#line 404
                  flags___0 |= 64;
                } else {
                  {
#line 405
                  tmp___2 = strcasecmp((char const   *)feat, "UNIX.uid");
                  }
#line 405
                  if (tmp___2 == 0) {
#line 406
                    flags___0 |= 128;
                  } else {
                    {
#line 407
                    tmp___1 = strcasecmp((char const   *)feat, "UNIX.gid");
                    }
#line 407
                    if (tmp___1 == 0) {
#line 408
                      flags___0 |= 256;
                    } else {
                      {
#line 409
                      tmp___0 = strcasecmp((char const   *)feat, "UNIX.gid");
                      }
#line 409
                      if (tmp___0 == 0) {
#line 410
                        flags___0 |= 512;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 412
    feat = strtokc((char *)((void *)0), ";*", & ctext);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  cip->mlsFeatures = flags___0;
#line 416
  return;
}
}
