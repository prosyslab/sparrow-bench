/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 141 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
struct item {
   struct item *next ;
   unsigned int len ;
   unsigned int hash ;
   char name[0] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 20 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct file {
   struct file *next ;
   struct file *parent ;
   char const   *name ;
   int lineno ;
};
#line 27
enum tristate {
    no = 0,
    mod = 1,
    yes = 2
} ;
#line 27 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
typedef enum tristate tristate;
#line 31
enum expr_type {
    E_NONE = 0,
    E_OR = 1,
    E_AND = 2,
    E_NOT = 3,
    E_EQUAL = 4,
    E_UNEQUAL = 5,
    E_LTH = 6,
    E_LEQ = 7,
    E_GTH = 8,
    E_GEQ = 9,
    E_LIST = 10,
    E_SYMBOL = 11,
    E_RANGE = 12
} ;
#line 37
struct expr;
#line 37
struct symbol;
#line 37 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
union expr_data {
   struct expr *expr ;
   struct symbol *sym ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct expr {
   enum expr_type type ;
   union expr_data left ;
   union expr_data right ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct expr_value {
   struct expr *expr ;
   tristate tri ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct symbol_value {
   void *val ;
   tristate tri ;
};
#line 64
enum symbol_type {
    S_UNKNOWN = 0,
    S_BOOLEAN = 1,
    S_TRISTATE = 2,
    S_INT = 3,
    S_HEX = 4,
    S_STRING = 5,
    S_OTHER = 6
} ;
#line 77
struct property;
#line 77 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct symbol {
   struct symbol *next ;
   char *name ;
   enum symbol_type type ;
   struct symbol_value curr ;
   struct symbol_value def[4] ;
   tristate visible ;
   int flags ;
   struct property *prop ;
   struct expr_value dir_dep ;
   struct expr_value rev_dep ;
};
#line 131
enum prop_type {
    P_UNKNOWN = 0,
    P_PROMPT = 1,
    P_COMMENT = 2,
    P_MENU = 3,
    P_DEFAULT = 4,
    P_CHOICE = 5,
    P_SELECT = 6,
    P_RANGE = 7,
    P_ENV = 8,
    P_SYMBOL = 9
} ;
#line 144
struct menu;
#line 144 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct property {
   struct property *next ;
   struct symbol *sym ;
   enum prop_type type ;
   char const   *text ;
   struct expr_value visible ;
   struct expr *expr ;
   struct menu *menu ;
   struct file *file ;
   int lineno ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct menu {
   struct menu *next ;
   struct menu *parent ;
   struct menu *list ;
   struct symbol *sym ;
   struct property *prompt ;
   struct expr *visibility ;
   struct expr *dep ;
   unsigned int flags ;
   char *help ;
   struct file *file ;
   int lineno ;
   void *data ;
};
#line 221
struct gstr;
#line 51 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
enum conf_def_mode {
    def_default = 0,
    def_yes = 1,
    def_mod = 2,
    def_no = 3,
    def_random = 4
} ;
#line 121 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
struct gstr {
   size_t len ;
   char *s ;
   int max_width ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
enum input_mode {
    oldaskconfig = 0,
    silentoldconfig = 1,
    oldconfig = 2,
    allnoconfig = 3,
    allyesconfig = 4,
    allmodconfig = 5,
    alldefconfig = 6,
    randconfig = 7,
    defconfig = 8,
    savedefconfig = 9,
    listnewconfig = 10,
    olddefconfig = 11
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 23 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 185 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct jump_key {
   struct list_head entries ;
   size_t offset ;
   struct menu *target ;
   int index ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
struct kconf_id {
   int name ;
   int token ;
   unsigned int flags ;
   enum symbol_type stype ;
};
#line 187 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
union YYSTYPE {
   char *string ;
   struct file *file ;
   struct symbol *symbol ;
   struct expr *expr ;
   struct menu *menu ;
   struct kconf_id  const  *id ;
};
#line 187 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
typedef union YYSTYPE YYSTYPE;
#line 69 "scripts/kconfig/zconf.gperf"
struct kconf_id_strings_t {
   char kconf_id_strings_str2[sizeof("if")] ;
   char kconf_id_strings_str3[sizeof("int")] ;
   char kconf_id_strings_str5[sizeof("endif")] ;
   char kconf_id_strings_str7[sizeof("default")] ;
   char kconf_id_strings_str8[sizeof("tristate")] ;
   char kconf_id_strings_str9[sizeof("endchoice")] ;
   char kconf_id_strings_str12[sizeof("def_tristate")] ;
   char kconf_id_strings_str13[sizeof("def_bool")] ;
   char kconf_id_strings_str14[sizeof("defconfig_list")] ;
   char kconf_id_strings_str17[sizeof("on")] ;
   char kconf_id_strings_str18[sizeof("optional")] ;
   char kconf_id_strings_str21[sizeof("option")] ;
   char kconf_id_strings_str22[sizeof("endmenu")] ;
   char kconf_id_strings_str23[sizeof("mainmenu")] ;
   char kconf_id_strings_str25[sizeof("menuconfig")] ;
   char kconf_id_strings_str27[sizeof("modules")] ;
   char kconf_id_strings_str28[sizeof("allnoconfig_y")] ;
   char kconf_id_strings_str29[sizeof("menu")] ;
   char kconf_id_strings_str31[sizeof("select")] ;
   char kconf_id_strings_str32[sizeof("comment")] ;
   char kconf_id_strings_str33[sizeof("env")] ;
   char kconf_id_strings_str35[sizeof("range")] ;
   char kconf_id_strings_str36[sizeof("choice")] ;
   char kconf_id_strings_str39[sizeof("bool")] ;
   char kconf_id_strings_str41[sizeof("source")] ;
   char kconf_id_strings_str42[sizeof("visible")] ;
   char kconf_id_strings_str43[sizeof("hex")] ;
   char kconf_id_strings_str46[sizeof("config")] ;
   char kconf_id_strings_str47[sizeof("boolean")] ;
   char kconf_id_strings_str51[sizeof("string")] ;
   char kconf_id_strings_str54[sizeof("help")] ;
   char kconf_id_strings_str56[sizeof("prompt")] ;
   char kconf_id_strings_str72[sizeof("depends")] ;
};
#line 222 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
typedef unsigned char yytype_uint8;
#line 229 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
typedef signed char yytype_int8;
#line 237 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
typedef unsigned short yytype_uint16;
#line 243 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
typedef short yytype_int16;
#line 375 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 70 "scripts/kconfig/zconf.lex.c_shipped"
typedef short flex_int16_t;
#line 71 "scripts/kconfig/zconf.lex.c_shipped"
typedef int flex_int32_t;
#line 171
struct yy_buffer_state;
#line 171 "scripts/kconfig/zconf.lex.c_shipped"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 202 "scripts/kconfig/zconf.lex.c_shipped"
typedef size_t yy_size_t;
#line 207 "scripts/kconfig/zconf.lex.c_shipped"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 360 "scripts/kconfig/zconf.lex.c_shipped"
typedef int yy_state_type;
#line 815 "scripts/kconfig/zconf.lex.c_shipped"
struct __anonstruct_current_pos_31 {
   struct file *file ;
   int lineno ;
};
#line 823 "scripts/kconfig/zconf.lex.c_shipped"
struct buffer {
   struct buffer *parent ;
   YY_BUFFER_STATE state ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
struct conf_printer {
   void (*print_symbol)(FILE * , struct symbol * , char const   * , void * ) ;
   void (*print_comment)(FILE * , char const   * , void * ) ;
};
#line 873 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
enum string_value_kind {
    k_string = 0,
    k_signed = 1,
    k_unsigned = 2,
    k_invalid = 3
} ;
#line 880 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
union string_value {
   unsigned long long u ;
   long long s ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_33 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_33 regmatch_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 958 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct sym_match {
   struct symbol *sym ;
   off_t so ;
   off_t eo ;
};
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct dep_stack {
   struct dep_stack *prev ;
   struct dep_stack *next ;
   struct symbol *sym ;
   struct property *prop ;
   struct expr *expr ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 31 "/usr/include/elf.h"
typedef uint16_t Elf32_Half;
#line 35 "/usr/include/elf.h"
typedef uint32_t Elf32_Word;
#line 47 "/usr/include/elf.h"
typedef uint32_t Elf32_Addr;
#line 51 "/usr/include/elf.h"
typedef uint32_t Elf32_Off;
#line 55 "/usr/include/elf.h"
typedef uint16_t Elf32_Section;
#line 67 "/usr/include/elf.h"
struct __anonstruct_Elf32_Ehdr_29 {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 67 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Ehdr_29 Elf32_Ehdr;
#line 272 "/usr/include/elf.h"
struct __anonstruct_Elf32_Shdr_31 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 272 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Shdr_31 Elf32_Shdr;
#line 381 "/usr/include/elf.h"
struct __anonstruct_Elf32_Sym_33 {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Section st_shndx ;
};
#line 381 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Sym_33 Elf32_Sym;
#line 496 "/usr/include/elf.h"
struct __anonstruct_Elf32_Rel_37 {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
#line 496 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Rel_37 Elf32_Rel;
#line 541 "/usr/include/elf.h"
struct __anonstruct_Elf32_Phdr_41 {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 541 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Phdr_41 Elf32_Phdr;
#line 23 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.h"
enum symtype {
    S_ABS = 0,
    S_REL = 1,
    S_SEG = 2,
    S_LIN = 3,
    S_NSYMTYPES = 4
} ;
#line 15 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
struct relocs {
   uint32_t *offset ;
   unsigned long count ;
   unsigned long size ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
struct section {
   Elf32_Shdr shdr ;
   struct section *link ;
   Elf32_Sym *symtab ;
   Elf32_Rel *reltab ;
   char *strtab ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 32 "/usr/include/elf.h"
typedef uint16_t Elf64_Half;
#line 43 "/usr/include/elf.h"
typedef uint64_t Elf64_Xword;
#line 44 "/usr/include/elf.h"
typedef int64_t Elf64_Sxword;
#line 48 "/usr/include/elf.h"
typedef uint64_t Elf64_Addr;
#line 52 "/usr/include/elf.h"
typedef uint64_t Elf64_Off;
#line 56 "/usr/include/elf.h"
typedef uint16_t Elf64_Section;
#line 85 "/usr/include/elf.h"
struct __anonstruct_Elf64_Ehdr_30 {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf32_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 85 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Ehdr_30 Elf64_Ehdr;
#line 286 "/usr/include/elf.h"
struct __anonstruct_Elf64_Shdr_32 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 286 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Shdr_32 Elf64_Shdr;
#line 391 "/usr/include/elf.h"
struct __anonstruct_Elf64_Sym_34 {
   Elf32_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Section st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 391 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Sym_34 Elf64_Sym;
#line 522 "/usr/include/elf.h"
struct __anonstruct_Elf64_Rela_40 {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
#line 522 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Rela_40 Elf64_Rela;
#line 553 "/usr/include/elf.h"
struct __anonstruct_Elf64_Phdr_42 {
   Elf32_Word p_type ;
   Elf32_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
#line 553 "/usr/include/elf.h"
typedef struct __anonstruct_Elf64_Phdr_42 Elf64_Phdr;
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
struct section___0 {
   Elf64_Shdr shdr ;
   struct section___0 *link ;
   Elf64_Sym *symtab ;
   Elf64_Rela *reltab ;
   char *strtab ;
};
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
char *target  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
char *depfile  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
char *cmdline  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void usage(void) 
{ 


  {
  {
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: fixdep <depfile> <target> <cmdline>\n");
#line 130
  exit(1);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void print_cmdline(void) 
{ 


  {
  {
#line 138
  printf((char const   */* __restrict  */)"cmd_%s := %s\n\n", target, cmdline);
  }
#line 139
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static struct item *hashtab[256]  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static unsigned int strhash(char const   *str , unsigned int sz ) 
{ 
  unsigned int i ;
  unsigned int hash ;

  {
#line 154
  hash = 2166136261U;
#line 156
  i = 0U;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < sz)) {
#line 156
      goto while_break;
    }
#line 157
    hash = (hash ^ (unsigned int )*(str + i)) * 16777619U;
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (hash);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static int is_defined_config(char const   *name , int len , unsigned int hash ) 
{ 
  struct item *aux ;
  int tmp ;

  {
#line 168
  aux = hashtab[hash % 256U];
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! aux) {
#line 168
      goto while_break;
    }
#line 169
    if (aux->hash == hash) {
#line 169
      if (aux->len == (unsigned int )len) {
        {
#line 169
        tmp = memcmp((void const   *)(aux->name), (void const   *)name, (size_t )len);
        }
#line 169
        if (tmp == 0) {
#line 171
          return (1);
        }
      }
    }
#line 168
    aux = aux->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (0);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void define_config(char const   *name , int len , unsigned int hash ) 
{ 
  struct item *aux ;
  void *tmp ;

  {
  {
#line 181
  tmp = malloc(sizeof(*aux) + (unsigned long )len);
#line 181
  aux = (struct item *)tmp;
  }
#line 183
  if (! aux) {
    {
#line 184
    perror("fixdep:malloc");
#line 185
    exit(1);
    }
  }
  {
#line 187
  memcpy((void */* __restrict  */)(aux->name), (void const   */* __restrict  */)name,
         (size_t )len);
#line 188
  aux->len = (unsigned int )len;
#line 189
  aux->hash = hash;
#line 190
  aux->next = hashtab[hash % 256U];
#line 191
  hashtab[hash % 256U] = aux;
  }
#line 192
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void clear_config(void) 
{ 
  struct item *aux ;
  struct item *next ;
  unsigned int i ;

  {
#line 202
  i = 0U;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < 256U)) {
#line 202
      goto while_break;
    }
#line 203
    aux = hashtab[i];
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! aux) {
#line 203
        goto while_break___0;
      }
      {
#line 204
      next = aux->next;
#line 205
      free((void *)aux);
#line 203
      aux = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 207
    hashtab[i] = (struct item *)((void *)0);
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void use_config(char const   *m , int slen ) 
{ 
  unsigned int hash ;
  unsigned int tmp ;
  int c ;
  int i ;
  int tmp___0 ;

  {
  {
#line 216
  tmp = strhash(m, (unsigned int )slen);
#line 216
  hash = tmp;
#line 219
  tmp___0 = is_defined_config(m, slen, hash);
  }
#line 219
  if (tmp___0) {
#line 220
    return;
  }
  {
#line 222
  define_config(m, slen, hash);
#line 224
  printf((char const   */* __restrict  */)"    $(wildcard include/config/");
#line 225
  i = 0;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < slen)) {
#line 225
      goto while_break;
    }
#line 226
    c = (int )*(m + i);
#line 227
    if (c == 95) {
#line 228
      c = '/';
    } else {
      {
#line 230
      c = tolower(c);
      }
    }
    {
#line 231
    putchar(c);
#line 225
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  printf((char const   */* __restrict  */)".h) \\\n");
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void parse_config_file(char const   *map , size_t len ) 
{ 
  int const   *end ;
  int const   *m ;
  char const   *p ;
  char const   *q ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
#line 238
  end = (int const   *)(map + len);
#line 240
  m = (int const   *)map + 1;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = ntohl((uint32_t )1129270854);
    }
#line 244
    if ((uint32_t )*m == tmp) {
#line 244
      p = (char const   *)((char *)m);
#line 244
      goto conf;
    }
    {
#line 245
    tmp___0 = ntohl((uint32_t )1330529865);
    }
#line 245
    if ((uint32_t )*m == tmp___0) {
#line 245
      p = (char const   *)((char *)m - 1);
#line 245
      goto conf;
    }
    {
#line 246
    tmp___1 = ntohl((uint32_t )1313229127);
    }
#line 246
    if ((uint32_t )*m == tmp___1) {
#line 246
      p = (char const   *)((char *)m - 2);
#line 246
      goto conf;
    }
    {
#line 247
    tmp___2 = ntohl((uint32_t )1179207519);
    }
#line 247
    if ((uint32_t )*m == tmp___2) {
#line 247
      p = (char const   *)((char *)m - 3);
#line 247
      goto conf;
    }
#line 248
    goto __Cont;
    conf: 
#line 250
    if ((unsigned long )p > (unsigned long )((map + len) - 7)) {
#line 251
      goto __Cont;
    }
    {
#line 252
    tmp___3 = memcmp((void const   *)p, (void const   *)"CONFIG_", (size_t )7);
    }
#line 252
    if (tmp___3) {
#line 253
      goto __Cont;
    }
#line 254
    q = p + 7;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! ((unsigned long )q < (unsigned long )(map + len))) {
#line 254
        goto while_break___0;
      }
      {
#line 255
      tmp___4 = __ctype_b_loc();
      }
#line 255
      if (! ((int const   )*(*tmp___4 + (int )*q) & 8)) {
#line 255
        if (! ((int const   )*q == 95)) {
#line 256
          goto found;
        }
      }
#line 254
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    goto __Cont;
    found: 
    {
#line 261
    tmp___5 = memcmp((void const   *)(q - 7), (void const   *)"_MODULE", (size_t )7);
    }
#line 261
    if (! tmp___5) {
#line 262
      q -= 7;
    }
#line 263
    if ((q - p) - 7L < 0L) {
#line 264
      goto __Cont;
    }
    {
#line 265
    use_config(p + 7, (int )((q - p) - 7L));
    }
    __Cont: /* CIL Label */ 
#line 243
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static int strrcmp(char *s , char *sub ) 
{ 
  int slen ;
  size_t tmp ;
  int sublen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 272
  tmp = strlen((char const   *)s);
#line 272
  slen = (int )tmp;
#line 273
  tmp___0 = strlen((char const   *)sub);
#line 273
  sublen = (int )tmp___0;
  }
#line 275
  if (sublen > slen) {
#line 276
    return (1);
  }
  {
#line 278
  tmp___1 = memcmp((void const   *)((s + slen) - sublen), (void const   *)sub, (size_t )sublen);
  }
#line 278
  return (tmp___1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void do_config_file(char const   *filename ) 
{ 
  struct stat st ;
  int fd ;
  void *map ;

  {
  {
#line 287
  fd = open(filename, 0);
  }
#line 288
  if (fd < 0) {
    {
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error opening config file: ");
#line 290
    perror(filename);
#line 291
    exit(2);
    }
  }
  {
#line 293
  fstat(fd, & st);
  }
#line 294
  if (st.st_size == 0L) {
    {
#line 295
    close(fd);
    }
#line 296
    return;
  }
  {
#line 298
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 299
  if ((long )map == -1L) {
    {
#line 300
    perror("fixdep: mmap");
#line 301
    close(fd);
    }
#line 302
    return;
  }
  {
#line 305
  parse_config_file((char const   *)map, (size_t )st.st_size);
#line 307
  munmap(map, (size_t )st.st_size);
#line 309
  close(fd);
  }
#line 310
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void parse_dep_file(void *map , size_t len ) 
{ 
  char *m ;
  char *end ;
  char *p ;
  char s[4096] ;
  int is_target ;
  int saw_any_target ;
  int is_first_dep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 319
  m = (char *)map;
#line 320
  end = m + len;
#line 324
  saw_any_target = 0;
#line 325
  is_first_dep = 0;
#line 327
  clear_config();
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 329
      goto while_break;
    }
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if ((unsigned long )m < (unsigned long )end) {
#line 331
        if (! ((int )*m == 32)) {
#line 331
          if (! ((int )*m == 92)) {
#line 331
            if (! ((int )*m == 10)) {
#line 331
              goto while_break___0;
            }
          }
        }
      } else {
#line 331
        goto while_break___0;
      }
#line 332
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 334
    p = m;
    {
#line 335
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 335
      if ((unsigned long )p < (unsigned long )end) {
#line 335
        if ((int )*p != 32) {
#line 335
          if ((int )*p != 92) {
#line 335
            if (! ((int )*p != 10)) {
#line 335
              goto while_break___1;
            }
          } else {
#line 335
            goto while_break___1;
          }
        } else {
#line 335
          goto while_break___1;
        }
      } else {
#line 335
        goto while_break___1;
      }
#line 336
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    is_target = (int )*(p - 1) == 58;
#line 340
    if (is_target) {
#line 342
      is_first_dep = 1;
    } else {
      {
#line 345
      memcpy((void */* __restrict  */)(s), (void const   */* __restrict  */)m, (size_t )(p - m));
#line 346
      s[p - m] = (char)0;
#line 349
      tmp = strrcmp(s, (char *)"include/generated/autoconf.h");
      }
#line 349
      if (tmp) {
        {
#line 349
        tmp___0 = strrcmp(s, (char *)"arch/um/include/uml-config.h");
        }
#line 349
        if (tmp___0) {
          {
#line 349
          tmp___1 = strrcmp(s, (char *)"include/linux/kconfig.h");
          }
#line 349
          if (tmp___1) {
            {
#line 349
            tmp___2 = strrcmp(s, (char *)".ver");
            }
#line 349
            if (tmp___2) {
#line 360
              if (is_first_dep) {
#line 370
                if (! saw_any_target) {
                  {
#line 371
                  saw_any_target = 1;
#line 372
                  printf((char const   */* __restrict  */)"source_%s := %s\n\n", target,
                         s);
#line 374
                  printf((char const   */* __restrict  */)"deps_%s := \\\n", target);
                  }
                }
#line 377
                is_first_dep = 0;
              } else {
                {
#line 379
                printf((char const   */* __restrict  */)"  %s \\\n", s);
                }
              }
              {
#line 380
              do_config_file((char const   *)(s));
              }
            }
          }
        }
      }
    }
#line 387
    m = p + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (! saw_any_target) {
    {
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: parse error; no targets found\n");
#line 392
    exit(1);
    }
  }
  {
#line 395
  printf((char const   */* __restrict  */)"\n%s: $(deps_%s)\n\n", target, target);
#line 396
  printf((char const   */* __restrict  */)"$(deps_%s):\n", target);
  }
#line 397
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void print_deps(void) 
{ 
  struct stat st ;
  int fd ;
  void *map ;
  int tmp ;

  {
  {
#line 405
  fd = open((char const   *)depfile, 0);
  }
#line 406
  if (fd < 0) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error opening depfile: ");
#line 408
    perror((char const   *)depfile);
#line 409
    exit(2);
    }
  }
  {
#line 411
  tmp = fstat(fd, & st);
  }
#line 411
  if (tmp < 0) {
    {
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error fstat\'ing depfile: ");
#line 413
    perror((char const   *)depfile);
#line 414
    exit(2);
    }
  }
#line 416
  if (st.st_size == 0L) {
    {
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: %s is empty\n",
            depfile);
#line 418
    close(fd);
    }
#line 419
    return;
  }
  {
#line 421
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 422
  if ((long )map == -1L) {
    {
#line 423
    perror("fixdep: mmap");
#line 424
    close(fd);
    }
#line 425
    return;
  }
  {
#line 428
  parse_dep_file(map, (size_t )st.st_size);
#line 430
  munmap(map, (size_t )st.st_size);
#line 432
  close(fd);
  }
#line 433
  return;
}
}
#line 437
static void traps(void) ;
#line 437 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static char test[5]  __attribute__((__aligned__(sizeof(int ))))  = {      (char )'C',      (char )'O',      (char )'N',      (char )'F', 
        (char )'\000'};
#line 435 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
static void traps(void) 
{ 
  int *p ;
  uint32_t tmp ;

  {
  {
#line 438
  p = (int *)(test);
#line 440
  tmp = ntohl((uint32_t )1129270854);
  }
#line 440
  if ((uint32_t )*p != tmp) {
    {
#line 441
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: sizeof(int) != 4 or wrong endianness? %#x\n",
            *p);
#line 443
    exit(2);
    }
  }
#line 445
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/basic/fixdep.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 449
  traps();
  }
#line 451
  if (argc != 4) {
    {
#line 452
    usage();
    }
  }
  {
#line 454
  depfile = *(argv + 1);
#line 455
  target = *(argv + 2);
#line 456
  cmdline = *(argv + 3);
#line 458
  print_cmdline();
#line 459
  print_deps();
  }
#line 461
  return (0);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc_proto.h"
void conf_parse(char const   *name ) ;
#line 5
int conf_read(char const   *name ) ;
#line 6
int conf_read_simple(char const   *name , int def ) ;
#line 7
int conf_write_defconfig(char const   *filename ) ;
#line 8
int conf_write(char const   *name ) ;
#line 9
int conf_write_autoconf(void) ;
#line 10
_Bool conf_get_changed(void) ;
#line 12
void conf_set_message_callback(void (*fn)(char const   *fmt , va_list ap ) ) ;
#line 15
struct menu rootmenu ;
#line 18
_Bool menu_is_visible(struct menu *menu ) ;
#line 20
char const   *menu_get_prompt(struct menu *menu ) ;
#line 22
struct menu *menu_get_parent_menu(struct menu *menu ) ;
#line 23
_Bool menu_has_help(struct menu *menu ) ;
#line 26
void menu_get_ext_help(struct menu *menu , struct gstr *help ) ;
#line 37
void sym_calc_value(struct symbol *sym ) ;
#line 38
enum symbol_type sym_get_type(struct symbol *sym ) ;
#line 39
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) ;
#line 40
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) ;
#line 44
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) ;
#line 45
_Bool sym_is_changable(struct symbol *sym ) ;
#line 47
char const   *sym_get_string_value(struct symbol *sym ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static char const   *CONFIG_prefix(void) 
{ 
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 42
  tmp___1 = getenv("CONFIG_");
#line 42
  tmp___0 = (char const   *)tmp___1;
  }
#line 42
  if (! tmp___0) {
#line 42
    tmp___0 = "CONFIG_";
  }
#line 42
  return (tmp___0);
}
}
#line 80
char const   *conf_get_configname(void) ;
#line 82
char *conf_get_default_confname(void) ;
#line 85
_Bool conf_set_all_new_symbols(enum conf_def_mode mode ) ;
#line 130
struct gstr str_new(void) ;
#line 131
void str_free(struct gstr *gs ) ;
#line 134
char const   *str_get(struct gstr *gs ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static tristate sym_get_tristate_value(struct symbol *sym ) 
{ 


  {
#line 150
  return (sym->curr.tri);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static struct symbol *sym_get_choice_value(struct symbol *sym ) 
{ 


  {
#line 156
  return ((struct symbol *)sym->curr.val);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_set_choice_value(struct symbol *ch , struct symbol *chval ) 
{ 
  _Bool tmp ;

  {
  {
#line 161
  tmp = sym_set_tristate_value(chval, (tristate )2);
  }
#line 161
  return (tmp);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 166
  if (sym->flags & 16) {
#line 166
    tmp = 1;
  } else {
#line 166
    tmp = 0;
  }
#line 166
  return ((_Bool )tmp);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 171
  if (sym->flags & 32) {
#line 171
    tmp = 1;
  } else {
#line 171
    tmp = 0;
  }
#line 171
  return ((_Bool )tmp);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_has_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 181
  if (sym->flags & 65536) {
#line 181
    tmp = 1;
  } else {
#line 181
    tmp = 0;
  }
#line 181
  return ((_Bool )tmp);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) ;
#line 21
static void check_conf(struct menu *menu ) ;
#line 22
static void xfgets(char *str , int size , FILE *in ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
enum input_mode input_mode  =    (enum input_mode )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int indent  =    1;
#line 40 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int tty_stdio  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int valid_stdin  =    1;
#line 42 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int sync_kconfig  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int conf_cnt  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static char line[128]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static struct menu *rootEntry  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void print_help(struct menu *menu ) 
{ 
  struct gstr help ;
  struct gstr tmp ;
  char const   *tmp___0 ;

  {
  {
#line 49
  tmp = str_new();
#line 49
  help = tmp;
#line 51
  menu_get_ext_help(menu, & help);
#line 53
  tmp___0 = str_get(& help);
#line 53
  printf((char const   */* __restrict  */)"\n%s\n", tmp___0);
#line 54
  str_free(& help);
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void strip(char *str ) 
{ 
  char *p ;
  int l ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 59
  p = str;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    tmp = __ctype_b_loc();
    }
#line 62
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 62
      goto while_break;
    }
#line 63
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  tmp___0 = strlen((char const   *)p);
#line 64
  l = (int )tmp___0;
  }
#line 65
  if ((unsigned long )p != (unsigned long )str) {
    {
#line 66
    memmove((void *)str, (void const   *)p, (size_t )(l + 1));
    }
  }
#line 67
  if (! l) {
#line 68
    return;
  }
#line 69
  p = (str + l) - 1;
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 70
    tmp___2 = __ctype_b_loc();
    }
#line 70
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 70
      goto while_break___0;
    }
#line 71
    tmp___1 = p;
#line 71
    p --;
#line 71
    *tmp___1 = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void check_stdin(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 76
  if (! valid_stdin) {
    {
#line 77
    tmp = gettext("aborted!\n\n");
#line 77
    printf((char const   */* __restrict  */)tmp);
#line 78
    tmp___0 = gettext("Console input/output is redirected. ");
#line 78
    printf((char const   */* __restrict  */)tmp___0);
#line 79
    tmp___1 = gettext("Run \'make oldconfig\' to update configuration.\n\n");
#line 79
    printf((char const   */* __restrict  */)tmp___1);
#line 80
    exit(1);
    }
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int conf_askvalue(struct symbol *sym , char const   *def ) 
{ 
  enum symbol_type type ;
  enum symbol_type tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 86
  tmp = sym_get_type(sym);
#line 86
  type = tmp;
#line 88
  tmp___1 = sym_has_value(sym);
  }
#line 88
  if (! tmp___1) {
    {
#line 89
    tmp___0 = gettext("(NEW) ");
#line 89
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 91
  line[0] = (char )'\n';
#line 92
  line[1] = (char)0;
#line 94
  tmp___2 = sym_is_changable(sym);
  }
#line 94
  if (! tmp___2) {
    {
#line 95
    printf((char const   */* __restrict  */)"%s\n", def);
#line 96
    line[0] = (char )'\n';
#line 97
    line[1] = (char)0;
    }
#line 98
    return (0);
  }
  {
#line 103
  if ((unsigned int )input_mode == 1U) {
#line 103
    goto case_1;
  }
#line 103
  if ((unsigned int )input_mode == 2U) {
#line 103
    goto case_1;
  }
#line 110
  if ((unsigned int )input_mode == 0U) {
#line 110
    goto case_0;
  }
#line 116
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 104
  tmp___3 = sym_has_value(sym);
  }
#line 104
  if (tmp___3) {
    {
#line 105
    printf((char const   */* __restrict  */)"%s\n", def);
    }
#line 106
    return (0);
  }
  {
#line 108
  check_stdin();
  }
  case_0: /* CIL Label */ 
  {
#line 111
  fflush(stdout);
#line 112
  xfgets(line, 128, stdin);
  }
#line 113
  if (! tty_stdio) {
    {
#line 114
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 115
  return (1);
  switch_default: /* CIL Label */ 
#line 117
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 123
  if ((unsigned int )type == 5U) {
#line 123
    goto case_5;
  }
#line 123
  if ((unsigned int )type == 4U) {
#line 123
    goto case_5;
  }
#line 123
  if ((unsigned int )type == 3U) {
#line 123
    goto case_5;
  }
#line 126
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"%s\n", def);
  }
#line 125
  return (1);
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 129
  printf((char const   */* __restrict  */)"%s", line);
  }
#line 130
  return (1);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int conf_string(struct menu *menu ) 
{ 
  struct symbol *sym ;
  char const   *def ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  _Bool tmp___3 ;

  {
#line 135
  sym = menu->sym;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    tmp = gettext((menu->prompt)->text);
#line 139
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", tmp);
#line 140
    printf((char const   */* __restrict  */)"(%s) ", sym->name);
#line 141
    def = sym_get_string_value(sym);
#line 142
    tmp___0 = sym_get_string_value(sym);
    }
#line 142
    if (tmp___0) {
      {
#line 143
      printf((char const   */* __restrict  */)"[%s] ", def);
      }
    }
    {
#line 144
    tmp___1 = conf_askvalue(sym, def);
    }
#line 144
    if (! tmp___1) {
#line 145
      return (0);
    }
    {
#line 147
    if ((int )line[0] == 10) {
#line 147
      goto case_10;
    }
#line 149
    if ((int )line[0] == 63) {
#line 149
      goto case_63;
    }
#line 157
    goto switch_default;
    case_10: /* CIL Label */ 
#line 148
    goto switch_break;
    case_63: /* CIL Label */ 
#line 151
    if ((int )line[1] == 10) {
      {
#line 152
      print_help(menu);
#line 153
      def = (char const   *)((void *)0);
      }
#line 154
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 158
    tmp___2 = strlen((char const   *)(line));
#line 158
    line[tmp___2 - 1UL] = (char)0;
#line 159
    def = (char const   *)(line);
    }
    switch_break: /* CIL Label */ ;
    }
#line 161
    if (def) {
      {
#line 161
      tmp___3 = sym_set_string_value(sym, def);
      }
#line 161
      if (tmp___3) {
#line 162
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int conf_sym(struct menu *menu ) 
{ 
  struct symbol *sym ;
  tristate oldval ;
  tristate newval ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 168
  sym = menu->sym;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    tmp = gettext((menu->prompt)->text);
#line 172
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", tmp);
    }
#line 173
    if (sym->name) {
      {
#line 174
      printf((char const   */* __restrict  */)"(%s) ", sym->name);
      }
    }
    {
#line 175
    putchar('[');
#line 176
    oldval = sym_get_tristate_value(sym);
    }
    {
#line 178
    if ((unsigned int )oldval == 0U) {
#line 178
      goto case_0;
    }
#line 181
    if ((unsigned int )oldval == 1U) {
#line 181
      goto case_1;
    }
#line 184
    if ((unsigned int )oldval == 2U) {
#line 184
      goto case_2;
    }
#line 177
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 179
    putchar('N');
    }
#line 180
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 182
    putchar('M');
    }
#line 183
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 185
    putchar('Y');
    }
#line 186
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 188
    if ((unsigned int )oldval != 0U) {
      {
#line 188
      tmp___0 = sym_tristate_within_range(sym, (tristate )0);
      }
#line 188
      if (tmp___0) {
        {
#line 189
        printf((char const   */* __restrict  */)"/n");
        }
      }
    }
#line 190
    if ((unsigned int )oldval != 1U) {
      {
#line 190
      tmp___1 = sym_tristate_within_range(sym, (tristate )1);
      }
#line 190
      if (tmp___1) {
        {
#line 191
        printf((char const   */* __restrict  */)"/m");
        }
      }
    }
#line 192
    if ((unsigned int )oldval != 2U) {
      {
#line 192
      tmp___2 = sym_tristate_within_range(sym, (tristate )2);
      }
#line 192
      if (tmp___2) {
        {
#line 193
        printf((char const   */* __restrict  */)"/y");
        }
      }
    }
    {
#line 194
    tmp___3 = menu_has_help(menu);
    }
#line 194
    if (tmp___3) {
      {
#line 195
      printf((char const   */* __restrict  */)"/?");
      }
    }
    {
#line 196
    printf((char const   */* __restrict  */)"] ");
#line 197
    tmp___4 = sym_get_string_value(sym);
#line 197
    tmp___5 = conf_askvalue(sym, tmp___4);
    }
#line 197
    if (! tmp___5) {
#line 198
      return (0);
    }
    {
#line 199
    strip(line);
    }
    {
#line 203
    if ((int )line[0] == 78) {
#line 203
      goto case_78;
    }
#line 203
    if ((int )line[0] == 110) {
#line 203
      goto case_78;
    }
#line 209
    if ((int )line[0] == 77) {
#line 209
      goto case_77;
    }
#line 209
    if ((int )line[0] == 109) {
#line 209
      goto case_77;
    }
#line 215
    if ((int )line[0] == 89) {
#line 215
      goto case_89;
    }
#line 215
    if ((int )line[0] == 121) {
#line 215
      goto case_89;
    }
#line 220
    if ((int )line[0] == 0) {
#line 220
      goto case_0___0;
    }
#line 223
    if ((int )line[0] == 63) {
#line 223
      goto case_63;
    }
#line 225
    goto switch_default;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 204
    newval = (tristate )0;
#line 205
    if (! line[1]) {
#line 206
      goto switch_break___0;
    } else {
      {
#line 205
      tmp___6 = strcmp((char const   *)(& line[1]), "o");
      }
#line 205
      if (! tmp___6) {
#line 206
        goto switch_break___0;
      }
    }
#line 207
    goto while_continue;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 210
    newval = (tristate )1;
#line 211
    if (! line[1]) {
#line 212
      goto switch_break___0;
    }
#line 213
    goto while_continue;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 216
    newval = (tristate )2;
#line 217
    if (! line[1]) {
#line 218
      goto switch_break___0;
    } else {
      {
#line 217
      tmp___7 = strcmp((char const   *)(& line[1]), "es");
      }
#line 217
      if (! tmp___7) {
#line 218
        goto switch_break___0;
      }
    }
#line 219
    goto while_continue;
    case_0___0: /* CIL Label */ 
#line 221
    newval = oldval;
#line 222
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 224
    goto help;
    switch_default: /* CIL Label */ 
#line 226
    goto while_continue;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 228
    tmp___8 = sym_set_tristate_value(sym, newval);
    }
#line 228
    if (tmp___8) {
#line 229
      return (0);
    }
    help: 
    {
#line 231
    print_help(menu);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static int conf_choice(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct symbol *def_sym ;
  struct menu *child ;
  _Bool is_new ;
  _Bool tmp ;
  int tmp___0 ;
  tristate tmp___1 ;
  tristate tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int cnt ;
  int def ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  _Bool tmp___14 ;
  char *tmp___15 ;
  _Bool tmp___16 ;
  unsigned short const   **tmp___17 ;
  _Bool tmp___18 ;
  size_t tmp___19 ;

  {
  {
#line 241
  sym = menu->sym;
#line 242
  tmp = sym_has_value(sym);
  }
#line 242
  if (tmp) {
#line 242
    tmp___0 = 0;
  } else {
#line 242
    tmp___0 = 1;
  }
  {
#line 242
  is_new = (_Bool )tmp___0;
#line 243
  tmp___5 = sym_is_changable(sym);
  }
#line 243
  if (tmp___5) {
    {
#line 244
    conf_sym(menu);
#line 245
    sym_calc_value(sym);
#line 246
    tmp___1 = sym_get_tristate_value(sym);
    }
    {
#line 247
    if ((unsigned int )tmp___1 == 0U) {
#line 247
      goto case_0;
    }
#line 249
    if ((unsigned int )tmp___1 == 1U) {
#line 249
      goto case_1;
    }
#line 251
    if ((unsigned int )tmp___1 == 2U) {
#line 251
      goto case_2;
    }
#line 246
    goto switch_break;
    case_0: /* CIL Label */ 
#line 248
    return (1);
    case_1: /* CIL Label */ 
#line 250
    return (0);
    case_2: /* CIL Label */ 
#line 252
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 255
    tmp___2 = sym_get_tristate_value(sym);
    }
    {
#line 256
    if ((unsigned int )tmp___2 == 0U) {
#line 256
      goto case_0___0;
    }
#line 258
    if ((unsigned int )tmp___2 == 1U) {
#line 258
      goto case_1___0;
    }
#line 261
    if ((unsigned int )tmp___2 == 2U) {
#line 261
      goto case_2___0;
    }
#line 255
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 257
    return (1);
    case_1___0: /* CIL Label */ 
    {
#line 259
    tmp___3 = menu_get_prompt(menu);
#line 259
    tmp___4 = gettext(tmp___3);
#line 259
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___4);
    }
#line 260
    return (0);
    case_2___0: /* CIL Label */ 
#line 262
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    tmp___6 = menu_get_prompt(menu);
#line 269
    tmp___7 = gettext(tmp___6);
#line 269
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___7);
#line 270
    def_sym = sym_get_choice_value(sym);
#line 271
    def = 0;
#line 271
    cnt = def;
#line 272
    line[0] = (char)0;
#line 273
    child = menu->list;
    }
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (! child) {
#line 273
        goto while_break___0;
      }
      {
#line 274
      tmp___8 = menu_is_visible(child);
      }
#line 274
      if (! tmp___8) {
#line 275
        goto __Cont;
      }
#line 276
      if (! child->sym) {
        {
#line 277
        tmp___9 = menu_get_prompt(child);
#line 277
        tmp___10 = gettext(tmp___9);
#line 277
        printf((char const   */* __restrict  */)"%*c %s\n", indent, '*', tmp___10);
        }
#line 278
        goto __Cont;
      }
#line 280
      cnt ++;
#line 281
      if ((unsigned long )child->sym == (unsigned long )def_sym) {
        {
#line 282
        def = cnt;
#line 283
        printf((char const   */* __restrict  */)"%*c", indent, '>');
        }
      } else {
        {
#line 285
        printf((char const   */* __restrict  */)"%*c", indent, ' ');
        }
      }
      {
#line 286
      tmp___11 = menu_get_prompt(child);
#line 286
      tmp___12 = gettext(tmp___11);
#line 286
      printf((char const   */* __restrict  */)" %d. %s", cnt, tmp___12);
      }
#line 287
      if ((child->sym)->name) {
        {
#line 288
        printf((char const   */* __restrict  */)" (%s)", (child->sym)->name);
        }
      }
      {
#line 289
      tmp___14 = sym_has_value(child->sym);
      }
#line 289
      if (! tmp___14) {
        {
#line 290
        tmp___13 = gettext(" (NEW)");
#line 290
        printf((char const   */* __restrict  */)tmp___13);
        }
      }
      {
#line 291
      printf((char const   */* __restrict  */)"\n");
      }
      __Cont: /* CIL Label */ 
#line 273
      child = child->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 293
    tmp___15 = gettext("%*schoice");
#line 293
    printf((char const   */* __restrict  */)tmp___15, indent - 1, "");
    }
#line 294
    if (cnt == 1) {
      {
#line 295
      printf((char const   */* __restrict  */)"[1]: 1\n");
      }
#line 296
      goto conf_childs;
    }
    {
#line 298
    printf((char const   */* __restrict  */)"[1-%d", cnt);
#line 299
    tmp___16 = menu_has_help(menu);
    }
#line 299
    if (tmp___16) {
      {
#line 300
      printf((char const   */* __restrict  */)"?");
      }
    }
    {
#line 301
    printf((char const   */* __restrict  */)"]: ");
    }
    {
#line 304
    if ((unsigned int )input_mode == 1U) {
#line 304
      goto case_1___1;
    }
#line 304
    if ((unsigned int )input_mode == 2U) {
#line 304
      goto case_1___1;
    }
#line 312
    if ((unsigned int )input_mode == 0U) {
#line 312
      goto case_0___1;
    }
#line 327
    goto switch_default;
    case_1___1: /* CIL Label */ 
    case_2___1: /* CIL Label */ 
#line 305
    if (! is_new) {
      {
#line 306
      cnt = def;
#line 307
      printf((char const   */* __restrict  */)"%d\n", cnt);
      }
#line 308
      goto switch_break___1;
    }
    {
#line 310
    check_stdin();
    }
    case_0___1: /* CIL Label */ 
    {
#line 313
    fflush(stdout);
#line 314
    xfgets(line, 128, stdin);
#line 315
    strip(line);
    }
#line 316
    if ((int )line[0] == 63) {
      {
#line 317
      print_help(menu);
      }
#line 318
      goto while_continue;
    }
#line 320
    if (! line[0]) {
#line 321
      cnt = def;
    } else {
      {
#line 322
      tmp___17 = __ctype_b_loc();
      }
#line 322
      if ((int const   )*(*tmp___17 + (int )line[0]) & 2048) {
        {
#line 323
        cnt = atoi((char const   *)(line));
        }
      } else {
#line 325
        goto while_continue;
      }
    }
#line 326
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 328
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    conf_childs: 
#line 332
    child = menu->list;
    {
#line 332
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 332
      if (! child) {
#line 332
        goto while_break___1;
      }
#line 333
      if (! child->sym) {
#line 334
        goto __Cont___0;
      } else {
        {
#line 333
        tmp___18 = menu_is_visible(child);
        }
#line 333
        if (! tmp___18) {
#line 334
          goto __Cont___0;
        }
      }
#line 335
      cnt --;
#line 335
      if (! cnt) {
#line 336
        goto while_break___1;
      }
      __Cont___0: /* CIL Label */ 
#line 332
      child = child->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    if (! child) {
#line 339
      goto while_continue;
    }
#line 340
    if (line[0]) {
      {
#line 340
      tmp___19 = strlen((char const   *)(line));
      }
#line 340
      if ((int )line[tmp___19 - 1UL] == 63) {
        {
#line 341
        print_help(child);
        }
#line 342
        goto while_continue;
      }
    }
    {
#line 344
    sym_set_choice_value(sym, child->sym);
#line 345
    child = child->list;
    }
    {
#line 345
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 345
      if (! child) {
#line 345
        goto while_break___2;
      }
      {
#line 346
      indent += 2;
#line 347
      conf(child);
#line 348
      indent -= 2;
#line 345
      child = child->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 350
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  struct menu *child ;
  _Bool tmp ;
  char const   *prompt ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 360
  tmp = menu_is_visible(menu);
  }
#line 360
  if (! tmp) {
#line 361
    return;
  }
#line 363
  sym = menu->sym;
#line 364
  prop = menu->prompt;
#line 365
  if (prop) {
    {
#line 369
    if ((unsigned int )prop->type == 3U) {
#line 369
      goto case_3;
    }
#line 378
    if ((unsigned int )prop->type == 2U) {
#line 378
      goto case_2;
    }
#line 385
    goto switch_default;
    case_3: /* CIL Label */ 
#line 370
    if ((unsigned int )input_mode == 1U) {
#line 370
      goto _L;
    } else
#line 370
    if ((unsigned int )input_mode == 10U) {
#line 370
      goto _L;
    } else
#line 370
    if ((unsigned int )input_mode == 11U) {
      _L: /* CIL Label */ 
#line 370
      if ((unsigned long )rootEntry != (unsigned long )menu) {
        {
#line 374
        check_conf(menu);
        }
#line 375
        return;
      }
    }
    case_2: /* CIL Label */ 
    {
#line 379
    prompt = menu_get_prompt(menu);
    }
#line 380
    if (prompt) {
      {
#line 381
      tmp___0 = gettext(prompt);
#line 381
      printf((char const   */* __restrict  */)"%*c\n%*c %s\n%*c\n", indent, '*', indent,
             '*', tmp___0, indent, '*');
      }
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 390
  if (! sym) {
#line 391
    goto conf_childs;
  }
  {
#line 393
  tmp___1 = sym_is_choice(sym);
  }
#line 393
  if (tmp___1) {
    {
#line 394
    conf_choice(menu);
    }
#line 395
    if ((unsigned int )sym->curr.tri != 1U) {
#line 396
      return;
    }
#line 397
    goto conf_childs;
  }
  {
#line 403
  if ((unsigned int )sym->type == 5U) {
#line 403
    goto case_5;
  }
#line 403
  if ((unsigned int )sym->type == 4U) {
#line 403
    goto case_5;
  }
#line 403
  if ((unsigned int )sym->type == 3U) {
#line 403
    goto case_5;
  }
#line 406
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 404
  conf_string(menu);
  }
#line 405
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 407
  conf_sym(menu);
  }
#line 408
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  conf_childs: 
#line 412
  if (sym) {
#line 413
    indent += 2;
  }
#line 414
  child = menu->list;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! child) {
#line 414
      goto while_break;
    }
    {
#line 415
    conf(child);
#line 414
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  if (sym) {
#line 417
    indent -= 2;
  }
#line 418
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void check_conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct menu *child ;
  _Bool tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  tristate tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 425
  tmp = menu_is_visible(menu);
  }
#line 425
  if (! tmp) {
#line 426
    return;
  }
#line 428
  sym = menu->sym;
#line 429
  if (sym) {
    {
#line 429
    tmp___7 = sym_has_value(sym);
    }
#line 429
    if (! tmp___7) {
      {
#line 430
      tmp___4 = sym_is_changable(sym);
      }
#line 430
      if (tmp___4) {
#line 430
        goto _L;
      } else {
        {
#line 430
        tmp___5 = sym_is_choice(sym);
        }
#line 430
        if (tmp___5) {
          {
#line 430
          tmp___6 = sym_get_tristate_value(sym);
          }
#line 430
          if ((unsigned int )tmp___6 == 2U) {
            _L: /* CIL Label */ 
#line 432
            if ((unsigned int )input_mode == 10U) {
#line 433
              if (sym->name) {
                {
#line 433
                tmp___1 = sym_is_choice_value(sym);
                }
#line 433
                if (! tmp___1) {
                  {
#line 434
                  tmp___0 = CONFIG_prefix();
#line 434
                  printf((char const   */* __restrict  */)"%s%s\n", tmp___0, sym->name);
                  }
                }
              }
            } else
#line 436
            if ((unsigned int )input_mode != 11U) {
#line 437
              tmp___3 = conf_cnt;
#line 437
              conf_cnt ++;
#line 437
              if (! tmp___3) {
                {
#line 438
                tmp___2 = gettext("*\n* Restart config...\n*\n");
#line 438
                printf((char const   */* __restrict  */)tmp___2);
                }
              }
              {
#line 439
              rootEntry = menu_get_parent_menu(menu);
#line 440
              conf(rootEntry);
              }
            }
          }
        }
      }
    }
  }
#line 445
  child = menu->list;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! child) {
#line 445
      goto while_break;
    }
    {
#line 446
    check_conf(child);
#line 445
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static struct option long_opts[14]  = 
#line 449
  {      {"oldaskconfig", 0, (int *)((void *)0), 0}, 
        {"oldconfig", 0, (int *)((void *)0), 2}, 
        {"silentoldconfig", 0, (int *)((void *)0), 1}, 
        {"defconfig", 2, (int *)((void *)0), 8}, 
        {"savedefconfig", 1, (int *)((void *)0), 9}, 
        {"allnoconfig", 0, (int *)((void *)0), 3}, 
        {"allyesconfig", 0, (int *)((void *)0), 4}, 
        {"allmodconfig", 0, (int *)((void *)0), 5}, 
        {"alldefconfig", 0, (int *)((void *)0), 6}, 
        {"randconfig", 0, (int *)((void *)0), 7}, 
        {"listnewconfig", 0, (int *)((void *)0), 10}, 
        {"olddefconfig", 0, (int *)((void *)0), 11}, 
        {"oldnoconfig", 0, (int *)((void *)0), 11}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 471 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void conf_usage(char const   *progname ) 
{ 


  {
  {
#line 474
  printf((char const   */* __restrict  */)"Usage: %s [-s] [option] <kconfig-file>\n",
         progname);
#line 475
  printf((char const   */* __restrict  */)"[option] is _one_ of the following:\n");
#line 476
  printf((char const   */* __restrict  */)"  --listnewconfig         List new options\n");
#line 477
  printf((char const   */* __restrict  */)"  --oldaskconfig          Start a new configuration using a line-oriented program\n");
#line 478
  printf((char const   */* __restrict  */)"  --oldconfig             Update a configuration using a provided .config as base\n");
#line 479
  printf((char const   */* __restrict  */)"  --silentoldconfig       Same as oldconfig, but quietly, additionally update deps\n");
#line 480
  printf((char const   */* __restrict  */)"  --olddefconfig          Same as silentoldconfig but sets new symbols to their default value\n");
#line 481
  printf((char const   */* __restrict  */)"  --oldnoconfig           An alias of olddefconfig\n");
#line 482
  printf((char const   */* __restrict  */)"  --defconfig <file>      New config with default defined in <file>\n");
#line 483
  printf((char const   */* __restrict  */)"  --savedefconfig <file>  Save the minimal current configuration to <file>\n");
#line 484
  printf((char const   */* __restrict  */)"  --allnoconfig           New config where all options are answered with no\n");
#line 485
  printf((char const   */* __restrict  */)"  --allyesconfig          New config where all options are answered with yes\n");
#line 486
  printf((char const   */* __restrict  */)"  --allmodconfig          New config where all options are answered with mod\n");
#line 487
  printf((char const   */* __restrict  */)"  --alldefconfig          New config with all symbols set to default\n");
#line 488
  printf((char const   */* __restrict  */)"  --randconfig            New config with random answer to all options\n");
  }
#line 489
  return;
}
}
#line 718 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/conf.c"
static void xfgets(char *str , int size , FILE *in ) 
{ 
  char *tmp ;

  {
  {
#line 720
  tmp = fgets((char */* __restrict  */)str, size, (FILE */* __restrict  */)in);
  }
#line 720
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 721
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError in reading or end of file.\n");
    }
  }
#line 722
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 209 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 72
  return ((unsigned long )head->next == (unsigned long )head);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/list.h"
__inline static void __list_add(struct list_head *_new , struct list_head *prev ,
                                struct list_head *next ) 
{ 


  {
#line 85
  next->prev = _new;
#line 86
  _new->next = next;
#line 87
  _new->prev = prev;
#line 88
  prev->next = _new;
#line 89
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/list.h"
__inline static void list_add_tail(struct list_head *_new , struct list_head *head ) 
{ 


  {
  {
#line 101
  __list_add(_new, head->prev, head);
  }
#line 102
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct file *file_list  ;
#line 195 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct file *current_file  ;
#line 198
struct symbol symbol_yes ;
#line 198
struct symbol symbol_no ;
#line 198
struct symbol symbol_mod ;
#line 199 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct symbol *modules_sym  ;
#line 200 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
struct symbol *sym_defconfig_list  ;
#line 201
int cdebug ;
#line 202
struct expr *expr_alloc_symbol(struct symbol *sym ) ;
#line 203
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) ;
#line 204
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) ;
#line 205
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) ;
#line 206
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) ;
#line 207
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) ;
#line 208
struct expr *expr_copy(struct expr  const  *org ) ;
#line 209
void expr_free(struct expr *e ) ;
#line 210
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) ;
#line 211
tristate expr_calc_value(struct expr *e ) ;
#line 212
struct expr *expr_trans_bool(struct expr *e ) ;
#line 213
struct expr *expr_eliminate_dups(struct expr *e ) ;
#line 214
struct expr *expr_transform(struct expr *e ) ;
#line 215
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) ;
#line 216
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) ;
#line 217
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) ;
#line 218
struct expr *expr_simplify_unmet_dep(struct expr *e1 , struct expr *e2 ) ;
#line 220
void expr_fprint(struct expr *e , FILE *out ) ;
#line 222
void expr_gstr_print(struct expr *e , struct gstr *gs ) ;
#line 224 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.h"
__inline static int expr_is_yes(struct expr *e ) 
{ 
  int tmp ;

  {
#line 226
  if (! e) {
#line 226
    tmp = 1;
  } else
#line 226
  if ((unsigned int )e->type == 11U) {
#line 226
    if ((unsigned long )e->left.sym == (unsigned long )(& symbol_yes)) {
#line 226
      tmp = 1;
    } else {
#line 226
      tmp = 0;
    }
  } else {
#line 226
    tmp = 0;
  }
#line 226
  return (tmp);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc_proto.h"
void conf_set_changed_callback(void (*fn)(void) ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc_proto.h"
struct menu rootmenu  ;
#line 17
_Bool menu_is_empty(struct menu *menu ) ;
#line 19
_Bool menu_has_prompt(struct menu *menu ) ;
#line 21
struct menu *menu_get_root_menu(struct menu *menu ) ;
#line 24
char const   *menu_get_help(struct menu *menu ) ;
#line 25
struct gstr get_relations_str(struct symbol **sym_arr , struct list_head *head ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc_proto.h"
struct symbol *symbol_hash[9973]  ;
#line 31
struct symbol *sym_lookup(char const   *name , int flags ) ;
#line 32
struct symbol *sym_find(char const   *name ) ;
#line 33
char const   *sym_expand_string_value(char const   *in ) ;
#line 34
char const   *sym_escape_string_value(char const   *in ) ;
#line 35
struct symbol **sym_re_search(char const   *pattern ) ;
#line 36
char const   *sym_type_name(enum symbol_type type ) ;
#line 41
tristate sym_toggle_tristate_value(struct symbol *sym ) ;
#line 42
_Bool sym_string_valid(struct symbol *sym , char const   *str ) ;
#line 43
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) ;
#line 46
struct property *sym_get_choice_prop(struct symbol *sym ) ;
#line 49
char const   *prop_get_type_name(enum prop_type type ) ;
#line 52
void expr_print(struct expr *e , void (*fn)(void * , struct symbol * , char const   * ) ,
                void *data , int prevtoken ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
void zconfdump(FILE *out ) ;
#line 72
void zconf_starthelp(void) ;
#line 73
FILE *zconf_fopen(char const   *name ) ;
#line 74
void zconf_initscan(char const   *name ) ;
#line 75
void zconf_nextfile(char const   *name ) ;
#line 76
int zconf_lineno(void) ;
#line 77
char const   *zconf_curname(void) ;
#line 81
char const   *conf_get_autoconfig_name(void) ;
#line 83
void sym_set_change_count(int count ) ;
#line 84
void sym_add_change_count(int count ) ;
#line 86
void set_all_choice_values(struct symbol *csym ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static void xfwrite(void const   *str , size_t len , size_t count , FILE *out ) 
{ 
  size_t tmp ;

  {
#line 92
  if (len == 0UL) {
#line 93
    return;
  }
  {
#line 95
  tmp = fwrite((void const   */* __restrict  */)str, len, count, (FILE */* __restrict  */)out);
  }
#line 95
  if (tmp != count) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in writing or end of file.\n");
    }
  }
#line 97
  return;
}
}
#line 100
void _menu_init(void) ;
#line 101
void menu_warn(struct menu *menu , char const   *fmt  , ...) ;
#line 102
struct menu *menu_add_menu(void) ;
#line 103
void menu_end_menu(void) ;
#line 104
void menu_add_entry(struct symbol *sym ) ;
#line 105
void menu_end_entry(void) ;
#line 106
void menu_add_dep(struct expr *dep ) ;
#line 107
void menu_add_visibility(struct expr *expr ) ;
#line 108
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) ;
#line 109
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) ;
#line 110
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) ;
#line 111
void menu_add_option(int token , char *arg ) ;
#line 112
void menu_finalize(struct menu *parent ) ;
#line 113
void menu_set_type(int type ) ;
#line 116
struct file *file_lookup(char const   *name ) ;
#line 117
int file_write_dep(char const   *name ) ;
#line 118
void *xmalloc(size_t size ) ;
#line 119
void *xcalloc(size_t nmemb , size_t size ) ;
#line 132
void str_append(struct gstr *gs , char const   *s ) ;
#line 133
void str_printf(struct gstr *gs , char const   *fmt  , ...) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
struct expr *sym_env_list  ;
#line 139
void sym_init(void) ;
#line 140
void sym_clear_all_valid(void) ;
#line 141
struct symbol *sym_choice_default(struct symbol *sym ) ;
#line 142
char const   *sym_get_string_default(struct symbol *sym ) ;
#line 143
struct symbol *sym_check_deps(struct symbol *sym ) ;
#line 144
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) ;
#line 145
struct symbol *prop_get_symbol(struct property *prop ) ;
#line 146
struct property *sym_get_env_prop(struct symbol *sym ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_optional(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 176
  if (sym->flags & 256) {
#line 176
    tmp = 1;
  } else {
#line 176
    tmp = 0;
  }
#line 176
  return ((_Bool )tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
int cdebug  =    1;
#line 98
int zconflex(void) ;
#line 99
static void zconfprint(char const   *err  , ...) ;
#line 100
static void zconf_error(char const   *err  , ...) ;
#line 101
static void zconferror(char const   *err ) ;
#line 102
static _Bool zconf_endtoken(struct kconf_id  const  *id , int starttoken , int endtoken ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_menu  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_entry  ;
#line 12 "scripts/kconfig/zconf.gperf"
__inline static struct kconf_id  const __attribute__((__gnu_inline__)) *kconf_id_lookup(char const   *str ,
                                                                                        unsigned int len ) ;
#line 25
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) ;
#line 25 "scripts/kconfig/zconf.gperf"
static unsigned char const   asso_values[256]  = 
#line 25
  {      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )5,      (unsigned char const   )25,      (unsigned char const   )25, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )5, 
        (unsigned char const   )45,      (unsigned char const   )73,      (unsigned char const   )20,      (unsigned char const   )20, 
        (unsigned char const   )0,      (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )73, 
        (unsigned char const   )20,      (unsigned char const   )5,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73};
#line 16 "scripts/kconfig/zconf.gperf"
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 54
  hval = (int )len;
  {
#line 62
  if (hval == 1) {
#line 62
    goto case_1;
  }
#line 62
  if (hval == 2) {
#line 62
    goto case_1;
  }
#line 58
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 59
  hval += (int )asso_values[(unsigned char )*(str + 2)];
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 63
  hval += (int )asso_values[(unsigned char )*(str + 0)];
#line 64
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return ((unsigned int )(hval + (int )asso_values[(unsigned char )*(str + (len - 1U))]));
}
}
#line 105 "scripts/kconfig/zconf.gperf"
static struct kconf_id_strings_t  const  kconf_id_strings_contents  = 
#line 105
     {{(char )'i', (char )'f', (char )'\000'}, {(char )'i', (char )'n', (char )'t',
                                              (char )'\000'}, {(char )'e', (char )'n',
                                                               (char )'d', (char )'i',
                                                               (char )'f', (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'a', (char )'u', (char )'l', (char )'t',
     (char )'\000'}, {(char )'t', (char )'r', (char )'i', (char )'s', (char )'t',
                      (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'e',
                                                                           (char )'n',
                                                                           (char )'d',
                                                                           (char )'c',
                                                                           (char )'h',
                                                                           (char )'o',
                                                                           (char )'i',
                                                                           (char )'c',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'_', (char )'t', (char )'r', (char )'i',
     (char )'s', (char )'t', (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'d',
                                                                                  (char )'e',
                                                                                  (char )'f',
                                                                                  (char )'_',
                                                                                  (char )'b',
                                                                                  (char )'o',
                                                                                  (char )'o',
                                                                                  (char )'l',
                                                                                  (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'c', (char )'o', (char )'n', (char )'f',
     (char )'i', (char )'g', (char )'_', (char )'l', (char )'i', (char )'s', (char )'t',
     (char )'\000'}, {(char )'o', (char )'n', (char )'\000'}, {(char )'o', (char )'p',
                                                               (char )'t', (char )'i',
                                                               (char )'o', (char )'n',
                                                               (char )'a', (char )'l',
                                                               (char )'\000'}, {(char )'o',
                                                                                (char )'p',
                                                                                (char )'t',
                                                                                (char )'i',
                                                                                (char )'o',
                                                                                (char )'n',
                                                                                (char )'\000'},
    {(char )'e', (char )'n', (char )'d', (char )'m', (char )'e', (char )'n', (char )'u',
     (char )'\000'}, {(char )'m', (char )'a', (char )'i', (char )'n', (char )'m',
                      (char )'e', (char )'n', (char )'u', (char )'\000'}, {(char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'u',
                                                                           (char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'m', (char )'o', (char )'d', (char )'u', (char )'l', (char )'e', (char )'s',
     (char )'\000'}, {(char )'a', (char )'l', (char )'l', (char )'n', (char )'o',
                      (char )'c', (char )'o', (char )'n', (char )'f', (char )'i',
                      (char )'g', (char )'_', (char )'y', (char )'\000'}, {(char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'u',
                                                                           (char )'\000'},
    {(char )'s', (char )'e', (char )'l', (char )'e', (char )'c', (char )'t', (char )'\000'},
    {(char )'c', (char )'o', (char )'m', (char )'m', (char )'e', (char )'n', (char )'t',
     (char )'\000'}, {(char )'e', (char )'n', (char )'v', (char )'\000'}, {(char )'r',
                                                                           (char )'a',
                                                                           (char )'n',
                                                                           (char )'g',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'c', (char )'h', (char )'o', (char )'i', (char )'c', (char )'e', (char )'\000'},
    {(char )'b', (char )'o', (char )'o', (char )'l', (char )'\000'}, {(char )'s',
                                                                      (char )'o',
                                                                      (char )'u',
                                                                      (char )'r',
                                                                      (char )'c',
                                                                      (char )'e',
                                                                      (char )'\000'},
    {(char )'v', (char )'i', (char )'s', (char )'i', (char )'b', (char )'l', (char )'e',
     (char )'\000'}, {(char )'h', (char )'e', (char )'x', (char )'\000'}, {(char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'b', (char )'o', (char )'o', (char )'l', (char )'e', (char )'a', (char )'n',
     (char )'\000'}, {(char )'s', (char )'t', (char )'r', (char )'i', (char )'n',
                      (char )'g', (char )'\000'}, {(char )'h', (char )'e', (char )'l',
                                                   (char )'p', (char )'\000'}, {(char )'p',
                                                                                (char )'r',
                                                                                (char )'o',
                                                                                (char )'m',
                                                                                (char )'p',
                                                                                (char )'t',
                                                                                (char )'\000'},
    {(char )'d', (char )'e', (char )'p', (char )'e', (char )'n', (char )'d', (char )'s',
     (char )'\000'}};
#line 160 "scripts/kconfig/zconf.gperf"
static struct kconf_id  const  wordlist[73]  = 
#line 160
  {      {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str2)),
      269, 3U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str3)),
      274, 1U, (enum symbol_type )3}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str5)),
      270, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str7)),
      275, 1U, (enum symbol_type )0}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str8)),
      274, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str9)),
      263, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str12)),
      275, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str13)),
      275, 1U, (enum symbol_type )1}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str14)),
      2, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str17)),
      280, 2U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str18)),
      272, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str21)),
      279, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str22)),
      260, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str23)),
      258, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str25)),
      266, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str27)),
      1, 4U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str28)),
      4, 4U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str29)),
      259, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str31)),
      276, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str32)),
      264, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str33)),
      3, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str35)),
      277, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str36)),
      262, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str39)),
      274, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str41)),
      261, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str42)),
      278, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str43)),
      274, 1U, (enum symbol_type )4}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str46)),
      265, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str47)),
      274, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str51)),
      274, 1U, (enum symbol_type )5}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str54)),
      267, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str56)),
      273, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str72)),
      271, 1U, 0U}};
#line 143 "scripts/kconfig/zconf.gperf"
__inline static struct kconf_id  const __attribute__((__gnu_inline__)) *kconf_id_lookup(char const   *str ,
                                                                                        unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int o ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 30
  if (len <= 14U) {
#line 30
    if (len >= 2U) {
      {
#line 32
      tmp = kconf_id_hash(str, len);
#line 32
      key = (int )tmp;
      }
#line 34
      if (key <= 72) {
#line 34
        if (key >= 0) {
#line 36
          o = (int )wordlist[key].name;
#line 37
          if (o >= 0) {
#line 39
            s = (char const   *)(& kconf_id_strings_contents) + o;
#line 41
            if ((int const   )*str == (int const   )*s) {
              {
#line 41
              tmp___0 = strncmp(str + 1, s + 1, (size_t )(len - 1U));
              }
#line 41
              if (! tmp___0) {
#line 41
                if ((int const   )*(s + len) == 0) {
#line 42
                  return ((struct kconf_id  const __attribute__((__gnu_inline__)) *)(& wordlist[key]));
                }
              }
            }
          }
        }
      }
    }
  }
#line 46
  return ((struct kconf_id  const __attribute__((__gnu_inline__)) *)0);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yytranslate[295]  = 
#line 452 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39};
#line 489 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint16 const   yyprhs[123]  = 
#line 489
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )6, 
        (yytype_uint16 const   )8,      (yytype_uint16 const   )11,      (yytype_uint16 const   )13,      (yytype_uint16 const   )14, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )20,      (yytype_uint16 const   )23,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )31,      (yytype_uint16 const   )36,      (yytype_uint16 const   )40,      (yytype_uint16 const   )42, 
        (yytype_uint16 const   )44,      (yytype_uint16 const   )46,      (yytype_uint16 const   )48,      (yytype_uint16 const   )50, 
        (yytype_uint16 const   )52,      (yytype_uint16 const   )54,      (yytype_uint16 const   )56,      (yytype_uint16 const   )58, 
        (yytype_uint16 const   )60,      (yytype_uint16 const   )62,      (yytype_uint16 const   )64,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )72,      (yytype_uint16 const   )75,      (yytype_uint16 const   )79, 
        (yytype_uint16 const   )82,      (yytype_uint16 const   )86,      (yytype_uint16 const   )89,      (yytype_uint16 const   )90, 
        (yytype_uint16 const   )93,      (yytype_uint16 const   )96,      (yytype_uint16 const   )99,      (yytype_uint16 const   )102, 
        (yytype_uint16 const   )105,      (yytype_uint16 const   )108,      (yytype_uint16 const   )112,      (yytype_uint16 const   )117, 
        (yytype_uint16 const   )122,      (yytype_uint16 const   )127,      (yytype_uint16 const   )133,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )142,      (yytype_uint16 const   )143,      (yytype_uint16 const   )146, 
        (yytype_uint16 const   )150,      (yytype_uint16 const   )153,      (yytype_uint16 const   )155,      (yytype_uint16 const   )159, 
        (yytype_uint16 const   )160,      (yytype_uint16 const   )163,      (yytype_uint16 const   )166,      (yytype_uint16 const   )169, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )175,      (yytype_uint16 const   )180,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )192,      (yytype_uint16 const   )193,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )202,      (yytype_uint16 const   )206,      (yytype_uint16 const   )207, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )213,      (yytype_uint16 const   )216,      (yytype_uint16 const   )220, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )228,      (yytype_uint16 const   )230,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )238,      (yytype_uint16 const   )241,      (yytype_uint16 const   )244, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )252,      (yytype_uint16 const   )255,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )262,      (yytype_uint16 const   )265,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277,      (yytype_uint16 const   )280, 
        (yytype_uint16 const   )283,      (yytype_uint16 const   )286,      (yytype_uint16 const   )287,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )292,      (yytype_uint16 const   )294,      (yytype_uint16 const   )297,      (yytype_uint16 const   )300, 
        (yytype_uint16 const   )303,      (yytype_uint16 const   )305,      (yytype_uint16 const   )308,      (yytype_uint16 const   )309, 
        (yytype_uint16 const   )312,      (yytype_uint16 const   )314,      (yytype_uint16 const   )318,      (yytype_uint16 const   )322, 
        (yytype_uint16 const   )326,      (yytype_uint16 const   )330,      (yytype_uint16 const   )334,      (yytype_uint16 const   )338, 
        (yytype_uint16 const   )342,      (yytype_uint16 const   )345,      (yytype_uint16 const   )349,      (yytype_uint16 const   )353, 
        (yytype_uint16 const   )355,      (yytype_uint16 const   )357,      (yytype_uint16 const   )358};
#line 507 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_int8 const   yyrhs[360]  = 
#line 507
  {      (yytype_int8 const   )41,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )85, 
        (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )67,      (yytype_int8 const   )43,      (yytype_int8 const   )-1,      (yytype_int8 const   )43, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )43,      (yytype_int8 const   )45, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )43,      (yytype_int8 const   )59,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )43,      (yytype_int8 const   )71,      (yytype_int8 const   )-1,      (yytype_int8 const   )43, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )43,      (yytype_int8 const   )26, 
        (yytype_int8 const   )1,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )43, 
        (yytype_int8 const   )44,      (yytype_int8 const   )1,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )43,      (yytype_int8 const   )1,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )18,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-1,      (yytype_int8 const   )23,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )65,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )48,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )50,      (yytype_int8 const   )-1,      (yytype_int8 const   )73,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )26,      (yytype_int8 const   )1,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )1,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )10, 
        (yytype_int8 const   )26,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )47, 
        (yytype_int8 const   )51,      (yytype_int8 const   )-1,      (yytype_int8 const   )11,      (yytype_int8 const   )26, 
        (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )49,      (yytype_int8 const   )51, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )52, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )53,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )51,      (yytype_int8 const   )79,      (yytype_int8 const   )-1,      (yytype_int8 const   )51, 
        (yytype_int8 const   )77,      (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )46, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )82,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )18,      (yytype_int8 const   )83,      (yytype_int8 const   )86,      (yytype_int8 const   )35, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )20,      (yytype_int8 const   )87,      (yytype_int8 const   )86, 
        (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )26, 
        (yytype_int8 const   )86,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )22, 
        (yytype_int8 const   )88,      (yytype_int8 const   )88,      (yytype_int8 const   )86,      (yytype_int8 const   )35, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )54,      (yytype_int8 const   )35, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )54,      (yytype_int8 const   )26, 
        (yytype_int8 const   )55,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )38, 
        (yytype_int8 const   )83,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )89, 
        (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )60, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )57, 
        (yytype_int8 const   )62,      (yytype_int8 const   )58,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )60,      (yytype_int8 const   )61,      (yytype_int8 const   )-1,      (yytype_int8 const   )60, 
        (yytype_int8 const   )79,      (yytype_int8 const   )-1,      (yytype_int8 const   )60,      (yytype_int8 const   )77, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )60,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )60,      (yytype_int8 const   )46,      (yytype_int8 const   )-1,      (yytype_int8 const   )18, 
        (yytype_int8 const   )83,      (yytype_int8 const   )86,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )82,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )86,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )45,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )14,      (yytype_int8 const   )87,      (yytype_int8 const   )85,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )63,      (yytype_int8 const   )66, 
        (yytype_int8 const   )64,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )66, 
        (yytype_int8 const   )45,      (yytype_int8 const   )-1,      (yytype_int8 const   )66,      (yytype_int8 const   )71, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )66,      (yytype_int8 const   )59,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )3,      (yytype_int8 const   )83,      (yytype_int8 const   )85,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )4,      (yytype_int8 const   )83,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )68,      (yytype_int8 const   )80,      (yytype_int8 const   )78,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )69,      (yytype_int8 const   )72, 
        (yytype_int8 const   )70,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )72, 
        (yytype_int8 const   )45,      (yytype_int8 const   )-1,      (yytype_int8 const   )72,      (yytype_int8 const   )71, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )72,      (yytype_int8 const   )59,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )6,      (yytype_int8 const   )83,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )9,      (yytype_int8 const   )83,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )74,      (yytype_int8 const   )78,      (yytype_int8 const   )-1,      (yytype_int8 const   )12, 
        (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )76,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )78,      (yytype_int8 const   )79, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )78,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )78,      (yytype_int8 const   )46,      (yytype_int8 const   )-1,      (yytype_int8 const   )16, 
        (yytype_int8 const   )25,      (yytype_int8 const   )87,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )80,      (yytype_int8 const   )81,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )80,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )23, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )83, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )27,      (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )35, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )8,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )15,      (yytype_int8 const   )35,      (yytype_int8 const   )-1,      (yytype_int8 const   )35, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )85,      (yytype_int8 const   )35,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )87,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )29, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )30, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )31, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )32, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )38, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )88,      (yytype_int8 const   )28, 
        (yytype_int8 const   )88,      (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )87, 
        (yytype_int8 const   )33,      (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )87, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )87,      (yytype_int8 const   )36,      (yytype_int8 const   )87, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )87,      (yytype_int8 const   )37,      (yytype_int8 const   )87, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1};
#line 548 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint16 const   yyrline[123]  = 
#line 548
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )108,      (yytype_uint16 const   )108,      (yytype_uint16 const   )108, 
        (yytype_uint16 const   )110,      (yytype_uint16 const   )110,      (yytype_uint16 const   )112,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )115,      (yytype_uint16 const   )116,      (yytype_uint16 const   )117,      (yytype_uint16 const   )118, 
        (yytype_uint16 const   )119,      (yytype_uint16 const   )123,      (yytype_uint16 const   )127,      (yytype_uint16 const   )127, 
        (yytype_uint16 const   )127,      (yytype_uint16 const   )127,      (yytype_uint16 const   )127,      (yytype_uint16 const   )127, 
        (yytype_uint16 const   )127,      (yytype_uint16 const   )127,      (yytype_uint16 const   )131,      (yytype_uint16 const   )132, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )134,      (yytype_uint16 const   )135,      (yytype_uint16 const   )136, 
        (yytype_uint16 const   )140,      (yytype_uint16 const   )141,      (yytype_uint16 const   )147,      (yytype_uint16 const   )155, 
        (yytype_uint16 const   )161,      (yytype_uint16 const   )169,      (yytype_uint16 const   )179,      (yytype_uint16 const   )181, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )183,      (yytype_uint16 const   )184,      (yytype_uint16 const   )185, 
        (yytype_uint16 const   )186,      (yytype_uint16 const   )189,      (yytype_uint16 const   )197,      (yytype_uint16 const   )203, 
        (yytype_uint16 const   )213,      (yytype_uint16 const   )219,      (yytype_uint16 const   )225,      (yytype_uint16 const   )228, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )241,      (yytype_uint16 const   )242,      (yytype_uint16 const   )247, 
        (yytype_uint16 const   )256,      (yytype_uint16 const   )261,      (yytype_uint16 const   )269,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )274,      (yytype_uint16 const   )275,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )281,      (yytype_uint16 const   )287,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )304,      (yytype_uint16 const   )314,      (yytype_uint16 const   )316,      (yytype_uint16 const   )321, 
        (yytype_uint16 const   )329,      (yytype_uint16 const   )337,      (yytype_uint16 const   )340,      (yytype_uint16 const   )342, 
        (yytype_uint16 const   )343,      (yytype_uint16 const   )344,      (yytype_uint16 const   )349,      (yytype_uint16 const   )356, 
        (yytype_uint16 const   )363,      (yytype_uint16 const   )368,      (yytype_uint16 const   )376,      (yytype_uint16 const   )379, 
        (yytype_uint16 const   )381,      (yytype_uint16 const   )382,      (yytype_uint16 const   )383,      (yytype_uint16 const   )386, 
        (yytype_uint16 const   )394,      (yytype_uint16 const   )401,      (yytype_uint16 const   )408,      (yytype_uint16 const   )414, 
        (yytype_uint16 const   )421,      (yytype_uint16 const   )423,      (yytype_uint16 const   )424,      (yytype_uint16 const   )425, 
        (yytype_uint16 const   )428,      (yytype_uint16 const   )436,      (yytype_uint16 const   )438,      (yytype_uint16 const   )439, 
        (yytype_uint16 const   )442,      (yytype_uint16 const   )449,      (yytype_uint16 const   )451,      (yytype_uint16 const   )456, 
        (yytype_uint16 const   )457,      (yytype_uint16 const   )460,      (yytype_uint16 const   )461,      (yytype_uint16 const   )462, 
        (yytype_uint16 const   )466,      (yytype_uint16 const   )467,      (yytype_uint16 const   )470,      (yytype_uint16 const   )471, 
        (yytype_uint16 const   )474,      (yytype_uint16 const   )475,      (yytype_uint16 const   )476,      (yytype_uint16 const   )477, 
        (yytype_uint16 const   )478,      (yytype_uint16 const   )479,      (yytype_uint16 const   )480,      (yytype_uint16 const   )481, 
        (yytype_uint16 const   )482,      (yytype_uint16 const   )483,      (yytype_uint16 const   )484,      (yytype_uint16 const   )487, 
        (yytype_uint16 const   )488,      (yytype_uint16 const   )491,      (yytype_uint16 const   )492};
#line 569 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static char const   * const  yytname[91]  = 
#line 569
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"T_MAINMENU", 
        (char const   */* const  */)"T_MENU",      (char const   */* const  */)"T_ENDMENU",      (char const   */* const  */)"T_SOURCE",      (char const   */* const  */)"T_CHOICE", 
        (char const   */* const  */)"T_ENDCHOICE",      (char const   */* const  */)"T_COMMENT",      (char const   */* const  */)"T_CONFIG",      (char const   */* const  */)"T_MENUCONFIG", 
        (char const   */* const  */)"T_HELP",      (char const   */* const  */)"T_HELPTEXT",      (char const   */* const  */)"T_IF",      (char const   */* const  */)"T_ENDIF", 
        (char const   */* const  */)"T_DEPENDS",      (char const   */* const  */)"T_OPTIONAL",      (char const   */* const  */)"T_PROMPT",      (char const   */* const  */)"T_TYPE", 
        (char const   */* const  */)"T_DEFAULT",      (char const   */* const  */)"T_SELECT",      (char const   */* const  */)"T_RANGE",      (char const   */* const  */)"T_VISIBLE", 
        (char const   */* const  */)"T_OPTION",      (char const   */* const  */)"T_ON",      (char const   */* const  */)"T_WORD",      (char const   */* const  */)"T_WORD_QUOTE", 
        (char const   */* const  */)"T_UNEQUAL",      (char const   */* const  */)"T_LESS",      (char const   */* const  */)"T_LESS_EQUAL",      (char const   */* const  */)"T_GREATER", 
        (char const   */* const  */)"T_GREATER_EQUAL",      (char const   */* const  */)"T_CLOSE_PAREN",      (char const   */* const  */)"T_OPEN_PAREN",      (char const   */* const  */)"T_EOL", 
        (char const   */* const  */)"T_OR",      (char const   */* const  */)"T_AND",      (char const   */* const  */)"T_EQUAL",      (char const   */* const  */)"T_NOT", 
        (char const   */* const  */)"$accept",      (char const   */* const  */)"input",      (char const   */* const  */)"start",      (char const   */* const  */)"stmt_list", 
        (char const   */* const  */)"option_name",      (char const   */* const  */)"common_stmt",      (char const   */* const  */)"option_error",      (char const   */* const  */)"config_entry_start", 
        (char const   */* const  */)"config_stmt",      (char const   */* const  */)"menuconfig_entry_start",      (char const   */* const  */)"menuconfig_stmt",      (char const   */* const  */)"config_option_list", 
        (char const   */* const  */)"config_option",      (char const   */* const  */)"symbol_option",      (char const   */* const  */)"symbol_option_list",      (char const   */* const  */)"symbol_option_arg", 
        (char const   */* const  */)"choice",      (char const   */* const  */)"choice_entry",      (char const   */* const  */)"choice_end",      (char const   */* const  */)"choice_stmt", 
        (char const   */* const  */)"choice_option_list",      (char const   */* const  */)"choice_option",      (char const   */* const  */)"choice_block",      (char const   */* const  */)"if_entry", 
        (char const   */* const  */)"if_end",      (char const   */* const  */)"if_stmt",      (char const   */* const  */)"if_block",      (char const   */* const  */)"mainmenu_stmt", 
        (char const   */* const  */)"menu",      (char const   */* const  */)"menu_entry",      (char const   */* const  */)"menu_end",      (char const   */* const  */)"menu_stmt", 
        (char const   */* const  */)"menu_block",      (char const   */* const  */)"source_stmt",      (char const   */* const  */)"comment",      (char const   */* const  */)"comment_stmt", 
        (char const   */* const  */)"help_start",      (char const   */* const  */)"help",      (char const   */* const  */)"depends_list",      (char const   */* const  */)"depends", 
        (char const   */* const  */)"visibility_list",      (char const   */* const  */)"visible",      (char const   */* const  */)"prompt_stmt_opt",      (char const   */* const  */)"prompt", 
        (char const   */* const  */)"end",      (char const   */* const  */)"nl",      (char const   */* const  */)"if_expr",      (char const   */* const  */)"expr", 
        (char const   */* const  */)"symbol",      (char const   */* const  */)"word_opt",      (char const   */* const  */)0};
#line 605 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yyr1[123]  = 
#line 605
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )72,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )89};
#line 623 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yyr2[123]  = 
#line 623
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 643 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yydefact[199]  = 
#line 643
  {      (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )104,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )34,      (yytype_uint8 const   )26,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )8,      (yytype_uint8 const   )70,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )79,      (yytype_uint8 const   )9,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )24,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )2,      (yytype_uint8 const   )74,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )102,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )119,      (yytype_uint8 const   )120,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )108,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )75,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )84,      (yytype_uint8 const   )30,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )116,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )58,      (yytype_uint8 const   )57,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )72,      (yytype_uint8 const   )68,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )0,      (yytype_uint8 const   )94,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )78,      (yytype_uint8 const   )81,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )89,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )117,      (yytype_uint8 const   )118,      (yytype_uint8 const   )114,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )112,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )86,      (yytype_uint8 const   )0,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )96,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )49,      (yytype_uint8 const   )46,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )48,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )45,      (yytype_uint8 const   )50};
#line 668 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yydefgoto[50]  = 
#line 668
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )112,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )74, 
        (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )165,      (yytype_int16 const   )194, 
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )128,      (yytype_int16 const   )41, 
        (yytype_int16 const   )76,      (yytype_int16 const   )124,      (yytype_int16 const   )77,      (yytype_int16 const   )42, 
        (yytype_int16 const   )132,      (yytype_int16 const   )43,      (yytype_int16 const   )78,      (yytype_int16 const   )6, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )141,      (yytype_int16 const   )46, 
        (yytype_int16 const   )80,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )115,      (yytype_int16 const   )116,      (yytype_int16 const   )81,      (yytype_int16 const   )117, 
        (yytype_int16 const   )79,      (yytype_int16 const   )138,      (yytype_int16 const   )160,      (yytype_int16 const   )161, 
        (yytype_int16 const   )50,      (yytype_int16 const   )7,      (yytype_int16 const   )173,      (yytype_int16 const   )69, 
        (yytype_int16 const   )70,      (yytype_int16 const   )60};
#line 680 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yypact[199]  = 
#line 680
  {      (yytype_int16 const   )19,      (yytype_int16 const   )37,      (yytype_int16 const   )-91,      (yytype_int16 const   )13, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )79,      (yytype_int16 const   )-91,      (yytype_int16 const   )20, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-16,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )21,      (yytype_int16 const   )37,      (yytype_int16 const   )25,      (yytype_int16 const   )37, 
        (yytype_int16 const   )41,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )78, 
        (yytype_int16 const   )83,      (yytype_int16 const   )31,      (yytype_int16 const   )56,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )116, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )127,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )147, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )105,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )109,      (yytype_int16 const   )-91,      (yytype_int16 const   )111,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )114,      (yytype_int16 const   )-91,      (yytype_int16 const   )136,      (yytype_int16 const   )137, 
        (yytype_int16 const   )142,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )76,      (yytype_int16 const   )254,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )143,      (yytype_int16 const   )146,      (yytype_int16 const   )27,      (yytype_int16 const   )115, 
        (yytype_int16 const   )207,      (yytype_int16 const   )258,      (yytype_int16 const   )243,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )243,      (yytype_int16 const   )179,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-7,      (yytype_int16 const   )-91,      (yytype_int16 const   )31,      (yytype_int16 const   )31, 
        (yytype_int16 const   )105,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )51,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )156,      (yytype_int16 const   )168,      (yytype_int16 const   )181, 
        (yytype_int16 const   )37,      (yytype_int16 const   )37,      (yytype_int16 const   )31,      (yytype_int16 const   )178, 
        (yytype_int16 const   )51,      (yytype_int16 const   )-91,      (yytype_int16 const   )206,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )196, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )175,      (yytype_int16 const   )37, 
        (yytype_int16 const   )37,      (yytype_int16 const   )185,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )214, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )230,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )183,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )31,      (yytype_int16 const   )214, 
        (yytype_int16 const   )194,      (yytype_int16 const   )214,      (yytype_int16 const   )45,      (yytype_int16 const   )214, 
        (yytype_int16 const   )51,      (yytype_int16 const   )26,      (yytype_int16 const   )195,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )214,      (yytype_int16 const   )197,      (yytype_int16 const   )214, 
        (yytype_int16 const   )31,      (yytype_int16 const   )-91,      (yytype_int16 const   )139,      (yytype_int16 const   )208, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )220,      (yytype_int16 const   )224, 
        (yytype_int16 const   )214,      (yytype_int16 const   )222,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )226,      (yytype_int16 const   )-91,      (yytype_int16 const   )227,      (yytype_int16 const   )123, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )235,      (yytype_int16 const   )37,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91};
#line 705 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yypgoto[50]  = 
#line 705
  {      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )264,      (yytype_int16 const   )268, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )30,      (yytype_int16 const   )-65,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )238, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-12, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )-91, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )200,      (yytype_int16 const   )209,      (yytype_int16 const   )-61, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-91,      (yytype_int16 const   )170,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )65,      (yytype_int16 const   )0,      (yytype_int16 const   )118,      (yytype_int16 const   )-66, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-91};
#line 718 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yytable[299]  = 
#line 718
  {      (yytype_int16 const   )10,      (yytype_int16 const   )88,      (yytype_int16 const   )89,      (yytype_int16 const   )150, 
        (yytype_int16 const   )151,      (yytype_int16 const   )152,      (yytype_int16 const   )153,      (yytype_int16 const   )154, 
        (yytype_int16 const   )155,      (yytype_int16 const   )135,      (yytype_int16 const   )54,      (yytype_int16 const   )123, 
        (yytype_int16 const   )56,      (yytype_int16 const   )11,      (yytype_int16 const   )58,      (yytype_int16 const   )126, 
        (yytype_int16 const   )145,      (yytype_int16 const   )62,      (yytype_int16 const   )164,      (yytype_int16 const   )2, 
        (yytype_int16 const   )146,      (yytype_int16 const   )136,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )148,      (yytype_int16 const   )149,      (yytype_int16 const   )147,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )101,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )102, 
        (yytype_int16 const   )162,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )103, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )106, 
        (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )-31,      (yytype_int16 const   )109, 
        (yytype_int16 const   )181,      (yytype_int16 const   )110,      (yytype_int16 const   )2,      (yytype_int16 const   )52, 
        (yytype_int16 const   )55,      (yytype_int16 const   )65,      (yytype_int16 const   )66,      (yytype_int16 const   )172, 
        (yytype_int16 const   )57,      (yytype_int16 const   )182,      (yytype_int16 const   )111,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )67,      (yytype_int16 const   )131,      (yytype_int16 const   )59, 
        (yytype_int16 const   )140,      (yytype_int16 const   )92,      (yytype_int16 const   )68,      (yytype_int16 const   )61, 
        (yytype_int16 const   )145,      (yytype_int16 const   )133,      (yytype_int16 const   )180,      (yytype_int16 const   )142, 
        (yytype_int16 const   )146,      (yytype_int16 const   )65,      (yytype_int16 const   )66,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )12,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )71, 
        (yytype_int16 const   )174,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )159, 
        (yytype_int16 const   )63,      (yytype_int16 const   )31,      (yytype_int16 const   )187,      (yytype_int16 const   )127, 
        (yytype_int16 const   )130,      (yytype_int16 const   )64,      (yytype_int16 const   )139,      (yytype_int16 const   )2, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )32,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )101,      (yytype_int16 const   )72,      (yytype_int16 const   )169,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )102, 
        (yytype_int16 const   )73,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )103, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )104,      (yytype_int16 const   )105,      (yytype_int16 const   )106, 
        (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )-33,      (yytype_int16 const   )109, 
        (yytype_int16 const   )52,      (yytype_int16 const   )110,      (yytype_int16 const   )129,      (yytype_int16 const   )134, 
        (yytype_int16 const   )82,      (yytype_int16 const   )143,      (yytype_int16 const   )83,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )12,      (yytype_int16 const   )84,      (yytype_int16 const   )111,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )85, 
        (yytype_int16 const   )86,      (yytype_int16 const   )31,      (yytype_int16 const   )188,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )87,      (yytype_int16 const   )99,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )101,      (yytype_int16 const   )100,      (yytype_int16 const   )32,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )156, 
        (yytype_int16 const   )198,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )103, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )157, 
        (yytype_int16 const   )163,      (yytype_int16 const   )110,      (yytype_int16 const   )158,      (yytype_int16 const   )166, 
        (yytype_int16 const   )101,      (yytype_int16 const   )167,      (yytype_int16 const   )168,      (yytype_int16 const   )171, 
        (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )144,      (yytype_int16 const   )-52, 
        (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )102, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )103, 
        (yytype_int16 const   )118,      (yytype_int16 const   )119,      (yytype_int16 const   )120,      (yytype_int16 const   )121, 
        (yytype_int16 const   )172,      (yytype_int16 const   )176,      (yytype_int16 const   )183,      (yytype_int16 const   )101, 
        (yytype_int16 const   )185,      (yytype_int16 const   )110,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )122,      (yytype_int16 const   )189, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )103,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )190, 
        (yytype_int16 const   )110,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )191, 
        (yytype_int16 const   )193,      (yytype_int16 const   )195,      (yytype_int16 const   )196,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )144,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )197,      (yytype_int16 const   )53, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )51,      (yytype_int16 const   )75, 
        (yytype_int16 const   )125,      (yytype_int16 const   )175,      (yytype_int16 const   )32,      (yytype_int16 const   )177, 
        (yytype_int16 const   )178,      (yytype_int16 const   )179,      (yytype_int16 const   )93,      (yytype_int16 const   )94, 
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )184, 
        (yytype_int16 const   )137,      (yytype_int16 const   )186,      (yytype_int16 const   )170,      (yytype_int16 const   )0, 
        (yytype_int16 const   )98,      (yytype_int16 const   )32,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )192};
#line 758 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yycheck[299]  = 
#line 758
  {      (yytype_int16 const   )1,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )93, 
        (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97, 
        (yytype_int16 const   )98,      (yytype_int16 const   )23,      (yytype_int16 const   )10,      (yytype_int16 const   )76, 
        (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )15,      (yytype_int16 const   )76, 
        (yytype_int16 const   )81,      (yytype_int16 const   )18,      (yytype_int16 const   )108,      (yytype_int16 const   )35, 
        (yytype_int16 const   )81,      (yytype_int16 const   )35,      (yytype_int16 const   )3,      (yytype_int16 const   )3, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )33,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )106,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )35,      (yytype_int16 const   )35, 
        (yytype_int16 const   )35,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )14, 
        (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )34,      (yytype_int16 const   )78,      (yytype_int16 const   )26, 
        (yytype_int16 const   )80,      (yytype_int16 const   )69,      (yytype_int16 const   )39,      (yytype_int16 const   )35, 
        (yytype_int16 const   )137,      (yytype_int16 const   )78,      (yytype_int16 const   )164,      (yytype_int16 const   )80, 
        (yytype_int16 const   )137,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )35, 
        (yytype_int16 const   )158,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )104, 
        (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )172,      (yytype_int16 const   )77, 
        (yytype_int16 const   )78,      (yytype_int16 const   )26,      (yytype_int16 const   )80,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )35,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )119,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )1,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )35,      (yytype_int16 const   )26,      (yytype_int16 const   )77,      (yytype_int16 const   )78, 
        (yytype_int16 const   )35,      (yytype_int16 const   )80,      (yytype_int16 const   )35,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )35, 
        (yytype_int16 const   )35,      (yytype_int16 const   )26,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )35, 
        (yytype_int16 const   )193,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )35, 
        (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )25,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )13,      (yytype_int16 const   )35,      (yytype_int16 const   )26, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )35,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )37,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )14,      (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )1, 
        (yytype_int16 const   )35,      (yytype_int16 const   )26,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )35,      (yytype_int16 const   )35, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )35, 
        (yytype_int16 const   )26,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )35, 
        (yytype_int16 const   )38,      (yytype_int16 const   )35,      (yytype_int16 const   )35,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )35,      (yytype_int16 const   )8,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )35,      (yytype_int16 const   )7, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )6,      (yytype_int16 const   )37, 
        (yytype_int16 const   )76,      (yytype_int16 const   )159,      (yytype_int16 const   )35,      (yytype_int16 const   )161, 
        (yytype_int16 const   )162,      (yytype_int16 const   )163,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )169, 
        (yytype_int16 const   )79,      (yytype_int16 const   )171,      (yytype_int16 const   )120,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )38,      (yytype_int16 const   )35,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )180};
#line 794 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yystos[199]  = 
#line 794
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )35,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )67,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )83,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )59,      (yytype_uint8 const   )63,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )71,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )84,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )42,      (yytype_uint8 const   )85,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )35,      (yytype_uint8 const   )83,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )35,      (yytype_uint8 const   )83,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )62,      (yytype_uint8 const   )66,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )78,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )38,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )1,      (yytype_uint8 const   )12,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )79,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )35,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )77,      (yytype_uint8 const   )79,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )84,      (yytype_uint8 const   )45,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )71,      (yytype_uint8 const   )84,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )78,      (yytype_uint8 const   )81,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )46,      (yytype_uint8 const   )79,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )25,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )87,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )54,      (yytype_uint8 const   )1,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )83,      (yytype_uint8 const   )82,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )86,      (yytype_uint8 const   )86,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )26,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )35,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )38,      (yytype_uint8 const   )55,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )83};
#line 941 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 
  FILE *yyo ;

  {
#line 951
  yyo = yyoutput;
#line 953
  if (! yyvaluep) {
#line 954
    return;
  }
  {
#line 963
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 964
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 966
  return;
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 985
  if (yytype < 40) {
    {
#line 986
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 988
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 990
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 991
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 992
  return;
}
}
#line 1001 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void yy_stack_print(yytype_int16 *yybottom , yytype_int16 *yytop ) 
{ 
  int yybot ;

  {
  {
#line 1010
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 1011
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1011
    if (! ((unsigned long )yybottom <= (unsigned long )yytop)) {
#line 1011
      goto while_break;
    }
    {
#line 1013
    yybot = (int )*yybottom;
#line 1014
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            yybot);
#line 1011
    yybottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1016
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1017
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void yy_reduce_print(YYSTYPE *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;

  {
  {
#line 1041
  yynrhs = (int )yyr2[yyrule];
#line 1043
  yylno = (unsigned long )yyrline[yyrule];
#line 1044
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 1047
  yyi = 0;
  }
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if (! (yyi < yynrhs)) {
#line 1047
      goto while_break;
    }
    {
#line 1049
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 1050
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 1053
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1047
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1055
  return;
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
int zconfdebug  ;
#line 1336 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1348
  if (! yymsg) {
#line 1349
    yymsg = "Deleting";
  }
  {
#line 1350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1350
    if (zconfdebug) {
      {
#line 1350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1350
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep);
#line 1350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1350
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1354
  if (yytype == 57) {
#line 1354
    goto case_57;
  }
#line 1364
  if (yytype == 63) {
#line 1364
    goto case_63;
  }
#line 1374
  if (yytype == 69) {
#line 1374
    goto case_69;
  }
#line 1385
  goto switch_default;
  case_57: /* CIL Label */ 
  {
#line 1357
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1359
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1360
    menu_end_menu();
    }
  }
#line 1363
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 1367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1369
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1370
    menu_end_menu();
    }
  }
#line 1373
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 1377
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1379
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1380
    menu_end_menu();
    }
  }
#line 1383
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1386
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1388
  return;
}
}
#line 1400
int zconfparse(void) ;
#line 1408 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
int zconfchar  ;
#line 1411 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
YYSTYPE zconflval  ;
#line 1414 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
int zconfnerrs  ;
#line 1434 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
int zconfparse(void) 
{ 
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  struct symbol *sym ;
  struct symbol *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  struct symbol *sym___0 ;
  struct symbol *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  struct symbol *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  struct expr *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  struct kconf_id  const  *id ;
  size_t tmp___22 ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___23 ;
  struct symbol *sym___1 ;
  struct symbol *tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  _Bool tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  struct symbol *tmp___36 ;
  int tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  _Bool tmp___43 ;
  int tmp___44 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  _Bool tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;
  int tmp___57 ;

  {
#line 1485
  yylen = 0;
#line 1487
  yytoken = 0;
#line 1488
  yyss = yyssa;
#line 1489
  yyvs = yyvsa;
#line 1490
  yystacksize = 200UL;
  {
#line 1492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1492
    if (zconfdebug) {
      {
#line 1492
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1492
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  yystate = 0;
#line 1495
  yyerrstatus = 0;
#line 1496
  zconfnerrs = 0;
#line 1497
  zconfchar = -2;
#line 1503
  yyssp = yyss;
#line 1504
  yyvsp = yyvs;
#line 1506
  goto yysetstate;
  yynewstate: 
#line 1514
  yyssp ++;
  yysetstate: 
#line 1517
  *yyssp = (yytype_int16 )yystate;
#line 1519
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1522
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1549
    if (10000UL <= yystacksize) {
#line 1550
      goto yyexhaustedlab;
    }
#line 1551
    yystacksize *= 2UL;
#line 1552
    if (10000UL < yystacksize) {
#line 1553
      yystacksize = 10000UL;
    }
    {
#line 1556
    yyss1 = yyss;
#line 1557
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1557
    yyptr = (union yyalloc *)tmp;
    }
#line 1559
    if (! yyptr) {
#line 1560
      goto yyexhaustedlab;
    }
    {
#line 1561
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1561
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1561
      yyss = & yyptr->yyss_alloc;
#line 1561
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1561
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1561
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1562
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1562
      yyvs = & yyptr->yyvs_alloc;
#line 1562
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1562
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1562
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1564
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1565
      free((void *)yyss1);
      }
    }
#line 1570
    yyssp = (yyss + yysize) - 1;
#line 1571
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1573
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1573
      if (zconfdebug) {
        {
#line 1573
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                yystacksize);
        }
      }
#line 1573
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1576
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1577
      goto yyabortlab;
    }
  }
  {
#line 1580
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1580
    if (zconfdebug) {
      {
#line 1580
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1580
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1582
  if (yystate == 11) {
#line 1583
    goto yyacceptlab;
  }
#line 1585
  goto yybackup;
  yybackup: 
#line 1596
  yyn = (int )yypact[yystate];
#line 1597
  if (yyn == -91) {
#line 1598
    goto yydefault;
  }
#line 1603
  if (zconfchar == -2) {
    {
#line 1605
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1605
      if (zconfdebug) {
        {
#line 1605
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1605
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1606
    zconfchar = zconflex();
    }
  }
#line 1609
  if (zconfchar <= 0) {
#line 1611
    yytoken = 0;
#line 1611
    zconfchar = yytoken;
    {
#line 1612
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1612
      if (zconfdebug) {
        {
#line 1612
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1612
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1616
    if ((unsigned int )zconfchar <= 294U) {
#line 1616
      yytoken = (int )yytranslate[zconfchar];
    } else {
#line 1616
      yytoken = 2;
    }
    {
#line 1617
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1617
      if (zconfdebug) {
        {
#line 1617
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1617
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& zconflval));
#line 1617
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1617
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1622
  yyn += yytoken;
#line 1623
  if (yyn < 0) {
#line 1624
    goto yydefault;
  } else
#line 1623
  if (298 < yyn) {
#line 1624
    goto yydefault;
  } else
#line 1623
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1624
    goto yydefault;
  }
#line 1625
  yyn = (int )yytable[yyn];
#line 1626
  if (yyn <= 0) {
#line 1630
    yyn = - yyn;
#line 1631
    goto yyreduce;
  }
#line 1636
  if (yyerrstatus) {
#line 1637
    yyerrstatus --;
  }
  {
#line 1640
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1640
    if (zconfdebug) {
      {
#line 1640
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1640
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& zconflval));
#line 1640
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1640
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1643
  zconfchar = -2;
#line 1645
  yystate = yyn;
#line 1646
  yyvsp ++;
#line 1646
  *yyvsp = zconflval;
#line 1648
  goto yynewstate;
  yydefault: 
#line 1655
  yyn = (int )yydefact[yystate];
#line 1656
  if (yyn == 0) {
#line 1657
    goto yyerrlab;
  }
#line 1658
  goto yyreduce;
  yyreduce: 
#line 1666
  yylen = (int )yyr2[yyn];
#line 1676
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1679
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1679
    if (zconfdebug) {
      {
#line 1679
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1679
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1682
  if (yyn == 10) {
#line 1682
    goto case_10;
  }
#line 1687
  if (yyn == 11) {
#line 1687
    goto case_11;
  }
#line 1692
  if (yyn == 12) {
#line 1692
    goto case_12;
  }
#line 1699
  if (yyn == 13) {
#line 1699
    goto case_13;
  }
#line 1704
  if (yyn == 28) {
#line 1704
    goto case_28;
  }
#line 1709
  if (yyn == 29) {
#line 1709
    goto case_29;
  }
#line 1714
  if (yyn == 30) {
#line 1714
    goto case_30;
  }
#line 1724
  if (yyn == 31) {
#line 1724
    goto case_31;
  }
#line 1732
  if (yyn == 32) {
#line 1732
    goto case_32;
  }
#line 1742
  if (yyn == 33) {
#line 1742
    goto case_33;
  }
#line 1754
  if (yyn == 41) {
#line 1754
    goto case_41;
  }
#line 1764
  if (yyn == 42) {
#line 1764
    goto case_42;
  }
#line 1772
  if (yyn == 43) {
#line 1772
    goto case_43;
  }
#line 1784
  if (yyn == 44) {
#line 1784
    goto case_44;
  }
#line 1792
  if (yyn == 45) {
#line 1792
    goto case_45;
  }
#line 1800
  if (yyn == 48) {
#line 1800
    goto case_48;
  }
#line 1812
  if (yyn == 49) {
#line 1812
    goto case_49;
  }
#line 1817
  if (yyn == 50) {
#line 1817
    goto case_50;
  }
#line 1822
  if (yyn == 51) {
#line 1822
    goto case_51;
  }
#line 1833
  if (yyn == 52) {
#line 1833
    goto case_52;
  }
#line 1840
  if (yyn == 53) {
#line 1840
    goto case_53;
  }
#line 1850
  if (yyn == 61) {
#line 1850
    goto case_61;
  }
#line 1858
  if (yyn == 62) {
#line 1858
    goto case_62;
  }
#line 1871
  if (yyn == 63) {
#line 1871
    goto case_63;
  }
#line 1879
  if (yyn == 64) {
#line 1879
    goto case_64;
  }
#line 1891
  if (yyn == 67) {
#line 1891
    goto case_67;
  }
#line 1901
  if (yyn == 68) {
#line 1901
    goto case_68;
  }
#line 1911
  if (yyn == 74) {
#line 1911
    goto case_74;
  }
#line 1918
  if (yyn == 75) {
#line 1918
    goto case_75;
  }
#line 1927
  if (yyn == 76) {
#line 1927
    goto case_76;
  }
#line 1934
  if (yyn == 77) {
#line 1934
    goto case_77;
  }
#line 1944
  if (yyn == 83) {
#line 1944
    goto case_83;
  }
#line 1952
  if (yyn == 84) {
#line 1952
    goto case_84;
  }
#line 1961
  if (yyn == 85) {
#line 1961
    goto case_85;
  }
#line 1968
  if (yyn == 86) {
#line 1968
    goto case_86;
  }
#line 1976
  if (yyn == 87) {
#line 1976
    goto case_87;
  }
#line 1983
  if (yyn == 92) {
#line 1983
    goto case_92;
  }
#line 1991
  if (yyn == 96) {
#line 1991
    goto case_96;
  }
#line 1998
  if (yyn == 98) {
#line 1998
    goto case_98;
  }
#line 2005
  if (yyn == 101) {
#line 2005
    goto case_101;
  }
#line 2010
  if (yyn == 102) {
#line 2010
    goto case_102;
  }
#line 2015
  if (yyn == 103) {
#line 2015
    goto case_103;
  }
#line 2020
  if (yyn == 106) {
#line 2020
    goto case_106;
  }
#line 2025
  if (yyn == 107) {
#line 2025
    goto case_107;
  }
#line 2030
  if (yyn == 108) {
#line 2030
    goto case_108;
  }
#line 2035
  if (yyn == 109) {
#line 2035
    goto case_109;
  }
#line 2040
  if (yyn == 110) {
#line 2040
    goto case_110;
  }
#line 2045
  if (yyn == 111) {
#line 2045
    goto case_111;
  }
#line 2050
  if (yyn == 112) {
#line 2050
    goto case_112;
  }
#line 2055
  if (yyn == 113) {
#line 2055
    goto case_113;
  }
#line 2060
  if (yyn == 114) {
#line 2060
    goto case_114;
  }
#line 2065
  if (yyn == 115) {
#line 2065
    goto case_115;
  }
#line 2070
  if (yyn == 116) {
#line 2070
    goto case_116;
  }
#line 2075
  if (yyn == 117) {
#line 2075
    goto case_117;
  }
#line 2080
  if (yyn == 118) {
#line 2080
    goto case_118;
  }
#line 2085
  if (yyn == 119) {
#line 2085
    goto case_119;
  }
#line 2090
  if (yyn == 120) {
#line 2090
    goto case_120;
  }
#line 2095
  if (yyn == 121) {
#line 2095
    goto case_121;
  }
#line 2102
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1684
  zconf_error("unexpected end statement");
  }
#line 1685
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1689
  zconf_error("unknown statement \"%s\"", (yyvsp + -2)->string);
  }
#line 1690
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1695
  zconf_error("unexpected option \"%s\"", (char const   *)(& kconf_id_strings_contents) + ((yyvsp + -2)->id)->name);
  }
#line 1697
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1701
  zconf_error("invalid statement");
  }
#line 1702
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 1706
  zconf_error("unknown option \"%s\"", (yyvsp + -2)->string);
  }
#line 1707
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1711
  zconf_error("invalid option");
  }
#line 1712
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 1717
  tmp___0 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1717
  sym = tmp___0;
#line 1718
  sym->flags |= 256;
#line 1719
  menu_add_entry(sym);
  }
#line 1720
  if (cdebug & 2) {
    {
#line 1720
    tmp___1 = zconf_lineno();
#line 1720
    tmp___2 = zconf_curname();
#line 1720
    printf((char const   */* __restrict  */)"%s:%d:config %s\n", tmp___2, tmp___1,
           (yyvsp + -1)->string);
    }
  }
#line 1722
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 1727
  menu_end_entry();
  }
#line 1728
  if (cdebug & 2) {
    {
#line 1728
    tmp___3 = zconf_lineno();
#line 1728
    tmp___4 = zconf_curname();
#line 1728
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___4, tmp___3);
    }
  }
#line 1730
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 1735
  tmp___5 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1735
  sym___0 = tmp___5;
#line 1736
  sym___0->flags |= 256;
#line 1737
  menu_add_entry(sym___0);
  }
#line 1738
  if (cdebug & 2) {
    {
#line 1738
    tmp___6 = zconf_lineno();
#line 1738
    tmp___7 = zconf_curname();
#line 1738
    printf((char const   */* __restrict  */)"%s:%d:menuconfig %s\n", tmp___7, tmp___6,
           (yyvsp + -1)->string);
    }
  }
#line 1740
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1745
  if (current_entry->prompt) {
#line 1746
    (current_entry->prompt)->type = (enum prop_type )3;
  } else {
    {
#line 1748
    zconfprint("warning: menuconfig statement without prompt");
    }
  }
  {
#line 1749
  menu_end_entry();
  }
#line 1750
  if (cdebug & 2) {
    {
#line 1750
    tmp___8 = zconf_lineno();
#line 1750
    tmp___9 = zconf_curname();
#line 1750
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___9, tmp___8);
    }
  }
#line 1752
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1757
  menu_set_type((int )((yyvsp + -2)->id)->stype);
  }
#line 1758
  if (cdebug & 2) {
    {
#line 1758
    tmp___10 = zconf_lineno();
#line 1758
    tmp___11 = zconf_curname();
#line 1758
    printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___11, tmp___10,
           (unsigned int const   )((yyvsp + -2)->id)->stype);
    }
  }
#line 1762
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1767
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1768
  if (cdebug & 2) {
    {
#line 1768
    tmp___12 = zconf_lineno();
#line 1768
    tmp___13 = zconf_curname();
#line 1768
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___13, tmp___12);
    }
  }
#line 1770
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1775
  menu_add_expr((enum prop_type )4, (yyvsp + -2)->expr, (yyvsp + -1)->expr);
  }
#line 1776
  if ((unsigned int const   )((yyvsp + -3)->id)->stype != 0U) {
    {
#line 1777
    menu_set_type((int )((yyvsp + -3)->id)->stype);
    }
  }
#line 1778
  if (cdebug & 2) {
    {
#line 1778
    tmp___14 = zconf_lineno();
#line 1778
    tmp___15 = zconf_curname();
#line 1778
    printf((char const   */* __restrict  */)"%s:%d:default(%u)\n", tmp___15, tmp___14,
           (unsigned int const   )((yyvsp + -3)->id)->stype);
    }
  }
#line 1782
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 1787
  tmp___16 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1787
  menu_add_symbol((enum prop_type )6, tmp___16, (yyvsp + -1)->expr);
  }
#line 1788
  if (cdebug & 2) {
    {
#line 1788
    tmp___17 = zconf_lineno();
#line 1788
    tmp___18 = zconf_curname();
#line 1788
    printf((char const   */* __restrict  */)"%s:%d:select\n", tmp___18, tmp___17);
    }
  }
#line 1790
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 1795
  tmp___19 = expr_alloc_comp((enum expr_type )12, (yyvsp + -3)->symbol, (yyvsp + -2)->symbol);
#line 1795
  menu_add_expr((enum prop_type )7, tmp___19, (yyvsp + -1)->expr);
  }
#line 1796
  if (cdebug & 2) {
    {
#line 1796
    tmp___20 = zconf_lineno();
#line 1796
    tmp___21 = zconf_curname();
#line 1796
    printf((char const   */* __restrict  */)"%s:%d:range\n", tmp___21, tmp___20);
    }
  }
#line 1798
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1803
  tmp___22 = strlen((char const   *)(yyvsp + -1)->string);
#line 1803
  tmp___23 = kconf_id_lookup((char const   *)(yyvsp + -1)->string, (unsigned int )tmp___22);
#line 1803
  id = (struct kconf_id  const  *)tmp___23;
  }
#line 1804
  if (id) {
#line 1804
    if (id->flags & 4U) {
      {
#line 1805
      menu_add_option((int )id->token, (yyvsp + 0)->string);
      }
    } else {
      {
#line 1807
      zconfprint("warning: ignoring unknown option %s", (yyvsp + -1)->string);
      }
    }
  } else {
    {
#line 1807
    zconfprint("warning: ignoring unknown option %s", (yyvsp + -1)->string);
    }
  }
  {
#line 1808
  free((void *)(yyvsp + -1)->string);
  }
#line 1810
  goto switch_break;
  case_49: /* CIL Label */ 
#line 1814
  yyval.string = (char *)((void *)0);
#line 1815
  goto switch_break;
  case_50: /* CIL Label */ 
#line 1819
  yyval.string = (yyvsp + 0)->string;
#line 1820
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 1825
  tmp___24 = sym_lookup((char const   *)(yyvsp + -1)->string, 16);
#line 1825
  sym___1 = tmp___24;
#line 1826
  sym___1->flags |= 4096;
#line 1827
  menu_add_entry(sym___1);
#line 1828
  menu_add_expr((enum prop_type )5, (struct expr *)((void *)0), (struct expr *)((void *)0));
  }
#line 1829
  if (cdebug & 2) {
    {
#line 1829
    tmp___25 = zconf_lineno();
#line 1829
    tmp___26 = zconf_curname();
#line 1829
    printf((char const   */* __restrict  */)"%s:%d:choice\n", tmp___26, tmp___25);
    }
  }
#line 1831
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 1836
  yyval.menu = menu_add_menu();
  }
#line 1838
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 1843
  tmp___29 = zconf_endtoken((yyvsp + 0)->id, 262, 263);
  }
#line 1843
  if (tmp___29) {
    {
#line 1844
    menu_end_menu();
    }
#line 1845
    if (cdebug & 2) {
      {
#line 1845
      tmp___27 = zconf_lineno();
#line 1845
      tmp___28 = zconf_curname();
#line 1845
      printf((char const   */* __restrict  */)"%s:%d:endchoice\n", tmp___28, tmp___27);
      }
    }
  }
#line 1848
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 1853
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1854
  if (cdebug & 2) {
    {
#line 1854
    tmp___30 = zconf_lineno();
#line 1854
    tmp___31 = zconf_curname();
#line 1854
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___31, tmp___30);
    }
  }
#line 1856
  goto switch_break;
  case_62: /* CIL Label */ 
#line 1861
  if ((unsigned int const   )((yyvsp + -2)->id)->stype == 1U) {
#line 1861
    goto _L;
  } else
#line 1861
  if ((unsigned int const   )((yyvsp + -2)->id)->stype == 2U) {
    _L: /* CIL Label */ 
    {
#line 1862
    menu_set_type((int )((yyvsp + -2)->id)->stype);
    }
#line 1863
    if (cdebug & 2) {
      {
#line 1863
      tmp___32 = zconf_lineno();
#line 1863
      tmp___33 = zconf_curname();
#line 1863
      printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___33, tmp___32,
             (unsigned int const   )((yyvsp + -2)->id)->stype);
      }
    }
  } else {
#line 1867
    goto yyerrorlab;
  }
#line 1869
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1874
  (current_entry->sym)->flags |= 256;
#line 1875
  if (cdebug & 2) {
    {
#line 1875
    tmp___34 = zconf_lineno();
#line 1875
    tmp___35 = zconf_curname();
#line 1875
    printf((char const   */* __restrict  */)"%s:%d:optional\n", tmp___35, tmp___34);
    }
  }
#line 1877
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1882
  if ((unsigned int const   )((yyvsp + -3)->id)->stype == 0U) {
    {
#line 1883
    tmp___36 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1883
    menu_add_symbol((enum prop_type )4, tmp___36, (yyvsp + -1)->expr);
    }
#line 1884
    if (cdebug & 2) {
      {
#line 1884
      tmp___37 = zconf_lineno();
#line 1884
      tmp___38 = zconf_curname();
#line 1884
      printf((char const   */* __restrict  */)"%s:%d:default\n", tmp___38, tmp___37);
      }
    }
  } else {
#line 1887
    goto yyerrorlab;
  }
#line 1889
  goto switch_break;
  case_67: /* CIL Label */ 
#line 1894
  if (cdebug & 2) {
    {
#line 1894
    tmp___39 = zconf_lineno();
#line 1894
    tmp___40 = zconf_curname();
#line 1894
    printf((char const   */* __restrict  */)"%s:%d:if\n", tmp___40, tmp___39);
    }
  }
  {
#line 1895
  menu_add_entry((struct symbol *)((void *)0));
#line 1896
  menu_add_dep((yyvsp + -1)->expr);
#line 1897
  yyval.menu = menu_add_menu();
  }
#line 1899
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 1904
  tmp___43 = zconf_endtoken((yyvsp + 0)->id, 269, 270);
  }
#line 1904
  if (tmp___43) {
    {
#line 1905
    menu_end_menu();
    }
#line 1906
    if (cdebug & 2) {
      {
#line 1906
      tmp___41 = zconf_lineno();
#line 1906
      tmp___42 = zconf_curname();
#line 1906
      printf((char const   */* __restrict  */)"%s:%d:endif\n", tmp___42, tmp___41);
      }
    }
  }
#line 1909
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1914
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1916
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1921
  menu_add_entry((struct symbol *)((void *)0));
#line 1922
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1923
  if (cdebug & 2) {
    {
#line 1923
    tmp___44 = zconf_lineno();
#line 1923
    tmp___45 = zconf_curname();
#line 1923
    printf((char const   */* __restrict  */)"%s:%d:menu\n", tmp___45, tmp___44);
    }
  }
#line 1925
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 1930
  yyval.menu = menu_add_menu();
  }
#line 1932
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 1937
  tmp___48 = zconf_endtoken((yyvsp + 0)->id, 259, 260);
  }
#line 1937
  if (tmp___48) {
    {
#line 1938
    menu_end_menu();
    }
#line 1939
    if (cdebug & 2) {
      {
#line 1939
      tmp___46 = zconf_lineno();
#line 1939
      tmp___47 = zconf_curname();
#line 1939
      printf((char const   */* __restrict  */)"%s:%d:endmenu\n", tmp___47, tmp___46);
      }
    }
  }
#line 1942
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1947
  if (cdebug & 2) {
    {
#line 1947
    tmp___49 = zconf_lineno();
#line 1947
    tmp___50 = zconf_curname();
#line 1947
    printf((char const   */* __restrict  */)"%s:%d:source %s\n", tmp___50, tmp___49,
           (yyvsp + -1)->string);
    }
  }
  {
#line 1948
  zconf_nextfile((char const   *)(yyvsp + -1)->string);
  }
#line 1950
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 1955
  menu_add_entry((struct symbol *)((void *)0));
#line 1956
  menu_add_prompt((enum prop_type )2, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1957
  if (cdebug & 2) {
    {
#line 1957
    tmp___51 = zconf_lineno();
#line 1957
    tmp___52 = zconf_curname();
#line 1957
    printf((char const   */* __restrict  */)"%s:%d:comment\n", tmp___52, tmp___51);
    }
  }
#line 1959
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1964
  menu_end_entry();
  }
#line 1966
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1971
  if (cdebug & 2) {
    {
#line 1971
    tmp___53 = zconf_lineno();
#line 1971
    tmp___54 = zconf_curname();
#line 1971
    printf((char const   */* __restrict  */)"%s:%d:help\n", tmp___54, tmp___53);
    }
  }
  {
#line 1972
  zconf_starthelp();
  }
#line 1974
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1979
  current_entry->help = (yyvsp + 0)->string;
#line 1981
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 1986
  menu_add_dep((yyvsp + -1)->expr);
  }
#line 1987
  if (cdebug & 2) {
    {
#line 1987
    tmp___55 = zconf_lineno();
#line 1987
    tmp___56 = zconf_curname();
#line 1987
    printf((char const   */* __restrict  */)"%s:%d:depends on\n", tmp___56, tmp___55);
    }
  }
#line 1989
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1994
  menu_add_visibility((yyvsp + 0)->expr);
  }
#line 1996
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 2001
  menu_add_prompt((enum prop_type )1, (yyvsp + -1)->string, (yyvsp + 0)->expr);
  }
#line 2003
  goto switch_break;
  case_101: /* CIL Label */ 
#line 2007
  yyval.id = (yyvsp + -1)->id;
#line 2008
  goto switch_break;
  case_102: /* CIL Label */ 
#line 2012
  yyval.id = (yyvsp + -1)->id;
#line 2013
  goto switch_break;
  case_103: /* CIL Label */ 
#line 2017
  yyval.id = (yyvsp + -1)->id;
#line 2018
  goto switch_break;
  case_106: /* CIL Label */ 
#line 2022
  yyval.expr = (struct expr *)((void *)0);
#line 2023
  goto switch_break;
  case_107: /* CIL Label */ 
#line 2027
  yyval.expr = (yyvsp + 0)->expr;
#line 2028
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 2032
  yyval.expr = expr_alloc_symbol((yyvsp + 0)->symbol);
  }
#line 2033
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 2037
  yyval.expr = expr_alloc_comp((enum expr_type )6, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2038
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 2042
  yyval.expr = expr_alloc_comp((enum expr_type )7, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2043
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 2047
  yyval.expr = expr_alloc_comp((enum expr_type )8, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2048
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 2052
  yyval.expr = expr_alloc_comp((enum expr_type )9, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2053
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 2057
  yyval.expr = expr_alloc_comp((enum expr_type )4, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2058
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 2062
  yyval.expr = expr_alloc_comp((enum expr_type )5, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 2063
  goto switch_break;
  case_115: /* CIL Label */ 
#line 2067
  yyval.expr = (yyvsp + -1)->expr;
#line 2068
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 2072
  yyval.expr = expr_alloc_one((enum expr_type )3, (yyvsp + 0)->expr);
  }
#line 2073
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 2077
  yyval.expr = expr_alloc_two((enum expr_type )1, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 2078
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 2082
  yyval.expr = expr_alloc_two((enum expr_type )2, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 2083
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 2087
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 0);
#line 2087
  free((void *)(yyvsp + 0)->string);
  }
#line 2088
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 2092
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 1);
#line 2092
  free((void *)(yyvsp + 0)->string);
  }
#line 2093
  goto switch_break;
  case_121: /* CIL Label */ 
#line 2097
  yyval.string = (char *)((void *)0);
#line 2098
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2115
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2115
    if (zconfdebug) {
      {
#line 2115
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 2115
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval));
#line 2115
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2115
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2117
  yyvsp -= yylen;
#line 2117
  yyssp -= yylen;
#line 2118
  yylen = 0;
  {
#line 2119
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2119
    if (zconfdebug) {
      {
#line 2119
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2119
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2121
  yyvsp ++;
#line 2121
  *yyvsp = yyval;
#line 2127
  yyn = (int )yyr1[yyn];
#line 2129
  yystate = (int )((int const   )yypgoto[yyn - 40] + (int const   )*yyssp);
#line 2130
  if (0 <= yystate) {
#line 2130
    if (yystate <= 298) {
#line 2130
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2131
        yystate = (int )yytable[yystate];
      } else {
#line 2133
        yystate = (int )yydefgoto[yyn - 40];
      }
    } else {
#line 2133
      yystate = (int )yydefgoto[yyn - 40];
    }
  } else {
#line 2133
    yystate = (int )yydefgoto[yyn - 40];
  }
#line 2135
  goto yynewstate;
  yyerrlab: 
#line 2144
  if (zconfchar == -2) {
#line 2144
    yytoken = -2;
  } else {
#line 2144
    if ((unsigned int )zconfchar <= 294U) {
#line 2144
      tmp___57 = (int const   )yytranslate[zconfchar];
    } else {
#line 2144
      tmp___57 = (int const   )2;
    }
#line 2144
    yytoken = (int )tmp___57;
  }
#line 2147
  if (! yyerrstatus) {
    {
#line 2149
    zconfnerrs ++;
#line 2151
    zconferror("syntax error");
    }
  }
#line 2188
  if (yyerrstatus == 3) {
#line 2193
    if (zconfchar <= 0) {
#line 2196
      if (zconfchar == 0) {
#line 2197
        goto yyabortlab;
      }
    } else {
      {
#line 2201
      yydestruct("Error: discarding", yytoken, & zconflval);
#line 2203
      zconfchar = -2;
      }
    }
  }
#line 2209
  goto yyerrlab1;
  yyerrorlab: 
#line 2225
  yyvsp -= yylen;
#line 2225
  yyssp -= yylen;
#line 2226
  yylen = 0;
  {
#line 2227
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2227
    if (zconfdebug) {
      {
#line 2227
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2227
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 2228
  yystate = (int )*yyssp;
#line 2229
  goto yyerrlab1;
  yyerrlab1: 
#line 2236
  yyerrstatus = 3;
  {
#line 2238
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2240
    yyn = (int )yypact[yystate];
#line 2241
    if (! (yyn == -91)) {
#line 2243
      yyn ++;
#line 2244
      if (0 <= yyn) {
#line 2244
        if (yyn <= 298) {
#line 2244
          if ((int const   )yycheck[yyn] == 1) {
#line 2246
            yyn = (int )yytable[yyn];
#line 2247
            if (0 < yyn) {
#line 2248
              goto while_break___12;
            }
          }
        }
      }
    }
#line 2253
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2254
      goto yyabortlab;
    }
    {
#line 2257
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2259
    yyvsp --;
#line 2259
    yyssp --;
#line 2260
    yystate = (int )*yyssp;
    }
    {
#line 2261
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2261
      if (zconfdebug) {
        {
#line 2261
        yy_stack_print(yyss, yyssp);
        }
      }
#line 2261
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2264
  yyvsp ++;
#line 2264
  *yyvsp = zconflval;
  {
#line 2268
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 2268
    if (zconfdebug) {
      {
#line 2268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 2268
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp);
#line 2268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2268
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 2270
  yystate = yyn;
#line 2271
  goto yynewstate;
  yyacceptlab: 
#line 2278
  yyresult = 0;
#line 2279
  goto yyreturn;
  yyabortlab: 
#line 2285
  yyresult = 1;
#line 2286
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2293
  zconferror("memory exhausted");
#line 2294
  yyresult = 2;
  }
  yyreturn: 
#line 2299
  if (zconfchar != -2) {
#line 2303
    if ((unsigned int )zconfchar <= 294U) {
#line 2303
      yytoken = (int )yytranslate[zconfchar];
    } else {
#line 2303
      yytoken = 2;
    }
    {
#line 2304
    yydestruct("Cleanup: discarding lookahead", yytoken, & zconflval);
    }
  }
#line 2309
  yyvsp -= yylen;
#line 2309
  yyssp -= yylen;
  {
#line 2310
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 2310
    if (zconfdebug) {
      {
#line 2310
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2310
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 2311
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2311
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2311
      goto while_break___16;
    }
    {
#line 2313
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2315
    yyvsp --;
#line 2315
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 2318
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2319
    free((void *)yyss);
    }
  }
#line 2326
  return (yyresult);
}
}
#line 2333 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
void conf_parse(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  struct symbol *tmp___1 ;

  {
  {
#line 2338
  zconf_initscan(name);
#line 2340
  sym_init();
#line 2341
  _menu_init();
#line 2342
  rootmenu.prompt = menu_add_prompt((enum prop_type )3, (char *)"Linux Kernel Configuration",
                                    (struct expr *)((void *)0));
#line 2344
  tmp = getenv("ZCONF_DEBUG");
  }
#line 2344
  if (tmp) {
#line 2345
    zconfdebug = 1;
  }
  {
#line 2346
  zconfparse();
  }
#line 2347
  if (zconfnerrs) {
    {
#line 2348
    exit(1);
    }
  }
#line 2349
  if (! modules_sym) {
    {
#line 2350
    modules_sym = sym_find("n");
    }
  }
  {
#line 2352
  tmp___0 = gettext((rootmenu.prompt)->text);
#line 2352
  (rootmenu.prompt)->text = (char const   *)tmp___0;
#line 2353
  (rootmenu.prompt)->text = sym_expand_string_value((rootmenu.prompt)->text);
#line 2355
  menu_finalize(& rootmenu);
#line 2356
  i = 0;
  }
  {
#line 2356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2356
    if (! (i < 9973)) {
#line 2356
      goto while_break;
    }
#line 2356
    sym = symbol_hash[i];
    {
#line 2356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2356
      if (! sym) {
#line 2356
        goto while_break___0;
      }
#line 2356
      if ((unsigned int )sym->type != 6U) {
        {
#line 2357
        tmp___1 = sym_check_deps(sym);
        }
#line 2357
        if (tmp___1) {
#line 2358
          zconfnerrs ++;
        }
      }
#line 2356
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2360
  if (zconfnerrs) {
    {
#line 2361
    exit(1);
    }
  }
  {
#line 2362
  sym_set_change_count(1);
  }
#line 2363
  return;
}
}
#line 2365 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static char const   *zconf_tokenname(int token ) 
{ 


  {
  {
#line 2368
  if (token == 259) {
#line 2368
    goto case_259;
  }
#line 2369
  if (token == 260) {
#line 2369
    goto case_260;
  }
#line 2370
  if (token == 262) {
#line 2370
    goto case_262;
  }
#line 2371
  if (token == 263) {
#line 2371
    goto case_263;
  }
#line 2372
  if (token == 269) {
#line 2372
    goto case_269;
  }
#line 2373
  if (token == 270) {
#line 2373
    goto case_270;
  }
#line 2374
  if (token == 271) {
#line 2374
    goto case_271;
  }
#line 2375
  if (token == 278) {
#line 2375
    goto case_278;
  }
#line 2367
  goto switch_break;
  case_259: /* CIL Label */ 
#line 2368
  return ("menu");
  case_260: /* CIL Label */ 
#line 2369
  return ("endmenu");
  case_262: /* CIL Label */ 
#line 2370
  return ("choice");
  case_263: /* CIL Label */ 
#line 2371
  return ("endchoice");
  case_269: /* CIL Label */ 
#line 2372
  return ("if");
  case_270: /* CIL Label */ 
#line 2373
  return ("endif");
  case_271: /* CIL Label */ 
#line 2374
  return ("depends");
  case_278: /* CIL Label */ 
#line 2375
  return ("visible");
  switch_break: /* CIL Label */ ;
  }
#line 2377
  return ("<token>");
}
}
#line 2380 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static _Bool zconf_endtoken(struct kconf_id  const  *id , int starttoken , int endtoken ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2382
  if (id->token != (int const   )endtoken) {
    {
#line 2383
    tmp = zconf_tokenname(starttoken);
#line 2383
    zconf_error("unexpected \'%s\' within %s block", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp);
#line 2385
    zconfnerrs ++;
    }
#line 2386
    return ((_Bool)0);
  }
#line 2388
  if ((unsigned long )current_menu->file != (unsigned long )current_file) {
    {
#line 2389
    tmp___0 = zconf_tokenname(starttoken);
#line 2389
    zconf_error("\'%s\' in different file than \'%s\'", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp___0);
#line 2391
    tmp___1 = zconf_tokenname(starttoken);
#line 2391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: location of the \'%s\'\n",
            (current_menu->file)->name, current_menu->lineno, tmp___1);
#line 2394
    zconfnerrs ++;
    }
#line 2395
    return ((_Bool)0);
  }
#line 2397
  return ((_Bool)1);
}
}
#line 2400 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void zconfprint(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2404
  tmp = zconf_lineno();
#line 2404
  tmp___0 = zconf_curname();
#line 2404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2405
  __builtin_va_start(ap, err);
#line 2406
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2407
  __builtin_va_end(ap);
#line 2408
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2409
  return;
}
}
#line 2411 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void zconf_error(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2415
  zconfnerrs ++;
#line 2416
  tmp = zconf_lineno();
#line 2416
  tmp___0 = zconf_curname();
#line 2416
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2417
  __builtin_va_start(ap, err);
#line 2418
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2419
  __builtin_va_end(ap);
#line 2420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2421
  return;
}
}
#line 2423 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void zconferror(char const   *err ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2425
  tmp = zconf_lineno();
#line 2425
  tmp___0 = zconf_curname();
#line 2425
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
          tmp___0, tmp + 1, err);
  }
#line 2426
  return;
}
}
#line 2428 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void print_quoted_string(FILE *out , char const   *str ) 
{ 
  char const   *p ;
  int len ;
  char *tmp ;

  {
  {
#line 2433
  _IO_putc('\"', out);
  }
  {
#line 2434
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2434
    tmp = strchr(str, '\"');
#line 2434
    p = (char const   *)tmp;
    }
#line 2434
    if (! p) {
#line 2434
      goto while_break;
    }
#line 2435
    len = (int )(p - str);
#line 2436
    if (len) {
      {
#line 2437
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%.*s",
              len, str);
      }
    }
    {
#line 2438
    fputs((char const   */* __restrict  */)"\\\"", (FILE */* __restrict  */)out);
#line 2439
    str = p + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2441
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)out);
#line 2442
  _IO_putc('\"', out);
  }
#line 2443
  return;
}
}
#line 2445 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
static void print_symbol(FILE *out , struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;

  {
  {
#line 2447
  sym = menu->sym;
#line 2450
  tmp = sym_is_choice(sym);
  }
#line 2450
  if (tmp) {
    {
#line 2451
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\nchoice\n");
    }
  } else {
    {
#line 2453
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\nconfig %s\n",
            sym->name);
    }
  }
  {
#line 2455
  if ((unsigned int )sym->type == 1U) {
#line 2455
    goto case_1;
  }
#line 2458
  if ((unsigned int )sym->type == 2U) {
#line 2458
    goto case_2;
  }
#line 2461
  if ((unsigned int )sym->type == 5U) {
#line 2461
    goto case_5;
  }
#line 2464
  if ((unsigned int )sym->type == 3U) {
#line 2464
    goto case_3;
  }
#line 2467
  if ((unsigned int )sym->type == 4U) {
#line 2467
    goto case_4;
  }
#line 2470
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2456
  fputs((char const   */* __restrict  */)"  boolean\n", (FILE */* __restrict  */)out);
  }
#line 2457
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2459
  fputs((char const   */* __restrict  */)"  tristate\n", (FILE */* __restrict  */)out);
  }
#line 2460
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2462
  fputs((char const   */* __restrict  */)"  string\n", (FILE */* __restrict  */)out);
  }
#line 2463
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2465
  fputs((char const   */* __restrict  */)"  integer\n", (FILE */* __restrict  */)out);
  }
#line 2466
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2468
  fputs((char const   */* __restrict  */)"  hex\n", (FILE */* __restrict  */)out);
  }
#line 2469
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2471
  fputs((char const   */* __restrict  */)"  ???\n", (FILE */* __restrict  */)out);
  }
#line 2472
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2474
  prop = sym->prop;
  {
#line 2474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2474
    if (! prop) {
#line 2474
      goto while_break;
    }
#line 2475
    if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 2476
      goto __Cont;
    }
    {
#line 2478
    if ((unsigned int )prop->type == 1U) {
#line 2478
      goto case_1___0;
    }
#line 2487
    if ((unsigned int )prop->type == 4U) {
#line 2487
      goto case_4___0;
    }
#line 2496
    if ((unsigned int )prop->type == 5U) {
#line 2496
      goto case_5___0;
    }
#line 2499
    if ((unsigned int )prop->type == 6U) {
#line 2499
      goto case_6;
    }
#line 2504
    if ((unsigned int )prop->type == 7U) {
#line 2504
      goto case_7;
    }
#line 2509
    if ((unsigned int )prop->type == 3U) {
#line 2509
      goto case_3___0;
    }
#line 2514
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 2479
    fputs((char const   */* __restrict  */)"  prompt ", (FILE */* __restrict  */)out);
#line 2480
    print_quoted_string(out, prop->text);
#line 2481
    tmp___0 = expr_is_yes(prop->visible.expr);
    }
#line 2481
    if (! tmp___0) {
      {
#line 2482
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2483
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2485
    fputc('\n', out);
    }
#line 2486
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 2488
    fputs((char const   */* __restrict  */)"  default ", (FILE */* __restrict  */)out);
#line 2489
    expr_fprint(prop->expr, out);
#line 2490
    tmp___1 = expr_is_yes(prop->visible.expr);
    }
#line 2490
    if (! tmp___1) {
      {
#line 2491
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2492
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2494
    fputc('\n', out);
    }
#line 2495
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 2497
    fputs((char const   */* __restrict  */)"  #choice value\n", (FILE */* __restrict  */)out);
    }
#line 2498
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 2500
    fputs((char const   */* __restrict  */)"  select ", (FILE */* __restrict  */)out);
#line 2501
    expr_fprint(prop->expr, out);
#line 2502
    fputc('\n', out);
    }
#line 2503
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 2505
    fputs((char const   */* __restrict  */)"  range ", (FILE */* __restrict  */)out);
#line 2506
    expr_fprint(prop->expr, out);
#line 2507
    fputc('\n', out);
    }
#line 2508
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 2510
    fputs((char const   */* __restrict  */)"  menu ", (FILE */* __restrict  */)out);
#line 2511
    print_quoted_string(out, prop->text);
#line 2512
    fputc('\n', out);
    }
#line 2513
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2515
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  unknown prop %d!\n",
            (unsigned int )prop->type);
    }
#line 2516
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2474
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2519
  if (menu->help) {
    {
#line 2520
    tmp___2 = strlen((char const   *)menu->help);
#line 2520
    len = (int )tmp___2;
    }
    {
#line 2521
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2521
      len --;
#line 2521
      if (! ((int )*(menu->help + len) == 10)) {
#line 2521
        goto while_break___0;
      }
#line 2522
      *(menu->help + len) = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2523
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  help\n%s\n",
            menu->help);
    }
  }
#line 2525
  return;
}
}
#line 2527 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/zconf.tab.c"
void zconfdump(FILE *out ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct menu *menu ;
  int tmp ;

  {
#line 2533
  menu = rootmenu.list;
  {
#line 2534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2534
    if (! menu) {
#line 2534
      goto while_break;
    }
#line 2535
    sym = menu->sym;
#line 2535
    if (sym) {
      {
#line 2536
      print_symbol(out, menu);
      }
    } else {
#line 2537
      prop = menu->prompt;
#line 2537
      if (prop) {
        {
#line 2539
        if ((unsigned int )prop->type == 2U) {
#line 2539
          goto case_2;
        }
#line 2544
        if ((unsigned int )prop->type == 3U) {
#line 2544
          goto case_3;
        }
#line 2549
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 2540
        fputs((char const   */* __restrict  */)"\ncomment ", (FILE */* __restrict  */)out);
#line 2541
        print_quoted_string(out, prop->text);
#line 2542
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2543
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2545
        fputs((char const   */* __restrict  */)"\nmenu ", (FILE */* __restrict  */)out);
#line 2546
        print_quoted_string(out, prop->text);
#line 2547
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2548
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2552
        tmp = expr_is_yes(prop->visible.expr);
        }
#line 2552
        if (! tmp) {
          {
#line 2553
          fputs((char const   */* __restrict  */)"  depends ", (FILE */* __restrict  */)out);
#line 2554
          expr_fprint(prop->visible.expr, out);
#line 2555
          fputc('\n', out);
          }
        }
      }
    }
#line 2559
    if (menu->list) {
#line 2560
      menu = menu->list;
    } else
#line 2561
    if (menu->next) {
#line 2562
      menu = menu->next;
    } else {
      {
#line 2563
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2563
        menu = menu->parent;
#line 2563
        if (! menu) {
#line 2563
          goto while_break___0;
        }
#line 2564
        if (menu->prompt) {
#line 2564
          if ((unsigned int )(menu->prompt)->type == 3U) {
            {
#line 2565
            fputs((char const   */* __restrict  */)"\nendmenu\n", (FILE */* __restrict  */)out);
            }
          }
        }
#line 2566
        if (menu->next) {
#line 2567
          menu = menu->next;
#line 2568
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2572
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 174 "scripts/kconfig/zconf.lex.c_shipped"
int zconfleng  ;
#line 176
FILE *zconfin ;
#line 176
FILE *zconfout ;
#line 271 "scripts/kconfig/zconf.lex.c_shipped"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 272 "scripts/kconfig/zconf.lex.c_shipped"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 273 "scripts/kconfig/zconf.lex.c_shipped"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 291 "scripts/kconfig/zconf.lex.c_shipped"
static char yy_hold_char  ;
#line 292 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_n_chars  ;
#line 296 "scripts/kconfig/zconf.lex.c_shipped"
static char *yy_c_buf_p  =    (char *)0;
#line 297 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_init  =    0;
#line 298 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_start  =    0;
#line 303 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_did_buffer_switch_on_eof  ;
#line 305
void zconfrestart(FILE *input_file ) ;
#line 306
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 307
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) ;
#line 308
void zconf_delete_buffer(YY_BUFFER_STATE b ) ;
#line 309
void zconf_flush_buffer(YY_BUFFER_STATE b ) ;
#line 310
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 311
void zconfpop_buffer_state(void) ;
#line 313
static void zconfensure_buffer_stack(void) ;
#line 314
static void zconf_load_buffer_state(void) ;
#line 315
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 319
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) ;
#line 320
YY_BUFFER_STATE zconf_scan_string(char const   *yystr ) ;
#line 321
YY_BUFFER_STATE zconf_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 323
void *zconfalloc(yy_size_t size ) ;
#line 324
void *zconfrealloc(void *ptr , yy_size_t size ) ;
#line 325
void zconffree(void *ptr ) ;
#line 358 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfin  =    (FILE *)0;
#line 358 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfout  =    (FILE *)0;
#line 362
int zconflineno ;
#line 364 "scripts/kconfig/zconf.lex.c_shipped"
int zconflineno  =    1;
#line 366 "scripts/kconfig/zconf.lex.c_shipped"
char *zconftext  ;
#line 368 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int16_t const   yy_nxt[67][19]  = 
#line 368
  { {        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )25,        (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )25,        (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )27,        (flex_int16_t const   )28, 
            (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31,        (flex_int16_t const   )32, 
            (flex_int16_t const   )30,        (flex_int16_t const   )33,        (flex_int16_t const   )34,        (flex_int16_t const   )35, 
            (flex_int16_t const   )36,        (flex_int16_t const   )36,        (flex_int16_t const   )37,        (flex_int16_t const   )38, 
            (flex_int16_t const   )39,        (flex_int16_t const   )40,        (flex_int16_t const   )41}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )27,        (flex_int16_t const   )28, 
            (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31,        (flex_int16_t const   )32, 
            (flex_int16_t const   )30,        (flex_int16_t const   )33,        (flex_int16_t const   )34,        (flex_int16_t const   )35, 
            (flex_int16_t const   )36,        (flex_int16_t const   )36,        (flex_int16_t const   )37,        (flex_int16_t const   )38, 
            (flex_int16_t const   )39,        (flex_int16_t const   )40,        (flex_int16_t const   )41}, 
   {        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-13,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )44,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )46, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )47,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )-19, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-20,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )51,        (flex_int16_t const   )-21,        (flex_int16_t const   )-21, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )53, 
            (flex_int16_t const   )52,        (flex_int16_t const   )-22,        (flex_int16_t const   )52,        (flex_int16_t const   )52, 
            (flex_int16_t const   )-22,        (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )52, 
            (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )52, 
            (flex_int16_t const   )52,        (flex_int16_t const   )-22,        (flex_int16_t const   )52}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )55, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-27,        (flex_int16_t const   )56,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )57, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )-30,        (flex_int16_t const   )-30,        (flex_int16_t const   )-30}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )59, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )60, 
            (flex_int16_t const   )61,        (flex_int16_t const   )61,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )61, 
            (flex_int16_t const   )61,        (flex_int16_t const   )61,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )62, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )63, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )64, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41, 
            (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41, 
            (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41, 
            (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )-41, 
            (flex_int16_t const   )-41,        (flex_int16_t const   )-41,        (flex_int16_t const   )65}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )-42,        (flex_int16_t const   )-42,        (flex_int16_t const   )44,        (flex_int16_t const   )-42, 
            (flex_int16_t const   )-42,        (flex_int16_t const   )-42,        (flex_int16_t const   )-42,        (flex_int16_t const   )-42, 
            (flex_int16_t const   )-42,        (flex_int16_t const   )-42,        (flex_int16_t const   )-42,        (flex_int16_t const   )-42, 
            (flex_int16_t const   )-42,        (flex_int16_t const   )-42,        (flex_int16_t const   )-42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )46, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )46, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )-47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )-47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )-47,        (flex_int16_t const   )47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )-47,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )-49,        (flex_int16_t const   )-49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )51,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )53, 
            (flex_int16_t const   )52,        (flex_int16_t const   )-52,        (flex_int16_t const   )52,        (flex_int16_t const   )52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )52, 
            (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )52,        (flex_int16_t const   )52, 
            (flex_int16_t const   )52,        (flex_int16_t const   )-52,        (flex_int16_t const   )52}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )55, 
            (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54, 
            (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54, 
            (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54, 
            (flex_int16_t const   )-54,        (flex_int16_t const   )-54,        (flex_int16_t const   )-54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-56,        (flex_int16_t const   )56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58, 
            (flex_int16_t const   )58,        (flex_int16_t const   )58,        (flex_int16_t const   )58}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )66, 
            (flex_int16_t const   )61,        (flex_int16_t const   )61,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61, 
            (flex_int16_t const   )-61,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61, 
            (flex_int16_t const   )-61,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61,        (flex_int16_t const   )61, 
            (flex_int16_t const   )61,        (flex_int16_t const   )61,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61, 
            (flex_int16_t const   )-61,        (flex_int16_t const   )-61,        (flex_int16_t const   )-61}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62, 
            (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62, 
            (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62, 
            (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62, 
            (flex_int16_t const   )-62,        (flex_int16_t const   )-62,        (flex_int16_t const   )-62}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63, 
            (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63, 
            (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63, 
            (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63, 
            (flex_int16_t const   )-63,        (flex_int16_t const   )-63,        (flex_int16_t const   )-63}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64, 
            (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64, 
            (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64, 
            (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64, 
            (flex_int16_t const   )-64,        (flex_int16_t const   )-64,        (flex_int16_t const   )-64}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65, 
            (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65, 
            (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65, 
            (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65, 
            (flex_int16_t const   )-65,        (flex_int16_t const   )-65,        (flex_int16_t const   )-65}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66, 
            (flex_int16_t const   )-66,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66, 
            (flex_int16_t const   )-66,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66,        (flex_int16_t const   )61, 
            (flex_int16_t const   )61,        (flex_int16_t const   )61,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66, 
            (flex_int16_t const   )-66,        (flex_int16_t const   )-66,        (flex_int16_t const   )-66}};
#line 720
static yy_state_type yy_get_previous_state(void) ;
#line 721
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 722
static int yy_get_next_buffer(void) ;
#line 723
static void yy_fatal_error(char const   *msg ) ;
#line 744 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int16_t const   yy_accept[67]  = 
#line 744
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )39, 
        (flex_int16_t const   )5,      (flex_int16_t const   )4,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )37, 
        (flex_int16_t const   )34,      (flex_int16_t const   )36,      (flex_int16_t const   )29,      (flex_int16_t const   )33, 
        (flex_int16_t const   )32,      (flex_int16_t const   )31,      (flex_int16_t const   )27,      (flex_int16_t const   )26, 
        (flex_int16_t const   )21,      (flex_int16_t const   )13,      (flex_int16_t const   )20,      (flex_int16_t const   )24, 
        (flex_int16_t const   )27,      (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )18,      (flex_int16_t const   )14,      (flex_int16_t const   )19, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )4,      (flex_int16_t const   )2, 
        (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )1,      (flex_int16_t const   )6, 
        (flex_int16_t const   )37,      (flex_int16_t const   )34,      (flex_int16_t const   )36,      (flex_int16_t const   )35, 
        (flex_int16_t const   )29,      (flex_int16_t const   )28,      (flex_int16_t const   )31,      (flex_int16_t const   )30, 
        (flex_int16_t const   )26,      (flex_int16_t const   )15,      (flex_int16_t const   )24,      (flex_int16_t const   )9, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )16,      (flex_int16_t const   )17, 
        (flex_int16_t const   )25,      (flex_int16_t const   )10,      (flex_int16_t const   )22};
#line 755 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int32_t const   yy_ec[256]  = 
#line 755
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )13, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )18,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 787
int zconf_flex_debug ;
#line 788 "scripts/kconfig/zconf.lex.c_shipped"
int zconf_flex_debug  =    0;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 815 "scripts/kconfig/zconf.lex.c_shipped"
static struct __anonstruct_current_pos_31 current_pos  ;
#line 820 "scripts/kconfig/zconf.lex.c_shipped"
static char *text  ;
#line 821 "scripts/kconfig/zconf.lex.c_shipped"
static int text_size  ;
#line 821 "scripts/kconfig/zconf.lex.c_shipped"
static int text_asize  ;
#line 828 "scripts/kconfig/zconf.lex.c_shipped"
struct buffer *current_buf  ;
#line 830 "scripts/kconfig/zconf.lex.c_shipped"
static int last_ts  ;
#line 830 "scripts/kconfig/zconf.lex.c_shipped"
static int first_ts  ;
#line 832
static void zconf_endhelp(void) ;
#line 833
static void zconf_endfile(void) ;
#line 835 "scripts/kconfig/zconf.lex.c_shipped"
static void new_string(void) 
{ 
  void *tmp ;

  {
  {
#line 837
  tmp = xmalloc((size_t )16);
#line 837
  text = (char *)tmp;
#line 838
  text_asize = 16;
#line 839
  text_size = 0;
#line 840
  *text = (char)0;
  }
#line 841
  return;
}
}
#line 843 "scripts/kconfig/zconf.lex.c_shipped"
static void append_string(char const   *str , int size ) 
{ 
  int new_size ;
  void *tmp ;

  {
#line 845
  new_size = (text_size + size) + 1;
#line 846
  if (new_size > text_asize) {
    {
#line 847
    new_size += 15;
#line 848
    new_size &= -16;
#line 849
    tmp = realloc((void *)text, (size_t )new_size);
#line 849
    text = (char *)tmp;
#line 850
    text_asize = new_size;
    }
  }
  {
#line 852
  memcpy((void */* __restrict  */)(text + text_size), (void const   */* __restrict  */)str,
         (size_t )size);
#line 853
  text_size += size;
#line 854
  *(text + text_size) = (char)0;
  }
#line 855
  return;
}
}
#line 857 "scripts/kconfig/zconf.lex.c_shipped"
static void alloc_string(char const   *str , int size ) 
{ 
  void *tmp ;

  {
  {
#line 859
  tmp = xmalloc((size_t )(size + 1));
#line 859
  text = (char *)tmp;
#line 860
  memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)str, (size_t )size);
#line 861
  *(text + size) = (char)0;
  }
#line 862
  return;
}
}
#line 882
static int yy_init_globals(void) ;
#line 887
int zconflex_destroy(void) ;
#line 889
int zconfget_debug(void) ;
#line 891
void zconfset_debug(int bdebug ) ;
#line 897
FILE *zconfget_in(void) ;
#line 899
void zconfset_in(FILE *in_str ) ;
#line 901
FILE *zconfget_out(void) ;
#line 903
void zconfset_out(FILE *out_str ) ;
#line 905
int zconfget_leng(void) ;
#line 907
char *zconfget_text(void) ;
#line 909
int zconfget_lineno(void) ;
#line 911
void zconfset_lineno(int line_number ) ;
#line 925
static void yyunput(int c , char *yy_bp ) ;
#line 1026 "scripts/kconfig/zconf.lex.c_shipped"
int zconflex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int str ;
  int ts ;
  int i ;
  YY_BUFFER_STATE tmp ;
  struct kconf_id  const  *id ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___0 ;
  struct kconf_id  const  *id___0 ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___6 ;

  {
#line 1032
  str = 0;
#line 1035
  if (! yy_init) {
#line 1037
    yy_init = 1;
#line 1043
    if (! yy_start) {
#line 1044
      yy_start = 1;
    }
#line 1046
    if (! zconfin) {
#line 1047
      zconfin = stdin;
    }
#line 1049
    if (! zconfout) {
#line 1050
      zconfout = stdout;
    }
#line 1052
    if (yy_buffer_stack) {
#line 1052
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1052
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1052
    if (! tmp) {
      {
#line 1053
      zconfensure_buffer_stack();
#line 1054
      *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
      }
    }
    {
#line 1058
    zconf_load_buffer_state();
    }
  }
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1063
    yy_cp = yy_c_buf_p;
#line 1066
    *yy_cp = yy_hold_char;
#line 1071
    yy_bp = yy_cp;
#line 1073
    yy_current_state = yy_start;
    yy_match: 
    {
#line 1075
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1075
      yy_current_state = (yy_state_type )yy_nxt[yy_current_state][yy_ec[(unsigned int )((unsigned char )*yy_cp)]];
#line 1075
      if (! (yy_current_state > 0)) {
#line 1075
        goto while_break___0;
      }
#line 1076
      yy_cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1078
    yy_current_state = - yy_current_state;
    yy_find_action: 
#line 1081
    yy_act = (int )yy_accept[yy_current_state];
#line 1083
    zconftext = yy_bp;
#line 1083
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1083
    yy_hold_char = *yy_cp;
#line 1083
    *yy_cp = (char )'\000';
#line 1083
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1091
    if (yy_act == 2) {
#line 1091
      goto case_2;
    }
#line 1091
    if (yy_act == 1) {
#line 1091
      goto case_2;
    }
#line 1099
    if (yy_act == 3) {
#line 1099
      goto case_3;
    }
#line 1103
    if (yy_act == 4) {
#line 1103
      goto case_4;
    }
#line 1109
    if (yy_act == 5) {
#line 1109
      goto case_5;
    }
#line 1117
    if (yy_act == 6) {
#line 1117
      goto case_6;
    }
#line 1133
    if (yy_act == 7) {
#line 1133
      goto case_7;
    }
#line 1137
    if (yy_act == 8) {
#line 1137
      goto case_8;
    }
#line 1147
    if (yy_act == 9) {
#line 1147
      goto case_9;
    }
#line 1151
    if (yy_act == 10) {
#line 1151
      goto case_10;
    }
#line 1155
    if (yy_act == 11) {
#line 1155
      goto case_11;
    }
#line 1159
    if (yy_act == 12) {
#line 1159
      goto case_12;
    }
#line 1163
    if (yy_act == 13) {
#line 1163
      goto case_13;
    }
#line 1167
    if (yy_act == 14) {
#line 1167
      goto case_14;
    }
#line 1171
    if (yy_act == 15) {
#line 1171
      goto case_15;
    }
#line 1175
    if (yy_act == 16) {
#line 1175
      goto case_16;
    }
#line 1179
    if (yy_act == 17) {
#line 1179
      goto case_17;
    }
#line 1183
    if (yy_act == 18) {
#line 1183
      goto case_18;
    }
#line 1187
    if (yy_act == 19) {
#line 1187
      goto case_19;
    }
#line 1191
    if (yy_act == 20) {
#line 1191
      goto case_20;
    }
#line 1199
    if (yy_act == 21) {
#line 1199
      goto case_21;
    }
#line 1204
    if (yy_act == 22) {
#line 1204
      goto case_22;
    }
#line 1208
    if (yy_act == 23) {
#line 1208
      goto case_23;
    }
#line 1221
    if (yy_act == 24) {
#line 1221
      goto case_24;
    }
#line 1225
    if (yy_act == 25) {
#line 1225
      goto case_25;
    }
#line 1230
    if (yy_act == 26) {
#line 1230
      goto case_26;
    }
#line 1234
    if (yy_act == 27) {
#line 1234
      goto case_27;
    }
#line 1242
    if (yy_act == 44) {
#line 1242
      goto case_44;
    }
#line 1248
    if (yy_act == 28) {
#line 1248
      goto case_28;
    }
#line 1260
    if (yy_act == 29) {
#line 1260
      goto case_29;
    }
#line 1266
    if (yy_act == 30) {
#line 1266
      goto case_30;
    }
#line 1278
    if (yy_act == 31) {
#line 1278
      goto case_31;
    }
#line 1284
    if (yy_act == 32) {
#line 1284
      goto case_32;
    }
#line 1295
    if (yy_act == 33) {
#line 1295
      goto case_33;
    }
#line 1305
    if (yy_act == 43) {
#line 1305
      goto case_43;
    }
#line 1311
    if (yy_act == 34) {
#line 1311
      goto case_34;
    }
#line 1336
    if (yy_act == 35) {
#line 1336
      goto case_35;
    }
#line 1348
    if (yy_act == 36) {
#line 1348
      goto case_36;
    }
#line 1356
    if (yy_act == 37) {
#line 1356
      goto case_37;
    }
#line 1369
    if (yy_act == 42) {
#line 1369
      goto case_42;
    }
#line 1377
    if (yy_act == 41) {
#line 1377
      goto case_41;
    }
#line 1377
    if (yy_act == 40) {
#line 1377
      goto case_41;
    }
#line 1387
    if (yy_act == 38) {
#line 1387
      goto case_38;
    }
#line 1392
    if (yy_act == 39) {
#line 1392
      goto case_39;
    }
#line 1514
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1095
    (current_file->lineno) ++;
#line 1096
    return (290);
#line 1098
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1102
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1106
    yy_start = 3;
#line 1108
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1112
    yyunput((int )*(zconftext + 0), zconftext);
#line 1113
    yy_start = 3;
    }
#line 1115
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1120
    tmp___0 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1120
    id = (struct kconf_id  const  *)tmp___0;
#line 1121
    yy_start = 9;
#line 1122
    current_pos.file = current_file;
#line 1123
    current_pos.lineno = current_file->lineno;
    }
#line 1124
    if (id) {
#line 1124
      if (id->flags & 1U) {
#line 1125
        zconflval.id = id;
#line 1126
        return ((int )id->token);
      }
    }
    {
#line 1128
    alloc_string((char const   *)zconftext, zconfleng);
#line 1129
    zconflval.string = text;
    }
#line 1130
    return (281);
#line 1132
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1136
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1141
    yy_start = 1;
#line 1142
    (current_file->lineno) ++;
#line 1143
    return (290);
#line 1145
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1149
    return (292);
#line 1150
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1153
    return (291);
#line 1154
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1157
    return (289);
#line 1158
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1161
    return (288);
#line 1162
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1165
    return (294);
#line 1166
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1169
    return (293);
#line 1170
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1173
    return (283);
#line 1174
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1177
    return (285);
#line 1178
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1181
    return (287);
#line 1182
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1185
    return (284);
#line 1186
    goto switch_break;
    case_19: /* CIL Label */ 
#line 1189
    return (286);
#line 1190
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 1194
    str = (int )*(zconftext + 0);
#line 1195
    new_string();
#line 1196
    yy_start = 7;
    }
#line 1198
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1202
    yy_start = 1;
#line 1202
    (current_file->lineno) ++;
#line 1202
    return (290);
#line 1203
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1207
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1211
    tmp___1 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1211
    id___0 = (struct kconf_id  const  *)tmp___1;
    }
#line 1212
    if (id___0) {
#line 1212
      if (id___0->flags & 2U) {
#line 1213
        zconflval.id = id___0;
#line 1214
        return ((int )id___0->token);
      }
    }
    {
#line 1216
    alloc_string((char const   *)zconftext, zconfleng);
#line 1217
    zconflval.string = text;
    }
#line 1218
    return (281);
#line 1220
    goto switch_break;
    case_24: /* CIL Label */ 
#line 1224
    goto switch_break;
    case_25: /* CIL Label */ 
#line 1228
    (current_file->lineno) ++;
#line 1229
    goto switch_break;
    case_26: /* CIL Label */ 
#line 1233
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 1237
    tmp___2 = zconf_lineno();
#line 1237
    tmp___3 = zconf_curname();
#line 1237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ignoring unsupported character \'%c\'\n",
            tmp___3, tmp___2, (int )*zconftext);
    }
#line 1241
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1244
    yy_start = 1;
#line 1246
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 1250
    *yy_cp = yy_hold_char;
#line 1251
    yy_cp --;
#line 1251
    yy_c_buf_p = yy_cp;
#line 1252
    zconftext = yy_bp;
#line 1252
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1252
    yy_hold_char = *yy_cp;
#line 1252
    *yy_cp = (char )'\000';
#line 1252
    yy_c_buf_p = yy_cp;
#line 1255
    append_string((char const   *)zconftext, zconfleng);
#line 1256
    zconflval.string = text;
    }
#line 1257
    return (282);
#line 1259
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 1263
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1265
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 1268
    *yy_cp = yy_hold_char;
#line 1269
    yy_cp --;
#line 1269
    yy_c_buf_p = yy_cp;
#line 1270
    zconftext = yy_bp;
#line 1270
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1270
    yy_hold_char = *yy_cp;
#line 1270
    *yy_cp = (char )'\000';
#line 1270
    yy_c_buf_p = yy_cp;
#line 1273
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
#line 1274
    zconflval.string = text;
    }
#line 1275
    return (282);
#line 1277
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 1281
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
    }
#line 1283
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1287
    if (str == (int )*(zconftext + 0)) {
#line 1288
      yy_start = 9;
#line 1289
      zconflval.string = text;
#line 1290
      return (282);
    } else {
      {
#line 1292
      append_string((char const   *)zconftext, 1);
      }
    }
#line 1294
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 1299
    tmp___4 = zconf_lineno();
#line 1299
    tmp___5 = zconf_curname();
#line 1299
    printf((char const   */* __restrict  */)"%s:%d:warning: multi-line strings not supported\n",
           tmp___5, tmp___4);
#line 1300
    (current_file->lineno) ++;
#line 1301
    yy_start = 1;
    }
#line 1302
    return (290);
#line 1304
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1307
    yy_start = 1;
#line 1309
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1314
    ts = 0;
#line 1315
    i = 0;
    {
#line 1315
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1315
      if (! (i < zconfleng)) {
#line 1315
        goto while_break___1;
      }
#line 1316
      if ((int )*(zconftext + i) == 9) {
#line 1317
        ts = (ts & -8) + 8;
      } else {
#line 1319
        ts ++;
      }
#line 1315
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1321
    last_ts = ts;
#line 1322
    if (first_ts) {
#line 1323
      if (ts < first_ts) {
        {
#line 1324
        zconf_endhelp();
        }
#line 1325
        return (268);
      }
#line 1327
      ts -= first_ts;
      {
#line 1328
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1328
        if (! (ts > 8)) {
#line 1328
          goto while_break___2;
        }
        {
#line 1329
        append_string("        ", 8);
#line 1330
        ts -= 8;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1332
      append_string("        ", ts);
      }
    }
#line 1335
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 1338
    *yy_cp = yy_hold_char;
#line 1339
    yy_cp --;
#line 1339
    yy_c_buf_p = yy_cp;
#line 1340
    zconftext = yy_bp;
#line 1340
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1340
    yy_hold_char = *yy_cp;
#line 1340
    *yy_cp = (char )'\000';
#line 1340
    yy_c_buf_p = yy_cp;
#line 1343
    (current_file->lineno) ++;
#line 1344
    zconf_endhelp();
    }
#line 1345
    return (268);
#line 1347
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 1352
    (current_file->lineno) ++;
#line 1353
    append_string("\n", 1);
    }
#line 1355
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 1359
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1359
      if (! zconfleng) {
#line 1359
        goto while_break___3;
      }
#line 1360
      if ((int )*(zconftext + (zconfleng - 1)) != 32) {
#line 1360
        if ((int )*(zconftext + (zconfleng - 1)) != 9) {
#line 1361
          goto while_break___3;
        }
      }
#line 1362
      zconfleng --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1364
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1365
    if (! first_ts) {
#line 1366
      first_ts = last_ts;
    }
#line 1368
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 1371
    zconf_endhelp();
    }
#line 1372
    return (268);
#line 1374
    goto switch_break;
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
#line 1379
    if (current_file) {
      {
#line 1380
      zconf_endfile();
      }
#line 1381
      return (290);
    }
    {
#line 1383
    fclose(zconfin);
    }
#line 1384
    return (0);
#line 1386
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 1389
    yy_fatal_error("flex scanner jammed");
    }
#line 1390
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1395
    yy_amount_of_matched_text = (int )(yy_cp - zconftext) - 1;
#line 1398
    *yy_cp = yy_hold_char;
#line 1401
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1412
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1413
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = zconfin;
#line 1414
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1424
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1428
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1430
      yy_current_state = yy_get_previous_state();
#line 1441
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1443
      yy_bp = zconftext + 0;
      }
#line 1445
      if (yy_next_state) {
#line 1448
        yy_c_buf_p ++;
#line 1448
        yy_cp = yy_c_buf_p;
#line 1449
        yy_current_state = yy_next_state;
#line 1450
        goto yy_match;
      } else {
#line 1455
        yy_cp = yy_c_buf_p;
#line 1456
        goto yy_find_action;
      }
    } else {
      {
#line 1460
      tmp___6 = yy_get_next_buffer();
      }
      {
#line 1462
      if (tmp___6 == 1) {
#line 1462
        goto case_1___0;
      }
#line 1491
      if (tmp___6 == 0) {
#line 1491
        goto case_0;
      }
#line 1501
      if (tmp___6 == 2) {
#line 1501
        goto case_2___0;
      }
#line 1460
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1464
      yy_did_buffer_switch_on_eof = 0;
#line 1477
      yy_c_buf_p = zconftext + 0;
#line 1479
      yy_act = (39 + (yy_start - 1) / 2) + 1;
#line 1480
      goto do_action;
#line 1488
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1492
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1495
      yy_current_state = yy_get_previous_state();
#line 1497
      yy_cp = yy_c_buf_p;
#line 1498
      yy_bp = zconftext + 0;
      }
#line 1499
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1502
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1505
      yy_current_state = yy_get_previous_state();
#line 1507
      yy_cp = yy_c_buf_p;
#line 1508
      yy_bp = zconftext + 0;
      }
#line 1509
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1511
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1515
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1528 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  yy_size_t new_size___0 ;
  void *tmp___8 ;

  {
#line 1530
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1531
  source = zconftext;
#line 1535
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1536
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1539
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1541
    if (yy_c_buf_p - zconftext == 1L) {
#line 1546
      return (1);
    } else {
#line 1554
      return (2);
    }
  }
#line 1561
  number_to_move = (int )(yy_c_buf_p - zconftext) - 1;
#line 1563
  i = 0;
  {
#line 1563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1563
    if (! (i < number_to_move)) {
#line 1563
      goto while_break;
    }
#line 1564
    tmp = dest;
#line 1564
    dest ++;
#line 1564
    tmp___0 = source;
#line 1564
    source ++;
#line 1564
    *tmp = *tmp___0;
#line 1563
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1566
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1570
    yy_n_chars = 0;
#line 1570
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1574
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1577
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1577
      if (! (num_to_read <= 0)) {
#line 1577
        goto while_break___0;
      }
#line 1581
      if (yy_buffer_stack) {
#line 1581
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1581
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1581
      b = tmp___1;
#line 1583
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1586
      if (b->yy_is_our_buffer) {
#line 1588
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1590
        if (new_size <= 0) {
#line 1591
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1593
          b->yy_buf_size *= 2UL;
        }
        {
#line 1595
        tmp___2 = zconfrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1595
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1601
        b->yy_ch_buf = (char *)0;
      }
#line 1603
      if (! b->yy_ch_buf) {
        {
#line 1604
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1607
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1609
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1614
    if (num_to_read > 8192) {
#line 1615
      num_to_read = 8192;
    }
    {
#line 1618
    tmp___3 = __errno_location();
#line 1618
    *tmp___3 = 0;
    }
    {
#line 1618
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1618
      tmp___6 = fileno(zconfin);
#line 1618
      tmp___7 = read(tmp___6, (void *)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                     (size_t )num_to_read);
#line 1618
      yy_n_chars = (int )tmp___7;
      }
#line 1618
      if (! (yy_n_chars < 0)) {
#line 1618
        goto while_break___1;
      }
      {
#line 1618
      tmp___4 = __errno_location();
      }
#line 1618
      if (*tmp___4 != 4) {
        {
#line 1618
        yy_fatal_error("input in flex scanner failed");
        }
#line 1618
        goto while_break___1;
      }
      {
#line 1618
      tmp___5 = __errno_location();
#line 1618
      *tmp___5 = 0;
#line 1618
      clearerr(zconfin);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1621
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1624
  if (yy_n_chars == 0) {
#line 1626
    if (number_to_move == 0) {
      {
#line 1628
      ret_val = 1;
#line 1629
      zconfrestart(zconfin);
      }
    } else {
#line 1634
      ret_val = 2;
#line 1635
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1641
    ret_val = 0;
  }
#line 1643
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1645
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1646
    tmp___8 = zconfrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                           new_size___0);
#line 1646
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___8;
    }
#line 1647
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1648
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1651
  yy_n_chars += number_to_move;
#line 1652
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1653
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1655
  zconftext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1657
  return (ret_val);
}
}
#line 1662 "scripts/kconfig/zconf.lex.c_shipped"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  flex_int32_t tmp ;

  {
#line 1667
  yy_current_state = yy_start;
#line 1669
  yy_cp = zconftext + 0;
  {
#line 1669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1669
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1669
      goto while_break;
    }
#line 1671
    if (*yy_cp) {
#line 1671
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1671
      tmp = (flex_int32_t const   )1;
    }
#line 1671
    yy_current_state = (yy_state_type )yy_nxt[yy_current_state][tmp];
#line 1669
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1674
  return (yy_current_state);
}
}
#line 1682 "scripts/kconfig/zconf.lex.c_shipped"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  int tmp ;

  {
#line 1686
  yy_current_state = (yy_state_type )yy_nxt[yy_current_state][1];
#line 1687
  yy_is_jam = yy_current_state <= 0;
#line 1689
  if (yy_is_jam) {
#line 1689
    tmp = 0;
  } else {
#line 1689
    tmp = yy_current_state;
  }
#line 1689
  return (tmp);
}
}
#line 1692 "scripts/kconfig/zconf.lex.c_shipped"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1696
  yy_cp = yy_c_buf_p;
#line 1699
  *yy_cp = yy_hold_char;
#line 1701
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1704
    number_to_move = yy_n_chars + 2;
#line 1705
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL);
#line 1707
    source = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1710
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1710
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1710
        goto while_break;
      }
#line 1711
      dest --;
#line 1711
      source --;
#line 1711
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1713
    yy_cp += (int )(dest - source);
#line 1714
    yy_bp += (int )(dest - source);
#line 1715
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1715
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1718
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1719
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1722
  yy_cp --;
#line 1722
  *yy_cp = (char )c;
#line 1724
  zconftext = yy_bp;
#line 1725
  yy_hold_char = *yy_cp;
#line 1726
  yy_c_buf_p = yy_cp;
#line 1727
  return;
}
}
#line 1808 "scripts/kconfig/zconf.lex.c_shipped"
void zconfrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1811
  if (yy_buffer_stack) {
#line 1811
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1811
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1811
  if (! tmp) {
    {
#line 1812
    zconfensure_buffer_stack();
#line 1813
    *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
    }
  }
#line 1817
  if (yy_buffer_stack) {
#line 1817
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1817
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1817
  zconf_init_buffer(tmp___0, input_file);
#line 1818
  zconf_load_buffer_state();
  }
#line 1819
  return;
}
}
#line 1825 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1833
  zconfensure_buffer_stack();
  }
#line 1834
  if (yy_buffer_stack) {
#line 1834
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1834
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1834
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1835
    return;
  }
#line 1837
  if (yy_buffer_stack) {
#line 1837
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1837
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1837
  if (tmp___0) {
#line 1840
    *yy_c_buf_p = yy_hold_char;
#line 1841
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1842
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1845
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1846
  zconf_load_buffer_state();
#line 1853
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1854
  return;
}
}
#line 1856 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_load_buffer_state(void) 
{ 


  {
#line 1858
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1859
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1859
  zconftext = yy_c_buf_p;
#line 1860
  zconfin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1861
  yy_hold_char = *yy_c_buf_p;
#line 1862
  return;
}
}
#line 1870 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1874
  tmp = zconfalloc(sizeof(struct yy_buffer_state ));
#line 1874
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1875
  if (! b) {
    {
#line 1876
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1878
  b->yy_buf_size = (yy_size_t )size;
#line 1883
  tmp___0 = zconfalloc(b->yy_buf_size + 2UL);
#line 1883
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1884
  if (! b->yy_ch_buf) {
    {
#line 1885
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1887
  b->yy_is_our_buffer = 1;
#line 1889
  zconf_init_buffer(b, file);
  }
#line 1891
  return (b);
}
}
#line 1898 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1901
  if (! b) {
#line 1902
    return;
  }
#line 1904
  if (yy_buffer_stack) {
#line 1904
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1904
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1904
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1905
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1907
  if (b->yy_is_our_buffer) {
    {
#line 1908
    zconffree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1910
  zconffree((void *)b);
  }
#line 1911
  return;
}
}
#line 1917 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1920
  tmp = __errno_location();
#line 1920
  oerrno = *tmp;
#line 1922
  zconf_flush_buffer(b);
#line 1924
  b->yy_input_file = file;
#line 1925
  b->yy_fill_buffer = 1;
  }
#line 1931
  if (yy_buffer_stack) {
#line 1931
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1931
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1931
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1932
    b->yy_bs_lineno = 1;
#line 1933
    b->yy_bs_column = 0;
  }
  {
#line 1936
  b->yy_is_interactive = 0;
#line 1938
  tmp___1 = __errno_location();
#line 1938
  *tmp___1 = oerrno;
  }
#line 1939
  return;
}
}
#line 1945 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1947
  if (! b) {
#line 1948
    return;
  }
#line 1950
  b->yy_n_chars = 0;
#line 1956
  *(b->yy_ch_buf + 0) = (char)0;
#line 1957
  *(b->yy_ch_buf + 1) = (char)0;
#line 1959
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1961
  b->yy_at_bol = 1;
#line 1962
  b->yy_buffer_status = 0;
#line 1964
  if (yy_buffer_stack) {
#line 1964
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1964
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1964
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1965
    zconf_load_buffer_state();
    }
  }
#line 1966
  return;
}
}
#line 1974 "scripts/kconfig/zconf.lex.c_shipped"
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1976
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1977
    return;
  }
  {
#line 1979
  zconfensure_buffer_stack();
  }
#line 1982
  if (yy_buffer_stack) {
#line 1982
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1982
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1982
  if (tmp) {
#line 1985
    *yy_c_buf_p = yy_hold_char;
#line 1986
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1987
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1991
  if (yy_buffer_stack) {
#line 1991
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1991
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1991
  if (tmp___0) {
#line 1992
    yy_buffer_stack_top ++;
  }
  {
#line 1993
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1996
  zconf_load_buffer_state();
#line 1997
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1998
  return;
}
}
#line 2004 "scripts/kconfig/zconf.lex.c_shipped"
void zconfpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2006
  if (yy_buffer_stack) {
#line 2006
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2006
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2006
  if (! tmp) {
#line 2007
    return;
  }
#line 2009
  if (yy_buffer_stack) {
#line 2009
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2009
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2009
  zconf_delete_buffer(tmp___0);
#line 2010
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2011
  if (yy_buffer_stack_top > 0UL) {
#line 2012
    yy_buffer_stack_top --;
  }
#line 2014
  if (yy_buffer_stack) {
#line 2014
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2014
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2014
  if (tmp___1) {
    {
#line 2015
    zconf_load_buffer_state();
#line 2016
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2018
  return;
}
}
#line 2023 "scripts/kconfig/zconf.lex.c_shipped"
static void zconfensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 2027
  if (! yy_buffer_stack) {
    {
#line 2033
    num_to_alloc = 1;
#line 2034
    tmp = zconfalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2034
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2037
    if (! yy_buffer_stack) {
      {
#line 2038
      yy_fatal_error("out of dynamic memory in zconfensure_buffer_stack()");
      }
    }
    {
#line 2040
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2042
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2043
    yy_buffer_stack_top = (size_t )0;
    }
#line 2044
    return;
  }
#line 2047
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 2050
    grow_size = 8;
#line 2052
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 2053
    tmp___0 = zconfrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2053
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2057
    if (! yy_buffer_stack) {
      {
#line 2058
      yy_fatal_error("out of dynamic memory in zconfensure_buffer_stack()");
      }
    }
    {
#line 2061
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2062
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2064
  return;
}
}
#line 2072 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2076
  if (size < 2UL) {
#line 2080
    return ((YY_BUFFER_STATE )0);
  } else
#line 2076
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2080
    return ((YY_BUFFER_STATE )0);
  } else
#line 2076
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2080
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2082
  tmp = zconfalloc(sizeof(struct yy_buffer_state ));
#line 2082
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2083
  if (! b) {
    {
#line 2084
    yy_fatal_error("out of dynamic memory in zconf_scan_buffer()");
    }
  }
  {
#line 2086
  b->yy_buf_size = size - 2UL;
#line 2087
  tmp___0 = base;
#line 2087
  b->yy_ch_buf = tmp___0;
#line 2087
  b->yy_buf_pos = tmp___0;
#line 2088
  b->yy_is_our_buffer = 0;
#line 2089
  b->yy_input_file = (FILE *)0;
#line 2090
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2091
  b->yy_is_interactive = 0;
#line 2092
  b->yy_at_bol = 1;
#line 2093
  b->yy_fill_buffer = 0;
#line 2094
  b->yy_buffer_status = 0;
#line 2096
  zconf_switch_to_buffer(b);
  }
#line 2098
  return (b);
}
}
#line 2109 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2112
  tmp = strlen(yystr);
#line 2112
  tmp___0 = zconf_scan_bytes(yystr, (int )tmp);
  }
#line 2112
  return (tmp___0);
}
}
#line 2122 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2130
  n = (yy_size_t )(_yybytes_len + 2);
#line 2131
  tmp = zconfalloc(n);
#line 2131
  buf = (char *)tmp;
  }
#line 2132
  if (! buf) {
    {
#line 2133
    yy_fatal_error("out of dynamic memory in zconf_scan_bytes()");
    }
  }
#line 2135
  i = 0;
  {
#line 2135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2135
    if (! (i < _yybytes_len)) {
#line 2135
      goto while_break;
    }
#line 2136
    *(buf + i) = (char )*(yybytes + i);
#line 2135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2138
  tmp___0 = (char)0;
#line 2138
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2138
  *(buf + _yybytes_len) = tmp___0;
#line 2140
  b = zconf_scan_buffer(buf, n);
  }
#line 2141
  if (! b) {
    {
#line 2142
    yy_fatal_error("bad buffer in zconf_scan_bytes()");
    }
  }
#line 2147
  b->yy_is_our_buffer = 1;
#line 2149
  return (b);
}
}
#line 2156 "scripts/kconfig/zconf.lex.c_shipped"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2159
  exit(2);
  }
}
}
#line 2184 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_lineno(void) 
{ 


  {
#line 2187
  return (zconflineno);
}
}
#line 2193 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfget_in(void) 
{ 


  {
#line 2195
  return (zconfin);
}
}
#line 2201 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfget_out(void) 
{ 


  {
#line 2203
  return (zconfout);
}
}
#line 2209 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_leng(void) 
{ 


  {
#line 2211
  return (zconfleng);
}
}
#line 2218 "scripts/kconfig/zconf.lex.c_shipped"
char *zconfget_text(void) 
{ 


  {
#line 2220
  return (zconftext);
}
}
#line 2227 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_lineno(int line_number ) 
{ 


  {
#line 2230
  zconflineno = line_number;
#line 2231
  return;
}
}
#line 2239 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_in(FILE *in_str ) 
{ 


  {
#line 2241
  zconfin = in_str;
#line 2242
  return;
}
}
#line 2244 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_out(FILE *out_str ) 
{ 


  {
#line 2246
  zconfout = out_str;
#line 2247
  return;
}
}
#line 2249 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_debug(void) 
{ 


  {
#line 2251
  return (zconf_flex_debug);
}
}
#line 2254 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_debug(int bdebug ) 
{ 


  {
#line 2256
  zconf_flex_debug = bdebug;
#line 2257
  return;
}
}
#line 2259 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_init_globals(void) 
{ 


  {
#line 2265
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2266
  yy_buffer_stack_top = (size_t )0;
#line 2267
  yy_buffer_stack_max = (size_t )0;
#line 2268
  yy_c_buf_p = (char *)0;
#line 2269
  yy_init = 0;
#line 2270
  yy_start = 0;
#line 2277
  zconfin = (FILE *)0;
#line 2278
  zconfout = (FILE *)0;
#line 2284
  return (0);
}
}
#line 2288 "scripts/kconfig/zconf.lex.c_shipped"
int zconflex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2292
    if (yy_buffer_stack) {
#line 2292
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2292
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2292
    if (! tmp___0) {
#line 2292
      goto while_break;
    }
#line 2293
    if (yy_buffer_stack) {
#line 2293
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2293
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2293
    zconf_delete_buffer(tmp);
#line 2294
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2295
    zconfpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2299
  zconffree((void *)yy_buffer_stack);
#line 2300
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2304
  yy_init_globals();
  }
#line 2306
  return (0);
}
}
#line 2333 "scripts/kconfig/zconf.lex.c_shipped"
void *zconfalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2335
  tmp = malloc(size);
  }
#line 2335
  return (tmp);
}
}
#line 2338 "scripts/kconfig/zconf.lex.c_shipped"
void *zconfrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2347
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2347
  return (tmp);
}
}
#line 2350 "scripts/kconfig/zconf.lex.c_shipped"
void zconffree(void *ptr ) 
{ 


  {
  {
#line 2352
  free((void *)((char *)ptr));
  }
#line 2353
  return;
}
}
#line 2357 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_starthelp(void) 
{ 


  {
  {
#line 2359
  new_string();
#line 2360
  first_ts = 0;
#line 2360
  last_ts = first_ts;
#line 2361
  yy_start = 5;
  }
#line 2362
  return;
}
}
#line 2364 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_endhelp(void) 
{ 


  {
#line 2366
  zconflval.string = text;
#line 2367
  yy_start = 1;
#line 2368
  return;
}
}
#line 2378 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconf_fopen(char const   *name ) 
{ 
  char *env ;
  char fullname___0[4097] ;
  FILE *f ;

  {
  {
#line 2383
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 2384
  if (! f) {
#line 2384
    if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 2384
      if ((int const   )*(name + 0) != 47) {
        {
#line 2385
        env = getenv("srctree");
        }
#line 2386
        if (env) {
          {
#line 2387
          sprintf((char */* __restrict  */)(fullname___0), (char const   */* __restrict  */)"%s/%s",
                  env, name);
#line 2388
          f = fopen((char const   */* __restrict  */)(fullname___0), (char const   */* __restrict  */)"r");
          }
        }
      }
    }
  }
#line 2391
  return (f);
}
}
#line 2394 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_initscan(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 2396
  zconfin = zconf_fopen(name);
  }
#line 2397
  if (! zconfin) {
    {
#line 2398
    printf((char const   */* __restrict  */)"can\'t find file %s\n", name);
#line 2399
    exit(1);
    }
  }
  {
#line 2402
  tmp = xmalloc(sizeof(*current_buf));
#line 2402
  current_buf = (struct buffer *)tmp;
#line 2403
  memset((void *)current_buf, 0, sizeof(*current_buf));
#line 2405
  current_file = file_lookup(name);
#line 2406
  current_file->lineno = 1;
  }
#line 2407
  return;
}
}
#line 2409 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_nextfile(char const   *name ) 
{ 
  struct file *iter ;
  struct file *file ;
  struct file *tmp ;
  struct buffer *buf ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2412
  tmp = file_lookup(name);
#line 2412
  file = tmp;
#line 2413
  tmp___0 = xmalloc(sizeof(*buf));
#line 2413
  buf = (struct buffer *)tmp___0;
#line 2414
  memset((void *)buf, 0, sizeof(*buf));
  }
#line 2416
  if (yy_buffer_stack) {
#line 2416
    current_buf->state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2416
    current_buf->state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2417
  zconfin = zconf_fopen(file->name);
  }
#line 2418
  if (! zconfin) {
    {
#line 2419
    tmp___1 = zconf_lineno();
#line 2419
    tmp___2 = zconf_curname();
#line 2419
    printf((char const   */* __restrict  */)"%s:%d: can\'t open file \"%s\"\n", tmp___2,
           tmp___1, file->name);
#line 2421
    exit(1);
    }
  }
  {
#line 2423
  tmp___3 = zconf_create_buffer(zconfin, 16384);
#line 2423
  zconf_switch_to_buffer(tmp___3);
#line 2424
  buf->parent = current_buf;
#line 2425
  current_buf = buf;
#line 2427
  iter = current_file->parent;
  }
  {
#line 2427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2427
    if (! iter) {
#line 2427
      goto while_break;
    }
    {
#line 2428
    tmp___8 = strcmp(current_file->name, iter->name);
    }
#line 2428
    if (! tmp___8) {
      {
#line 2429
      tmp___4 = zconf_curname();
#line 2429
      tmp___5 = zconf_lineno();
#line 2429
      tmp___6 = zconf_curname();
#line 2429
      printf((char const   */* __restrict  */)"%s:%d: recursive inclusion detected. Inclusion path:\n  current file : \'%s\'\n",
             tmp___6, tmp___5, tmp___4);
#line 2433
      iter = current_file->parent;
      }
      {
#line 2434
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2434
        if (iter) {
          {
#line 2434
          tmp___7 = strcmp(iter->name, current_file->name);
          }
#line 2434
          if (! tmp___7) {
#line 2434
            goto while_break___0;
          }
        } else {
#line 2434
          goto while_break___0;
        }
        {
#line 2436
        printf((char const   */* __restrict  */)"  included from: \'%s:%d\'\n", iter->name,
               iter->lineno - 1);
#line 2438
        iter = iter->parent;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2440
      if (iter) {
        {
#line 2441
        printf((char const   */* __restrict  */)"  included from: \'%s:%d\'\n", iter->name,
               iter->lineno + 1);
        }
      }
      {
#line 2443
      exit(1);
      }
    }
#line 2427
    iter = iter->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 2446
  file->lineno = 1;
#line 2447
  file->parent = current_file;
#line 2448
  current_file = file;
#line 2449
  return;
}
}
#line 2451 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_endfile(void) 
{ 
  struct buffer *parent ;
  YY_BUFFER_STATE tmp ;

  {
#line 2455
  current_file = current_file->parent;
#line 2457
  parent = current_buf->parent;
#line 2458
  if (parent) {
    {
#line 2459
    fclose(zconfin);
    }
#line 2460
    if (yy_buffer_stack) {
#line 2460
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2460
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2460
    zconf_delete_buffer(tmp);
#line 2461
    zconf_switch_to_buffer(parent->state);
    }
  }
  {
#line 2463
  free((void *)current_buf);
#line 2464
  current_buf = parent;
  }
#line 2465
  return;
}
}
#line 2467 "scripts/kconfig/zconf.lex.c_shipped"
int zconf_lineno(void) 
{ 


  {
#line 2469
  return (current_pos.lineno);
}
}
#line 2472 "scripts/kconfig/zconf.lex.c_shipped"
char const   *zconf_curname(void) 
{ 
  char const   *tmp ;

  {
#line 2474
  if (current_pos.file) {
#line 2474
    tmp = (current_pos.file)->name;
  } else {
#line 2474
    tmp = "<none>";
  }
#line 2474
  return (tmp);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
struct file *file_lookup(char const   *name ) 
{ 
  struct file *file ;
  char const   *file_name ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 17
  tmp = sym_expand_string_value(name);
#line 17
  file_name = tmp;
#line 19
  file = file_list;
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! file) {
#line 19
      goto while_break;
    }
    {
#line 20
    tmp___0 = strcmp(name, file->name);
    }
#line 20
    if (! tmp___0) {
      {
#line 21
      free((void *)file_name);
      }
#line 22
      return (file);
    }
#line 19
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26
  tmp___1 = xmalloc(sizeof(*file));
#line 26
  file = (struct file *)tmp___1;
#line 27
  memset((void *)file, 0, sizeof(*file));
#line 28
  file->name = file_name;
#line 29
  file->next = file_list;
#line 30
  file_list = file;
  }
#line 31
  return (file);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
int file_write_dep(char const   *name ) 
{ 
  struct symbol *sym ;
  struct symbol *env_sym ;
  struct expr *e ;
  struct file *file ;
  FILE *out ;
  char const   *tmp ;
  struct property *prop ;
  char const   *value ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 42
  if (! name) {
#line 43
    name = ".kconfig.d";
  }
  {
#line 44
  out = fopen((char const   */* __restrict  */)"..config.tmp", (char const   */* __restrict  */)"w");
  }
#line 45
  if (! out) {
#line 46
    return (1);
  }
  {
#line 47
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"deps_config := \\\n");
#line 48
  file = file_list;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! file) {
#line 48
      goto while_break;
    }
#line 49
    if (file->next) {
      {
#line 50
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s \\\n",
              file->name);
      }
    } else {
      {
#line 52
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s\n",
              file->name);
      }
    }
#line 48
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  tmp = conf_get_autoconfig_name();
#line 54
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n%s: \\\n\t$(deps_config)\n\n",
          tmp);
#line 57
  e = sym_env_list;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (e) {
#line 57
      sym = e->right.sym;
#line 57
      if (! sym) {
#line 57
        goto while_break___0;
      }
    } else {
#line 57
      goto while_break___0;
    }
    {
#line 61
    prop = sym_get_env_prop(sym);
#line 62
    env_sym = prop_get_symbol(prop);
    }
#line 63
    if (! env_sym) {
#line 64
      goto __Cont;
    }
    {
#line 65
    tmp___0 = getenv((char const   *)env_sym->name);
#line 65
    value = (char const   *)tmp___0;
    }
#line 66
    if (! value) {
#line 67
      value = "";
    }
    {
#line 68
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"ifneq \"$(%s)\" \"%s\"\n",
            env_sym->name, value);
#line 69
    tmp___1 = conf_get_autoconfig_name();
#line 69
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: FORCE\n",
            tmp___1);
#line 70
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"endif\n");
    }
    __Cont: /* CIL Label */ 
#line 57
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n$(deps_config): ;\n");
#line 74
  fclose(out);
#line 75
  rename("..config.tmp", name);
  }
#line 76
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
struct gstr str_new(void) 
{ 
  struct gstr gs ;
  void *tmp ;

  {
  {
#line 84
  tmp = xmalloc(sizeof(char ) * 64UL);
#line 84
  gs.s = (char *)tmp;
#line 85
  gs.len = (size_t )64;
#line 86
  gs.max_width = 0;
#line 87
  strcpy((char */* __restrict  */)gs.s, (char const   */* __restrict  */)"\000");
  }
#line 88
  return (gs);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
void str_free(struct gstr *gs ) 
{ 


  {
#line 94
  if (gs->s) {
    {
#line 95
    free((void *)gs->s);
    }
  }
#line 96
  gs->s = (char *)((void *)0);
#line 97
  gs->len = (size_t )0;
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
void str_append(struct gstr *gs , char const   *s ) 
{ 
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 104
  if (s) {
    {
#line 105
    tmp = strlen((char const   *)gs->s);
#line 105
    tmp___0 = strlen(s);
#line 105
    l = (tmp + tmp___0) + 1UL;
    }
#line 106
    if (l > gs->len) {
      {
#line 107
      tmp___1 = realloc((void *)gs->s, l);
#line 107
      gs->s = (char *)tmp___1;
#line 108
      gs->len = l;
      }
    }
    {
#line 110
    strcat((char */* __restrict  */)gs->s, (char const   */* __restrict  */)s);
    }
  }
#line 112
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
void str_printf(struct gstr *gs , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char s[10000] ;

  {
  {
#line 119
  __builtin_va_start(ap, fmt);
#line 120
  vsnprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)fmt,
            ap);
#line 121
  str_append(gs, (char const   *)(s));
#line 122
  __builtin_va_end(ap);
  }
#line 123
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
char const   *str_get(struct gstr *gs ) 
{ 


  {
#line 128
  return ((char const   *)gs->s);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
void *xmalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 133
  tmp = malloc(size);
#line 133
  p = tmp;
  }
#line 134
  if (p) {
#line 135
    return (p);
  }
  {
#line 136
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 137
  exit(1);
  }
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/util.c"
void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 142
  tmp = calloc(nmemb, size);
#line 142
  p = tmp;
  }
#line 143
  if (p) {
#line 144
    return (p);
  }
  {
#line 145
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 146
  exit(1);
  }
}
}
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) ;
#line 27
static void ( /* format attribute */  conf_message)(char const   *fmt  , ...) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static char const   *conf_filename  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int conf_lineno  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int conf_warnings  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int conf_unsaved  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
char const   conf_defname[21]  = 
#line 33
  {      (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'/',      (char const   )'$',      (char const   )'A',      (char const   )'R', 
        (char const   )'C',      (char const   )'H',      (char const   )'/',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'f',      (char const   )'i',      (char const   )'g', 
        (char const   )'\000'};
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 38
  __builtin_va_start(ap, fmt);
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          conf_filename, conf_lineno);
#line 40
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 42
  __builtin_va_end(ap);
#line 43
  conf_warnings ++;
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void conf_default_message_callback(char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 48
  printf((char const   */* __restrict  */)"#\n# ");
#line 49
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 50
  printf((char const   */* __restrict  */)"\n#\n");
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void (*conf_message_callback)(char const   *fmt , va_list ap )  =    & conf_default_message_callback;
#line 55 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
void conf_set_message_callback(void (*fn)(char const   *fmt , va_list ap ) ) 
{ 


  {
#line 57
  conf_message_callback = fn;
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_message)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 64
  __builtin_va_start(ap, fmt);
  }
#line 65
  if (conf_message_callback) {
    {
#line 66
    (*conf_message_callback)(fmt, ap);
    }
  }
  {
#line 67
  __builtin_va_end(ap);
  }
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
char const   *conf_get_configname(void) 
{ 
  char *name ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 72
  tmp = getenv("KCONFIG_CONFIG");
#line 72
  name = tmp;
  }
#line 74
  if (name) {
#line 74
    tmp___0 = (char const   *)name;
  } else {
#line 74
    tmp___0 = ".config";
  }
#line 74
  return (tmp___0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
char const   *conf_get_autoconfig_name(void) 
{ 
  char *name ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 79
  tmp = getenv("KCONFIG_AUTOCONFIG");
#line 79
  name = tmp;
  }
#line 81
  if (name) {
#line 81
    tmp___0 = (char const   *)name;
  } else {
#line 81
    tmp___0 = "include/config/auto.conf";
  }
#line 81
  return (tmp___0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static char res_value[256]  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static char *conf_expand_value(char const   *in ) 
{ 
  struct symbol *sym ;
  char const   *src ;
  char *dst ;
  char name[256] ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 91
  res_value[0] = (char)0;
#line 92
  dst = name;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp___3 = strchr(in, '$');
#line 93
    src = (char const   *)tmp___3;
    }
#line 93
    if (! src) {
#line 93
      goto while_break;
    }
    {
#line 94
    strncat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in,
            (size_t )(src - in));
#line 95
    src ++;
#line 96
    dst = name;
    }
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 97
      tmp___1 = __ctype_b_loc();
      }
#line 97
      if (! ((int const   )*(*tmp___1 + (int )*src) & 8)) {
#line 97
        if (! ((int const   )*src == 95)) {
#line 97
          goto while_break___0;
        }
      }
#line 98
      tmp = dst;
#line 98
      dst ++;
#line 98
      tmp___0 = src;
#line 98
      src ++;
#line 98
      *tmp = (char )*tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 99
    *dst = (char)0;
#line 100
    sym = sym_lookup((char const   *)(name), 0);
#line 101
    sym_calc_value(sym);
#line 102
    tmp___2 = sym_get_string_value(sym);
#line 102
    strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)tmp___2);
#line 103
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in);
  }
#line 107
  return (res_value);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static char fullname[4097]  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
char *conf_get_default_confname(void) 
{ 
  struct stat buf ;
  char *env ;
  char *name ;
  int tmp ;

  {
  {
#line 116
  name = conf_expand_value(conf_defname);
#line 117
  env = getenv("srctree");
  }
#line 118
  if (env) {
    {
#line 119
    sprintf((char */* __restrict  */)(fullname), (char const   */* __restrict  */)"%s/%s",
            env, name);
#line 120
    tmp = stat((char const   */* __restrict  */)(fullname), (struct stat */* __restrict  */)(& buf));
    }
#line 120
    if (! tmp) {
#line 121
      return (fullname);
    }
  }
#line 123
  return (name);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int conf_set_sym_val(struct symbol *sym , int def , int def_flags , char *p ) 
{ 
  char *p2 ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 131
  if ((unsigned int )sym->type == 2U) {
#line 131
    goto case_2;
  }
#line 138
  if ((unsigned int )sym->type == 1U) {
#line 138
    goto case_1;
  }
#line 153
  if ((unsigned int )sym->type == 6U) {
#line 153
    goto case_6;
  }
#line 161
  if ((unsigned int )sym->type == 5U) {
#line 161
    goto case_5;
  }
#line 178
  if ((unsigned int )sym->type == 4U) {
#line 178
    goto done;
  }
#line 178
  if ((unsigned int )sym->type == 3U) {
#line 178
    goto done;
  }
#line 190
  goto switch_default;
  case_2: /* CIL Label */ 
#line 132
  if ((int )*(p + 0) == 109) {
#line 133
    sym->def[def].tri = (tristate )1;
#line 134
    sym->flags |= def_flags;
#line 135
    goto switch_break;
  }
  case_1: /* CIL Label */ 
#line 139
  if ((int )*(p + 0) == 121) {
#line 140
    sym->def[def].tri = (tristate )2;
#line 141
    sym->flags |= def_flags;
#line 142
    goto switch_break;
  }
#line 144
  if ((int )*(p + 0) == 110) {
#line 145
    sym->def[def].tri = (tristate )0;
#line 146
    sym->flags |= def_flags;
#line 147
    goto switch_break;
  }
#line 149
  if (def != 1) {
    {
#line 150
    conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
    }
  }
#line 152
  return (1);
  case_6: /* CIL Label */ 
#line 154
  if ((int )*p != 34) {
#line 155
    p2 = p;
    {
#line 155
    while (1) {
      while_continue: /* CIL Label */ ;
#line 155
      if (*p2) {
        {
#line 155
        tmp = __ctype_b_loc();
        }
#line 155
        if ((int const   )*(*tmp + (int )*p2) & 8192) {
#line 155
          goto while_break;
        }
      } else {
#line 155
        goto while_break;
      }
#line 155
      p2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 157
    sym->type = (enum symbol_type )5;
#line 158
    goto done;
  }
  case_5: /* CIL Label */ 
#line 162
  tmp___0 = p;
#line 162
  p ++;
#line 162
  if ((int )*tmp___0 != 34) {
#line 163
    goto switch_break;
  }
#line 164
  p2 = p;
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 164
    p2 = strpbrk((char const   *)p2, "\"\\");
    }
#line 164
    if (! p2) {
#line 164
      goto while_break___0;
    }
#line 165
    if ((int )*p2 == 34) {
#line 166
      *p2 = (char)0;
#line 167
      goto while_break___0;
    }
    {
#line 169
    tmp___1 = strlen((char const   *)p2);
#line 169
    memmove((void *)p2, (void const   *)(p2 + 1), tmp___1);
#line 164
    p2 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 171
  if (! p2) {
#line 172
    if (def != 1) {
      {
#line 173
      conf_warning("invalid string found");
      }
    }
#line 174
    return (1);
  }
  done: 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 180
  tmp___3 = sym_string_valid(sym, (char const   *)p);
  }
#line 180
  if (tmp___3) {
    {
#line 181
    tmp___2 = strdup((char const   *)p);
#line 181
    sym->def[def].val = (void *)tmp___2;
#line 182
    sym->flags |= def_flags;
    }
  } else {
#line 184
    if (def != 1) {
      {
#line 185
      conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
      }
    }
#line 187
    return (1);
  }
#line 189
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 193
  return (0);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int add_byte(int c , char **lineptr , size_t slen , size_t *n ) 
{ 
  char *nline ;
  size_t new_size ;
  void *tmp ;

  {
#line 200
  new_size = slen + 1UL;
#line 201
  if (new_size > *n) {
    {
#line 202
    new_size += 15UL;
#line 203
    new_size *= 2UL;
#line 204
    tmp = realloc((void *)*lineptr, new_size);
#line 204
    nline = (char *)tmp;
    }
#line 205
    if (! nline) {
#line 206
      return (-1);
    }
#line 208
    *lineptr = nline;
#line 209
    *n = new_size;
  }
#line 212
  *(*lineptr + slen) = (char )c;
#line 214
  return (0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static ssize_t compat_getline(char **lineptr , size_t *n , FILE *stream ) 
{ 
  char *line___0 ;
  size_t slen ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 219
  line___0 = *lineptr;
#line 220
  slen = (size_t )0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp = _IO_getc(stream);
#line 223
    c = tmp;
    }
    {
#line 226
    if (c == 10) {
#line 226
      goto case_10;
    }
#line 231
    if (c == -1) {
#line 231
      goto case_neg_1;
    }
#line 238
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 227
    tmp___0 = add_byte(c, & line___0, slen, n);
    }
#line 227
    if (tmp___0 < 0) {
#line 228
      goto e_out;
    }
#line 229
    slen ++;
    case_neg_1: /* CIL Label */ 
    {
#line 232
    tmp___1 = add_byte('\000', & line___0, slen, n);
    }
#line 232
    if (tmp___1 < 0) {
#line 233
      goto e_out;
    }
#line 234
    *lineptr = line___0;
#line 235
    if (slen == 0UL) {
#line 236
      return ((ssize_t )-1);
    }
#line 237
    return ((ssize_t )slen);
    switch_default: /* CIL Label */ 
    {
#line 239
    tmp___2 = add_byte(c, & line___0, slen, n);
    }
#line 239
    if (tmp___2 < 0) {
#line 240
      goto e_out;
    }
#line 241
    slen ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  e_out: 
#line 246
  *(line___0 + (slen - 1UL)) = (char )'\000';
#line 247
  *lineptr = line___0;
#line 248
  return ((ssize_t )-1);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
int conf_read_simple(char const   *name , int def ) 
{ 
  FILE *in ;
  char *line___0 ;
  size_t line_asize ;
  char *p ;
  char *p2 ;
  struct symbol *sym ;
  int i ;
  int def_flags ;
  struct property *prop ;
  tristate tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  char const   *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  char const   *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  size_t tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  struct symbol *cs ;
  struct property *tmp___28 ;
  struct symbol *tmp___29 ;
  _Bool tmp___30 ;
  ssize_t tmp___31 ;

  {
#line 253
  in = (FILE *)((void *)0);
#line 254
  line___0 = (char *)((void *)0);
#line 255
  line_asize = (size_t )0;
#line 260
  if (name) {
    {
#line 261
    in = zconf_fopen(name);
    }
  } else {
    {
#line 265
    name = conf_get_configname();
#line 266
    in = zconf_fopen(name);
    }
#line 267
    if (in) {
#line 268
      goto load;
    }
    {
#line 269
    sym_add_change_count(1);
    }
#line 270
    if (! sym_defconfig_list) {
#line 271
      if (modules_sym) {
        {
#line 272
        sym_calc_value(modules_sym);
        }
      }
#line 273
      return (1);
    }
#line 276
    prop = sym_defconfig_list->prop;
    {
#line 276
    while (1) {
      while_continue: /* CIL Label */ ;
#line 276
      if (! prop) {
#line 276
        goto while_break;
      }
#line 276
      if ((unsigned int )prop->type == 4U) {
        {
#line 277
        tmp = expr_calc_value(prop->visible.expr);
        }
#line 277
        if ((unsigned int )tmp == 0U) {
#line 279
          goto __Cont;
        } else
#line 277
        if ((unsigned int )(prop->expr)->type != 11U) {
#line 279
          goto __Cont;
        }
        {
#line 280
        tmp___0 = conf_expand_value((char const   *)((prop->expr)->left.sym)->name);
#line 280
        name = (char const   *)tmp___0;
#line 281
        in = zconf_fopen(name);
        }
#line 282
        if (in) {
          {
#line 283
          tmp___1 = gettext("using defaults found in %s");
#line 283
          conf_message((char const   *)tmp___1, name);
          }
#line 285
          goto load;
        }
      }
      __Cont: /* CIL Label */ 
#line 276
      prop = prop->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 289
  if (! in) {
#line 290
    return (1);
  }
  load: 
#line 293
  conf_filename = name;
#line 294
  conf_lineno = 0;
#line 295
  conf_warnings = 0;
#line 296
  conf_unsaved = 0;
#line 298
  def_flags = 65536 << def;
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (i < 9973)) {
#line 299
      goto while_break___0;
    }
#line 299
    sym = symbol_hash[i];
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 299
      if (! sym) {
#line 299
        goto while_break___1;
      }
#line 299
      if ((unsigned int )sym->type != 6U) {
        {
#line 300
        sym->flags |= 1024;
#line 301
        sym->flags &= ~ (def_flags | 128);
#line 302
        tmp___2 = sym_is_choice(sym);
        }
#line 302
        if (tmp___2) {
#line 303
          sym->flags |= def_flags;
        }
        {
#line 307
        if ((unsigned int )sym->type == 5U) {
#line 307
          goto case_5;
        }
#line 307
        if ((unsigned int )sym->type == 4U) {
#line 307
          goto case_5;
        }
#line 307
        if ((unsigned int )sym->type == 3U) {
#line 307
          goto case_5;
        }
#line 311
        goto switch_default;
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 308
        if (sym->def[def].val) {
          {
#line 309
          free(sym->def[def].val);
          }
        }
        switch_default: /* CIL Label */ 
#line 312
        sym->def[def].val = (void *)0;
#line 313
        sym->def[def].tri = (tristate )0;
        switch_break: /* CIL Label */ ;
        }
      }
#line 299
      sym = sym->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 299
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 317
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 317
    tmp___31 = compat_getline(& line___0, & line_asize, in);
    }
#line 317
    if (! (tmp___31 != -1L)) {
#line 317
      goto while_break___2;
    }
#line 318
    conf_lineno ++;
#line 319
    sym = (struct symbol *)((void *)0);
#line 320
    if ((int )*(line___0 + 0) == 35) {
      {
#line 321
      tmp___3 = CONFIG_prefix();
#line 321
      tmp___4 = strlen(tmp___3);
#line 321
      tmp___5 = CONFIG_prefix();
#line 321
      tmp___6 = memcmp((void const   *)(line___0 + 2), (void const   *)tmp___5, tmp___4);
      }
#line 321
      if (tmp___6) {
#line 322
        goto while_continue___2;
      }
      {
#line 323
      tmp___7 = CONFIG_prefix();
#line 323
      tmp___8 = strlen(tmp___7);
#line 323
      p = strchr((char const   *)((line___0 + 2) + tmp___8), ' ');
      }
#line 324
      if (! p) {
#line 325
        goto while_continue___2;
      }
      {
#line 326
      tmp___9 = p;
#line 326
      p ++;
#line 326
      *tmp___9 = (char)0;
#line 327
      tmp___10 = strncmp((char const   *)p, "is not set", (size_t )10);
      }
#line 327
      if (tmp___10) {
#line 328
        goto while_continue___2;
      }
#line 329
      if (def == 0) {
        {
#line 330
        tmp___11 = CONFIG_prefix();
#line 330
        tmp___12 = strlen(tmp___11);
#line 330
        sym = sym_find((char const   *)((line___0 + 2) + tmp___12));
        }
#line 331
        if (! sym) {
          {
#line 332
          sym_add_change_count(1);
          }
#line 333
          goto setsym;
        }
      } else {
        {
#line 336
        tmp___13 = CONFIG_prefix();
#line 336
        tmp___14 = strlen(tmp___13);
#line 336
        sym = sym_lookup((char const   *)((line___0 + 2) + tmp___14), 0);
        }
#line 337
        if ((unsigned int )sym->type == 0U) {
#line 338
          sym->type = (enum symbol_type )1;
        }
      }
#line 340
      if (sym->flags & def_flags) {
        {
#line 341
        conf_warning("override: reassigning to symbol %s", sym->name);
        }
      }
      {
#line 345
      if ((unsigned int )sym->type == 2U) {
#line 345
        goto case_2;
      }
#line 345
      if ((unsigned int )sym->type == 1U) {
#line 345
        goto case_2;
      }
#line 349
      goto switch_default___0;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 346
      sym->def[def].tri = (tristate )0;
#line 347
      sym->flags |= def_flags;
#line 348
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 352
      tmp___24 = CONFIG_prefix();
#line 352
      tmp___25 = strlen(tmp___24);
#line 352
      tmp___26 = CONFIG_prefix();
#line 352
      tmp___27 = memcmp((void const   *)line___0, (void const   *)tmp___26, tmp___25);
      }
#line 352
      if (tmp___27 == 0) {
        {
#line 353
        tmp___15 = CONFIG_prefix();
#line 353
        tmp___16 = strlen(tmp___15);
#line 353
        p = strchr((char const   *)(line___0 + tmp___16), '=');
        }
#line 354
        if (! p) {
#line 355
          goto while_continue___2;
        }
        {
#line 356
        tmp___17 = p;
#line 356
        p ++;
#line 356
        *tmp___17 = (char)0;
#line 357
        p2 = strchr((char const   *)p, '\n');
        }
#line 358
        if (p2) {
#line 359
          tmp___18 = p2;
#line 359
          p2 --;
#line 359
          *tmp___18 = (char)0;
#line 360
          if ((int )*p2 == 13) {
#line 361
            *p2 = (char)0;
          }
        }
#line 363
        if (def == 0) {
          {
#line 364
          tmp___19 = CONFIG_prefix();
#line 364
          tmp___20 = strlen(tmp___19);
#line 364
          sym = sym_find((char const   *)(line___0 + tmp___20));
          }
#line 365
          if (! sym) {
            {
#line 366
            sym_add_change_count(1);
            }
#line 367
            goto setsym;
          }
        } else {
          {
#line 370
          tmp___21 = CONFIG_prefix();
#line 370
          tmp___22 = strlen(tmp___21);
#line 370
          sym = sym_lookup((char const   *)(line___0 + tmp___22), 0);
          }
#line 371
          if ((unsigned int )sym->type == 0U) {
#line 372
            sym->type = (enum symbol_type )6;
          }
        }
#line 374
        if (sym->flags & def_flags) {
          {
#line 375
          conf_warning("override: reassigning to symbol %s", sym->name);
          }
        }
        {
#line 377
        tmp___23 = conf_set_sym_val(sym, def, def_flags, p);
        }
#line 377
        if (tmp___23) {
#line 378
          goto while_continue___2;
        }
      } else {
#line 380
        if ((int )*(line___0 + 0) != 13) {
#line 380
          if ((int )*(line___0 + 0) != 10) {
            {
#line 381
            conf_warning("unexpected data");
            }
          }
        }
#line 382
        goto while_continue___2;
      }
    }
    setsym: 
#line 385
    if (sym) {
      {
#line 385
      tmp___30 = sym_is_choice_value(sym);
      }
#line 385
      if (tmp___30) {
        {
#line 386
        tmp___28 = sym_get_choice_prop(sym);
#line 386
        tmp___29 = prop_get_symbol(tmp___28);
#line 386
        cs = tmp___29;
        }
        {
#line 388
        if ((unsigned int )sym->def[def].tri == 0U) {
#line 388
          goto case_0;
        }
#line 390
        if ((unsigned int )sym->def[def].tri == 1U) {
#line 390
          goto case_1___0;
        }
#line 396
        if ((unsigned int )sym->def[def].tri == 2U) {
#line 396
          goto case_2___0;
        }
#line 387
        goto switch_break___1;
        case_0: /* CIL Label */ 
#line 389
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
#line 391
        if ((unsigned int )cs->def[def].tri == 2U) {
          {
#line 392
          conf_warning("%s creates inconsistent choice state", sym->name);
#line 393
          cs->flags &= ~ def_flags;
          }
        }
#line 395
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
#line 397
        if ((unsigned int )cs->def[def].tri != 0U) {
          {
#line 398
          conf_warning("override: %s changes choice state", sym->name);
          }
        }
#line 399
        cs->def[def].val = (void *)sym;
#line 400
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 402
        if ((unsigned int )cs->def[def].tri > (unsigned int )sym->def[def].tri) {
#line 402
          cs->def[def].tri = cs->def[def].tri;
        } else {
#line 402
          cs->def[def].tri = sym->def[def].tri;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 405
  free((void *)line___0);
#line 406
  fclose(in);
  }
#line 408
  if (modules_sym) {
    {
#line 409
    sym_calc_value(modules_sym);
    }
  }
#line 410
  return (0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
int conf_read(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;
  int tmp ;
  _Bool tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;

  {
  {
#line 418
  sym_set_change_count(0);
#line 420
  tmp = conf_read_simple(name, 0);
  }
#line 420
  if (tmp) {
#line 421
    return (1);
  }
#line 423
  i = 0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < 9973)) {
#line 423
      goto while_break;
    }
#line 423
    sym = symbol_hash[i];
    {
#line 423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 423
      if (! sym) {
#line 423
        goto while_break___0;
      }
#line 423
      if ((unsigned int )sym->type != 6U) {
        {
#line 424
        sym_calc_value(sym);
#line 425
        tmp___0 = sym_is_choice(sym);
        }
#line 425
        if (tmp___0) {
#line 426
          goto __Cont;
        } else
#line 425
        if (sym->flags & 4096) {
#line 426
          goto __Cont;
        }
        {
#line 427
        tmp___5 = sym_has_value(sym);
        }
#line 427
        if (tmp___5) {
#line 427
          if (sym->flags & 512) {
            {
#line 431
            if ((unsigned int )sym->type == 2U) {
#line 431
              goto case_2;
            }
#line 431
            if ((unsigned int )sym->type == 1U) {
#line 431
              goto case_2;
            }
#line 437
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 432
            tmp___1 = sym_get_tristate_value(sym);
            }
#line 432
            if ((unsigned int )sym->def[0].tri != (unsigned int )tmp___1) {
#line 433
              goto switch_break;
            }
            {
#line 434
            tmp___2 = sym_is_choice(sym);
            }
#line 434
            if (! tmp___2) {
#line 435
              goto __Cont;
            }
            switch_default: /* CIL Label */ 
            {
#line 438
            tmp___3 = strcmp((char const   *)sym->curr.val, (char const   *)sym->def[0].val);
            }
#line 438
            if (! tmp___3) {
#line 439
              goto __Cont;
            }
#line 440
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 427
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 442
          tmp___4 = sym_has_value(sym);
          }
#line 442
          if (! tmp___4) {
#line 442
            if (! (sym->flags & 512)) {
#line 444
              goto __Cont;
            }
          }
        }
#line 445
        conf_unsaved ++;
      }
      __Cont: /* CIL Label */ 
#line 423
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  i = 0;
  {
#line 449
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 449
    if (! (i < 9973)) {
#line 449
      goto while_break___1;
    }
#line 449
    sym = symbol_hash[i];
    {
#line 449
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 449
      if (! sym) {
#line 449
        goto while_break___2;
      }
#line 449
      if ((unsigned int )sym->type != 6U) {
        {
#line 450
        tmp___7 = sym_has_value(sym);
        }
#line 450
        if (tmp___7) {
          {
#line 450
          tmp___8 = sym_is_choice_value(sym);
          }
#line 450
          if (! tmp___8) {
#line 456
            if ((unsigned int )sym->visible == 0U) {
#line 456
              if (! conf_unsaved) {
#line 457
                sym->flags &= -65537;
              }
            }
            {
#line 461
            if ((unsigned int )sym->type == 4U) {
#line 461
              goto case_4;
            }
#line 461
            if ((unsigned int )sym->type == 3U) {
#line 461
              goto case_4;
            }
#line 461
            if ((unsigned int )sym->type == 5U) {
#line 461
              goto case_4;
            }
#line 468
            goto switch_default___0;
            case_4: /* CIL Label */ 
            case_3: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 463
            tmp___6 = sym_string_within_range(sym, (char const   *)sym->def[0].val);
            }
#line 463
            if (tmp___6) {
#line 464
              goto switch_break___0;
            }
#line 465
            sym->flags &= -65665;
#line 466
            conf_unsaved ++;
#line 467
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 469
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
      }
#line 449
      sym = sym->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 449
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 474
  if (conf_warnings) {
#line 474
    tmp___9 = 1;
  } else
#line 474
  if (conf_unsaved) {
#line 474
    tmp___9 = 1;
  } else {
#line 474
    tmp___9 = 0;
  }
  {
#line 474
  sym_add_change_count(tmp___9);
  }
#line 476
  return (0);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void kconfig_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                 void *arg ) 
{ 
  _Bool skip_unset ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 493
  if ((unsigned int )sym->type == 2U) {
#line 493
    goto case_2;
  }
#line 493
  if ((unsigned int )sym->type == 1U) {
#line 493
    goto case_2;
  }
#line 503
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 494
  if ((int const   )*value == 110) {
#line 495
    skip_unset = (_Bool )((unsigned long )arg != (unsigned long )((void *)0));
#line 497
    if (! skip_unset) {
      {
#line 498
      tmp = CONFIG_prefix();
#line 498
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# %s%s is not set\n",
              tmp, sym->name);
      }
    }
#line 500
    return;
  }
#line 502
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 504
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 507
  tmp___0 = CONFIG_prefix();
#line 507
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s=%s\n",
          tmp___0, sym->name, value);
  }
#line 508
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void kconfig_print_comment(FILE *fp , char const   *value , void *arg ) 
{ 
  char const   *p ;
  size_t l ;
  char const   *tmp ;

  {
#line 513
  p = value;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 517
    l = strcspn(p, "\n");
#line 518
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#");
    }
#line 519
    if (l) {
      {
#line 520
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 521
      xfwrite((void const   *)p, l, (size_t )1, fp);
#line 522
      p += l;
      }
    }
    {
#line 524
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 525
    tmp = p;
#line 525
    p ++;
    }
#line 525
    if ((int const   )*tmp == 0) {
#line 526
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static struct conf_printer kconfig_printer_cb  =    {& kconfig_print_symbol, & kconfig_print_comment};
#line 541 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void header_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                void *arg ) 
{ 
  char const   *suffix ;
  char const   *tmp ;
  char const   *prefix ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 547
  if ((unsigned int )sym->type == 2U) {
#line 547
    goto case_2;
  }
#line 547
  if ((unsigned int )sym->type == 1U) {
#line 547
    goto case_2;
  }
#line 562
  if ((unsigned int )sym->type == 4U) {
#line 562
    goto case_4;
  }
#line 572
  if ((unsigned int )sym->type == 3U) {
#line 572
    goto case_3;
  }
#line 572
  if ((unsigned int )sym->type == 5U) {
#line 572
    goto case_3;
  }
#line 576
  goto switch_default___0;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 548
  suffix = "";
  {
#line 551
  if ((int const   )*value == 110) {
#line 551
    goto case_110;
  }
#line 553
  if ((int const   )*value == 109) {
#line 553
    goto case_109;
  }
#line 556
  goto switch_default;
  case_110: /* CIL Label */ 
#line 552
  goto switch_break___0;
  case_109: /* CIL Label */ 
#line 554
  suffix = "_MODULE";
  switch_default: /* CIL Label */ 
  {
#line 557
  tmp = CONFIG_prefix();
#line 557
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s%s 1\n",
          tmp, sym->name, suffix);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 560
  goto switch_break;
  case_4: /* CIL Label */ 
#line 563
  prefix = "";
#line 565
  if ((int const   )*(value + 0) != 48) {
#line 566
    prefix = "0x";
  } else
#line 565
  if ((int const   )*(value + 1) != 120) {
#line 565
    if ((int const   )*(value + 1) != 88) {
#line 566
      prefix = "0x";
    }
  }
  {
#line 567
  tmp___0 = CONFIG_prefix();
#line 567
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s %s%s\n",
          tmp___0, sym->name, prefix, value);
  }
#line 569
  goto switch_break;
  case_3: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 573
  tmp___1 = CONFIG_prefix();
#line 573
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s %s\n",
          tmp___1, sym->name, value);
  }
#line 575
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 577
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 580
  return;
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void header_print_comment(FILE *fp , char const   *value , void *arg ) 
{ 
  char const   *p ;
  size_t l ;
  char const   *tmp ;

  {
  {
#line 585
  p = value;
#line 588
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"/*\n");
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 590
    l = strcspn(p, "\n");
#line 591
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
#line 592
    if (l) {
      {
#line 593
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 594
      xfwrite((void const   *)p, l, (size_t )1, fp);
#line 595
      p += l;
      }
    }
    {
#line 597
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 598
    tmp = p;
#line 598
    p ++;
    }
#line 598
    if ((int const   )*tmp == 0) {
#line 599
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 601
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" */\n");
  }
#line 602
  return;
}
}
#line 604 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static struct conf_printer header_printer_cb  =    {& header_print_symbol, & header_print_comment};
#line 615 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void tristate_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                  void *arg ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
#line 619
  if ((unsigned int )sym->type == 2U) {
#line 619
    if ((int const   )*value != 110) {
      {
#line 620
      tmp = toupper((int )*value);
#line 620
      tmp___0 = CONFIG_prefix();
#line 620
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s=%c\n",
              tmp___0, sym->name, (int )((char )tmp));
      }
    }
  }
#line 621
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static struct conf_printer tristate_printer_cb  =    {& tristate_print_symbol, & kconfig_print_comment};
#line 629 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void conf_write_symbol(FILE *fp , struct symbol *sym , struct conf_printer *printer ,
                              void *printer_arg ) 
{ 
  char const   *str ;

  {
  {
#line 636
  if ((unsigned int )sym->type == 0U) {
#line 636
    goto case_0;
  }
#line 636
  if ((unsigned int )sym->type == 6U) {
#line 636
    goto case_0;
  }
#line 638
  if ((unsigned int )sym->type == 5U) {
#line 638
    goto case_5;
  }
#line 644
  goto switch_default;
  case_0: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 637
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 639
  str = sym_get_string_value(sym);
#line 640
  str = sym_escape_string_value(str);
#line 641
  (*(printer->print_symbol))(fp, sym, str, printer_arg);
#line 642
  free((void *)str);
  }
#line 643
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 645
  str = sym_get_string_value(sym);
#line 646
  (*(printer->print_symbol))(fp, sym, str, printer_arg);
  }
  switch_break: /* CIL Label */ ;
  }
#line 648
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void conf_write_heading(FILE *fp , struct conf_printer *printer , void *printer_arg ) 
{ 
  char buf[256] ;

  {
  {
#line 655
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"\nAutomatically generated file; DO NOT EDIT.\n%s\n",
           (rootmenu.prompt)->text);
#line 661
  (*(printer->print_comment))(fp, (char const   *)(buf), printer_arg);
  }
#line 662
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
int conf_write_defconfig(char const   *filename ) 
{ 
  struct symbol *sym ;
  struct menu *menu ;
  FILE *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  struct symbol *cs ;
  struct symbol *ds ;
  struct property *tmp___4 ;
  tristate tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 674
  out = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 675
  if (! out) {
#line 676
    return (1);
  }
  {
#line 678
  sym_clear_all_valid();
#line 681
  menu = rootmenu.list;
  }
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! ((unsigned long )menu != (unsigned long )((void *)0))) {
#line 683
      goto while_break;
    }
#line 685
    sym = menu->sym;
#line 686
    if ((unsigned long )sym == (unsigned long )((void *)0)) {
      {
#line 687
      tmp = menu_is_visible(menu);
      }
#line 687
      if (! tmp) {
#line 688
        goto next_menu;
      }
    } else {
      {
#line 689
      tmp___8 = sym_is_choice(sym);
      }
#line 689
      if (! tmp___8) {
        {
#line 690
        sym_calc_value(sym);
        }
#line 691
        if (! (sym->flags & 512)) {
#line 692
          goto next_menu;
        }
        {
#line 693
        sym->flags &= -513;
#line 695
        tmp___0 = sym_is_changable(sym);
        }
#line 695
        if (! tmp___0) {
#line 696
          goto next_menu;
        }
        {
#line 698
        tmp___1 = sym_get_string_default(sym);
#line 698
        tmp___2 = sym_get_string_value(sym);
#line 698
        tmp___3 = strcmp(tmp___2, tmp___1);
        }
#line 698
        if (tmp___3 == 0) {
#line 699
          goto next_menu;
        }
        {
#line 708
        tmp___7 = sym_is_choice_value(sym);
        }
#line 708
        if (tmp___7) {
          {
#line 712
          tmp___4 = sym_get_choice_prop(sym);
#line 712
          cs = prop_get_symbol(tmp___4);
#line 713
          ds = sym_choice_default(cs);
#line 714
          tmp___6 = sym_is_optional(cs);
          }
#line 714
          if (! tmp___6) {
#line 714
            if ((unsigned long )sym == (unsigned long )ds) {
#line 715
              if ((unsigned int )sym->type == 1U) {
                {
#line 715
                tmp___5 = sym_get_tristate_value(sym);
                }
#line 715
                if ((unsigned int )tmp___5 == 2U) {
#line 717
                  goto next_menu;
                }
              }
            }
          }
        }
        {
#line 720
        conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)0);
        }
      }
    }
    next_menu: 
#line 723
    if ((unsigned long )menu->list != (unsigned long )((void *)0)) {
#line 724
      menu = menu->list;
    } else
#line 726
    if ((unsigned long )menu->next != (unsigned long )((void *)0)) {
#line 727
      menu = menu->next;
    } else {
      {
#line 729
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 729
        menu = menu->parent;
#line 729
        if (! menu) {
#line 729
          goto while_break___0;
        }
#line 730
        if ((unsigned long )menu->next != (unsigned long )((void *)0)) {
#line 731
          menu = menu->next;
#line 732
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 737
  fclose(out);
  }
#line 738
  return (0);
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
int conf_write(char const   *name ) 
{ 
  FILE *out ;
  struct symbol *sym ;
  struct menu *menu ;
  char const   *basename ;
  char const   *str ;
  char dirname[4097] ;
  char tmpname[4097] ;
  char newname[4097] ;
  char *env ;
  struct stat st ;
  char *slash ;
  int size ;
  int tmp ;
  __pid_t tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 751
  dirname[0] = (char)0;
#line 752
  if (name) {
#line 752
    if (*(name + 0)) {
      {
#line 756
      tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
      }
#line 756
      if (tmp) {
        _L: /* CIL Label */ 
        {
#line 760
        slash = strrchr(name, '/');
        }
#line 760
        if (slash) {
          {
#line 761
          size = (int )((slash - (char *)name) + 1L);
#line 762
          memcpy((void */* __restrict  */)(dirname), (void const   */* __restrict  */)name,
                 (size_t )size);
#line 763
          dirname[size] = (char)0;
          }
#line 764
          if (*(slash + 1)) {
#line 765
            basename = (char const   *)(slash + 1);
          } else {
            {
#line 767
            basename = conf_get_configname();
            }
          }
        } else {
#line 769
          basename = name;
        }
      } else
#line 756
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 757
        strcpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)name);
#line 758
        strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)"/");
#line 759
        basename = conf_get_configname();
        }
      } else {
#line 756
        goto _L;
      }
    } else {
      {
#line 771
      basename = conf_get_configname();
      }
    }
  } else {
    {
#line 771
    basename = conf_get_configname();
    }
  }
  {
#line 773
  sprintf((char */* __restrict  */)(newname), (char const   */* __restrict  */)"%s%s",
          dirname, basename);
#line 774
  env = getenv("KCONFIG_OVERWRITECONFIG");
  }
#line 775
  if (! env) {
    {
#line 776
    tmp___0 = getpid();
#line 776
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
            dirname, tmp___0);
#line 777
    out = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"w");
    }
  } else
#line 775
  if (! *env) {
    {
#line 776
    tmp___0 = getpid();
#line 776
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
            dirname, tmp___0);
#line 777
    out = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"w");
    }
  } else {
    {
#line 779
    tmpname[0] = (char)0;
#line 780
    out = fopen((char const   */* __restrict  */)(newname), (char const   */* __restrict  */)"w");
    }
  }
#line 782
  if (! out) {
#line 783
    return (1);
  }
  {
#line 785
  conf_write_heading(out, & kconfig_printer_cb, (void *)0);
#line 787
  tmp___1 = conf_get_changed();
  }
#line 787
  if (! tmp___1) {
    {
#line 788
    sym_clear_all_valid();
    }
  }
#line 790
  menu = rootmenu.list;
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! menu) {
#line 791
      goto while_break;
    }
#line 792
    sym = menu->sym;
#line 793
    if (! sym) {
      {
#line 794
      tmp___2 = menu_is_visible(menu);
      }
#line 794
      if (! tmp___2) {
#line 795
        goto next;
      }
      {
#line 796
      str = menu_get_prompt(menu);
#line 797
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n#\n# %s\n#\n",
              str);
      }
    } else
#line 801
    if (! (sym->flags & 16)) {
      {
#line 802
      sym_calc_value(sym);
      }
#line 803
      if (! (sym->flags & 512)) {
#line 804
        goto next;
      }
      {
#line 805
      sym->flags &= -513;
#line 807
      conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)0);
      }
    }
    next: 
#line 811
    if (menu->list) {
#line 812
      menu = menu->list;
#line 813
      goto while_continue;
    }
#line 815
    if (menu->next) {
#line 816
      menu = menu->next;
    } else {
      {
#line 817
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 817
        menu = menu->parent;
#line 817
        if (! menu) {
#line 817
          goto while_break___0;
        }
#line 818
        if (menu->next) {
#line 819
          menu = menu->next;
#line 820
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 824
  fclose(out);
  }
#line 826
  if (tmpname[0]) {
    {
#line 827
    strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)basename);
#line 828
    strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)".old");
#line 829
    rename((char const   *)(newname), (char const   *)(dirname));
#line 830
    tmp___3 = rename((char const   *)(tmpname), (char const   *)(newname));
    }
#line 830
    if (tmp___3) {
#line 831
      return (1);
    }
  }
  {
#line 834
  tmp___4 = gettext("configuration written to %s");
#line 834
  conf_message((char const   *)tmp___4, newname);
#line 836
  sym_set_change_count(0);
  }
#line 838
  return (0);
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int conf_split_config(void) 
{ 
  char const   *name ;
  char path[4097] ;
  char *s ;
  char *d ;
  char c ;
  struct symbol *sym ;
  struct stat sb ;
  int res ;
  int i ;
  int fd ;
  int tmp ;
  tristate tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  tristate tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 850
  name = conf_get_autoconfig_name();
#line 851
  conf_read_simple(name, 1);
#line 853
  tmp = chdir("include/config");
  }
#line 853
  if (tmp) {
#line 854
    return (1);
  }
#line 856
  res = 0;
#line 857
  i = 0;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! (i < 9973)) {
#line 857
      goto while_break;
    }
#line 857
    sym = symbol_hash[i];
    {
#line 857
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 857
      if (! sym) {
#line 857
        goto while_break___0;
      }
#line 857
      if ((unsigned int )sym->type != 6U) {
        {
#line 858
        sym_calc_value(sym);
        }
#line 859
        if (sym->flags & 4096) {
#line 860
          goto __Cont;
        } else
#line 859
        if (! sym->name) {
#line 860
          goto __Cont;
        }
#line 861
        if (sym->flags & 512) {
#line 862
          if (sym->flags & 131072) {
            {
#line 869
            if ((unsigned int )sym->type == 2U) {
#line 869
              goto case_2;
            }
#line 869
            if ((unsigned int )sym->type == 1U) {
#line 869
              goto case_2;
            }
#line 876
            if ((unsigned int )sym->type == 3U) {
#line 876
              goto case_3;
            }
#line 876
            if ((unsigned int )sym->type == 4U) {
#line 876
              goto case_3;
            }
#line 876
            if ((unsigned int )sym->type == 5U) {
#line 876
              goto case_3;
            }
#line 881
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 870
            tmp___0 = sym_get_tristate_value(sym);
            }
#line 870
            if ((unsigned int )tmp___0 == (unsigned int )sym->def[1].tri) {
#line 872
              goto __Cont;
            }
#line 873
            goto switch_break;
            case_3: /* CIL Label */ 
            case_4: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 877
            tmp___1 = sym_get_string_value(sym);
#line 877
            tmp___2 = strcmp(tmp___1, (char const   *)sym->def[1].val);
            }
#line 877
            if (! tmp___2) {
#line 879
              goto __Cont;
            }
#line 880
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 882
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
            {
#line 891
            if ((unsigned int )sym->type == 2U) {
#line 891
              goto case_2___0;
            }
#line 891
            if ((unsigned int )sym->type == 1U) {
#line 891
              goto case_2___0;
            }
#line 895
            goto switch_default___0;
            case_2___0: /* CIL Label */ 
            case_1___0: /* CIL Label */ 
            {
#line 892
            tmp___3 = sym_get_tristate_value(sym);
            }
#line 892
            if ((unsigned int )tmp___3 == 0U) {
#line 893
              goto __Cont;
            }
#line 894
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 896
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        } else
#line 899
        if (! (sym->flags & 131072)) {
#line 901
          goto __Cont;
        }
#line 909
        s = sym->name;
#line 910
        d = path;
        {
#line 911
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 911
          tmp___6 = s;
#line 911
          s ++;
#line 911
          c = *tmp___6;
#line 911
          if (! c) {
#line 911
            goto while_break___1;
          }
          {
#line 912
          tmp___4 = tolower((int )c);
#line 912
          c = (char )tmp___4;
#line 913
          tmp___5 = d;
#line 913
          d ++;
          }
#line 913
          if ((int )c == 95) {
#line 913
            *tmp___5 = (char )'/';
          } else {
#line 913
            *tmp___5 = c;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 915
        strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)".h");
#line 918
        fd = open((char const   *)(path), 577, 420);
        }
#line 919
        if (fd == -1) {
          {
#line 920
          tmp___7 = __errno_location();
          }
#line 920
          if (*tmp___7 != 2) {
#line 921
            res = 1;
#line 922
            goto while_break___0;
          }
#line 928
          d = path;
          {
#line 929
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 929
            d = strchr((char const   *)d, '/');
            }
#line 929
            if (! d) {
#line 929
              goto while_break___2;
            }
            {
#line 930
            *d = (char)0;
#line 931
            tmp___8 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& sb));
            }
#line 931
            if (tmp___8) {
              {
#line 931
              tmp___9 = mkdir((char const   *)(path), (__mode_t )493);
              }
#line 931
              if (tmp___9) {
#line 932
                res = 1;
#line 933
                goto out;
              }
            }
#line 935
            tmp___10 = d;
#line 935
            d ++;
#line 935
            *tmp___10 = (char )'/';
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 938
          fd = open((char const   *)(path), 577, 420);
          }
#line 939
          if (fd == -1) {
#line 940
            res = 1;
#line 941
            goto while_break___0;
          }
        }
        {
#line 944
        close(fd);
        }
      }
      __Cont: /* CIL Label */ 
#line 857
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 857
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 947
  tmp___11 = chdir("../..");
  }
#line 947
  if (tmp___11) {
#line 948
    return (1);
  }
#line 950
  return (res);
}
}
#line 953 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
int conf_write_autoconf(void) 
{ 
  struct symbol *sym ;
  char const   *name ;
  FILE *out ;
  FILE *tristate___0 ;
  FILE *out_h ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 960
  sym_clear_all_valid();
#line 962
  file_write_dep("include/config/auto.conf.cmd");
#line 964
  tmp = conf_split_config();
  }
#line 964
  if (tmp) {
#line 965
    return (1);
  }
  {
#line 967
  out = fopen((char const   */* __restrict  */)".tmpconfig", (char const   */* __restrict  */)"w");
  }
#line 968
  if (! out) {
#line 969
    return (1);
  }
  {
#line 971
  tristate___0 = fopen((char const   */* __restrict  */)".tmpconfig_tristate", (char const   */* __restrict  */)"w");
  }
#line 972
  if (! tristate___0) {
    {
#line 973
    fclose(out);
    }
#line 974
    return (1);
  }
  {
#line 977
  out_h = fopen((char const   */* __restrict  */)".tmpconfig.h", (char const   */* __restrict  */)"w");
  }
#line 978
  if (! out_h) {
    {
#line 979
    fclose(out);
#line 980
    fclose(tristate___0);
    }
#line 981
    return (1);
  }
  {
#line 984
  conf_write_heading(out, & kconfig_printer_cb, (void *)0);
#line 986
  conf_write_heading(tristate___0, & tristate_printer_cb, (void *)0);
#line 988
  conf_write_heading(out_h, & header_printer_cb, (void *)0);
#line 990
  i = 0;
  }
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if (! (i < 9973)) {
#line 990
      goto while_break;
    }
#line 990
    sym = symbol_hash[i];
    {
#line 990
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 990
      if (! sym) {
#line 990
        goto while_break___0;
      }
#line 990
      if ((unsigned int )sym->type != 6U) {
        {
#line 991
        sym_calc_value(sym);
        }
#line 992
        if (! (sym->flags & 512)) {
#line 993
          goto __Cont;
        } else
#line 992
        if (! sym->name) {
#line 993
          goto __Cont;
        }
        {
#line 996
        conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)1);
#line 998
        conf_write_symbol(tristate___0, sym, & tristate_printer_cb, (void *)1);
#line 1000
        conf_write_symbol(out_h, sym, & header_printer_cb, (void *)0);
        }
      }
      __Cont: /* CIL Label */ 
#line 990
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 990
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1002
  fclose(out);
#line 1003
  fclose(tristate___0);
#line 1004
  fclose(out_h);
#line 1006
  tmp___0 = getenv("KCONFIG_AUTOHEADER");
#line 1006
  name = (char const   *)tmp___0;
  }
#line 1007
  if (! name) {
#line 1008
    name = "include/generated/autoconf.h";
  }
  {
#line 1009
  tmp___1 = rename(".tmpconfig.h", name);
  }
#line 1009
  if (tmp___1) {
#line 1010
    return (1);
  }
  {
#line 1011
  tmp___2 = getenv("KCONFIG_TRISTATE");
#line 1011
  name = (char const   *)tmp___2;
  }
#line 1012
  if (! name) {
#line 1013
    name = "include/config/tristate.conf";
  }
  {
#line 1014
  tmp___3 = rename(".tmpconfig_tristate", name);
  }
#line 1014
  if (tmp___3) {
#line 1015
    return (1);
  }
  {
#line 1016
  name = conf_get_autoconfig_name();
#line 1021
  tmp___4 = rename(".tmpconfig", name);
  }
#line 1021
  if (tmp___4) {
#line 1022
    return (1);
  }
#line 1024
  return (0);
}
}
#line 1027 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static int sym_change_count  ;
#line 1028 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static void (*conf_changed_callback)(void)  ;
#line 1030 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
void sym_set_change_count(int count ) 
{ 
  int _sym_change_count ;

  {
#line 1032
  _sym_change_count = sym_change_count;
#line 1033
  sym_change_count = count;
#line 1034
  if (conf_changed_callback) {
#line 1034
    if ((int )((_Bool )_sym_change_count) != (int )((_Bool )count)) {
      {
#line 1036
      (*conf_changed_callback)();
      }
    }
  }
#line 1037
  return;
}
}
#line 1039 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
void sym_add_change_count(int count ) 
{ 


  {
  {
#line 1041
  sym_set_change_count(count + sym_change_count);
  }
#line 1042
  return;
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
_Bool conf_get_changed(void) 
{ 


  {
#line 1046
  return ((_Bool )sym_change_count);
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
void conf_set_changed_callback(void (*fn)(void) ) 
{ 


  {
#line 1051
  conf_changed_callback = fn;
#line 1052
  return;
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
static _Bool randomize_choice_values(struct symbol *csym ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct expr *e ;
  int cnt ;
  int def ;
  int tmp ;
  int tmp___0 ;

  {
#line 1066
  if ((unsigned int )csym->curr.tri != 2U) {
#line 1067
    return ((_Bool)0);
  }
  {
#line 1069
  prop = sym_get_choice_prop(csym);
#line 1072
  cnt = 0;
#line 1073
  e = prop->expr;
  }
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (e) {
#line 1073
      sym = e->right.sym;
#line 1073
      if (! sym) {
#line 1073
        goto while_break;
      }
    } else {
#line 1073
      goto while_break;
    }
#line 1074
    cnt ++;
#line 1073
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1080
  tmp = rand();
#line 1080
  def = tmp % cnt;
#line 1082
  cnt = 0;
#line 1083
  e = prop->expr;
  }
  {
#line 1083
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1083
    if (e) {
#line 1083
      sym = e->right.sym;
#line 1083
      if (! sym) {
#line 1083
        goto while_break___0;
      }
    } else {
#line 1083
      goto while_break___0;
    }
#line 1084
    tmp___0 = cnt;
#line 1084
    cnt ++;
#line 1084
    if (def == tmp___0) {
#line 1085
      sym->def[0].tri = (tristate )2;
#line 1086
      csym->def[0].val = (void *)sym;
    } else {
#line 1089
      sym->def[0].tri = (tristate )0;
    }
#line 1091
    sym->flags |= 65536;
#line 1093
    sym->flags &= -129;
#line 1083
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1095
  csym->flags |= 65536;
#line 1097
  csym->flags &= -129;
#line 1099
  return ((_Bool)1);
}
}
#line 1102 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
void set_all_choice_values(struct symbol *csym ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct expr *e ;
  _Bool tmp ;

  {
  {
#line 1108
  prop = sym_get_choice_prop(csym);
#line 1113
  e = prop->expr;
  }
  {
#line 1113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1113
    if (e) {
#line 1113
      sym = e->right.sym;
#line 1113
      if (! sym) {
#line 1113
        goto while_break;
      }
    } else {
#line 1113
      goto while_break;
    }
    {
#line 1114
    tmp = sym_has_value(sym);
    }
#line 1114
    if (! tmp) {
#line 1115
      sym->def[0].tri = (tristate )0;
    }
#line 1113
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  csym->flags |= 65536;
#line 1119
  csym->flags &= -1048705;
#line 1120
  return;
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/confdata.c"
_Bool conf_set_all_new_symbols(enum conf_def_mode mode ) 
{ 
  struct symbol *sym ;
  struct symbol *csym ;
  int i ;
  int cnt ;
  int pby ;
  int pty ;
  int ptm ;
  int n ;
  int p[3] ;
  char *env ;
  char *tmp ;
  char *endp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  _Bool has_changed ;
  _Bool tmp___5 ;
  enum symbol_type tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;

  {
#line 1130
  pby = 50;
#line 1130
  ptm = 33;
#line 1130
  pty = ptm;
#line 1133
  if ((unsigned int )mode == 4U) {
    {
#line 1135
    tmp = getenv("KCONFIG_PROBABILITY");
#line 1135
    env = tmp;
#line 1136
    n = 0;
    }
    {
#line 1137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1137
      if (env) {
#line 1137
        if (! *env) {
#line 1137
          goto while_break;
        }
      } else {
#line 1137
        goto while_break;
      }
      {
#line 1139
      tmp___1 = strtol((char const   */* __restrict  */)env, (char **/* __restrict  */)(& endp),
                       10);
#line 1139
      tmp___0 = (int )tmp___1;
      }
#line 1140
      if (tmp___0 >= 0) {
#line 1140
        if (tmp___0 <= 100) {
#line 1141
          tmp___2 = n;
#line 1141
          n ++;
#line 1141
          p[tmp___2] = tmp___0;
        } else {
          {
#line 1143
          tmp___3 = __errno_location();
#line 1143
          *tmp___3 = 34;
#line 1144
          perror("KCONFIG_PROBABILITY");
#line 1145
          exit(1);
          }
        }
      } else {
        {
#line 1143
        tmp___3 = __errno_location();
#line 1143
        *tmp___3 = 34;
#line 1144
        perror("KCONFIG_PROBABILITY");
#line 1145
        exit(1);
        }
      }
#line 1147
      if ((int )*endp == 58) {
#line 1147
        env = endp + 1;
      } else {
#line 1147
        env = endp;
      }
#line 1148
      if (n >= 3) {
#line 1149
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1153
    if (n == 1) {
#line 1153
      goto case_1;
    }
#line 1156
    if (n == 2) {
#line 1156
      goto case_2;
    }
#line 1159
    if (n == 3) {
#line 1159
      goto case_3;
    }
#line 1152
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1154
    pby = p[0];
#line 1154
    ptm = pby / 2;
#line 1154
    pty = pby - ptm;
#line 1155
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1157
    pty = p[0];
#line 1157
    ptm = p[1];
#line 1157
    pby = pty + ptm;
#line 1158
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1160
    pby = p[0];
#line 1160
    pty = p[1];
#line 1160
    ptm = p[2];
#line 1161
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1164
    if (pty + ptm > 100) {
      {
#line 1165
      tmp___4 = __errno_location();
#line 1165
      *tmp___4 = 34;
#line 1166
      perror("KCONFIG_PROBABILITY");
#line 1167
      exit(1);
      }
    }
  }
#line 1170
  has_changed = (_Bool)0;
#line 1172
  i = 0;
  {
#line 1172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1172
    if (! (i < 9973)) {
#line 1172
      goto while_break___0;
    }
#line 1172
    sym = symbol_hash[i];
    {
#line 1172
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1172
      if (! sym) {
#line 1172
        goto while_break___1;
      }
#line 1172
      if ((unsigned int )sym->type != 6U) {
        {
#line 1173
        tmp___5 = sym_has_value(sym);
        }
#line 1173
        if (tmp___5) {
#line 1174
          goto __Cont;
        } else
#line 1173
        if (sym->flags & 128) {
#line 1174
          goto __Cont;
        }
        {
#line 1175
        tmp___6 = sym_get_type(sym);
        }
        {
#line 1177
        if ((unsigned int )tmp___6 == 2U) {
#line 1177
          goto case_2___0;
        }
#line 1177
        if ((unsigned int )tmp___6 == 1U) {
#line 1177
          goto case_2___0;
        }
#line 1209
        goto switch_default___0;
        case_2___0: /* CIL Label */ 
        case_1___0: /* CIL Label */ 
#line 1178
        has_changed = (_Bool)1;
        {
#line 1180
        if ((unsigned int )mode == 1U) {
#line 1180
          goto case_1___1;
        }
#line 1183
        if ((unsigned int )mode == 2U) {
#line 1183
          goto case_2___1;
        }
#line 1186
        if ((unsigned int )mode == 3U) {
#line 1186
          goto case_3___0;
        }
#line 1192
        if ((unsigned int )mode == 4U) {
#line 1192
          goto case_4;
        }
#line 1203
        goto switch_default;
        case_1___1: /* CIL Label */ 
#line 1181
        sym->def[0].tri = (tristate )2;
#line 1182
        goto switch_break___1;
        case_2___1: /* CIL Label */ 
#line 1184
        sym->def[0].tri = (tristate )1;
#line 1185
        goto switch_break___1;
        case_3___0: /* CIL Label */ 
#line 1187
        if (sym->flags & 2097152) {
#line 1188
          sym->def[0].tri = (tristate )2;
        } else {
#line 1190
          sym->def[0].tri = (tristate )0;
        }
#line 1191
        goto switch_break___1;
        case_4: /* CIL Label */ 
        {
#line 1193
        sym->def[0].tri = (tristate )0;
#line 1194
        tmp___7 = rand();
#line 1194
        cnt = tmp___7 % 100;
        }
#line 1195
        if ((unsigned int )sym->type == 2U) {
#line 1196
          if (cnt < pty) {
#line 1197
            sym->def[0].tri = (tristate )2;
          } else
#line 1198
          if (cnt < pty + ptm) {
#line 1199
            sym->def[0].tri = (tristate )1;
          }
        } else
#line 1200
        if (cnt < pby) {
#line 1201
          sym->def[0].tri = (tristate )2;
        }
#line 1202
        goto switch_break___1;
        switch_default: /* CIL Label */ 
#line 1204
        goto __Cont;
        switch_break___1: /* CIL Label */ ;
        }
        {
#line 1206
        tmp___8 = sym_is_choice(sym);
        }
#line 1206
        if (tmp___8) {
#line 1206
          if (! ((unsigned int )mode == 4U)) {
#line 1207
            sym->flags |= 65536;
          }
        } else {
#line 1207
          sym->flags |= 65536;
        }
#line 1208
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 1210
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 1172
      sym = sym->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1172
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1215
  sym_clear_all_valid();
  }
#line 1226
  if ((unsigned int )mode != 4U) {
#line 1227
    i = 0;
    {
#line 1227
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1227
      if (! (i < 9973)) {
#line 1227
        goto while_break___2;
      }
#line 1227
      csym = symbol_hash[i];
      {
#line 1227
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1227
        if (! csym) {
#line 1227
          goto while_break___3;
        }
#line 1227
        if ((unsigned int )csym->type != 6U) {
          {
#line 1228
          tmp___9 = sym_is_choice(csym);
          }
#line 1228
          if (tmp___9) {
            {
#line 1228
            tmp___10 = sym_has_value(csym);
            }
#line 1228
            if (tmp___10) {
#line 1228
              goto _L;
            } else {
#line 1230
              csym->flags |= 1048576;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 1228
            tmp___11 = sym_is_choice_value(csym);
            }
#line 1228
            if (tmp___11) {
#line 1230
              csym->flags |= 1048576;
            }
          }
        }
#line 1227
        csym = csym->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1227
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1234
  i = 0;
  {
#line 1234
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1234
    if (! (i < 9973)) {
#line 1234
      goto while_break___4;
    }
#line 1234
    csym = symbol_hash[i];
    {
#line 1234
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1234
      if (! csym) {
#line 1234
        goto while_break___5;
      }
#line 1234
      if ((unsigned int )csym->type != 6U) {
        {
#line 1235
        tmp___12 = sym_has_value(csym);
        }
#line 1235
        if (tmp___12) {
#line 1236
          goto __Cont___0;
        } else {
          {
#line 1235
          tmp___13 = sym_is_choice(csym);
          }
#line 1235
          if (! tmp___13) {
#line 1236
            goto __Cont___0;
          }
        }
        {
#line 1238
        sym_calc_value(csym);
        }
#line 1239
        if ((unsigned int )mode == 4U) {
          {
#line 1240
          has_changed = randomize_choice_values(csym);
          }
        } else {
          {
#line 1242
          set_all_choice_values(csym);
#line 1243
          has_changed = (_Bool)1;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1234
      csym = csym->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1234
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1247
  return (has_changed);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static int expr_eq(struct expr *e1 , struct expr *e2 ) ;
#line 15
static struct expr *expr_eliminate_yn(struct expr *e ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_symbol(struct symbol *sym ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 19
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 19
  e = (struct expr *)tmp;
#line 20
  e->type = (enum expr_type )11;
#line 21
  e->left.sym = sym;
  }
#line 22
  return (e);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 27
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 27
  e = (struct expr *)tmp;
#line 28
  e->type = type;
#line 29
  e->left.expr = ce;
  }
#line 30
  return (e);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 35
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 35
  e = (struct expr *)tmp;
#line 36
  e->type = type;
#line 37
  e->left.expr = e1;
#line 38
  e->right.expr = e2;
  }
#line 39
  return (e);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 44
  tmp = xcalloc((size_t )1, sizeof(*e));
#line 44
  e = (struct expr *)tmp;
#line 45
  e->type = type;
#line 46
  e->left.sym = s1;
#line 47
  e->right.sym = s2;
  }
#line 48
  return (e);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 53
  if (! e1) {
#line 54
    return (e2);
  }
#line 55
  if (e2) {
    {
#line 55
    tmp = expr_alloc_two((enum expr_type )2, e1, e2);
#line 55
    tmp___0 = tmp;
    }
  } else {
#line 55
    tmp___0 = e1;
  }
#line 55
  return (tmp___0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 60
  if (! e1) {
#line 61
    return (e2);
  }
#line 62
  if (e2) {
    {
#line 62
    tmp = expr_alloc_two((enum expr_type )1, e1, e2);
#line 62
    tmp___0 = tmp;
    }
  } else {
#line 62
    tmp___0 = e1;
  }
#line 62
  return (tmp___0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_copy(struct expr  const  *org ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
#line 69
  if (! org) {
#line 70
    return ((struct expr *)((void *)0));
  }
  {
#line 72
  tmp = xmalloc(sizeof(*org));
#line 72
  e = (struct expr *)tmp;
#line 73
  memcpy((void */* __restrict  */)e, (void const   */* __restrict  */)org, sizeof(*org));
  }
  {
#line 75
  if ((unsigned int const   )org->type == 11U) {
#line 75
    goto case_11;
  }
#line 78
  if ((unsigned int const   )org->type == 3U) {
#line 78
    goto case_3;
  }
#line 86
  if ((unsigned int const   )org->type == 5U) {
#line 86
    goto case_5;
  }
#line 86
  if ((unsigned int const   )org->type == 6U) {
#line 86
    goto case_5;
  }
#line 86
  if ((unsigned int const   )org->type == 7U) {
#line 86
    goto case_5;
  }
#line 86
  if ((unsigned int const   )org->type == 8U) {
#line 86
    goto case_5;
  }
#line 86
  if ((unsigned int const   )org->type == 9U) {
#line 86
    goto case_5;
  }
#line 86
  if ((unsigned int const   )org->type == 4U) {
#line 86
    goto case_5;
  }
#line 92
  if ((unsigned int const   )org->type == 10U) {
#line 92
    goto case_10;
  }
#line 92
  if ((unsigned int const   )org->type == 1U) {
#line 92
    goto case_10;
  }
#line 92
  if ((unsigned int const   )org->type == 2U) {
#line 92
    goto case_10;
  }
#line 96
  goto switch_default;
  case_11: /* CIL Label */ 
#line 76
  e->left = (union expr_data )org->left;
#line 77
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 79
  e->left.expr = expr_copy((struct expr  const  *)org->left.expr);
  }
#line 80
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 87
  e->left.sym = (struct symbol *)org->left.sym;
#line 88
  e->right.sym = (struct symbol *)org->right.sym;
#line 89
  goto switch_break;
  case_10: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 93
  e->left.expr = expr_copy((struct expr  const  *)org->left.expr);
#line 94
  e->right.expr = expr_copy((struct expr  const  *)org->right.expr);
  }
#line 95
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 97
  printf((char const   */* __restrict  */)"can\'t copy type %d\n", (unsigned int )e->type);
#line 98
  free((void *)e);
#line 99
  e = (struct expr *)((void *)0);
  }
#line 100
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 103
  return (e);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
void expr_free(struct expr *e ) 
{ 


  {
#line 108
  if (! e) {
#line 109
    return;
  }
  {
#line 112
  if ((unsigned int )e->type == 11U) {
#line 112
    goto case_11;
  }
#line 114
  if ((unsigned int )e->type == 3U) {
#line 114
    goto case_3;
  }
#line 122
  if ((unsigned int )e->type == 5U) {
#line 122
    goto case_5;
  }
#line 122
  if ((unsigned int )e->type == 6U) {
#line 122
    goto case_5;
  }
#line 122
  if ((unsigned int )e->type == 7U) {
#line 122
    goto case_5;
  }
#line 122
  if ((unsigned int )e->type == 8U) {
#line 122
    goto case_5;
  }
#line 122
  if ((unsigned int )e->type == 9U) {
#line 122
    goto case_5;
  }
#line 122
  if ((unsigned int )e->type == 4U) {
#line 122
    goto case_5;
  }
#line 125
  if ((unsigned int )e->type == 2U) {
#line 125
    goto case_2;
  }
#line 125
  if ((unsigned int )e->type == 1U) {
#line 125
    goto case_2;
  }
#line 129
  goto switch_default;
  case_11: /* CIL Label */ 
#line 113
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 115
  expr_free(e->left.expr);
  }
#line 116
  return;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 123
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 126
  expr_free(e->left.expr);
#line 127
  expr_free(e->right.expr);
  }
#line 128
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 130
  printf((char const   */* __restrict  */)"how to free type %d?\n", (unsigned int )e->type);
  }
#line 131
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 133
  free((void *)e);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static int trans_count  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static void __expr_eliminate_eq(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  int tmp ;

  {
#line 143
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 144
    __expr_eliminate_eq(type, & (*ep1)->left.expr, ep2);
#line 145
    __expr_eliminate_eq(type, & (*ep1)->right.expr, ep2);
    }
#line 146
    return;
  }
#line 148
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 149
    __expr_eliminate_eq(type, ep1, & (*ep2)->left.expr);
#line 150
    __expr_eliminate_eq(type, ep1, & (*ep2)->right.expr);
    }
#line 151
    return;
  }
#line 153
  if ((unsigned int )(*ep1)->type == 11U) {
#line 153
    if ((unsigned int )(*ep2)->type == 11U) {
#line 153
      if ((unsigned long )(*ep1)->left.sym == (unsigned long )(*ep2)->left.sym) {
#line 153
        if ((unsigned long )(*ep1)->left.sym == (unsigned long )(& symbol_yes)) {
#line 156
          return;
        } else
#line 153
        if ((unsigned long )(*ep1)->left.sym == (unsigned long )(& symbol_no)) {
#line 156
          return;
        }
      }
    }
  }
  {
#line 157
  tmp = expr_eq(*ep1, *ep2);
  }
#line 157
  if (! tmp) {
#line 158
    return;
  }
  {
#line 159
  trans_count ++;
#line 160
  expr_free(*ep1);
#line 160
  expr_free(*ep2);
  }
  {
#line 162
  if ((unsigned int )type == 1U) {
#line 162
    goto case_1;
  }
#line 166
  if ((unsigned int )type == 2U) {
#line 166
    goto case_2;
  }
#line 170
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 163
  *ep1 = expr_alloc_symbol(& symbol_no);
#line 164
  *ep2 = expr_alloc_symbol(& symbol_no);
  }
#line 165
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 167
  *ep1 = expr_alloc_symbol(& symbol_yes);
#line 168
  *ep2 = expr_alloc_symbol(& symbol_yes);
  }
#line 169
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) 
{ 


  {
#line 177
  if (! *ep1) {
#line 178
    return;
  } else
#line 177
  if (! *ep2) {
#line 178
    return;
  }
  {
#line 181
  if ((unsigned int )(*ep1)->type == 2U) {
#line 181
    goto case_2;
  }
#line 181
  if ((unsigned int )(*ep1)->type == 1U) {
#line 181
    goto case_2;
  }
#line 183
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 182
  __expr_eliminate_eq((*ep1)->type, ep1, ep2);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 186
  if ((unsigned int )(*ep1)->type != (unsigned int )(*ep2)->type) {
    {
#line 188
    if ((unsigned int )(*ep2)->type == 2U) {
#line 188
      goto case_2___0;
    }
#line 188
    if ((unsigned int )(*ep2)->type == 1U) {
#line 188
      goto case_2___0;
    }
#line 190
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 189
    __expr_eliminate_eq((*ep2)->type, ep1, ep2);
    }
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 193
  *ep1 = expr_eliminate_yn(*ep1);
#line 194
  *ep2 = expr_eliminate_yn(*ep2);
  }
#line 195
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static int expr_eq(struct expr *e1 , struct expr *e2 ) 
{ 
  int res ;
  int old_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 204
  if ((unsigned int )e1->type != (unsigned int )e2->type) {
#line 205
    return (0);
  }
  {
#line 212
  if ((unsigned int )e1->type == 5U) {
#line 212
    goto case_5;
  }
#line 212
  if ((unsigned int )e1->type == 6U) {
#line 212
    goto case_5;
  }
#line 212
  if ((unsigned int )e1->type == 7U) {
#line 212
    goto case_5;
  }
#line 212
  if ((unsigned int )e1->type == 8U) {
#line 212
    goto case_5;
  }
#line 212
  if ((unsigned int )e1->type == 9U) {
#line 212
    goto case_5;
  }
#line 212
  if ((unsigned int )e1->type == 4U) {
#line 212
    goto case_5;
  }
#line 214
  if ((unsigned int )e1->type == 11U) {
#line 214
    goto case_11;
  }
#line 216
  if ((unsigned int )e1->type == 3U) {
#line 216
    goto case_3;
  }
#line 219
  if ((unsigned int )e1->type == 1U) {
#line 219
    goto case_1;
  }
#line 219
  if ((unsigned int )e1->type == 2U) {
#line 219
    goto case_1;
  }
#line 232
  if ((unsigned int )e1->type == 0U) {
#line 232
    goto case_0;
  }
#line 232
  if ((unsigned int )e1->type == 12U) {
#line 232
    goto case_0;
  }
#line 232
  if ((unsigned int )e1->type == 10U) {
#line 232
    goto case_0;
  }
#line 206
  goto switch_break;
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 213
  if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 213
    if ((unsigned long )e1->right.sym == (unsigned long )e2->right.sym) {
#line 213
      tmp = 1;
    } else {
#line 213
      tmp = 0;
    }
  } else {
#line 213
    tmp = 0;
  }
#line 213
  return (tmp);
  case_11: /* CIL Label */ 
#line 215
  return ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym);
  case_3: /* CIL Label */ 
  {
#line 217
  tmp___0 = expr_eq(e1->left.expr, e2->left.expr);
  }
#line 217
  return (tmp___0);
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 220
  e1 = expr_copy((struct expr  const  *)e1);
#line 221
  e2 = expr_copy((struct expr  const  *)e2);
#line 222
  old_count = trans_count;
#line 223
  expr_eliminate_eq(& e1, & e2);
  }
#line 224
  if ((unsigned int )e1->type == 11U) {
#line 224
    if ((unsigned int )e2->type == 11U) {
#line 224
      if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 224
        tmp___1 = 1;
      } else {
#line 224
        tmp___1 = 0;
      }
    } else {
#line 224
      tmp___1 = 0;
    }
  } else {
#line 224
    tmp___1 = 0;
  }
  {
#line 224
  res = tmp___1;
#line 226
  expr_free(e1);
#line 227
  expr_free(e2);
#line 228
  trans_count = old_count;
  }
#line 229
  return (res);
  case_0: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 243
  return (0);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static struct expr *expr_eliminate_yn(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 250
  if (e) {
    {
#line 251
    if ((unsigned int )e->type == 2U) {
#line 251
      goto case_2;
    }
#line 287
    if ((unsigned int )e->type == 1U) {
#line 287
      goto case_1;
    }
#line 323
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 252
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 253
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 254
    if ((unsigned int )(e->left.expr)->type == 11U) {
#line 255
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 256
        expr_free(e->left.expr);
#line 257
        expr_free(e->right.expr);
#line 258
        e->type = (enum expr_type )11;
#line 259
        e->left.sym = & symbol_no;
#line 260
        e->right.expr = (struct expr *)((void *)0);
        }
#line 261
        return (e);
      } else
#line 262
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 263
        free((void *)e->left.expr);
#line 264
        tmp = e->right.expr;
#line 265
        *e = *(e->right.expr);
#line 266
        free((void *)tmp);
        }
#line 267
        return (e);
      }
    }
#line 270
    if ((unsigned int )(e->right.expr)->type == 11U) {
#line 271
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 272
        expr_free(e->left.expr);
#line 273
        expr_free(e->right.expr);
#line 274
        e->type = (enum expr_type )11;
#line 275
        e->left.sym = & symbol_no;
#line 276
        e->right.expr = (struct expr *)((void *)0);
        }
#line 277
        return (e);
      } else
#line 278
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 279
        free((void *)e->right.expr);
#line 280
        tmp = e->left.expr;
#line 281
        *e = *(e->left.expr);
#line 282
        free((void *)tmp);
        }
#line 283
        return (e);
      }
    }
#line 286
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 288
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 289
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 290
    if ((unsigned int )(e->left.expr)->type == 11U) {
#line 291
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 292
        free((void *)e->left.expr);
#line 293
        tmp = e->right.expr;
#line 294
        *e = *(e->right.expr);
#line 295
        free((void *)tmp);
        }
#line 296
        return (e);
      } else
#line 297
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 298
        expr_free(e->left.expr);
#line 299
        expr_free(e->right.expr);
#line 300
        e->type = (enum expr_type )11;
#line 301
        e->left.sym = & symbol_yes;
#line 302
        e->right.expr = (struct expr *)((void *)0);
        }
#line 303
        return (e);
      }
    }
#line 306
    if ((unsigned int )(e->right.expr)->type == 11U) {
#line 307
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 308
        free((void *)e->right.expr);
#line 309
        tmp = e->left.expr;
#line 310
        *e = *(e->left.expr);
#line 311
        free((void *)tmp);
        }
#line 312
        return (e);
      } else
#line 313
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 314
        expr_free(e->left.expr);
#line 315
        expr_free(e->right.expr);
#line 316
        e->type = (enum expr_type )11;
#line 317
        e->left.sym = & symbol_yes;
#line 318
        e->right.expr = (struct expr *)((void *)0);
        }
#line 319
        return (e);
      }
    }
#line 322
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 326
  return (e);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_trans_bool(struct expr *e ) 
{ 


  {
#line 334
  if (! e) {
#line 335
    return ((struct expr *)((void *)0));
  }
  {
#line 339
  if ((unsigned int )e->type == 3U) {
#line 339
    goto case_3;
  }
#line 339
  if ((unsigned int )e->type == 1U) {
#line 339
    goto case_3;
  }
#line 339
  if ((unsigned int )e->type == 2U) {
#line 339
    goto case_3;
  }
#line 343
  if ((unsigned int )e->type == 5U) {
#line 343
    goto case_5;
  }
#line 352
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 340
  e->left.expr = expr_trans_bool(e->left.expr);
#line 341
  e->right.expr = expr_trans_bool(e->right.expr);
  }
#line 342
  goto switch_break;
  case_5: /* CIL Label */ 
#line 345
  if ((unsigned int )(e->left.sym)->type == 2U) {
#line 346
    if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 347
      e->type = (enum expr_type )11;
#line 348
      e->right.sym = (struct symbol *)((void *)0);
    }
  }
#line 351
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 355
  return (e);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static struct expr *expr_join_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;

  {
  {
#line 366
  tmp___1 = expr_eq(e1, e2);
  }
#line 366
  if (tmp___1) {
    {
#line 367
    tmp___0 = expr_copy((struct expr  const  *)e1);
    }
#line 367
    return (tmp___0);
  }
#line 368
  if ((unsigned int )e1->type != 4U) {
#line 368
    if ((unsigned int )e1->type != 5U) {
#line 368
      if ((unsigned int )e1->type != 11U) {
#line 368
        if ((unsigned int )e1->type != 3U) {
#line 369
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 370
  if ((unsigned int )e2->type != 4U) {
#line 370
    if ((unsigned int )e2->type != 5U) {
#line 370
      if ((unsigned int )e2->type != 11U) {
#line 370
        if ((unsigned int )e2->type != 3U) {
#line 371
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 372
  if ((unsigned int )e1->type == 3U) {
#line 373
    tmp = e1->left.expr;
#line 374
    if ((unsigned int )tmp->type != 4U) {
#line 374
      if ((unsigned int )tmp->type != 5U) {
#line 374
        if ((unsigned int )tmp->type != 11U) {
#line 375
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 376
    sym1 = tmp->left.sym;
  } else {
#line 378
    sym1 = e1->left.sym;
  }
#line 379
  if ((unsigned int )e2->type == 3U) {
#line 380
    if ((unsigned int )(e2->left.expr)->type != 11U) {
#line 381
      return ((struct expr *)((void *)0));
    }
#line 382
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 384
    sym2 = e2->left.sym;
  }
#line 385
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 386
    return ((struct expr *)((void *)0));
  }
#line 387
  if ((unsigned int )sym1->type != 1U) {
#line 387
    if ((unsigned int )sym1->type != 2U) {
#line 388
      return ((struct expr *)((void *)0));
    }
  }
#line 389
  if ((unsigned int )sym1->type == 2U) {
#line 390
    if ((unsigned int )e1->type == 4U) {
#line 390
      if ((unsigned int )e2->type == 4U) {
#line 390
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 390
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 394
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 394
            return (tmp___2);
          } else {
#line 390
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 390
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 390
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 394
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 394
            return (tmp___2);
          }
        }
      }
    }
#line 396
    if ((unsigned int )e1->type == 4U) {
#line 396
      if ((unsigned int )e2->type == 4U) {
#line 396
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 396
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 400
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 400
            return (tmp___3);
          } else {
#line 396
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 396
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 396
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 400
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 400
            return (tmp___3);
          }
        }
      }
    }
#line 402
    if ((unsigned int )e1->type == 4U) {
#line 402
      if ((unsigned int )e2->type == 4U) {
#line 402
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 402
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 406
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 406
            return (tmp___4);
          } else {
#line 402
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 402
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 402
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 406
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 406
            return (tmp___4);
          }
        }
      }
    }
  }
#line 409
  if ((unsigned int )sym1->type == 1U) {
#line 409
    if ((unsigned long )sym1 == (unsigned long )sym2) {
#line 410
      if ((unsigned int )e1->type == 3U) {
#line 410
        if ((unsigned int )(e1->left.expr)->type == 11U) {
#line 410
          if ((unsigned int )e2->type == 11U) {
            {
#line 412
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 412
            return (tmp___5);
          } else {
#line 410
            goto _L___3;
          }
        } else {
#line 410
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 410
      if ((unsigned int )e2->type == 3U) {
#line 410
        if ((unsigned int )(e2->left.expr)->type == 11U) {
#line 410
          if ((unsigned int )e1->type == 11U) {
            {
#line 412
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 412
            return (tmp___5);
          }
        }
      }
    }
  }
#line 422
  return ((struct expr *)((void *)0));
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static struct expr *expr_join_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;
  struct expr *tmp___10 ;
  struct expr *tmp___11 ;
  struct expr *tmp___12 ;
  struct expr *tmp___13 ;

  {
  {
#line 430
  tmp___1 = expr_eq(e1, e2);
  }
#line 430
  if (tmp___1) {
    {
#line 431
    tmp___0 = expr_copy((struct expr  const  *)e1);
    }
#line 431
    return (tmp___0);
  }
#line 432
  if ((unsigned int )e1->type != 4U) {
#line 432
    if ((unsigned int )e1->type != 5U) {
#line 432
      if ((unsigned int )e1->type != 11U) {
#line 432
        if ((unsigned int )e1->type != 3U) {
#line 433
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 434
  if ((unsigned int )e2->type != 4U) {
#line 434
    if ((unsigned int )e2->type != 5U) {
#line 434
      if ((unsigned int )e2->type != 11U) {
#line 434
        if ((unsigned int )e2->type != 3U) {
#line 435
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 436
  if ((unsigned int )e1->type == 3U) {
#line 437
    tmp = e1->left.expr;
#line 438
    if ((unsigned int )tmp->type != 4U) {
#line 438
      if ((unsigned int )tmp->type != 5U) {
#line 438
        if ((unsigned int )tmp->type != 11U) {
#line 439
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 440
    sym1 = tmp->left.sym;
  } else {
#line 442
    sym1 = e1->left.sym;
  }
#line 443
  if ((unsigned int )e2->type == 3U) {
#line 444
    if ((unsigned int )(e2->left.expr)->type != 11U) {
#line 445
      return ((struct expr *)((void *)0));
    }
#line 446
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 448
    sym2 = e2->left.sym;
  }
#line 449
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 450
    return ((struct expr *)((void *)0));
  }
#line 451
  if ((unsigned int )sym1->type != 1U) {
#line 451
    if ((unsigned int )sym1->type != 2U) {
#line 452
      return ((struct expr *)((void *)0));
    }
  }
#line 454
  if ((unsigned int )e1->type == 11U) {
#line 454
    if ((unsigned int )e2->type == 4U) {
#line 454
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 457
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 457
        return (tmp___2);
      } else {
#line 454
        goto _L___0;
      }
    } else {
#line 454
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 454
  if ((unsigned int )e2->type == 11U) {
#line 454
    if ((unsigned int )e1->type == 4U) {
#line 454
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 457
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 457
        return (tmp___2);
      }
    }
  }
#line 459
  if ((unsigned int )e1->type == 11U) {
#line 459
    if ((unsigned int )e2->type == 5U) {
#line 459
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 462
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 462
        return (tmp___3);
      } else {
#line 459
        goto _L___2;
      }
    } else {
#line 459
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 459
  if ((unsigned int )e2->type == 11U) {
#line 459
    if ((unsigned int )e1->type == 5U) {
#line 459
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 462
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 462
        return (tmp___3);
      }
    }
  }
#line 464
  if ((unsigned int )e1->type == 11U) {
#line 464
    if ((unsigned int )e2->type == 5U) {
#line 464
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 467
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 467
        return (tmp___4);
      } else {
#line 464
        goto _L___4;
      }
    } else {
#line 464
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 464
  if ((unsigned int )e2->type == 11U) {
#line 464
    if ((unsigned int )e1->type == 5U) {
#line 464
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 467
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 467
        return (tmp___4);
      }
    }
  }
#line 469
  if ((unsigned int )sym1->type == 2U) {
#line 470
    if ((unsigned int )e1->type == 4U) {
#line 470
      if ((unsigned int )e2->type == 5U) {
#line 472
        sym2 = e1->right.sym;
#line 473
        if ((e2->right.sym)->flags & 1) {
#line 473
          if (sym2->flags & 1) {
#line 474
            if ((unsigned long )sym2 != (unsigned long )e2->right.sym) {
              {
#line 474
              tmp___5 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 474
              tmp___7 = tmp___5;
              }
            } else {
              {
#line 474
              tmp___6 = expr_alloc_symbol(& symbol_no);
#line 474
              tmp___7 = tmp___6;
              }
            }
#line 474
            return (tmp___7);
          }
        }
      }
    }
#line 477
    if ((unsigned int )e1->type == 5U) {
#line 477
      if ((unsigned int )e2->type == 4U) {
#line 479
        sym2 = e2->right.sym;
#line 480
        if ((e1->right.sym)->flags & 1) {
#line 480
          if (sym2->flags & 1) {
#line 481
            if ((unsigned long )sym2 != (unsigned long )e1->right.sym) {
              {
#line 481
              tmp___8 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 481
              tmp___10 = tmp___8;
              }
            } else {
              {
#line 481
              tmp___9 = expr_alloc_symbol(& symbol_no);
#line 481
              tmp___10 = tmp___9;
              }
            }
#line 481
            return (tmp___10);
          }
        }
      }
    }
#line 484
    if ((unsigned int )e1->type == 5U) {
#line 484
      if ((unsigned int )e2->type == 5U) {
#line 484
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 484
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 488
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 488
            return (tmp___11);
          } else {
#line 484
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 484
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 484
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 488
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 488
            return (tmp___11);
          }
        }
      }
    }
#line 490
    if ((unsigned int )e1->type == 5U) {
#line 490
      if ((unsigned int )e2->type == 5U) {
#line 490
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 490
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 494
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 494
            return (tmp___12);
          } else {
#line 490
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 490
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 490
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 494
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 494
            return (tmp___12);
          }
        }
      }
    }
#line 496
    if ((unsigned int )e1->type == 5U) {
#line 496
      if ((unsigned int )e2->type == 5U) {
#line 496
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 496
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 500
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 500
            return (tmp___13);
          } else {
#line 496
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 496
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 496
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 500
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 500
            return (tmp___13);
          }
        }
      }
    }
#line 502
    if ((unsigned int )e1->type == 11U) {
#line 502
      if ((unsigned int )e2->type == 4U) {
#line 502
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
#line 506
          return ((struct expr *)((void *)0));
        } else {
#line 502
          goto _L___13;
        }
      } else {
#line 502
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 502
    if ((unsigned int )e2->type == 11U) {
#line 502
      if ((unsigned int )e1->type == 4U) {
#line 502
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 506
          return ((struct expr *)((void *)0));
        } else {
#line 502
          goto _L___11;
        }
      } else {
#line 502
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 502
    if ((unsigned int )e1->type == 11U) {
#line 502
      if ((unsigned int )e2->type == 5U) {
#line 502
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
#line 506
          return ((struct expr *)((void *)0));
        } else {
#line 502
          goto _L___9;
        }
      } else {
#line 502
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 502
    if ((unsigned int )e2->type == 11U) {
#line 502
      if ((unsigned int )e1->type == 5U) {
#line 502
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 506
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 516
  return ((struct expr *)((void *)0));
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups1(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
#line 525
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 526
    expr_eliminate_dups1(type, & (*ep1)->left.expr, ep2);
#line 527
    expr_eliminate_dups1(type, & (*ep1)->right.expr, ep2);
    }
#line 528
    return;
  }
#line 530
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 531
    expr_eliminate_dups1(type, ep1, & (*ep2)->left.expr);
#line 532
    expr_eliminate_dups1(type, ep1, & (*ep2)->right.expr);
    }
#line 533
    return;
  }
#line 535
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 536
    return;
  }
  {
#line 539
  if ((unsigned int )(*ep1)->type == 2U) {
#line 539
    goto case_2;
  }
#line 539
  if ((unsigned int )(*ep1)->type == 1U) {
#line 539
    goto case_2;
  }
#line 541
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 540
  expr_eliminate_dups1((*ep1)->type, ep1, ep1);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 546
  if ((unsigned int )type == 1U) {
#line 546
    goto case_1___0;
  }
#line 555
  if ((unsigned int )type == 2U) {
#line 555
    goto case_2___0;
  }
#line 564
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 547
  tmp = expr_join_or(*ep1, *ep2);
  }
#line 548
  if (tmp) {
    {
#line 549
    expr_free(*ep1);
#line 549
    expr_free(*ep2);
#line 550
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 551
    *ep2 = tmp;
#line 552
    trans_count ++;
    }
  }
#line 554
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 556
  tmp = expr_join_and(*ep1, *ep2);
  }
#line 557
  if (tmp) {
    {
#line 558
    expr_free(*ep1);
#line 558
    expr_free(*ep2);
#line 559
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 560
    *ep2 = tmp;
#line 561
    trans_count ++;
    }
  }
#line 563
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 569
  return;
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_dups(struct expr *e ) 
{ 
  int oldcount ;

  {
#line 574
  if (! e) {
#line 575
    return (e);
  }
#line 577
  oldcount = trans_count;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    trans_count = 0;
    {
#line 581
    if ((unsigned int )e->type == 2U) {
#line 581
      goto case_2;
    }
#line 581
    if ((unsigned int )e->type == 1U) {
#line 581
      goto case_2;
    }
#line 583
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 582
    expr_eliminate_dups1(e->type, & e, & e);
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 586
    if (! trans_count) {
#line 587
      goto while_break;
    }
    {
#line 588
    e = expr_eliminate_yn(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  trans_count = oldcount;
#line 591
  return (e);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_transform(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 598
  if (! e) {
#line 599
    return ((struct expr *)((void *)0));
  }
  {
#line 608
  if ((unsigned int )e->type == 10U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 11U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 5U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 6U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 7U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 8U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 9U) {
#line 608
    goto case_10;
  }
#line 608
  if ((unsigned int )e->type == 4U) {
#line 608
    goto case_10;
  }
#line 610
  goto switch_default;
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 609
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 611
  e->left.expr = expr_transform(e->left.expr);
#line 612
  e->right.expr = expr_transform(e->right.expr);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 616
  if ((unsigned int )e->type == 4U) {
#line 616
    goto case_4___0;
  }
#line 638
  if ((unsigned int )e->type == 5U) {
#line 638
    goto case_5___0;
  }
#line 660
  if ((unsigned int )e->type == 3U) {
#line 660
    goto case_3;
  }
#line 745
  goto switch_default___1;
  case_4___0: /* CIL Label */ 
#line 617
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 618
    goto switch_break___0;
  }
#line 619
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
    {
#line 620
    e->type = (enum expr_type )3;
#line 621
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 622
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 623
    goto switch_break___0;
  }
#line 625
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 626
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'n\'\n",
           (e->left.sym)->name);
#line 627
    e->type = (enum expr_type )11;
#line 628
    e->left.sym = & symbol_no;
#line 629
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 630
    goto switch_break___0;
  }
#line 632
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
#line 633
    e->type = (enum expr_type )11;
#line 634
    e->right.sym = (struct symbol *)((void *)0);
#line 635
    goto switch_break___0;
  }
#line 637
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 639
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 640
    goto switch_break___0;
  }
#line 641
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 642
    e->type = (enum expr_type )11;
#line 643
    e->right.sym = (struct symbol *)((void *)0);
#line 644
    goto switch_break___0;
  }
#line 646
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 647
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'y\'\n",
           (e->left.sym)->name);
#line 648
    e->type = (enum expr_type )11;
#line 649
    e->left.sym = & symbol_yes;
#line 650
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 651
    goto switch_break___0;
  }
#line 653
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
    {
#line 654
    e->type = (enum expr_type )3;
#line 655
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 656
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 657
    goto switch_break___0;
  }
#line 659
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 662
  if ((unsigned int )(e->left.expr)->type == 3U) {
#line 662
    goto case_3___0;
  }
#line 671
  if ((unsigned int )(e->left.expr)->type == 5U) {
#line 671
    goto case_5___1;
  }
#line 671
  if ((unsigned int )(e->left.expr)->type == 4U) {
#line 671
    goto case_5___1;
  }
#line 679
  if ((unsigned int )(e->left.expr)->type == 9U) {
#line 679
    goto case_9___0;
  }
#line 679
  if ((unsigned int )(e->left.expr)->type == 7U) {
#line 679
    goto case_9___0;
  }
#line 687
  if ((unsigned int )(e->left.expr)->type == 8U) {
#line 687
    goto case_8___0;
  }
#line 687
  if ((unsigned int )(e->left.expr)->type == 6U) {
#line 687
    goto case_8___0;
  }
#line 694
  if ((unsigned int )(e->left.expr)->type == 1U) {
#line 694
    goto case_1;
  }
#line 703
  if ((unsigned int )(e->left.expr)->type == 2U) {
#line 703
    goto case_2;
  }
#line 712
  if ((unsigned int )(e->left.expr)->type == 11U) {
#line 712
    goto case_11___0;
  }
#line 741
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
  {
#line 664
  tmp = (e->left.expr)->left.expr;
#line 665
  free((void *)e->left.expr);
#line 666
  free((void *)e);
#line 667
  e = tmp;
#line 668
  e = expr_transform(e);
  }
#line 669
  goto switch_break___1;
  case_5___1: /* CIL Label */ 
  case_4___1: /* CIL Label */ 
  {
#line 673
  tmp = e->left.expr;
#line 674
  free((void *)e);
#line 675
  e = tmp;
  }
#line 676
  if ((unsigned int )e->type == 4U) {
#line 676
    e->type = (enum expr_type )5;
  } else {
#line 676
    e->type = (enum expr_type )4;
  }
#line 677
  goto switch_break___1;
  case_9___0: /* CIL Label */ 
  case_7___0: /* CIL Label */ 
  {
#line 681
  tmp = e->left.expr;
#line 682
  free((void *)e);
#line 683
  e = tmp;
  }
#line 684
  if ((unsigned int )e->type == 7U) {
#line 684
    e->type = (enum expr_type )8;
  } else {
#line 684
    e->type = (enum expr_type )6;
  }
#line 685
  goto switch_break___1;
  case_8___0: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
  {
#line 689
  tmp = e->left.expr;
#line 690
  free((void *)e);
#line 691
  e = tmp;
  }
#line 692
  if ((unsigned int )e->type == 6U) {
#line 692
    e->type = (enum expr_type )9;
  } else {
#line 692
    e->type = (enum expr_type )7;
  }
#line 693
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 696
  tmp = e->left.expr;
#line 697
  e->type = (enum expr_type )2;
#line 698
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 699
  tmp->type = (enum expr_type )3;
#line 700
  tmp->right.expr = (struct expr *)((void *)0);
#line 701
  e = expr_transform(e);
  }
#line 702
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 705
  tmp = e->left.expr;
#line 706
  e->type = (enum expr_type )1;
#line 707
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 708
  tmp->type = (enum expr_type )3;
#line 709
  tmp->right.expr = (struct expr *)((void *)0);
#line 710
  e = expr_transform(e);
  }
#line 711
  goto switch_break___1;
  case_11___0: /* CIL Label */ 
#line 713
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
    {
#line 715
    tmp = e->left.expr;
#line 716
    free((void *)e);
#line 717
    e = tmp;
#line 718
    e->type = (enum expr_type )11;
#line 719
    e->left.sym = & symbol_no;
    }
#line 720
    goto switch_break___1;
  }
#line 722
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 724
    tmp = e->left.expr;
#line 725
    free((void *)e);
#line 726
    e = tmp;
#line 727
    e->type = (enum expr_type )11;
#line 728
    e->left.sym = & symbol_mod;
    }
#line 729
    goto switch_break___1;
  }
#line 731
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
    {
#line 733
    tmp = e->left.expr;
#line 734
    free((void *)e);
#line 735
    e = tmp;
#line 736
    e->type = (enum expr_type )11;
#line 737
    e->left.sym = & symbol_yes;
    }
#line 738
    goto switch_break___1;
  }
#line 740
  goto switch_break___1;
  switch_default___0: /* CIL Label */ ;
  switch_break___1: /* CIL Label */ ;
  }
#line 744
  goto switch_break___0;
  switch_default___1: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 748
  return (e);
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 753
  if (! dep) {
#line 754
    return (0);
  }
  {
#line 758
  if ((unsigned int )dep->type == 1U) {
#line 758
    goto case_1;
  }
#line 758
  if ((unsigned int )dep->type == 2U) {
#line 758
    goto case_1;
  }
#line 761
  if ((unsigned int )dep->type == 11U) {
#line 761
    goto case_11;
  }
#line 768
  if ((unsigned int )dep->type == 5U) {
#line 768
    goto case_5;
  }
#line 768
  if ((unsigned int )dep->type == 6U) {
#line 768
    goto case_5;
  }
#line 768
  if ((unsigned int )dep->type == 7U) {
#line 768
    goto case_5;
  }
#line 768
  if ((unsigned int )dep->type == 8U) {
#line 768
    goto case_5;
  }
#line 768
  if ((unsigned int )dep->type == 9U) {
#line 768
    goto case_5;
  }
#line 768
  if ((unsigned int )dep->type == 4U) {
#line 768
    goto case_5;
  }
#line 771
  if ((unsigned int )dep->type == 3U) {
#line 771
    goto case_3;
  }
#line 773
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 759
  tmp = expr_contains_symbol(dep->left.expr, sym);
  }
#line 759
  if (tmp) {
#line 759
    tmp___1 = 1;
  } else {
    {
#line 759
    tmp___0 = expr_contains_symbol(dep->right.expr, sym);
    }
#line 759
    if (tmp___0) {
#line 759
      tmp___1 = 1;
    } else {
#line 759
      tmp___1 = 0;
    }
  }
#line 759
  return (tmp___1);
  case_11: /* CIL Label */ 
#line 762
  return ((unsigned long )dep->left.sym == (unsigned long )sym);
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 769
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 769
    tmp___2 = 1;
  } else
#line 769
  if ((unsigned long )dep->right.sym == (unsigned long )sym) {
#line 769
    tmp___2 = 1;
  } else {
#line 769
    tmp___2 = 0;
  }
#line 769
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 772
  tmp___3 = expr_contains_symbol(dep->left.expr, sym);
  }
#line 772
  return (tmp___3);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 776
  return (0);
}
}
#line 779 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 781
  if (! dep) {
#line 782
    return ((_Bool)0);
  }
  {
#line 785
  if ((unsigned int )dep->type == 2U) {
#line 785
    goto case_2;
  }
#line 788
  if ((unsigned int )dep->type == 11U) {
#line 788
    goto case_11;
  }
#line 790
  if ((unsigned int )dep->type == 4U) {
#line 790
    goto case_4;
  }
#line 796
  if ((unsigned int )dep->type == 5U) {
#line 796
    goto case_5;
  }
#line 802
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 786
  tmp = expr_depends_symbol(dep->left.expr, sym);
  }
#line 786
  if (tmp) {
#line 786
    tmp___1 = 1;
  } else {
    {
#line 786
    tmp___0 = expr_depends_symbol(dep->right.expr, sym);
    }
#line 786
    if (tmp___0) {
#line 786
      tmp___1 = 1;
    } else {
#line 786
      tmp___1 = 0;
    }
  }
#line 786
  return ((_Bool )tmp___1);
  case_11: /* CIL Label */ 
#line 789
  return ((_Bool )((unsigned long )dep->left.sym == (unsigned long )sym));
  case_4: /* CIL Label */ 
#line 791
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 792
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_yes)) {
#line 793
      return ((_Bool)1);
    } else
#line 792
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_mod)) {
#line 793
      return ((_Bool)1);
    }
  }
#line 795
  goto switch_break;
  case_5: /* CIL Label */ 
#line 797
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 798
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_no)) {
#line 799
      return ((_Bool)1);
    }
  }
#line 801
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 805
  return ((_Bool)0);
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) 
{ 
  struct expr *e1 ;
  struct expr *e2 ;
  int tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;

  {
#line 812
  if (! e) {
    {
#line 813
    e = expr_alloc_symbol(sym);
    }
#line 814
    if ((unsigned int )type == 5U) {
      {
#line 815
      e = expr_alloc_one((enum expr_type )3, e);
      }
    }
#line 816
    return (e);
  }
  {
#line 819
  if ((unsigned int )e->type == 2U) {
#line 819
    goto case_2;
  }
#line 829
  if ((unsigned int )e->type == 1U) {
#line 829
    goto case_1;
  }
#line 839
  if ((unsigned int )e->type == 3U) {
#line 839
    goto case_3;
  }
#line 846
  if ((unsigned int )e->type == 4U) {
#line 846
    goto case_4;
  }
#line 846
  if ((unsigned int )e->type == 9U) {
#line 846
    goto case_4;
  }
#line 846
  if ((unsigned int )e->type == 8U) {
#line 846
    goto case_4;
  }
#line 846
  if ((unsigned int )e->type == 7U) {
#line 846
    goto case_4;
  }
#line 846
  if ((unsigned int )e->type == 6U) {
#line 846
    goto case_4;
  }
#line 846
  if ((unsigned int )e->type == 5U) {
#line 846
    goto case_4;
  }
#line 863
  if ((unsigned int )e->type == 11U) {
#line 863
    goto case_11;
  }
#line 867
  if ((unsigned int )e->type == 0U) {
#line 867
    goto case_0;
  }
#line 867
  if ((unsigned int )e->type == 12U) {
#line 867
    goto case_0;
  }
#line 867
  if ((unsigned int )e->type == 10U) {
#line 867
    goto case_0;
  }
#line 818
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 820
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 821
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 822
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 823
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 824
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 825
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 826
  if ((unsigned int )type == 5U) {
    {
#line 827
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 828
  return (e);
  case_1: /* CIL Label */ 
  {
#line 830
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 831
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 832
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 833
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 834
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 835
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 836
  if ((unsigned int )type == 5U) {
    {
#line 837
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 838
  return (e);
  case_3: /* CIL Label */ 
#line 840
  if ((unsigned int )type == 4U) {
#line 840
    tmp = 5;
  } else {
#line 840
    tmp = 4;
  }
  {
#line 840
  tmp___0 = expr_trans_compare(e->left.expr, (enum expr_type )tmp, sym);
  }
#line 840
  return (tmp___0);
  case_4: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 847
  if ((unsigned int )type == 4U) {
#line 848
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 849
      tmp___1 = expr_copy((struct expr  const  *)e);
      }
#line 849
      return (tmp___1);
    }
#line 850
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 851
      tmp___2 = expr_alloc_symbol(& symbol_no);
      }
#line 851
      return (tmp___2);
    }
#line 852
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 853
      tmp___3 = expr_copy((struct expr  const  *)e);
#line 853
      tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
      }
#line 853
      return (tmp___4);
    }
  } else {
#line 855
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 856
      tmp___5 = expr_copy((struct expr  const  *)e);
#line 856
      tmp___6 = expr_alloc_one((enum expr_type )3, tmp___5);
      }
#line 856
      return (tmp___6);
    }
#line 857
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 858
      tmp___7 = expr_alloc_symbol(& symbol_yes);
      }
#line 858
      return (tmp___7);
    }
#line 859
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 860
      tmp___8 = expr_copy((struct expr  const  *)e);
      }
#line 860
      return (tmp___8);
    }
  }
#line 862
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 864
  tmp___9 = expr_alloc_comp(type, e->left.sym, sym);
  }
#line 864
  return (tmp___9);
  case_0: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 870
  return ((struct expr *)((void *)0));
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static enum string_value_kind expr_parse_string(char const   *str , enum symbol_type type ,
                                                union string_value *val ) 
{ 
  char *tail ;
  enum string_value_kind kind ;
  int *tmp ;
  unsigned int tmp___2 ;
  int *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 892
  tmp = __errno_location();
#line 892
  *tmp = 0;
  }
  {
#line 895
  if ((unsigned int )type == 2U) {
#line 895
    goto case_2;
  }
#line 895
  if ((unsigned int )type == 1U) {
#line 895
    goto case_2;
  }
#line 897
  if ((unsigned int )type == 3U) {
#line 897
    goto case_3;
  }
#line 901
  if ((unsigned int )type == 4U) {
#line 901
    goto case_4;
  }
#line 906
  if ((unsigned int )type == 0U) {
#line 906
    goto case_0;
  }
#line 906
  if ((unsigned int )type == 5U) {
#line 906
    goto case_0;
  }
#line 910
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 896
  return ((enum string_value_kind )0);
  case_3: /* CIL Label */ 
  {
#line 898
  val->s = strtoll((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tail),
                   10);
#line 899
  kind = (enum string_value_kind )1;
  }
#line 900
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 902
  val->u = strtoull((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tail),
                    16);
#line 903
  kind = (enum string_value_kind )2;
  }
#line 904
  goto switch_break;
  case_0: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 907
  val->s = strtoll((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tail),
                   0);
#line 908
  kind = (enum string_value_kind )1;
  }
#line 909
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 911
  return ((enum string_value_kind )3);
  switch_break: /* CIL Label */ ;
  }
  {
#line 913
  tmp___3 = __errno_location();
  }
#line 913
  if (*tmp___3) {
#line 913
    tmp___2 = 0U;
  } else
#line 913
  if (! *tail) {
#line 913
    if ((unsigned long )tail > (unsigned long )str) {
      {
#line 913
      tmp___4 = __ctype_b_loc();
      }
#line 913
      if ((int const   )*(*tmp___4 + (int )*(tail + -1)) & 4096) {
#line 913
        tmp___2 = (unsigned int )kind;
      } else {
#line 913
        tmp___2 = 0U;
      }
    } else {
#line 913
      tmp___2 = 0U;
    }
  } else {
#line 913
    tmp___2 = 0U;
  }
#line 913
  return ((enum string_value_kind )tmp___2);
}
}
#line 917 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
tristate expr_calc_value(struct expr *e ) 
{ 
  tristate val1 ;
  tristate val2 ;
  char const   *str1 ;
  char const   *str2 ;
  enum string_value_kind k1 ;
  enum string_value_kind k2 ;
  union string_value lval ;
  union string_value rval ;
  int res ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 921
  k1 = (enum string_value_kind )0;
#line 921
  k2 = (enum string_value_kind )0;
#line 922
  lval.u = 0ULL;
#line 922
  rval.u = 0ULL;
#line 925
  if (! e) {
#line 926
    return ((tristate )2);
  }
  {
#line 929
  if ((unsigned int )e->type == 11U) {
#line 929
    goto case_11;
  }
#line 932
  if ((unsigned int )e->type == 2U) {
#line 932
    goto case_2;
  }
#line 936
  if ((unsigned int )e->type == 1U) {
#line 936
    goto case_1;
  }
#line 940
  if ((unsigned int )e->type == 3U) {
#line 940
    goto case_3;
  }
#line 948
  if ((unsigned int )e->type == 5U) {
#line 948
    goto case_5;
  }
#line 948
  if ((unsigned int )e->type == 6U) {
#line 948
    goto case_5;
  }
#line 948
  if ((unsigned int )e->type == 7U) {
#line 948
    goto case_5;
  }
#line 948
  if ((unsigned int )e->type == 8U) {
#line 948
    goto case_5;
  }
#line 948
  if ((unsigned int )e->type == 9U) {
#line 948
    goto case_5;
  }
#line 948
  if ((unsigned int )e->type == 4U) {
#line 948
    goto case_5;
  }
#line 950
  goto switch_default;
  case_11: /* CIL Label */ 
  {
#line 930
  sym_calc_value(e->left.sym);
  }
#line 931
  return ((e->left.sym)->curr.tri);
  case_2: /* CIL Label */ 
  {
#line 933
  val1 = expr_calc_value(e->left.expr);
#line 934
  val2 = expr_calc_value(e->right.expr);
  }
#line 935
  if ((unsigned int )val1 < (unsigned int )val2) {
#line 935
    tmp = (unsigned int )val1;
  } else {
#line 935
    tmp = (unsigned int )val2;
  }
#line 935
  return ((tristate )tmp);
  case_1: /* CIL Label */ 
  {
#line 937
  val1 = expr_calc_value(e->left.expr);
#line 938
  val2 = expr_calc_value(e->right.expr);
  }
#line 939
  if ((unsigned int )val1 > (unsigned int )val2) {
#line 939
    tmp___0 = (unsigned int )val1;
  } else {
#line 939
    tmp___0 = (unsigned int )val2;
  }
#line 939
  return ((tristate )tmp___0);
  case_3: /* CIL Label */ 
  {
#line 941
  val1 = expr_calc_value(e->left.expr);
  }
#line 942
  return ((tristate )(2U - (unsigned int )val1));
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 949
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 951
  printf((char const   */* __restrict  */)"expr_calc_value: %d?\n", (unsigned int )e->type);
  }
#line 952
  return ((tristate )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 955
  sym_calc_value(e->left.sym);
#line 956
  sym_calc_value(e->right.sym);
#line 957
  str1 = sym_get_string_value(e->left.sym);
#line 958
  str2 = sym_get_string_value(e->right.sym);
  }
#line 960
  if ((unsigned int )(e->left.sym)->type != 5U) {
    {
#line 961
    k1 = expr_parse_string(str1, (e->left.sym)->type, & lval);
#line 962
    k2 = expr_parse_string(str2, (e->right.sym)->type, & rval);
    }
  } else
#line 960
  if ((unsigned int )(e->right.sym)->type != 5U) {
    {
#line 961
    k1 = expr_parse_string(str1, (e->left.sym)->type, & lval);
#line 962
    k2 = expr_parse_string(str2, (e->right.sym)->type, & rval);
    }
  }
#line 965
  if ((unsigned int )k1 == 0U) {
    {
#line 966
    res = strcmp(str1, str2);
    }
  } else
#line 965
  if ((unsigned int )k2 == 0U) {
    {
#line 966
    res = strcmp(str1, str2);
    }
  } else
#line 967
  if ((unsigned int )k1 == 3U) {
#line 967
    goto _L;
  } else
#line 967
  if ((unsigned int )k2 == 3U) {
    _L: /* CIL Label */ 
#line 968
    if ((unsigned int )e->type != 4U) {
#line 968
      if ((unsigned int )e->type != 5U) {
        {
#line 969
        printf((char const   */* __restrict  */)"Cannot compare \"%s\" and \"%s\"\n",
               str1, str2);
        }
#line 970
        return ((tristate )0);
      }
    }
    {
#line 972
    res = strcmp(str1, str2);
    }
  } else
#line 973
  if ((unsigned int )k1 == 2U) {
#line 974
    res = (lval.u > rval.u) - (lval.u < rval.u);
  } else
#line 973
  if ((unsigned int )k2 == 2U) {
#line 974
    res = (lval.u > rval.u) - (lval.u < rval.u);
  } else {
#line 976
    res = (lval.s > rval.s) - (lval.s < rval.s);
  }
  {
#line 979
  if ((unsigned int )e->type == 4U) {
#line 979
    goto case_4___0;
  }
#line 981
  if ((unsigned int )e->type == 9U) {
#line 981
    goto case_9___0;
  }
#line 983
  if ((unsigned int )e->type == 8U) {
#line 983
    goto case_8___0;
  }
#line 985
  if ((unsigned int )e->type == 7U) {
#line 985
    goto case_7___0;
  }
#line 987
  if ((unsigned int )e->type == 6U) {
#line 987
    goto case_6___0;
  }
#line 989
  if ((unsigned int )e->type == 5U) {
#line 989
    goto case_5___0;
  }
#line 991
  goto switch_default___0;
  case_4___0: /* CIL Label */ 
#line 980
  if (res) {
#line 980
    tmp___1 = 0;
  } else {
#line 980
    tmp___1 = 2;
  }
#line 980
  return ((tristate )tmp___1);
  case_9___0: /* CIL Label */ 
#line 982
  if (res >= 0) {
#line 982
    tmp___2 = 2;
  } else {
#line 982
    tmp___2 = 0;
  }
#line 982
  return ((tristate )tmp___2);
  case_8___0: /* CIL Label */ 
#line 984
  if (res > 0) {
#line 984
    tmp___3 = 2;
  } else {
#line 984
    tmp___3 = 0;
  }
#line 984
  return ((tristate )tmp___3);
  case_7___0: /* CIL Label */ 
#line 986
  if (res <= 0) {
#line 986
    tmp___4 = 2;
  } else {
#line 986
    tmp___4 = 0;
  }
#line 986
  return ((tristate )tmp___4);
  case_6___0: /* CIL Label */ 
#line 988
  if (res < 0) {
#line 988
    tmp___5 = 2;
  } else {
#line 988
    tmp___5 = 0;
  }
#line 988
  return ((tristate )tmp___5);
  case_5___0: /* CIL Label */ 
#line 990
  if (res) {
#line 990
    tmp___6 = 2;
  } else {
#line 990
    tmp___6 = 0;
  }
#line 990
  return ((tristate )tmp___6);
  switch_default___0: /* CIL Label */ 
  {
#line 992
  printf((char const   */* __restrict  */)"expr_calc_value: relation %d?\n", (unsigned int )e->type);
  }
#line 993
  return ((tristate )0);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) 
{ 


  {
#line 999
  if ((unsigned int )t1 == (unsigned int )t2) {
#line 1000
    return (0);
  }
  {
#line 1005
  if ((unsigned int )t1 == 8U) {
#line 1005
    goto case_8;
  }
#line 1005
  if ((unsigned int )t1 == 9U) {
#line 1005
    goto case_8;
  }
#line 1005
  if ((unsigned int )t1 == 6U) {
#line 1005
    goto case_8;
  }
#line 1005
  if ((unsigned int )t1 == 7U) {
#line 1005
    goto case_8;
  }
#line 1009
  if ((unsigned int )t1 == 5U) {
#line 1009
    goto case_5;
  }
#line 1009
  if ((unsigned int )t1 == 4U) {
#line 1009
    goto case_5;
  }
#line 1012
  if ((unsigned int )t1 == 3U) {
#line 1012
    goto case_3;
  }
#line 1015
  if ((unsigned int )t1 == 2U) {
#line 1015
    goto case_2;
  }
#line 1018
  if ((unsigned int )t1 == 1U) {
#line 1018
    goto case_1;
  }
#line 1021
  if ((unsigned int )t1 == 10U) {
#line 1021
    goto case_10;
  }
#line 1024
  goto switch_default;
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1006
  if ((unsigned int )t2 == 4U) {
#line 1007
    return (1);
  } else
#line 1006
  if ((unsigned int )t2 == 5U) {
#line 1007
    return (1);
  }
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1010
  if ((unsigned int )t2 == 3U) {
#line 1011
    return (1);
  }
  case_3: /* CIL Label */ 
#line 1013
  if ((unsigned int )t2 == 2U) {
#line 1014
    return (1);
  }
  case_2: /* CIL Label */ 
#line 1016
  if ((unsigned int )t2 == 1U) {
#line 1017
    return (1);
  }
  case_1: /* CIL Label */ 
#line 1019
  if ((unsigned int )t2 == 10U) {
#line 1020
    return (1);
  }
  case_10: /* CIL Label */ 
#line 1022
  if ((unsigned int )t2 == 0U) {
#line 1023
    return (1);
  }
  switch_default: /* CIL Label */ 
#line 1025
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1027
  printf((char const   */* __restrict  */)"[%dgt%d?]", (unsigned int )t1, (unsigned int )t2);
  }
#line 1028
  return (0);
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
__inline static struct expr *expr_get_leftmost_symbol(struct expr  const  *e ) 
{ 
  struct expr *tmp ;

  {
#line 1035
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 1036
    return ((struct expr *)((void *)0));
  }
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1038
    if (! ((unsigned int const   )e->type != 11U)) {
#line 1038
      goto while_break;
    }
#line 1039
    e = (struct expr  const  *)e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1041
  tmp = expr_copy(e);
  }
#line 1041
  return (tmp);
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
struct expr *expr_simplify_unmet_dep(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *ret ;
  struct expr *tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *e ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  int tmp___5 ;
  struct expr *tmp___6 ;

  {
  {
#line 1053
  if ((unsigned int )e1->type == 1U) {
#line 1053
    goto case_1;
  }
#line 1057
  if ((unsigned int )e1->type == 2U) {
#line 1057
    goto case_2;
  }
#line 1065
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1054
  tmp = expr_simplify_unmet_dep(e1->right.expr, e2);
#line 1054
  tmp___0 = expr_simplify_unmet_dep(e1->left.expr, e2);
#line 1054
  tmp___1 = expr_alloc_and(tmp___0, tmp);
  }
#line 1054
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 1059
  tmp___2 = expr_copy((struct expr  const  *)e2);
#line 1059
  tmp___3 = expr_copy((struct expr  const  *)e1);
#line 1059
  e = expr_alloc_and(tmp___3, tmp___2);
#line 1060
  e = expr_eliminate_dups(e);
#line 1061
  tmp___5 = expr_eq(e, e1);
  }
#line 1061
  if (tmp___5) {
#line 1061
    ret = (struct expr *)((void *)0);
  } else {
#line 1061
    ret = e1;
  }
  {
#line 1062
  expr_free(e);
  }
#line 1063
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1066
  ret = e1;
#line 1067
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1070
  tmp___6 = expr_get_leftmost_symbol((struct expr  const  *)ret);
  }
#line 1070
  return (tmp___6);
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
void expr_print(struct expr *e , void (*fn)(void * , struct symbol * , char const   * ) ,
                void *data , int prevtoken ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char buf[32] ;
  int tmp___2 ;

  {
#line 1075
  if (! e) {
    {
#line 1076
    (*fn)(data, (struct symbol *)((void *)0), "y");
    }
#line 1077
    return;
  }
  {
#line 1080
  tmp = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1080
  if (tmp > 0) {
    {
#line 1081
    (*fn)(data, (struct symbol *)((void *)0), "(");
    }
  }
  {
#line 1083
  if ((unsigned int )e->type == 11U) {
#line 1083
    goto case_11;
  }
#line 1089
  if ((unsigned int )e->type == 3U) {
#line 1089
    goto case_3;
  }
#line 1093
  if ((unsigned int )e->type == 4U) {
#line 1093
    goto case_4;
  }
#line 1102
  if ((unsigned int )e->type == 6U) {
#line 1102
    goto case_6;
  }
#line 1102
  if ((unsigned int )e->type == 7U) {
#line 1102
    goto case_6;
  }
#line 1111
  if ((unsigned int )e->type == 8U) {
#line 1111
    goto case_8;
  }
#line 1111
  if ((unsigned int )e->type == 9U) {
#line 1111
    goto case_8;
  }
#line 1119
  if ((unsigned int )e->type == 5U) {
#line 1119
    goto case_5;
  }
#line 1127
  if ((unsigned int )e->type == 1U) {
#line 1127
    goto case_1;
  }
#line 1132
  if ((unsigned int )e->type == 2U) {
#line 1132
    goto case_2;
  }
#line 1137
  if ((unsigned int )e->type == 10U) {
#line 1137
    goto case_10;
  }
#line 1144
  if ((unsigned int )e->type == 12U) {
#line 1144
    goto case_12;
  }
#line 1151
  goto switch_default;
  case_11: /* CIL Label */ 
#line 1084
  if ((e->left.sym)->name) {
    {
#line 1085
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1087
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
#line 1088
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1090
  (*fn)(data, (struct symbol *)((void *)0), "!");
#line 1091
  expr_print(e->left.expr, fn, data, 3);
  }
#line 1092
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1094
  if ((e->left.sym)->name) {
    {
#line 1095
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1097
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
  {
#line 1098
  (*fn)(data, (struct symbol *)((void *)0), "=");
#line 1099
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1100
  goto switch_break;
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1103
  if ((e->left.sym)->name) {
    {
#line 1104
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1106
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
#line 1107
  if ((unsigned int )e->type == 7U) {
#line 1107
    tmp___0 = "<=";
  } else {
#line 1107
    tmp___0 = "<";
  }
  {
#line 1107
  (*fn)(data, (struct symbol *)((void *)0), tmp___0);
#line 1108
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1109
  goto switch_break;
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 1112
  if ((e->left.sym)->name) {
    {
#line 1113
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1115
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
#line 1116
  if ((unsigned int )e->type == 9U) {
#line 1116
    tmp___1 = ">=";
  } else {
#line 1116
    tmp___1 = ">";
  }
  {
#line 1116
  (*fn)(data, (struct symbol *)((void *)0), tmp___1);
#line 1117
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1118
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1120
  if ((e->left.sym)->name) {
    {
#line 1121
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1123
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
  {
#line 1124
  (*fn)(data, (struct symbol *)((void *)0), "!=");
#line 1125
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1126
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1128
  expr_print(e->left.expr, fn, data, 1);
#line 1129
  (*fn)(data, (struct symbol *)((void *)0), " || ");
#line 1130
  expr_print(e->right.expr, fn, data, 1);
  }
#line 1131
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1133
  expr_print(e->left.expr, fn, data, 2);
#line 1134
  (*fn)(data, (struct symbol *)((void *)0), " && ");
#line 1135
  expr_print(e->right.expr, fn, data, 2);
  }
#line 1136
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1138
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1139
  if (e->left.expr) {
    {
#line 1140
    (*fn)(data, (struct symbol *)((void *)0), " ^ ");
#line 1141
    expr_print(e->left.expr, fn, data, 10);
    }
  }
#line 1143
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1145
  (*fn)(data, (struct symbol *)((void *)0), "[");
#line 1146
  (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
#line 1147
  (*fn)(data, (struct symbol *)((void *)0), " ");
#line 1148
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
#line 1149
  (*fn)(data, (struct symbol *)((void *)0), "]");
  }
#line 1150
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1154
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"<unknown type %d>",
          (unsigned int )e->type);
#line 1155
  (*fn)(data, (struct symbol *)((void *)0), (char const   *)(buf));
  }
#line 1156
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1159
  tmp___2 = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1159
  if (tmp___2 > 0) {
    {
#line 1160
    (*fn)(data, (struct symbol *)((void *)0), ")");
    }
  }
#line 1161
  return;
}
}
#line 1163 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static void expr_print_file_helper(void *data , struct symbol *sym , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 1165
  tmp = strlen(str);
#line 1165
  xfwrite((void const   *)str, tmp, (size_t )1, (FILE *)data);
  }
#line 1166
  return;
}
}
#line 1168 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
void expr_fprint(struct expr *e , FILE *out ) 
{ 


  {
  {
#line 1170
  expr_print(e, & expr_print_file_helper, (void *)out, 0);
  }
#line 1171
  return;
}
}
#line 1173 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
static void expr_print_gstr_helper(void *data , struct symbol *sym , char const   *str ) 
{ 
  struct gstr *gs ;
  char const   *sym_str ;
  unsigned int extra_length ;
  size_t tmp ;
  char const   *last_cr ;
  char *tmp___0 ;
  unsigned int last_line_length ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1175
  gs = (struct gstr *)data;
#line 1176
  sym_str = (char const   *)((void *)0);
#line 1178
  if (sym) {
    {
#line 1179
    sym_str = sym_get_string_value(sym);
    }
  }
#line 1181
  if (gs->max_width) {
    {
#line 1182
    tmp = strlen(str);
#line 1182
    extra_length = (unsigned int )tmp;
#line 1183
    tmp___0 = strrchr((char const   *)gs->s, '\n');
#line 1183
    last_cr = (char const   *)tmp___0;
    }
#line 1186
    if (sym_str) {
      {
#line 1187
      tmp___1 = strlen(sym_str);
#line 1187
      extra_length = (unsigned int )((size_t )extra_length + (4UL + tmp___1));
      }
    }
#line 1189
    if (! last_cr) {
#line 1190
      last_cr = (char const   *)gs->s;
    }
    {
#line 1192
    tmp___2 = strlen((char const   *)gs->s);
#line 1192
    last_line_length = (unsigned int )(tmp___2 - (size_t )(last_cr - (char const   *)gs->s));
    }
#line 1194
    if (last_line_length + extra_length > (unsigned int )gs->max_width) {
      {
#line 1195
      str_append(gs, "\\\n");
      }
    }
  }
  {
#line 1198
  str_append(gs, str);
  }
#line 1199
  if (sym) {
#line 1199
    if ((unsigned int )sym->type != 0U) {
      {
#line 1200
      str_printf(gs, " [=%s]", sym_str);
      }
    }
  }
#line 1201
  return;
}
}
#line 1203 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/expr.c"
void expr_gstr_print(struct expr *e , struct gstr *gs ) 
{ 


  {
  {
#line 1205
  expr_print(e, & expr_print_gstr_helper, (void *)gs, 0);
  }
#line 1206
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol symbol_yes  = 
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
     {(struct symbol *)0, (char *)"y", 0U, {(void *)"y", (tristate )2}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol symbol_mod  = 
#line 14
     {(struct symbol *)0, (char *)"m", 0U, {(void *)"m", (tristate )1}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol symbol_no  = 
#line 14
     {(struct symbol *)0, (char *)"n", 0U, {(void *)"n", (tristate )0}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol symbol_empty  = 
#line 14
     {(struct symbol *)0, (char *)"", 0U, {(void *)"", (tristate )0}, {{(void *)0, 0U},
                                                                     {(void *)0, 0U},
                                                                     {(void *)0, 0U},
                                                                     {(void *)0, 0U}},
    0U, 128, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 34 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
tristate modules_val  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void sym_add_default(struct symbol *sym , char const   *def ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  struct symbol *tmp___0 ;

  {
  {
#line 40
  tmp = prop_alloc((enum prop_type )4, sym);
#line 40
  prop = tmp;
#line 42
  tmp___0 = sym_lookup(def, 1);
#line 42
  prop->expr = expr_alloc_symbol(tmp___0);
  }
#line 43
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static _Bool inited  =    (_Bool)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
void sym_init(void) 
{ 
  struct symbol *sym ;
  struct utsname uts ;

  {
#line 51
  if (inited) {
#line 52
    return;
  }
  {
#line 53
  inited = (_Bool)1;
#line 55
  uname(& uts);
#line 57
  sym = sym_lookup("UNAME_RELEASE", 0);
#line 58
  sym->type = (enum symbol_type )5;
#line 59
  sym->flags |= 4096;
#line 60
  sym_add_default(sym, (char const   *)(uts.release));
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
enum symbol_type sym_get_type(struct symbol *sym ) 
{ 
  enum symbol_type type ;
  _Bool tmp ;

  {
#line 65
  type = sym->type;
#line 67
  if ((unsigned int )type == 2U) {
    {
#line 68
    tmp = sym_is_choice_value(sym);
    }
#line 68
    if (tmp) {
#line 68
      if ((unsigned int )sym->visible == 2U) {
#line 69
        type = (enum symbol_type )1;
      } else {
#line 68
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 70
    if ((unsigned int )modules_val == 0U) {
#line 71
      type = (enum symbol_type )1;
    }
  }
#line 73
  return (type);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
char const   *sym_type_name(enum symbol_type type ) 
{ 


  {
  {
#line 79
  if ((unsigned int )type == 1U) {
#line 79
    goto case_1;
  }
#line 81
  if ((unsigned int )type == 2U) {
#line 81
    goto case_2;
  }
#line 83
  if ((unsigned int )type == 3U) {
#line 83
    goto case_3;
  }
#line 85
  if ((unsigned int )type == 4U) {
#line 85
    goto case_4;
  }
#line 87
  if ((unsigned int )type == 5U) {
#line 87
    goto case_5;
  }
#line 89
  if ((unsigned int )type == 0U) {
#line 89
    goto case_0;
  }
#line 91
  if ((unsigned int )type == 6U) {
#line 91
    goto case_6;
  }
#line 78
  goto switch_break;
  case_1: /* CIL Label */ 
#line 80
  return ("boolean");
  case_2: /* CIL Label */ 
#line 82
  return ("tristate");
  case_3: /* CIL Label */ 
#line 84
  return ("integer");
  case_4: /* CIL Label */ 
#line 86
  return ("hex");
  case_5: /* CIL Label */ 
#line 88
  return ("string");
  case_0: /* CIL Label */ 
#line 90
  return ("unknown");
  case_6: /* CIL Label */ 
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 94
  return ("???");
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct property *sym_get_choice_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 101
  prop = sym->prop;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! prop) {
#line 101
      goto while_break;
    }
#line 101
    if ((unsigned int )prop->type == 5U) {
#line 102
      return (prop);
    }
#line 101
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return ((struct property *)((void *)0));
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct property *sym_get_env_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 110
  prop = sym->prop;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! prop) {
#line 110
      goto while_break;
    }
#line 110
    if ((unsigned int )prop->type == 8U) {
#line 111
      return (prop);
    }
#line 110
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return ((struct property *)((void *)0));
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct property *sym_get_default_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 119
  prop = sym->prop;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! prop) {
#line 119
      goto while_break;
    }
#line 119
    if ((unsigned int )prop->type == 4U) {
      {
#line 120
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 121
      if ((unsigned int )prop->visible.tri != 0U) {
#line 122
        return (prop);
      }
    }
#line 119
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return ((struct property *)((void *)0));
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct property *sym_get_range_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 131
  prop = sym->prop;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! prop) {
#line 131
      goto while_break;
    }
#line 131
    if ((unsigned int )prop->type == 7U) {
      {
#line 132
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 133
      if ((unsigned int )prop->visible.tri != 0U) {
#line 134
        return (prop);
      }
    }
#line 131
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return ((struct property *)((void *)0));
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static long long sym_get_range_val(struct symbol *sym , int base ) 
{ 
  long long tmp ;

  {
  {
#line 141
  sym_calc_value(sym);
  }
  {
#line 143
  if ((unsigned int )sym->type == 3U) {
#line 143
    goto case_3;
  }
#line 146
  if ((unsigned int )sym->type == 4U) {
#line 146
    goto case_4;
  }
#line 149
  goto switch_default;
  case_3: /* CIL Label */ 
#line 144
  base = 10;
#line 145
  goto switch_break;
  case_4: /* CIL Label */ 
#line 147
  base = 16;
#line 148
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 150
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = strtoll((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
                base);
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void sym_validate_range(struct symbol *sym ) 
{ 
  struct property *prop ;
  int base ;
  long long val ;
  long long val2 ;
  char str[64] ;
  char *tmp ;

  {
  {
#line 163
  if ((unsigned int )sym->type == 3U) {
#line 163
    goto case_3;
  }
#line 166
  if ((unsigned int )sym->type == 4U) {
#line 166
    goto case_4;
  }
#line 169
  goto switch_default;
  case_3: /* CIL Label */ 
#line 164
  base = 10;
#line 165
  goto switch_break;
  case_4: /* CIL Label */ 
#line 167
  base = 16;
#line 168
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 170
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 172
  prop = sym_get_range_prop(sym);
  }
#line 173
  if (! prop) {
#line 174
    return;
  }
  {
#line 175
  val = strtoll((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
                base);
#line 176
  val2 = sym_get_range_val((prop->expr)->left.sym, base);
  }
#line 177
  if (val >= val2) {
    {
#line 178
    val2 = sym_get_range_val((prop->expr)->right.sym, base);
    }
#line 179
    if (val <= val2) {
#line 180
      return;
    }
  }
#line 182
  if ((unsigned int )sym->type == 3U) {
    {
#line 183
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%lld",
            val2);
    }
  } else {
    {
#line 185
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"0x%llx",
            val2);
    }
  }
  {
#line 186
  tmp = strdup((char const   *)(str));
#line 186
  sym->curr.val = (void *)tmp;
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void sym_set_changed(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 193
  sym->flags |= 1024;
#line 194
  prop = sym->prop;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! prop) {
#line 194
      goto while_break;
    }
#line 195
    if (prop->menu) {
#line 196
      (prop->menu)->flags |= 1U;
    }
#line 194
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void sym_set_all_changed(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < 9973)) {
#line 205
      goto while_break;
    }
#line 205
    sym = symbol_hash[i];
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! sym) {
#line 205
        goto while_break___0;
      }
#line 205
      if ((unsigned int )sym->type != 6U) {
        {
#line 206
        sym_set_changed(sym);
        }
      }
#line 205
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 205
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void sym_calc_visibility(struct symbol *sym ) 
{ 
  struct property *prop ;
  tristate tri ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;

  {
#line 215
  tri = (tristate )0;
#line 216
  prop = sym->prop;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! prop) {
#line 216
      goto while_break;
    }
#line 216
    if (prop->text) {
      {
#line 217
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 218
      if ((unsigned int )tri > (unsigned int )prop->visible.tri) {
#line 218
        tri = tri;
      } else {
#line 218
        tri = prop->visible.tri;
      }
    }
#line 216
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if ((unsigned int )tri == 1U) {
#line 220
    if ((unsigned int )sym->type != 2U) {
#line 221
      tri = (tristate )2;
    } else
#line 220
    if ((unsigned int )modules_val == 0U) {
#line 221
      tri = (tristate )2;
    }
  }
#line 222
  if ((unsigned int )sym->visible != (unsigned int )tri) {
    {
#line 223
    sym->visible = tri;
#line 224
    sym_set_changed(sym);
    }
  }
  {
#line 226
  tmp = sym_is_choice_value(sym);
  }
#line 226
  if (tmp) {
#line 227
    return;
  }
#line 229
  tri = (tristate )2;
#line 230
  if (sym->dir_dep.expr) {
    {
#line 231
    tri = expr_calc_value(sym->dir_dep.expr);
    }
  }
#line 232
  if ((unsigned int )tri == 1U) {
#line 233
    tri = (tristate )2;
  }
#line 234
  if ((unsigned int )sym->dir_dep.tri != (unsigned int )tri) {
    {
#line 235
    sym->dir_dep.tri = tri;
#line 236
    sym_set_changed(sym);
    }
  }
#line 238
  tri = (tristate )0;
#line 239
  if (sym->rev_dep.expr) {
    {
#line 240
    tri = expr_calc_value(sym->rev_dep.expr);
    }
  }
#line 241
  if ((unsigned int )tri == 1U) {
    {
#line 241
    tmp___0 = sym_get_type(sym);
    }
#line 241
    if ((unsigned int )tmp___0 == 1U) {
#line 242
      tri = (tristate )2;
    }
  }
#line 243
  if ((unsigned int )sym->rev_dep.tri != (unsigned int )tri) {
    {
#line 244
    sym->rev_dep.tri = tri;
#line 245
    sym_set_changed(sym);
    }
  }
#line 247
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol *sym_choice_default(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;

  {
#line 262
  prop = sym->prop;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! prop) {
#line 262
      goto while_break;
    }
#line 262
    if ((unsigned int )prop->type == 4U) {
      {
#line 263
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 264
      if ((unsigned int )prop->visible.tri == 0U) {
#line 265
        goto __Cont;
      }
      {
#line 266
      def_sym = prop_get_symbol(prop);
      }
#line 267
      if ((unsigned int )def_sym->visible != 0U) {
#line 268
        return (def_sym);
      }
    }
    __Cont: /* CIL Label */ 
#line 262
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  prop = sym_get_choice_prop(sym);
#line 273
  e = prop->expr;
  }
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 273
    if (e) {
#line 273
      def_sym = e->right.sym;
#line 273
      if (! def_sym) {
#line 273
        goto while_break___0;
      }
    } else {
#line 273
      goto while_break___0;
    }
#line 274
    if ((unsigned int )def_sym->visible != 0U) {
#line 275
      return (def_sym);
    }
#line 273
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 278
  return ((struct symbol *)((void *)0));
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct symbol *sym_calc_choice(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;
  int flags ;

  {
  {
#line 289
  flags = sym->flags;
#line 290
  prop = sym_get_choice_prop(sym);
#line 291
  e = prop->expr;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (e) {
#line 291
      def_sym = e->right.sym;
#line 291
      if (! def_sym) {
#line 291
        goto while_break;
      }
    } else {
#line 291
      goto while_break;
    }
    {
#line 292
    sym_calc_visibility(def_sym);
    }
#line 293
    if ((unsigned int )def_sym->visible != 0U) {
#line 294
      flags &= def_sym->flags;
    }
#line 291
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  sym->flags &= flags | -65537;
#line 300
  def_sym = (struct symbol *)sym->def[0].val;
#line 301
  if (def_sym) {
#line 301
    if ((unsigned int )def_sym->visible != 0U) {
#line 302
      return (def_sym);
    }
  }
  {
#line 304
  def_sym = sym_choice_default(sym);
  }
#line 306
  if ((unsigned long )def_sym == (unsigned long )((void *)0)) {
#line 308
    sym->curr.tri = (tristate )0;
  }
#line 310
  return (def_sym);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
void sym_calc_value(struct symbol *sym ) 
{ 
  struct symbol_value newval ;
  struct symbol_value oldval ;
  struct property *prop ;
  struct expr *e ;
  struct symbol *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  enum symbol_type tmp___2 ;
  struct symbol *tmp___4 ;
  _Bool tmp___5 ;
  tristate tmp___7 ;
  tristate tmp___8 ;
  _Bool tmp___9 ;
  struct expr *e___0 ;
  _Bool tmp___10 ;
  enum symbol_type tmp___11 ;
  _Bool tmp___12 ;
  struct symbol *ds ;
  struct symbol *tmp___13 ;
  struct symbol *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  struct symbol *choice_sym ;
  _Bool tmp___17 ;

  {
#line 319
  if (! sym) {
#line 320
    return;
  }
#line 322
  if (sym->flags & 128) {
#line 323
    return;
  }
  {
#line 325
  tmp___0 = sym_is_choice_value(sym);
  }
#line 325
  if (tmp___0) {
#line 325
    if (sym->flags & 1048576) {
      {
#line 327
      sym->flags &= -1048577;
#line 328
      prop = sym_get_choice_prop(sym);
#line 329
      tmp = prop_get_symbol(prop);
#line 329
      sym_calc_value(tmp);
      }
    }
  }
#line 332
  sym->flags |= 128;
#line 334
  oldval = sym->curr;
  {
#line 339
  if ((unsigned int )sym->type == 5U) {
#line 339
    goto case_5;
  }
#line 339
  if ((unsigned int )sym->type == 4U) {
#line 339
    goto case_5;
  }
#line 339
  if ((unsigned int )sym->type == 3U) {
#line 339
    goto case_5;
  }
#line 343
  if ((unsigned int )sym->type == 2U) {
#line 343
    goto case_2;
  }
#line 343
  if ((unsigned int )sym->type == 1U) {
#line 343
    goto case_2;
  }
#line 346
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 340
  newval = symbol_empty.curr;
#line 341
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 344
  newval = symbol_no.curr;
#line 345
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 347
  sym->curr.val = (void *)sym->name;
#line 348
  sym->curr.tri = (tristate )0;
#line 349
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  tmp___1 = sym_is_choice_value(sym);
  }
#line 351
  if (! tmp___1) {
#line 352
    sym->flags &= -513;
  }
  {
#line 354
  sym_calc_visibility(sym);
#line 357
  sym->curr = newval;
#line 359
  tmp___2 = sym_get_type(sym);
  }
  {
#line 361
  if ((unsigned int )tmp___2 == 2U) {
#line 361
    goto case_2___0;
  }
#line 361
  if ((unsigned int )tmp___2 == 1U) {
#line 361
    goto case_2___0;
  }
#line 407
  if ((unsigned int )tmp___2 == 3U) {
#line 407
    goto case_3___0;
  }
#line 407
  if ((unsigned int )tmp___2 == 4U) {
#line 407
    goto case_3___0;
  }
#line 407
  if ((unsigned int )tmp___2 == 5U) {
#line 407
    goto case_3___0;
  }
#line 425
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 362
  tmp___10 = sym_is_choice_value(sym);
  }
#line 362
  if (tmp___10) {
#line 362
    if ((unsigned int )sym->visible == 2U) {
      {
#line 363
      prop = sym_get_choice_prop(sym);
#line 364
      tmp___4 = prop_get_symbol(prop);
      }
#line 364
      if ((unsigned long )tmp___4->curr.val == (unsigned long )sym) {
#line 364
        newval.tri = (tristate )2;
      } else {
#line 364
        newval.tri = (tristate )0;
      }
    } else {
#line 362
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 366
    if ((unsigned int )sym->visible != 0U) {
      {
#line 370
      sym->flags |= 512;
#line 371
      tmp___5 = sym_has_value(sym);
      }
#line 371
      if (tmp___5) {
#line 372
        if ((unsigned int )sym->def[0].tri < (unsigned int )sym->visible) {
#line 372
          newval.tri = sym->def[0].tri;
        } else {
#line 372
          newval.tri = sym->visible;
        }
#line 374
        goto calc_newval;
      }
    }
#line 377
    if ((unsigned int )sym->rev_dep.tri != 0U) {
#line 378
      sym->flags |= 512;
    }
    {
#line 379
    tmp___9 = sym_is_choice(sym);
    }
#line 379
    if (! tmp___9) {
      {
#line 380
      prop = sym_get_default_prop(sym);
      }
#line 381
      if (prop) {
        {
#line 382
        sym->flags |= 512;
#line 383
        tmp___8 = expr_calc_value(prop->expr);
        }
#line 383
        if ((unsigned int )tmp___8 < (unsigned int )prop->visible.tri) {
          {
#line 383
          tmp___7 = expr_calc_value(prop->expr);
#line 383
          newval.tri = tmp___7;
          }
        } else {
#line 383
          newval.tri = prop->visible.tri;
        }
      }
    }
    calc_newval: 
#line 388
    if ((unsigned int )sym->dir_dep.tri == 0U) {
#line 388
      if ((unsigned int )sym->rev_dep.tri != 0U) {
        {
#line 390
        e___0 = expr_simplify_unmet_dep(sym->rev_dep.expr, sym->dir_dep.expr);
#line 392
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: (");
#line 393
        expr_fprint(e___0, stderr);
#line 394
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)") selects %s which has unmet direct dependencies (",
                sym->name);
#line 396
        expr_fprint(sym->dir_dep.expr, stderr);
#line 397
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
#line 398
        expr_free(e___0);
        }
      }
    }
#line 400
    if ((unsigned int )newval.tri > (unsigned int )sym->rev_dep.tri) {
#line 400
      newval.tri = newval.tri;
    } else {
#line 400
      newval.tri = sym->rev_dep.tri;
    }
  }
#line 402
  if ((unsigned int )newval.tri == 1U) {
    {
#line 402
    tmp___11 = sym_get_type(sym);
    }
#line 402
    if ((unsigned int )tmp___11 == 1U) {
#line 403
      newval.tri = (tristate )2;
    }
  }
#line 404
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 408
  if ((unsigned int )sym->visible != 0U) {
    {
#line 409
    sym->flags |= 512;
#line 410
    tmp___12 = sym_has_value(sym);
    }
#line 410
    if (tmp___12) {
#line 411
      newval.val = sym->def[0].val;
#line 412
      goto switch_break___0;
    }
  }
  {
#line 415
  prop = sym_get_default_prop(sym);
  }
#line 416
  if (prop) {
    {
#line 417
    tmp___13 = prop_get_symbol(prop);
#line 417
    ds = tmp___13;
    }
#line 418
    if (ds) {
      {
#line 419
      sym->flags |= 512;
#line 420
      sym_calc_value(ds);
#line 421
      newval.val = ds->curr.val;
      }
    }
  }
#line 424
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 429
  sym->curr = newval;
#line 430
  tmp___15 = sym_is_choice(sym);
  }
#line 430
  if (tmp___15) {
#line 430
    if ((unsigned int )newval.tri == 2U) {
      {
#line 431
      tmp___14 = sym_calc_choice(sym);
#line 431
      sym->curr.val = (void *)tmp___14;
      }
    }
  }
  {
#line 432
  sym_validate_range(sym);
#line 434
  tmp___16 = memcmp((void const   *)(& oldval), (void const   *)(& sym->curr), sizeof(oldval));
  }
#line 434
  if (tmp___16) {
    {
#line 435
    sym_set_changed(sym);
    }
#line 436
    if ((unsigned long )modules_sym == (unsigned long )sym) {
      {
#line 437
      sym_set_all_changed();
#line 438
      modules_val = modules_sym->curr.tri;
      }
    }
  }
  {
#line 442
  tmp___17 = sym_is_choice(sym);
  }
#line 442
  if (tmp___17) {
    {
#line 445
    prop = sym_get_choice_prop(sym);
#line 446
    e = prop->expr;
    }
    {
#line 446
    while (1) {
      while_continue: /* CIL Label */ ;
#line 446
      if (e) {
#line 446
        choice_sym = e->right.sym;
#line 446
        if (! choice_sym) {
#line 446
          goto while_break;
        }
      } else {
#line 446
        goto while_break;
      }
#line 447
      if (sym->flags & 512) {
#line 447
        if ((unsigned int )choice_sym->visible != 0U) {
#line 449
          choice_sym->flags |= 512;
        }
      }
#line 450
      if (sym->flags & 1024) {
        {
#line 451
        sym_set_changed(choice_sym);
        }
      }
#line 446
      e = e->left.expr;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 455
  if (sym->flags & 4096) {
#line 456
    sym->flags &= -513;
  }
#line 458
  if (sym->flags & 1048576) {
    {
#line 459
    set_all_choice_values(sym);
    }
  }
#line 460
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
void sym_clear_all_valid(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 467
  i = 0;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (i < 9973)) {
#line 467
      goto while_break;
    }
#line 467
    sym = symbol_hash[i];
    {
#line 467
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 467
      if (! sym) {
#line 467
        goto while_break___0;
      }
#line 467
      if ((unsigned int )sym->type != 6U) {
#line 468
        sym->flags &= -129;
      }
#line 467
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 467
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  sym_add_change_count(1);
  }
#line 470
  if (modules_sym) {
    {
#line 471
    sym_calc_value(modules_sym);
    }
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) 
{ 
  int type ;
  enum symbol_type tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 476
  tmp = sym_get_type(sym);
#line 476
  type = (int )tmp;
  }
#line 478
  if ((unsigned int )sym->visible == 0U) {
#line 479
    return ((_Bool)0);
  }
#line 481
  if (type != 1) {
#line 481
    if (type != 2) {
#line 482
      return ((_Bool)0);
    }
  }
#line 484
  if (type == 1) {
#line 484
    if ((unsigned int )val == 1U) {
#line 485
      return ((_Bool)0);
    }
  }
#line 486
  if ((unsigned int )sym->visible <= (unsigned int )sym->rev_dep.tri) {
#line 487
    return ((_Bool)0);
  }
  {
#line 488
  tmp___0 = sym_is_choice_value(sym);
  }
#line 488
  if (tmp___0) {
#line 488
    if ((unsigned int )sym->visible == 2U) {
#line 489
      return ((_Bool )((unsigned int )val == 2U));
    }
  }
#line 490
  if ((unsigned int )val >= (unsigned int )sym->rev_dep.tri) {
#line 490
    if ((unsigned int )val <= (unsigned int )sym->visible) {
#line 490
      tmp___1 = 1;
    } else {
#line 490
      tmp___1 = 0;
    }
  } else {
#line 490
    tmp___1 = 0;
  }
#line 490
  return ((_Bool )tmp___1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) 
{ 
  tristate oldval ;
  tristate tmp ;
  _Bool tmp___0 ;
  struct symbol *cs ;
  struct property *tmp___1 ;
  struct symbol *tmp___2 ;
  struct property *prop ;
  struct expr *e ;
  _Bool tmp___3 ;

  {
  {
#line 495
  tmp = sym_get_tristate_value(sym);
#line 495
  oldval = tmp;
  }
#line 497
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 497
    tmp___0 = sym_tristate_within_range(sym, val);
    }
#line 497
    if (! tmp___0) {
#line 498
      return ((_Bool)0);
    }
  }
#line 500
  if (! (sym->flags & 65536)) {
    {
#line 501
    sym->flags |= 65536;
#line 502
    sym_set_changed(sym);
    }
  }
  {
#line 508
  tmp___3 = sym_is_choice_value(sym);
  }
#line 508
  if (tmp___3) {
#line 508
    if ((unsigned int )val == 2U) {
      {
#line 509
      tmp___1 = sym_get_choice_prop(sym);
#line 509
      tmp___2 = prop_get_symbol(tmp___1);
#line 509
      cs = tmp___2;
#line 513
      cs->def[0].val = (void *)sym;
#line 514
      cs->flags |= 65536;
#line 515
      prop = sym_get_choice_prop(cs);
#line 516
      e = prop->expr;
      }
      {
#line 516
      while (1) {
        while_continue: /* CIL Label */ ;
#line 516
        if (! e) {
#line 516
          goto while_break;
        }
#line 517
        if ((unsigned int )(e->right.sym)->visible != 0U) {
#line 518
          (e->right.sym)->flags |= 65536;
        }
#line 516
        e = e->left.expr;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 522
  sym->def[0].tri = val;
#line 523
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 524
    sym_clear_all_valid();
    }
  }
#line 526
  return ((_Bool)1);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
tristate sym_toggle_tristate_value(struct symbol *sym ) 
{ 
  tristate oldval ;
  tristate newval ;
  _Bool tmp ;

  {
  {
#line 533
  newval = sym_get_tristate_value(sym);
#line 533
  oldval = newval;
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 536
    if ((unsigned int )newval == 0U) {
#line 536
      goto case_0;
    }
#line 539
    if ((unsigned int )newval == 1U) {
#line 539
      goto case_1;
    }
#line 542
    if ((unsigned int )newval == 2U) {
#line 542
      goto case_2;
    }
#line 535
    goto switch_break;
    case_0: /* CIL Label */ 
#line 537
    newval = (tristate )1;
#line 538
    goto switch_break;
    case_1: /* CIL Label */ 
#line 540
    newval = (tristate )2;
#line 541
    goto switch_break;
    case_2: /* CIL Label */ 
#line 543
    newval = (tristate )0;
#line 544
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 546
    tmp = sym_set_tristate_value(sym, newval);
    }
#line 546
    if (tmp) {
#line 547
      goto while_break;
    }
#line 534
    if (! ((unsigned int )oldval != (unsigned int )newval)) {
#line 534
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  return (newval);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
_Bool sym_string_valid(struct symbol *sym , char const   *str ) 
{ 
  signed char ch ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 557
  if ((unsigned int )sym->type == 5U) {
#line 557
    goto case_5;
  }
#line 559
  if ((unsigned int )sym->type == 3U) {
#line 559
    goto case_3;
  }
#line 572
  if ((unsigned int )sym->type == 4U) {
#line 572
    goto case_4;
  }
#line 582
  if ((unsigned int )sym->type == 2U) {
#line 582
    goto case_2;
  }
#line 582
  if ((unsigned int )sym->type == 1U) {
#line 582
    goto case_2;
  }
#line 590
  goto switch_default;
  case_5: /* CIL Label */ 
#line 558
  return ((_Bool)1);
  case_3: /* CIL Label */ 
#line 560
  tmp = str;
#line 560
  str ++;
#line 560
  ch = (signed char )*tmp;
#line 561
  if ((int )ch == 45) {
#line 562
    tmp___0 = str;
#line 562
    str ++;
#line 562
    ch = (signed char )*tmp___0;
  }
  {
#line 563
  tmp___1 = __ctype_b_loc();
  }
#line 563
  if (! ((int const   )*(*tmp___1 + (int )ch) & 2048)) {
#line 564
    return ((_Bool)0);
  }
#line 565
  if ((int )ch == 48) {
#line 565
    if ((int const   )*str != 0) {
#line 566
      return ((_Bool)0);
    }
  }
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    tmp___3 = str;
#line 567
    str ++;
#line 567
    ch = (signed char )*tmp___3;
#line 567
    if (! ch) {
#line 567
      goto while_break;
    }
    {
#line 568
    tmp___2 = __ctype_b_loc();
    }
#line 568
    if (! ((int const   )*(*tmp___2 + (int )ch) & 2048)) {
#line 569
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return ((_Bool)1);
  case_4: /* CIL Label */ 
#line 573
  if ((int const   )*(str + 0) == 48) {
#line 573
    if ((int const   )*(str + 1) == 120) {
#line 574
      str += 2;
    } else
#line 573
    if ((int const   )*(str + 1) == 88) {
#line 574
      str += 2;
    }
  }
#line 575
  tmp___4 = str;
#line 575
  str ++;
#line 575
  ch = (signed char )*tmp___4;
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 577
    tmp___5 = __ctype_b_loc();
    }
#line 577
    if (! ((int const   )*(*tmp___5 + (int )ch) & 4096)) {
#line 578
      return ((_Bool)0);
    }
#line 576
    tmp___6 = str;
#line 576
    str ++;
#line 576
    ch = (signed char )*tmp___6;
#line 576
    if (! ch) {
#line 576
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 580
  return ((_Bool)1);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 586
  if ((int const   )*(str + 0) == 78) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 110) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 77) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 109) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 89) {
#line 586
    goto case_78;
  }
#line 586
  if ((int const   )*(str + 0) == 121) {
#line 586
    goto case_78;
  }
#line 583
  goto switch_break___0;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 587
  return ((_Bool)1);
  switch_break___0: /* CIL Label */ ;
  }
#line 589
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 591
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) 
{ 
  struct property *prop ;
  long long val ;
  _Bool tmp ;
  _Bool tmp___0 ;
  long long tmp___1 ;
  long long tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  long long tmp___5 ;
  long long tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  {
#line 601
  if ((unsigned int )sym->type == 5U) {
#line 601
    goto case_5;
  }
#line 603
  if ((unsigned int )sym->type == 3U) {
#line 603
    goto case_3;
  }
#line 612
  if ((unsigned int )sym->type == 4U) {
#line 612
    goto case_4;
  }
#line 622
  if ((unsigned int )sym->type == 2U) {
#line 622
    goto case_2;
  }
#line 622
  if ((unsigned int )sym->type == 1U) {
#line 622
    goto case_2;
  }
#line 632
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 602
  tmp = sym_string_valid(sym, str);
  }
#line 602
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 604
  tmp___0 = sym_string_valid(sym, str);
  }
#line 604
  if (! tmp___0) {
#line 605
    return ((_Bool)0);
  }
  {
#line 606
  prop = sym_get_range_prop(sym);
  }
#line 607
  if (! prop) {
#line 608
    return ((_Bool)1);
  }
  {
#line 609
  val = strtoll((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                10);
#line 610
  tmp___1 = sym_get_range_val((prop->expr)->left.sym, 10);
  }
#line 610
  if (val >= tmp___1) {
    {
#line 610
    tmp___2 = sym_get_range_val((prop->expr)->right.sym, 10);
    }
#line 610
    if (val <= tmp___2) {
#line 610
      tmp___3 = 1;
    } else {
#line 610
      tmp___3 = 0;
    }
  } else {
#line 610
    tmp___3 = 0;
  }
#line 610
  return ((_Bool )tmp___3);
  case_4: /* CIL Label */ 
  {
#line 613
  tmp___4 = sym_string_valid(sym, str);
  }
#line 613
  if (! tmp___4) {
#line 614
    return ((_Bool)0);
  }
  {
#line 615
  prop = sym_get_range_prop(sym);
  }
#line 616
  if (! prop) {
#line 617
    return ((_Bool)1);
  }
  {
#line 618
  val = strtoll((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                16);
#line 619
  tmp___5 = sym_get_range_val((prop->expr)->left.sym, 16);
  }
#line 619
  if (val >= tmp___5) {
    {
#line 619
    tmp___6 = sym_get_range_val((prop->expr)->right.sym, 16);
    }
#line 619
    if (val <= tmp___6) {
#line 619
      tmp___7 = 1;
    } else {
#line 619
      tmp___7 = 0;
    }
  } else {
#line 619
    tmp___7 = 0;
  }
#line 619
  return ((_Bool )tmp___7);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 624
  if ((int const   )*(str + 0) == 89) {
#line 624
    goto case_89;
  }
#line 624
  if ((int const   )*(str + 0) == 121) {
#line 624
    goto case_89;
  }
#line 626
  if ((int const   )*(str + 0) == 77) {
#line 626
    goto case_77;
  }
#line 626
  if ((int const   )*(str + 0) == 109) {
#line 626
    goto case_77;
  }
#line 628
  if ((int const   )*(str + 0) == 78) {
#line 628
    goto case_78;
  }
#line 628
  if ((int const   )*(str + 0) == 110) {
#line 628
    goto case_78;
  }
#line 623
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 625
  tmp___8 = sym_tristate_within_range(sym, (tristate )2);
  }
#line 625
  return (tmp___8);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 627
  tmp___9 = sym_tristate_within_range(sym, (tristate )1);
  }
#line 627
  return (tmp___9);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 629
  tmp___10 = sym_tristate_within_range(sym, (tristate )0);
  }
#line 629
  return (tmp___10);
  switch_break___0: /* CIL Label */ ;
  }
#line 631
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 633
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) 
{ 
  char const   *oldval ;
  char *val ;
  int size ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 645
  if ((unsigned int )sym->type == 2U) {
#line 645
    goto case_2;
  }
#line 645
  if ((unsigned int )sym->type == 1U) {
#line 645
    goto case_2;
  }
#line 655
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 647
  if ((int const   )*(newval + 0) == 89) {
#line 647
    goto case_89;
  }
#line 647
  if ((int const   )*(newval + 0) == 121) {
#line 647
    goto case_89;
  }
#line 649
  if ((int const   )*(newval + 0) == 77) {
#line 649
    goto case_77;
  }
#line 649
  if ((int const   )*(newval + 0) == 109) {
#line 649
    goto case_77;
  }
#line 651
  if ((int const   )*(newval + 0) == 78) {
#line 651
    goto case_78;
  }
#line 651
  if ((int const   )*(newval + 0) == 110) {
#line 651
    goto case_78;
  }
#line 646
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 648
  tmp = sym_set_tristate_value(sym, (tristate )2);
  }
#line 648
  return (tmp);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 650
  tmp___0 = sym_set_tristate_value(sym, (tristate )1);
  }
#line 650
  return (tmp___0);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 652
  tmp___1 = sym_set_tristate_value(sym, (tristate )0);
  }
#line 652
  return (tmp___1);
  switch_break___0: /* CIL Label */ ;
  }
#line 654
  return ((_Bool)0);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 659
  tmp___2 = sym_string_within_range(sym, newval);
  }
#line 659
  if (! tmp___2) {
#line 660
    return ((_Bool)0);
  }
#line 662
  if (! (sym->flags & 65536)) {
    {
#line 663
    sym->flags |= 65536;
#line 664
    sym_set_changed(sym);
    }
  }
  {
#line 667
  oldval = (char const   *)sym->def[0].val;
#line 668
  tmp___3 = strlen(newval);
#line 668
  size = (int )(tmp___3 + 1UL);
  }
#line 669
  if ((unsigned int )sym->type == 4U) {
#line 669
    if ((int const   )*(newval + 0) != 48) {
#line 669
      goto _L___0;
    } else
#line 669
    if ((int const   )*(newval + 1) != 120) {
#line 669
      if ((int const   )*(newval + 1) != 88) {
        _L___0: /* CIL Label */ 
        {
#line 670
        size += 2;
#line 671
        tmp___4 = xmalloc((size_t )size);
#line 671
        val = (char *)tmp___4;
#line 671
        sym->def[0].val = (void *)val;
#line 672
        tmp___5 = val;
#line 672
        val ++;
#line 672
        *tmp___5 = (char )'0';
#line 673
        tmp___6 = val;
#line 673
        val ++;
#line 673
        *tmp___6 = (char )'x';
        }
      } else {
#line 669
        goto _L;
      }
    } else {
#line 669
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 674
  if (! oldval) {
    {
#line 675
    tmp___7 = xmalloc((size_t )size);
#line 675
    val = (char *)tmp___7;
#line 675
    sym->def[0].val = (void *)val;
    }
  } else {
    {
#line 674
    tmp___8 = strcmp(oldval, newval);
    }
#line 674
    if (tmp___8) {
      {
#line 675
      tmp___7 = xmalloc((size_t )size);
#line 675
      val = (char *)tmp___7;
#line 675
      sym->def[0].val = (void *)val;
      }
    } else {
#line 677
      return ((_Bool)1);
    }
  }
  {
#line 679
  strcpy((char */* __restrict  */)val, (char const   */* __restrict  */)newval);
#line 680
  free((void *)oldval);
#line 681
  sym_clear_all_valid();
  }
#line 683
  return ((_Bool)1);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_default(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *ds ;
  char const   *str ;
  tristate val ;
  tristate tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 700
  sym_calc_visibility(sym);
#line 701
  sym_calc_value(modules_sym);
#line 702
  val = symbol_no.curr.tri;
#line 703
  str = (char const   *)symbol_empty.curr.val;
#line 706
  prop = sym_get_default_prop(sym);
  }
#line 707
  if ((unsigned long )prop != (unsigned long )((void *)0)) {
    {
#line 710
    if ((unsigned int )sym->type == 2U) {
#line 710
      goto case_2;
    }
#line 710
    if ((unsigned int )sym->type == 1U) {
#line 710
      goto case_2;
    }
#line 714
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 712
    tmp___1 = expr_calc_value(prop->expr);
    }
#line 712
    if ((unsigned int )tmp___1 < (unsigned int )prop->visible.tri) {
      {
#line 712
      tmp___0 = expr_calc_value(prop->expr);
#line 712
      val = tmp___0;
      }
    } else {
#line 712
      val = prop->visible.tri;
    }
#line 713
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 720
    ds = prop_get_symbol(prop);
    }
#line 721
    if ((unsigned long )ds != (unsigned long )((void *)0)) {
      {
#line 722
      sym_calc_value(ds);
#line 723
      str = (char const   *)ds->curr.val;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 729
  if ((unsigned int )val > (unsigned int )sym->rev_dep.tri) {
#line 729
    val = val;
  } else {
#line 729
    val = sym->rev_dep.tri;
  }
#line 732
  if ((unsigned int )val == 1U) {
    {
#line 733
    tmp___2 = sym_is_choice_value(sym);
    }
#line 733
    if (! tmp___2) {
#line 733
      if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 734
        val = (tristate )2;
      }
    }
  }
#line 737
  if ((unsigned int )sym->type == 1U) {
#line 737
    if ((unsigned int )val == 1U) {
#line 738
      val = (tristate )2;
    }
  }
  {
#line 742
  if ((unsigned int )sym->type == 2U) {
#line 742
    goto case_2___0;
  }
#line 742
  if ((unsigned int )sym->type == 1U) {
#line 742
    goto case_2___0;
  }
#line 749
  if ((unsigned int )sym->type == 4U) {
#line 749
    goto case_4;
  }
#line 749
  if ((unsigned int )sym->type == 3U) {
#line 749
    goto case_4;
  }
#line 751
  if ((unsigned int )sym->type == 5U) {
#line 751
    goto case_5;
  }
#line 754
  if ((unsigned int )sym->type == 0U) {
#line 754
    goto case_0___0;
  }
#line 754
  if ((unsigned int )sym->type == 6U) {
#line 754
    goto case_0___0;
  }
#line 740
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 744
  if ((unsigned int )val == 0U) {
#line 744
    goto case_0;
  }
#line 745
  if ((unsigned int )val == 1U) {
#line 745
    goto case_1___1;
  }
#line 746
  if ((unsigned int )val == 2U) {
#line 746
    goto case_2___1;
  }
#line 743
  goto switch_break___1;
  case_0: /* CIL Label */ 
#line 744
  return ("n");
  case_1___1: /* CIL Label */ 
#line 745
  return ("m");
  case_2___1: /* CIL Label */ 
#line 746
  return ("y");
  switch_break___1: /* CIL Label */ ;
  }
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 750
  return (str);
  case_5: /* CIL Label */ 
#line 752
  return (str);
  case_0___0: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 755
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 757
  return ("");
}
}
#line 760 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_value(struct symbol *sym ) 
{ 
  tristate val ;
  char const   *tmp ;

  {
  {
#line 766
  if ((unsigned int )sym->type == 2U) {
#line 766
    goto case_2;
  }
#line 766
  if ((unsigned int )sym->type == 1U) {
#line 766
    goto case_2;
  }
#line 778
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 767
  val = sym_get_tristate_value(sym);
  }
  {
#line 769
  if ((unsigned int )val == 0U) {
#line 769
    goto case_0;
  }
#line 771
  if ((unsigned int )val == 1U) {
#line 771
    goto case_1___0;
  }
#line 774
  if ((unsigned int )val == 2U) {
#line 774
    goto case_2___0;
  }
#line 768
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 770
  return ("n");
  case_1___0: /* CIL Label */ 
  {
#line 772
  sym_calc_value(modules_sym);
  }
#line 773
  if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 773
    tmp = "n";
  } else {
#line 773
    tmp = "m";
  }
#line 773
  return (tmp);
  case_2___0: /* CIL Label */ 
#line 775
  return ("y");
  switch_break___0: /* CIL Label */ ;
  }
#line 777
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 781
  return ((char const   *)sym->curr.val);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
_Bool sym_is_changable(struct symbol *sym ) 
{ 


  {
#line 786
  return ((_Bool )((unsigned int )sym->visible > (unsigned int )sym->rev_dep.tri));
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static unsigned int strhash___0(char const   *s ) 
{ 
  unsigned int hash ;

  {
#line 792
  hash = 2166136261U;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! *s) {
#line 793
      goto while_break;
    }
#line 794
    hash = (hash ^ (unsigned int )*s) * 16777619U;
#line 793
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  return (hash);
}
}
#line 798 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol *sym_lookup(char const   *name , int flags ) 
{ 
  struct symbol *symbol ;
  char *new_name ;
  int hash ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 804
  if (name) {
#line 805
    if (*(name + 0)) {
#line 805
      if (! *(name + 1)) {
        {
#line 807
        if ((int const   )*(name + 0) == 121) {
#line 807
          goto case_121;
        }
#line 808
        if ((int const   )*(name + 0) == 109) {
#line 808
          goto case_109;
        }
#line 809
        if ((int const   )*(name + 0) == 110) {
#line 809
          goto case_110;
        }
#line 806
        goto switch_break;
        case_121: /* CIL Label */ 
#line 807
        return (& symbol_yes);
        case_109: /* CIL Label */ 
#line 808
        return (& symbol_mod);
        case_110: /* CIL Label */ 
#line 809
        return (& symbol_no);
        switch_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 812
    tmp = strhash___0(name);
#line 812
    hash = (int )(tmp % 9973U);
#line 814
    symbol = symbol_hash[hash];
    }
    {
#line 814
    while (1) {
      while_continue: /* CIL Label */ ;
#line 814
      if (! symbol) {
#line 814
        goto while_break;
      }
#line 815
      if (symbol->name) {
        {
#line 815
        tmp___0 = strcmp((char const   *)symbol->name, name);
        }
#line 815
        if (! tmp___0) {
#line 815
          if (flags) {
#line 815
            tmp___1 = symbol->flags & flags;
          } else {
#line 815
            tmp___1 = ! (symbol->flags & 17);
          }
#line 815
          if (tmp___1) {
#line 819
            return (symbol);
          }
        }
      }
#line 814
      symbol = symbol->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 821
    new_name = strdup(name);
    }
  } else {
#line 823
    new_name = (char *)((void *)0);
#line 824
    hash = 0;
  }
  {
#line 827
  tmp___2 = xmalloc(sizeof(*symbol));
#line 827
  symbol = (struct symbol *)tmp___2;
#line 828
  memset((void *)symbol, 0, sizeof(*symbol));
#line 829
  symbol->name = new_name;
#line 830
  symbol->type = (enum symbol_type )0;
#line 831
  symbol->flags |= flags;
#line 833
  symbol->next = symbol_hash[hash];
#line 834
  symbol_hash[hash] = symbol;
  }
#line 836
  return (symbol);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol *sym_find(char const   *name ) 
{ 
  struct symbol *symbol ;
  int hash ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 841
  symbol = (struct symbol *)((void *)0);
#line 842
  hash = 0;
#line 844
  if (! name) {
#line 845
    return ((struct symbol *)((void *)0));
  }
#line 847
  if (*(name + 0)) {
#line 847
    if (! *(name + 1)) {
      {
#line 849
      if ((int const   )*(name + 0) == 121) {
#line 849
        goto case_121;
      }
#line 850
      if ((int const   )*(name + 0) == 109) {
#line 850
        goto case_109;
      }
#line 851
      if ((int const   )*(name + 0) == 110) {
#line 851
        goto case_110;
      }
#line 848
      goto switch_break;
      case_121: /* CIL Label */ 
#line 849
      return (& symbol_yes);
      case_109: /* CIL Label */ 
#line 850
      return (& symbol_mod);
      case_110: /* CIL Label */ 
#line 851
      return (& symbol_no);
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 854
  tmp = strhash___0(name);
#line 854
  hash = (int )(tmp % 9973U);
#line 856
  symbol = symbol_hash[hash];
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! symbol) {
#line 856
      goto while_break;
    }
#line 857
    if (symbol->name) {
      {
#line 857
      tmp___0 = strcmp((char const   *)symbol->name, name);
      }
#line 857
      if (! tmp___0) {
#line 857
        if (! (symbol->flags & 1)) {
#line 860
          goto while_break;
        }
      }
    }
#line 856
    symbol = symbol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return (symbol);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
char const   *sym_expand_string_value(char const   *in ) 
{ 
  char const   *src ;
  char *res ;
  size_t reslen ;
  size_t tmp ;
  void *tmp___0 ;
  char *p ;
  char name[256] ;
  char const   *symval ;
  struct symbol *sym ;
  size_t newlen ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 877
  tmp = strlen(in);
#line 877
  reslen = tmp + 1UL;
#line 878
  tmp___0 = xmalloc(reslen);
#line 878
  res = (char *)tmp___0;
#line 879
  *(res + 0) = (char )'\000';
  }
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 881
    tmp___8 = strchr(in, '$');
#line 881
    src = (char const   *)tmp___8;
    }
#line 881
    if (! src) {
#line 881
      goto while_break;
    }
    {
#line 883
    symval = "";
#line 887
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)in, (size_t )(src - in));
#line 888
    src ++;
#line 890
    p = name;
    }
    {
#line 891
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 891
      tmp___3 = __ctype_b_loc();
      }
#line 891
      if (! ((int const   )*(*tmp___3 + (int )*src) & 8)) {
#line 891
        if (! ((int const   )*src == 95)) {
#line 891
          goto while_break___0;
        }
      }
#line 892
      tmp___1 = p;
#line 892
      p ++;
#line 892
      tmp___2 = src;
#line 892
      src ++;
#line 892
      *tmp___1 = (char )*tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 893
    *p = (char )'\000';
#line 895
    sym = sym_find((char const   *)(name));
    }
#line 896
    if ((unsigned long )sym != (unsigned long )((void *)0)) {
      {
#line 897
      sym_calc_value(sym);
#line 898
      symval = sym_get_string_value(sym);
      }
    }
    {
#line 901
    tmp___4 = strlen((char const   *)res);
#line 901
    tmp___5 = strlen(symval);
#line 901
    tmp___6 = strlen(src);
#line 901
    newlen = ((tmp___4 + tmp___5) + tmp___6) + 1UL;
    }
#line 902
    if (newlen > reslen) {
      {
#line 903
      reslen = newlen;
#line 904
      tmp___7 = realloc((void *)res, reslen);
#line 904
      res = (char *)tmp___7;
      }
    }
    {
#line 907
    strcat((char */* __restrict  */)res, (char const   */* __restrict  */)symval);
#line 908
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 910
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)in);
  }
#line 912
  return ((char const   *)res);
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
char const   *sym_escape_string_value(char const   *in ) 
{ 
  char const   *p ;
  size_t reslen ;
  char *res ;
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 922
  tmp = strlen(in);
#line 922
  tmp___0 = strlen("\"\"");
#line 922
  reslen = (tmp + tmp___0) + 1UL;
#line 924
  p = in;
  }
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 926
    l = strcspn(p, "\"\\");
#line 927
    p += l;
    }
#line 929
    if ((int const   )*(p + 0) == 0) {
#line 930
      goto while_break;
    }
#line 932
    reslen ++;
#line 933
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 936
  tmp___1 = xmalloc(reslen);
#line 936
  res = (char *)tmp___1;
#line 937
  *(res + 0) = (char )'\000';
#line 939
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\"");
#line 941
  p = in;
  }
  {
#line 942
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 943
    l = strcspn(p, "\"\\");
#line 944
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)p, l);
#line 945
    p += l;
    }
#line 947
    if ((int const   )*(p + 0) == 0) {
#line 948
      goto while_break___0;
    }
    {
#line 950
    strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\\");
#line 951
    tmp___2 = p;
#line 951
    p ++;
#line 951
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)tmp___2,
            (size_t )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 954
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\"");
  }
#line 955
  return ((char const   *)res);
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static int sym_rel_comp(void const   *sym1 , void const   *sym2 ) 
{ 
  struct sym_match  const  *s1 ;
  struct sym_match  const  *s2 ;
  int exact1 ;
  int exact2 ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 969
  s1 = (struct sym_match  const  *)sym1;
#line 970
  s2 = (struct sym_match  const  *)sym2;
#line 982
  tmp = strlen((char const   *)(s1->sym)->name);
#line 982
  exact1 = (size_t )(s1->eo - s1->so) == tmp;
#line 983
  tmp___0 = strlen((char const   *)(s2->sym)->name);
#line 983
  exact2 = (size_t )(s2->eo - s2->so) == tmp___0;
  }
#line 984
  if (exact1) {
#line 984
    if (! exact2) {
#line 985
      return (-1);
    }
  }
#line 986
  if (! exact1) {
#line 986
    if (exact2) {
#line 987
      return (1);
    }
  }
  {
#line 990
  tmp___1 = strcmp((char const   *)(s1->sym)->name, (char const   *)(s2->sym)->name);
  }
#line 990
  return (tmp___1);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol **sym_re_search(char const   *pattern ) 
{ 
  struct symbol *sym ;
  struct symbol **sym_arr ;
  struct sym_match *sym_match_arr ;
  int i ;
  int cnt ;
  int size ;
  regex_t re ;
  regmatch_t match[1] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 995
  sym_arr = (struct symbol **)((void *)0);
#line 996
  sym_match_arr = (struct sym_match *)((void *)0);
#line 1001
  size = 0;
#line 1001
  cnt = size;
#line 1003
  tmp = strlen(pattern);
  }
#line 1003
  if (tmp == 0UL) {
#line 1004
    return ((struct symbol **)((void *)0));
  }
  {
#line 1005
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)pattern,
                    1 | (1 << 1));
  }
#line 1005
  if (tmp___0) {
#line 1006
    return ((struct symbol **)((void *)0));
  }
#line 1008
  i = 0;
  {
#line 1008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1008
    if (! (i < 9973)) {
#line 1008
      goto while_break;
    }
#line 1008
    sym = symbol_hash[i];
    {
#line 1008
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1008
      if (! sym) {
#line 1008
        goto while_break___0;
      }
#line 1008
      if ((unsigned int )sym->type != 6U) {
#line 1009
        if (sym->flags & 1) {
#line 1010
          goto __Cont;
        } else
#line 1009
        if (! sym->name) {
#line 1010
          goto __Cont;
        }
        {
#line 1011
        tmp___1 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)sym->name,
                          (size_t )1, (regmatch_t */* __restrict  */)(match), 0);
        }
#line 1011
        if (tmp___1) {
#line 1012
          goto __Cont;
        }
#line 1013
        if (cnt >= size) {
          {
#line 1015
          size += 16;
#line 1016
          tmp___2 = realloc((void *)sym_match_arr, (unsigned long )size * sizeof(struct sym_match ));
          }
#line 1017
          if (! tmp___2) {
#line 1018
            goto sym_re_search_free;
          }
#line 1019
          sym_match_arr = (struct sym_match *)tmp___2;
        }
        {
#line 1021
        sym_calc_value(sym);
#line 1025
        (sym_match_arr + cnt)->so = (off_t )match[0].rm_so;
#line 1026
        (sym_match_arr + cnt)->eo = (off_t )match[0].rm_eo;
#line 1027
        tmp___3 = cnt;
#line 1027
        cnt ++;
#line 1027
        (sym_match_arr + tmp___3)->sym = sym;
        }
      }
      __Cont: /* CIL Label */ 
#line 1008
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1008
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1029
  if (sym_match_arr) {
    {
#line 1030
    qsort((void *)sym_match_arr, (size_t )cnt, sizeof(struct sym_match ), & sym_rel_comp);
#line 1031
    tmp___4 = malloc((unsigned long )(cnt + 1) * sizeof(struct symbol ));
#line 1031
    sym_arr = (struct symbol **)tmp___4;
    }
#line 1032
    if (! sym_arr) {
#line 1033
      goto sym_re_search_free;
    }
#line 1034
    i = 0;
    {
#line 1034
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1034
      if (! (i < cnt)) {
#line 1034
        goto while_break___1;
      }
#line 1035
      *(sym_arr + i) = (sym_match_arr + i)->sym;
#line 1034
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1036
    *(sym_arr + cnt) = (struct symbol *)((void *)0);
  }
  sym_re_search_free: 
  {
#line 1040
  free((void *)sym_match_arr);
#line 1041
  regfree(& re);
  }
#line 1043
  return (sym_arr);
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct dep_stack *check_top  ;
#line 1059 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void dep_stack_insert(struct dep_stack *stack , struct symbol *sym ) 
{ 


  {
  {
#line 1061
  memset((void *)stack, 0, sizeof(*stack));
  }
#line 1062
  if (check_top) {
#line 1063
    check_top->next = stack;
  }
#line 1064
  stack->prev = check_top;
#line 1065
  stack->sym = sym;
#line 1066
  check_top = stack;
#line 1067
  return;
}
}
#line 1069 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void dep_stack_remove(void) 
{ 


  {
#line 1071
  check_top = check_top->prev;
#line 1072
  if (check_top) {
#line 1073
    check_top->next = (struct dep_stack *)((void *)0);
  }
#line 1074
  return;
}
}
#line 1081 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void sym_check_print_recursive(struct symbol *last_sym ) 
{ 
  struct dep_stack *stack ;
  struct symbol *sym ;
  struct symbol *next_sym ;
  struct menu *menu ;
  struct property *prop ;
  struct dep_stack cv_stack ;
  struct property *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  {
#line 1085
  menu = (struct menu *)((void *)0);
#line 1089
  tmp___0 = sym_is_choice_value(last_sym);
  }
#line 1089
  if (tmp___0) {
    {
#line 1090
    dep_stack_insert(& cv_stack, last_sym);
#line 1091
    tmp = sym_get_choice_prop(last_sym);
#line 1091
    last_sym = prop_get_symbol(tmp);
    }
  }
#line 1094
  stack = check_top;
  {
#line 1094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1094
    if (! ((unsigned long )stack != (unsigned long )((void *)0))) {
#line 1094
      goto while_break;
    }
#line 1095
    if ((unsigned long )stack->sym == (unsigned long )last_sym) {
#line 1096
      goto while_break;
    }
#line 1094
    stack = stack->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 1097
  if (! stack) {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected recursive dependency error\n");
    }
#line 1099
    return;
  }
  {
#line 1102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1102
    if (! stack) {
#line 1102
      goto while_break___0;
    }
#line 1103
    sym = stack->sym;
#line 1104
    if (stack->next) {
#line 1104
      next_sym = (stack->next)->sym;
    } else {
#line 1104
      next_sym = last_sym;
    }
#line 1105
    prop = stack->prop;
#line 1106
    if ((unsigned long )prop == (unsigned long )((void *)0)) {
#line 1107
      prop = (stack->sym)->prop;
    }
    {
#line 1110
    tmp___1 = sym_is_choice(sym);
    }
#line 1110
    if (tmp___1) {
#line 1110
      goto _L;
    } else {
      {
#line 1110
      tmp___2 = sym_is_choice_value(sym);
      }
#line 1110
      if (tmp___2) {
        _L: /* CIL Label */ 
#line 1111
        prop = sym->prop;
        {
#line 1111
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1111
          if (! prop) {
#line 1111
            goto while_break___1;
          }
#line 1112
          menu = prop->menu;
#line 1113
          if (prop->menu) {
#line 1114
            goto while_break___1;
          }
#line 1111
          prop = prop->next;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1117
    if ((unsigned long )stack->sym == (unsigned long )last_sym) {
      {
#line 1118
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:error: recursive dependency detected!\n",
              (prop->file)->name, prop->lineno);
      }
    }
#line 1120
    if (stack->expr) {
#line 1121
      if (next_sym->name) {
#line 1121
        tmp___3 = (char const   *)next_sym->name;
      } else {
#line 1121
        tmp___3 = "<choice>";
      }
      {
#line 1121
      tmp___4 = prop_get_type_name(prop->type);
      }
#line 1121
      if (sym->name) {
#line 1121
        tmp___5 = (char const   *)sym->name;
      } else {
#line 1121
        tmp___5 = "<choice>";
      }
      {
#line 1121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s %s value contains %s\n",
              (prop->file)->name, prop->lineno, tmp___5, tmp___4, tmp___3);
      }
    } else
#line 1126
    if (stack->prop) {
#line 1127
      if (next_sym->name) {
#line 1127
        tmp___6 = (char const   *)next_sym->name;
      } else {
#line 1127
        tmp___6 = "<choice>";
      }
#line 1127
      if (sym->name) {
#line 1127
        tmp___7 = (char const   *)sym->name;
      } else {
#line 1127
        tmp___7 = "<choice>";
      }
      {
#line 1127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s depends on %s\n",
              (prop->file)->name, prop->lineno, tmp___7, tmp___6);
      }
    } else {
      {
#line 1131
      tmp___15 = sym_is_choice(sym);
      }
#line 1131
      if (tmp___15) {
#line 1132
        if (next_sym->name) {
#line 1132
          tmp___8 = (char const   *)next_sym->name;
        } else {
#line 1132
          tmp___8 = "<choice>";
        }
#line 1132
        if (sym->name) {
#line 1132
          tmp___9 = (char const   *)sym->name;
        } else {
#line 1132
          tmp___9 = "<choice>";
        }
        {
#line 1132
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tchoice %s contains symbol %s\n",
                (menu->file)->name, menu->lineno, tmp___9, tmp___8);
        }
      } else {
        {
#line 1136
        tmp___14 = sym_is_choice_value(sym);
        }
#line 1136
        if (tmp___14) {
#line 1137
          if (next_sym->name) {
#line 1137
            tmp___10 = (char const   *)next_sym->name;
          } else {
#line 1137
            tmp___10 = "<choice>";
          }
#line 1137
          if (sym->name) {
#line 1137
            tmp___11 = (char const   *)sym->name;
          } else {
#line 1137
            tmp___11 = "<choice>";
          }
          {
#line 1137
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s is part of choice %s\n",
                  (menu->file)->name, menu->lineno, tmp___11, tmp___10);
          }
        } else {
#line 1142
          if (next_sym->name) {
#line 1142
            tmp___12 = (char const   *)next_sym->name;
          } else {
#line 1142
            tmp___12 = "<choice>";
          }
#line 1142
          if (sym->name) {
#line 1142
            tmp___13 = (char const   *)sym->name;
          } else {
#line 1142
            tmp___13 = "<choice>";
          }
          {
#line 1142
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s is selected by %s\n",
                  (prop->file)->name, prop->lineno, tmp___13, tmp___12);
          }
        }
      }
    }
#line 1102
    stack = stack->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1149
  if ((unsigned long )check_top == (unsigned long )(& cv_stack)) {
    {
#line 1150
    dep_stack_remove();
    }
  }
#line 1151
  return;
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_expr_deps(struct expr *e ) 
{ 
  struct symbol *sym ;
  struct symbol *tmp ;
  struct symbol *tmp___0 ;
  struct symbol *tmp___1 ;
  struct symbol *tmp___2 ;

  {
#line 1157
  if (! e) {
#line 1158
    return ((struct symbol *)((void *)0));
  }
  {
#line 1161
  if ((unsigned int )e->type == 2U) {
#line 1161
    goto case_2;
  }
#line 1161
  if ((unsigned int )e->type == 1U) {
#line 1161
    goto case_2;
  }
#line 1166
  if ((unsigned int )e->type == 3U) {
#line 1166
    goto case_3;
  }
#line 1173
  if ((unsigned int )e->type == 5U) {
#line 1173
    goto case_5;
  }
#line 1173
  if ((unsigned int )e->type == 6U) {
#line 1173
    goto case_5;
  }
#line 1173
  if ((unsigned int )e->type == 7U) {
#line 1173
    goto case_5;
  }
#line 1173
  if ((unsigned int )e->type == 8U) {
#line 1173
    goto case_5;
  }
#line 1173
  if ((unsigned int )e->type == 9U) {
#line 1173
    goto case_5;
  }
#line 1173
  if ((unsigned int )e->type == 4U) {
#line 1173
    goto case_5;
  }
#line 1178
  if ((unsigned int )e->type == 11U) {
#line 1178
    goto case_11;
  }
#line 1180
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1162
  sym = sym_check_expr_deps(e->left.expr);
  }
#line 1163
  if (sym) {
#line 1164
    return (sym);
  }
  {
#line 1165
  tmp = sym_check_expr_deps(e->right.expr);
  }
#line 1165
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 1167
  tmp___0 = sym_check_expr_deps(e->left.expr);
  }
#line 1167
  return (tmp___0);
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1174
  sym = sym_check_deps(e->left.sym);
  }
#line 1175
  if (sym) {
#line 1176
    return (sym);
  }
  {
#line 1177
  tmp___1 = sym_check_deps(e->right.sym);
  }
#line 1177
  return (tmp___1);
  case_11: /* CIL Label */ 
  {
#line 1179
  tmp___2 = sym_check_deps(e->left.sym);
  }
#line 1179
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 1181
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1183
  printf((char const   */* __restrict  */)"Oops! How to check %d?\n", (unsigned int )e->type);
  }
#line 1184
  return ((struct symbol *)((void *)0));
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_sym_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  struct dep_stack stack ;
  _Bool tmp ;

  {
  {
#line 1194
  dep_stack_insert(& stack, sym);
#line 1196
  sym2 = sym_check_expr_deps(sym->rev_dep.expr);
  }
#line 1197
  if (sym2) {
#line 1198
    goto out;
  }
#line 1200
  prop = sym->prop;
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if (! prop) {
#line 1200
      goto while_break;
    }
#line 1201
    if ((unsigned int )prop->type == 5U) {
#line 1202
      goto __Cont;
    } else
#line 1201
    if ((unsigned int )prop->type == 6U) {
#line 1202
      goto __Cont;
    }
    {
#line 1203
    stack.prop = prop;
#line 1204
    sym2 = sym_check_expr_deps(prop->visible.expr);
    }
#line 1205
    if (sym2) {
#line 1206
      goto while_break;
    }
#line 1207
    if ((unsigned int )prop->type != 4U) {
#line 1208
      goto __Cont;
    } else {
      {
#line 1207
      tmp = sym_is_choice(sym);
      }
#line 1207
      if (tmp) {
#line 1208
        goto __Cont;
      }
    }
    {
#line 1209
    stack.expr = prop->expr;
#line 1210
    sym2 = sym_check_expr_deps(prop->expr);
    }
#line 1211
    if (sym2) {
#line 1212
      goto while_break;
    }
#line 1213
    stack.expr = (struct expr *)((void *)0);
    __Cont: /* CIL Label */ 
#line 1200
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 1217
  dep_stack_remove();
  }
#line 1219
  return (sym2);
}
}
#line 1222 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_choice_deps(struct symbol *choice ) 
{ 
  struct symbol *sym ;
  struct symbol *sym2 ;
  struct property *prop ;
  struct expr *e ;
  struct dep_stack stack ;
  _Bool tmp ;
  struct property *tmp___0 ;
  struct symbol *tmp___1 ;

  {
  {
#line 1229
  dep_stack_insert(& stack, choice);
#line 1231
  prop = sym_get_choice_prop(choice);
#line 1232
  e = prop->expr;
  }
  {
#line 1232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1232
    if (e) {
#line 1232
      sym = e->right.sym;
#line 1232
      if (! sym) {
#line 1232
        goto while_break;
      }
    } else {
#line 1232
      goto while_break;
    }
#line 1233
    sym->flags |= 8200;
#line 1232
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1235
  choice->flags |= 8200;
#line 1236
  sym2 = sym_check_sym_deps(choice);
#line 1237
  choice->flags &= -9;
  }
#line 1238
  if (sym2) {
#line 1239
    goto out;
  }
#line 1241
  e = prop->expr;
  {
#line 1241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1241
    if (e) {
#line 1241
      sym = e->right.sym;
#line 1241
      if (! sym) {
#line 1241
        goto while_break___0;
      }
    } else {
#line 1241
      goto while_break___0;
    }
    {
#line 1242
    sym2 = sym_check_sym_deps(sym);
    }
#line 1243
    if (sym2) {
#line 1244
      goto while_break___0;
    }
#line 1241
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 1247
  e = prop->expr;
  {
#line 1247
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1247
    if (e) {
#line 1247
      sym = e->right.sym;
#line 1247
      if (! sym) {
#line 1247
        goto while_break___1;
      }
    } else {
#line 1247
      goto while_break___1;
    }
#line 1248
    sym->flags &= -9;
#line 1247
    e = e->left.expr;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1250
  if (sym2) {
    {
#line 1250
    tmp = sym_is_choice_value(sym2);
    }
#line 1250
    if (tmp) {
      {
#line 1250
      tmp___0 = sym_get_choice_prop(sym2);
#line 1250
      tmp___1 = prop_get_symbol(tmp___0);
      }
#line 1250
      if ((unsigned long )tmp___1 == (unsigned long )choice) {
#line 1252
        sym2 = choice;
      }
    }
  }
  {
#line 1254
  dep_stack_remove();
  }
#line 1256
  return (sym2);
}
}
#line 1259 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol *sym_check_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  struct dep_stack stack ;
  struct symbol *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1264
  if (sym->flags & 8) {
    {
#line 1265
    sym_check_print_recursive(sym);
    }
#line 1266
    return (sym);
  }
#line 1268
  if (sym->flags & 8192) {
#line 1269
    return ((struct symbol *)((void *)0));
  }
  {
#line 1271
  tmp___1 = sym_is_choice_value(sym);
  }
#line 1271
  if (tmp___1) {
    {
#line 1275
    dep_stack_insert(& stack, sym);
#line 1276
    prop = sym_get_choice_prop(sym);
#line 1277
    tmp = prop_get_symbol(prop);
#line 1277
    sym2 = sym_check_deps(tmp);
#line 1278
    dep_stack_remove();
    }
  } else {
    {
#line 1279
    tmp___0 = sym_is_choice(sym);
    }
#line 1279
    if (tmp___0) {
      {
#line 1280
      sym2 = sym_check_choice_deps(sym);
      }
    } else {
      {
#line 1282
      sym->flags |= 8200;
#line 1283
      sym2 = sym_check_sym_deps(sym);
#line 1284
      sym->flags &= -9;
      }
    }
  }
#line 1287
  if (sym2) {
#line 1287
    if ((unsigned long )sym2 == (unsigned long )sym) {
#line 1288
      sym2 = (struct symbol *)((void *)0);
    }
  }
#line 1290
  return (sym2);
}
}
#line 1293 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) 
{ 
  struct property *prop ;
  struct property **propp ;
  void *tmp ;

  {
  {
#line 1298
  tmp = xmalloc(sizeof(*prop));
#line 1298
  prop = (struct property *)tmp;
#line 1299
  memset((void *)prop, 0, sizeof(*prop));
#line 1300
  prop->type = type;
#line 1301
  prop->sym = sym;
#line 1302
  prop->file = current_file;
#line 1303
  prop->lineno = zconf_lineno();
  }
#line 1306
  if (sym) {
#line 1307
    propp = & sym->prop;
    {
#line 1307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1307
      if (! *propp) {
#line 1307
        goto while_break;
      }
#line 1307
      propp = & (*propp)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1309
    *propp = prop;
  }
#line 1312
  return (prop);
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
struct symbol *prop_get_symbol(struct property *prop ) 
{ 


  {
#line 1317
  if (prop->expr) {
#line 1317
    if ((unsigned int )(prop->expr)->type == 11U) {
#line 1319
      return ((prop->expr)->left.sym);
    } else
#line 1317
    if ((unsigned int )(prop->expr)->type == 10U) {
#line 1319
      return ((prop->expr)->left.sym);
    }
  }
#line 1320
  return ((struct symbol *)((void *)0));
}
}
#line 1323 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
char const   *prop_get_type_name(enum prop_type type ) 
{ 


  {
  {
#line 1326
  if ((unsigned int )type == 1U) {
#line 1326
    goto case_1;
  }
#line 1328
  if ((unsigned int )type == 8U) {
#line 1328
    goto case_8;
  }
#line 1330
  if ((unsigned int )type == 2U) {
#line 1330
    goto case_2;
  }
#line 1332
  if ((unsigned int )type == 3U) {
#line 1332
    goto case_3;
  }
#line 1334
  if ((unsigned int )type == 4U) {
#line 1334
    goto case_4;
  }
#line 1336
  if ((unsigned int )type == 5U) {
#line 1336
    goto case_5;
  }
#line 1338
  if ((unsigned int )type == 6U) {
#line 1338
    goto case_6;
  }
#line 1340
  if ((unsigned int )type == 7U) {
#line 1340
    goto case_7;
  }
#line 1342
  if ((unsigned int )type == 9U) {
#line 1342
    goto case_9;
  }
#line 1344
  if ((unsigned int )type == 0U) {
#line 1344
    goto case_0;
  }
#line 1325
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1327
  return ("prompt");
  case_8: /* CIL Label */ 
#line 1329
  return ("env");
  case_2: /* CIL Label */ 
#line 1331
  return ("comment");
  case_3: /* CIL Label */ 
#line 1333
  return ("menu");
  case_4: /* CIL Label */ 
#line 1335
  return ("default");
  case_5: /* CIL Label */ 
#line 1337
  return ("choice");
  case_6: /* CIL Label */ 
#line 1339
  return ("select");
  case_7: /* CIL Label */ 
#line 1341
  return ("range");
  case_9: /* CIL Label */ 
#line 1343
  return ("symbol");
  case_0: /* CIL Label */ 
#line 1345
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1347
  return ("unknown");
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/symbol.c"
static void prop_add_env(char const   *env ) 
{ 
  struct symbol *sym ;
  struct symbol *sym2 ;
  struct property *prop ;
  char *p ;
  int tmp ;
  struct symbol *tmp___0 ;

  {
#line 1356
  sym = current_entry->sym;
#line 1357
  sym->flags |= 4096;
#line 1358
  prop = sym->prop;
  {
#line 1358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1358
    if (! prop) {
#line 1358
      goto while_break;
    }
#line 1358
    if ((unsigned int )prop->type == 8U) {
      {
#line 1359
      sym2 = prop_get_symbol(prop);
#line 1360
      tmp = strcmp((char const   *)sym2->name, env);
      }
#line 1360
      if (tmp) {
        {
#line 1361
        menu_warn(current_entry, "redefining environment symbol from %s", sym2->name);
        }
      }
#line 1363
      return;
    }
#line 1358
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1366
  prop = prop_alloc((enum prop_type )8, sym);
#line 1367
  tmp___0 = sym_lookup(env, 1);
#line 1367
  prop->expr = expr_alloc_symbol(tmp___0);
#line 1369
  sym_env_list = expr_alloc_one((enum expr_type )10, sym_env_list);
#line 1370
  sym_env_list->right.sym = sym;
#line 1372
  p = getenv(env);
  }
#line 1373
  if (p) {
    {
#line 1374
    sym_add_default(sym, (char const   *)p);
    }
  } else {
    {
#line 1376
    menu_warn(current_entry, "environment variable %s undefined", env);
    }
  }
#line 1377
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static char const   nohelp_text[44]  = 
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
  {      (char const   )'T',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'n',      (char const   )'o',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'a',      (char const   )'v',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'.',      (char const   )'\000'};
#line 16 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static struct menu **last_entry_ptr  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_warn(struct menu *menu , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 24
  __builtin_va_start(ap, fmt);
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (menu->file)->name, menu->lineno);
#line 26
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 28
  __builtin_va_end(ap);
  }
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static void prop_warn(struct property *prop , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 34
  __builtin_va_start(ap, fmt);
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (prop->file)->name, prop->lineno);
#line 36
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 38
  __builtin_va_end(ap);
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void _menu_init(void) 
{ 


  {
#line 43
  current_menu = & rootmenu;
#line 43
  current_entry = current_menu;
#line 44
  last_entry_ptr = & rootmenu.list;
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_add_entry(struct symbol *sym ) 
{ 
  struct menu *menu ;
  void *tmp ;

  {
  {
#line 51
  tmp = xmalloc(sizeof(*menu));
#line 51
  menu = (struct menu *)tmp;
#line 52
  memset((void *)menu, 0, sizeof(*menu));
#line 53
  menu->sym = sym;
#line 54
  menu->parent = current_menu;
#line 55
  menu->file = current_file;
#line 56
  menu->lineno = zconf_lineno();
#line 58
  *last_entry_ptr = menu;
#line 59
  last_entry_ptr = & menu->next;
#line 60
  current_entry = menu;
  }
#line 61
  if (sym) {
    {
#line 62
    menu_add_symbol((enum prop_type )9, sym, (struct expr *)((void *)0));
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_end_entry(void) 
{ 


  {
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
struct menu *menu_add_menu(void) 
{ 


  {
  {
#line 71
  menu_end_entry();
#line 72
  last_entry_ptr = & current_entry->list;
#line 73
  current_menu = current_entry;
  }
#line 73
  return (current_menu);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_end_menu(void) 
{ 


  {
#line 78
  last_entry_ptr = & current_menu->next;
#line 79
  current_menu = current_menu->parent;
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static struct expr *menu_check_dep(struct expr *e ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 84
  if (! e) {
#line 85
    return (e);
  }
  {
#line 88
  if ((unsigned int )e->type == 3U) {
#line 88
    goto case_3;
  }
#line 92
  if ((unsigned int )e->type == 2U) {
#line 92
    goto case_2;
  }
#line 92
  if ((unsigned int )e->type == 1U) {
#line 92
    goto case_2;
  }
#line 96
  if ((unsigned int )e->type == 11U) {
#line 96
    goto case_11;
  }
#line 101
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 89
  e->left.expr = menu_check_dep(e->left.expr);
  }
#line 90
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 93
  e->left.expr = menu_check_dep(e->left.expr);
#line 94
  e->right.expr = menu_check_dep(e->right.expr);
  }
#line 95
  goto switch_break;
  case_11: /* CIL Label */ 
#line 98
  if ((unsigned long )e->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 99
    tmp = expr_alloc_symbol(modules_sym);
#line 99
    tmp___0 = expr_alloc_and(e, tmp);
    }
#line 99
    return (tmp___0);
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 104
  return (e);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_add_dep(struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 109
  tmp = menu_check_dep(dep);
#line 109
  current_entry->dep = expr_alloc_and(current_entry->dep, tmp);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_set_type(int type ) 
{ 
  struct symbol *sym ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 114
  sym = current_entry->sym;
#line 116
  if ((unsigned int )sym->type == (unsigned int )type) {
#line 117
    return;
  }
#line 118
  if ((unsigned int )sym->type == 0U) {
#line 119
    sym->type = (enum symbol_type )type;
#line 120
    return;
  }
  {
#line 122
  tmp = sym_type_name((enum symbol_type )type);
#line 122
  tmp___0 = sym_type_name(sym->type);
  }
#line 122
  if (sym->name) {
#line 122
    tmp___1 = (char const   *)sym->name;
  } else {
#line 122
    tmp___1 = "<choice>";
  }
  {
#line 122
  menu_warn(current_entry, "ignoring type redefinition of \'%s\' from \'%s\' to \'%s\'",
            tmp___1, tmp___0, tmp);
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                                      struct expr *dep ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct menu *menu ;
  struct expr *dup_expr ;

  {
  {
#line 130
  tmp = prop_alloc(type, current_entry->sym);
#line 130
  prop = tmp;
#line 132
  prop->menu = current_entry;
#line 133
  prop->expr = expr;
#line 134
  prop->visible.expr = menu_check_dep(dep);
  }
#line 136
  if (prompt) {
    {
#line 137
    tmp___1 = __ctype_b_loc();
    }
#line 137
    if ((int const   )*(*tmp___1 + (int )*prompt) & 8192) {
      {
#line 138
      prop_warn(prop, "leading whitespace ignored");
      }
      {
#line 139
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 139
        tmp___0 = __ctype_b_loc();
        }
#line 139
        if (! ((int const   )*(*tmp___0 + (int )*prompt) & 8192)) {
#line 139
          goto while_break;
        }
#line 140
        prompt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 142
    if (current_entry->prompt) {
#line 142
      if ((unsigned long )current_entry != (unsigned long )(& rootmenu)) {
        {
#line 143
        prop_warn(prop, "prompt redefined");
        }
      }
    }
#line 146
    if ((unsigned int )type == 1U) {
#line 147
      menu = current_entry;
      {
#line 149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 149
        menu = menu->parent;
#line 149
        if (! ((unsigned long )menu != (unsigned long )((void *)0))) {
#line 149
          goto while_break___0;
        }
#line 152
        if (! menu->visibility) {
#line 153
          goto while_continue___0;
        }
        {
#line 163
        dup_expr = expr_copy((struct expr  const  *)menu->visibility);
#line 165
        prop->visible.expr = expr_alloc_and(prop->visible.expr, dup_expr);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 171
    current_entry->prompt = prop;
  }
#line 173
  prop->text = (char const   *)prompt;
#line 175
  return (prop);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) 
{ 
  struct property *tmp ;

  {
  {
#line 180
  tmp = menu_add_prop(type, prompt, (struct expr *)((void *)0), dep);
  }
#line 180
  return (tmp);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_add_visibility(struct expr *expr ) 
{ 


  {
  {
#line 185
  current_entry->visibility = expr_alloc_and(current_entry->visibility, expr);
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) 
{ 


  {
  {
#line 191
  menu_add_prop(type, (char *)((void *)0), expr, dep);
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 196
  tmp = expr_alloc_symbol(sym);
#line 196
  menu_add_prop(type, (char *)((void *)0), tmp, dep);
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_add_option(int token , char *arg ) 
{ 


  {
  {
#line 202
  if (token == 1) {
#line 202
    goto case_1;
  }
#line 211
  if (token == 2) {
#line 211
    goto case_2;
  }
#line 217
  if (token == 3) {
#line 217
    goto case_3;
  }
#line 220
  if (token == 4) {
#line 220
    goto case_4;
  }
#line 201
  goto switch_break;
  case_1: /* CIL Label */ 
#line 203
  if (modules_sym) {
    {
#line 204
    zconf_error("symbol \'%s\' redefines option \'modules\' already defined by symbol \'%s\'",
                (current_entry->sym)->name, modules_sym->name);
    }
  }
#line 209
  modules_sym = current_entry->sym;
#line 210
  goto switch_break;
  case_2: /* CIL Label */ 
#line 212
  if (! sym_defconfig_list) {
#line 213
    sym_defconfig_list = current_entry->sym;
  } else
#line 214
  if ((unsigned long )sym_defconfig_list != (unsigned long )current_entry->sym) {
    {
#line 215
    zconf_error("trying to redefine defconfig symbol");
    }
  }
#line 216
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 218
  prop_add_env((char const   *)arg);
  }
#line 219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 221
  (current_entry->sym)->flags |= 2097152;
#line 222
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static int menu_validate_number(struct symbol *sym , struct symbol *sym2 ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 228
  if ((unsigned int )sym2->type == 3U) {
#line 228
    tmp___0 = 1;
  } else
#line 228
  if ((unsigned int )sym2->type == 4U) {
#line 228
    tmp___0 = 1;
  } else
#line 228
  if ((unsigned int )sym2->type == 0U) {
    {
#line 228
    tmp = sym_string_valid(sym, (char const   *)sym2->name);
    }
#line 228
    if (tmp) {
#line 228
      tmp___0 = 1;
    } else {
#line 228
      tmp___0 = 0;
    }
  } else {
#line 228
    tmp___0 = 0;
  }
#line 228
  return (tmp___0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static void sym_check_prop(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *sym2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 236
  prop = sym->prop;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! prop) {
#line 236
      goto while_break;
    }
    {
#line 238
    if ((unsigned int )prop->type == 4U) {
#line 238
      goto case_4;
    }
#line 254
    if ((unsigned int )prop->type == 6U) {
#line 254
      goto case_6;
    }
#line 268
    if ((unsigned int )prop->type == 7U) {
#line 268
      goto case_7;
    }
#line 276
    goto switch_default;
    case_4: /* CIL Label */ 
#line 239
    if ((unsigned int )sym->type == 5U) {
#line 239
      goto _L;
    } else
#line 239
    if ((unsigned int )sym->type == 3U) {
#line 239
      goto _L;
    } else
#line 239
    if ((unsigned int )sym->type == 4U) {
      _L: /* CIL Label */ 
#line 239
      if ((unsigned int )(prop->expr)->type != 11U) {
        {
#line 241
        prop_warn(prop, "default for config symbol \'%s\' must be a single symbol",
                  sym->name);
        }
      }
    }
#line 244
    if ((unsigned int )(prop->expr)->type != 11U) {
#line 245
      goto switch_break;
    }
    {
#line 246
    sym2 = prop_get_symbol(prop);
    }
#line 247
    if ((unsigned int )sym->type == 4U) {
#line 247
      goto _L___0;
    } else
#line 247
    if ((unsigned int )sym->type == 3U) {
      _L___0: /* CIL Label */ 
      {
#line 248
      tmp = menu_validate_number(sym, sym2);
      }
#line 248
      if (! tmp) {
        {
#line 249
        prop_warn(prop, "\'%s\': number is invalid", sym->name);
        }
      }
    }
#line 253
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 255
    sym2 = prop_get_symbol(prop);
    }
#line 256
    if ((unsigned int )sym->type != 1U) {
#line 256
      if ((unsigned int )sym->type != 2U) {
        {
#line 257
        prop_warn(prop, "config symbol \'%s\' uses select, but is not boolean or tristate",
                  sym->name);
        }
      } else {
#line 256
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 260
    if ((unsigned int )sym2->type != 0U) {
#line 260
      if ((unsigned int )sym2->type != 1U) {
#line 260
        if ((unsigned int )sym2->type != 2U) {
          {
#line 263
          prop_warn(prop, "\'%s\' has wrong type. \'select\' only accept arguments of boolean and tristate type",
                    sym2->name);
          }
        }
      }
    }
#line 267
    goto switch_break;
    case_7: /* CIL Label */ 
#line 269
    if ((unsigned int )sym->type != 3U) {
#line 269
      if ((unsigned int )sym->type != 4U) {
        {
#line 270
        prop_warn(prop, "range is only allowed for int or hex symbols");
        }
      }
    }
    {
#line 272
    tmp___0 = menu_validate_number(sym, (prop->expr)->left.sym);
    }
#line 272
    if (tmp___0) {
      {
#line 272
      tmp___1 = menu_validate_number(sym, (prop->expr)->right.sym);
      }
#line 272
      if (! tmp___1) {
        {
#line 274
        prop_warn(prop, "range is invalid");
        }
      }
    } else {
      {
#line 274
      prop_warn(prop, "range is invalid");
      }
    }
#line 275
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 236
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_finalize(struct menu *parent ) 
{ 
  struct menu *menu ;
  struct menu *last_menu ;
  struct symbol *sym ;
  struct property *prop ;
  struct expr *parentdep ;
  struct expr *basedep ;
  struct expr *dep ;
  struct expr *dep2 ;
  struct expr **ep ;
  _Bool tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct symbol *es ;
  struct symbol *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  struct expr *tmp___9 ;
  int tmp___10 ;
  struct expr *tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  struct expr *tmp___15 ;
  struct expr *tmp___16 ;
  _Bool tmp___17 ;

  {
#line 289
  sym = parent->sym;
#line 290
  if (parent->list) {
#line 291
    if (sym) {
      {
#line 291
      tmp = sym_is_choice(sym);
      }
#line 291
      if (tmp) {
#line 292
        if ((unsigned int )sym->type == 0U) {
#line 294
          current_entry = parent;
#line 295
          menu = parent->list;
          {
#line 295
          while (1) {
            while_continue: /* CIL Label */ ;
#line 295
            if (! menu) {
#line 295
              goto while_break;
            }
#line 296
            if (menu->sym) {
#line 296
              if ((unsigned int )(menu->sym)->type != 0U) {
                {
#line 297
                menu_set_type((int )(menu->sym)->type);
                }
#line 298
                goto while_break;
              }
            }
#line 295
            menu = menu->next;
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 303
        menu = parent->list;
        {
#line 303
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 303
          if (! menu) {
#line 303
            goto while_break___0;
          }
#line 304
          current_entry = menu;
#line 305
          if (menu->sym) {
#line 305
            if ((unsigned int )(menu->sym)->type == 0U) {
              {
#line 306
              menu_set_type((int )sym->type);
              }
            }
          }
#line 303
          menu = menu->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 308
        parentdep = expr_alloc_symbol(sym);
        }
      } else {
#line 291
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 309
    if (parent->prompt) {
#line 310
      parentdep = (parent->prompt)->visible.expr;
    } else {
#line 312
      parentdep = parent->dep;
    }
#line 314
    menu = parent->list;
    {
#line 314
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 314
      if (! menu) {
#line 314
        goto while_break___1;
      }
      {
#line 315
      basedep = expr_transform(menu->dep);
#line 316
      tmp___0 = expr_copy((struct expr  const  *)parentdep);
#line 316
      basedep = expr_alloc_and(tmp___0, basedep);
#line 317
      basedep = expr_eliminate_dups(basedep);
#line 318
      menu->dep = basedep;
      }
#line 319
      if (menu->sym) {
#line 320
        prop = (menu->sym)->prop;
      } else {
#line 322
        prop = menu->prompt;
      }
      {
#line 323
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 323
        if (! prop) {
#line 323
          goto while_break___2;
        }
#line 324
        if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 325
          goto __Cont;
        }
        {
#line 326
        dep = expr_transform(prop->visible.expr);
#line 327
        tmp___1 = expr_copy((struct expr  const  *)basedep);
#line 327
        dep = expr_alloc_and(tmp___1, dep);
#line 328
        dep = expr_eliminate_dups(dep);
        }
#line 329
        if (menu->sym) {
#line 329
          if ((unsigned int )(menu->sym)->type != 2U) {
            {
#line 330
            dep = expr_trans_bool(dep);
            }
          }
        }
#line 331
        prop->visible.expr = dep;
#line 332
        if ((unsigned int )prop->type == 6U) {
          {
#line 333
          tmp___2 = prop_get_symbol(prop);
#line 333
          es = tmp___2;
#line 334
          tmp___3 = expr_copy((struct expr  const  *)dep);
#line 334
          tmp___4 = expr_alloc_symbol(menu->sym);
#line 334
          tmp___5 = expr_alloc_and(tmp___4, tmp___3);
#line 334
          es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr, tmp___5);
          }
        }
        __Cont: /* CIL Label */ 
#line 323
        prop = prop->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 314
      menu = menu->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 339
    menu = parent->list;
    {
#line 339
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 339
      if (! menu) {
#line 339
        goto while_break___3;
      }
      {
#line 340
      menu_finalize(menu);
#line 339
      menu = menu->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 341
  if (sym) {
#line 342
    if (parent->prompt) {
#line 342
      basedep = (parent->prompt)->visible.expr;
    } else {
#line 342
      basedep = (struct expr *)((void *)0);
    }
    {
#line 343
    basedep = expr_trans_compare(basedep, (enum expr_type )5, & symbol_no);
#line 344
    tmp___6 = expr_transform(basedep);
#line 344
    basedep = expr_eliminate_dups(tmp___6);
#line 345
    last_menu = (struct menu *)((void *)0);
#line 346
    menu = parent->next;
    }
    {
#line 346
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 346
      if (! menu) {
#line 346
        goto while_break___4;
      }
#line 347
      if (menu->prompt) {
#line 347
        dep = (menu->prompt)->visible.expr;
      } else {
#line 347
        dep = menu->dep;
      }
      {
#line 348
      tmp___7 = expr_contains_symbol(dep, sym);
      }
#line 348
      if (! tmp___7) {
#line 349
        goto while_break___4;
      }
      {
#line 350
      tmp___8 = expr_depends_symbol(dep, sym);
      }
#line 350
      if (tmp___8) {
#line 351
        goto next;
      }
      {
#line 352
      dep = expr_trans_compare(dep, (enum expr_type )5, & symbol_no);
#line 353
      tmp___9 = expr_transform(dep);
#line 353
      dep = expr_eliminate_dups(tmp___9);
#line 354
      dep2 = expr_copy((struct expr  const  *)basedep);
#line 355
      expr_eliminate_eq(& dep, & dep2);
#line 356
      expr_free(dep);
#line 357
      tmp___10 = expr_is_yes(dep2);
      }
#line 357
      if (! tmp___10) {
        {
#line 358
        expr_free(dep2);
        }
#line 359
        goto while_break___4;
      }
      {
#line 361
      expr_free(dep2);
      }
      next: 
      {
#line 363
      menu_finalize(menu);
#line 364
      menu->parent = parent;
#line 365
      last_menu = menu;
#line 346
      menu = menu->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 367
    if (last_menu) {
#line 368
      parent->list = parent->next;
#line 369
      parent->next = last_menu->next;
#line 370
      last_menu->next = (struct menu *)((void *)0);
    }
    {
#line 373
    sym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);
    }
  }
#line 375
  menu = parent->list;
  {
#line 375
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 375
    if (! menu) {
#line 375
      goto while_break___5;
    }
#line 376
    if (sym) {
      {
#line 376
      tmp___12 = sym_is_choice(sym);
      }
#line 376
      if (tmp___12) {
#line 376
        if (menu->sym) {
          {
#line 376
          tmp___13 = sym_is_choice_value(menu->sym);
          }
#line 376
          if (! tmp___13) {
#line 378
            current_entry = menu;
#line 379
            (menu->sym)->flags |= 32;
#line 380
            if (! menu->prompt) {
              {
#line 381
              menu_warn(menu, "choice value must have a prompt");
              }
            }
#line 382
            prop = (menu->sym)->prop;
            {
#line 382
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 382
              if (! prop) {
#line 382
                goto while_break___6;
              }
#line 383
              if ((unsigned int )prop->type == 4U) {
                {
#line 384
                prop_warn(prop, "defaults for choice values not supported");
                }
              }
#line 386
              if ((unsigned long )prop->menu == (unsigned long )menu) {
#line 387
                goto __Cont___0;
              }
#line 388
              if ((unsigned int )prop->type == 1U) {
#line 388
                if ((unsigned long )((prop->menu)->parent)->sym != (unsigned long )sym) {
                  {
#line 390
                  prop_warn(prop, "choice value used outside its choice group");
                  }
                }
              }
              __Cont___0: /* CIL Label */ 
#line 382
              prop = prop->next;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 398
            if ((unsigned int )sym->type == 2U) {
#line 398
              if ((unsigned int )(menu->sym)->type != 2U) {
                {
#line 399
                basedep = expr_alloc_comp((enum expr_type )4, sym, & symbol_yes);
#line 400
                menu->dep = expr_alloc_and(basedep, menu->dep);
#line 401
                prop = (menu->sym)->prop;
                }
                {
#line 401
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 401
                  if (! prop) {
#line 401
                    goto while_break___7;
                  }
#line 402
                  if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 403
                    goto __Cont___1;
                  }
                  {
#line 404
                  tmp___11 = expr_copy((struct expr  const  *)basedep);
#line 404
                  prop->visible.expr = expr_alloc_and(tmp___11, prop->visible.expr);
                  }
                  __Cont___1: /* CIL Label */ 
#line 401
                  prop = prop->next;
                }
                while_break___7: /* CIL Label */ ;
                }
              }
            }
            {
#line 408
            menu_add_symbol((enum prop_type )5, sym, (struct expr *)((void *)0));
#line 409
            prop = sym_get_choice_prop(sym);
#line 410
            ep = & prop->expr;
            }
            {
#line 410
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 410
              if (! *ep) {
#line 410
                goto while_break___8;
              }
#line 410
              ep = & (*ep)->left.expr;
            }
            while_break___8: /* CIL Label */ ;
            }
            {
#line 412
            *ep = expr_alloc_one((enum expr_type )10, (struct expr *)((void *)0));
#line 413
            (*ep)->right.sym = menu->sym;
            }
          }
        }
      }
    }
#line 415
    if (menu->list) {
#line 415
      if (! menu->prompt) {
#line 415
        goto _L___0;
      } else
#line 415
      if (! (menu->prompt)->text) {
        _L___0: /* CIL Label */ 
#line 416
        last_menu = menu->list;
        {
#line 416
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 417
          last_menu->parent = parent;
#line 418
          if (! last_menu->next) {
#line 419
            goto while_break___9;
          }
#line 416
          last_menu = last_menu->next;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 421
        last_menu->next = menu->next;
#line 422
        menu->next = menu->list;
#line 423
        menu->list = (struct menu *)((void *)0);
      }
    }
#line 375
    menu = menu->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 427
  if (sym) {
#line 427
    if (! (sym->flags & 32768)) {
#line 428
      if ((unsigned int )sym->type == 0U) {
        {
#line 429
        menu_warn(parent, "config symbol defined without type");
        }
      }
      {
#line 431
      tmp___14 = sym_is_choice(sym);
      }
#line 431
      if (tmp___14) {
#line 431
        if (! parent->prompt) {
          {
#line 432
          menu_warn(parent, "choice must have a prompt");
          }
        }
      }
      {
#line 435
      sym_check_prop(sym);
#line 436
      sym->flags |= 32768;
      }
    }
  }
#line 439
  if (sym) {
    {
#line 439
    tmp___17 = sym_is_optional(sym);
    }
#line 439
    if (! tmp___17) {
#line 439
      if (parent->prompt) {
        {
#line 440
        tmp___15 = expr_alloc_symbol(& symbol_mod);
#line 440
        tmp___16 = expr_alloc_and((parent->prompt)->visible.expr, tmp___15);
#line 440
        sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr, tmp___16);
        }
      }
    }
  }
#line 444
  return;
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
_Bool menu_has_prompt(struct menu *menu ) 
{ 


  {
#line 448
  if (! menu->prompt) {
#line 449
    return ((_Bool)0);
  }
#line 450
  return ((_Bool)1);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
_Bool menu_is_empty(struct menu *menu ) 
{ 
  struct menu *child ;
  _Bool tmp ;

  {
#line 462
  child = menu->list;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! child) {
#line 462
      goto while_break;
    }
    {
#line 463
    tmp = menu_is_visible(child);
    }
#line 463
    if (tmp) {
#line 464
      return ((_Bool)0);
    }
#line 462
    child = child->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return ((_Bool)1);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
_Bool menu_is_visible(struct menu *menu ) 
{ 
  struct menu *child ;
  struct symbol *sym ;
  tristate visible ;
  tristate tmp ;
  tristate tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;

  {
#line 475
  if (! menu->prompt) {
#line 476
    return ((_Bool)0);
  }
#line 478
  if (menu->visibility) {
    {
#line 479
    tmp = expr_calc_value(menu->visibility);
    }
#line 479
    if ((unsigned int )tmp == 0U) {
#line 480
      return ((_Bool)0);
    }
  }
#line 483
  sym = menu->sym;
#line 484
  if (sym) {
    {
#line 485
    sym_calc_value(sym);
#line 486
    visible = (menu->prompt)->visible.tri;
    }
  } else {
    {
#line 488
    tmp___0 = expr_calc_value((menu->prompt)->visible.expr);
#line 488
    (menu->prompt)->visible.tri = tmp___0;
#line 488
    visible = tmp___0;
    }
  }
#line 490
  if ((unsigned int )visible != 0U) {
#line 491
    return ((_Bool)1);
  }
#line 493
  if (! sym) {
#line 494
    return ((_Bool)0);
  } else {
    {
#line 493
    tmp___1 = sym_get_tristate_value(menu->sym);
    }
#line 493
    if ((unsigned int )tmp___1 == 0U) {
#line 494
      return ((_Bool)0);
    }
  }
#line 496
  child = menu->list;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! child) {
#line 496
      goto while_break;
    }
    {
#line 497
    tmp___2 = menu_is_visible(child);
    }
#line 497
    if (tmp___2) {
#line 498
      if (sym) {
#line 499
        sym->flags |= 65536;
      }
#line 500
      return ((_Bool)1);
    }
#line 496
    child = child->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return ((_Bool)0);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
char const   *menu_get_prompt(struct menu *menu ) 
{ 


  {
#line 509
  if (menu->prompt) {
#line 510
    return ((menu->prompt)->text);
  } else
#line 511
  if (menu->sym) {
#line 512
    return ((char const   *)(menu->sym)->name);
  }
#line 513
  return ((char const   *)((void *)0));
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
struct menu *menu_get_root_menu(struct menu *menu ) 
{ 


  {
#line 518
  return (& rootmenu);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
struct menu *menu_get_parent_menu(struct menu *menu ) 
{ 
  enum prop_type type ;

  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! ((unsigned long )menu != (unsigned long )(& rootmenu))) {
#line 525
      goto while_break;
    }
#line 526
    if (menu->prompt) {
#line 526
      type = (menu->prompt)->type;
    } else {
#line 526
      type = (enum prop_type )0;
    }
#line 527
    if ((unsigned int )type == 3U) {
#line 528
      goto while_break;
    }
#line 525
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return (menu);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
_Bool menu_has_help(struct menu *menu ) 
{ 


  {
#line 535
  return ((_Bool )((unsigned long )menu->help != (unsigned long )((void *)0)));
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
char const   *menu_get_help(struct menu *menu ) 
{ 


  {
#line 540
  if (menu->help) {
#line 541
    return ((char const   *)menu->help);
  } else {
#line 543
    return ("");
  }
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static void get_prompt_str(struct gstr *r , struct property *prop , struct list_head *head ) 
{ 
  int i ;
  int j ;
  struct menu *submenu[8] ;
  struct menu *menu ;
  struct menu *location ;
  struct jump_key *jump ;
  char *tmp ;
  char *tmp___0 ;
  _Bool accessible ;
  _Bool tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  struct list_head  const  *__mptr ;
  int tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 550
  location = (struct menu *)((void *)0);
#line 551
  jump = (struct jump_key *)((void *)0);
#line 553
  tmp = gettext(prop->text);
#line 553
  tmp___0 = gettext("Prompt: %s\n");
#line 553
  str_printf(r, (char const   *)tmp___0, tmp);
#line 554
  menu = (prop->menu)->parent;
#line 555
  i = 0;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if ((unsigned long )menu != (unsigned long )(& rootmenu)) {
#line 555
      if (! (i < 8)) {
#line 555
        goto while_break;
      }
    } else {
#line 555
      goto while_break;
    }
    {
#line 556
    tmp___1 = menu_is_visible(menu);
#line 556
    accessible = tmp___1;
#line 558
    tmp___2 = i;
#line 558
    i ++;
#line 558
    submenu[tmp___2] = menu;
    }
#line 559
    if ((unsigned long )location == (unsigned long )((void *)0)) {
#line 559
      if (accessible) {
#line 560
        location = menu;
      }
    }
#line 555
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  if (head) {
#line 562
    if (location) {
      {
#line 563
      tmp___3 = xmalloc(sizeof(struct jump_key ));
#line 563
      jump = (struct jump_key *)tmp___3;
#line 565
      tmp___4 = menu_is_visible(prop->menu);
      }
#line 565
      if (tmp___4) {
#line 572
        jump->target = prop->menu;
      } else {
#line 574
        jump->target = location;
      }
      {
#line 576
      tmp___5 = list_empty((struct list_head  const  *)head);
      }
#line 576
      if (tmp___5) {
#line 577
        jump->index = 0;
      } else {
#line 579
        __mptr = (struct list_head  const  *)head->prev;
#line 579
        jump->index = ((struct jump_key *)((char *)__mptr - (size_t )(& ((struct jump_key *)0)->entries)))->index + 1;
      }
      {
#line 582
      list_add_tail(& jump->entries, head);
      }
    }
  }
#line 585
  if (i > 0) {
    {
#line 586
    tmp___6 = gettext("  Location:\n");
#line 586
    str_printf(r, (char const   *)tmp___6);
#line 587
    j = 4;
    }
    {
#line 587
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 587
      i --;
#line 587
      if (! (i >= 0)) {
#line 587
        goto while_break___0;
      }
#line 588
      menu = submenu[i];
#line 589
      if (jump) {
#line 589
        if ((unsigned long )menu == (unsigned long )location) {
          {
#line 590
          jump->offset = strlen((char const   *)r->s);
          }
        }
      }
      {
#line 591
      tmp___7 = menu_get_prompt(menu);
#line 591
      tmp___8 = gettext(tmp___7);
#line 591
      str_printf(r, "%*c-> %s", j, ' ', tmp___8);
      }
#line 593
      if (menu->sym) {
        {
#line 594
        tmp___9 = sym_get_string_value(menu->sym);
        }
#line 594
        if ((menu->sym)->name) {
#line 594
          tmp___11 = (menu->sym)->name;
        } else {
          {
#line 594
          tmp___10 = gettext("<choice>");
#line 594
          tmp___11 = tmp___10;
          }
        }
        {
#line 594
        str_printf(r, " (%s [=%s])", tmp___11, tmp___9);
        }
      }
      {
#line 598
      str_append(r, "\n");
#line 587
      j += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 601
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static struct property *get_symbol_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 608
  prop = (struct property *)((void *)0);
#line 610
  prop = sym->prop;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! prop) {
#line 610
      goto while_break;
    }
#line 610
    if ((unsigned int )prop->type == 9U) {
#line 611
      goto while_break;
    }
#line 610
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 612
  return (prop);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
static void get_symbol_str(struct gstr *r , struct symbol *sym , struct list_head *head ) 
{ 
  _Bool hit ;
  struct property *prop ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 624
  if (sym) {
#line 624
    if (sym->name) {
      {
#line 625
      tmp = sym_get_string_value(sym);
#line 625
      str_printf(r, "Symbol: %s [=%s]\n", sym->name, tmp);
#line 627
      tmp___0 = sym_type_name(sym->type);
#line 627
      str_printf(r, "Type  : %s\n", tmp___0);
      }
#line 628
      if ((unsigned int )sym->type == 3U) {
#line 628
        goto _L;
      } else
#line 628
      if ((unsigned int )sym->type == 4U) {
        _L: /* CIL Label */ 
        {
#line 629
        prop = sym_get_range_prop(sym);
        }
#line 630
        if (prop) {
          {
#line 631
          str_printf(r, "Range : ");
#line 632
          expr_gstr_print(prop->expr, r);
#line 633
          str_append(r, "\n");
          }
        }
      }
    }
  }
#line 637
  prop = sym->prop;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! prop) {
#line 637
      goto while_break;
    }
#line 637
    if (prop->text) {
      {
#line 638
      get_prompt_str(r, prop, head);
      }
    }
#line 637
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  prop = get_symbol_prop(sym);
  }
#line 641
  if (prop) {
    {
#line 642
    tmp___1 = gettext("  Defined at %s:%d\n");
#line 642
    str_printf(r, (char const   *)tmp___1, ((prop->menu)->file)->name, (prop->menu)->lineno);
#line 644
    tmp___3 = expr_is_yes(prop->visible.expr);
    }
#line 644
    if (! tmp___3) {
      {
#line 645
      tmp___2 = gettext("  Depends on: ");
#line 645
      str_append(r, (char const   *)tmp___2);
#line 646
      expr_gstr_print(prop->visible.expr, r);
#line 647
      str_append(r, "\n");
      }
    }
  }
#line 651
  hit = (_Bool)0;
#line 652
  prop = sym->prop;
  {
#line 652
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 652
    if (! prop) {
#line 652
      goto while_break___0;
    }
#line 652
    if ((unsigned int )prop->type == 6U) {
#line 653
      if (! hit) {
        {
#line 654
        str_append(r, "  Selects: ");
#line 655
        hit = (_Bool)1;
        }
      } else {
        {
#line 657
        str_printf(r, " && ");
        }
      }
      {
#line 658
      expr_gstr_print(prop->expr, r);
      }
    }
#line 652
    prop = prop->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 660
  if (hit) {
    {
#line 661
    str_append(r, "\n");
    }
  }
#line 662
  if (sym->rev_dep.expr) {
    {
#line 663
    tmp___4 = gettext("  Selected by: ");
#line 663
    str_append(r, (char const   *)tmp___4);
#line 664
    expr_gstr_print(sym->rev_dep.expr, r);
#line 665
    str_append(r, "\n");
    }
  }
  {
#line 667
  str_append(r, "\n\n");
  }
#line 668
  return;
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
struct gstr get_relations_str(struct symbol **sym_arr , struct list_head *head ) 
{ 
  struct symbol *sym ;
  struct gstr res ;
  struct gstr tmp ;
  int i ;
  char *tmp___0 ;

  {
  {
#line 673
  tmp = str_new();
#line 673
  res = tmp;
#line 676
  i = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (sym_arr) {
#line 676
      sym = *(sym_arr + i);
#line 676
      if (! sym) {
#line 676
        goto while_break;
      }
    } else {
#line 676
      goto while_break;
    }
    {
#line 677
    get_symbol_str(& res, sym, head);
#line 676
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if (! i) {
    {
#line 679
    tmp___0 = gettext("No matches found.\n");
#line 679
    str_append(& res, (char const   *)tmp___0);
    }
  }
#line 680
  return (res);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/scripts/kconfig/menu.c"
void menu_get_ext_help(struct menu *menu , struct gstr *help ) 
{ 
  struct symbol *sym ;
  char const   *help_text ;
  char const   *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 686
  sym = menu->sym;
#line 687
  help_text = nohelp_text;
#line 689
  tmp___0 = menu_has_help(menu);
  }
#line 689
  if (tmp___0) {
#line 690
    if (sym->name) {
      {
#line 691
      tmp = CONFIG_prefix();
#line 691
      str_printf(help, "%s%s:\n\n", tmp, sym->name);
      }
    }
    {
#line 692
    help_text = menu_get_help(menu);
    }
  }
  {
#line 694
  tmp___1 = gettext(help_text);
#line 694
  str_printf(help, "%s\n", tmp___1);
  }
#line 695
  if (sym) {
    {
#line 696
    get_symbol_str(help, sym, (struct list_head *)((void *)0));
    }
  }
#line 697
  return;
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 582 "/usr/include/regex.h"
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 22 "./tools/include/tools/le_byteshift.h"
__inline static void __put_unaligned_le16(uint16_t val , uint8_t *p ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
#line 24
  tmp = p;
#line 24
  p ++;
#line 24
  *tmp = (uint8_t )val;
#line 25
  tmp___0 = p;
#line 25
  p ++;
#line 25
  *tmp___0 = (uint8_t )((int )val >> 8);
#line 26
  return;
}
}
#line 28 "./tools/include/tools/le_byteshift.h"
__inline static void __put_unaligned_le32(uint32_t val , uint8_t *p ) 
{ 


  {
  {
#line 30
  __put_unaligned_le16((uint16_t )(val >> 16), p + 2);
#line 31
  __put_unaligned_le16((uint16_t )val, p);
  }
#line 32
  return;
}
}
#line 60 "./tools/include/tools/le_byteshift.h"
__inline static void put_unaligned_le32(uint32_t val , void *p ) 
{ 


  {
  {
#line 62
  __put_unaligned_le32(val, (uint8_t *)p);
  }
#line 63
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.h"
void die(char *fmt  , ...) ;
#line 31
void process_32(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static Elf32_Ehdr ehdr  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct relocs relocs16  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct relocs relocs32  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct section *secs  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_kernel[4]  = {      (char const   */* const  */)"^(xen_irq_disable_direct_reloc$|xen_save_fl_direct_reloc$|VDSO|__crc_)",      (char const   */* const  */)"^(__init_(begin|end)|__x86_cpu_dev_(start|end)|(__parainstructions|__alt_instructions)(|_end)|(__iommu_table|__apicdrivers|__smp_locks)(|_end)|__(start|end)_pci_.*|__(start|end)_builtin_fw|__(start|stop)___ksymtab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___kcrctab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___param|__(start|stop)___modver|__(start|stop)___bug_table|__tracedata_(start|end)|__(start|stop)_notes|__end_rodata|__initramfs_start|(jiffies|jiffies_64)|__vvar_page|_end)$"};
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_realmode[4]  = {      (char const   */* const  */)0,      (char const   */* const  */)"^pa_",      (char const   */* const  */)"^real_mode_seg$",      (char const   */* const  */)"^pa_"};
#line 103 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   * const  *sym_regex  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static regex_t sym_regex_c[4]  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int is_reloc(enum symtype type , char const   *sym_name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 108
  if (*(sym_regex + type)) {
    {
#line 108
    tmp = regexec((regex_t const   */* __restrict  */)(& sym_regex_c[type]), (char const   */* __restrict  */)sym_name___1,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 108
    if (tmp) {
#line 108
      tmp___0 = 0;
    } else {
#line 108
      tmp___0 = 1;
    }
  } else {
#line 108
    tmp___0 = 0;
  }
#line 108
  return (tmp___0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void regex_init(int use_real_mode ) 
{ 
  char errbuf[128] ;
  int err ;
  int i ;

  {
#line 118
  if (use_real_mode) {
#line 119
    sym_regex = sym_regex_realmode;
  } else {
#line 121
    sym_regex = sym_regex_kernel;
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 4)) {
#line 123
      goto while_break;
    }
#line 124
    if (! *(sym_regex + i)) {
#line 125
      goto __Cont;
    }
    {
#line 127
    err = regcomp((regex_t */* __restrict  */)(& sym_regex_c[i]), (char const   */* __restrict  */)*(sym_regex + i),
                  1 | (((1 << 1) << 1) << 1));
    }
#line 130
    if (err) {
      {
#line 131
      regerror(err, (regex_t const   */* __restrict  */)(& sym_regex_c[i]), (char */* __restrict  */)(errbuf),
               sizeof(errbuf));
#line 132
      die((char *)"%s", errbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 139
static char const   *sym_type(unsigned int type ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *type_name[7]  = {      "STT_NOTYPE",      "STT_OBJECT",      "STT_FUNC",      "STT_SECTION", 
        "STT_FILE",      "STT_COMMON",      "STT_TLS"};
#line 137 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_type(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 150
  name = "unknown sym type name";
#line 151
  if ((unsigned long )type < sizeof(type_name) / sizeof(type_name[0])) {
#line 152
    name = type_name[type];
  }
#line 154
  return (name);
}
}
#line 159
static char const   *sym_bind(unsigned int bind ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *bind_name[3]  = {      "STB_LOCAL",      "STB_GLOBAL",      "STB_WEAK"};
#line 157 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_bind(unsigned int bind ) 
{ 
  char const   *name ;

  {
#line 166
  name = "unknown sym bind name";
#line 167
  if ((unsigned long )bind < sizeof(bind_name) / sizeof(bind_name[0])) {
#line 168
    name = bind_name[bind];
  }
#line 170
  return (name);
}
}
#line 175
static char const   *sym_visibility(unsigned int visibility ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *visibility_name[4]  = {      "STV_DEFAULT",      "STV_INTERNAL",      "STV_HIDDEN",      "STV_PROTECTED"};
#line 173 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_visibility(unsigned int visibility ) 
{ 
  char const   *name ;

  {
#line 183
  name = "unknown sym visibility name";
#line 184
  if ((unsigned long )visibility < sizeof(visibility_name) / sizeof(visibility_name[0])) {
#line 185
    name = visibility_name[visibility];
  }
#line 187
  return (name);
}
}
#line 192
static char const   *rel_type(unsigned int type ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *type_name___0[24]  = 
#line 192
  {      "R_386_NONE",      "R_386_32",      "R_386_PC32",      "R_386_GOT32", 
        "R_386_PLT32",      "R_386_COPY",      "R_386_GLOB_DAT",      "R_386_JMP_SLOT", 
        "R_386_RELATIVE",      "R_386_GOTOFF",      "R_386_GOTPC",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "R_386_16",      "R_386_PC16",      "R_386_8",      "R_386_PC8"};
#line 190 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *rel_type(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 230
  name = "unknown type rel type name";
#line 231
  if ((unsigned long )type < sizeof(type_name___0) / sizeof(type_name___0[0])) {
#line 231
    if (type_name___0[type]) {
#line 232
      name = type_name___0[type];
    }
  }
#line 234
  return (name);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sec_name(unsigned int shndx ) 
{ 
  char const   *sec_strtab ;
  char const   *name ;

  {
#line 241
  sec_strtab = (char const   *)(secs + ehdr.e_shstrndx)->strtab;
#line 242
  name = "<noname>";
#line 243
  if (shndx < (unsigned int )ehdr.e_shnum) {
#line 244
    name = sec_strtab + (secs + shndx)->shdr.sh_name;
  } else
#line 246
  if (shndx == 65521U) {
#line 247
    name = "ABSOLUTE";
  } else
#line 249
  if (shndx == 65522U) {
#line 250
    name = "COMMON";
  }
#line 252
  return (name);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_name(char const   *sym_strtab , Elf32_Sym *sym ) 
{ 
  char const   *name ;

  {
#line 258
  name = "<noname>";
#line 259
  if (sym->st_name) {
#line 260
    name = sym_strtab + sym->st_name;
  } else {
    {
#line 263
    name = sec_name((unsigned int )sym->st_shndx);
    }
  }
#line 265
  return (name);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static uint16_t elf16_to_cpu(uint16_t val ) 
{ 


  {
#line 308
  return (val);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static uint32_t elf32_to_cpu(uint32_t val ) 
{ 


  {
#line 313
  return (val);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_ehdr(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 335
  tmp___1 = fread((void */* __restrict  */)(& ehdr), sizeof(ehdr), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 335
  if (tmp___1 != 1UL) {
    {
#line 336
    tmp = __errno_location();
#line 336
    tmp___0 = strerror(*tmp);
#line 336
    die((char *)"Cannot read ELF header: %s\n", tmp___0);
    }
  }
  {
#line 339
  tmp___2 = memcmp((void const   *)(ehdr.e_ident), (void const   *)"\177ELF", (size_t )4);
  }
#line 339
  if (tmp___2 != 0) {
    {
#line 340
    die((char *)"No ELF magic\n");
    }
  }
#line 342
  if ((int )ehdr.e_ident[4] != 1) {
    {
#line 343
    die((char *)"Not a %d bit executable\n", 32);
    }
  }
#line 345
  if ((int )ehdr.e_ident[5] != 1) {
    {
#line 346
    die((char *)"Not a LSB ELF executable\n");
    }
  }
#line 348
  if ((int )ehdr.e_ident[6] != 1) {
    {
#line 349
    die((char *)"Unknown ELF version\n");
    }
  }
  {
#line 352
  ehdr.e_type = elf16_to_cpu(ehdr.e_type);
#line 353
  ehdr.e_machine = elf16_to_cpu(ehdr.e_machine);
#line 354
  ehdr.e_version = elf32_to_cpu(ehdr.e_version);
#line 355
  ehdr.e_entry = elf32_to_cpu(ehdr.e_entry);
#line 356
  ehdr.e_phoff = elf32_to_cpu(ehdr.e_phoff);
#line 357
  ehdr.e_shoff = elf32_to_cpu(ehdr.e_shoff);
#line 358
  ehdr.e_flags = elf32_to_cpu(ehdr.e_flags);
#line 359
  ehdr.e_ehsize = elf16_to_cpu(ehdr.e_ehsize);
#line 360
  ehdr.e_phentsize = elf16_to_cpu(ehdr.e_phentsize);
#line 361
  ehdr.e_phnum = elf16_to_cpu(ehdr.e_phnum);
#line 362
  ehdr.e_shentsize = elf16_to_cpu(ehdr.e_shentsize);
#line 363
  ehdr.e_shnum = elf16_to_cpu(ehdr.e_shnum);
#line 364
  ehdr.e_shstrndx = elf16_to_cpu(ehdr.e_shstrndx);
  }
#line 366
  if ((int )ehdr.e_type != 2) {
#line 366
    if ((int )ehdr.e_type != 3) {
      {
#line 367
      die((char *)"Unsupported ELF header type\n");
      }
    }
  }
#line 369
  if ((int )ehdr.e_machine != 3) {
    {
#line 370
    die((char *)"Not for %s\n", "i386");
    }
  }
#line 372
  if (ehdr.e_version != 1U) {
    {
#line 373
    die((char *)"Unknown ELF version\n");
    }
  }
#line 375
  if ((unsigned long )ehdr.e_ehsize != sizeof(Elf32_Ehdr )) {
    {
#line 376
    die((char *)"Bad Elf header size\n");
    }
  }
#line 378
  if ((unsigned long )ehdr.e_phentsize != sizeof(Elf32_Phdr )) {
    {
#line 379
    die((char *)"Bad program header entry\n");
    }
  }
#line 381
  if ((unsigned long )ehdr.e_shentsize != sizeof(Elf32_Shdr )) {
    {
#line 382
    die((char *)"Bad section header entry\n");
    }
  }
#line 384
  if ((int )ehdr.e_shstrndx >= (int )ehdr.e_shnum) {
    {
#line 385
    die((char *)"String table index out of bounds\n");
    }
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_shdrs(FILE *fp ) 
{ 
  int i ;
  Elf32_Shdr shdr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct section *sec ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 394
  tmp = calloc((size_t )ehdr.e_shnum, sizeof(struct section ));
#line 394
  secs = (struct section *)tmp;
  }
#line 395
  if (! secs) {
    {
#line 396
    die((char *)"Unable to allocate %d section headers\n", (int )ehdr.e_shnum);
    }
  }
  {
#line 399
  tmp___2 = fseek(fp, (long )ehdr.e_shoff, 0);
  }
#line 399
  if (tmp___2 < 0) {
    {
#line 400
    tmp___0 = __errno_location();
#line 400
    tmp___1 = strerror(*tmp___0);
#line 400
    die((char *)"Seek to %d failed: %s\n", ehdr.e_shoff, tmp___1);
    }
  }
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < (int )ehdr.e_shnum)) {
#line 403
      goto while_break;
    }
    {
#line 404
    sec = secs + i;
#line 405
    tmp___5 = fread((void */* __restrict  */)(& shdr), sizeof(shdr), (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 405
    if (tmp___5 != 1UL) {
      {
#line 406
      tmp___3 = __errno_location();
#line 406
      tmp___4 = strerror(*tmp___3);
#line 406
      die((char *)"Cannot read ELF section headers %d/%d: %s\n", i, (int )ehdr.e_shnum,
          tmp___4);
      }
    }
    {
#line 408
    sec->shdr.sh_name = elf32_to_cpu(shdr.sh_name);
#line 409
    sec->shdr.sh_type = elf32_to_cpu(shdr.sh_type);
#line 410
    sec->shdr.sh_flags = elf32_to_cpu(shdr.sh_flags);
#line 411
    sec->shdr.sh_addr = elf32_to_cpu(shdr.sh_addr);
#line 412
    sec->shdr.sh_offset = elf32_to_cpu(shdr.sh_offset);
#line 413
    sec->shdr.sh_size = elf32_to_cpu(shdr.sh_size);
#line 414
    sec->shdr.sh_link = elf32_to_cpu(shdr.sh_link);
#line 415
    sec->shdr.sh_info = elf32_to_cpu(shdr.sh_info);
#line 416
    sec->shdr.sh_addralign = elf32_to_cpu(shdr.sh_addralign);
#line 417
    sec->shdr.sh_entsize = elf32_to_cpu(shdr.sh_entsize);
    }
#line 418
    if (sec->shdr.sh_link < (Elf32_Word )ehdr.e_shnum) {
#line 419
      sec->link = secs + sec->shdr.sh_link;
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_strtabs(FILE *fp ) 
{ 
  int i ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 427
  i = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < (int )ehdr.e_shnum)) {
#line 427
      goto while_break;
    }
#line 428
    sec = secs + i;
#line 429
    if (sec->shdr.sh_type != 3U) {
#line 430
      goto __Cont;
    }
    {
#line 432
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 432
    sec->strtab = (char *)tmp;
    }
#line 433
    if (! sec->strtab) {
      {
#line 434
      die((char *)"malloc of %d bytes for strtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 437
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 437
    if (tmp___2 < 0) {
      {
#line 438
      tmp___0 = __errno_location();
#line 438
      tmp___1 = strerror(*tmp___0);
#line 438
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 441
    tmp___5 = fread((void */* __restrict  */)sec->strtab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 441
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 443
      tmp___3 = __errno_location();
#line 443
      tmp___4 = strerror(*tmp___3);
#line 443
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
    __Cont: /* CIL Label */ 
#line 427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_symtabs(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf32_Sym *sym ;

  {
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < (int )ehdr.e_shnum)) {
#line 452
      goto while_break;
    }
#line 453
    sec = secs + i;
#line 454
    if (sec->shdr.sh_type != 2U) {
#line 455
      goto __Cont;
    }
    {
#line 457
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 457
    sec->symtab = (Elf32_Sym *)tmp;
    }
#line 458
    if (! sec->symtab) {
      {
#line 459
      die((char *)"malloc of %d bytes for symtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 462
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 462
    if (tmp___2 < 0) {
      {
#line 463
      tmp___0 = __errno_location();
#line 463
      tmp___1 = strerror(*tmp___0);
#line 463
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 466
    tmp___5 = fread((void */* __restrict  */)sec->symtab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 466
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 468
      tmp___3 = __errno_location();
#line 468
      tmp___4 = strerror(*tmp___3);
#line 468
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 471
    j = 0;
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Sym ))) {
#line 471
        goto while_break___0;
      }
      {
#line 472
      sym = sec->symtab + j;
#line 473
      sym->st_name = elf32_to_cpu(sym->st_name);
#line 474
      sym->st_value = elf32_to_cpu(sym->st_value);
#line 475
      sym->st_size = elf32_to_cpu(sym->st_size);
#line 476
      sym->st_shndx = elf16_to_cpu(sym->st_shndx);
#line 471
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_relocs(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf32_Rel *rel ;

  {
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < (int )ehdr.e_shnum)) {
#line 485
      goto while_break;
    }
#line 486
    sec = secs + i;
#line 487
    if (sec->shdr.sh_type != 9U) {
#line 488
      goto __Cont;
    }
    {
#line 490
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 490
    sec->reltab = (Elf32_Rel *)tmp;
    }
#line 491
    if (! sec->reltab) {
      {
#line 492
      die((char *)"malloc of %d bytes for relocs failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 495
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 495
    if (tmp___2 < 0) {
      {
#line 496
      tmp___0 = __errno_location();
#line 496
      tmp___1 = strerror(*tmp___0);
#line 496
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 499
    tmp___5 = fread((void */* __restrict  */)sec->reltab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 499
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 501
      tmp___3 = __errno_location();
#line 501
      tmp___4 = strerror(*tmp___3);
#line 501
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 504
    j = 0;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 504
        goto while_break___0;
      }
      {
#line 505
      rel = sec->reltab + j;
#line 506
      rel->r_offset = elf32_to_cpu(rel->r_offset);
#line 507
      rel->r_info = elf32_to_cpu(rel->r_info);
#line 504
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void print_absolute_symbols(void) 
{ 
  int i ;
  char const   *format ;
  struct section *sec ;
  char *sym_strtab ;
  int j ;
  Elf32_Sym *sym ;
  char const   *name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 524
  format = "%5d %08x  %5d %10s %10s %12s %s\n";
#line 526
  printf((char const   */* __restrict  */)"Absolute symbols\n");
#line 527
  printf((char const   */* __restrict  */)" Num:    Value Size  Type       Bind        Visibility  Name\n");
#line 528
  i = 0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < (int )ehdr.e_shnum)) {
#line 528
      goto while_break;
    }
#line 529
    sec = secs + i;
#line 533
    if (sec->shdr.sh_type != 2U) {
#line 534
      goto __Cont;
    }
#line 536
    sym_strtab = (sec->link)->strtab;
#line 537
    j = 0;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Sym ))) {
#line 537
        goto while_break___0;
      }
      {
#line 540
      sym = sec->symtab + j;
#line 541
      name = sym_name((char const   *)sym_strtab, sym);
      }
#line 542
      if ((int )sym->st_shndx != 65521) {
#line 543
        goto __Cont___0;
      }
      {
#line 545
      tmp = sym_visibility((unsigned int )((int )sym->st_other & 3));
#line 545
      tmp___0 = sym_bind((unsigned int )((int )sym->st_info >> 4));
#line 545
      tmp___1 = sym_type((unsigned int )((int )sym->st_info & 15));
#line 545
      printf((char const   */* __restrict  */)format, j, sym->st_value, sym->st_size,
             tmp___1, tmp___0, tmp, name);
      }
      __Cont___0: /* CIL Label */ 
#line 537
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  printf((char const   */* __restrict  */)"\n");
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void print_absolute_relocs(void) 
{ 
  int i ;
  int printed ;
  char const   *format ;
  struct section *sec ;
  struct section *sec_applies ;
  struct section *sec_symtab ;
  char *sym_strtab ;
  Elf32_Sym *sh_symtab ;
  int j ;
  Elf32_Rel *rel ;
  Elf32_Sym *sym ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 558
  printed = 0;
#line 564
  format = "%08x %08x %10s %08x  %s\n";
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < (int )ehdr.e_shnum)) {
#line 566
      goto while_break;
    }
#line 567
    sec = secs + i;
#line 572
    if (sec->shdr.sh_type != 9U) {
#line 573
      goto __Cont;
    }
#line 575
    sec_symtab = sec->link;
#line 576
    sec_applies = secs + sec->shdr.sh_info;
#line 577
    if (! (sec_applies->shdr.sh_flags & (unsigned int )(1 << 1))) {
#line 578
      goto __Cont;
    }
#line 580
    sh_symtab = sec_symtab->symtab;
#line 581
    sym_strtab = (sec_symtab->link)->strtab;
#line 582
    j = 0;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 582
        goto while_break___0;
      }
      {
#line 586
      rel = sec->reltab + j;
#line 587
      sym = sh_symtab + (rel->r_info >> 8);
#line 588
      name = sym_name((char const   *)sym_strtab, sym);
      }
#line 589
      if ((int )sym->st_shndx != 65521) {
#line 590
        goto __Cont___0;
      }
      {
#line 606
      tmp = is_reloc((enum symtype )0, name);
      }
#line 606
      if (tmp) {
#line 607
        goto __Cont___0;
      } else {
        {
#line 606
        tmp___0 = is_reloc((enum symtype )1, name);
        }
#line 606
        if (tmp___0) {
#line 607
          goto __Cont___0;
        }
      }
#line 609
      if (! printed) {
        {
#line 610
        printf((char const   */* __restrict  */)"WARNING: Absolute relocations present\n");
#line 612
        printf((char const   */* __restrict  */)"Offset     Info     Type     Sym.Value Sym.Name\n");
#line 614
        printed = 1;
        }
      }
      {
#line 617
      tmp___1 = rel_type(rel->r_info & 255U);
#line 617
      printf((char const   */* __restrict  */)format, rel->r_offset, rel->r_info,
             tmp___1, sym->st_value, name);
      }
      __Cont___0: /* CIL Label */ 
#line 582
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  if (printed) {
    {
#line 627
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void add_reloc(struct relocs *r , uint32_t offset ) 
{ 
  unsigned long newsize ;
  void *mem ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 632
  if (r->count == r->size) {
    {
#line 633
    newsize = r->size + 50000UL;
#line 634
    tmp = realloc((void *)r->offset, newsize * sizeof(*(r->offset + 0)));
#line 634
    mem = tmp;
    }
#line 636
    if (! mem) {
      {
#line 637
      die((char *)"realloc of %ld entries for relocs failed\n", newsize);
      }
    }
#line 639
    r->offset = (uint32_t *)mem;
#line 640
    r->size = newsize;
  }
#line 642
  tmp___0 = r->count;
#line 642
  (r->count) ++;
#line 642
  *(r->offset + tmp___0) = offset;
#line 643
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void walk_relocs(int (*process)(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym ,
                                       char const   *symname ) ) 
{ 
  int i ;
  char *sym_strtab ;
  Elf32_Sym *sh_symtab ;
  struct section *sec_applies ;
  struct section *sec_symtab ;
  int j ;
  struct section *sec ;
  Elf32_Rel *rel ;
  Elf32_Sym *sym ;
  char const   *symname ;
  char const   *tmp ;

  {
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < (int )ehdr.e_shnum)) {
#line 650
      goto while_break;
    }
#line 655
    sec = secs + i;
#line 657
    if (sec->shdr.sh_type != 9U) {
#line 658
      goto __Cont;
    }
#line 660
    sec_symtab = sec->link;
#line 661
    sec_applies = secs + sec->shdr.sh_info;
#line 662
    if (! (sec_applies->shdr.sh_flags & (unsigned int )(1 << 1))) {
#line 663
      goto __Cont;
    }
#line 665
    sh_symtab = sec_symtab->symtab;
#line 666
    sym_strtab = (sec_symtab->link)->strtab;
#line 667
    j = 0;
    {
#line 667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 667
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 667
        goto while_break___0;
      }
      {
#line 668
      rel = sec->reltab + j;
#line 669
      sym = sh_symtab + (rel->r_info >> 8);
#line 670
      tmp = sym_name((char const   *)sym_strtab, sym);
#line 670
      symname = tmp;
#line 672
      (*process)(sec, rel, sym, symname);
#line 667
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int do_reloc32(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) 
{ 
  unsigned int r_type ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 831
  r_type = rel->r_info & 255U;
#line 832
  if ((int )sym->st_shndx == 65521) {
    {
#line 832
    tmp = is_reloc((enum symtype )1, symname);
    }
#line 832
    if (tmp) {
#line 832
      tmp___0 = 0;
    } else {
#line 832
      tmp___0 = 1;
    }
  } else {
#line 832
    tmp___0 = 0;
  }
#line 832
  shn_abs = tmp___0;
  {
#line 838
  if (r_type == 23U) {
#line 838
    goto case_23;
  }
#line 838
  if (r_type == 21U) {
#line 838
    goto case_23;
  }
#line 838
  if (r_type == 2U) {
#line 838
    goto case_23;
  }
#line 838
  if (r_type == 0U) {
#line 838
    goto case_23;
  }
#line 845
  if (r_type == 1U) {
#line 845
    goto case_1;
  }
#line 862
  goto switch_default;
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 843
  goto switch_break;
  case_1: /* CIL Label */ 
#line 846
  if (shn_abs) {
    {
#line 851
    tmp___1 = is_reloc((enum symtype )0, symname);
    }
#line 851
    if (tmp___1) {
#line 852
      goto switch_break;
    }
    {
#line 854
    tmp___2 = rel_type(r_type);
#line 854
    die((char *)"Invalid absolute %s relocation: %s\n", tmp___2, symname);
    }
#line 856
    goto switch_break;
  }
  {
#line 859
  add_reloc(& relocs32, rel->r_offset);
  }
#line 860
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 863
  tmp___3 = rel_type(r_type);
#line 863
  die((char *)"Unsupported relocation type: %s (%d)\n", tmp___3, r_type);
  }
#line 865
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 868
  return (0);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int do_reloc_real(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) 
{ 
  unsigned int r_type ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
#line 874
  r_type = rel->r_info & 255U;
#line 875
  if ((int )sym->st_shndx == 65521) {
    {
#line 875
    tmp = is_reloc((enum symtype )1, symname);
    }
#line 875
    if (tmp) {
#line 875
      tmp___0 = 0;
    } else {
#line 875
      tmp___0 = 1;
    }
  } else {
#line 875
    tmp___0 = 0;
  }
#line 875
  shn_abs = tmp___0;
  {
#line 881
  if (r_type == 23U) {
#line 881
    goto case_23;
  }
#line 881
  if (r_type == 21U) {
#line 881
    goto case_23;
  }
#line 881
  if (r_type == 2U) {
#line 881
    goto case_23;
  }
#line 881
  if (r_type == 0U) {
#line 881
    goto case_23;
  }
#line 888
  if (r_type == 20U) {
#line 888
    goto case_20;
  }
#line 910
  if (r_type == 1U) {
#line 910
    goto case_1;
  }
#line 933
  goto switch_default;
  case_23: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 886
  goto switch_break;
  case_20: /* CIL Label */ 
#line 889
  if (shn_abs) {
    {
#line 894
    tmp___1 = is_reloc((enum symtype )0, symname);
    }
#line 894
    if (tmp___1) {
#line 895
      goto switch_break;
    }
    {
#line 897
    tmp___2 = is_reloc((enum symtype )2, symname);
    }
#line 897
    if (tmp___2) {
      {
#line 898
      add_reloc(& relocs16, rel->r_offset);
      }
#line 899
      goto switch_break;
    }
  } else {
    {
#line 902
    tmp___3 = is_reloc((enum symtype )3, symname);
    }
#line 902
    if (! tmp___3) {
#line 903
      goto switch_break;
    }
  }
  {
#line 905
  tmp___4 = rel_type(r_type);
  }
#line 905
  if (shn_abs) {
#line 905
    tmp___5 = "absolute";
  } else {
#line 905
    tmp___5 = "relative";
  }
  {
#line 905
  die((char *)"Invalid %s %s relocation: %s\n", tmp___5, tmp___4, symname);
  }
#line 908
  goto switch_break;
  case_1: /* CIL Label */ 
#line 911
  if (shn_abs) {
    {
#line 916
    tmp___6 = is_reloc((enum symtype )0, symname);
    }
#line 916
    if (tmp___6) {
#line 917
      goto switch_break;
    }
    {
#line 919
    tmp___7 = is_reloc((enum symtype )1, symname);
    }
#line 919
    if (tmp___7) {
      {
#line 920
      add_reloc(& relocs32, rel->r_offset);
      }
#line 921
      goto switch_break;
    }
  } else {
    {
#line 924
    tmp___8 = is_reloc((enum symtype )3, symname);
    }
#line 924
    if (tmp___8) {
      {
#line 925
      add_reloc(& relocs32, rel->r_offset);
      }
    }
#line 926
    goto switch_break;
  }
  {
#line 928
  tmp___9 = rel_type(r_type);
  }
#line 928
  if (shn_abs) {
#line 928
    tmp___10 = "absolute";
  } else {
#line 928
    tmp___10 = "relative";
  }
  {
#line 928
  die((char *)"Invalid %s %s relocation: %s\n", tmp___10, tmp___9, symname);
  }
#line 931
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 934
  tmp___11 = rel_type(r_type);
#line 934
  die((char *)"Unsupported relocation type: %s (%d)\n", tmp___11, r_type);
  }
#line 936
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 939
  return (0);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int cmp_relocs(void const   *va , void const   *vb ) 
{ 
  uint32_t const   *a ;
  uint32_t const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 947
  a = (uint32_t const   *)va;
#line 947
  b = (uint32_t const   *)vb;
#line 948
  if (*a == *b) {
#line 948
    tmp___0 = 0;
  } else {
#line 948
    if (*a > *b) {
#line 948
      tmp = 1;
    } else {
#line 948
      tmp = -1;
    }
#line 948
    tmp___0 = tmp;
  }
#line 948
  return (tmp___0);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void sort_relocs(struct relocs *r ) 
{ 


  {
  {
#line 953
  qsort((void *)r->offset, r->count, sizeof(*(r->offset + 0)), & cmp_relocs);
  }
#line 954
  return;
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int write32(uint32_t v , FILE *f ) 
{ 
  unsigned char buf[4] ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 960
  put_unaligned_le32(v, (void *)(buf));
#line 961
  tmp___1 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)f);
  }
#line 961
  if (tmp___1 == 4UL) {
#line 961
    tmp___0 = 0;
  } else {
#line 961
    tmp___0 = -1;
  }
#line 961
  return (tmp___0);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int write32_as_text(uint32_t v , FILE *f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 966
  tmp___1 = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\t.long 0x%08x\n",
                    v);
  }
#line 966
  if (tmp___1 > 0) {
#line 966
    tmp___0 = 0;
  } else {
#line 966
    tmp___0 = -1;
  }
#line 966
  return (tmp___0);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void emit_relocs(int as_text , int use_real_mode ) 
{ 
  int i ;
  int (*write_reloc)(uint32_t  , FILE * ) ;
  int (*do_reloc)(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) ;

  {
#line 972
  write_reloc = & write32;
#line 982
  if (! use_real_mode) {
#line 983
    do_reloc = & do_reloc32;
  } else {
#line 985
    do_reloc = & do_reloc_real;
  }
  {
#line 989
  walk_relocs(do_reloc);
  }
#line 991
  if (relocs16.count) {
#line 991
    if (! use_real_mode) {
      {
#line 992
      die((char *)"Segment relocations found but --realmode not specified\n");
      }
    }
  }
  {
#line 995
  sort_relocs(& relocs16);
#line 996
  sort_relocs(& relocs32);
  }
#line 1003
  if (as_text) {
    {
#line 1007
    printf((char const   */* __restrict  */)".section \".data.reloc\",\"a\"\n");
#line 1008
    printf((char const   */* __restrict  */)".balign 4\n");
#line 1009
    write_reloc = & write32_as_text;
    }
  }
#line 1012
  if (use_real_mode) {
    {
#line 1013
    (*write_reloc)((uint32_t )relocs16.count, stdout);
#line 1014
    i = 0;
    }
    {
#line 1014
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1014
      if (! ((unsigned long )i < relocs16.count)) {
#line 1014
        goto while_break;
      }
      {
#line 1015
      (*write_reloc)(*(relocs16.offset + i), stdout);
#line 1014
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1017
    (*write_reloc)((uint32_t )relocs32.count, stdout);
#line 1018
    i = 0;
    }
    {
#line 1018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1018
      if (! ((unsigned long )i < relocs32.count)) {
#line 1018
        goto while_break___0;
      }
      {
#line 1019
      (*write_reloc)(*(relocs32.offset + i), stdout);
#line 1018
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1038
    (*write_reloc)((uint32_t )0, stdout);
#line 1041
    i = 0;
    }
    {
#line 1041
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1041
      if (! ((unsigned long )i < relocs32.count)) {
#line 1041
        goto while_break___1;
      }
      {
#line 1042
      (*write_reloc)(*(relocs32.offset + i), stdout);
#line 1041
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1044
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int do_reloc_info(struct section *sec , Elf32_Rel *rel , Elf32_Sym *sym , char const   *symname ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1055
  tmp = sec_name((unsigned int )sym->st_shndx);
#line 1055
  tmp___0 = rel_type(rel->r_info & 255U);
#line 1055
  tmp___1 = sec_name(sec->shdr.sh_info);
#line 1055
  printf((char const   */* __restrict  */)"%s\t%s\t%s\t%s\n", tmp___1, tmp___0, symname,
         tmp);
  }
#line 1060
  return (0);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void print_reloc_info(void) 
{ 


  {
  {
#line 1065
  printf((char const   */* __restrict  */)"reloc section\treloc type\tsymbol\tsymbol section\n");
#line 1066
  walk_relocs(& do_reloc_info);
  }
#line 1067
  return;
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
void process_32(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) 
{ 


  {
  {
#line 1079
  regex_init(use_real_mode);
#line 1080
  read_ehdr(fp);
#line 1081
  read_shdrs(fp);
#line 1082
  read_strtabs(fp);
#line 1083
  read_symtabs(fp);
#line 1084
  read_relocs(fp);
  }
#line 1087
  if (show_absolute_syms) {
    {
#line 1088
    print_absolute_symbols();
    }
#line 1089
    return;
  }
#line 1091
  if (show_absolute_relocs) {
    {
#line 1092
    print_absolute_relocs();
    }
#line 1093
    return;
  }
#line 1095
  if (show_reloc_info) {
    {
#line 1096
    print_reloc_info();
    }
#line 1097
    return;
  }
  {
#line 1099
  emit_relocs(as_text, use_real_mode);
  }
#line 1100
  return;
}
}
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.h"
void process_64(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs_common.c"
void die(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 6
  __builtin_va_start(ap, fmt);
#line 7
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 8
  __builtin_va_end(ap);
#line 9
  exit(1);
  }
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs_common.c"
static void usage___0(void) 
{ 


  {
  {
#line 14
  die((char *)"relocs [--abs-syms|--abs-relocs|--reloc-info|--text|--realmode] vmlinux\n");
  }
#line 16
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static Elf64_Ehdr ehdr___0  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct relocs relocs16___0  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct relocs relocs32___0  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct relocs relocs32neg  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct relocs relocs64  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static struct section___0 *secs___0  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_kernel___0[4]  = {      (char const   */* const  */)"^(xen_irq_disable_direct_reloc$|xen_save_fl_direct_reloc$|VDSO|__crc_)",      (char const   */* const  */)"^(__init_(begin|end)|__x86_cpu_dev_(start|end)|(__parainstructions|__alt_instructions)(|_end)|(__iommu_table|__apicdrivers|__smp_locks)(|_end)|__(start|end)_pci_.*|__(start|end)_builtin_fw|__(start|stop)___ksymtab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___kcrctab(|_gpl|_unused|_unused_gpl|_gpl_future)|__(start|stop)___param|__(start|stop)___modver|__(start|stop)___bug_table|__tracedata_(start|end)|__(start|stop)_notes|__end_rodata|__initramfs_start|(jiffies|jiffies_64)|__per_cpu_load|init_per_cpu__.*|__end_rodata_hpage_align|__vvar_page|_end)$"};
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_realmode___0[4]  = {      (char const   */* const  */)0,      (char const   */* const  */)"^pa_",      (char const   */* const  */)"^real_mode_seg$",      (char const   */* const  */)"^pa_"};
#line 103 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   * const  *sym_regex___0  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static regex_t sym_regex_c___0[4]  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int is_reloc___0(enum symtype type , char const   *sym_name___1 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 108
  if (*(sym_regex___0 + type)) {
    {
#line 108
    tmp = regexec((regex_t const   */* __restrict  */)(& sym_regex_c___0[type]), (char const   */* __restrict  */)sym_name___1,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 108
    if (tmp) {
#line 108
      tmp___0 = 0;
    } else {
#line 108
      tmp___0 = 1;
    }
  } else {
#line 108
    tmp___0 = 0;
  }
#line 108
  return (tmp___0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void regex_init___0(int use_real_mode ) 
{ 
  char errbuf[128] ;
  int err ;
  int i ;

  {
#line 118
  if (use_real_mode) {
#line 119
    sym_regex___0 = sym_regex_realmode___0;
  } else {
#line 121
    sym_regex___0 = sym_regex_kernel___0;
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 4)) {
#line 123
      goto while_break;
    }
#line 124
    if (! *(sym_regex___0 + i)) {
#line 125
      goto __Cont;
    }
    {
#line 127
    err = regcomp((regex_t */* __restrict  */)(& sym_regex_c___0[i]), (char const   */* __restrict  */)*(sym_regex___0 + i),
                  1 | (((1 << 1) << 1) << 1));
    }
#line 130
    if (err) {
      {
#line 131
      regerror(err, (regex_t const   */* __restrict  */)(& sym_regex_c___0[i]), (char */* __restrict  */)(errbuf),
               sizeof(errbuf));
#line 132
      die((char *)"%s", errbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 139
static char const   *sym_type___0(unsigned int type ) ;
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *type_name___1[7]  = {      "STT_NOTYPE",      "STT_OBJECT",      "STT_FUNC",      "STT_SECTION", 
        "STT_FILE",      "STT_COMMON",      "STT_TLS"};
#line 137 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_type___0(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 150
  name = "unknown sym type name";
#line 151
  if ((unsigned long )type < sizeof(type_name___1) / sizeof(type_name___1[0])) {
#line 152
    name = type_name___1[type];
  }
#line 154
  return (name);
}
}
#line 159
static char const   *sym_bind___0(unsigned int bind ) ;
#line 159 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *bind_name___0[3]  = {      "STB_LOCAL",      "STB_GLOBAL",      "STB_WEAK"};
#line 157 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_bind___0(unsigned int bind ) 
{ 
  char const   *name ;

  {
#line 166
  name = "unknown sym bind name";
#line 167
  if ((unsigned long )bind < sizeof(bind_name___0) / sizeof(bind_name___0[0])) {
#line 168
    name = bind_name___0[bind];
  }
#line 170
  return (name);
}
}
#line 175
static char const   *sym_visibility___0(unsigned int visibility ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *visibility_name___0[4]  = {      "STV_DEFAULT",      "STV_INTERNAL",      "STV_HIDDEN",      "STV_PROTECTED"};
#line 173 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_visibility___0(unsigned int visibility ) 
{ 
  char const   *name ;

  {
#line 183
  name = "unknown sym visibility name";
#line 184
  if ((unsigned long )visibility < sizeof(visibility_name___0) / sizeof(visibility_name___0[0])) {
#line 185
    name = visibility_name___0[visibility];
  }
#line 187
  return (name);
}
}
#line 192
static char const   *rel_type___0(unsigned int type ) ;
#line 192 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *type_name___2[16]  = 
#line 192
  {      "R_X86_64_NONE",      "R_X86_64_64",      "R_X86_64_PC32",      "R_X86_64_GOT32", 
        "R_X86_64_PLT32",      "R_X86_64_COPY",      "R_X86_64_GLOB_DAT",      "R_X86_64_JUMP_SLOT", 
        "R_X86_64_RELATIVE",      "R_X86_64_GOTPCREL",      "R_X86_64_32",      "R_X86_64_32S", 
        "R_X86_64_16",      "R_X86_64_PC16",      "R_X86_64_8",      "R_X86_64_PC8"};
#line 190 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *rel_type___0(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 230
  name = "unknown type rel type name";
#line 231
  if ((unsigned long )type < sizeof(type_name___2) / sizeof(type_name___2[0])) {
#line 231
    if (type_name___2[type]) {
#line 232
      name = type_name___2[type];
    }
  }
#line 234
  return (name);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sec_name___0(unsigned int shndx ) 
{ 
  char const   *sec_strtab ;
  char const   *name ;

  {
#line 241
  sec_strtab = (char const   *)(secs___0 + ehdr___0.e_shstrndx)->strtab;
#line 242
  name = "<noname>";
#line 243
  if (shndx < (unsigned int )ehdr___0.e_shnum) {
#line 244
    name = sec_strtab + (secs___0 + shndx)->shdr.sh_name;
  } else
#line 246
  if (shndx == 65521U) {
#line 247
    name = "ABSOLUTE";
  } else
#line 249
  if (shndx == 65522U) {
#line 250
    name = "COMMON";
  }
#line 252
  return (name);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static char const   *sym_name___0(char const   *sym_strtab , Elf64_Sym *sym ) 
{ 
  char const   *name ;

  {
#line 258
  name = "<noname>";
#line 259
  if (sym->st_name) {
#line 260
    name = sym_strtab + sym->st_name;
  } else {
    {
#line 263
    name = sec_name___0((unsigned int )sym->st_shndx);
    }
  }
#line 265
  return (name);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static Elf64_Sym *sym_lookup___0(char const   *symname ) 
{ 
  int i ;
  struct section___0 *sec ;
  long nsyms ;
  char *strtab ;
  Elf64_Sym *symtab ;
  Elf64_Sym *sym ;
  int tmp ;

  {
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 271
      goto while_break;
    }
#line 272
    sec = secs___0 + i;
#line 278
    if (sec->shdr.sh_type != 2U) {
#line 279
      goto __Cont;
    }
#line 281
    nsyms = (long )(sec->shdr.sh_size / sizeof(Elf64_Sym ));
#line 282
    symtab = sec->symtab;
#line 283
    strtab = (sec->link)->strtab;
#line 285
    sym = symtab;
    {
#line 285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 285
      nsyms --;
#line 285
      if (! (nsyms >= 0L)) {
#line 285
        goto while_break___0;
      }
#line 286
      if (! sym->st_name) {
#line 287
        goto __Cont___0;
      }
      {
#line 288
      tmp = strcmp(symname, (char const   *)(strtab + sym->st_name));
      }
#line 288
      if (tmp == 0) {
#line 289
        return (sym);
      }
      __Cont___0: /* CIL Label */ 
#line 285
      sym ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 271
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return ((Elf64_Sym *)0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static uint16_t elf16_to_cpu___0(uint16_t val ) 
{ 


  {
#line 308
  return (val);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static uint32_t elf32_to_cpu___0(uint32_t val ) 
{ 


  {
#line 313
  return (val);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static uint64_t elf64_to_cpu(uint64_t val ) 
{ 


  {
#line 322
  return (val);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_ehdr___0(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 335
  tmp___1 = fread((void */* __restrict  */)(& ehdr___0), sizeof(ehdr___0), (size_t )1,
                  (FILE */* __restrict  */)fp);
  }
#line 335
  if (tmp___1 != 1UL) {
    {
#line 336
    tmp = __errno_location();
#line 336
    tmp___0 = strerror(*tmp);
#line 336
    die((char *)"Cannot read ELF header: %s\n", tmp___0);
    }
  }
  {
#line 339
  tmp___2 = memcmp((void const   *)(ehdr___0.e_ident), (void const   *)"\177ELF",
                   (size_t )4);
  }
#line 339
  if (tmp___2 != 0) {
    {
#line 340
    die((char *)"No ELF magic\n");
    }
  }
#line 342
  if ((int )ehdr___0.e_ident[4] != 2) {
    {
#line 343
    die((char *)"Not a %d bit executable\n", 64);
    }
  }
#line 345
  if ((int )ehdr___0.e_ident[5] != 1) {
    {
#line 346
    die((char *)"Not a LSB ELF executable\n");
    }
  }
#line 348
  if ((int )ehdr___0.e_ident[6] != 1) {
    {
#line 349
    die((char *)"Unknown ELF version\n");
    }
  }
  {
#line 352
  ehdr___0.e_type = elf16_to_cpu___0(ehdr___0.e_type);
#line 353
  ehdr___0.e_machine = elf16_to_cpu___0(ehdr___0.e_machine);
#line 354
  ehdr___0.e_version = elf32_to_cpu___0(ehdr___0.e_version);
#line 355
  ehdr___0.e_entry = elf64_to_cpu(ehdr___0.e_entry);
#line 356
  ehdr___0.e_phoff = elf64_to_cpu(ehdr___0.e_phoff);
#line 357
  ehdr___0.e_shoff = elf64_to_cpu(ehdr___0.e_shoff);
#line 358
  ehdr___0.e_flags = elf32_to_cpu___0(ehdr___0.e_flags);
#line 359
  ehdr___0.e_ehsize = elf16_to_cpu___0(ehdr___0.e_ehsize);
#line 360
  ehdr___0.e_phentsize = elf16_to_cpu___0(ehdr___0.e_phentsize);
#line 361
  ehdr___0.e_phnum = elf16_to_cpu___0(ehdr___0.e_phnum);
#line 362
  ehdr___0.e_shentsize = elf16_to_cpu___0(ehdr___0.e_shentsize);
#line 363
  ehdr___0.e_shnum = elf16_to_cpu___0(ehdr___0.e_shnum);
#line 364
  ehdr___0.e_shstrndx = elf16_to_cpu___0(ehdr___0.e_shstrndx);
  }
#line 366
  if ((int )ehdr___0.e_type != 2) {
#line 366
    if ((int )ehdr___0.e_type != 3) {
      {
#line 367
      die((char *)"Unsupported ELF header type\n");
      }
    }
  }
#line 369
  if ((int )ehdr___0.e_machine != 62) {
    {
#line 370
    die((char *)"Not for %s\n", "x86_64");
    }
  }
#line 372
  if (ehdr___0.e_version != 1U) {
    {
#line 373
    die((char *)"Unknown ELF version\n");
    }
  }
#line 375
  if ((unsigned long )ehdr___0.e_ehsize != sizeof(Elf64_Ehdr )) {
    {
#line 376
    die((char *)"Bad Elf header size\n");
    }
  }
#line 378
  if ((unsigned long )ehdr___0.e_phentsize != sizeof(Elf64_Phdr )) {
    {
#line 379
    die((char *)"Bad program header entry\n");
    }
  }
#line 381
  if ((unsigned long )ehdr___0.e_shentsize != sizeof(Elf64_Shdr )) {
    {
#line 382
    die((char *)"Bad section header entry\n");
    }
  }
#line 384
  if ((int )ehdr___0.e_shstrndx >= (int )ehdr___0.e_shnum) {
    {
#line 385
    die((char *)"String table index out of bounds\n");
    }
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_shdrs___0(FILE *fp ) 
{ 
  int i ;
  Elf64_Shdr shdr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct section___0 *sec ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 394
  tmp = calloc((size_t )ehdr___0.e_shnum, sizeof(struct section___0 ));
#line 394
  secs___0 = (struct section___0 *)tmp;
  }
#line 395
  if (! secs___0) {
    {
#line 396
    die((char *)"Unable to allocate %d section headers\n", (int )ehdr___0.e_shnum);
    }
  }
  {
#line 399
  tmp___2 = fseek(fp, (long )ehdr___0.e_shoff, 0);
  }
#line 399
  if (tmp___2 < 0) {
    {
#line 400
    tmp___0 = __errno_location();
#line 400
    tmp___1 = strerror(*tmp___0);
#line 400
    die((char *)"Seek to %d failed: %s\n", ehdr___0.e_shoff, tmp___1);
    }
  }
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 403
      goto while_break;
    }
    {
#line 404
    sec = secs___0 + i;
#line 405
    tmp___5 = fread((void */* __restrict  */)(& shdr), sizeof(shdr), (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 405
    if (tmp___5 != 1UL) {
      {
#line 406
      tmp___3 = __errno_location();
#line 406
      tmp___4 = strerror(*tmp___3);
#line 406
      die((char *)"Cannot read ELF section headers %d/%d: %s\n", i, (int )ehdr___0.e_shnum,
          tmp___4);
      }
    }
    {
#line 408
    sec->shdr.sh_name = elf32_to_cpu___0(shdr.sh_name);
#line 409
    sec->shdr.sh_type = elf32_to_cpu___0(shdr.sh_type);
#line 410
    sec->shdr.sh_flags = elf64_to_cpu(shdr.sh_flags);
#line 411
    sec->shdr.sh_addr = elf64_to_cpu(shdr.sh_addr);
#line 412
    sec->shdr.sh_offset = elf64_to_cpu(shdr.sh_offset);
#line 413
    sec->shdr.sh_size = elf64_to_cpu(shdr.sh_size);
#line 414
    sec->shdr.sh_link = elf32_to_cpu___0(shdr.sh_link);
#line 415
    sec->shdr.sh_info = elf32_to_cpu___0(shdr.sh_info);
#line 416
    sec->shdr.sh_addralign = elf64_to_cpu(shdr.sh_addralign);
#line 417
    sec->shdr.sh_entsize = elf64_to_cpu(shdr.sh_entsize);
    }
#line 418
    if (sec->shdr.sh_link < (Elf32_Word )ehdr___0.e_shnum) {
#line 419
      sec->link = secs___0 + sec->shdr.sh_link;
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_strtabs___0(FILE *fp ) 
{ 
  int i ;
  struct section___0 *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 427
  i = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 427
      goto while_break;
    }
#line 428
    sec = secs___0 + i;
#line 429
    if (sec->shdr.sh_type != 3U) {
#line 430
      goto __Cont;
    }
    {
#line 432
    tmp = malloc(sec->shdr.sh_size);
#line 432
    sec->strtab = (char *)tmp;
    }
#line 433
    if (! sec->strtab) {
      {
#line 434
      die((char *)"malloc of %d bytes for strtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 437
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 437
    if (tmp___2 < 0) {
      {
#line 438
      tmp___0 = __errno_location();
#line 438
      tmp___1 = strerror(*tmp___0);
#line 438
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 441
    tmp___5 = fread((void */* __restrict  */)sec->strtab, (size_t )1, sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 441
    if (tmp___5 != sec->shdr.sh_size) {
      {
#line 443
      tmp___3 = __errno_location();
#line 443
      tmp___4 = strerror(*tmp___3);
#line 443
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
    __Cont: /* CIL Label */ 
#line 427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_symtabs___0(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section___0 *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf64_Sym *sym ;

  {
#line 452
  i = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 452
      goto while_break;
    }
#line 453
    sec = secs___0 + i;
#line 454
    if (sec->shdr.sh_type != 2U) {
#line 455
      goto __Cont;
    }
    {
#line 457
    tmp = malloc(sec->shdr.sh_size);
#line 457
    sec->symtab = (Elf64_Sym *)tmp;
    }
#line 458
    if (! sec->symtab) {
      {
#line 459
      die((char *)"malloc of %d bytes for symtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 462
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 462
    if (tmp___2 < 0) {
      {
#line 463
      tmp___0 = __errno_location();
#line 463
      tmp___1 = strerror(*tmp___0);
#line 463
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 466
    tmp___5 = fread((void */* __restrict  */)sec->symtab, (size_t )1, sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 466
    if (tmp___5 != sec->shdr.sh_size) {
      {
#line 468
      tmp___3 = __errno_location();
#line 468
      tmp___4 = strerror(*tmp___3);
#line 468
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 471
    j = 0;
    {
#line 471
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 471
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Sym ))) {
#line 471
        goto while_break___0;
      }
      {
#line 472
      sym = sec->symtab + j;
#line 473
      sym->st_name = elf32_to_cpu___0(sym->st_name);
#line 474
      sym->st_value = elf64_to_cpu(sym->st_value);
#line 475
      sym->st_size = elf64_to_cpu(sym->st_size);
#line 476
      sym->st_shndx = elf16_to_cpu___0(sym->st_shndx);
#line 471
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 452
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void read_relocs___0(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section___0 *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf64_Rela *rel ;
  uint64_t tmp___6 ;

  {
#line 485
  i = 0;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 485
      goto while_break;
    }
#line 486
    sec = secs___0 + i;
#line 487
    if (sec->shdr.sh_type != 4U) {
#line 488
      goto __Cont;
    }
    {
#line 490
    tmp = malloc(sec->shdr.sh_size);
#line 490
    sec->reltab = (Elf64_Rela *)tmp;
    }
#line 491
    if (! sec->reltab) {
      {
#line 492
      die((char *)"malloc of %d bytes for relocs failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 495
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 495
    if (tmp___2 < 0) {
      {
#line 496
      tmp___0 = __errno_location();
#line 496
      tmp___1 = strerror(*tmp___0);
#line 496
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 499
    tmp___5 = fread((void */* __restrict  */)sec->reltab, (size_t )1, sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 499
    if (tmp___5 != sec->shdr.sh_size) {
      {
#line 501
      tmp___3 = __errno_location();
#line 501
      tmp___4 = strerror(*tmp___3);
#line 501
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 504
    j = 0;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Rela ))) {
#line 504
        goto while_break___0;
      }
      {
#line 505
      rel = sec->reltab + j;
#line 506
      rel->r_offset = elf64_to_cpu(rel->r_offset);
#line 507
      rel->r_info = elf64_to_cpu(rel->r_info);
#line 509
      tmp___6 = elf64_to_cpu((uint64_t )rel->r_addend);
#line 509
      rel->r_addend = (Elf64_Sxword )tmp___6;
#line 504
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void print_absolute_symbols___0(void) 
{ 
  int i ;
  char const   *format ;
  struct section___0 *sec ;
  char *sym_strtab ;
  int j ;
  Elf64_Sym *sym ;
  char const   *name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 522
  format = "%5d %016lx %5ld %10s %10s %12s %s\n";
#line 526
  printf((char const   */* __restrict  */)"Absolute symbols\n");
#line 527
  printf((char const   */* __restrict  */)" Num:    Value Size  Type       Bind        Visibility  Name\n");
#line 528
  i = 0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 528
      goto while_break;
    }
#line 529
    sec = secs___0 + i;
#line 533
    if (sec->shdr.sh_type != 2U) {
#line 534
      goto __Cont;
    }
#line 536
    sym_strtab = (sec->link)->strtab;
#line 537
    j = 0;
    {
#line 537
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Sym ))) {
#line 537
        goto while_break___0;
      }
      {
#line 540
      sym = sec->symtab + j;
#line 541
      name = sym_name___0((char const   *)sym_strtab, sym);
      }
#line 542
      if ((int )sym->st_shndx != 65521) {
#line 543
        goto __Cont___0;
      }
      {
#line 545
      tmp = sym_visibility___0((unsigned int )((int )sym->st_other & 3));
#line 545
      tmp___0 = sym_bind___0((unsigned int )((int )sym->st_info >> 4));
#line 545
      tmp___1 = sym_type___0((unsigned int )((int )sym->st_info & 15));
#line 545
      printf((char const   */* __restrict  */)format, j, sym->st_value, sym->st_size,
             tmp___1, tmp___0, tmp, name);
      }
      __Cont___0: /* CIL Label */ 
#line 537
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  printf((char const   */* __restrict  */)"\n");
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void print_absolute_relocs___0(void) 
{ 
  int i ;
  int printed ;
  char const   *format ;
  struct section___0 *sec ;
  struct section___0 *sec_applies ;
  struct section___0 *sec_symtab ;
  char *sym_strtab ;
  Elf64_Sym *sh_symtab ;
  int j ;
  Elf64_Rela *rel ;
  Elf64_Sym *sym ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 558
  printed = 0;
#line 562
  format = "%016lx %016lx %10s %016lx  %s\n";
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 566
      goto while_break;
    }
#line 567
    sec = secs___0 + i;
#line 572
    if (sec->shdr.sh_type != 4U) {
#line 573
      goto __Cont;
    }
#line 575
    sec_symtab = sec->link;
#line 576
    sec_applies = secs___0 + sec->shdr.sh_info;
#line 577
    if (! (sec_applies->shdr.sh_flags & (unsigned long )(1 << 1))) {
#line 578
      goto __Cont;
    }
#line 580
    sh_symtab = sec_symtab->symtab;
#line 581
    sym_strtab = (sec_symtab->link)->strtab;
#line 582
    j = 0;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Rela ))) {
#line 582
        goto while_break___0;
      }
      {
#line 586
      rel = sec->reltab + j;
#line 587
      sym = sh_symtab + (rel->r_info >> 32);
#line 588
      name = sym_name___0((char const   *)sym_strtab, sym);
      }
#line 589
      if ((int )sym->st_shndx != 65521) {
#line 590
        goto __Cont___0;
      }
      {
#line 606
      tmp = is_reloc___0((enum symtype )0, name);
      }
#line 606
      if (tmp) {
#line 607
        goto __Cont___0;
      } else {
        {
#line 606
        tmp___0 = is_reloc___0((enum symtype )1, name);
        }
#line 606
        if (tmp___0) {
#line 607
          goto __Cont___0;
        }
      }
#line 609
      if (! printed) {
        {
#line 610
        printf((char const   */* __restrict  */)"WARNING: Absolute relocations present\n");
#line 612
        printf((char const   */* __restrict  */)"Offset     Info     Type     Sym.Value Sym.Name\n");
#line 614
        printed = 1;
        }
      }
      {
#line 617
      tmp___1 = rel_type___0((unsigned int )(rel->r_info & 4294967295UL));
#line 617
      printf((char const   */* __restrict  */)format, rel->r_offset, rel->r_info,
             tmp___1, sym->st_value, name);
      }
      __Cont___0: /* CIL Label */ 
#line 582
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  if (printed) {
    {
#line 627
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 628
  return;
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void add_reloc___0(struct relocs *r , uint32_t offset ) 
{ 
  unsigned long newsize ;
  void *mem ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 632
  if (r->count == r->size) {
    {
#line 633
    newsize = r->size + 50000UL;
#line 634
    tmp = realloc((void *)r->offset, newsize * sizeof(*(r->offset + 0)));
#line 634
    mem = tmp;
    }
#line 636
    if (! mem) {
      {
#line 637
      die((char *)"realloc of %ld entries for relocs failed\n", newsize);
      }
    }
#line 639
    r->offset = (uint32_t *)mem;
#line 640
    r->size = newsize;
  }
#line 642
  tmp___0 = r->count;
#line 642
  (r->count) ++;
#line 642
  *(r->offset + tmp___0) = offset;
#line 643
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void walk_relocs___0(int (*process)(struct section___0 *sec , Elf64_Rela *rel ,
                                           Elf64_Sym *sym , char const   *symname ) ) 
{ 
  int i ;
  char *sym_strtab ;
  Elf64_Sym *sh_symtab ;
  struct section___0 *sec_applies ;
  struct section___0 *sec_symtab ;
  int j ;
  struct section___0 *sec ;
  Elf64_Rela *rel ;
  Elf64_Sym *sym ;
  char const   *symname ;
  char const   *tmp ;

  {
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 650
      goto while_break;
    }
#line 655
    sec = secs___0 + i;
#line 657
    if (sec->shdr.sh_type != 4U) {
#line 658
      goto __Cont;
    }
#line 660
    sec_symtab = sec->link;
#line 661
    sec_applies = secs___0 + sec->shdr.sh_info;
#line 662
    if (! (sec_applies->shdr.sh_flags & (unsigned long )(1 << 1))) {
#line 663
      goto __Cont;
    }
#line 665
    sh_symtab = sec_symtab->symtab;
#line 666
    sym_strtab = (sec_symtab->link)->strtab;
#line 667
    j = 0;
    {
#line 667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 667
      if (! ((Elf64_Xword )j < sec->shdr.sh_size / sizeof(Elf64_Rela ))) {
#line 667
        goto while_break___0;
      }
      {
#line 668
      rel = sec->reltab + j;
#line 669
      sym = sh_symtab + (rel->r_info >> 32);
#line 670
      tmp = sym_name___0((char const   *)sym_strtab, sym);
#line 670
      symname = tmp;
#line 672
      (*process)(sec, rel, sym, symname);
#line 667
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int per_cpu_shndx  =    -1;
#line 701 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static Elf64_Addr per_cpu_load_addr  ;
#line 703 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void percpu_init(void) 
{ 
  int i ;
  Elf64_Sym *sym ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 706
  i = 0;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! (i < (int )ehdr___0.e_shnum)) {
#line 706
      goto while_break;
    }
    {
#line 708
    tmp = sec_name___0((unsigned int )i);
#line 708
    tmp___0 = strcmp(tmp, ".data..percpu");
    }
#line 708
    if (tmp___0) {
#line 709
      goto __Cont;
    }
#line 711
    if ((secs___0 + i)->shdr.sh_addr != 0UL) {
#line 712
      return;
    }
    {
#line 714
    sym = sym_lookup___0("__per_cpu_load");
    }
#line 715
    if (! sym) {
      {
#line 716
      die((char *)"can\'t find __per_cpu_load\n");
      }
    }
#line 718
    per_cpu_shndx = i;
#line 719
    per_cpu_load_addr = sym->st_value;
#line 720
    return;
    __Cont: /* CIL Label */ 
#line 706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int is_percpu_sym(Elf64_Sym *sym , char const   *symname ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 743
  if ((int )sym->st_shndx == per_cpu_shndx) {
    {
#line 743
    tmp = strcmp(symname, "__init_begin");
    }
#line 743
    if (tmp) {
      {
#line 743
      tmp___0 = strcmp(symname, "__per_cpu_load");
      }
#line 743
      if (tmp___0) {
        {
#line 743
        tmp___1 = strncmp(symname, "init_per_cpu_", (size_t )13);
        }
#line 743
        if (tmp___1) {
#line 743
          tmp___2 = 1;
        } else {
#line 743
          tmp___2 = 0;
        }
      } else {
#line 743
        tmp___2 = 0;
      }
    } else {
#line 743
      tmp___2 = 0;
    }
  } else {
#line 743
    tmp___2 = 0;
  }
#line 743
  return (tmp___2);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int do_reloc64(struct section___0 *sec , Elf64_Rela *rel , Elf64_Sym *sym ,
                      char const   *symname ) 
{ 
  unsigned int r_type ;
  Elf64_Addr offset ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 753
  r_type = (unsigned int )(rel->r_info & 4294967295UL);
#line 754
  offset = rel->r_offset;
#line 755
  if ((int )sym->st_shndx == 65521) {
    {
#line 755
    tmp = is_reloc___0((enum symtype )1, symname);
    }
#line 755
    if (tmp) {
#line 755
      tmp___0 = 0;
    } else {
#line 755
      tmp___0 = 1;
    }
  } else {
#line 755
    tmp___0 = 0;
  }
#line 755
  shn_abs = tmp___0;
#line 757
  if ((int )sym->st_shndx == 0) {
#line 758
    return (0);
  }
#line 763
  if (sec->shdr.sh_info == (Elf32_Word )per_cpu_shndx) {
#line 764
    offset += per_cpu_load_addr;
  }
  {
#line 767
  if (r_type == 0U) {
#line 767
    goto case_0;
  }
#line 771
  if (r_type == 2U) {
#line 771
    goto case_2;
  }
#line 782
  if (r_type == 1U) {
#line 782
    goto case_1;
  }
#line 782
  if (r_type == 11U) {
#line 782
    goto case_1;
  }
#line 782
  if (r_type == 10U) {
#line 782
    goto case_1;
  }
#line 817
  goto switch_default;
  case_0: /* CIL Label */ 
#line 769
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 776
  tmp___1 = is_percpu_sym(sym, symname);
  }
#line 776
  if (tmp___1) {
    {
#line 777
    add_reloc___0(& relocs32neg, (uint32_t )offset);
    }
  }
#line 778
  goto switch_break;
  case_1: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 786
  tmp___2 = is_percpu_sym(sym, symname);
  }
#line 786
  if (tmp___2) {
#line 787
    goto switch_break;
  }
#line 789
  if (shn_abs) {
    {
#line 794
    tmp___3 = is_reloc___0((enum symtype )0, symname);
    }
#line 794
    if (tmp___3) {
#line 795
      goto switch_break;
    }
    {
#line 797
    tmp___4 = rel_type___0(r_type);
#line 797
    die((char *)"Invalid absolute %s relocation: %s\n", tmp___4, symname);
    }
#line 799
    goto switch_break;
  }
#line 808
  if ((int64_t )((int32_t )offset) != (int64_t )offset) {
    {
#line 809
    die((char *)"Relocation offset doesn\'t fit in 32 bits\n");
    }
  }
#line 811
  if (r_type == 1U) {
    {
#line 812
    add_reloc___0(& relocs64, (uint32_t )offset);
    }
  } else {
    {
#line 814
    add_reloc___0(& relocs32___0, (uint32_t )offset);
    }
  }
#line 815
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 818
  tmp___5 = rel_type___0(r_type);
#line 818
  die((char *)"Unsupported relocation type: %s (%d)\n", tmp___5, r_type);
  }
#line 820
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 823
  return (0);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int cmp_relocs___0(void const   *va , void const   *vb ) 
{ 
  uint32_t const   *a ;
  uint32_t const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 947
  a = (uint32_t const   *)va;
#line 947
  b = (uint32_t const   *)vb;
#line 948
  if (*a == *b) {
#line 948
    tmp___0 = 0;
  } else {
#line 948
    if (*a > *b) {
#line 948
      tmp = 1;
    } else {
#line 948
      tmp = -1;
    }
#line 948
    tmp___0 = tmp;
  }
#line 948
  return (tmp___0);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void sort_relocs___0(struct relocs *r ) 
{ 


  {
  {
#line 953
  qsort((void *)r->offset, r->count, sizeof(*(r->offset + 0)), & cmp_relocs___0);
  }
#line 954
  return;
}
}
#line 956 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int write32___0(uint32_t v , FILE *f ) 
{ 
  unsigned char buf[4] ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 960
  put_unaligned_le32(v, (void *)(buf));
#line 961
  tmp___1 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)f);
  }
#line 961
  if (tmp___1 == 4UL) {
#line 961
    tmp___0 = 0;
  } else {
#line 961
    tmp___0 = -1;
  }
#line 961
  return (tmp___0);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int write32_as_text___0(uint32_t v , FILE *f ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 966
  tmp___1 = fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\t.long 0x%08x\n",
                    v);
  }
#line 966
  if (tmp___1 > 0) {
#line 966
    tmp___0 = 0;
  } else {
#line 966
    tmp___0 = -1;
  }
#line 966
  return (tmp___0);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void emit_relocs___0(int as_text , int use_real_mode ) 
{ 
  int i ;
  int (*write_reloc)(uint32_t  , FILE * ) ;
  int (*do_reloc)(struct section___0 *sec , Elf64_Rela *rel , Elf64_Sym *sym , char const   *symname ) ;

  {
#line 972
  write_reloc = & write32___0;
#line 977
  if (! use_real_mode) {
#line 978
    do_reloc = & do_reloc64;
  } else {
    {
#line 980
    die((char *)"--realmode not valid for a 64-bit ELF file");
    }
  }
  {
#line 989
  walk_relocs___0(do_reloc);
  }
#line 991
  if (relocs16___0.count) {
#line 991
    if (! use_real_mode) {
      {
#line 992
      die((char *)"Segment relocations found but --realmode not specified\n");
      }
    }
  }
  {
#line 995
  sort_relocs___0(& relocs16___0);
#line 996
  sort_relocs___0(& relocs32___0);
#line 998
  sort_relocs___0(& relocs32neg);
#line 999
  sort_relocs___0(& relocs64);
  }
#line 1003
  if (as_text) {
    {
#line 1007
    printf((char const   */* __restrict  */)".section \".data.reloc\",\"a\"\n");
#line 1008
    printf((char const   */* __restrict  */)".balign 4\n");
#line 1009
    write_reloc = & write32_as_text___0;
    }
  }
#line 1012
  if (use_real_mode) {
    {
#line 1013
    (*write_reloc)((uint32_t )relocs16___0.count, stdout);
#line 1014
    i = 0;
    }
    {
#line 1014
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1014
      if (! ((unsigned long )i < relocs16___0.count)) {
#line 1014
        goto while_break;
      }
      {
#line 1015
      (*write_reloc)(*(relocs16___0.offset + i), stdout);
#line 1014
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1017
    (*write_reloc)((uint32_t )relocs32___0.count, stdout);
#line 1018
    i = 0;
    }
    {
#line 1018
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1018
      if (! ((unsigned long )i < relocs32___0.count)) {
#line 1018
        goto while_break___0;
      }
      {
#line 1019
      (*write_reloc)(*(relocs32___0.offset + i), stdout);
#line 1018
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1023
    (*write_reloc)((uint32_t )0, stdout);
#line 1026
    i = 0;
    }
    {
#line 1026
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1026
      if (! ((unsigned long )i < relocs64.count)) {
#line 1026
        goto while_break___1;
      }
      {
#line 1027
      (*write_reloc)(*(relocs64.offset + i), stdout);
#line 1026
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1030
    (*write_reloc)((uint32_t )0, stdout);
#line 1033
    i = 0;
    }
    {
#line 1033
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1033
      if (! ((unsigned long )i < relocs32neg.count)) {
#line 1033
        goto while_break___2;
      }
      {
#line 1034
      (*write_reloc)(*(relocs32neg.offset + i), stdout);
#line 1033
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1038
    (*write_reloc)((uint32_t )0, stdout);
#line 1041
    i = 0;
    }
    {
#line 1041
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1041
      if (! ((unsigned long )i < relocs32___0.count)) {
#line 1041
        goto while_break___3;
      }
      {
#line 1042
      (*write_reloc)(*(relocs32___0.offset + i), stdout);
#line 1041
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1044
  return;
}
}
#line 1052 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static int do_reloc_info___0(struct section___0 *sec , Elf64_Rela *rel , Elf64_Sym *sym ,
                             char const   *symname ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1055
  tmp = sec_name___0((unsigned int )sym->st_shndx);
#line 1055
  tmp___0 = rel_type___0((unsigned int )(rel->r_info & 4294967295UL));
#line 1055
  tmp___1 = sec_name___0(sec->shdr.sh_info);
#line 1055
  printf((char const   */* __restrict  */)"%s\t%s\t%s\t%s\n", tmp___1, tmp___0, symname,
         tmp);
  }
#line 1060
  return (0);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
static void print_reloc_info___0(void) 
{ 


  {
  {
#line 1065
  printf((char const   */* __restrict  */)"reloc section\treloc type\tsymbol\tsymbol section\n");
#line 1066
  walk_relocs___0(& do_reloc_info___0);
  }
#line 1067
  return;
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/linux-lts-wily-4.2.0/arch/x86/tools/relocs.c"
void process_64(FILE *fp , int use_real_mode , int as_text , int show_absolute_syms ,
                int show_absolute_relocs , int show_reloc_info ) 
{ 


  {
  {
#line 1079
  regex_init___0(use_real_mode);
#line 1080
  read_ehdr___0(fp);
#line 1081
  read_shdrs___0(fp);
#line 1082
  read_strtabs___0(fp);
#line 1083
  read_symtabs___0(fp);
#line 1084
  read_relocs___0(fp);
#line 1086
  percpu_init();
  }
#line 1087
  if (show_absolute_syms) {
    {
#line 1088
    print_absolute_symbols___0();
    }
#line 1089
    return;
  }
#line 1091
  if (show_absolute_relocs) {
    {
#line 1092
    print_absolute_relocs___0();
    }
#line 1093
    return;
  }
#line 1095
  if (show_reloc_info) {
    {
#line 1096
    print_reloc_info___0();
    }
#line 1097
    return;
  }
  {
#line 1099
  emit_relocs___0(as_text, use_real_mode);
  }
#line 1100
  return;
}
}
