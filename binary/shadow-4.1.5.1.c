/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __gid_t gid_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_21 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_22 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_21 __wait_terminated ;
   struct __anonstruct___wait_stopped_22 __wait_stopped ;
};
#line 86 "../lib/prototypes.h"
typedef void (*cleanup_function)(void *arg );
#line 42 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
typedef void *parg_t;
#line 92 "../lib/prototypes.h"
struct cleanup_info_mod {
   char *audit_msg ;
   char *action ;
   char const   *name ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_56 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_56 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 43 "/usr/include/utmpx.h"
struct utmp;
#line 45 "../lib/faillog.h"
struct faillog {
   short fail_cnt ;
   short fail_max ;
   char fail_line[12] ;
   time_t fail_time ;
   long fail_locktime ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_56___0 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_56___0 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __dev_t dev_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __ino_t ino_t;
#line 68 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __nlink_t nlink_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
struct link_name {
   dev_t ln_dev ;
   ino_t ln_ino ;
   nlink_t ln_count ;
   char *ln_name ;
   struct link_name *ln_next ;
};
#line 46 "../lib/commonio.h"
struct commonio_entry {
   char *line ;
   void *eptr ;
   struct commonio_entry *prev ;
   struct commonio_entry *next ;
   _Bool changed : 1 ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 43 "../lib/gshadow_.h"
struct sgrp {
   char *sg_name ;
   char *sg_passwd ;
   char **sg_adm ;
   char **sg_mem ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct lastlog {
   int32_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 315 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 326 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 326 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 209 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 162 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/prototypes.h"
int get_pid(char const   *pidstr , pid_t *pid ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/get_pid.c"
int get_pid(char const   *pidstr , pid_t *pid ) 
{ 
  long long val ;
  char *endptr ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 42
  tmp = __errno_location();
#line 42
  *tmp = 0;
#line 43
  val = strtoll((char const   */* __restrict  */)pidstr, (char **/* __restrict  */)(& endptr),
                10);
  }
#line 44
  if (0 == (int )*pidstr) {
#line 48
    return (0);
  } else
#line 44
  if (0 != (int )*endptr) {
#line 48
    return (0);
  } else {
    {
#line 44
    tmp___0 = __errno_location();
    }
#line 44
    if (34 == *tmp___0) {
#line 48
      return (0);
    } else
#line 44
    if (val != (long long )((pid_t )val)) {
#line 48
      return (0);
    }
  }
#line 51
  *pid = (pid_t )val;
#line 52
  return (1);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 41 "../lib/getdef.h"
extern char const   *getdef_str(char const   * ) ;
#line 117 "../lib/prototypes.h"
_Bool console(char const   *tty ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
_Bool console(char const   *tty ) 
{ 
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 127
  tmp = strncmp(tty, "/dev/", (size_t )5);
  }
#line 127
  if (tmp == 0) {
#line 128
    tty += 5;
  }
  {
#line 131
  tmp___0 = is_listed("CONSOLE", tty, (_Bool)1);
  }
#line 131
  return (tmp___0);
}
}
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 64 "../lib/prototypes.h"
int add_groups(char const   *list___30 ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/addgrps.c"
int add_groups(char const   *list___30 ) 
{ 
  gid_t *grouplist___0 ;
  gid_t *tmp ;
  size_t i ;
  int ngroups___0 ;
  _Bool added ;
  char *token ;
  char buf___0[1024] ;
  int *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  struct group *grp ;
  char *tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 61
  tmp___1 = strlen(list___30);
  }
#line 61
  if (tmp___1 >= sizeof(buf___0)) {
    {
#line 62
    tmp___0 = __errno_location();
#line 62
    *tmp___0 = 22;
    }
#line 63
    return (-1);
  }
  {
#line 65
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)list___30);
#line 67
  i = (size_t )16;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp___2 = malloc(i * sizeof(gid_t ));
#line 69
    grouplist___0 = (gid_t *)tmp___2;
    }
#line 70
    if ((unsigned long )((void *)0) == (unsigned long )grouplist___0) {
#line 71
      return (-1);
    }
    {
#line 73
    ngroups___0 = getgroups((int )i, grouplist___0);
    }
#line 74
    if (-1 == ngroups___0) {
      {
#line 74
      tmp___3 = __errno_location();
      }
#line 74
      if (22 != *tmp___3) {
#line 79
        goto while_break;
      } else {
#line 74
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 74
    if (i > (size_t )ngroups___0) {
#line 79
      goto while_break;
    }
    {
#line 82
    free((void *)grouplist___0);
#line 83
    i *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (ngroups___0 < 0) {
    {
#line 86
    free((void *)grouplist___0);
    }
#line 87
    return (-1);
  }
  {
#line 90
  added = (_Bool)0;
#line 91
  token = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)",:");
  }
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )((void *)0) != (unsigned long )token)) {
#line 91
      goto while_break___0;
    }
    {
#line 94
    grp = getgrnam((char const   *)token);
    }
#line 95
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
      {
#line 96
      tmp___4 = gettext("Warning: unknown group %s\n");
#line 96
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              token);
      }
#line 98
      goto __Cont;
    }
#line 101
    i = (size_t )0;
    {
#line 101
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 101
      if (i < (size_t )ngroups___0) {
#line 101
        if (! (*(grouplist___0 + i) != grp->gr_gid)) {
#line 101
          goto while_break___1;
        }
      } else {
#line 101
        goto while_break___1;
      }
#line 101
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 103
    if (i < (size_t )ngroups___0) {
#line 104
      goto __Cont;
    }
    {
#line 107
    tmp___6 = sysconf(3);
    }
#line 107
    if ((long )ngroups___0 >= tmp___6) {
      {
#line 108
      tmp___5 = gettext("Warning: too many groups\n");
#line 108
      fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stderr);
      }
#line 109
      goto while_break___0;
    }
    {
#line 111
    tmp___7 = realloc((void *)grouplist___0, (size_t )(ngroups___0 + 1) * sizeof(gid_t ));
#line 111
    tmp = (gid_t *)tmp___7;
    }
#line 112
    if ((unsigned long )((void *)0) == (unsigned long )tmp) {
      {
#line 113
      free((void *)grouplist___0);
      }
#line 114
      return (-1);
    }
#line 116
    *(tmp + ngroups___0) = grp->gr_gid;
#line 117
    ngroups___0 ++;
#line 118
    grouplist___0 = tmp;
#line 119
    added = (_Bool)1;
    __Cont: /* CIL Label */ 
    {
#line 91
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",:");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  if (added) {
    {
#line 123
    tmp___8 = setgroups((size_t )ngroups___0, (__gid_t const   *)grouplist___0);
    }
#line 123
    return (tmp___8);
  }
#line 126
  return (0);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 483
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                             __uid_t __owner ,
                                                                                             __gid_t __group ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 78 "../lib/prototypes.h"
int chown_tree(char const   *root , uid_t old_uid , uid_t new_uid , gid_t old_gid ,
               gid_t new_gid ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chowndir.c"
int chown_tree(char const   *root , uid_t old_uid , uid_t new_uid , gid_t old_gid ,
               gid_t new_gid ) 
{ 
  char *new_name ;
  size_t new_name_len ;
  int rc ;
  struct dirent *ent ;
  struct stat sb ;
  DIR *dir ;
  void *tmp ;
  int tmp___0 ;
  size_t ent_name_len ;
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  uid_t tmpuid___0 ;
  gid_t tmpgid___0 ;
  int tmp___8 ;

  {
  {
#line 64
  rc = 0;
#line 69
  tmp = malloc((size_t )1024);
#line 69
  new_name = (char *)tmp;
  }
#line 70
  if ((unsigned long )((void *)0) == (unsigned long )new_name) {
#line 71
    return (-1);
  }
  {
#line 73
  new_name_len = (size_t )1024;
#line 80
  tmp___0 = access(root, 0);
  }
#line 80
  if (tmp___0 != 0) {
    {
#line 81
    free((void *)new_name);
    }
#line 82
    return (-1);
  }
  {
#line 92
  dir = opendir(root);
  }
#line 93
  if ((unsigned long )((void *)0) == (unsigned long )dir) {
    {
#line 94
    free((void *)new_name);
    }
#line 95
    return (-1);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    ent = readdir(dir);
    }
#line 98
    if (! ent) {
#line 98
      goto while_break;
    }
    {
#line 100
    tmpuid = (uid_t )-1;
#line 101
    tmpgid = (gid_t )-1;
#line 107
    tmp___1 = strcmp((char const   *)(ent->d_name), ".");
    }
#line 107
    if (tmp___1 == 0) {
#line 109
      goto while_continue;
    } else {
      {
#line 107
      tmp___2 = strcmp((char const   *)(ent->d_name), "..");
      }
#line 107
      if (tmp___2 == 0) {
#line 109
        goto while_continue;
      }
    }
    {
#line 117
    tmp___3 = strlen(root);
#line 117
    tmp___4 = strlen((char const   *)(ent->d_name));
#line 117
    ent_name_len = (tmp___3 + tmp___4) + 2UL;
    }
#line 118
    if (ent_name_len > new_name_len) {
      {
#line 119
      tmp___6 = realloc((void *)new_name, ent_name_len);
#line 119
      tmp___5 = (char *)tmp___6;
      }
#line 120
      if ((unsigned long )((void *)0) == (unsigned long )tmp___5) {
#line 121
        rc = -1;
#line 122
        goto while_break;
      }
#line 124
      new_name = tmp___5;
#line 125
      new_name_len = ent_name_len;
    }
    {
#line 128
    snprintf((char */* __restrict  */)new_name, new_name_len, (char const   */* __restrict  */)"%s/%s",
             root, ent->d_name);
#line 131
    tmp___7 = lstat((char const   */* __restrict  */)new_name, (struct stat */* __restrict  */)(& sb));
    }
#line 131
    if (tmp___7 == -1) {
#line 132
      goto while_continue;
    }
#line 135
    if ((sb.st_mode & 61440U) == 16384U) {
#line 135
      if (! ((sb.st_mode & 61440U) == 40960U)) {
        {
#line 141
        rc = chown_tree((char const   *)new_name, old_uid, new_uid, old_gid, new_gid);
        }
#line 143
        if (0 != rc) {
#line 144
          goto while_break;
        }
      }
    }
#line 162
    if (4294967295U == old_uid) {
#line 163
      tmpuid = new_uid;
    } else
#line 162
    if (sb.st_uid == old_uid) {
#line 163
      tmpuid = new_uid;
    }
#line 165
    if (4294967295U == old_gid) {
#line 166
      tmpgid = new_gid;
    } else
#line 165
    if (sb.st_gid == old_gid) {
#line 166
      tmpgid = new_gid;
    }
#line 168
    if (4294967295U != tmpuid) {
#line 168
      goto _L;
    } else
#line 168
    if (4294967295U != tmpgid) {
      _L: /* CIL Label */ 
      {
#line 169
      rc = lchown((char const   *)new_name, tmpuid, tmpgid);
      }
#line 170
      if (0 != rc) {
#line 171
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  free((void *)new_name);
#line 177
  closedir(dir);
  }
#line 183
  if (0 == rc) {
    {
#line 183
    tmp___8 = stat((char const   */* __restrict  */)root, (struct stat */* __restrict  */)(& sb));
    }
#line 183
    if (tmp___8 == 0) {
#line 184
      tmpuid___0 = (uid_t )-1;
#line 185
      tmpgid___0 = (gid_t )-1;
#line 186
      if (4294967295U == old_uid) {
#line 187
        tmpuid___0 = new_uid;
      } else
#line 186
      if (sb.st_uid == old_uid) {
#line 187
        tmpuid___0 = new_uid;
      }
#line 189
      if (4294967295U == old_gid) {
#line 190
        tmpgid___0 = new_gid;
      } else
#line 189
      if (sb.st_gid == old_gid) {
#line 190
        tmpgid___0 = new_gid;
      }
#line 192
      if (4294967295U != tmpuid___0) {
        {
#line 193
        rc = lchown(root, tmpuid___0, tmpgid___0);
        }
      } else
#line 192
      if (4294967295U != tmpgid___0) {
        {
#line 193
        rc = lchown(root, tmpuid___0, tmpgid___0);
        }
      }
    } else {
#line 196
      rc = -1;
    }
  } else {
#line 196
    rc = -1;
  }
#line 199
  return (rc);
}
}
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 478 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 83 "../lib/prototypes.h"
void chown_tty(struct passwd  const  *info ) ;
#line 156
extern struct group *getgr_nam_gid(char const   *grname ) ;
#line 38 "../lib/getdef.h"
extern int getdef_num(char const   * , int  ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chowntty.c"
void chown_tty(struct passwd  const  *info ) 
{ 
  struct group *grent___29 ;
  gid_t gid ;
  char const   *tmp ;
  int err ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 62
  tmp = getdef_str("TTYGROUP");
#line 62
  grent___29 = getgr_nam_gid(tmp);
  }
#line 63
  if ((unsigned long )((void *)0) != (unsigned long )grent___29) {
#line 64
    gid = grent___29->gr_gid;
  } else {
#line 66
    gid = (gid_t )info->pw_gid;
  }
  {
#line 74
  tmp___5 = fchown(0, (__uid_t )info->pw_uid, gid);
  }
#line 74
  if (tmp___5 != 0) {
#line 74
    goto _L;
  } else {
    {
#line 74
    tmp___6 = getdef_num("TTYPERM", 384);
#line 74
    tmp___7 = fchmod(0, (mode_t )tmp___6);
    }
#line 74
    if (tmp___7 != 0) {
      _L: /* CIL Label */ 
      {
#line 76
      tmp___0 = __errno_location();
#line 76
      err = *tmp___0;
#line 78
      tmp___1 = strerror(err);
#line 78
      tmp___2 = gettext("Unable to change owner or mode of tty stdin: %s");
#line 78
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              tmp___1);
      }
      {
#line 81
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 81
        tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 81
        old_locale = tmp___3;
#line 81
        saved_locale = (char *)((void *)0);
        }
#line 81
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 81
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 81
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 81
          setlocale(6, "C");
          }
        }
        {
#line 81
        tmp___4 = strerror(err);
#line 81
        syslog(4, "unable to change owner or mode of tty stdin for user `%s\': %s\n",
               info->pw_name, tmp___4);
        }
#line 81
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 81
          setlocale(6, (char const   *)saved_locale);
#line 81
          free((void *)saved_locale);
          }
        }
#line 81
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 84
      if (30 != err) {
        {
#line 85
        closelog();
#line 86
        exit(1);
        }
      }
    }
  }
#line 98
  return;
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 722
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setregid)(__gid_t __rgid ,
                                                                               __gid_t __egid ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 60 "../lib/prototypes.h"
char const   *Prog  ;
#line 75
char const   *Basename(char const   *str ) ;
#line 136
void sanitize_env(void) ;
#line 139
extern void change_field(char * , size_t  , char const   * ) ;
#line 159
extern int getlong(char const   *numstr , long *result ) ;
#line 291
extern void process_root_flag(char const   *short_opt , int argc , char **argv ) ;
#line 357
extern long strtoday(char const   * ) ;
#line 408
extern char *xstrdup(char const   * ) ;
#line 41 "../lib/pwio.h"
extern int pw_close(void) ;
#line 42
extern struct passwd  const  *pw_locate(char const   *name ) ;
#line 44
extern int pw_lock(void) ;
#line 46
extern char const   *pw_dbname(void) ;
#line 48
extern int pw_open(int mode ) ;
#line 51
extern int pw_unlock(void) ;
#line 52
extern int pw_update(struct passwd  const  *pw ) ;
#line 39 "../lib/shadowio.h"
extern int spw_close(void) ;
#line 40
extern _Bool spw_file_present(void) ;
#line 41
extern struct spwd  const  *spw_locate(char const   *name ) ;
#line 42
extern int spw_lock(void) ;
#line 44
extern char const   *spw_dbname(void) ;
#line 46
extern int spw_open(int mode ) ;
#line 49
extern int spw_unlock(void) ;
#line 50
extern int spw_update(struct spwd  const  *sp ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool dflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool Eflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool Iflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool lflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool mflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool Mflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool Wflg  =    (_Bool)0;
#line 78 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool amroot  =    (_Bool)0;
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool pw_locked  =    (_Bool)0;
#line 81 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static _Bool spw_locked  =    (_Bool)0;
#line 83 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static char user_name[8192]  = {      (char )'\000'};
#line 84 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static uid_t user_uid  =    (uid_t )-1;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static long mindays  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static long maxdays  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static long lstchgdate  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static long warndays  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static long inactdays  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static long expdate  ;
#line 94
static void usage(int status ) ;
#line 95
static void date_to_str(char *buf___0 , size_t maxsize , time_t date ) ;
#line 96
static int new_fields(void) ;
#line 97
static void print_date(time_t date ) ;
#line 98
static void list_fields(void) ;
#line 99
static void process_flags(int argc , char **argv ) ;
#line 100
static void check_flags(int argc , int opt_index ) ;
#line 101
static void check_perms(void) ;
#line 102
static void open_files(_Bool readonly ) ;
#line 103
static void close_files(void) ;
#line 104
static void fail_exit(int code ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void fail_exit(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 111
  if (spw_locked) {
    {
#line 112
    tmp___3 = spw_unlock();
    }
#line 112
    if (tmp___3 == 0) {
      {
#line 113
      tmp = spw_dbname();
#line 113
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 113
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 114
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 114
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 114
        old_locale = tmp___1;
#line 114
        saved_locale = (char *)((void *)0);
        }
#line 114
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 114
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 114
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 114
          setlocale(6, "C");
          }
        }
        {
#line 114
        tmp___2 = spw_dbname();
#line 114
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 114
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 114
          setlocale(6, (char const   *)saved_locale);
#line 114
          free((void *)saved_locale);
          }
        }
#line 114
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 118
  if (pw_locked) {
    {
#line 119
    tmp___8 = pw_unlock();
    }
#line 119
    if (tmp___8 == 0) {
      {
#line 120
      tmp___4 = pw_dbname();
#line 120
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 120
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 121
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 121
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 121
        old_locale___0 = tmp___6;
#line 121
        saved_locale___0 = (char *)((void *)0);
        }
#line 121
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 121
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 121
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 121
          setlocale(6, "C");
          }
        }
        {
#line 121
        tmp___7 = pw_dbname();
#line 121
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 121
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 121
          setlocale(6, (char const   *)saved_locale___0);
#line 121
          free((void *)saved_locale___0);
          }
        }
#line 121
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 125
  closelog();
#line 135
  exit(code);
  }
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void usage(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 143
  if (0 != status) {
#line 143
    tmp = stderr;
  } else {
#line 143
    tmp = stdout;
  }
  {
#line 143
  usageout = tmp;
#line 144
  tmp___0 = gettext("Usage: %s [options] LOGIN\n\nOptions:\n");
#line 144
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 149
  tmp___1 = gettext("  -d, --lastday LAST_DAY        set date of last password change to LAST_DAY\n");
#line 149
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 150
  tmp___2 = gettext("  -E, --expiredate EXPIRE_DATE  set account expiration date to EXPIRE_DATE\n");
#line 150
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 151
  tmp___3 = gettext("  -h, --help                    display this help message and exit\n");
#line 151
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 152
  tmp___4 = gettext("  -I, --inactive INACTIVE       set password inactive after expiration\n                                to INACTIVE\n");
#line 152
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 154
  tmp___5 = gettext("  -l, --list                    show account aging information\n");
#line 154
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 155
  tmp___6 = gettext("  -m, --mindays MIN_DAYS        set minimum number of days before password\n                                change to MIN_DAYS\n");
#line 155
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 157
  tmp___7 = gettext("  -M, --maxdays MAX_DAYS        set maximim number of days before password\n                                change to MAX_DAYS\n");
#line 157
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 159
  tmp___8 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 159
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 160
  tmp___9 = gettext("  -W, --warndays WARN_DAYS      set expiration warning days to WARN_DAYS\n");
#line 160
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)usageout);
#line 161
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 162
  exit(status);
  }
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void date_to_str(char *buf___0 , size_t maxsize , time_t date ) 
{ 
  struct tm *tp ;

  {
  {
#line 169
  tp = gmtime((time_t const   *)(& date));
#line 171
  strftime((char */* __restrict  */)buf___0, maxsize, (char const   */* __restrict  */)"%Y-%m-%d",
           (struct tm  const  */* __restrict  */)tp);
  }
#line 176
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static int new_fields(void) 
{ 
  char buf___0[200] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 191
  tmp = gettext("Enter the new value, or press ENTER for the default");
#line 191
  puts((char const   *)tmp);
#line 192
  puts("");
#line 194
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%ld",
           mindays);
#line 195
  tmp___0 = gettext("Minimum Password Age");
#line 195
  change_field(buf___0, sizeof(buf___0), (char const   *)tmp___0);
#line 196
  tmp___1 = getlong((char const   *)(buf___0), & mindays);
  }
#line 196
  if (tmp___1 == 0) {
#line 198
    return (0);
  } else
#line 196
  if (mindays < -1L) {
#line 198
    return (0);
  }
  {
#line 201
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%ld",
           maxdays);
#line 202
  tmp___2 = gettext("Maximum Password Age");
#line 202
  change_field(buf___0, sizeof(buf___0), (char const   *)tmp___2);
#line 203
  tmp___3 = getlong((char const   *)(buf___0), & maxdays);
  }
#line 203
  if (tmp___3 == 0) {
#line 205
    return (0);
  } else
#line 203
  if (maxdays < -1L) {
#line 205
    return (0);
  }
#line 208
  if (-1L == lstchgdate) {
    {
#line 209
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"-1");
    }
  } else {
    {
#line 211
    date_to_str(buf___0, sizeof(buf___0), lstchgdate * 86400L);
    }
  }
  {
#line 214
  tmp___4 = gettext("Last Password Change (YYYY-MM-DD)");
#line 214
  change_field(buf___0, sizeof(buf___0), (char const   *)tmp___4);
#line 216
  tmp___5 = strcmp((char const   *)(buf___0), "-1");
  }
#line 216
  if (tmp___5 == 0) {
#line 217
    lstchgdate = -1L;
  } else {
    {
#line 219
    lstchgdate = strtoday((char const   *)(buf___0));
    }
#line 220
    if (lstchgdate <= -1L) {
#line 221
      return (0);
    }
  }
  {
#line 225
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%ld",
           warndays);
#line 226
  tmp___6 = gettext("Password Expiration Warning");
#line 226
  change_field(buf___0, sizeof(buf___0), (char const   *)tmp___6);
#line 227
  tmp___7 = getlong((char const   *)(buf___0), & warndays);
  }
#line 227
  if (tmp___7 == 0) {
#line 229
    return (0);
  } else
#line 227
  if (warndays < -1L) {
#line 229
    return (0);
  }
  {
#line 232
  snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%ld",
           inactdays);
#line 233
  tmp___8 = gettext("Password Inactive");
#line 233
  change_field(buf___0, sizeof(buf___0), (char const   *)tmp___8);
#line 234
  tmp___9 = getlong((char const   *)(buf___0), & inactdays);
  }
#line 234
  if (tmp___9 == 0) {
#line 236
    return (0);
  } else
#line 234
  if (inactdays < -1L) {
#line 236
    return (0);
  }
#line 239
  if (-1L == expdate) {
    {
#line 240
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"-1");
    }
  } else {
    {
#line 242
    date_to_str(buf___0, sizeof(buf___0), expdate * 86400L);
    }
  }
  {
#line 245
  tmp___10 = gettext("Account Expiration Date (YYYY-MM-DD)");
#line 245
  change_field(buf___0, sizeof(buf___0), (char const   *)tmp___10);
#line 248
  tmp___11 = strcmp((char const   *)(buf___0), "-1");
  }
#line 248
  if (tmp___11 == 0) {
#line 249
    expdate = -1L;
  } else {
    {
#line 251
    expdate = strtoday((char const   *)(buf___0));
    }
#line 252
    if (expdate <= -1L) {
#line 253
      return (0);
    }
  }
#line 257
  return (1);
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void print_date(time_t date ) 
{ 
  struct tm *tp ;
  char buf___0[80] ;

  {
  {
#line 266
  tp = gmtime((time_t const   *)(& date));
  }
#line 267
  if ((unsigned long )((void *)0) == (unsigned long )tp) {
    {
#line 268
    printf((char const   */* __restrict  */)"time_t: %lu\n", (unsigned long )date);
    }
  } else {
    {
#line 270
    strftime((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%b %d, %Y",
             (struct tm  const  */* __restrict  */)tp);
#line 271
    puts((char const   *)(buf___0));
    }
  }
#line 287
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void list_fields(void) 
{ 
  long changed ;
  long expires ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 298
  changed = 0L;
#line 305
  tmp = gettext("Last password change\t\t\t\t\t: ");
#line 305
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stdout);
  }
#line 306
  if (lstchgdate < 0L) {
    {
#line 307
    tmp___0 = gettext("never");
#line 307
    puts((char const   *)tmp___0);
    }
  } else
#line 308
  if (lstchgdate == 0L) {
    {
#line 309
    tmp___1 = gettext("password must be changed");
#line 309
    puts((char const   *)tmp___1);
    }
  } else {
    {
#line 311
    changed = lstchgdate * 86400L;
#line 312
    print_date(changed);
    }
  }
  {
#line 319
  tmp___2 = gettext("Password expires\t\t\t\t\t: ");
#line 319
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
  }
#line 320
  if (lstchgdate == 0L) {
    {
#line 321
    tmp___3 = gettext("password must be changed");
#line 321
    puts((char const   *)tmp___3);
    }
  } else
#line 322
  if (lstchgdate < 0L) {
    {
#line 325
    tmp___4 = gettext("never");
#line 325
    puts((char const   *)tmp___4);
    }
  } else
#line 322
  if (maxdays >= 10000L) {
    {
#line 325
    tmp___4 = gettext("never");
#line 325
    puts((char const   *)tmp___4);
    }
  } else
#line 322
  if (maxdays < 0L) {
    {
#line 325
    tmp___4 = gettext("never");
#line 325
    puts((char const   *)tmp___4);
    }
  } else {
    {
#line 327
    expires = changed + maxdays * 86400L;
#line 328
    print_date(expires);
    }
  }
  {
#line 337
  tmp___5 = gettext("Password inactive\t\t\t\t\t: ");
#line 337
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stdout);
  }
#line 338
  if (lstchgdate == 0L) {
    {
#line 339
    tmp___6 = gettext("password must be changed");
#line 339
    puts((char const   *)tmp___6);
    }
  } else
#line 340
  if (lstchgdate < 0L) {
    {
#line 344
    tmp___7 = gettext("never");
#line 344
    puts((char const   *)tmp___7);
    }
  } else
#line 340
  if (inactdays < 0L) {
    {
#line 344
    tmp___7 = gettext("never");
#line 344
    puts((char const   *)tmp___7);
    }
  } else
#line 340
  if (maxdays >= 10000L) {
    {
#line 344
    tmp___7 = gettext("never");
#line 344
    puts((char const   *)tmp___7);
    }
  } else
#line 340
  if (maxdays < 0L) {
    {
#line 344
    tmp___7 = gettext("never");
#line 344
    puts((char const   *)tmp___7);
    }
  } else {
    {
#line 346
    expires = changed + (maxdays + inactdays) * 86400L;
#line 347
    print_date(expires);
    }
  }
  {
#line 354
  tmp___8 = gettext("Account expires\t\t\t\t\t\t: ");
#line 354
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stdout);
  }
#line 355
  if (expdate < 0L) {
    {
#line 356
    tmp___9 = gettext("never");
#line 356
    puts((char const   *)tmp___9);
    }
  } else {
    {
#line 358
    expires = expdate * 86400L;
#line 359
    print_date(expires);
    }
  }
  {
#line 369
  tmp___10 = gettext("Minimum number of days between password change\t\t: %ld\n");
#line 369
  printf((char const   */* __restrict  */)tmp___10, mindays);
#line 371
  tmp___11 = gettext("Maximum number of days between password change\t\t: %ld\n");
#line 371
  printf((char const   */* __restrict  */)tmp___11, maxdays);
#line 373
  tmp___12 = gettext("Number of days of warning before password expires\t: %ld\n");
#line 373
  printf((char const   */* __restrict  */)tmp___12, warndays);
  }
#line 375
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static struct option long_options[10]  = 
#line 388
  {      {"lastday", 1, (int *)((void *)0), 'd'}, 
        {"expiredate", 1, (int *)((void *)0), 'E'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"inactive", 1, (int *)((void *)0), 'I'}, 
        {"list", 0, (int *)((void *)0), 'l'}, 
        {"mindays", 1, (int *)((void *)0), 'm'}, 
        {"maxdays", 1, (int *)((void *)0), 'M'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"warndays", 1, (int *)((void *)0), 'W'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 382 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void process_flags(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 401
    c = getopt_long(argc, (char * const  *)argv, "d:E:hI:lm:M:R:W:", (struct option  const  *)(long_options),
                    (int *)((void *)0));
    }
#line 401
    if (! (c != -1)) {
#line 401
      goto while_break;
    }
    {
#line 404
    if (c == 100) {
#line 404
      goto case_100;
    }
#line 414
    if (c == 69) {
#line 414
      goto case_69;
    }
#line 424
    if (c == 104) {
#line 424
      goto case_104;
    }
#line 427
    if (c == 73) {
#line 427
      goto case_73;
    }
#line 437
    if (c == 108) {
#line 437
      goto case_108;
    }
#line 440
    if (c == 109) {
#line 440
      goto case_109;
    }
#line 450
    if (c == 77) {
#line 450
      goto case_77;
    }
#line 460
    if (c == 82) {
#line 460
      goto case_82;
    }
#line 462
    if (c == 87) {
#line 462
      goto case_87;
    }
#line 472
    goto switch_default;
    case_100: /* CIL Label */ 
    {
#line 405
    dflg = (_Bool)1;
#line 406
    lstchgdate = strtoday((char const   *)optarg);
    }
#line 407
    if (lstchgdate < -1L) {
      {
#line 408
      tmp = gettext("%s: invalid date \'%s\'\n");
#line 408
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 411
      usage(2);
      }
    }
#line 413
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 415
    Eflg = (_Bool)1;
#line 416
    expdate = strtoday((char const   *)optarg);
    }
#line 417
    if (expdate < -1L) {
      {
#line 418
      tmp___0 = gettext("%s: invalid date \'%s\'\n");
#line 418
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, optarg);
#line 421
      usage(2);
      }
    }
#line 423
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 425
    usage(0);
    }
#line 426
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 428
    Iflg = (_Bool)1;
#line 429
    tmp___2 = getlong((char const   *)optarg, & inactdays);
    }
#line 429
    if (tmp___2 == 0) {
      {
#line 431
      tmp___1 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, optarg);
#line 434
      usage(2);
      }
    } else
#line 429
    if (inactdays < -1L) {
      {
#line 431
      tmp___1 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, optarg);
#line 434
      usage(2);
      }
    }
#line 436
    goto switch_break;
    case_108: /* CIL Label */ 
#line 438
    lflg = (_Bool)1;
#line 439
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 441
    mflg = (_Bool)1;
#line 442
    tmp___4 = getlong((char const   *)optarg, & mindays);
    }
#line 442
    if (tmp___4 == 0) {
      {
#line 444
      tmp___3 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 444
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, optarg);
#line 447
      usage(2);
      }
    } else
#line 442
    if (mindays < -1L) {
      {
#line 444
      tmp___3 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 444
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, optarg);
#line 447
      usage(2);
      }
    }
#line 449
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 451
    Mflg = (_Bool)1;
#line 452
    tmp___6 = getlong((char const   *)optarg, & maxdays);
    }
#line 452
    if (tmp___6 == 0) {
      {
#line 454
      tmp___5 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 454
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, optarg);
#line 457
      usage(2);
      }
    } else
#line 452
    if (maxdays < -1L) {
      {
#line 454
      tmp___5 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 454
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, optarg);
#line 457
      usage(2);
      }
    }
#line 459
    goto switch_break;
    case_82: /* CIL Label */ 
#line 461
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 463
    Wflg = (_Bool)1;
#line 464
    tmp___8 = getlong((char const   *)optarg, & warndays);
    }
#line 464
    if (tmp___8 == 0) {
      {
#line 466
      tmp___7 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              Prog, optarg);
#line 469
      usage(2);
      }
    } else
#line 464
    if (warndays < -1L) {
      {
#line 466
      tmp___7 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              Prog, optarg);
#line 469
      usage(2);
      }
    }
#line 471
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 473
    usage(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  check_flags(argc, optind);
  }
#line 478
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void check_flags(int argc , int opt_index ) 
{ 
  char *tmp ;

  {
#line 492
  if (argc != opt_index + 1) {
    {
#line 493
    usage(2);
    }
  }
#line 496
  if (lflg) {
#line 496
    if (mflg) {
      {
#line 497
      tmp = gettext("%s: do not include \"l\" with other flags\n");
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 500
      usage(2);
      }
    } else
#line 496
    if (Mflg) {
      {
#line 497
      tmp = gettext("%s: do not include \"l\" with other flags\n");
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 500
      usage(2);
      }
    } else
#line 496
    if (dflg) {
      {
#line 497
      tmp = gettext("%s: do not include \"l\" with other flags\n");
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 500
      usage(2);
      }
    } else
#line 496
    if (Wflg) {
      {
#line 497
      tmp = gettext("%s: do not include \"l\" with other flags\n");
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 500
      usage(2);
      }
    } else
#line 496
    if (Iflg) {
      {
#line 497
      tmp = gettext("%s: do not include \"l\" with other flags\n");
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 500
      usage(2);
      }
    } else
#line 496
    if (Eflg) {
      {
#line 497
      tmp = gettext("%s: do not include \"l\" with other flags\n");
#line 497
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 500
      usage(2);
      }
    }
  }
#line 502
  return;
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void check_perms(void) 
{ 
  char *tmp ;

  {
#line 534
  if (! amroot) {
#line 534
    if (! lflg) {
      {
#line 535
      tmp = gettext("%s: Permission denied.\n");
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 536
      fail_exit(1);
      }
    }
  }
#line 571
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void open_files(_Bool readonly ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *old_locale___0 ;
  char *tmp___13 ;
  char *saved_locale___0 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 586
  if (! readonly) {
    {
#line 587
    tmp___1 = pw_lock();
    }
#line 587
    if (tmp___1 == 0) {
      {
#line 588
      tmp = pw_dbname();
#line 588
      tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 588
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
#line 591
      fail_exit(1);
      }
    }
#line 593
    pw_locked = (_Bool)1;
  }
#line 595
  if (readonly) {
#line 595
    tmp___6 = 0;
  } else {
#line 595
    tmp___6 = 2;
  }
  {
#line 595
  tmp___7 = pw_open(tmp___6);
  }
#line 595
  if (tmp___7 == 0) {
    {
#line 596
    tmp___2 = pw_dbname();
#line 596
    tmp___3 = gettext("%s: cannot open %s\n");
#line 596
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
    }
    {
#line 597
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 597
      tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 597
      old_locale = tmp___4;
#line 597
      saved_locale = (char *)((void *)0);
      }
#line 597
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 597
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 597
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 597
        setlocale(6, "C");
        }
      }
      {
#line 597
      tmp___5 = pw_dbname();
#line 597
      syslog(4, "cannot open %s", tmp___5);
      }
#line 597
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 597
        setlocale(6, (char const   *)saved_locale);
#line 597
        free((void *)saved_locale);
        }
      }
#line 597
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 598
    fail_exit(1);
    }
  }
#line 607
  if (! readonly) {
    {
#line 608
    tmp___10 = spw_lock();
    }
#line 608
    if (tmp___10 == 0) {
      {
#line 609
      tmp___8 = spw_dbname();
#line 609
      tmp___9 = gettext("%s: cannot lock %s; try again later.\n");
#line 609
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
#line 612
      fail_exit(1);
      }
    }
#line 614
    spw_locked = (_Bool)1;
  }
#line 616
  if (readonly) {
#line 616
    tmp___15 = 0;
  } else {
#line 616
    tmp___15 = 2;
  }
  {
#line 616
  tmp___16 = spw_open(tmp___15);
  }
#line 616
  if (tmp___16 == 0) {
    {
#line 617
    tmp___11 = spw_dbname();
#line 617
    tmp___12 = gettext("%s: cannot open %s\n");
#line 617
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
            Prog, tmp___11);
    }
    {
#line 619
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 619
      tmp___13 = setlocale(6, (char const   *)((void *)0));
#line 619
      old_locale___0 = tmp___13;
#line 619
      saved_locale___0 = (char *)((void *)0);
      }
#line 619
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 619
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 619
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 619
        setlocale(6, "C");
        }
      }
      {
#line 619
      tmp___14 = spw_dbname();
#line 619
      syslog(4, "cannot open %s", tmp___14);
      }
#line 619
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 619
        setlocale(6, (char const   *)saved_locale___0);
#line 619
        free((void *)saved_locale___0);
        }
      }
#line 619
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 620
    fail_exit(1);
    }
  }
#line 622
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void close_files(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 633
  tmp___3 = spw_close();
  }
#line 633
  if (tmp___3 == 0) {
    {
#line 634
    tmp = spw_dbname();
#line 634
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 634
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 636
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 636
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 636
      old_locale = tmp___1;
#line 636
      saved_locale = (char *)((void *)0);
      }
#line 636
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 636
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 636
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 636
        setlocale(6, "C");
        }
      }
      {
#line 636
      tmp___2 = spw_dbname();
#line 636
      syslog(3, "failure while writing changes to %s", tmp___2);
      }
#line 636
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 636
        setlocale(6, (char const   *)saved_locale);
#line 636
        free((void *)saved_locale);
        }
      }
#line 636
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 637
    fail_exit(1);
    }
  }
  {
#line 644
  tmp___8 = pw_close();
  }
#line 644
  if (tmp___8 == 0) {
    {
#line 645
    tmp___4 = pw_dbname();
#line 645
    tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 645
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            Prog, tmp___4);
    }
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 646
      tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 646
      old_locale___0 = tmp___6;
#line 646
      saved_locale___0 = (char *)((void *)0);
      }
#line 646
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 646
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 646
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 646
        setlocale(6, "C");
        }
      }
      {
#line 646
      tmp___7 = pw_dbname();
#line 646
      syslog(3, "failure while writing changes to %s", tmp___7);
      }
#line 646
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 646
        setlocale(6, (char const   *)saved_locale___0);
#line 646
        free((void *)saved_locale___0);
        }
      }
#line 646
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 647
    fail_exit(1);
    }
  }
  {
#line 649
  tmp___13 = spw_unlock();
  }
#line 649
  if (tmp___13 == 0) {
    {
#line 650
    tmp___9 = spw_dbname();
#line 650
    tmp___10 = gettext("%s: failed to unlock %s\n");
#line 650
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
            Prog, tmp___9);
    }
    {
#line 651
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 651
      tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 651
      old_locale___1 = tmp___11;
#line 651
      saved_locale___1 = (char *)((void *)0);
      }
#line 651
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 651
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 651
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 651
        setlocale(6, "C");
        }
      }
      {
#line 651
      tmp___12 = spw_dbname();
#line 651
      syslog(3, "failed to unlock %s", tmp___12);
      }
#line 651
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 651
        setlocale(6, (char const   *)saved_locale___1);
#line 651
        free((void *)saved_locale___1);
        }
      }
#line 651
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 654
  spw_locked = (_Bool)0;
#line 655
  tmp___18 = pw_unlock();
  }
#line 655
  if (tmp___18 == 0) {
    {
#line 656
    tmp___14 = pw_dbname();
#line 656
    tmp___15 = gettext("%s: failed to unlock %s\n");
#line 656
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
            Prog, tmp___14);
    }
    {
#line 657
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 657
      tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 657
      old_locale___2 = tmp___16;
#line 657
      saved_locale___2 = (char *)((void *)0);
      }
#line 657
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 657
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 657
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 657
        setlocale(6, "C");
        }
      }
      {
#line 657
      tmp___17 = pw_dbname();
#line 657
      syslog(3, "failed to unlock %s", tmp___17);
      }
#line 657
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 657
        setlocale(6, (char const   *)saved_locale___2);
#line 657
        free((void *)saved_locale___2);
        }
      }
#line 657
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 660
  pw_locked = (_Bool)0;
#line 661
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void update_age(struct spwd  const  *sp , struct passwd  const  *pw ) 
{ 
  struct spwd spwent ;
  struct passwd pwent___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 678
  if ((unsigned long )((void *)0) == (unsigned long )sp) {
    {
#line 679
    pwent___0 = *pw;
#line 681
    memset((void *)(& spwent), 0, sizeof(spwent));
#line 682
    spwent.sp_namp = xstrdup((char const   *)pwent___0.pw_name);
#line 683
    spwent.sp_pwdp = xstrdup((char const   *)pwent___0.pw_passwd);
#line 684
    spwent.sp_flag = 0xffffffffffffffffUL;
#line 686
    pwent___0.pw_passwd = (char *)"x";
#line 687
    tmp___1 = pw_update((struct passwd  const  *)(& pwent___0));
    }
#line 687
    if (tmp___1 == 0) {
      {
#line 688
      tmp = pw_dbname();
#line 688
      tmp___0 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 688
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp, pwent___0.pw_name);
#line 690
      fail_exit(1);
      }
    }
  } else {
    {
#line 693
    spwent.sp_namp = xstrdup((char const   *)sp->sp_namp);
#line 694
    spwent.sp_pwdp = xstrdup((char const   *)sp->sp_pwdp);
#line 695
    spwent.sp_flag = (unsigned long )sp->sp_flag;
    }
  }
  {
#line 703
  spwent.sp_max = maxdays;
#line 704
  spwent.sp_min = mindays;
#line 705
  spwent.sp_lstchg = lstchgdate;
#line 706
  spwent.sp_warn = warndays;
#line 707
  spwent.sp_inact = inactdays;
#line 708
  spwent.sp_expire = expdate;
#line 710
  tmp___4 = spw_update((struct spwd  const  *)(& spwent));
  }
#line 710
  if (tmp___4 == 0) {
    {
#line 711
    tmp___2 = spw_dbname();
#line 711
    tmp___3 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 711
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2, spwent.sp_namp);
#line 713
    fail_exit(1);
    }
  }
#line 716
  return;
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
static void get_defaults(struct spwd  const  *sp ) 
{ 


  {
#line 727
  if ((unsigned long )((void *)0) != (unsigned long )sp) {
#line 728
    if (! Mflg) {
#line 729
      maxdays = (long )sp->sp_max;
    }
#line 731
    if (! mflg) {
#line 732
      mindays = (long )sp->sp_min;
    }
#line 734
    if (! dflg) {
#line 735
      lstchgdate = (long )sp->sp_lstchg;
    }
#line 737
    if (! Wflg) {
#line 738
      warndays = (long )sp->sp_warn;
    }
#line 740
    if (! Iflg) {
#line 741
      inactdays = (long )sp->sp_inact;
    }
#line 743
    if (! Eflg) {
#line 744
      expdate = (long )sp->sp_expire;
    }
  } else {
#line 751
    if (! Mflg) {
#line 752
      maxdays = -1L;
    }
#line 754
    if (! mflg) {
#line 755
      mindays = -1L;
    }
#line 757
    if (! dflg) {
#line 758
      lstchgdate = -1L;
    }
#line 760
    if (! Wflg) {
#line 761
      warndays = -1L;
    }
#line 763
    if (! Iflg) {
#line 764
      inactdays = -1L;
    }
#line 766
    if (! Eflg) {
#line 767
      expdate = -1L;
    }
  }
#line 770
  return;
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chage.c"
int main(int argc , char **argv ) 
{ 
  struct spwd  const  *sp ;
  uid_t ruid ;
  gid_t rgid ;
  struct passwd  const  *pw ;
  char *tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  _Bool tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *old_locale___0 ;
  char *tmp___13 ;
  char *saved_locale___0 ;

  {
  {
#line 803
  Prog = Basename((char const   *)*(argv + 0));
#line 805
  sanitize_env();
#line 806
  setlocale(6, "");
#line 807
  bindtextdomain("shadow", "/usr/share/locale");
#line 808
  textdomain("shadow");
#line 810
  process_root_flag("-R", argc, argv);
#line 815
  openlog("chage", 1, 10 << 3);
#line 817
  ruid = getuid();
#line 818
  rgid = getgid();
#line 819
  amroot = (_Bool )(ruid == 0U);
#line 826
  process_flags(argc, argv);
#line 828
  check_perms();
#line 830
  tmp___1 = spw_file_present();
  }
#line 830
  if (! tmp___1) {
    {
#line 831
    tmp = gettext("%s: the shadow password file is not present\n");
#line 831
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog);
    }
    {
#line 834
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 834
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 834
      old_locale = tmp___0;
#line 834
      saved_locale = (char *)((void *)0);
      }
#line 834
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 834
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 834
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 834
        setlocale(6, "C");
        }
      }
      {
#line 834
      syslog(4, "can\'t find the shadow password file");
      }
#line 834
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 834
        setlocale(6, (char const   *)saved_locale);
#line 834
        free((void *)saved_locale);
        }
      }
#line 834
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 835
    closelog();
#line 836
    exit(15);
    }
  }
  {
#line 839
  open_files(lflg);
  }
#line 841
  if (lflg) {
    {
#line 841
    tmp___5 = setregid(rgid, rgid);
    }
#line 841
    if (tmp___5 != 0) {
      {
#line 843
      tmp___2 = __errno_location();
#line 843
      tmp___3 = strerror(*tmp___2);
#line 843
      tmp___4 = gettext("%s: failed to drop privileges (%s)\n");
#line 843
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              Prog, tmp___3);
#line 845
      fail_exit(1);
      }
    } else {
      {
#line 841
      tmp___6 = setreuid(ruid, ruid);
      }
#line 841
      if (tmp___6 != 0) {
        {
#line 843
        tmp___2 = __errno_location();
#line 843
        tmp___3 = strerror(*tmp___2);
#line 843
        tmp___4 = gettext("%s: failed to drop privileges (%s)\n");
#line 843
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                Prog, tmp___3);
#line 845
        fail_exit(1);
        }
      }
    }
  }
  {
#line 848
  pw = pw_locate((char const   *)*(argv + optind));
  }
#line 849
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
    {
#line 850
    tmp___7 = pw_dbname();
#line 850
    tmp___8 = gettext("%s: user \'%s\' does not exist in %s\n");
#line 850
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            Prog, *(argv + optind), tmp___7);
#line 852
    closelog();
#line 853
    fail_exit(1);
    }
  }
  {
#line 856
  strncpy((char */* __restrict  */)(user_name), (char const   */* __restrict  */)pw->pw_name,
          sizeof(user_name) - 1UL);
#line 856
  user_name[sizeof(user_name) - 1UL] = (char )'\000';
#line 862
  user_uid = (uid_t )pw->pw_uid;
#line 864
  sp = spw_locate((char const   *)*(argv + optind));
#line 865
  get_defaults(sp);
  }
#line 871
  if (lflg) {
#line 872
    if (! amroot) {
#line 872
      if (ruid != user_uid) {
        {
#line 873
        tmp___9 = gettext("%s: Permission denied.\n");
#line 873
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
                Prog);
#line 874
        fail_exit(1);
        }
      }
    }
    {
#line 881
    list_fields();
#line 882
    fail_exit(0);
    }
  }
#line 889
  if (! mflg) {
#line 889
    if (! Mflg) {
#line 889
      if (! dflg) {
#line 889
        if (! Wflg) {
#line 889
          if (! Iflg) {
#line 889
            if (! Eflg) {
              {
#line 890
              tmp___10 = gettext("Changing the aging information for %s\n");
#line 890
              printf((char const   */* __restrict  */)tmp___10, user_name);
#line 892
              tmp___12 = new_fields();
              }
#line 892
              if (tmp___12 == 0) {
                {
#line 893
                tmp___11 = gettext("%s: error changing fields\n");
#line 893
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
                        Prog);
#line 895
                fail_exit(1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 939
  update_age(sp, pw);
#line 941
  close_files();
  }
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 943
    tmp___13 = setlocale(6, (char const   *)((void *)0));
#line 943
    old_locale___0 = tmp___13;
#line 943
    saved_locale___0 = (char *)((void *)0);
    }
#line 943
    if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
      {
#line 943
      saved_locale___0 = strdup((char const   *)old_locale___0);
      }
    }
#line 943
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
      {
#line 943
      setlocale(6, "C");
      }
    }
    {
#line 943
    syslog(6, "changed password expiry for %s", user_name);
    }
#line 943
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
      {
#line 943
      setlocale(6, (char const   *)saved_locale___0);
#line 943
      free((void *)saved_locale___0);
      }
    }
#line 943
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 945
  closelog();
#line 946
  exit(0);
  }
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 71 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 70 "/usr/include/shadow.h"
extern void endspent(void) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 62 "../lib/gshadow_.h"
extern void endsgent(void) ;
#line 68 "../lib/prototypes.h"
void agecheck(struct spwd  const  *sp ) ;
#line 69
int expire(struct passwd  const  *pw , struct spwd  const  *sp ) ;
#line 71
extern int isexpired(struct passwd  const  * , struct spwd  const  * ) ;
#line 312
extern int setup_uid_gid(struct passwd  const  *info , _Bool is_console ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/age.c"
int expire(struct passwd  const  *pw , struct spwd  const  *sp ) 
{ 
  int status ;
  pid_t child ;
  pid_t pid ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int err ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )sp) {
#line 63
    return (0);
  }
  {
#line 71
  status = isexpired(pw, sp);
  }
  {
#line 73
  if (status == 0) {
#line 73
    goto case_0;
  }
#line 75
  if (status == 1) {
#line 75
    goto case_1;
  }
#line 78
  if (status == 2) {
#line 78
    goto case_2;
  }
#line 81
  if (status == 3) {
#line 81
    goto case_3;
  }
#line 72
  goto switch_break;
  case_0: /* CIL Label */ 
#line 74
  return (0);
  case_1: /* CIL Label */ 
  {
#line 76
  tmp = gettext("Your password has expired.");
#line 76
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stdout);
  }
#line 77
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 79
  tmp___0 = gettext("Your password is inactive.");
#line 79
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
  }
#line 80
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 82
  tmp___1 = gettext("Your login has expired.");
#line 82
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 83
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 93
  if (status > 1) {
    {
#line 94
    tmp___2 = gettext("  Contact the system administrator.");
#line 94
    puts((char const   *)tmp___2);
#line 95
    exit(1);
    }
  } else
#line 93
  if (sp->sp_max < sp->sp_min) {
    {
#line 94
    tmp___2 = gettext("  Contact the system administrator.");
#line 94
    puts((char const   *)tmp___2);
#line 95
    exit(1);
    }
  }
  {
#line 97
  tmp___3 = gettext("  Choose a new password.");
#line 97
  puts((char const   *)tmp___3);
#line 98
  fflush(stdout);
#line 106
  endspent();
#line 107
  endpwent();
#line 109
  endsgent();
#line 111
  endgrent();
#line 120
  pid = fork();
  }
#line 121
  if (0 == pid) {
    {
#line 130
    tmp___4 = setup_uid_gid(pw, (_Bool)0);
    }
#line 130
    if (tmp___4 != 0) {
      {
#line 135
      _exit(126);
      }
    }
    {
#line 138
    execl("/usr/bin/passwd", "/usr/bin/passwd", pw->pw_name, (char *)0);
#line 139
    tmp___5 = __errno_location();
#line 139
    err = *tmp___5;
#line 140
    perror("Can\'t execute /usr/bin/passwd");
    }
#line 141
    if (2 == err) {
#line 141
      tmp___6 = 127;
    } else {
#line 141
      tmp___6 = 126;
    }
    {
#line 141
    _exit(tmp___6);
    }
  } else
#line 142
  if (-1 == pid) {
    {
#line 143
    perror("fork");
#line 144
    exit(1);
    }
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    child = wait((union wait *)(& status));
    }
#line 147
    if (child != pid) {
#line 147
      if (! (child != -1)) {
#line 147
        goto while_break;
      }
    } else {
#line 147
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (child == pid) {
#line 149
    if (0 == status) {
#line 150
      return (1);
    }
  }
  {
#line 153
  exit(1);
  }
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/age.c"
void agecheck(struct spwd  const  *sp ) 
{ 
  long now ;
  time_t tmp ;
  long remain ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 165
  tmp = time((time_t *)0);
#line 165
  now = tmp / 86400L;
  }
#line 168
  if ((unsigned long )((void *)0) == (unsigned long )sp) {
#line 169
    return;
  }
#line 177
  if (-1L == sp->sp_lstchg) {
#line 180
    return;
  } else
#line 177
  if (-1L == sp->sp_max) {
#line 180
    return;
  } else
#line 177
  if (-1L == sp->sp_warn) {
#line 180
    return;
  }
#line 183
  if (0L == sp->sp_lstchg) {
    {
#line 184
    tmp___0 = gettext("You must change your password.");
#line 184
    puts((char const   *)tmp___0);
    }
#line 185
    return;
  }
#line 188
  remain = (long )((sp->sp_lstchg + sp->sp_max) - (long const   )now);
#line 189
  if (remain <= (long )sp->sp_warn) {
#line 190
    remain = remain;
#line 191
    if (remain > 1L) {
      {
#line 192
      tmp___1 = gettext("Your password will expire in %ld days.\n");
#line 192
      printf((char const   */* __restrict  */)tmp___1, remain);
      }
    } else
#line 194
    if (1L == remain) {
      {
#line 195
      tmp___2 = gettext("Your password will expire tomorrow.");
#line 195
      puts((char const   *)tmp___2);
      }
    } else
#line 196
    if (remain == 0L) {
      {
#line 197
      tmp___3 = gettext("Your password will expire today.");
#line 197
      puts((char const   *)tmp___3);
      }
    }
  }
#line 200
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 87 "../lib/prototypes.h"
void add_cleanup(void (*pcf)(void *arg ) , void *arg ) ;
#line 88
void del_cleanup(void (*pcf)(void *arg ) ) ;
#line 89
void do_cleanups(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
void do_cleanups(void) 
{ 
  unsigned int i ;
  __pid_t tmp ;

  {
#line 71
  if (! ((unsigned long )((void *)0) == (unsigned long )cleanup_functions[9])) {
    {
#line 71
    __assert_fail("((void *)0) == cleanup_functions[10-1]", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c",
                  71U, "do_cleanups");
    }
  }
  {
#line 73
  tmp = getpid();
  }
#line 73
  if (tmp != cleanup_pid) {
#line 74
    return;
  }
#line 77
  i = 10U;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    i --;
#line 80
    if ((unsigned long )cleanup_functions[i] != (unsigned long )((void *)0)) {
      {
#line 81
      (*(cleanup_functions[i]))(cleanup_function_args[i]);
      }
    }
#line 78
    if (! (i > 0U)) {
#line 78
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
void add_cleanup(void (*pcf)(void *arg ) , void *arg ) 
{ 
  unsigned int i ;

  {
#line 92
  if (! ((unsigned long )((void *)0) != (unsigned long )pcf)) {
    {
#line 92
    __assert_fail("((void *)0) != pcf", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c",
                  92U, "add_cleanup");
    }
  }
#line 94
  if (! ((unsigned long )((void *)0) == (unsigned long )cleanup_functions[8])) {
    {
#line 94
    __assert_fail("((void *)0) == cleanup_functions[10-2]", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c",
                  94U, "add_cleanup");
    }
  }
#line 96
  if (0 == cleanup_pid) {
    {
#line 97
    cleanup_pid = getpid();
    }
  }
#line 101
  i = 0U;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! ((unsigned long )((void *)0) != (unsigned long )cleanup_functions[i])) {
#line 101
      goto while_break;
    }
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  cleanup_functions[i] = pcf;
#line 103
  cleanup_function_args[i] = arg;
#line 104
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
void del_cleanup(void (*pcf)(void *arg ) ) 
{ 
  unsigned int i ;

  {
#line 112
  if (! ((unsigned long )((void *)0) != (unsigned long )pcf)) {
    {
#line 112
    __assert_fail("((void *)0) != pcf", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c",
                  112U, "del_cleanup");
    }
  }
#line 115
  i = 0U;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < 10U)) {
#line 115
      goto while_break;
    }
#line 116
    if ((unsigned long )cleanup_functions[i] == (unsigned long )pcf) {
#line 117
      goto while_break;
    }
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (! (i < 10U)) {
    {
#line 122
    __assert_fail("i<10", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c",
                  122U, "del_cleanup");
    }
  }
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 125
    if (! (i < 10U)) {
#line 125
      goto while_break___0;
    }
#line 127
    if (! (i == 9U)) {
#line 127
      if (! ((unsigned long )cleanup_functions[i + 1U] != (unsigned long )pcf)) {
        {
#line 127
        __assert_fail("(i == (10 -1)) || (cleanup_functions[i+1] != pcf)", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c",
                      128U, "del_cleanup");
        }
      }
    }
#line 130
    if (i == 9U) {
#line 131
      cleanup_functions[i] = (cleanup_function )((void *)0);
#line 132
      cleanup_function_args[i] = (void *)0;
    } else {
#line 134
      cleanup_functions[i] = cleanup_functions[i + 1U];
#line 135
      cleanup_function_args[i] = cleanup_function_args[i + 1U];
    }
#line 139
    if ((unsigned long )((void *)0) == (unsigned long )cleanup_functions[i]) {
#line 140
      goto while_break___0;
    }
#line 125
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/basename.c"
char const   *Basename(char const   *str ) 
{ 
  char *cp ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 47
  tmp = strrchr(str, '/');
#line 47
  cp = tmp;
  }
#line 49
  if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 49
    tmp___0 = (char const   *)(cp + 1);
  } else {
#line 49
    tmp___0 = str;
  }
#line 49
  return (tmp___0);
}
}
#line 107 "../lib/prototypes.h"
void cleanup_report_mod_passwd(void *cleanup_info ) ;
#line 114
void cleanup_unlock_passwd(void *arg  __attribute__((__unused__)) ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_user.c"
void cleanup_report_add_user(void *user_name___3 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;

  {
#line 47
  name___3 = (char const   *)user_name___3;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    tmp = setlocale(6, (char const   *)((void *)0));
#line 49
    old_locale = tmp;
#line 49
    saved_locale = (char *)((void *)0);
    }
#line 49
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 49
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 49
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 49
      setlocale(6, "C");
      }
    }
    {
#line 49
    syslog(3, "failed to add user %s", name___3);
    }
#line 49
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 49
      setlocale(6, (char const   *)saved_locale);
#line 49
      free((void *)saved_locale);
      }
    }
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_user.c"
void cleanup_report_mod_passwd(void *cleanup_info ) 
{ 
  struct cleanup_info_mod  const  *info ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 61
  info = (struct cleanup_info_mod  const  *)cleanup_info;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 63
    tmp = setlocale(6, (char const   *)((void *)0));
#line 63
    old_locale = tmp;
#line 63
    saved_locale = (char *)((void *)0);
    }
#line 63
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 63
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 63
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 63
      setlocale(6, "C");
      }
    }
    {
#line 63
    tmp___0 = pw_dbname();
#line 63
    syslog(3, "failed to change %s (%s)", tmp___0, info->action);
    }
#line 63
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 63
      setlocale(6, (char const   *)saved_locale);
#line 63
      free((void *)saved_locale);
      }
    }
#line 63
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_user.c"
void cleanup_report_add_user_passwd(void *user_name___3 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 84
  name___3 = (char const   *)user_name___3;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    tmp = setlocale(6, (char const   *)((void *)0));
#line 86
    old_locale = tmp;
#line 86
    saved_locale = (char *)((void *)0);
    }
#line 86
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 86
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 86
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 86
      setlocale(6, "C");
      }
    }
    {
#line 86
    tmp___0 = pw_dbname();
#line 86
    syslog(3, "failed to add user %s to %s", name___3, tmp___0);
    }
#line 86
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 86
      setlocale(6, (char const   *)saved_locale);
#line 86
      free((void *)saved_locale);
      }
    }
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_user.c"
void cleanup_report_add_user_shadow(void *user_name___3 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 104
  name___3 = (char const   *)user_name___3;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp = setlocale(6, (char const   *)((void *)0));
#line 106
    old_locale = tmp;
#line 106
    saved_locale = (char *)((void *)0);
    }
#line 106
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 106
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 106
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 106
      setlocale(6, "C");
      }
    }
    {
#line 106
    tmp___0 = spw_dbname();
#line 106
    syslog(3, "failed to add user %s to %s", name___3, tmp___0);
    }
#line 106
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 106
      setlocale(6, (char const   *)saved_locale);
#line 106
      free((void *)saved_locale);
      }
    }
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_user.c"
void cleanup_unlock_passwd(void *arg  __attribute__((__unused__)) ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 122
  tmp___3 = pw_unlock();
  }
#line 122
  if (tmp___3 == 0) {
    {
#line 123
    tmp = pw_dbname();
#line 123
    tmp___0 = gettext("%s: failed to unlock %s\n");
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 126
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 126
      old_locale = tmp___1;
#line 126
      saved_locale = (char *)((void *)0);
      }
#line 126
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 126
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 126
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 126
        setlocale(6, "C");
        }
      }
      {
#line 126
      tmp___2 = pw_dbname();
#line 126
      syslog(3, "failed to unlock %s", tmp___2);
      }
#line 126
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 126
        setlocale(6, (char const   *)saved_locale);
#line 126
        free((void *)saved_locale);
        }
      }
#line 126
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 132
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_user.c"
void cleanup_unlock_shadow(void *arg  __attribute__((__unused__)) ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 141
  tmp___3 = spw_unlock();
  }
#line 141
  if (tmp___3 == 0) {
    {
#line 142
    tmp = spw_dbname();
#line 142
    tmp___0 = gettext("%s: failed to unlock %s\n");
#line 142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 145
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 145
      old_locale = tmp___1;
#line 145
      saved_locale = (char *)((void *)0);
      }
#line 145
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 145
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 145
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 145
        setlocale(6, "C");
        }
      }
      {
#line 145
      tmp___2 = spw_dbname();
#line 145
      syslog(3, "failed to unlock %s", tmp___2);
      }
#line 145
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 145
        setlocale(6, (char const   *)saved_locale);
#line 145
        free((void *)saved_locale);
        }
      }
#line 145
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 151
  return;
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/prototypes.h"
int get_gid(char const   *gidstr , gid_t *gid ) ;
#line 324
struct group *sgetgrent(char const   *buf___0 ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size) {
#line 70
      size = i + 100;
#line 71
      if (members) {
        {
#line 72
        tmp = realloc((void *)members, (unsigned long )size * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members) {
          {
#line 81
          free((void *)members);
          }
        }
#line 82
        members = (char **)0;
#line 83
        size = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members + i) = (char *)0;
#line 99
  return (members);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___0  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
struct group *sgetgrent(char const   *buf___0 ) 
{ 
  int i ;
  char *cp ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 112
  tmp___1 = strlen(buf___0);
  }
#line 112
  if (tmp___1 + 1UL > size___0) {
#line 115
    if (grpbuf) {
      {
#line 116
      free((void *)grpbuf);
      }
    }
    {
#line 117
    tmp = strlen(buf___0);
#line 117
    size___0 = tmp + 1000UL;
#line 118
    tmp___0 = malloc(size___0);
#line 118
    grpbuf = (char *)tmp___0;
    }
#line 119
    if (! grpbuf) {
#line 120
      size___0 = (size_t )0;
#line 121
      return ((struct group *)0);
    }
  }
  {
#line 124
  strcpy((char */* __restrict  */)grpbuf, (char const   */* __restrict  */)buf___0);
#line 126
  cp = strrchr((char const   *)grpbuf, '\n');
  }
#line 127
  if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 128
    *cp = (char )'\000';
  }
#line 131
  cp = grpbuf;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (i < 4) {
#line 131
      if (! ((unsigned long )((void *)0) != (unsigned long )cp)) {
#line 131
        goto while_break;
      }
    } else {
#line 131
      goto while_break;
    }
    {
#line 132
    grpfields[i] = cp;
#line 133
    cp = strchr((char const   *)cp, ':');
    }
#line 134
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 135
      *cp = (char )'\000';
#line 136
      cp ++;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (i < 3) {
#line 140
    return ((struct group *)0);
  } else
#line 139
  if ((int )*(grpfields[2]) == 0) {
#line 140
    return ((struct group *)0);
  }
  {
#line 142
  grent.gr_name = grpfields[0];
#line 143
  grent.gr_passwd = grpfields[1];
#line 144
  tmp___2 = get_gid((char const   *)grpfields[2], & grent.gr_gid);
  }
#line 144
  if (tmp___2 == 0) {
#line 145
    return ((struct group *)0);
  }
  {
#line 147
  grent.gr_mem = list(grpfields[3]);
  }
#line 148
  if ((unsigned long )((void *)0) == (unsigned long )grent.gr_mem) {
#line 149
    return ((struct group *)0);
  }
#line 152
  return (& grent);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.h"
_Bool is_valid_user_name(char const   *name___3 ) ;
#line 48
_Bool is_valid_group_name(char const   *name___3 ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
_Bool is_valid_user_name(char const   *name___3 ) 
{ 
  size_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 79
  tmp = strlen(name___3);
  }
#line 79
  if (tmp > sizeof(((struct utmpx *)((void *)0))->ut_user)) {
#line 80
    return ((_Bool)0);
  }
  {
#line 83
  tmp___0 = is_valid_name(name___3);
  }
#line 83
  return (tmp___0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
_Bool is_valid_group_name(char const   *name___3 ) 
{ 
  size_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 92
  tmp = strlen(name___3);
  }
#line 92
  if (tmp > 16UL) {
#line 94
    return ((_Bool)0);
  }
  {
#line 97
  tmp___0 = is_valid_name(name___3);
  }
#line 97
  return (tmp___0);
}
}
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 86 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 130 "../lib/prototypes.h"
void pw_entry(char const   *name___3 , struct passwd *pwent___0 ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/entry.c"
void pw_entry(char const   *name___3 , struct passwd *pwent___0 ) 
{ 
  struct passwd *passwd ;
  struct spwd *spwd ;

  {
  {
#line 49
  passwd = getpwnam(name___3);
  }
#line 49
  if (passwd) {
    {
#line 53
    pwent___0->pw_name = xstrdup((char const   *)passwd->pw_name);
#line 54
    pwent___0->pw_uid = passwd->pw_uid;
#line 55
    pwent___0->pw_gid = passwd->pw_gid;
#line 56
    pwent___0->pw_gecos = xstrdup((char const   *)passwd->pw_gecos);
#line 57
    pwent___0->pw_dir = xstrdup((char const   *)passwd->pw_dir);
#line 58
    pwent___0->pw_shell = xstrdup((char const   *)passwd->pw_shell);
#line 61
    spwd = getspnam(name___3);
    }
#line 61
    if (spwd) {
      {
#line 62
      pwent___0->pw_passwd = xstrdup((char const   *)spwd->sp_pwdp);
      }
#line 63
      return;
    }
    {
#line 66
    pwent___0->pw_passwd = xstrdup((char const   *)passwd->pw_passwd);
    }
  } else {
#line 50
    pwent___0->pw_name = (char *)0;
#line 51
    return;
  }
#line 68
  return;
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 61 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ngettext)(char const   *__msgid1 ,
                                                                                 char const   *__msgid2 ,
                                                                                 unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.h"
void failure(uid_t uid , char const   *tty , struct faillog *fl ) ;
#line 61
int failcheck(uid_t uid , struct faillog *fl , _Bool failed ) ;
#line 69
void failprint(struct faillog  const  *fail___0 ) ;
#line 80
void failtmp(char const   *username___0 , struct utmp  const  *failent ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
void failure(uid_t uid , char const   *tty , struct faillog *fl ) 
{ 
  int fd ;
  off_t offset_uid ;
  int tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;
  char *old_locale___0 ;
  char *tmp___3 ;
  char *saved_locale___0 ;
  __off_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 54
  offset_uid = (off_t )sizeof(*fl) * (off_t )uid;
#line 60
  tmp = access("/var/log/faillog", 0);
  }
#line 60
  if (tmp != 0) {
#line 61
    return;
  }
  {
#line 64
  fd = open("/var/log/faillog", 2);
  }
#line 65
  if (fd < 0) {
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 66
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 66
      old_locale = tmp___0;
#line 66
      saved_locale = (char *)((void *)0);
      }
#line 66
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 66
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 66
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 66
        setlocale(6, "C");
        }
      }
      {
#line 66
      syslog(4, "Can\'t write faillog entry for UID %lu in %s.", (unsigned long )uid,
             "/var/log/faillog");
      }
#line 66
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 66
        setlocale(6, (char const   *)saved_locale);
#line 66
        free((void *)saved_locale);
        }
      }
#line 66
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 69
    return;
  }
  {
#line 78
  tmp___1 = lseek(fd, offset_uid, 0);
  }
#line 78
  if (tmp___1 != offset_uid) {
    {
#line 87
    memset((void *)fl, 0, sizeof(*fl));
    }
  } else {
    {
#line 78
    tmp___2 = read(fd, (void *)((char *)fl), sizeof(*fl));
    }
#line 78
    if (tmp___2 != (ssize_t )sizeof(*fl)) {
      {
#line 87
      memset((void *)fl, 0, sizeof(*fl));
      }
    }
  }
#line 97
  if ((int )fl->fail_cnt + 1 > 0) {
#line 98
    fl->fail_cnt = (short )((int )fl->fail_cnt + 1);
  }
  {
#line 101
  strncpy((char */* __restrict  */)(fl->fail_line), (char const   */* __restrict  */)tty,
          sizeof(fl->fail_line));
#line 102
  time(& fl->fail_time);
#line 111
  tmp___4 = lseek(fd, offset_uid, 0);
  }
#line 111
  if (tmp___4 != offset_uid) {
#line 111
    goto _L;
  } else {
    {
#line 111
    tmp___5 = write(fd, (void const   *)((char *)fl), sizeof(*fl));
    }
#line 111
    if (tmp___5 != (ssize_t )sizeof(*fl)) {
#line 111
      goto _L;
    } else {
      {
#line 111
      tmp___6 = close(fd);
      }
#line 111
      if (tmp___6 != 0) {
        _L: /* CIL Label */ 
        {
#line 114
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 114
          tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 114
          old_locale___0 = tmp___3;
#line 114
          saved_locale___0 = (char *)((void *)0);
          }
#line 114
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
            {
#line 114
            saved_locale___0 = strdup((char const   *)old_locale___0);
            }
          }
#line 114
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 114
            setlocale(6, "C");
            }
          }
          {
#line 114
          syslog(4, "Can\'t write faillog entry for UID %lu in %s.", (unsigned long )uid,
                 "/var/log/faillog");
          }
#line 114
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 114
            setlocale(6, (char const   *)saved_locale___0);
#line 114
            free((void *)saved_locale___0);
            }
          }
#line 114
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 117
        close(fd);
        }
      }
    }
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
int failcheck(uid_t uid , struct faillog *fl , _Bool failed ) 
{ 
  int fd ;
  struct faillog fail___0 ;
  off_t offset_uid ;
  int tmp ;
  int tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;
  _Bool tmp___4 ;
  char *old_locale___0 ;
  char *tmp___5 ;
  char *saved_locale___0 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 157
  offset_uid = (off_t )sizeof(*fl) * (off_t )uid;
#line 163
  tmp = access("/var/log/faillog", 0);
  }
#line 163
  if (tmp != 0) {
#line 164
    return (1);
  }
#line 167
  if (failed) {
#line 167
    tmp___0 = 0;
  } else {
#line 167
    tmp___0 = 2;
  }
  {
#line 167
  fd = open("/var/log/faillog", tmp___0);
  }
#line 168
  if (fd < 0) {
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 169
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 169
      old_locale = tmp___1;
#line 169
      saved_locale = (char *)((void *)0);
      }
#line 169
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 169
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 169
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 169
        setlocale(6, "C");
        }
      }
      {
#line 169
      syslog(4, "Can\'t open the faillog file (%s) to check UID %lu. User access authorized.",
             "/var/log/faillog", (unsigned long )uid);
      }
#line 169
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 169
        setlocale(6, (char const   *)saved_locale);
#line 169
        free((void *)saved_locale);
        }
      }
#line 169
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 173
    return (1);
  }
  {
#line 188
  tmp___2 = lseek(fd, offset_uid, 0);
  }
#line 188
  if (tmp___2 != offset_uid) {
    {
#line 190
    close(fd);
    }
#line 191
    return (1);
  } else {
    {
#line 188
    tmp___3 = read(fd, (void *)((char *)fl), sizeof(*fl));
    }
#line 188
    if (tmp___3 != (ssize_t )sizeof(*fl)) {
      {
#line 190
      close(fd);
      }
#line 191
      return (1);
    }
  }
  {
#line 194
  tmp___4 = too_many_failures((struct faillog  const  *)fl);
  }
#line 194
  if (tmp___4) {
    {
#line 195
    close(fd);
    }
#line 196
    return (0);
  }
#line 206
  if (! failed) {
    {
#line 207
    fail___0 = *fl;
#line 208
    fail___0.fail_cnt = (short)0;
#line 210
    tmp___6 = lseek(fd, offset_uid, 0);
    }
#line 210
    if (tmp___6 != offset_uid) {
#line 210
      goto _L;
    } else {
      {
#line 210
      tmp___7 = write(fd, (void const   *)(& fail___0), sizeof(fail___0));
      }
#line 210
      if (tmp___7 != (ssize_t )sizeof(fail___0)) {
#line 210
        goto _L;
      } else {
        {
#line 210
        tmp___8 = close(fd);
        }
#line 210
        if (tmp___8 != 0) {
          _L: /* CIL Label */ 
          {
#line 213
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 213
            tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 213
            old_locale___0 = tmp___5;
#line 213
            saved_locale___0 = (char *)((void *)0);
            }
#line 213
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
              {
#line 213
              saved_locale___0 = strdup((char const   *)old_locale___0);
              }
            }
#line 213
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 213
              setlocale(6, "C");
              }
            }
            {
#line 213
            syslog(4, "Can\'t reset faillog entry for UID %lu in %s.", (unsigned long )uid,
                   "/var/log/faillog");
            }
#line 213
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 213
              setlocale(6, (char const   *)saved_locale___0);
#line 213
              free((void *)saved_locale___0);
              }
            }
#line 213
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 216
          close(fd);
          }
        }
      }
    }
  } else {
    {
#line 219
    close(fd);
    }
  }
#line 222
  return (1);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
void failprint(struct faillog  const  *fail___0 ) 
{ 
  struct tm *tp ;
  char lasttimeb[256] ;
  char *lasttime ;
  time_t NOW ;
  char *tmp ;

  {
#line 238
  lasttime = lasttimeb;
#line 244
  if (0 == (int )fail___0->fail_cnt) {
#line 245
    return;
  }
  {
#line 248
  tp = localtime(& fail___0->fail_time);
#line 249
  time(& NOW);
#line 255
  strftime((char */* __restrict  */)(lasttimeb), sizeof(lasttimeb), (char const   */* __restrict  */)"%c",
           (struct tm  const  */* __restrict  */)tp);
#line 277
  tmp = ngettext("%d failure since last login.\nLast was %s on %s.\n", "%d failures since last login.\nLast was %s on %s.\n",
                 (unsigned long )fail___0->fail_cnt);
#line 277
  printf((char const   */* __restrict  */)tmp, (int const   )fail___0->fail_cnt, lasttime,
         fail___0->fail_line);
  }
#line 284
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
void failtmp(char const   *username___0 , struct utmp  const  *failent ) 
{ 
  char const   *ftmp ;
  int fd ;
  int tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  char *old_locale___0 ;
  char *tmp___1 ;
  char *saved_locale___0 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 309
  ftmp = getdef_str("FTMP_FILE");
  }
#line 310
  if ((unsigned long )((void *)0) == (unsigned long )ftmp) {
#line 311
    return;
  }
  {
#line 319
  tmp = access(ftmp, 0);
  }
#line 319
  if (tmp != 0) {
#line 320
    return;
  }
  {
#line 323
  fd = open(ftmp, 1025);
  }
#line 324
  if (-1 == fd) {
    {
#line 325
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 325
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 325
      old_locale = tmp___0;
#line 325
      saved_locale = (char *)((void *)0);
      }
#line 325
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 325
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 325
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 325
        setlocale(6, "C");
        }
      }
      {
#line 325
      syslog(4, "Can\'t append failure of user %s to %s.", username___0, ftmp);
      }
#line 325
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 325
        setlocale(6, (char const   *)saved_locale);
#line 325
        free((void *)saved_locale);
        }
      }
#line 325
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 328
    return;
  }
  {
#line 335
  tmp___2 = write(fd, (void const   *)failent, sizeof(*failent));
  }
#line 335
  if (tmp___2 != (ssize_t )sizeof(*failent)) {
#line 335
    goto _L;
  } else {
    {
#line 335
    tmp___3 = close(fd);
    }
#line 335
    if (tmp___3 != 0) {
      _L: /* CIL Label */ 
      {
#line 337
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 337
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 337
        old_locale___0 = tmp___1;
#line 337
        saved_locale___0 = (char *)((void *)0);
        }
#line 337
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 337
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 337
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 337
          setlocale(6, "C");
          }
        }
        {
#line 337
        syslog(4, "Can\'t append failure of user %s to %s.", username___0, ftmp);
        }
#line 337
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 337
          setlocale(6, (char const   *)saved_locale___0);
#line 337
          free((void *)saved_locale___0);
          }
        }
#line 337
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 340
      close(fd);
      }
    }
  }
#line 342
  return;
}
}
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                                            __mode_t __mode ,
                                                                                            __dev_t __dev ) ;
#line 138 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lutimes)(char const   *__file ,
                                                                                              struct timeval  const  *__tvp ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimes)(int __fd ,
                                                                              struct timeval  const  *__tvp ) ;
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 120 "../lib/prototypes.h"
int copy_tree(char const   *src_root , char const   *dst_root , _Bool copy_root ,
              _Bool reset_selinux , uid_t old_uid , uid_t new_uid , gid_t old_gid ,
              gid_t new_gid ) ;
#line 406
extern char *xmalloc(size_t size ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links  ;
#line 72
static int copy_entry(char const   *src , char const   *dst , _Bool reset_selinux ,
                      uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir(char const   *src , char const   *dst , _Bool reset_selinux ,
                    struct stat  const  *statp , struct timeval  const  *mt , uid_t old_uid ,
                    uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc(char const   *filename___0 ) ;
#line 83
static int copy_symlink(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                         struct link_name *lp ) ;
#line 92
static int copy_special(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file(char const   *src , char const   *dst , _Bool reset_selinux ,
                     struct stat  const  *statp , struct timeval  const  *mt , uid_t old_uid ,
                     uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                           uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                            uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed(int dst , struct stat  const  *statp , uid_t old_uid ,
                            uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links == (unsigned long )ln) {
    {
#line 149
    links = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig);
#line 199
  dst_len = strlen(dst_orig);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig, name___3 + src_len);
#line 207
  lp->ln_next = links;
#line 208
  links = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
int copy_tree(char const   *src_root , char const   *dst_root , _Bool copy_root ,
              _Bool reset_selinux , uid_t old_uid , uid_t new_uid , gid_t old_gid ,
              gid_t new_gid ) 
{ 
  int err ;
  _Bool set_orig ;
  struct dirent *ent ;
  DIR *dir ;
  struct stat sb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *src_name ;
  char *dst_name ;
  size_t src_len ;
  size_t tmp___4 ;
  size_t dst_len ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 235
  err = 0;
#line 236
  set_orig = (_Bool)0;
#line 240
  if (copy_root) {
    {
#line 242
    tmp = access(dst_root, 0);
    }
#line 242
    if (tmp == 0) {
#line 243
      return (-1);
    }
    {
#line 246
    tmp___0 = lstat((char const   */* __restrict  */)src_root, (struct stat */* __restrict  */)(& sb));
    }
#line 246
    if (tmp___0 == -1) {
#line 247
      return (-1);
    }
#line 250
    if (! ((sb.st_mode & 61440U) == 16384U)) {
      {
#line 251
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a directory",
              Prog, src_root);
      }
#line 254
      return (-1);
    }
    {
#line 257
    tmp___1 = copy_entry(src_root, dst_root, reset_selinux, old_uid, new_uid, old_gid,
                         new_gid);
    }
#line 257
    return (tmp___1);
  }
  {
#line 267
  tmp___2 = access(src_root, 0);
  }
#line 267
  if (tmp___2 != 0) {
#line 269
    return (-1);
  } else {
    {
#line 267
    tmp___3 = access(dst_root, 0);
    }
#line 267
    if (tmp___3 != 0) {
#line 269
      return (-1);
    }
  }
  {
#line 279
  dir = opendir(src_root);
  }
#line 280
  if ((unsigned long )((void *)0) == (unsigned long )dir) {
#line 281
    return (-1);
  }
#line 284
  if ((unsigned long )src_orig == (unsigned long )((void *)0)) {
#line 285
    src_orig = src_root;
#line 286
    dst_orig = dst_root;
#line 287
    set_orig = (_Bool)1;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (0 == err) {
      {
#line 289
      ent = readdir(dir);
      }
#line 289
      if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 289
        goto while_break;
      }
    } else {
#line 289
      goto while_break;
    }
    {
#line 293
    tmp___10 = strcmp((char const   *)(ent->d_name), ".");
    }
#line 293
    if (tmp___10 != 0) {
      {
#line 293
      tmp___11 = strcmp((char const   *)(ent->d_name), "..");
      }
#line 293
      if (tmp___11 != 0) {
        {
#line 297
        tmp___4 = strlen((char const   *)(ent->d_name));
#line 297
        src_len = tmp___4 + 2UL;
#line 298
        tmp___5 = strlen((char const   *)(ent->d_name));
#line 298
        dst_len = tmp___5 + 2UL;
#line 299
        tmp___6 = strlen(src_root);
#line 299
        src_len += tmp___6;
#line 300
        tmp___7 = strlen(dst_root);
#line 300
        dst_len += tmp___7;
#line 302
        tmp___8 = malloc(src_len);
#line 302
        src_name = (char *)tmp___8;
#line 303
        tmp___9 = malloc(dst_len);
#line 303
        dst_name = (char *)tmp___9;
        }
#line 305
        if ((unsigned long )((void *)0) == (unsigned long )src_name) {
#line 306
          err = -1;
        } else
#line 305
        if ((unsigned long )((void *)0) == (unsigned long )dst_name) {
#line 306
          err = -1;
        } else {
          {
#line 312
          snprintf((char */* __restrict  */)src_name, src_len, (char const   */* __restrict  */)"%s/%s",
                   src_root, ent->d_name);
#line 314
          snprintf((char */* __restrict  */)dst_name, dst_len, (char const   */* __restrict  */)"%s/%s",
                   dst_root, ent->d_name);
#line 317
          err = copy_entry((char const   *)src_name, (char const   *)dst_name, reset_selinux,
                           old_uid, new_uid, old_gid, new_gid);
          }
        }
#line 322
        if ((unsigned long )((void *)0) != (unsigned long )src_name) {
          {
#line 323
          free((void *)src_name);
          }
        }
#line 325
        if ((unsigned long )((void *)0) != (unsigned long )dst_name) {
          {
#line 326
          free((void *)dst_name);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  closedir(dir);
  }
#line 332
  if (set_orig) {
#line 333
    src_orig = (char const   *)((void *)0);
#line 334
    dst_orig = (char const   *)((void *)0);
  }
#line 355
  return (err);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry(char const   *src , char const   *dst , _Bool reset_selinux ,
                      uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                     old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else {
      {
#line 434
      lp = check_link(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                           (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                           new_gid);
        }
      } else {
        {
#line 455
        err = copy_file(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                        old_uid, new_uid, old_gid, new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir(char const   *src , char const   *dst , _Bool reset_selinux ,
                    struct stat  const  *statp , struct timeval  const  *mt , uid_t old_uid ,
                    uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                         struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file(char const   *src , char const   *dst , _Bool reset_selinux ,
                     struct stat  const  *statp , struct timeval  const  *mt , uid_t old_uid ,
                     uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                           uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                            uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed(int dst , struct stat  const  *statp , uid_t old_uid ,
                            uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 62 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 77
extern struct group *getgrent(void) ;
#line 105
extern struct group *getgrgid(__gid_t __gid ) ;
#line 143 "../lib/prototypes.h"
int find_new_gid(_Bool sys_group , gid_t *gid , gid_t const   *preferred_gid ) ;
#line 43 "../lib/groupio.h"
extern struct group  const  *gr_locate_gid(gid_t gid ) ;
#line 47
extern struct group  const  *gr_next(void) ;
#line 50
extern int gr_rewind(void) ;
#line 39 "../lib/getdef.h"
extern unsigned long getdef_ulong(char const   * , unsigned long  ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/find_new_gid.c"
int find_new_gid(_Bool sys_group , gid_t *gid , gid_t const   *preferred_gid ) 
{ 
  struct group  const  *grp ;
  gid_t gid_min ;
  gid_t gid_max ;
  gid_t group_id___2 ;
  _Bool *used_gids ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct group *tmp___11 ;
  struct group  const  *tmp___12 ;
  gid_t id ;
  struct group *tmp___13 ;
  struct group *tmp___14 ;
  char *tmp___15 ;
  char *old_locale ;
  char *tmp___16 ;
  char *saved_locale ;
  char *tmp___17 ;
  char *old_locale___0 ;
  char *tmp___18 ;
  char *saved_locale___0 ;

  {
#line 59
  if (! ((unsigned long )gid != (unsigned long )((void *)0))) {
    {
#line 59
    __assert_fail("gid != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/find_new_gid.c",
                  59U, "find_new_gid");
    }
  }
#line 61
  if (! sys_group) {
    {
#line 62
    tmp = getdef_ulong("GID_MIN", 1000UL);
#line 62
    gid_min = (gid_t )tmp;
#line 63
    tmp___0 = getdef_ulong("GID_MAX", 60000UL);
#line 63
    gid_max = (gid_t )tmp___0;
    }
#line 64
    if (gid_max < gid_min) {
      {
#line 65
      tmp___1 = gettext("%s: Invalid configuration: GID_MIN (%lu), GID_MAX (%lu)\n");
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, (unsigned long )gid_min, (unsigned long )gid_max);
      }
#line 68
      return (-1);
    }
  } else {
    {
#line 71
    tmp___2 = getdef_ulong("SYS_GID_MIN", 101UL);
#line 71
    gid_min = (gid_t )tmp___2;
#line 72
    tmp___3 = getdef_ulong("GID_MIN", 1000UL);
#line 72
    gid_max = (gid_t )tmp___3 - 1U;
#line 73
    tmp___4 = getdef_ulong("SYS_GID_MAX", (unsigned long )gid_max);
#line 73
    gid_max = (gid_t )tmp___4;
    }
#line 74
    if (gid_max < gid_min) {
      {
#line 75
      tmp___5 = getdef_ulong("GID_MIN", 1000UL);
#line 75
      tmp___6 = gettext("%s: Invalid configuration: SYS_GID_MIN (%lu), GID_MIN (%lu), SYS_GID_MAX (%lu)\n");
#line 75
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, (unsigned long )gid_min, tmp___5, (unsigned long )gid_max);
      }
#line 78
      return (-1);
    }
  }
  {
#line 81
  tmp___7 = malloc(sizeof(_Bool ) * (unsigned long )(gid_max + 1U));
#line 81
  used_gids = (_Bool *)tmp___7;
  }
#line 82
  if ((unsigned long )((void *)0) == (unsigned long )used_gids) {
    {
#line 83
    tmp___8 = __errno_location();
#line 83
    tmp___9 = strerror(*tmp___8);
#line 83
    tmp___10 = gettext("%s: failed to allocate memory: %s\n");
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
            Prog, tmp___9);
    }
#line 86
    return (-1);
  }
  {
#line 88
  memset((void *)used_gids, 0, sizeof(_Bool ) * (unsigned long )(gid_max + 1U));
  }
#line 90
  if ((unsigned long )((void *)0) != (unsigned long )preferred_gid) {
#line 90
    if (*preferred_gid >= (gid_t const   )gid_min) {
#line 90
      if (*preferred_gid <= (gid_t const   )gid_max) {
        {
#line 90
        tmp___11 = getgrgid((__gid_t )*preferred_gid);
        }
#line 90
        if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
          {
#line 90
          tmp___12 = gr_locate_gid((gid_t )*preferred_gid);
          }
#line 90
          if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
            {
#line 98
            *gid = (gid_t )*preferred_gid;
#line 99
            free((void *)used_gids);
            }
#line 100
            return (0);
          }
        }
      }
    }
  }
#line 112
  if (sys_group) {
#line 120
    group_id___2 = gid_max;
#line 121
    id = gid_max;
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      if (! (id >= gid_min)) {
#line 121
        goto while_break;
      }
      {
#line 122
      tmp___13 = getgrgid(id);
      }
#line 122
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 123
        group_id___2 = id - 1U;
#line 124
        *(used_gids + id) = (_Bool)1;
      }
#line 121
      id --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 128
    gr_rewind();
    }
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 129
      grp = gr_next();
      }
#line 129
      if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 129
        goto while_break___0;
      }
#line 130
      if (grp->gr_gid <= (__gid_t const   )group_id___2) {
#line 130
        if (grp->gr_gid >= (__gid_t const   )gid_min) {
#line 131
          group_id___2 = (gid_t )(grp->gr_gid - 1U);
        }
      }
#line 134
      if (grp->gr_gid <= (__gid_t const   )gid_max) {
#line 135
        *(used_gids + grp->gr_gid) = (_Bool)1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 139
    group_id___2 = gid_min;
#line 140
    setgrent();
    }
    {
#line 141
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 141
      tmp___14 = getgrent();
#line 141
      grp = (struct group  const  *)tmp___14;
      }
#line 141
      if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 141
        goto while_break___1;
      }
#line 142
      if (grp->gr_gid >= (__gid_t const   )group_id___2) {
#line 142
        if (grp->gr_gid <= (__gid_t const   )gid_max) {
#line 143
          group_id___2 = (gid_t )(grp->gr_gid + 1U);
        }
      }
#line 146
      if (grp->gr_gid <= (__gid_t const   )gid_max) {
#line 147
        *(used_gids + grp->gr_gid) = (_Bool)1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 150
    endgrent();
#line 152
    gr_rewind();
    }
    {
#line 153
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 153
      grp = gr_next();
      }
#line 153
      if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 153
        goto while_break___2;
      }
#line 154
      if (grp->gr_gid >= (__gid_t const   )group_id___2) {
#line 154
        if (grp->gr_gid <= (__gid_t const   )gid_max) {
#line 155
          group_id___2 = (gid_t )(grp->gr_gid + 1U);
        }
      }
#line 158
      if (grp->gr_gid <= (__gid_t const   )gid_max) {
#line 159
        *(used_gids + grp->gr_gid) = (_Bool)1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 170
  if (sys_group) {
#line 171
    if (group_id___2 < gid_min) {
#line 172
      group_id___2 = gid_max;
      {
#line 172
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 172
        if (! (group_id___2 >= gid_min)) {
#line 172
          goto while_break___3;
        }
#line 173
        if (0 == (int )*(used_gids + group_id___2)) {
#line 174
          goto while_break___3;
        }
#line 172
        group_id___2 --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 177
      if (group_id___2 < gid_min) {
        {
#line 178
        tmp___15 = gettext("%s: Can\'t get unique system GID (no more available GIDs)\n");
#line 178
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                Prog);
        }
        {
#line 181
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 181
          tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 181
          old_locale = tmp___16;
#line 181
          saved_locale = (char *)((void *)0);
          }
#line 181
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 181
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 181
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 181
            setlocale(6, "C");
            }
          }
          {
#line 181
          syslog(4, "no more available GID on the system");
          }
#line 181
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 181
            setlocale(6, (char const   *)saved_locale);
#line 181
            free((void *)saved_locale);
            }
          }
#line 181
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 183
        free((void *)used_gids);
        }
#line 184
        return (-1);
      }
    }
  } else
#line 188
  if (group_id___2 > gid_max) {
#line 189
    group_id___2 = gid_min;
    {
#line 189
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 189
      if (! (group_id___2 <= gid_max)) {
#line 189
        goto while_break___5;
      }
#line 190
      if (0 == (int )*(used_gids + group_id___2)) {
#line 191
        goto while_break___5;
      }
#line 189
      group_id___2 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 194
    if (group_id___2 > gid_max) {
      {
#line 195
      tmp___17 = gettext("%s: Can\'t get unique GID (no more available GIDs)\n");
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
              Prog);
      }
      {
#line 198
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 198
        tmp___18 = setlocale(6, (char const   *)((void *)0));
#line 198
        old_locale___0 = tmp___18;
#line 198
        saved_locale___0 = (char *)((void *)0);
        }
#line 198
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 198
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 198
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 198
          setlocale(6, "C");
          }
        }
        {
#line 198
        syslog(4, "no more available GID on the system");
        }
#line 198
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 198
          setlocale(6, (char const   *)saved_locale___0);
#line 198
          free((void *)saved_locale___0);
          }
        }
#line 198
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 199
      free((void *)used_gids);
      }
#line 200
      return (-1);
    }
  }
  {
#line 205
  free((void *)used_gids);
#line 206
  *gid = group_id___2;
  }
#line 207
  return (0);
}
}
#line 46 "../lib/groupio.h"
extern char const   *gr_dbname(void) ;
#line 51
extern int gr_unlock(void) ;
#line 43 "../lib/sgroupio.h"
extern char const   *sgr_dbname(void) ;
#line 48
extern int sgr_unlock(void) ;
#line 97 "../lib/prototypes.h"
void cleanup_report_add_group(void *group_name___2 ) ;
#line 98
void cleanup_report_add_group_group(void *group_name___2 ) ;
#line 100
void cleanup_report_add_group_gshadow(void *group_name___2 ) ;
#line 102
void cleanup_report_del_group(void *group_name___2 ) ;
#line 103
void cleanup_report_del_group_group(void *group_name___2 ) ;
#line 105
void cleanup_report_del_group_gshadow(void *group_name___2 ) ;
#line 108
void cleanup_report_mod_group(void *cleanup_info ) ;
#line 109
void cleanup_report_mod_gshadow(void *cleanup_info ) ;
#line 110
void cleanup_unlock_group(void *arg  __attribute__((__unused__)) ) ;
#line 112
void cleanup_unlock_gshadow(void *arg  __attribute__((__unused__)) ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_add_group(void *group_name___2 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;

  {
#line 47
  name___3 = (char const   *)group_name___2;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    tmp = setlocale(6, (char const   *)((void *)0));
#line 49
    old_locale = tmp;
#line 49
    saved_locale = (char *)((void *)0);
    }
#line 49
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 49
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 49
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 49
      setlocale(6, "C");
      }
    }
    {
#line 49
    syslog(3, "failed to add group %s", name___3);
    }
#line 49
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 49
      setlocale(6, (char const   *)saved_locale);
#line 49
      free((void *)saved_locale);
      }
    }
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_del_group(void *group_name___2 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;

  {
#line 65
  name___3 = (char const   *)group_name___2;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp = setlocale(6, (char const   *)((void *)0));
#line 67
    old_locale = tmp;
#line 67
    saved_locale = (char *)((void *)0);
    }
#line 67
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 67
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 67
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 67
      setlocale(6, "C");
      }
    }
    {
#line 67
    syslog(3, "failed to remove group %s", name___3);
    }
#line 67
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 67
      setlocale(6, (char const   *)saved_locale);
#line 67
      free((void *)saved_locale);
      }
    }
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_mod_group(void *cleanup_info ) 
{ 
  struct cleanup_info_mod  const  *info ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 79
  info = (struct cleanup_info_mod  const  *)cleanup_info;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    tmp = setlocale(6, (char const   *)((void *)0));
#line 81
    old_locale = tmp;
#line 81
    saved_locale = (char *)((void *)0);
    }
#line 81
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 81
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 81
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 81
      setlocale(6, "C");
      }
    }
    {
#line 81
    tmp___0 = gr_dbname();
#line 81
    syslog(3, "failed to change %s (%s)", tmp___0, info->action);
    }
#line 81
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 81
      setlocale(6, (char const   *)saved_locale);
#line 81
      free((void *)saved_locale);
      }
    }
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_mod_gshadow(void *cleanup_info ) 
{ 
  struct cleanup_info_mod  const  *info ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 97
  info = (struct cleanup_info_mod  const  *)cleanup_info;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp = setlocale(6, (char const   *)((void *)0));
#line 99
    old_locale = tmp;
#line 99
    saved_locale = (char *)((void *)0);
    }
#line 99
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 99
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 99
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 99
      setlocale(6, "C");
      }
    }
    {
#line 99
    tmp___0 = sgr_dbname();
#line 99
    syslog(3, "failed to change %s (%s)", tmp___0, info->action);
    }
#line 99
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 99
      setlocale(6, (char const   *)saved_locale);
#line 99
      free((void *)saved_locale);
      }
    }
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_add_group_group(void *group_name___2 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 120
  name___3 = (char const   *)group_name___2;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    tmp = setlocale(6, (char const   *)((void *)0));
#line 122
    old_locale = tmp;
#line 122
    saved_locale = (char *)((void *)0);
    }
#line 122
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 122
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 122
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 122
      setlocale(6, "C");
      }
    }
    {
#line 122
    tmp___0 = gr_dbname();
#line 122
    syslog(3, "failed to add group %s to %s", name___3, tmp___0);
    }
#line 122
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 122
      setlocale(6, (char const   *)saved_locale);
#line 122
      free((void *)saved_locale);
      }
    }
#line 122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_add_group_gshadow(void *group_name___2 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 140
  name___3 = (char const   *)group_name___2;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 142
    tmp = setlocale(6, (char const   *)((void *)0));
#line 142
    old_locale = tmp;
#line 142
    saved_locale = (char *)((void *)0);
    }
#line 142
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 142
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 142
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 142
      setlocale(6, "C");
      }
    }
    {
#line 142
    tmp___0 = sgr_dbname();
#line 142
    syslog(3, "failed to add group %s to %s", name___3, tmp___0);
    }
#line 142
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 142
      setlocale(6, (char const   *)saved_locale);
#line 142
      free((void *)saved_locale);
      }
    }
#line 142
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_del_group_group(void *group_name___2 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 161
  name___3 = (char const   *)group_name___2;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    tmp = setlocale(6, (char const   *)((void *)0));
#line 163
    old_locale = tmp;
#line 163
    saved_locale = (char *)((void *)0);
    }
#line 163
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 163
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 163
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 163
      setlocale(6, "C");
      }
    }
    {
#line 163
    tmp___0 = gr_dbname();
#line 163
    syslog(3, "failed to remove group %s from %s", name___3, tmp___0);
    }
#line 163
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 163
      setlocale(6, (char const   *)saved_locale);
#line 163
      free((void *)saved_locale);
      }
    }
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_report_del_group_gshadow(void *group_name___2 ) 
{ 
  char const   *name___3 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;

  {
#line 184
  name___3 = (char const   *)group_name___2;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 186
    tmp = setlocale(6, (char const   *)((void *)0));
#line 186
    old_locale = tmp;
#line 186
    saved_locale = (char *)((void *)0);
    }
#line 186
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 186
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 186
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 186
      setlocale(6, "C");
      }
    }
    {
#line 186
    tmp___0 = sgr_dbname();
#line 186
    syslog(3, "failed to remove group %s from %s", name___3, tmp___0);
    }
#line 186
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 186
      setlocale(6, (char const   *)saved_locale);
#line 186
      free((void *)saved_locale);
      }
    }
#line 186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_unlock_group(void *arg  __attribute__((__unused__)) ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 205
  tmp___3 = gr_unlock();
  }
#line 205
  if (tmp___3 == 0) {
    {
#line 206
    tmp = gr_dbname();
#line 206
    tmp___0 = gettext("%s: failed to unlock %s\n");
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 209
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 209
      old_locale = tmp___1;
#line 209
      saved_locale = (char *)((void *)0);
      }
#line 209
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 209
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 209
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 209
        setlocale(6, "C");
        }
      }
      {
#line 209
      tmp___2 = gr_dbname();
#line 209
      syslog(3, "failed to unlock %s", tmp___2);
      }
#line 209
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 209
        setlocale(6, (char const   *)saved_locale);
#line 209
        free((void *)saved_locale);
        }
      }
#line 209
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 215
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup_group.c"
void cleanup_unlock_gshadow(void *arg  __attribute__((__unused__)) ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 225
  tmp___3 = sgr_unlock();
  }
#line 225
  if (tmp___3 == 0) {
    {
#line 226
    tmp = sgr_dbname();
#line 226
    tmp___0 = gettext("%s: failed to unlock %s\n");
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 229
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 229
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 229
      old_locale = tmp___1;
#line 229
      saved_locale = (char *)((void *)0);
      }
#line 229
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 229
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 229
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 229
        setlocale(6, "C");
        }
      }
      {
#line 229
      tmp___2 = sgr_dbname();
#line 229
      syslog(3, "failed to unlock %s", tmp___2);
      }
#line 229
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 229
        setlocale(6, (char const   *)saved_locale);
#line 229
        free((void *)saved_locale);
        }
      }
#line 229
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 235
  return;
}
}
#line 43 "/usr/include/ulimit.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) ulimit)(int __cmd 
                                                                              , ...) ;
#line 382 "../lib/prototypes.h"
int set_filesize_limit(int blocks ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/ulimit.c"
int set_filesize_limit(int blocks ) 
{ 
  int ret ;
  long tmp ;

  {
  {
#line 55
  ret = -1;
#line 57
  tmp = ulimit(2, blocks);
  }
#line 57
  if (tmp != -1L) {
#line 58
    ret = 0;
  }
#line 68
  return (ret);
}
}
#line 545 "/usr/include/unistd.h"
extern char **environ ;
#line 133 "../lib/prototypes.h"
void addenv(char const   *string , char const   *value ) ;
#line 134
void initenv(void) ;
#line 135
void set_env(int argc , char * const  *argv ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
size_t newenvc  =    (size_t )0;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
char **newenvp  =    (char **)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid[14]  = 
#line 53
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 82 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
void initenv(void) 
{ 
  char *tmp ;

  {
  {
#line 84
  tmp = xmalloc(16UL * sizeof(char *));
#line 84
  newenvp = (char **)tmp;
#line 85
  *newenvp = (char *)((void *)0);
  }
#line 86
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
void addenv(char const   *string , char const   *value ) 
{ 
  char *cp ;
  char *newstring ;
  size_t i ;
  size_t n ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  int wlen ;
  int tmp___1 ;
  size_t tmp___2 ;
  char **__newenvp ;
  size_t newsize ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 95
  if ((unsigned long )((void *)0) != (unsigned long )value) {
    {
#line 96
    tmp = strlen(string);
#line 96
    tmp___0 = strlen(value);
#line 96
    len = (tmp + tmp___0) + 2UL;
#line 98
    newstring = xmalloc(len);
#line 99
    wlen = snprintf((char */* __restrict  */)newstring, len, (char const   */* __restrict  */)"%s=%s",
                    string, value);
    }
#line 100
    if (! (wlen == (int )len - 1)) {
      {
#line 100
      __assert_fail("wlen == (int) len -1", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c",
                    100U, "addenv");
      }
    }
  } else {
    {
#line 102
    newstring = xstrdup(string);
    }
  }
  {
#line 110
  cp = strchr((char const   *)newstring, '=');
  }
#line 111
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
    {
#line 112
    free((void *)newstring);
    }
#line 113
    return;
  }
#line 116
  n = (size_t )(cp - newstring);
#line 121
  i = (size_t )0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < newenvc)) {
#line 121
      goto while_break;
    }
    {
#line 122
    tmp___1 = strncmp((char const   *)newstring, (char const   *)*(newenvp + i), n);
    }
#line 122
    if (tmp___1 == 0) {
#line 122
      if (61 == (int )*(*(newenvp + i) + n)) {
#line 124
        goto while_break;
      } else
#line 122
      if (0 == (int )*(*(newenvp + i) + n)) {
#line 124
        goto while_break;
      }
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (i < newenvc) {
    {
#line 129
    free((void *)*(newenvp + i));
#line 130
    *(newenvp + i) = newstring;
    }
#line 131
    return;
  }
#line 137
  tmp___2 = newenvc;
#line 137
  newenvc ++;
#line 137
  *(newenvp + tmp___2) = newstring;
#line 151
  if ((newenvc & 15UL) == 0UL) {
    {
#line 160
    newsize = (newenvc + 16UL) * sizeof(char *);
#line 161
    tmp___3 = realloc((void *)newenvp, newsize);
#line 161
    __newenvp = (char **)tmp___3;
    }
#line 163
    if ((unsigned long )((void *)0) != (unsigned long )__newenvp) {
#line 169
      if ((unsigned long )environ == (unsigned long )newenvp) {
#line 170
        environ = __newenvp;
      }
#line 172
      newenvp = __newenvp;
    } else {
      {
#line 174
      tmp___4 = gettext("Environment overflow\n");
#line 174
      fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stderr);
#line 175
      newenvc --;
#line 176
      free((void *)*(newenvp + newenvc));
      }
    }
  }
#line 184
  *(newenvp + newenvc) = (char *)((void *)0);
#line 185
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
void set_env(int argc , char * const  *argv ) 
{ 
  int noname ;
  char variable[1024] ;
  char *cp ;
  size_t tmp ;
  int wlen ;
  char const   **p ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 193
  noname = 1;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (argc > 0)) {
#line 197
      goto while_break;
    }
    {
#line 198
    tmp = strlen((char const   *)*argv);
    }
#line 198
    if (tmp >= sizeof(variable)) {
#line 199
      goto __Cont;
    }
    {
#line 202
    cp = strchr((char const   *)*argv, '=');
    }
#line 203
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 205
      wlen = snprintf((char */* __restrict  */)(variable), sizeof(variable), (char const   */* __restrict  */)"L%d",
                      noname);
      }
#line 206
      if (! (wlen < (int )sizeof(variable))) {
        {
#line 206
        __assert_fail("wlen < (int) sizeof(variable)", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c",
                      206U, "set_env");
        }
      }
      {
#line 207
      noname ++;
#line 208
      addenv((char const   *)(variable), (char const   *)*argv);
      }
    } else {
#line 212
      p = forbid;
      {
#line 212
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 212
        if (! ((unsigned long )((void *)0) != (unsigned long )*p)) {
#line 212
          goto while_break___0;
        }
        {
#line 213
        tmp___0 = strlen(*p);
#line 213
        tmp___1 = strncmp((char const   *)*argv, *p, tmp___0);
        }
#line 213
        if (tmp___1 == 0) {
#line 214
          goto while_break___0;
        }
#line 212
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 218
      if ((unsigned long )((void *)0) != (unsigned long )*p) {
        {
#line 219
        strncpy((char */* __restrict  */)(variable), (char const   */* __restrict  */)*argv,
                (size_t )(cp - (char *)*argv));
#line 220
        variable[cp - (char *)*argv] = (char )'\000';
#line 221
        tmp___2 = gettext("You may not change $%s\n");
#line 221
        printf((char const   */* __restrict  */)tmp___2, variable);
        }
#line 223
        goto __Cont;
      }
      {
#line 226
      addenv((char const   *)*argv, (char const   *)((void *)0));
      }
    }
    __Cont: /* CIL Label */ 
#line 197
    argc --;
#line 197
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
void sanitize_env(void) 
{ 
  char **envp ;
  char const   **bad ;
  char **cur ;
  char **move ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 242
  envp = environ;
#line 247
  cur = envp;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! ((unsigned long )((void *)0) != (unsigned long )*cur)) {
#line 247
      goto while_break;
    }
#line 248
    bad = forbid;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! ((unsigned long )((void *)0) != (unsigned long )*bad)) {
#line 248
        goto while_break___0;
      }
      {
#line 249
      tmp = strlen(*bad);
#line 249
      tmp___0 = strncmp((char const   *)*cur, *bad, tmp);
      }
#line 249
      if (tmp___0 == 0) {
#line 250
        move = cur;
        {
#line 250
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 250
          if (! ((unsigned long )((void *)0) != (unsigned long )*move)) {
#line 250
            goto while_break___1;
          }
#line 251
          *move = *(move + 1);
#line 250
          move ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 253
        cur --;
#line 254
        goto while_break___0;
      }
#line 248
      bad ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 247
    cur ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  cur = envp;
  {
#line 259
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 259
    if (! ((unsigned long )((void *)0) != (unsigned long )*cur)) {
#line 259
      goto while_break___2;
    }
#line 260
    bad = noslash;
    {
#line 260
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 260
      if (! ((unsigned long )((void *)0) != (unsigned long )*bad)) {
#line 260
        goto while_break___3;
      }
      {
#line 261
      tmp___1 = strlen(*bad);
#line 261
      tmp___2 = strncmp((char const   *)*cur, *bad, tmp___1);
      }
#line 261
      if (tmp___2 != 0) {
#line 262
        goto __Cont;
      }
      {
#line 264
      tmp___3 = strchr((char const   *)*cur, '/');
      }
#line 264
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 265
        goto __Cont;
      }
#line 267
      move = cur;
      {
#line 267
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 267
        if (! ((unsigned long )((void *)0) != (unsigned long )*move)) {
#line 267
          goto while_break___4;
        }
#line 268
        *move = *(move + 1);
#line 267
        move ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 270
      cur --;
#line 271
      goto while_break___3;
      __Cont: /* CIL Label */ 
#line 260
      bad ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 259
    cur ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___0(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___0(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___0[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___0[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___0  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___0(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___0  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___1  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___0(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___1) {
#line 70
      size___1 = i + 100;
#line 71
      if (members___0) {
        {
#line 72
        tmp = realloc((void *)members___0, (unsigned long )size___1 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___1 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___0) {
          {
#line 81
          free((void *)members___0);
          }
        }
#line 82
        members___0 = (char **)0;
#line 83
        size___1 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___0 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___0 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___0 + i) = (char *)0;
#line 99
  return (members___0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___0  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___2  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___0[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___0  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___0(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___0(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___0  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___0  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___0  ;
#line 72
static int copy_entry___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___0(char const   *filename___0 ) ;
#line 83
static int copy_symlink___0(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___0(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___0(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___0(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___0(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___0(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___0 == (unsigned long )ln) {
    {
#line 149
    links___0 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___0(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___0)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___0)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___0);
#line 199
  dst_len = strlen(dst_orig___0);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___0, name___3 + src_len);
#line 207
  lp->ln_next = links___0;
#line 208
  links___0 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___0(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___0(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___0(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___0(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___0(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___0(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___0(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___0(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___0(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___0)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___0)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___0(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___0);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___0, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___0);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___0);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___0);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___0, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___0(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___0(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___0(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___0(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___0(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___0(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___0(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___0(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___0(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 275 "../lib/prototypes.h"
extern void __pw_del_entry(struct commonio_entry  const  *ent ) ;
#line 277
extern struct commonio_entry *__pw_get_head(void) ;
#line 342
extern struct commonio_entry *__spw_get_head(void) ;
#line 343
extern void __spw_del_entry(struct commonio_entry  const  *ent ) ;
#line 422
extern _Bool yes_or_no(_Bool read_only ) ;
#line 45 "../lib/pwio.h"
extern int pw_setdbname(char const   *filename ) ;
#line 53
extern int pw_sort(void) ;
#line 43 "../lib/shadowio.h"
extern int spw_setdbname(char const   *filename ) ;
#line 51
extern int spw_sort(void) ;
#line 8 "../lib/nscd.h"
extern int nscd_flush_cache(char const   *service ) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool use_system_pw_file  =    (_Bool)1;
#line 74 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool use_system_spw_file  =    (_Bool)1;
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool is_shadow  =    (_Bool)0;
#line 78 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool spw_opened  =    (_Bool)0;
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool pw_locked___0  =    (_Bool)0;
#line 81 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool spw_locked___0  =    (_Bool)0;
#line 84 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool read_only  =    (_Bool)0;
#line 85 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool sort_mode  =    (_Bool)0;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static _Bool quiet  =    (_Bool)0;
#line 89
static void fail_exit___0(int code ) ;
#line 90
static void usage___0(int status ) ;
#line 91
static void process_flags___0(int argc , char **argv ) ;
#line 92
static void open_files___0(void) ;
#line 93
static void close_files___0(_Bool changed ) ;
#line 94
static void check_pw_file(int *errors___0 , _Bool *changed ) ;
#line 95
static void check_spw_file(int *errors___0 , _Bool *changed ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void fail_exit___0(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 102
  if (spw_locked___0) {
    {
#line 103
    tmp___3 = spw_unlock();
    }
#line 103
    if (tmp___3 == 0) {
      {
#line 104
      tmp = spw_dbname();
#line 104
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
#line 105
      if (use_system_spw_file) {
        {
#line 106
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 106
          tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 106
          old_locale = tmp___1;
#line 106
          saved_locale = (char *)((void *)0);
          }
#line 106
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 106
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 106
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 106
            setlocale(6, "C");
            }
          }
          {
#line 106
          tmp___2 = spw_dbname();
#line 106
          syslog(3, "failed to unlock %s", tmp___2);
          }
#line 106
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 106
            setlocale(6, (char const   *)saved_locale);
#line 106
            free((void *)saved_locale);
            }
          }
#line 106
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 113
  if (pw_locked___0) {
    {
#line 114
    tmp___8 = pw_unlock();
    }
#line 114
    if (tmp___8 == 0) {
      {
#line 115
      tmp___4 = pw_dbname();
#line 115
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 115
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
#line 116
      if (use_system_pw_file) {
        {
#line 117
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 117
          tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 117
          old_locale___0 = tmp___6;
#line 117
          saved_locale___0 = (char *)((void *)0);
          }
#line 117
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
            {
#line 117
            saved_locale___0 = strdup((char const   *)old_locale___0);
            }
          }
#line 117
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 117
            setlocale(6, "C");
            }
          }
          {
#line 117
          tmp___7 = pw_dbname();
#line 117
          syslog(3, "failed to unlock %s", tmp___7);
          }
#line 117
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 117
            setlocale(6, (char const   *)saved_locale___0);
#line 117
            free((void *)saved_locale___0);
            }
          }
#line 117
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 124
  closelog();
#line 126
  exit(code);
  }
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void usage___0(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 133
  if (0 != status) {
#line 133
    tmp = stderr;
  } else {
#line 133
    tmp = stdout;
  }
  {
#line 133
  usageout = tmp;
#line 144
  tmp___0 = gettext("Usage: %s [options] [passwd [shadow]]\n\nOptions:\n");
#line 144
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 150
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 150
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 151
  tmp___2 = gettext("  -q, --quiet                   report errors only\n");
#line 151
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 152
  tmp___3 = gettext("  -r, --read-only               display errors and warnings\n                                but do not change files\n");
#line 152
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 154
  tmp___4 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 154
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 159
  tmp___5 = gettext("  -s, --sort                    sort entries by UID\n");
#line 159
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 161
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 162
  exit(status);
  }
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static struct option long_options___0[6]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"read-only", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"sort", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 170 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void process_flags___0(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;

  {
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    c = getopt_long(argc, (char * const  *)argv, "ehqrR:s", (struct option  const  *)(long_options___0),
                    (int *)((void *)0));
    }
#line 185
    if (! (c != -1)) {
#line 185
      goto while_break;
    }
    {
#line 188
    if (c == 104) {
#line 188
      goto case_104;
    }
#line 192
    if (c == 113) {
#line 192
      goto case_113;
    }
#line 192
    if (c == 101) {
#line 192
      goto case_113;
    }
#line 195
    if (c == 114) {
#line 195
      goto case_114;
    }
#line 198
    if (c == 82) {
#line 198
      goto case_82;
    }
#line 200
    if (c == 115) {
#line 200
      goto case_115;
    }
#line 203
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 189
    usage___0(0);
    }
#line 190
    goto switch_break;
    case_113: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 193
    quiet = (_Bool)1;
#line 194
    goto switch_break;
    case_114: /* CIL Label */ 
#line 196
    read_only = (_Bool)1;
#line 197
    goto switch_break;
    case_82: /* CIL Label */ 
#line 199
    goto switch_break;
    case_115: /* CIL Label */ 
#line 201
    sort_mode = (_Bool)1;
#line 202
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 204
    usage___0(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (sort_mode) {
#line 208
    if (read_only) {
      {
#line 209
      tmp = gettext("%s: -s and -r are incompatible\n");
#line 209
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 210
      exit(1);
      }
    }
  }
#line 216
  if (argc > optind + 2) {
    {
#line 217
    usage___0(1);
    }
  }
#line 224
  if (optind != argc) {
    {
#line 225
    pw_setdbname((char const   *)*(argv + optind));
#line 226
    use_system_pw_file = (_Bool)0;
    }
  }
#line 228
  if (optind + 2 == argc) {
    {
#line 237
    spw_setdbname((char const   *)*(argv + (optind + 1)));
#line 238
    is_shadow = (_Bool)1;
#line 239
    use_system_spw_file = (_Bool)0;
    }
  } else
#line 240
  if (optind == argc) {
    {
#line 241
    is_shadow = spw_file_present();
    }
  }
#line 243
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void open_files___0(void) 
{ 
  _Bool use_tcb ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *old_locale ;
  char *tmp___7 ;
  char *saved_locale ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *old_locale___0 ;
  char *tmp___13 ;
  char *saved_locale___0 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 253
  use_tcb = (_Bool)0;
#line 261
  if (! read_only) {
    {
#line 262
    tmp___1 = pw_lock();
    }
#line 262
    if (tmp___1 == 0) {
      {
#line 263
      tmp = pw_dbname();
#line 263
      tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 263
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
#line 266
      fail_exit___0(4);
      }
    }
#line 268
    pw_locked___0 = (_Bool)1;
#line 269
    if (is_shadow) {
#line 269
      if (! use_tcb) {
        {
#line 270
        tmp___4 = spw_lock();
        }
#line 270
        if (tmp___4 == 0) {
          {
#line 271
          tmp___2 = spw_dbname();
#line 271
          tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 271
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                  Prog, tmp___2);
#line 274
          fail_exit___0(4);
          }
        }
#line 276
        spw_locked___0 = (_Bool)1;
      }
    }
  }
#line 284
  if (read_only) {
#line 284
    tmp___9 = 0;
  } else {
#line 284
    tmp___9 = 2;
  }
  {
#line 284
  tmp___10 = pw_open(tmp___9);
  }
#line 284
  if (tmp___10 == 0) {
    {
#line 285
    tmp___5 = pw_dbname();
#line 285
    tmp___6 = gettext("%s: cannot open %s\n");
#line 285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
    }
#line 287
    if (use_system_pw_file) {
      {
#line 288
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 288
        tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 288
        old_locale = tmp___7;
#line 288
        saved_locale = (char *)((void *)0);
        }
#line 288
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 288
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 288
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 288
          setlocale(6, "C");
          }
        }
        {
#line 288
        tmp___8 = pw_dbname();
#line 288
        syslog(4, "cannot open %s", tmp___8);
        }
#line 288
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 288
          setlocale(6, (char const   *)saved_locale);
#line 288
          free((void *)saved_locale);
          }
        }
#line 288
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 290
    fail_exit___0(3);
    }
  }
#line 292
  if (is_shadow) {
#line 292
    if (! use_tcb) {
#line 293
      if (read_only) {
#line 293
        tmp___15 = 0;
      } else {
#line 293
        tmp___15 = 2;
      }
      {
#line 293
      tmp___16 = spw_open(tmp___15);
      }
#line 293
      if (tmp___16 == 0) {
        {
#line 294
        tmp___11 = spw_dbname();
#line 294
        tmp___12 = gettext("%s: cannot open %s\n");
#line 294
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                Prog, tmp___11);
        }
#line 296
        if (use_system_spw_file) {
          {
#line 297
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 297
            tmp___13 = setlocale(6, (char const   *)((void *)0));
#line 297
            old_locale___0 = tmp___13;
#line 297
            saved_locale___0 = (char *)((void *)0);
            }
#line 297
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
              {
#line 297
              saved_locale___0 = strdup((char const   *)old_locale___0);
              }
            }
#line 297
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 297
              setlocale(6, "C");
              }
            }
            {
#line 297
            tmp___14 = spw_dbname();
#line 297
            syslog(4, "cannot open %s", tmp___14);
            }
#line 297
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 297
              setlocale(6, (char const   *)saved_locale___0);
#line 297
              free((void *)saved_locale___0);
              }
            }
#line 297
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 300
        fail_exit___0(3);
        }
      }
#line 302
      spw_opened = (_Bool)1;
    }
  }
#line 304
  return;
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void close_files___0(_Bool changed ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 319
  if (changed) {
    {
#line 320
    tmp___3 = pw_close();
    }
#line 320
    if (tmp___3 == 0) {
      {
#line 321
      tmp = pw_dbname();
#line 321
      tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
#line 324
      if (use_system_pw_file) {
        {
#line 325
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 325
          tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 325
          old_locale = tmp___1;
#line 325
          saved_locale = (char *)((void *)0);
          }
#line 325
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 325
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 325
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 325
            setlocale(6, "C");
            }
          }
          {
#line 325
          tmp___2 = pw_dbname();
#line 325
          syslog(3, "failure while writing changes to %s", tmp___2);
          }
#line 325
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 325
            setlocale(6, (char const   *)saved_locale);
#line 325
            free((void *)saved_locale);
            }
          }
#line 325
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 329
      fail_exit___0(5);
      }
    }
#line 331
    if (spw_opened) {
      {
#line 331
      tmp___8 = spw_close();
      }
#line 331
      if (tmp___8 == 0) {
        {
#line 332
        tmp___4 = spw_dbname();
#line 332
        tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 332
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, tmp___4);
        }
#line 335
        if (use_system_spw_file) {
          {
#line 336
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 336
            tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 336
            old_locale___0 = tmp___6;
#line 336
            saved_locale___0 = (char *)((void *)0);
            }
#line 336
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
              {
#line 336
              saved_locale___0 = strdup((char const   *)old_locale___0);
              }
            }
#line 336
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 336
              setlocale(6, "C");
              }
            }
            {
#line 336
            tmp___7 = spw_dbname();
#line 336
            syslog(3, "failure while writing changes to %s", tmp___7);
            }
#line 336
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 336
              setlocale(6, (char const   *)saved_locale___0);
#line 336
              free((void *)saved_locale___0);
              }
            }
#line 336
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 340
        fail_exit___0(5);
        }
      }
    }
#line 342
    spw_opened = (_Bool)0;
  }
#line 348
  if (spw_locked___0) {
    {
#line 349
    tmp___13 = spw_unlock();
    }
#line 349
    if (tmp___13 == 0) {
      {
#line 350
      tmp___9 = spw_dbname();
#line 350
      tmp___10 = gettext("%s: failed to unlock %s\n");
#line 350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
#line 353
      if (use_system_spw_file) {
        {
#line 354
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 354
          tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 354
          old_locale___1 = tmp___11;
#line 354
          saved_locale___1 = (char *)((void *)0);
          }
#line 354
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
            {
#line 354
            saved_locale___1 = strdup((char const   *)old_locale___1);
            }
          }
#line 354
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
            {
#line 354
            setlocale(6, "C");
            }
          }
          {
#line 354
          tmp___12 = spw_dbname();
#line 354
          syslog(3, "failed to unlock %s", tmp___12);
          }
#line 354
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
            {
#line 354
            setlocale(6, (char const   *)saved_locale___1);
#line 354
            free((void *)saved_locale___1);
            }
          }
#line 354
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 360
  spw_locked___0 = (_Bool)0;
#line 361
  if (pw_locked___0) {
    {
#line 362
    tmp___18 = pw_unlock();
    }
#line 362
    if (tmp___18 == 0) {
      {
#line 363
      tmp___14 = pw_dbname();
#line 363
      tmp___15 = gettext("%s: failed to unlock %s\n");
#line 363
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
      }
#line 366
      if (use_system_pw_file) {
        {
#line 367
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 367
          tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 367
          old_locale___2 = tmp___16;
#line 367
          saved_locale___2 = (char *)((void *)0);
          }
#line 367
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
            {
#line 367
            saved_locale___2 = strdup((char const   *)old_locale___2);
            }
          }
#line 367
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 367
            setlocale(6, "C");
            }
          }
          {
#line 367
          tmp___17 = pw_dbname();
#line 367
          syslog(3, "failed to unlock %s", tmp___17);
          }
#line 367
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 367
            setlocale(6, (char const   *)saved_locale___2);
#line 367
            free((void *)saved_locale___2);
            }
          }
#line 367
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 373
  pw_locked___0 = (_Bool)0;
#line 374
  return;
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void check_pw_file(int *errors___0 , _Bool *changed ) 
{ 
  struct commonio_entry *pfe ;
  struct commonio_entry *tpfe ;
  struct passwd *pwd ;
  struct spwd *spw ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  struct passwd  const  *ent ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct group *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  struct spwd  const  *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  struct spwd sp ;
  struct passwd pw ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  time_t tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  _Bool tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;

  {
  {
#line 388
  pfe = __pw_get_head();
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )((void *)0) != (unsigned long )pfe)) {
#line 388
      goto while_break;
    }
#line 393
    if (43 == (int )*(pfe->line + 0)) {
#line 394
      goto __Cont;
    } else
#line 393
    if (45 == (int )*(pfe->line + 0)) {
#line 394
      goto __Cont;
    }
#line 402
    if ((unsigned long )((void *)0) == (unsigned long )pfe->eptr) {
      {
#line 407
      tmp = gettext("invalid password file entry");
#line 407
      puts((char const   *)tmp);
#line 408
      tmp___0 = gettext("delete line \'%s\'? ");
#line 408
      printf((char const   */* __restrict  */)tmp___0, pfe->line);
#line 409
      (*errors___0) ++;
#line 414
      tmp___1 = yes_or_no(read_only);
      }
#line 414
      if (! tmp___1) {
#line 415
        goto __Cont;
      }
      delete_pw: 
#line 425
      if (use_system_pw_file) {
        {
#line 426
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 426
          tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 426
          old_locale = tmp___2;
#line 426
          saved_locale = (char *)((void *)0);
          }
#line 426
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 426
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 426
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 426
            setlocale(6, "C");
            }
          }
          {
#line 426
          syslog(6, "delete passwd line \'%s\'", pfe->line);
          }
#line 426
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 426
            setlocale(6, (char const   *)saved_locale);
#line 426
            free((void *)saved_locale);
            }
          }
#line 426
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 429
      *changed = (_Bool)1;
#line 431
      __pw_del_entry((struct commonio_entry  const  *)pfe);
      }
#line 432
      goto __Cont;
    }
    {
#line 438
    pwd = (struct passwd *)pfe->eptr;
#line 443
    tpfe = __pw_get_head();
    }
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! ((unsigned long )((void *)0) != (unsigned long )tpfe)) {
#line 443
        goto while_break___1;
      }
#line 444
      ent = (struct passwd  const  *)tpfe->eptr;
#line 449
      if ((unsigned long )tpfe == (unsigned long )pfe) {
#line 450
        goto __Cont___0;
      }
#line 456
      if ((unsigned long )((void *)0) == (unsigned long )ent) {
#line 457
        goto __Cont___0;
      }
      {
#line 460
      tmp___3 = strcmp((char const   *)pwd->pw_name, (char const   *)ent->pw_name);
      }
#line 460
      if (tmp___3 != 0) {
#line 461
        goto __Cont___0;
      }
      {
#line 468
      tmp___4 = gettext("duplicate password entry");
#line 468
      puts((char const   *)tmp___4);
#line 469
      tmp___5 = gettext("delete line \'%s\'? ");
#line 469
      printf((char const   */* __restrict  */)tmp___5, pfe->line);
#line 470
      (*errors___0) ++;
#line 475
      tmp___6 = yes_or_no(read_only);
      }
#line 475
      if (tmp___6) {
#line 476
        goto delete_pw;
      }
      __Cont___0: /* CIL Label */ 
#line 443
      tpfe = tpfe->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 483
    tmp___8 = is_valid_user_name((char const   *)pwd->pw_name);
    }
#line 483
    if (! tmp___8) {
      {
#line 484
      tmp___7 = gettext("invalid user name \'%s\'\n");
#line 484
      printf((char const   */* __restrict  */)tmp___7, pwd->pw_name);
#line 485
      (*errors___0) ++;
      }
    }
#line 491
    if (pwd->pw_uid == 4294967295U) {
      {
#line 492
      tmp___9 = gettext("invalid user ID \'%lu\'\n");
#line 492
      printf((char const   */* __restrict  */)tmp___9, (unsigned long )pwd->pw_uid);
#line 493
      (*errors___0) ++;
      }
    }
#line 500
    if (! quiet) {
      {
#line 500
      tmp___11 = getgrgid(pwd->pw_gid);
      }
#line 500
      if ((unsigned long )((void *)0) == (unsigned long )tmp___11) {
        {
#line 506
        tmp___10 = gettext("user \'%s\': no group %lu\n");
#line 506
        printf((char const   */* __restrict  */)tmp___10, pwd->pw_name, (unsigned long )pwd->pw_gid);
#line 508
        (*errors___0) ++;
        }
      }
    }
#line 514
    if (! quiet) {
      {
#line 514
      tmp___13 = access((char const   *)pwd->pw_dir, 0);
      }
#line 514
      if (tmp___13 != 0) {
        {
#line 518
        tmp___12 = gettext("user \'%s\': directory \'%s\' does not exist\n");
#line 518
        printf((char const   */* __restrict  */)tmp___12, pwd->pw_name, pwd->pw_dir);
#line 520
        (*errors___0) ++;
        }
      }
    }
#line 526
    if (! quiet) {
#line 526
      if (0 != (int )*(pwd->pw_shell + 0)) {
        {
#line 526
        tmp___15 = access((char const   *)pwd->pw_shell, 0);
        }
#line 526
        if (tmp___15 != 0) {
          {
#line 533
          tmp___14 = gettext("user \'%s\': program \'%s\' does not exist\n");
#line 533
          printf((char const   */* __restrict  */)tmp___14, pwd->pw_name, pwd->pw_shell);
#line 535
          (*errors___0) ++;
          }
        }
      }
    }
#line 542
    if (is_shadow) {
      {
#line 589
      tmp___16 = spw_locate((char const   *)pwd->pw_name);
#line 589
      spw = (struct spwd *)tmp___16;
      }
#line 590
      if ((unsigned long )((void *)0) == (unsigned long )spw) {
        {
#line 591
        tmp___17 = spw_dbname();
#line 591
        tmp___18 = gettext("no matching password file entry in %s\n");
#line 591
        printf((char const   */* __restrict  */)tmp___18, tmp___17);
#line 593
        tmp___19 = spw_dbname();
#line 593
        tmp___20 = gettext("add user \'%s\' in %s? ");
#line 593
        printf((char const   */* __restrict  */)tmp___20, pwd->pw_name, tmp___19);
#line 595
        (*errors___0) ++;
#line 596
        tmp___31 = yes_or_no(read_only);
        }
#line 596
        if (tmp___31) {
          {
#line 600
          sp.sp_namp = pwd->pw_name;
#line 601
          sp.sp_pwdp = pwd->pw_passwd;
#line 602
          tmp___21 = getdef_num("PASS_MIN_DAYS", -1);
#line 602
          sp.sp_min = (long )tmp___21;
#line 604
          tmp___22 = getdef_num("PASS_MAX_DAYS", -1);
#line 604
          sp.sp_max = (long )tmp___22;
#line 606
          tmp___23 = getdef_num("PASS_WARN_AGE", -1);
#line 606
          sp.sp_warn = (long )tmp___23;
#line 608
          sp.sp_inact = -1L;
#line 609
          sp.sp_expire = -1L;
#line 610
          sp.sp_flag = 0xffffffffffffffffUL;
#line 611
          tmp___24 = time((time_t *)0);
#line 611
          sp.sp_lstchg = tmp___24 / 86400L;
          }
#line 612
          if (0L == sp.sp_lstchg) {
#line 616
            sp.sp_lstchg = -1L;
          }
          {
#line 618
          *changed = (_Bool)1;
#line 620
          tmp___27 = spw_update((struct spwd  const  *)(& sp));
          }
#line 620
          if (tmp___27 == 0) {
            {
#line 621
            tmp___25 = spw_dbname();
#line 621
            tmp___26 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 621
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___26,
                    Prog, tmp___25, sp.sp_namp);
#line 624
            fail_exit___0(5);
            }
          }
          {
#line 627
          pw = *pwd;
#line 628
          pw.pw_passwd = (char *)"x";
#line 629
          tmp___30 = pw_update((struct passwd  const  *)(& pw));
          }
#line 629
          if (tmp___30 == 0) {
            {
#line 630
            tmp___28 = pw_dbname();
#line 630
            tmp___29 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 630
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___29,
                    Prog, tmp___28, pw.pw_name);
#line 633
            fail_exit___0(5);
            }
          }
        }
      } else
#line 640
      if (! quiet) {
        {
#line 640
        tmp___35 = strcmp((char const   *)pwd->pw_passwd, "x");
        }
#line 640
        if (tmp___35 != 0) {
          {
#line 643
          tmp___32 = pw_dbname();
#line 643
          tmp___33 = spw_dbname();
#line 643
          tmp___34 = gettext("user %s has an entry in %s, but its password field in %s is not set to \'x\'\n");
#line 643
          printf((char const   */* __restrict  */)tmp___34, pwd->pw_name, tmp___33,
                 tmp___32);
#line 645
          (*errors___0) ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 388
    pfe = pfe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwck.c"
static void check_spw_file(int *errors___0 , _Bool *changed ) 
{ 
  struct commonio_entry *spe ;
  struct commonio_entry *tspe ;
  struct spwd *spw ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  struct spwd  const  *ent ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  struct passwd  const  *tmp___11 ;
  time_t t ;
  time_t tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 690
  spe = __spw_get_head();
  }
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! ((unsigned long )((void *)0) != (unsigned long )spe)) {
#line 690
      goto while_break;
    }
#line 695
    if ((unsigned long )((void *)0) == (unsigned long )spe->line) {
#line 696
      goto __Cont;
    }
#line 703
    if (43 == (int )*(spe->line + 0)) {
#line 704
      goto __Cont;
    } else
#line 703
    if (45 == (int )*(spe->line + 0)) {
#line 704
      goto __Cont;
    }
#line 712
    if ((unsigned long )((void *)0) == (unsigned long )spe->eptr) {
      {
#line 717
      tmp = gettext("invalid shadow password file entry");
#line 717
      puts((char const   *)tmp);
#line 718
      tmp___0 = gettext("delete line \'%s\'? ");
#line 718
      printf((char const   */* __restrict  */)tmp___0, spe->line);
#line 719
      (*errors___0) ++;
#line 724
      tmp___1 = yes_or_no(read_only);
      }
#line 724
      if (! tmp___1) {
#line 725
        goto __Cont;
      }
      delete_spw: 
#line 735
      if (use_system_spw_file) {
        {
#line 736
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 736
          tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 736
          old_locale = tmp___2;
#line 736
          saved_locale = (char *)((void *)0);
          }
#line 736
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 736
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 736
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 736
            setlocale(6, "C");
            }
          }
          {
#line 736
          syslog(6, "delete shadow line \'%s\'", spe->line);
          }
#line 736
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 736
            setlocale(6, (char const   *)saved_locale);
#line 736
            free((void *)saved_locale);
            }
          }
#line 736
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 739
      *changed = (_Bool)1;
#line 741
      __spw_del_entry((struct commonio_entry  const  *)spe);
      }
#line 742
      goto __Cont;
    }
    {
#line 748
    spw = (struct spwd *)spe->eptr;
#line 753
    tspe = __spw_get_head();
    }
    {
#line 753
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 753
      if (! ((unsigned long )((void *)0) != (unsigned long )tspe)) {
#line 753
        goto while_break___1;
      }
#line 754
      ent = (struct spwd  const  *)tspe->eptr;
#line 759
      if ((unsigned long )tspe == (unsigned long )spe) {
#line 760
        goto __Cont___0;
      }
#line 766
      if ((unsigned long )((void *)0) == (unsigned long )ent) {
#line 767
        goto __Cont___0;
      }
      {
#line 770
      tmp___3 = strcmp((char const   *)spw->sp_namp, (char const   *)ent->sp_namp);
      }
#line 770
      if (tmp___3 != 0) {
#line 771
        goto __Cont___0;
      }
      {
#line 778
      tmp___4 = gettext("duplicate shadow password entry");
#line 778
      puts((char const   *)tmp___4);
#line 779
      tmp___5 = gettext("delete line \'%s\'? ");
#line 779
      printf((char const   */* __restrict  */)tmp___5, spe->line);
#line 780
      (*errors___0) ++;
#line 785
      tmp___6 = yes_or_no(read_only);
      }
#line 785
      if (tmp___6) {
#line 786
        goto delete_spw;
      }
      __Cont___0: /* CIL Label */ 
#line 753
      tspe = tspe->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 794
    tmp___11 = pw_locate((char const   *)spw->sp_namp);
    }
#line 794
    if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
      {
#line 799
      tmp___7 = pw_dbname();
#line 799
      tmp___8 = gettext("no matching password file entry in %s\n");
#line 799
      printf((char const   */* __restrict  */)tmp___8, tmp___7);
#line 801
      tmp___9 = gettext("delete line \'%s\'? ");
#line 801
      printf((char const   */* __restrict  */)tmp___9, spe->line);
#line 802
      (*errors___0) ++;
#line 807
      tmp___10 = yes_or_no(read_only);
      }
#line 807
      if (tmp___10) {
#line 808
        goto delete_spw;
      }
    }
#line 815
    if (! quiet) {
      {
#line 816
      tmp___12 = time((time_t *)0);
#line 816
      t = tmp___12;
      }
#line 817
      if (t != 0L) {
#line 817
        if (spw->sp_lstchg > t / 86400L) {
          {
#line 819
          tmp___13 = gettext("user %s: last password change in the future\n");
#line 819
          printf((char const   */* __restrict  */)tmp___13, spw->sp_namp);
#line 821
          (*errors___0) ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 690
    spe = spe->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 825
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___0[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___0[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___1(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___1(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___1[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___1[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___1  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___1(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___1  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___3  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___1(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___3) {
#line 70
      size___3 = i + 100;
#line 71
      if (members___1) {
        {
#line 72
        tmp = realloc((void *)members___1, (unsigned long )size___3 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___3 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___1) {
          {
#line 81
          free((void *)members___1);
          }
        }
#line 82
        members___1 = (char **)0;
#line 83
        size___3 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___1 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___1 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___1 + i) = (char *)0;
#line 99
  return (members___1);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___1  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___4  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___1[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___1  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___1(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___1(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___1  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___1  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___1  ;
#line 72
static int copy_entry___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___1(char const   *filename___0 ) ;
#line 83
static int copy_symlink___1(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___1(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___1(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___1(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___1(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___1(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___1 == (unsigned long )ln) {
    {
#line 149
    links___1 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___1;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___1(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___1)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___1)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___1;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___1);
#line 199
  dst_len = strlen(dst_orig___1);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___1, name___3 + src_len);
#line 207
  lp->ln_next = links___1;
#line 208
  links___1 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___1(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___1(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___1(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___1(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___1(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___1(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___1(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___1(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___1(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___1)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___1)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___1(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___1);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___1, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___1);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___1);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___1);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___1, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___1(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___1(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___1(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___1(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___1(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___1(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___1(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___1(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___1(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 350 "../lib/prototypes.h"
extern int shell(char const   *file , char const   *arg , char * const  *envp ) ;
#line 378
char const   *tz(char const   *fname ) ;
#line 403
extern _Bool valid(char const   * , struct passwd  const  * ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/sulogin.c"
static char name[8192]  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/sulogin.c"
static char pass[8192]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/sulogin.c"
static struct passwd pwent  ;
#line 69
static void catch_signals(int sig  __attribute__((__unused__)) ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/sulogin.c"
static void catch_signals(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 73
  exit(1);
  }
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___1[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___1[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___2(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___2(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___2[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___2[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___2  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___2(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___2  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___5  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___2(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___5) {
#line 70
      size___5 = i + 100;
#line 71
      if (members___2) {
        {
#line 72
        tmp = realloc((void *)members___2, (unsigned long )size___5 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___5 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___2) {
          {
#line 81
          free((void *)members___2);
          }
        }
#line 82
        members___2 = (char **)0;
#line 83
        size___5 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___2 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___2 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___2 + i) = (char *)0;
#line 99
  return (members___2);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___2  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___6  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___2[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___2  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___2(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127 "../lib/prototypes.h"
extern char *pw_encrypt(char const   * , char const   * ) ;
#line 148
extern int find_new_uid(_Bool sys_user , uid_t *uid , uid_t const   *preferred_uid ) ;
#line 170
extern int get_uid(char const   *uidstr , uid_t *uid ) ;
#line 294
extern char const   *crypt_make_salt(char const   *meth , void *arg ) ;
#line 41 "../lib/groupio.h"
extern int gr_close(void) ;
#line 42
extern struct group  const  *gr_locate(char const   *name ) ;
#line 44
extern int gr_lock(void) ;
#line 48
extern int gr_open(int mode ) ;
#line 52
extern int gr_update(struct group  const  *gr ) ;
#line 38 "../lib/sgroupio.h"
extern int sgr_close(void) ;
#line 39
extern _Bool sgr_file_present(void) ;
#line 40
extern struct sgrp  const  *sgr_locate(char const   *name ) ;
#line 41
extern int sgr_lock(void) ;
#line 45
extern int sgr_open(int mode ) ;
#line 49
extern int sgr_update(struct sgrp  const  *sg ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool rflg  =    (_Bool)0;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static char *crypt_method  =    (char *)((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool sflg  =    (_Bool)0;
#line 81 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static long sha_rounds  =    5000L;
#line 85 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool is_shadow___0  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool is_shadow_grp  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool sgr_locked  =    (_Bool)0;
#line 90 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool pw_locked___1  =    (_Bool)0;
#line 91 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool gr_locked  =    (_Bool)0;
#line 92 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static _Bool spw_locked___1  =    (_Bool)0;
#line 95
static void usage___1(int status ) ;
#line 96
static void fail_exit___1(int code ) ;
#line 97
static int add_group(char const   *name___3 , char const   *gid , gid_t *ngid , unsigned int uid ) ;
#line 98
static int get_user_id(char const   *uid , uid_t *nuid ) ;
#line 99
static int add_user(char const   *name___3 , uid_t uid , gid_t gid ) ;
#line 101
static void update_passwd(struct passwd *pwd , char const   *password ) ;
#line 103
static int add_passwd(struct passwd *pwd , char const   *password ) ;
#line 104
static void process_flags___1(int argc , char **argv ) ;
#line 105
static void check_flags___0(void) ;
#line 106
static void check_perms___0(void) ;
#line 107
static void open_files___1(void) ;
#line 108
static void close_files___1(void) ;
#line 113 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void usage___1(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 115
  if (0 != status) {
#line 115
    tmp = stderr;
  } else {
#line 115
    tmp = stdout;
  }
  {
#line 115
  usageout = tmp;
#line 116
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 116
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 122
  tmp___1 = gettext("  -c, --crypt-method METHOD     the crypt method (one of %s)\n");
#line 122
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___1,
          "NONE DES MD5 SHA256 SHA512");
#line 131
  tmp___2 = gettext("  -h, --help                    display this help message and exit\n");
#line 131
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 132
  tmp___3 = gettext("  -r, --system                  create system accounts\n");
#line 132
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 133
  tmp___4 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 133
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 136
  tmp___5 = gettext("  -s, --sha-rounds              number of SHA rounds for the SHA*\n                                crypt algorithms\n");
#line 136
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 141
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 143
  exit(status);
  }
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void fail_exit___1(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 151
  if (spw_locked___1) {
    {
#line 152
    tmp___3 = spw_unlock();
    }
#line 152
    if (tmp___3 == 0) {
      {
#line 153
      tmp = spw_dbname();
#line 153
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 154
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 154
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 154
        old_locale = tmp___1;
#line 154
        saved_locale = (char *)((void *)0);
        }
#line 154
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 154
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 154
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 154
          setlocale(6, "C");
          }
        }
        {
#line 154
        tmp___2 = spw_dbname();
#line 154
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 154
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 154
          setlocale(6, (char const   *)saved_locale);
#line 154
          free((void *)saved_locale);
          }
        }
#line 154
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 158
  if (pw_locked___1) {
    {
#line 159
    tmp___8 = pw_unlock();
    }
#line 159
    if (tmp___8 == 0) {
      {
#line 160
      tmp___4 = pw_dbname();
#line 160
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 160
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 161
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 161
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 161
        old_locale___0 = tmp___6;
#line 161
        saved_locale___0 = (char *)((void *)0);
        }
#line 161
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 161
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 161
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 161
          setlocale(6, "C");
          }
        }
        {
#line 161
        tmp___7 = pw_dbname();
#line 161
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 161
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 161
          setlocale(6, (char const   *)saved_locale___0);
#line 161
          free((void *)saved_locale___0);
          }
        }
#line 161
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 165
  if (gr_locked) {
    {
#line 166
    tmp___13 = gr_unlock();
    }
#line 166
    if (tmp___13 == 0) {
      {
#line 167
      tmp___9 = gr_dbname();
#line 167
      tmp___10 = gettext("%s: failed to unlock %s\n");
#line 167
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 168
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 168
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 168
        old_locale___1 = tmp___11;
#line 168
        saved_locale___1 = (char *)((void *)0);
        }
#line 168
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 168
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 168
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 168
          setlocale(6, "C");
          }
        }
        {
#line 168
        tmp___12 = gr_dbname();
#line 168
        syslog(3, "failed to unlock %s", tmp___12);
        }
#line 168
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 168
          setlocale(6, (char const   *)saved_locale___1);
#line 168
          free((void *)saved_locale___1);
          }
        }
#line 168
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 173
  if (sgr_locked) {
    {
#line 174
    tmp___18 = sgr_unlock();
    }
#line 174
    if (tmp___18 == 0) {
      {
#line 175
      tmp___14 = sgr_dbname();
#line 175
      tmp___15 = gettext("%s: failed to unlock %s\n");
#line 175
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
      }
      {
#line 176
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 176
        tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 176
        old_locale___2 = tmp___16;
#line 176
        saved_locale___2 = (char *)((void *)0);
        }
#line 176
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 176
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 176
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 176
          setlocale(6, "C");
          }
        }
        {
#line 176
        tmp___17 = sgr_dbname();
#line 176
        syslog(3, "failed to unlock %s", tmp___17);
        }
#line 176
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 176
          setlocale(6, (char const   *)saved_locale___2);
#line 176
          free((void *)saved_locale___2);
          }
        }
#line 176
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 182
  exit(code);
  }
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static int add_group(char const   *name___3 , char const   *gid , gid_t *ngid , unsigned int uid ) 
{ 
  struct group  const  *grp ;
  struct group grent___29 ;
  char *members___30[1] ;
  struct sgrp  const  *sg ;
  struct group *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct group *tmp___2 ;
  struct group  const  *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  char *tmp___10 ;
  struct sgrp sgrent___2 ;
  char *admins___0[1] ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 201
  tmp = getgrnam(gid);
#line 201
  grp = (struct group  const  *)tmp;
  }
#line 202
  if ((unsigned long )((void *)0) == (unsigned long )grp) {
    {
#line 203
    grp = gr_locate(gid);
    }
  }
#line 205
  if ((unsigned long )((void *)0) != (unsigned long )grp) {
#line 207
    *ngid = (gid_t )grp->gr_gid;
#line 209
    return (0);
  }
  {
#line 212
  tmp___6 = __ctype_b_loc();
  }
#line 212
  if ((int const   )*(*tmp___6 + (int )*(gid + 0)) & 2048) {
    {
#line 218
    tmp___1 = get_gid(gid, & grent___29.gr_gid);
    }
#line 218
    if (tmp___1 == 0) {
      {
#line 219
      tmp___0 = gettext("%s: invalid group ID \'%s\'\n");
#line 219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, gid);
      }
#line 222
      return (-1);
    }
    {
#line 228
    tmp___2 = getgrgid(grent___29.gr_gid);
    }
#line 228
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 232
      *ngid = grent___29.gr_gid;
#line 233
      return (0);
    } else {
      {
#line 228
      tmp___3 = gr_locate_gid(grent___29.gr_gid);
      }
#line 228
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 232
        *ngid = grent___29.gr_gid;
#line 233
        return (0);
      }
    }
#line 237
    if (grent___29.gr_gid == 4294967295U) {
      {
#line 238
      tmp___4 = gettext("%s: invalid group ID \'%s\'\n");
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              Prog, gid);
      }
#line 241
      return (-1);
    }
  } else {
    {
#line 248
    tmp___5 = find_new_gid(rflg, & grent___29.gr_gid, (gid_t const   *)(& uid));
    }
#line 248
    if (tmp___5 < 0) {
#line 249
      return (-1);
    }
  }
#line 256
  if (0 != (int )*(gid + 0)) {
    {
#line 256
    tmp___7 = __ctype_b_loc();
    }
#line 256
    if ((int const   )*(*tmp___7 + (int )*(gid + 0)) & 2048) {
      {
#line 259
      grent___29.gr_name = xstrdup(name___3);
      }
    } else {
      {
#line 257
      grent___29.gr_name = xstrdup(gid);
      }
    }
  } else {
    {
#line 259
    grent___29.gr_name = xstrdup(name___3);
    }
  }
  {
#line 264
  tmp___9 = is_valid_group_name((char const   *)grent___29.gr_name);
  }
#line 264
  if (! tmp___9) {
    {
#line 265
    tmp___8 = gettext("%s: invalid group name \'%s\'\n");
#line 265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            Prog, grent___29.gr_name);
#line 268
    free((void *)grent___29.gr_name);
    }
#line 269
    return (-1);
  }
#line 272
  grent___29.gr_passwd = (char *)"*";
#line 273
  members___30[0] = (char *)((void *)0);
#line 274
  grent___29.gr_mem = members___30;
#line 276
  *ngid = grent___29.gr_gid;
#line 279
  if (is_shadow_grp) {
    {
#line 280
    sg = sgr_locate((char const   *)grent___29.gr_name);
    }
#line 282
    if ((unsigned long )((void *)0) != (unsigned long )sg) {
      {
#line 283
      tmp___10 = gettext("%s: group \'%s\' is a shadow group, but does not exist in /etc/group\n");
#line 283
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, grent___29.gr_name);
      }
#line 286
      return (-1);
    }
  }
#line 292
  if (is_shadow_grp) {
    {
#line 295
    sgrent___2.sg_name = grent___29.gr_name;
#line 296
    sgrent___2.sg_passwd = (char *)"*";
#line 297
    grent___29.gr_passwd = (char *)"x";
#line 298
    admins___0[0] = (char *)((void *)0);
#line 299
    sgrent___2.sg_adm = admins___0;
#line 300
    sgrent___2.sg_mem = members___30;
#line 302
    tmp___11 = sgr_update((struct sgrp  const  *)(& sgrent___2));
    }
#line 302
    if (tmp___11 == 0) {
#line 303
      return (-1);
    }
  }
  {
#line 308
  tmp___12 = gr_update((struct group  const  *)(& grent___29));
  }
#line 308
  if (tmp___12 == 0) {
#line 309
    return (-1);
  }
#line 312
  return (0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static int get_user_id(char const   *uid , uid_t *nuid ) 
{ 
  char *tmp ;
  int tmp___0 ;
  struct passwd  const  *pwd ;
  struct passwd *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 321
  tmp___4 = __ctype_b_loc();
  }
#line 321
  if ((int const   )*(*tmp___4 + (int )*(uid + 0)) & 2048) {
    {
#line 322
    tmp___0 = get_uid(uid, nuid);
    }
#line 322
    if (tmp___0 == 0) {
      {
#line 323
      tmp = gettext("%s: invalid user ID \'%s\'\n");
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, uid);
      }
#line 326
      return (-1);
    } else
#line 322
    if (*nuid == 4294967295U) {
      {
#line 323
      tmp = gettext("%s: invalid user ID \'%s\'\n");
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, uid);
      }
#line 326
      return (-1);
    }
  } else
#line 329
  if (0 != (int )*(uid + 0)) {
    {
#line 332
    tmp___1 = getpwnam(uid);
#line 332
    pwd = (struct passwd  const  *)tmp___1;
    }
#line 333
    if ((unsigned long )((void *)0) == (unsigned long )pwd) {
      {
#line 334
      pwd = pw_locate(uid);
      }
    }
#line 337
    if ((unsigned long )((void *)0) != (unsigned long )pwd) {
#line 338
      *nuid = (uid_t )pwd->pw_uid;
    } else {
      {
#line 340
      tmp___2 = gettext("%s: user \'%s\' does not exist\n");
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, uid);
      }
#line 343
      return (-1);
    }
  } else {
    {
#line 346
    tmp___3 = find_new_uid(rflg, nuid, (uid_t const   *)((void *)0));
    }
#line 346
    if (tmp___3 < 0) {
#line 347
      return (-1);
    }
  }
#line 352
  return (0);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static int add_user(char const   *name___3 , uid_t uid , gid_t gid ) 
{ 
  struct passwd pwent___0 ;
  char *tmp ;
  _Bool tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 363
  tmp___0 = is_valid_user_name(name___3);
  }
#line 363
  if (! tmp___0) {
    {
#line 364
    tmp = gettext("%s: invalid user name \'%s\'\n");
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, name___3);
    }
#line 367
    return (-1);
  }
  {
#line 375
  pwent___0.pw_name = xstrdup(name___3);
#line 376
  pwent___0.pw_uid = uid;
#line 377
  pwent___0.pw_passwd = (char *)"x";
#line 378
  pwent___0.pw_gid = gid;
#line 379
  pwent___0.pw_gecos = (char *)"";
#line 380
  pwent___0.pw_dir = (char *)"";
#line 381
  pwent___0.pw_shell = (char *)"";
#line 383
  tmp___3 = pw_update((struct passwd  const  *)(& pwent___0));
  }
#line 383
  if (tmp___3 == 0) {
#line 383
    tmp___2 = -1;
  } else {
#line 383
    tmp___2 = 0;
  }
#line 383
  return (tmp___2);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void update_passwd(struct passwd *pwd , char const   *password ) 
{ 
  void *crypt_arg ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 389
  crypt_arg = (void *)0;
#line 390
  if ((unsigned long )crypt_method != (unsigned long )((void *)0)) {
#line 392
    if (sflg) {
#line 393
      crypt_arg = (void *)(& sha_rounds);
    }
  }
#line 398
  if ((unsigned long )crypt_method != (unsigned long )((void *)0)) {
    {
#line 398
    tmp___0 = strcmp((char const   *)crypt_method, "NONE");
    }
#line 398
    if (0 == tmp___0) {
#line 399
      pwd->pw_passwd = (char *)password;
    } else {
      {
#line 401
      tmp = crypt_make_salt((char const   *)crypt_method, crypt_arg);
#line 401
      pwd->pw_passwd = pw_encrypt(password, tmp);
      }
    }
  } else {
    {
#line 401
    tmp = crypt_make_salt((char const   *)crypt_method, crypt_arg);
#line 401
    pwd->pw_passwd = pw_encrypt(password, tmp);
    }
  }
#line 405
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static int add_passwd(struct passwd *pwd , char const   *password ) 
{ 
  struct spwd  const  *sp ;
  struct spwd spent ;
  void *crypt_arg ;
  char const   *salt ;
  char const   *tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *salt___0 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 417
  crypt_arg = (void *)0;
#line 418
  if ((unsigned long )crypt_method != (unsigned long )((void *)0)) {
#line 420
    if (sflg) {
#line 421
      crypt_arg = (void *)(& sha_rounds);
    }
  }
#line 431
  if (! is_shadow___0) {
    {
#line 432
    update_passwd(pwd, password);
    }
#line 433
    return (0);
  }
  {
#line 441
  sp = spw_locate((char const   *)pwd->pw_name);
  }
#line 443
  if ((unsigned long )((void *)0) != (unsigned long )sp) {
#line 444
    spent = (struct spwd )*sp;
#line 445
    if ((unsigned long )((void *)0) != (unsigned long )crypt_method) {
      {
#line 445
      tmp___0 = strcmp((char const   *)crypt_method, "NONE");
      }
#line 445
      if (0 == tmp___0) {
#line 447
        spent.sp_pwdp = (char *)password;
      } else {
        {
#line 449
        tmp = crypt_make_salt((char const   *)crypt_method, crypt_arg);
#line 449
        salt = tmp;
#line 451
        spent.sp_pwdp = pw_encrypt(password, salt);
        }
      }
    } else {
      {
#line 449
      tmp = crypt_make_salt((char const   *)crypt_method, crypt_arg);
#line 449
      salt = tmp;
#line 451
      spent.sp_pwdp = pw_encrypt(password, salt);
      }
    }
    {
#line 453
    tmp___1 = time((time_t *)0);
#line 453
    spent.sp_lstchg = tmp___1 / 86400L;
    }
#line 454
    if (0L == spent.sp_lstchg) {
#line 457
      spent.sp_lstchg = -1L;
    }
    {
#line 459
    tmp___2 = spw_update((struct spwd  const  *)(& spent));
    }
#line 459
    return (tmp___2 == 0);
  }
  {
#line 468
  tmp___3 = strcmp((char const   *)pwd->pw_passwd, "x");
  }
#line 468
  if (tmp___3 != 0) {
    {
#line 469
    update_passwd(pwd, password);
    }
#line 470
    return (0);
  }
#line 489
  spent.sp_namp = pwd->pw_name;
#line 491
  if ((unsigned long )crypt_method != (unsigned long )((void *)0)) {
    {
#line 491
    tmp___5 = strcmp((char const   *)crypt_method, "NONE");
    }
#line 491
    if (0 == tmp___5) {
#line 492
      spent.sp_pwdp = (char *)password;
    } else {
      {
#line 494
      tmp___4 = crypt_make_salt((char const   *)crypt_method, crypt_arg);
#line 494
      salt___0 = tmp___4;
#line 495
      spent.sp_pwdp = pw_encrypt(password, salt___0);
      }
    }
  } else {
    {
#line 494
    tmp___4 = crypt_make_salt((char const   *)crypt_method, crypt_arg);
#line 494
    salt___0 = tmp___4;
#line 495
    spent.sp_pwdp = pw_encrypt(password, salt___0);
    }
  }
  {
#line 504
  tmp___6 = time((time_t *)0);
#line 504
  spent.sp_lstchg = tmp___6 / 86400L;
  }
#line 505
  if (0L == spent.sp_lstchg) {
#line 507
    spent.sp_lstchg = -1L;
  }
  {
#line 509
  tmp___7 = getdef_num("PASS_MIN_DAYS", 0);
#line 509
  spent.sp_min = (long )tmp___7;
#line 511
  tmp___8 = getdef_num("PASS_MAX_DAYS", 10000);
#line 511
  spent.sp_max = (long )tmp___8;
#line 512
  tmp___9 = getdef_num("PASS_WARN_AGE", -1);
#line 512
  spent.sp_warn = (long )tmp___9;
#line 513
  spent.sp_inact = -1L;
#line 514
  spent.sp_expire = -1L;
#line 515
  spent.sp_flag = 0xffffffffffffffffUL;
#line 517
  tmp___10 = spw_update((struct spwd  const  *)(& spent));
  }
#line 517
  return (tmp___10 == 0);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static struct option long_options___1[6]  = {      {"crypt-method", 1, (int *)((void *)0), 'c'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"system", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"sha-rounds", 1, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 525 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void process_flags___1(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  int tmp___0 ;
  char buf___0[8192] ;
  FILE *tmp___1 ;

  {
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 543
    c = getopt_long(argc, (char * const  *)argv, "c:hrs:", (struct option  const  *)(long_options___1),
                    (int *)((void *)0));
    }
#line 543
    if (! (c != -1)) {
#line 543
      goto while_break;
    }
    {
#line 556
    if (c == 99) {
#line 556
      goto case_99;
    }
#line 560
    if (c == 104) {
#line 560
      goto case_104;
    }
#line 563
    if (c == 114) {
#line 563
      goto case_114;
    }
#line 566
    if (c == 82) {
#line 566
      goto case_82;
    }
#line 570
    if (c == 115) {
#line 570
      goto case_115;
    }
#line 581
    goto switch_default;
    case_99: /* CIL Label */ 
#line 557
    crypt_method = optarg;
#line 558
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 561
    usage___1(0);
    }
#line 562
    goto switch_break;
    case_114: /* CIL Label */ 
#line 564
    rflg = (_Bool)1;
#line 565
    goto switch_break;
    case_82: /* CIL Label */ 
#line 567
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 571
    sflg = (_Bool)1;
#line 572
    tmp___0 = getlong((char const   *)optarg, & sha_rounds);
    }
#line 572
    if (tmp___0 == 0) {
      {
#line 573
      tmp = gettext("%s: invalid numeric argument \'%s\'\n");
#line 573
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 576
      usage___1(1);
      }
    }
#line 578
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 582
    usage___1(1);
    }
#line 583
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  if (optind != argc) {
#line 587
    if (optind + 1 != argc) {
      {
#line 589
      usage___1(1);
      }
    }
  }
#line 592
  if ((unsigned long )*(argv + optind) != (unsigned long )((void *)0)) {
    {
#line 593
    tmp___1 = freopen((char const   */* __restrict  */)*(argv + optind), (char const   */* __restrict  */)"r",
                      (FILE */* __restrict  */)stdin);
    }
#line 593
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 595
      snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%s: %s",
               Prog, *(argv + 1));
#line 596
      perror((char const   *)(buf___0));
#line 597
      fail_exit___1(1);
      }
    }
  }
  {
#line 602
  check_flags___0();
  }
#line 603
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void check_flags___0(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 614
  if (sflg) {
#line 614
    if (! ((unsigned long )((void *)0) != (unsigned long )crypt_method)) {
      {
#line 615
      tmp = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 615
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, "-s", "-c");
#line 618
      usage___1(1);
      }
    }
  }
#line 622
  if ((unsigned long )((void *)0) != (unsigned long )crypt_method) {
    {
#line 623
    tmp___1 = strcmp((char const   *)crypt_method, "DES");
    }
#line 623
    if (0 != tmp___1) {
      {
#line 623
      tmp___2 = strcmp((char const   *)crypt_method, "MD5");
      }
#line 623
      if (0 != tmp___2) {
        {
#line 623
        tmp___3 = strcmp((char const   *)crypt_method, "NONE");
        }
#line 623
        if (0 != tmp___3) {
          {
#line 623
          tmp___4 = strcmp((char const   *)crypt_method, "SHA256");
          }
#line 623
          if (0 != tmp___4) {
            {
#line 623
            tmp___5 = strcmp((char const   *)crypt_method, "SHA512");
            }
#line 623
            if (0 != tmp___5) {
              {
#line 631
              tmp___0 = gettext("%s: unsupported crypt method: %s\n");
#line 631
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                      Prog, crypt_method);
#line 634
              usage___1(1);
              }
            }
          }
        }
      }
    }
  }
#line 638
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void check_perms___0(void) 
{ 


  {
#line 688
  return;
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void open_files___1(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 701
  tmp___1 = pw_lock();
  }
#line 701
  if (tmp___1 == 0) {
    {
#line 702
    tmp = pw_dbname();
#line 702
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 705
    fail_exit___1(1);
    }
  }
#line 707
  pw_locked___1 = (_Bool)1;
#line 708
  if (is_shadow___0) {
    {
#line 709
    tmp___4 = spw_lock();
    }
#line 709
    if (tmp___4 == 0) {
      {
#line 710
      tmp___2 = spw_dbname();
#line 710
      tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 710
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2);
#line 713
      fail_exit___1(1);
      }
    }
#line 715
    spw_locked___1 = (_Bool)1;
  }
  {
#line 717
  tmp___7 = gr_lock();
  }
#line 717
  if (tmp___7 == 0) {
    {
#line 718
    tmp___5 = gr_dbname();
#line 718
    tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 718
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
#line 721
    fail_exit___1(1);
    }
  }
#line 723
  gr_locked = (_Bool)1;
#line 725
  if (is_shadow_grp) {
    {
#line 726
    tmp___10 = sgr_lock();
    }
#line 726
    if (tmp___10 == 0) {
      {
#line 727
      tmp___8 = sgr_dbname();
#line 727
      tmp___9 = gettext("%s: cannot lock %s; try again later.\n");
#line 727
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
#line 730
      fail_exit___1(1);
      }
    }
#line 732
    sgr_locked = (_Bool)1;
  }
  {
#line 736
  tmp___13 = pw_open(2);
  }
#line 736
  if (tmp___13 == 0) {
    {
#line 737
    tmp___11 = pw_dbname();
#line 737
    tmp___12 = gettext("%s: cannot open %s\n");
#line 737
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
            Prog, tmp___11);
#line 738
    fail_exit___1(1);
    }
  }
#line 740
  if (is_shadow___0) {
    {
#line 740
    tmp___16 = spw_open(2);
    }
#line 740
    if (tmp___16 == 0) {
      {
#line 741
      tmp___14 = spw_dbname();
#line 741
      tmp___15 = gettext("%s: cannot open %s\n");
#line 741
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
#line 742
      fail_exit___1(1);
      }
    }
  }
  {
#line 744
  tmp___19 = gr_open(2);
  }
#line 744
  if (tmp___19 == 0) {
    {
#line 745
    tmp___17 = gr_dbname();
#line 745
    tmp___18 = gettext("%s: cannot open %s\n");
#line 745
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
            Prog, tmp___17);
#line 746
    fail_exit___1(1);
    }
  }
#line 749
  if (is_shadow_grp) {
    {
#line 749
    tmp___22 = sgr_open(2);
    }
#line 749
    if (tmp___22 == 0) {
      {
#line 750
      tmp___20 = sgr_dbname();
#line 750
      tmp___21 = gettext("%s: cannot open %s\n");
#line 750
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
              Prog, tmp___20);
#line 751
      fail_exit___1(1);
      }
    }
  }
#line 754
  return;
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newusers.c"
static void close_files___1(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *old_locale___3 ;
  char *tmp___21 ;
  char *saved_locale___3 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char *old_locale___4 ;
  char *tmp___26 ;
  char *saved_locale___4 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char *old_locale___5 ;
  char *tmp___31 ;
  char *saved_locale___5 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  char *old_locale___6 ;
  char *tmp___36 ;
  char *saved_locale___6 ;
  char const   *tmp___37 ;
  int tmp___38 ;

  {
  {
#line 761
  tmp___3 = pw_close();
  }
#line 761
  if (tmp___3 == 0) {
    {
#line 762
    tmp = pw_dbname();
#line 762
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 762
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 763
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 763
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 763
      old_locale = tmp___1;
#line 763
      saved_locale = (char *)((void *)0);
      }
#line 763
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 763
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 763
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 763
        setlocale(6, "C");
        }
      }
      {
#line 763
      tmp___2 = pw_dbname();
#line 763
      syslog(3, "failure while writing changes to %s", tmp___2);
      }
#line 763
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 763
        setlocale(6, (char const   *)saved_locale);
#line 763
        free((void *)saved_locale);
        }
      }
#line 763
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 764
    fail_exit___1(1);
    }
  }
  {
#line 766
  tmp___8 = pw_unlock();
  }
#line 766
  if (tmp___8 == 0) {
    {
#line 767
    tmp___4 = pw_dbname();
#line 767
    tmp___5 = gettext("%s: failed to unlock %s\n");
#line 767
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            Prog, tmp___4);
    }
    {
#line 768
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 768
      tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 768
      old_locale___0 = tmp___6;
#line 768
      saved_locale___0 = (char *)((void *)0);
      }
#line 768
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 768
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 768
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 768
        setlocale(6, "C");
        }
      }
      {
#line 768
      tmp___7 = pw_dbname();
#line 768
      syslog(3, "failed to unlock %s", tmp___7);
      }
#line 768
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 768
        setlocale(6, (char const   *)saved_locale___0);
#line 768
        free((void *)saved_locale___0);
        }
      }
#line 768
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 771
  pw_locked___1 = (_Bool)0;
#line 773
  if (is_shadow___0) {
    {
#line 774
    tmp___13 = spw_close();
    }
#line 774
    if (tmp___13 == 0) {
      {
#line 775
      tmp___9 = spw_dbname();
#line 775
      tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 775
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 778
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 778
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 778
        old_locale___1 = tmp___11;
#line 778
        saved_locale___1 = (char *)((void *)0);
        }
#line 778
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 778
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 778
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 778
          setlocale(6, "C");
          }
        }
        {
#line 778
        tmp___12 = spw_dbname();
#line 778
        syslog(3, "failure while writing changes to %s", tmp___12);
        }
#line 778
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 778
          setlocale(6, (char const   *)saved_locale___1);
#line 778
          free((void *)saved_locale___1);
          }
        }
#line 778
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 779
      fail_exit___1(1);
      }
    }
    {
#line 781
    tmp___18 = spw_unlock();
    }
#line 781
    if (tmp___18 == 0) {
      {
#line 782
      tmp___14 = spw_dbname();
#line 782
      tmp___15 = gettext("%s: failed to unlock %s\n");
#line 782
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
      }
      {
#line 785
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 785
        tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 785
        old_locale___2 = tmp___16;
#line 785
        saved_locale___2 = (char *)((void *)0);
        }
#line 785
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 785
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 785
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 785
          setlocale(6, "C");
          }
        }
        {
#line 785
        tmp___17 = spw_dbname();
#line 785
        syslog(3, "failed to unlock %s", tmp___17);
        }
#line 785
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 785
          setlocale(6, (char const   *)saved_locale___2);
#line 785
          free((void *)saved_locale___2);
          }
        }
#line 785
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 788
    spw_locked___1 = (_Bool)0;
  }
  {
#line 791
  tmp___23 = gr_close();
  }
#line 791
  if (tmp___23 == 0) {
    {
#line 792
    tmp___19 = gr_dbname();
#line 792
    tmp___20 = gettext("%s: failure while writing changes to %s\n");
#line 792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
            Prog, tmp___19);
    }
    {
#line 795
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 795
      tmp___21 = setlocale(6, (char const   *)((void *)0));
#line 795
      old_locale___3 = tmp___21;
#line 795
      saved_locale___3 = (char *)((void *)0);
      }
#line 795
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
        {
#line 795
        saved_locale___3 = strdup((char const   *)old_locale___3);
        }
      }
#line 795
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
        {
#line 795
        setlocale(6, "C");
        }
      }
      {
#line 795
      tmp___22 = gr_dbname();
#line 795
      syslog(3, "failure while writing changes to %s", tmp___22);
      }
#line 795
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
        {
#line 795
        setlocale(6, (char const   *)saved_locale___3);
#line 795
        free((void *)saved_locale___3);
        }
      }
#line 795
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 796
    fail_exit___1(1);
    }
  }
  {
#line 798
  tmp___28 = gr_unlock();
  }
#line 798
  if (tmp___28 == 0) {
    {
#line 799
    tmp___24 = gr_dbname();
#line 799
    tmp___25 = gettext("%s: failed to unlock %s\n");
#line 799
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___25,
            Prog, tmp___24);
    }
    {
#line 802
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 802
      tmp___26 = setlocale(6, (char const   *)((void *)0));
#line 802
      old_locale___4 = tmp___26;
#line 802
      saved_locale___4 = (char *)((void *)0);
      }
#line 802
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
        {
#line 802
        saved_locale___4 = strdup((char const   *)old_locale___4);
        }
      }
#line 802
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 802
        setlocale(6, "C");
        }
      }
      {
#line 802
      tmp___27 = gr_dbname();
#line 802
      syslog(3, "failed to unlock %s", tmp___27);
      }
#line 802
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 802
        setlocale(6, (char const   *)saved_locale___4);
#line 802
        free((void *)saved_locale___4);
        }
      }
#line 802
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 805
  gr_locked = (_Bool)0;
#line 808
  if (is_shadow_grp) {
    {
#line 809
    tmp___33 = sgr_close();
    }
#line 809
    if (tmp___33 == 0) {
      {
#line 810
      tmp___29 = sgr_dbname();
#line 810
      tmp___30 = gettext("%s: failure while writing changes to %s\n");
#line 810
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
              Prog, tmp___29);
      }
      {
#line 813
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 813
        tmp___31 = setlocale(6, (char const   *)((void *)0));
#line 813
        old_locale___5 = tmp___31;
#line 813
        saved_locale___5 = (char *)((void *)0);
        }
#line 813
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
          {
#line 813
          saved_locale___5 = strdup((char const   *)old_locale___5);
          }
        }
#line 813
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
          {
#line 813
          setlocale(6, "C");
          }
        }
        {
#line 813
        tmp___32 = sgr_dbname();
#line 813
        syslog(3, "failure while writing changes to %s", tmp___32);
        }
#line 813
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
          {
#line 813
          setlocale(6, (char const   *)saved_locale___5);
#line 813
          free((void *)saved_locale___5);
          }
        }
#line 813
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 814
      fail_exit___1(1);
      }
    }
    {
#line 816
    tmp___38 = sgr_unlock();
    }
#line 816
    if (tmp___38 == 0) {
      {
#line 817
      tmp___34 = sgr_dbname();
#line 817
      tmp___35 = gettext("%s: failed to unlock %s\n");
#line 817
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
              Prog, tmp___34);
      }
      {
#line 820
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 820
        tmp___36 = setlocale(6, (char const   *)((void *)0));
#line 820
        old_locale___6 = tmp___36;
#line 820
        saved_locale___6 = (char *)((void *)0);
        }
#line 820
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___6) {
          {
#line 820
          saved_locale___6 = strdup((char const   *)old_locale___6);
          }
        }
#line 820
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
          {
#line 820
          setlocale(6, "C");
          }
        }
        {
#line 820
        tmp___37 = sgr_dbname();
#line 820
        syslog(3, "failed to unlock %s", tmp___37);
        }
#line 820
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
          {
#line 820
          setlocale(6, (char const   *)saved_locale___6);
#line 820
          free((void *)saved_locale___6);
          }
        }
#line 820
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 823
    sgr_locked = (_Bool)0;
  }
#line 826
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___2(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___2  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___2  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___2  ;
#line 72
static int copy_entry___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___2(char const   *filename___0 ) ;
#line 83
static int copy_symlink___2(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___2(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___2(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___2(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___2(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___2(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___2 == (unsigned long )ln) {
    {
#line 149
    links___2 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___2;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___2(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___2)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___2)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___2;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___2);
#line 199
  dst_len = strlen(dst_orig___2);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___2, name___3 + src_len);
#line 207
  lp->ln_next = links___2;
#line 208
  links___2 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___2(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___2(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___2(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___2(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___2(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___2(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___2(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___2(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___2(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___2)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___2)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___2(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___2);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___2, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___2);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___2);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___2);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___2, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___2(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___2(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___2(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___2(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___2(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___2(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___2(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___2(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___2(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___2[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___2[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___3(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___3(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___3[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___3[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___3  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___3(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___3  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___7  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___3(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___7) {
#line 70
      size___7 = i + 100;
#line 71
      if (members___3) {
        {
#line 72
        tmp = realloc((void *)members___3, (unsigned long )size___7 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___7 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___3) {
          {
#line 81
          free((void *)members___3);
          }
        }
#line 82
        members___3 = (char **)0;
#line 83
        size___7 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___3 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___3 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___3 + i) = (char *)0;
#line 99
  return (members___3);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___3  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___8  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___3[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___3  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___3(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___3(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___3  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___3  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___3  ;
#line 72
static int copy_entry___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___3(char const   *filename___0 ) ;
#line 83
static int copy_symlink___3(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___3(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___3(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___3(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___3(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___3(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___3 == (unsigned long )ln) {
    {
#line 149
    links___3 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___3;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___3(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___3)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___3)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___3;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___3);
#line 199
  dst_len = strlen(dst_orig___3);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___3, name___3 + src_len);
#line 207
  lp->ln_next = links___3;
#line 208
  links___3 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___3(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___3(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___3(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___3(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___3(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___3(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___3(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___3(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___3(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___3)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___3)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___3(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___3);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___3, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___3);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___3);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___3);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___3, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___3(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___3(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___3(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___3(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___3(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___3(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___3(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___3(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___3(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 332 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 580
extern int putchar(int __c ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 700 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 213 "../lib/prototypes.h"
extern char **add_list(char ** , char const   * ) ;
#line 214
extern char **del_list(char ** , char const   * ) ;
#line 215
extern char **dup_list(char * const  * ) ;
#line 216
extern _Bool is_on_list(char * const  *list , char const   *member ) ;
#line 217
extern char **comma_to_list(char const   * ) ;
#line 239
extern struct passwd *get_my_pwent(void) ;
#line 272
extern void pwd_init(void) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool is_shadowgrp  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool aflg  =    (_Bool)0;
#line 69 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool Aflg  =    (_Bool)0;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool dflg___0  =    (_Bool)0;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool Mflg___0  =    (_Bool)0;
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool rflg___0  =    (_Bool)0;
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool Rflg  =    (_Bool)0;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static char *group  =    (char *)((void *)0);
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static char *user  =    (char *)((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static char *members___4  =    (char *)((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static char *admins  =    (char *)((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static char *myname  =    (char *)((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static uid_t bywho  ;
#line 97
static void usage___2(int status ) ;
#line 98
static void catch_signals___0(int killed ) ;
#line 99
static _Bool is_valid_user_list(char const   *users ) ;
#line 100
static void process_flags___2(int argc , char **argv ) ;
#line 101
static void check_flags___1(int argc , int opt_index ) ;
#line 102
static void open_files___2(void) ;
#line 103
static void close_files___2(void) ;
#line 105
static void get_group(struct group *gr , struct sgrp *sg ) ;
#line 106
static void check_perms___1(struct group  const  *gr , struct sgrp  const  *sg ) ;
#line 107
static void update_group(struct group *gr , struct sgrp *sg ) ;
#line 108
static void change_passwd(struct group *gr , struct sgrp *sg ) ;
#line 115
static void log_gpasswd_failure(char const   *suffix ) ;
#line 116
static void log_gpasswd_failure_system(void *arg  __attribute__((__unused__)) ) ;
#line 117
static void log_gpasswd_failure_group(void *arg  __attribute__((__unused__)) ) ;
#line 119
static void log_gpasswd_failure_gshadow(void *arg  __attribute__((__unused__)) ) ;
#line 121
static void log_gpasswd_success(char const   *suffix ) ;
#line 122
static void log_gpasswd_success_system(void *arg  __attribute__((__unused__)) ) ;
#line 123
static void log_gpasswd_success_group(void *arg  __attribute__((__unused__)) ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void usage___2(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 130
  if (0 != status) {
#line 130
    tmp = stderr;
  } else {
#line 130
    tmp = stdout;
  }
  {
#line 130
  usageout = tmp;
#line 131
  tmp___0 = gettext("Usage: %s [option] GROUP\n\nOptions:\n");
#line 131
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 136
  tmp___1 = gettext("  -a, --add USER                add USER to GROUP\n");
#line 136
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 137
  tmp___2 = gettext("  -d, --delete USER             remove USER from GROUP\n");
#line 137
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 138
  tmp___3 = gettext("  -h, --help                    display this help message and exit\n");
#line 138
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 139
  tmp___4 = gettext("  -Q, --root CHROOT_DIR         directory to chroot into\n");
#line 139
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 140
  tmp___5 = gettext("  -r, --remove-password         remove the GROUP\'s password\n");
#line 140
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 141
  tmp___6 = gettext("  -R, --restrict                restrict access to GROUP to its members\n");
#line 141
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 142
  tmp___7 = gettext("  -M, --members USER,...        set the list of members of GROUP\n");
#line 142
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 144
  tmp___8 = gettext("  -A, --administrators ADMIN,...\n                                set the list of administrators for GROUP\n");
#line 144
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 146
  tmp___9 = gettext("Except for the -A and -M options, the options cannot be combined.\n");
#line 146
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)usageout);
#line 150
  exit(status);
  }
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static struct termios sgtty  ;
#line 161 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void catch_signals___0(int killed ) 
{ 


  {
#line 165
  if (0 != killed) {
    {
#line 166
    tcsetattr(0, 0, (struct termios  const  *)(& sgtty));
    }
  } else {
    {
#line 168
    tcgetattr(0, & sgtty);
    }
  }
#line 171
  if (0 != killed) {
    {
#line 172
    putchar('\n');
#line 173
    fflush(stdout);
#line 174
    exit(killed);
    }
  }
#line 176
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static _Bool is_valid_user_list(char const   *users ) 
{ 
  char const   *username___0 ;
  char *end ;
  _Bool is_valid ;
  char *tmpusers ;
  char *tmp ;
  char *tmp___0 ;
  struct passwd *tmp___1 ;

  {
  {
#line 190
  is_valid = (_Bool)1;
#line 191
  tmp = xstrdup(users);
#line 191
  tmpusers = tmp;
#line 193
  username___0 = (char const   *)tmpusers;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if ((unsigned long )((void *)0) != (unsigned long )username___0) {
#line 193
      if (! (0 != (int )*username___0)) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
    {
#line 196
    end = strchr(username___0, ',');
    }
#line 197
    if ((unsigned long )((void *)0) != (unsigned long )end) {
#line 198
      *end = (char )'\000';
#line 199
      end ++;
    }
    {
#line 207
    tmp___1 = getpwnam(username___0);
    }
#line 207
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 208
      tmp___0 = gettext("%s: user \'%s\' does not exist\n");
#line 208
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, username___0);
#line 210
      is_valid = (_Bool)0;
      }
    }
#line 193
    username___0 = (char const   *)end;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  free((void *)tmpusers);
  }
#line 216
  return (is_valid);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void failure___0(void) 
{ 
  char *tmp ;

  {
  {
#line 221
  tmp = gettext("%s: Permission denied.\n");
#line 221
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, Prog);
#line 222
  log_gpasswd_failure(": Permission denied");
#line 223
  exit(1);
  }
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static struct option long_options___2[9]  = 
#line 232
  {      {"add", 1, (int *)((void *)0), 'a'}, 
        {"administrators", 1, (int *)((void *)0), 'A'}, 
        {"delete", 1, (int *)((void *)0), 'd'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"members", 1, (int *)((void *)0), 'M'}, 
        {"root", 1, (int *)((void *)0), 'Q'}, 
        {"remove-password", 0, (int *)((void *)0), 'r'}, 
        {"restrict", 0, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 229 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void process_flags___2(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  struct passwd *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 244
    c = getopt_long(argc, (char * const  *)argv, "a:A:d:ghM:Q:rR", (struct option  const  *)(long_options___2),
                    (int *)((void *)0));
    }
#line 244
    if (! (c != -1)) {
#line 244
      goto while_break;
    }
    {
#line 247
    if (c == 97) {
#line 247
      goto case_97;
    }
#line 259
    if (c == 65) {
#line 259
      goto case_65;
    }
#line 273
    if (c == 100) {
#line 273
      goto case_100;
    }
#line 277
    if (c == 103) {
#line 277
      goto case_103;
    }
#line 279
    if (c == 104) {
#line 279
      goto case_104;
    }
#line 282
    if (c == 77) {
#line 282
      goto case_77;
    }
#line 289
    if (c == 81) {
#line 289
      goto case_81;
    }
#line 291
    if (c == 114) {
#line 291
      goto case_114;
    }
#line 294
    if (c == 82) {
#line 294
      goto case_82;
    }
#line 297
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 248
    aflg = (_Bool)1;
#line 249
    user = optarg;
#line 251
    tmp___0 = getpwnam((char const   *)user);
    }
#line 251
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 252
      tmp = gettext("%s: user \'%s\' does not exist\n");
#line 252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, user);
#line 255
      exit(3);
      }
    }
#line 257
    goto switch_break;
    case_65: /* CIL Label */ 
#line 260
    if (! is_shadowgrp) {
      {
#line 261
      tmp___1 = gettext("%s: shadow group passwords required for -A\n");
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog);
#line 264
      exit(17);
      }
    }
    {
#line 266
    admins = optarg;
#line 267
    tmp___2 = is_valid_user_list((char const   *)admins);
    }
#line 267
    if (! tmp___2) {
      {
#line 268
      exit(3);
      }
    }
#line 270
    Aflg = (_Bool)1;
#line 271
    goto switch_break;
    case_100: /* CIL Label */ 
#line 274
    dflg___0 = (_Bool)1;
#line 275
    user = optarg;
#line 276
    goto switch_break;
    case_103: /* CIL Label */ 
#line 278
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 280
    usage___2(0);
    }
#line 281
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 283
    members___4 = optarg;
#line 284
    tmp___3 = is_valid_user_list((char const   *)members___4);
    }
#line 284
    if (! tmp___3) {
      {
#line 285
      exit(3);
      }
    }
#line 287
    Mflg___0 = (_Bool)1;
#line 288
    goto switch_break;
    case_81: /* CIL Label */ 
#line 290
    goto switch_break;
    case_114: /* CIL Label */ 
#line 292
    rflg___0 = (_Bool)1;
#line 293
    goto switch_break;
    case_82: /* CIL Label */ 
#line 295
    Rflg = (_Bool)1;
#line 296
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 298
    usage___2(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  group = *(argv + optind);
#line 305
  check_flags___1(argc, optind);
  }
#line 306
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void check_flags___1(int argc , int opt_index ) 
{ 
  int exclusive___0 ;

  {
#line 313
  exclusive___0 = 0;
#line 317
  if (aflg) {
#line 318
    exclusive___0 ++;
  }
#line 320
  if (dflg___0) {
#line 321
    exclusive___0 ++;
  }
#line 323
  if (rflg___0) {
#line 324
    exclusive___0 ++;
  }
#line 326
  if (Rflg) {
#line 327
    exclusive___0 ++;
  }
#line 329
  if (Aflg) {
#line 330
    exclusive___0 ++;
  } else
#line 329
  if (Mflg___0) {
#line 330
    exclusive___0 ++;
  }
#line 332
  if (exclusive___0 > 1) {
    {
#line 333
    usage___2(2);
    }
  }
#line 339
  if (argc != opt_index + 1) {
    {
#line 340
    usage___2(2);
    }
  } else
#line 339
  if ((unsigned long )((void *)0) == (unsigned long )group) {
    {
#line 340
    usage___2(2);
    }
  }
#line 342
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void open_files___2(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *old_locale ;
  char *tmp___7 ;
  char *saved_locale ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *old_locale___0 ;
  char *tmp___12 ;
  char *saved_locale___0 ;
  char const   *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 351
  tmp___1 = gr_lock();
  }
#line 351
  if (tmp___1 == 0) {
    {
#line 352
    tmp = gr_dbname();
#line 352
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 352
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 355
    exit(1);
    }
  }
  {
#line 357
  add_cleanup(& cleanup_unlock_group, (void *)0);
  }
#line 360
  if (is_shadowgrp) {
    {
#line 361
    tmp___4 = sgr_lock();
    }
#line 361
    if (tmp___4 == 0) {
      {
#line 362
      tmp___2 = sgr_dbname();
#line 362
      tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 362
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2);
#line 365
      exit(1);
      }
    }
    {
#line 367
    add_cleanup(& cleanup_unlock_gshadow, (void *)0);
    }
  }
  {
#line 371
  add_cleanup(& log_gpasswd_failure_system, (void *)0);
#line 373
  tmp___9 = gr_open(2);
  }
#line 373
  if (tmp___9 == 0) {
    {
#line 374
    tmp___5 = gr_dbname();
#line 374
    tmp___6 = gettext("%s: cannot open %s\n");
#line 374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
    }
    {
#line 377
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 377
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 377
      old_locale = tmp___7;
#line 377
      saved_locale = (char *)((void *)0);
      }
#line 377
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 377
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 377
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 377
        setlocale(6, "C");
        }
      }
      {
#line 377
      tmp___8 = gr_dbname();
#line 377
      syslog(4, "cannot open %s", tmp___8);
      }
#line 377
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 377
        setlocale(6, (char const   *)saved_locale);
#line 377
        free((void *)saved_locale);
        }
      }
#line 377
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 378
    exit(1);
    }
  }
#line 382
  if (is_shadowgrp) {
    {
#line 383
    tmp___14 = sgr_open(2);
    }
#line 383
    if (tmp___14 == 0) {
      {
#line 384
      tmp___10 = sgr_dbname();
#line 384
      tmp___11 = gettext("%s: cannot open %s\n");
#line 384
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
              Prog, tmp___10);
      }
      {
#line 387
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 387
        tmp___12 = setlocale(6, (char const   *)((void *)0));
#line 387
        old_locale___0 = tmp___12;
#line 387
        saved_locale___0 = (char *)((void *)0);
        }
#line 387
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 387
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 387
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 387
          setlocale(6, "C");
          }
        }
        {
#line 387
        tmp___13 = sgr_dbname();
#line 387
        syslog(4, "cannot open %s", tmp___13);
        }
#line 387
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 387
          setlocale(6, (char const   *)saved_locale___0);
#line 387
          free((void *)saved_locale___0);
          }
        }
#line 387
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 388
      exit(1);
      }
    }
    {
#line 390
    add_cleanup(& log_gpasswd_failure_gshadow, (void *)0);
    }
  }
  {
#line 394
  add_cleanup(& log_gpasswd_failure_group, (void *)0);
#line 395
  del_cleanup(& log_gpasswd_failure_system);
  }
#line 396
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_failure(char const   *suffix ) 
{ 
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char *old_locale___0 ;
  char *tmp___0 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___1 ;
  char *saved_locale___1 ;
  char *old_locale___2 ;
  char *tmp___2 ;
  char *saved_locale___2 ;
  char *old_locale___3 ;
  char *tmp___3 ;
  char *saved_locale___3 ;
  char *old_locale___4 ;
  char *tmp___4 ;
  char *saved_locale___4 ;
  char *old_locale___5 ;
  char *tmp___5 ;
  char *saved_locale___5 ;

  {
#line 403
  if (aflg) {
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 404
      tmp = setlocale(6, (char const   *)((void *)0));
#line 404
      old_locale = tmp;
#line 404
      saved_locale = (char *)((void *)0);
      }
#line 404
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 404
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 404
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 404
        setlocale(6, "C");
        }
      }
      {
#line 404
      syslog(3, "%s failed to add user %s to group %s%s", myname, user, group, suffix);
      }
#line 404
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 404
        setlocale(6, (char const   *)saved_locale);
#line 404
        free((void *)saved_locale);
        }
      }
#line 404
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 417
  if (dflg___0) {
    {
#line 418
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 418
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 418
      old_locale___0 = tmp___0;
#line 418
      saved_locale___0 = (char *)((void *)0);
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 418
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 418
        setlocale(6, "C");
        }
      }
      {
#line 418
      syslog(3, "%s failed to remove user %s from group %s%s", myname, user, group,
             suffix);
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 418
        setlocale(6, (char const   *)saved_locale___0);
#line 418
        free((void *)saved_locale___0);
        }
      }
#line 418
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 431
  if (rflg___0) {
    {
#line 432
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 432
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 432
      old_locale___1 = tmp___1;
#line 432
      saved_locale___1 = (char *)((void *)0);
      }
#line 432
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 432
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 432
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 432
        setlocale(6, "C");
        }
      }
      {
#line 432
      syslog(3, "%s failed to remove password of group %s%s", myname, group, suffix);
      }
#line 432
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 432
        setlocale(6, (char const   *)saved_locale___1);
#line 432
        free((void *)saved_locale___1);
        }
      }
#line 432
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 445
  if (Rflg) {
    {
#line 446
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 446
      tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 446
      old_locale___2 = tmp___2;
#line 446
      saved_locale___2 = (char *)((void *)0);
      }
#line 446
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 446
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 446
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 446
        setlocale(6, "C");
        }
      }
      {
#line 446
      syslog(3, "%s failed to restrict access to group %s%s", myname, group, suffix);
      }
#line 446
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 446
        setlocale(6, (char const   *)saved_locale___2);
#line 446
        free((void *)saved_locale___2);
        }
      }
#line 446
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 459
  if (Aflg) {
#line 459
    goto _L;
  } else
#line 459
  if (Mflg___0) {
    _L: /* CIL Label */ 
#line 461
    if (Aflg) {
      {
#line 462
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 462
        tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 462
        old_locale___3 = tmp___3;
#line 462
        saved_locale___3 = (char *)((void *)0);
        }
#line 462
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
          {
#line 462
          saved_locale___3 = strdup((char const   *)old_locale___3);
          }
        }
#line 462
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 462
          setlocale(6, "C");
          }
        }
        {
#line 462
        syslog(3, "%s failed to set the administrators of group %s to %s%s", myname,
               group, admins, suffix);
        }
#line 462
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 462
          setlocale(6, (char const   *)saved_locale___3);
#line 462
          free((void *)saved_locale___3);
          }
        }
#line 462
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 477
    if (Mflg___0) {
      {
#line 478
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 478
        tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 478
        old_locale___4 = tmp___4;
#line 478
        saved_locale___4 = (char *)((void *)0);
        }
#line 478
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
          {
#line 478
          saved_locale___4 = strdup((char const   *)old_locale___4);
          }
        }
#line 478
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
          {
#line 478
          setlocale(6, "C");
          }
        }
        {
#line 478
        syslog(3, "%s failed to set the members of group %s to %s%s", myname, group,
               members___4, suffix);
        }
#line 478
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
          {
#line 478
          setlocale(6, (char const   *)saved_locale___4);
#line 478
          free((void *)saved_locale___4);
          }
        }
#line 478
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 493
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 493
      tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 493
      old_locale___5 = tmp___5;
#line 493
      saved_locale___5 = (char *)((void *)0);
      }
#line 493
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
        {
#line 493
        saved_locale___5 = strdup((char const   *)old_locale___5);
        }
      }
#line 493
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
        {
#line 493
        setlocale(6, "C");
        }
      }
      {
#line 493
      syslog(3, "%s failed to change password of group %s%s", myname, group, suffix);
      }
#line 493
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
        {
#line 493
        setlocale(6, (char const   *)saved_locale___5);
#line 493
        free((void *)saved_locale___5);
        }
      }
#line 493
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 507
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_failure_system(void *arg  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 511
  log_gpasswd_failure("");
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_failure_group(void *arg  __attribute__((__unused__)) ) 
{ 
  char buf___0[1024] ;
  char const   *tmp ;

  {
  {
#line 517
  tmp = gr_dbname();
#line 517
  snprintf((char */* __restrict  */)(buf___0), (size_t )1023, (char const   */* __restrict  */)" in %s",
           tmp);
#line 518
  buf___0[1023] = (char )'\000';
#line 519
  log_gpasswd_failure((char const   *)(buf___0));
  }
#line 520
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_failure_gshadow(void *arg  __attribute__((__unused__)) ) 
{ 
  char buf___0[1024] ;
  char const   *tmp ;

  {
  {
#line 526
  tmp = sgr_dbname();
#line 526
  snprintf((char */* __restrict  */)(buf___0), (size_t )1023, (char const   */* __restrict  */)" in %s",
           tmp);
#line 527
  buf___0[1023] = (char )'\000';
#line 528
  log_gpasswd_failure((char const   *)(buf___0));
  }
#line 529
  return;
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_success(char const   *suffix ) 
{ 
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char *old_locale___0 ;
  char *tmp___0 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___1 ;
  char *saved_locale___1 ;
  char *old_locale___2 ;
  char *tmp___2 ;
  char *saved_locale___2 ;
  char *old_locale___3 ;
  char *tmp___3 ;
  char *saved_locale___3 ;
  char *old_locale___4 ;
  char *tmp___4 ;
  char *saved_locale___4 ;
  char *old_locale___5 ;
  char *tmp___5 ;
  char *saved_locale___5 ;

  {
#line 537
  if (aflg) {
    {
#line 538
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 538
      tmp = setlocale(6, (char const   *)((void *)0));
#line 538
      old_locale = tmp;
#line 538
      saved_locale = (char *)((void *)0);
      }
#line 538
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 538
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 538
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 538
        setlocale(6, "C");
        }
      }
      {
#line 538
      syslog(6, "user %s added by %s to group %s%s", user, myname, group, suffix);
      }
#line 538
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 538
        setlocale(6, (char const   *)saved_locale);
#line 538
        free((void *)saved_locale);
        }
      }
#line 538
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 551
  if (dflg___0) {
    {
#line 552
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 552
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 552
      old_locale___0 = tmp___0;
#line 552
      saved_locale___0 = (char *)((void *)0);
      }
#line 552
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 552
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 552
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 552
        setlocale(6, "C");
        }
      }
      {
#line 552
      syslog(6, "user %s removed by %s from group %s%s", user, myname, group, suffix);
      }
#line 552
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 552
        setlocale(6, (char const   *)saved_locale___0);
#line 552
        free((void *)saved_locale___0);
        }
      }
#line 552
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 565
  if (rflg___0) {
    {
#line 566
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 566
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 566
      old_locale___1 = tmp___1;
#line 566
      saved_locale___1 = (char *)((void *)0);
      }
#line 566
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 566
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 566
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 566
        setlocale(6, "C");
        }
      }
      {
#line 566
      syslog(6, "password of group %s removed by %s%s", group, myname, suffix);
      }
#line 566
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 566
        setlocale(6, (char const   *)saved_locale___1);
#line 566
        free((void *)saved_locale___1);
        }
      }
#line 566
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 579
  if (Rflg) {
    {
#line 580
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 580
      tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 580
      old_locale___2 = tmp___2;
#line 580
      saved_locale___2 = (char *)((void *)0);
      }
#line 580
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 580
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 580
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 580
        setlocale(6, "C");
        }
      }
      {
#line 580
      syslog(6, "access to group %s restricted by %s%s", group, myname, suffix);
      }
#line 580
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 580
        setlocale(6, (char const   *)saved_locale___2);
#line 580
        free((void *)saved_locale___2);
        }
      }
#line 580
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 593
  if (Aflg) {
#line 593
    goto _L;
  } else
#line 593
  if (Mflg___0) {
    _L: /* CIL Label */ 
#line 595
    if (Aflg) {
      {
#line 596
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 596
        tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 596
        old_locale___3 = tmp___3;
#line 596
        saved_locale___3 = (char *)((void *)0);
        }
#line 596
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
          {
#line 596
          saved_locale___3 = strdup((char const   *)old_locale___3);
          }
        }
#line 596
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 596
          setlocale(6, "C");
          }
        }
        {
#line 596
        syslog(6, "administrators of group %s set by %s to %s%s", group, myname, admins,
               suffix);
        }
#line 596
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 596
          setlocale(6, (char const   *)saved_locale___3);
#line 596
          free((void *)saved_locale___3);
          }
        }
#line 596
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 611
    if (Mflg___0) {
      {
#line 612
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 612
        tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 612
        old_locale___4 = tmp___4;
#line 612
        saved_locale___4 = (char *)((void *)0);
        }
#line 612
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
          {
#line 612
          saved_locale___4 = strdup((char const   *)old_locale___4);
          }
        }
#line 612
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
          {
#line 612
          setlocale(6, "C");
          }
        }
        {
#line 612
        syslog(6, "members of group %s set by %s to %s%s", group, myname, members___4,
               suffix);
        }
#line 612
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
          {
#line 612
          setlocale(6, (char const   *)saved_locale___4);
#line 612
          free((void *)saved_locale___4);
          }
        }
#line 612
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 627
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 627
      tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 627
      old_locale___5 = tmp___5;
#line 627
      saved_locale___5 = (char *)((void *)0);
      }
#line 627
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
        {
#line 627
        saved_locale___5 = strdup((char const   *)old_locale___5);
        }
      }
#line 627
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
        {
#line 627
        setlocale(6, "C");
        }
      }
      {
#line 627
      syslog(6, "password of group %s changed by %s%s", group, myname, suffix);
      }
#line 627
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
        {
#line 627
        setlocale(6, (char const   *)saved_locale___5);
#line 627
        free((void *)saved_locale___5);
        }
      }
#line 627
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 641
  return;
}
}
#line 643 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_success_system(void *arg  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 645
  log_gpasswd_success("");
  }
#line 646
  return;
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void log_gpasswd_success_group(void *arg  __attribute__((__unused__)) ) 
{ 
  char buf___0[1024] ;
  char const   *tmp ;

  {
  {
#line 651
  tmp = gr_dbname();
#line 651
  snprintf((char */* __restrict  */)(buf___0), (size_t )1023, (char const   */* __restrict  */)" in %s",
           tmp);
#line 652
  buf___0[1023] = (char )'\000';
#line 653
  log_gpasswd_success((char const   *)(buf___0));
  }
#line 654
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void close_files___2(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 665
  tmp___1 = gr_close();
  }
#line 665
  if (tmp___1 == 0) {
    {
#line 666
    tmp = gr_dbname();
#line 666
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 666
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 669
    exit(1);
    }
  }
  {
#line 671
  add_cleanup(& log_gpasswd_success_group, (void *)0);
#line 672
  del_cleanup(& log_gpasswd_failure_group);
#line 674
  cleanup_unlock_group((void *)0);
#line 675
  del_cleanup(& cleanup_unlock_group);
  }
#line 678
  if (is_shadowgrp) {
    {
#line 679
    tmp___4 = sgr_close();
    }
#line 679
    if (tmp___4 == 0) {
      {
#line 680
      tmp___2 = sgr_dbname();
#line 680
      tmp___3 = gettext("%s: failure while writing changes to %s\n");
#line 680
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2);
#line 683
      exit(1);
      }
    }
    {
#line 685
    del_cleanup(& log_gpasswd_failure_gshadow);
#line 687
    cleanup_unlock_gshadow((void *)0);
#line 688
    del_cleanup(& cleanup_unlock_gshadow);
    }
  }
  {
#line 692
  log_gpasswd_success_system((void *)0);
#line 693
  del_cleanup(& log_gpasswd_success_group);
  }
#line 694
  return;
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void check_perms___1(struct group  const  *gr , struct sgrp  const  *sg ) 
{ 
  _Bool tmp ;

  {
#line 711
  if (! (0U == bywho)) {
#line 711
    if (Aflg) {
      {
#line 712
      failure___0();
      }
    } else
#line 711
    if (Mflg___0) {
      {
#line 712
      failure___0();
      }
    }
  }
#line 716
  if (is_shadowgrp) {
#line 724
    if (! (0U == bywho)) {
      {
#line 724
      tmp = is_on_list((char * const  *)sg->sg_adm, (char const   *)myname);
      }
#line 724
      if (! tmp) {
        {
#line 725
        failure___0();
        }
      }
    }
  } else
#line 755
  if (! (0U == bywho)) {
    {
#line 756
    failure___0();
    }
  }
#line 760
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void update_group(struct group *gr , struct sgrp *sg ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 771
  tmp___1 = gr_update((struct group  const  *)gr);
  }
#line 771
  if (tmp___1 == 0) {
    {
#line 772
    tmp = gr_dbname();
#line 772
    tmp___0 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 772
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp, gr->gr_name);
#line 775
    exit(1);
    }
  }
#line 778
  if (is_shadowgrp) {
    {
#line 778
    tmp___4 = sgr_update((struct sgrp  const  *)sg);
    }
#line 778
    if (tmp___4 == 0) {
      {
#line 779
      tmp___2 = sgr_dbname();
#line 779
      tmp___3 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 779
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2, sg->sg_name);
#line 782
      exit(1);
      }
    }
  }
#line 785
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void get_group(struct group *gr , struct sgrp *sg ) 
{ 
  struct group  const  *tmpgr ;
  struct sgrp  const  *tmpsg ;
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *old_locale___0 ;
  char *tmp___8 ;
  char *saved_locale___0 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *old_locale___1 ;
  char *tmp___13 ;
  char *saved_locale___1 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *old_locale___2 ;
  char *tmp___19 ;
  char *saved_locale___2 ;
  char const   *tmp___20 ;
  int tmp___21 ;

  {
  {
#line 801
  tmpgr = (struct group  const  *)((void *)0);
#line 803
  tmpsg = (struct sgrp  const  *)((void *)0);
#line 806
  tmp___3 = gr_open(0);
  }
#line 806
  if (tmp___3 == 0) {
    {
#line 807
    tmp = gr_dbname();
#line 807
    tmp___0 = gettext("%s: cannot open %s\n");
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 808
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 808
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 808
      old_locale = tmp___1;
#line 808
      saved_locale = (char *)((void *)0);
      }
#line 808
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 808
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 808
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 808
        setlocale(6, "C");
        }
      }
      {
#line 808
      tmp___2 = gr_dbname();
#line 808
      syslog(4, "cannot open %s", tmp___2);
      }
#line 808
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 808
        setlocale(6, (char const   *)saved_locale);
#line 808
        free((void *)saved_locale);
        }
      }
#line 808
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 809
    exit(1);
    }
  }
  {
#line 812
  tmpgr = gr_locate((char const   *)group);
  }
#line 813
  if ((unsigned long )((void *)0) == (unsigned long )tmpgr) {
    {
#line 814
    tmp___4 = gr_dbname();
#line 814
    tmp___5 = gettext("%s: group \'%s\' does not exist in %s\n");
#line 814
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            Prog, group, tmp___4);
#line 817
    exit(3);
    }
  }
  {
#line 820
  *gr = (struct group )*tmpgr;
#line 821
  gr->gr_name = xstrdup((char const   *)tmpgr->gr_name);
#line 822
  gr->gr_passwd = xstrdup((char const   *)tmpgr->gr_passwd);
#line 823
  gr->gr_mem = dup_list((char * const  *)tmpgr->gr_mem);
#line 825
  tmp___10 = gr_close();
  }
#line 825
  if (tmp___10 == 0) {
    {
#line 826
    tmp___6 = gr_dbname();
#line 826
    tmp___7 = gettext("%s: failure while closing read-only %s\n");
#line 826
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            Prog, tmp___6);
    }
    {
#line 829
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 829
      tmp___8 = setlocale(6, (char const   *)((void *)0));
#line 829
      old_locale___0 = tmp___8;
#line 829
      saved_locale___0 = (char *)((void *)0);
      }
#line 829
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 829
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 829
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 829
        setlocale(6, "C");
        }
      }
      {
#line 829
      tmp___9 = gr_dbname();
#line 829
      syslog(3, "failure while closing read-only %s", tmp___9);
      }
#line 829
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 829
        setlocale(6, (char const   *)saved_locale___0);
#line 829
        free((void *)saved_locale___0);
        }
      }
#line 829
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 832
    exit(1);
    }
  }
#line 836
  if (is_shadowgrp) {
    {
#line 837
    tmp___15 = sgr_open(0);
    }
#line 837
    if (tmp___15 == 0) {
      {
#line 838
      tmp___11 = sgr_dbname();
#line 838
      tmp___12 = gettext("%s: cannot open %s\n");
#line 838
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
              Prog, tmp___11);
      }
      {
#line 841
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 841
        tmp___13 = setlocale(6, (char const   *)((void *)0));
#line 841
        old_locale___1 = tmp___13;
#line 841
        saved_locale___1 = (char *)((void *)0);
        }
#line 841
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 841
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 841
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 841
          setlocale(6, "C");
          }
        }
        {
#line 841
        tmp___14 = sgr_dbname();
#line 841
        syslog(4, "cannot open %s", tmp___14);
        }
#line 841
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 841
          setlocale(6, (char const   *)saved_locale___1);
#line 841
          free((void *)saved_locale___1);
          }
        }
#line 841
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 842
      exit(1);
      }
    }
    {
#line 844
    tmpsg = sgr_locate((char const   *)group);
    }
#line 845
    if ((unsigned long )((void *)0) != (unsigned long )tmpsg) {
      {
#line 846
      *sg = (struct sgrp )*tmpsg;
#line 847
      sg->sg_name = xstrdup((char const   *)tmpsg->sg_name);
#line 848
      sg->sg_passwd = xstrdup((char const   *)tmpsg->sg_passwd);
#line 850
      sg->sg_mem = dup_list((char * const  *)tmpsg->sg_mem);
#line 851
      sg->sg_adm = dup_list((char * const  *)tmpsg->sg_adm);
      }
    } else {
      {
#line 853
      sg->sg_name = xstrdup((char const   *)group);
#line 854
      sg->sg_passwd = gr->gr_passwd;
#line 855
      gr->gr_passwd = (char *)"x";
#line 857
      sg->sg_mem = dup_list((char * const  *)gr->gr_mem);
#line 859
      tmp___16 = xmalloc(sizeof(char *) * 2UL);
#line 859
      sg->sg_adm = (char **)tmp___16;
#line 867
      *(sg->sg_adm + 0) = (char *)((void *)0);
      }
    }
    {
#line 871
    tmp___21 = sgr_close();
    }
#line 871
    if (tmp___21 == 0) {
      {
#line 872
      tmp___17 = sgr_dbname();
#line 872
      tmp___18 = gettext("%s: failure while closing read-only %s\n");
#line 872
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
              Prog, tmp___17);
      }
      {
#line 875
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 875
        tmp___19 = setlocale(6, (char const   *)((void *)0));
#line 875
        old_locale___2 = tmp___19;
#line 875
        saved_locale___2 = (char *)((void *)0);
        }
#line 875
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 875
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 875
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 875
          setlocale(6, "C");
          }
        }
        {
#line 875
        tmp___20 = sgr_dbname();
#line 875
        syslog(3, "failure while closing read-only %s", tmp___20);
        }
#line 875
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 875
          setlocale(6, (char const   *)saved_locale___2);
#line 875
          free((void *)saved_locale___2);
          }
        }
#line 875
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 878
      exit(1);
      }
    }
  }
#line 882
  return;
}
}
#line 899 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static char pass___0[8192]  ;
#line 893 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/gpasswd.c"
static void change_passwd(struct group *gr , struct sgrp *sg ) 
{ 
  char *cp ;
  int retries ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 908
  tmp = gettext("Changing the password for group %s\n");
#line 908
  printf((char const   */* __restrict  */)tmp, group);
#line 910
  retries = 0;
  }
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    if (! (retries < 3)) {
#line 910
      goto while_break;
    }
    {
#line 911
    tmp___0 = gettext("New Password: ");
#line 911
    cp = getpass((char const   *)tmp___0);
    }
#line 912
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 913
      exit(1);
      }
    }
    {
#line 916
    strncpy((char */* __restrict  */)(pass___0), (char const   */* __restrict  */)cp,
            sizeof(pass___0) - 1UL);
#line 916
    pass___0[sizeof(pass___0) - 1UL] = (char )'\000';
#line 917
    tmp___1 = strlen((char const   *)cp);
#line 917
    memset((void *)cp, 0, tmp___1);
#line 918
    tmp___2 = gettext("Re-enter new password: ");
#line 918
    cp = getpass((char const   *)tmp___2);
    }
#line 919
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 920
      exit(1);
      }
    }
    {
#line 923
    tmp___4 = strcmp((char const   *)(pass___0), (char const   *)cp);
    }
#line 923
    if (tmp___4 == 0) {
      {
#line 924
      tmp___3 = strlen((char const   *)cp);
#line 924
      memset((void *)cp, 0, tmp___3);
      }
#line 925
      goto while_break;
    }
    {
#line 928
    tmp___5 = strlen((char const   *)cp);
#line 928
    memset((void *)cp, 0, tmp___5);
#line 929
    memset((void *)(pass___0), 0, sizeof(pass___0));
    }
#line 931
    if (retries + 1 < 3) {
      {
#line 932
      tmp___6 = gettext("They don\'t match; try again");
#line 932
      puts((char const   *)tmp___6);
      }
    }
#line 910
    retries ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  if (retries == 3) {
    {
#line 937
    tmp___7 = gettext("%s: Try again later\n");
#line 937
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            Prog);
#line 938
    exit(1);
    }
  }
  {
#line 941
  tmp___8 = crypt_make_salt((char const   *)((void *)0), (void *)0);
#line 941
  cp = pw_encrypt((char const   *)(pass___0), tmp___8);
#line 942
  memset((void *)(pass___0), 0, sizeof(pass___0));
  }
#line 944
  if (is_shadowgrp) {
#line 945
    gr->gr_passwd = (char *)"x";
#line 946
    sg->sg_passwd = cp;
  } else {
#line 950
    gr->gr_passwd = cp;
  }
#line 952
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___3[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___3[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___4(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___4(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___4[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___4[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___4  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___4(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___5  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___9  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___4(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___9) {
#line 70
      size___9 = i + 100;
#line 71
      if (members___5) {
        {
#line 72
        tmp = realloc((void *)members___5, (unsigned long )size___9 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___9 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___5) {
          {
#line 81
          free((void *)members___5);
          }
        }
#line 82
        members___5 = (char **)0;
#line 83
        size___9 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___5 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___5 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___5 + i) = (char *)0;
#line 99
  return (members___5);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___4  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___10  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___4[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___4  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___4(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___4(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___4  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___4  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___4  ;
#line 72
static int copy_entry___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___4(char const   *filename___0 ) ;
#line 83
static int copy_symlink___4(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___4(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___4(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___4(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___4(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___4(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___4 == (unsigned long )ln) {
    {
#line 149
    links___4 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___4;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___4(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___4)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___4)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___4;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___4);
#line 199
  dst_len = strlen(dst_orig___4);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___4, name___3 + src_len);
#line 207
  lp->ln_next = links___4;
#line 208
  links___4 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___4(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___4(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___4(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___4(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___4(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___4(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___4(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___4(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___4(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___4)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___4)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___4(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___4);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___4, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___4);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___4);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___4);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___4, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___4(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___4(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___4(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___4(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___4(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___4(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___4(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___4(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___4(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 849
extern char *getlogin(void) ;
#line 58 "../lib/gshadow_.h"
extern struct sgrp *getsgnam(char const   * ) ;
#line 36 "../lib/getdef.h"
extern _Bool getdef_bool(char const   * ) ;
#line 415 "../lib/prototypes.h"
extern struct group *xgetgrnam(char const   * ) ;
#line 417
extern struct group *xgetgrgid(gid_t  ) ;
#line 419
extern struct spwd *xgetspnam(char const   * ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static int ngroups  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static gid_t *grouplist  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static _Bool is_newgrp  ;
#line 68
static void usage___3(void) ;
#line 69
static void check_perms___2(struct group  const  *grp , struct passwd *pwd , char const   *groupname ) ;
#line 72
static void syslog_sg(char const   *name___3 , char const   *group___0 ) ;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static void usage___3(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 79
  if (is_newgrp) {
    {
#line 80
    tmp = gettext("Usage: newgrp [-] [group]\n");
#line 80
    fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
    }
  } else {
    {
#line 82
    tmp___0 = gettext("Usage: sg group [[-c] command]\n");
#line 82
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
    }
  }
#line 84
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static struct group *find_matching_group(char const   *name___3 , gid_t gid ) 
{ 
  struct group *gr ;
  char **look ;
  _Bool notfound ;
  int tmp ;

  {
  {
#line 94
  notfound = (_Bool)1;
#line 96
  setgrent();
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    gr = getgrent();
    }
#line 97
    if (! ((unsigned long )gr != (unsigned long )((void *)0))) {
#line 97
      goto while_break;
    }
#line 98
    if (gr->gr_gid != gid) {
#line 99
      goto while_continue;
    }
#line 106
    look = gr->gr_mem;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if ((unsigned long )((void *)0) != (unsigned long )*look) {
#line 107
        if (! notfound) {
#line 107
          goto while_break___0;
        }
      } else {
#line 107
        goto while_break___0;
      }
      {
#line 108
      tmp = strcmp((char const   *)*look, name___3);
#line 108
      notfound = (_Bool )(tmp != 0);
#line 109
      look ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    if (! notfound) {
#line 112
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  endgrent();
  }
#line 116
  return (gr);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static void check_perms___2(struct group  const  *grp , struct passwd *pwd , char const   *groupname ) 
{ 
  _Bool needspasswd ;
  struct spwd *spwd ;
  char *cp ;
  char const   *cpasswd ;
  _Bool tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  char *tmp___4 ;
  int tmp___5 ;
  __uid_t tmp___6 ;

  {
#line 130
  needspasswd = (_Bool)0;
#line 144
  if (grp->gr_gid != (__gid_t const   )pwd->pw_gid) {
    {
#line 144
    tmp = is_on_list((char * const  *)grp->gr_mem, (char const   *)pwd->pw_name);
    }
#line 144
    if (! tmp) {
#line 146
      needspasswd = (_Bool)1;
    }
  }
  {
#line 154
  spwd = xgetspnam((char const   *)pwd->pw_name);
  }
#line 155
  if ((unsigned long )((void *)0) != (unsigned long )spwd) {
#line 156
    pwd->pw_passwd = spwd->sp_pwdp;
  }
#line 159
  if ((int )*(pwd->pw_passwd + 0) == 0) {
#line 159
    if ((int )*(grp->gr_passwd + 0) != 0) {
#line 160
      needspasswd = (_Bool)1;
    }
  }
  {
#line 169
  tmp___6 = getuid();
  }
#line 169
  if (tmp___6 != 0U) {
#line 169
    if (needspasswd) {
      {
#line 174
      tmp___0 = gettext("Password: ");
#line 174
      cp = getpass((char const   *)tmp___0);
      }
#line 175
      if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 176
        goto failure;
      }
      {
#line 184
      tmp___1 = pw_encrypt((char const   *)cp, (char const   *)grp->gr_passwd);
#line 184
      cpasswd = (char const   *)tmp___1;
#line 185
      tmp___2 = strlen((char const   *)cp);
#line 185
      memset((void *)cp, 0, tmp___2);
      }
#line 187
      if ((int )*(grp->gr_passwd + 0) == 0) {
#line 187
        goto _L;
      } else {
        {
#line 187
        tmp___5 = strcmp(cpasswd, (char const   *)grp->gr_passwd);
        }
#line 187
        if (tmp___5 != 0) {
          _L: /* CIL Label */ 
          {
#line 197
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 197
            tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 197
            old_locale = tmp___3;
#line 197
            saved_locale = (char *)((void *)0);
            }
#line 197
            if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
              {
#line 197
              saved_locale = strdup((char const   *)old_locale);
              }
            }
#line 197
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
              {
#line 197
              setlocale(6, "C");
              }
            }
            {
#line 197
            syslog(6, "Invalid password for group \'%s\' from \'%s\'", groupname,
                   pwd->pw_name);
            }
#line 197
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
              {
#line 197
              setlocale(6, (char const   *)saved_locale);
#line 197
              free((void *)saved_locale);
              }
            }
#line 197
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 200
          sleep(1U);
#line 201
          tmp___4 = gettext("Invalid password.\n");
#line 201
          fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stderr);
          }
#line 202
          goto failure;
        }
      }
    }
  }
#line 214
  return;
  failure: 
  {
#line 220
  closelog();
#line 234
  exit(1);
  }
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/newgrp.c"
static void syslog_sg(char const   *name___3 , char const   *group___0 ) 
{ 
  char const   *loginname ;
  char *tmp ;
  char const   *tty ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;

  {
  {
#line 246
  tmp = getlogin();
#line 246
  loginname = (char const   *)tmp;
#line 247
  tmp___0 = ttyname(0);
#line 247
  tty = (char const   *)tmp___0;
  }
#line 249
  if ((unsigned long )loginname != (unsigned long )((void *)0)) {
    {
#line 250
    tmp___1 = xstrdup(loginname);
#line 250
    loginname = (char const   *)tmp___1;
    }
  }
#line 252
  if ((unsigned long )tty != (unsigned long )((void *)0)) {
    {
#line 253
    tmp___2 = xstrdup(tty);
#line 253
    tty = (char const   *)tmp___2;
    }
  }
#line 256
  if ((unsigned long )loginname == (unsigned long )((void *)0)) {
#line 257
    loginname = "???";
  }
#line 259
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 260
    tty = "???";
  } else {
    {
#line 261
    tmp___3 = strncmp(tty, "/dev/", (size_t )5);
    }
#line 261
    if (tmp___3 == 0) {
#line 262
      tty += 5;
    }
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 264
    tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 264
    old_locale = tmp___4;
#line 264
    saved_locale = (char *)((void *)0);
    }
#line 264
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 264
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 264
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 264
      setlocale(6, "C");
      }
    }
    {
#line 264
    syslog(6, "user \'%s\' (login \'%s\' on %s) switched to group \'%s\'", name___3,
           loginname, tty, group___0);
    }
#line 264
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 264
      setlocale(6, (char const   *)saved_locale);
#line 264
      free((void *)saved_locale);
      }
    }
#line 264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___4[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___4[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 110
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 773
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 165 "../lib/prototypes.h"
extern int getrange(char *range , unsigned long *min , _Bool *has_min , unsigned long *max ,
                    _Bool *has_max ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void usage___4(int status ) ;
#line 52
static void print_one(struct passwd  const  *pw , _Bool force ) ;
#line 53
static void set_locktime(long locktime ) ;
#line 54
static _Bool set_locktime_one(uid_t uid , long locktime ) ;
#line 55
static void setmax(short max ) ;
#line 56
static _Bool setmax_one(uid_t uid , short max ) ;
#line 57
static void print(void) ;
#line 58
static _Bool reset_one(uid_t uid ) ;
#line 59
static void reset(void) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static FILE *fail  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static time_t seconds  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static unsigned long umin  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool has_umin  =    (_Bool)0;
#line 69 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static unsigned long umax  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool has_umax  =    (_Bool)0;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool errors  =    (_Bool)0;
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool aflg___0  =    (_Bool)0;
#line 74 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool uflg  =    (_Bool)0;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool tflg  =    (_Bool)0;
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool lflg___0  =    (_Bool)0;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool mflg___0  =    (_Bool)0;
#line 78 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool rflg___1  =    (_Bool)0;
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static struct stat statbuf  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void usage___4(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 86
  if (0 != status) {
#line 86
    tmp = stderr;
  } else {
#line 86
    tmp = stdout;
  }
  {
#line 86
  usageout = tmp;
#line 87
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 87
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 92
  tmp___1 = gettext("  -a, --all                     display faillog records for all users\n");
#line 92
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 93
  tmp___2 = gettext("  -h, --help                    display this help message and exit\n");
#line 93
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 94
  tmp___3 = gettext("  -l, --lock-secs SEC           after failed login lock account for SEC seconds\n");
#line 94
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 95
  tmp___4 = gettext("  -m, --maximum MAX             set maximum failed login counters to MAX\n");
#line 95
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 96
  tmp___5 = gettext("  -r, --reset                   reset the counters of login failures\n");
#line 96
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 97
  tmp___6 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 97
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 98
  tmp___7 = gettext("  -t, --time DAYS               display faillog records more recent than DAYS\n");
#line 98
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 99
  tmp___8 = gettext("  -u, --user LOGIN/RANGE        display faillog record or maintains failure\n                                counters and limits (if used with -r, -m,\n                                or -l) only for the specified LOGIN(s)\n");
#line 99
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 102
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 103
  exit(status);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool once  =    (_Bool)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void print_one(struct passwd  const  *pw , _Bool force ) 
{ 
  struct tm *tm ;
  off_t offset ;
  struct faillog fl ;
  time_t now ;
  char *cp ;
  char ptime[80] ;
  int err ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 119
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
#line 120
    return;
  }
#line 123
  offset = (off_t )((unsigned long )((off_t )pw->pw_uid) * sizeof(fl));
#line 124
  if ((unsigned long )offset + sizeof(fl) <= (unsigned long )statbuf.st_size) {
    {
#line 126
    tmp = fseeko(fail, offset, 0);
#line 126
    err = tmp;
    }
#line 127
    if (! (0 == err)) {
      {
#line 127
      __assert_fail("0 == err", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c",
                    127U, "print_one");
      }
    }
    {
#line 132
    tmp___1 = fread((void */* __restrict  */)((char *)(& fl)), sizeof(fl), (size_t )1,
                    (FILE */* __restrict  */)fail);
    }
#line 132
    if (tmp___1 != 1UL) {
      {
#line 133
      tmp___0 = gettext("%s: Failed to get the entry for UID %lu\n");
#line 133
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, (unsigned long )pw->pw_uid);
      }
#line 136
      return;
    }
  } else {
    {
#line 144
    memset((void *)(& fl), 0, sizeof(fl));
    }
  }
#line 148
  if (! force) {
#line 148
    if (0L == fl.fail_time) {
#line 149
      return;
    }
  }
  {
#line 152
  time(& now);
  }
#line 155
  if (tflg) {
#line 155
    if (now - fl.fail_time > seconds) {
#line 156
      return;
    }
  }
#line 160
  if (! once) {
    {
#line 161
    tmp___2 = gettext("Login       Failures Maximum Latest                   On\n");
#line 161
    puts((char const   *)tmp___2);
#line 162
    once = (_Bool)1;
    }
  }
  {
#line 165
  tm = localtime((time_t const   *)(& fl.fail_time));
#line 167
  strftime((char */* __restrict  */)(ptime), sizeof(ptime), (char const   */* __restrict  */)"%D %H:%M:%S %z",
           (struct tm  const  */* __restrict  */)tm);
#line 168
  cp = ptime;
#line 170
  printf((char const   */* __restrict  */)"%-9s   %5d    %5d   ", pw->pw_name, (int )fl.fail_cnt,
         (int )fl.fail_max);
#line 173
  printf((char const   */* __restrict  */)"%s  %s", cp, fl.fail_line);
  }
#line 174
  if (0L != fl.fail_locktime) {
#line 175
    if (fl.fail_time + fl.fail_locktime > now) {
#line 175
      if (0 != (int )fl.fail_cnt) {
        {
#line 177
        tmp___3 = gettext(" [%lus left]");
#line 177
        printf((char const   */* __restrict  */)tmp___3, ((unsigned long )fl.fail_time + (unsigned long )fl.fail_locktime) - (unsigned long )now);
        }
      } else {
        {
#line 180
        tmp___4 = gettext(" [%lds lock]");
#line 180
        printf((char const   */* __restrict  */)tmp___4, fl.fail_locktime);
        }
      }
    } else {
      {
#line 180
      tmp___4 = gettext(" [%lds lock]");
#line 180
      printf((char const   */* __restrict  */)tmp___4, fl.fail_locktime);
      }
    }
  }
  {
#line 184
  putchar('\n');
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void print(void) 
{ 
  struct passwd *tmp ;
  struct passwd *pwent___0 ;

  {
#line 189
  if (uflg) {
#line 189
    if (has_umin) {
#line 189
      if (has_umax) {
#line 189
        if (umin == umax) {
          {
#line 190
          tmp = getpwuid((uid_t )umin);
#line 190
          print_one((struct passwd  const  *)tmp, (_Bool)1);
          }
        } else {
#line 189
          goto _L___2;
        }
      } else {
#line 189
        goto _L___2;
      }
    } else {
#line 189
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 200
    setpwent();
    }
    {
#line 201
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 201
      pwent___0 = getpwent();
      }
#line 201
      if (! ((unsigned long )pwent___0 != (unsigned long )((void *)0))) {
#line 201
        goto while_break;
      }
#line 202
      if (uflg) {
#line 202
        if (has_umin) {
#line 202
          if (pwent___0->pw_uid < (uid_t )umin) {
#line 205
            goto while_continue;
          } else {
#line 202
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 202
        if (has_umax) {
#line 202
          if (pwent___0->pw_uid > (uid_t )umax) {
#line 205
            goto while_continue;
          }
        }
      }
      {
#line 207
      print_one((struct passwd  const  *)pwent___0, aflg___0);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 209
    endpwent();
    }
  }
#line 211
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool reset_one(uid_t uid ) 
{ 
  off_t offset ;
  struct faillog fl ;
  int err ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 223
  offset = (off_t )((unsigned long )((off_t )uid) * sizeof(fl));
#line 224
  if ((unsigned long )offset + sizeof(fl) <= (unsigned long )statbuf.st_size) {
    {
#line 226
    tmp = fseeko(fail, offset, 0);
#line 226
    err = tmp;
    }
#line 227
    if (! (0 == err)) {
      {
#line 227
      __assert_fail("0 == err", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c",
                    227U, "reset_one");
      }
    }
    {
#line 232
    tmp___1 = fread((void */* __restrict  */)((char *)(& fl)), sizeof(fl), (size_t )1,
                    (FILE */* __restrict  */)fail);
    }
#line 232
    if (tmp___1 != 1UL) {
      {
#line 233
      tmp___0 = gettext("%s: Failed to get the entry for UID %lu\n");
#line 233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, (unsigned long )uid);
      }
#line 236
      return ((_Bool)1);
    }
  } else {
    {
#line 244
    memset((void *)(& fl), 0, sizeof(fl));
    }
  }
#line 247
  if (0 == (int )fl.fail_cnt) {
#line 252
    return ((_Bool)0);
  }
  {
#line 255
  fl.fail_cnt = (short)0;
#line 257
  tmp___2 = fseeko(fail, offset, 0);
  }
#line 257
  if (tmp___2 == 0) {
    {
#line 257
    tmp___3 = fwrite((void const   */* __restrict  */)((char *)(& fl)), sizeof(fl),
                     (size_t )1, (FILE */* __restrict  */)fail);
    }
#line 257
    if (tmp___3 == 1UL) {
      {
#line 259
      fflush(fail);
      }
#line 260
      return ((_Bool)0);
    }
  }
  {
#line 263
  tmp___4 = gettext("%s: Failed to reset fail count for UID %lu\n");
#line 263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
          Prog, (unsigned long )uid);
  }
#line 266
  return ((_Bool)1);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void reset(void) 
{ 
  _Bool tmp ;
  uid_t uidmax ;
  uid_t uid ;
  _Bool tmp___0 ;
  struct passwd *pwent___0 ;
  _Bool tmp___1 ;

  {
#line 271
  if (uflg) {
#line 271
    if (has_umin) {
#line 271
      if (has_umax) {
#line 271
        if (umin == umax) {
          {
#line 272
          tmp = reset_one((uid_t )umin);
          }
#line 272
          if (tmp) {
#line 273
            errors = (_Bool)1;
          }
        } else {
#line 271
          goto _L___2;
        }
      } else {
#line 271
        goto _L___2;
      }
    } else {
#line 271
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 279
    uidmax = (uid_t )((unsigned long )statbuf.st_size / sizeof(struct faillog ));
#line 280
    if (uidmax > 1U) {
#line 281
      uidmax --;
    }
#line 283
    if (has_umax) {
#line 283
      if ((uid_t )umax < uidmax) {
#line 284
        uidmax = (uid_t )umax;
      }
    }
#line 290
    if (aflg___0) {
#line 293
      uid = (uid_t )0;
#line 296
      if (has_umin) {
#line 297
        uid = (uid_t )umin;
      }
      {
#line 300
      while (1) {
        while_continue: /* CIL Label */ ;
#line 300
        if (! (uid <= uidmax)) {
#line 300
          goto while_break;
        }
        {
#line 301
        tmp___0 = reset_one(uid);
        }
#line 301
        if (tmp___0) {
#line 302
          errors = (_Bool)1;
        }
#line 304
        uid ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 311
      setpwent();
      }
      {
#line 312
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 312
        pwent___0 = getpwent();
        }
#line 312
        if (! ((unsigned long )pwent___0 != (unsigned long )((void *)0))) {
#line 312
          goto while_break___0;
        }
#line 313
        if (uflg) {
#line 313
          if (has_umin) {
#line 313
            if (pwent___0->pw_uid < (uid_t )umin) {
#line 316
              goto while_continue___0;
            } else {
#line 313
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 313
          if (pwent___0->pw_uid > uidmax) {
#line 316
            goto while_continue___0;
          }
        }
        {
#line 318
        tmp___1 = reset_one(pwent___0->pw_uid);
        }
#line 318
        if (tmp___1) {
#line 319
          errors = (_Bool)1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 322
      endpwent();
      }
    }
  }
#line 325
  return;
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool setmax_one(uid_t uid , short max ) 
{ 
  off_t offset ;
  struct faillog fl ;
  int err ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 337
  offset = (off_t )((unsigned long )((off_t )uid) * sizeof(fl));
#line 338
  if ((unsigned long )offset + sizeof(fl) <= (unsigned long )statbuf.st_size) {
    {
#line 340
    tmp = fseeko(fail, offset, 0);
#line 340
    err = tmp;
    }
#line 341
    if (! (0 == err)) {
      {
#line 341
      __assert_fail("0 == err", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c",
                    341U, "setmax_one");
      }
    }
    {
#line 346
    tmp___1 = fread((void */* __restrict  */)((char *)(& fl)), sizeof(fl), (size_t )1,
                    (FILE */* __restrict  */)fail);
    }
#line 346
    if (tmp___1 != 1UL) {
      {
#line 347
      tmp___0 = gettext("%s: Failed to get the entry for UID %lu\n");
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, (unsigned long )uid);
      }
#line 350
      return ((_Bool)1);
    }
  } else {
    {
#line 358
    memset((void *)(& fl), 0, sizeof(fl));
    }
  }
#line 361
  if ((int )max == (int )fl.fail_max) {
#line 367
    return ((_Bool)0);
  }
  {
#line 370
  fl.fail_max = max;
#line 372
  tmp___2 = fseeko(fail, offset, 0);
  }
#line 372
  if (tmp___2 == 0) {
    {
#line 372
    tmp___3 = fwrite((void const   */* __restrict  */)((char *)(& fl)), sizeof(fl),
                     (size_t )1, (FILE */* __restrict  */)fail);
    }
#line 372
    if (tmp___3 == 1UL) {
      {
#line 374
      fflush(fail);
      }
#line 375
      return ((_Bool)0);
    }
  }
  {
#line 378
  tmp___4 = gettext("%s: Failed to set max for UID %lu\n");
#line 378
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
          Prog, (unsigned long )uid);
  }
#line 381
  return ((_Bool)1);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void setmax(short max ) 
{ 
  _Bool tmp ;
  uid_t uid ;
  uid_t uidmax ;
  _Bool tmp___0 ;
  struct passwd *pwent___0 ;
  _Bool tmp___1 ;

  {
#line 386
  if (uflg) {
#line 386
    if (has_umin) {
#line 386
      if (has_umax) {
#line 386
        if (umin == umax) {
          {
#line 387
          tmp = setmax_one((uid_t )umin, max);
          }
#line 387
          if (tmp) {
#line 388
            errors = (_Bool)1;
          }
        } else {
#line 386
          goto _L___2;
        }
      } else {
#line 386
        goto _L___2;
      }
    } else {
#line 386
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 396
  if (aflg___0) {
#line 400
    uid = (uid_t )0;
#line 404
    uidmax = (uid_t )((unsigned long )statbuf.st_size / sizeof(struct faillog ));
#line 405
    if (uidmax > 1U) {
#line 406
      uidmax --;
    }
#line 410
    if (has_umin) {
#line 411
      uid = (uid_t )umin;
    }
#line 413
    if (has_umax) {
#line 414
      uidmax = (uid_t )umax;
    }
    {
#line 417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 417
      if (! (uid <= uidmax)) {
#line 417
        goto while_break;
      }
      {
#line 418
      tmp___0 = setmax_one(uid, max);
      }
#line 418
      if (tmp___0) {
#line 419
        errors = (_Bool)1;
      }
#line 421
      uid ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 428
    setpwent();
    }
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 429
      pwent___0 = getpwent();
      }
#line 429
      if (! ((unsigned long )pwent___0 != (unsigned long )((void *)0))) {
#line 429
        goto while_break___0;
      }
#line 430
      if (uflg) {
#line 430
        if (has_umin) {
#line 430
          if (pwent___0->pw_uid < (uid_t )umin) {
#line 433
            goto while_continue___0;
          } else {
#line 430
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 430
        if (has_umax) {
#line 430
          if (pwent___0->pw_uid > (uid_t )umax) {
#line 433
            goto while_continue___0;
          }
        }
      }
      {
#line 435
      tmp___1 = setmax_one(pwent___0->pw_uid, max);
      }
#line 435
      if (tmp___1) {
#line 436
        errors = (_Bool)1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 439
    endpwent();
    }
  }
#line 442
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static _Bool set_locktime_one(uid_t uid , long locktime ) 
{ 
  off_t offset ;
  struct faillog fl ;
  int err ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 454
  offset = (off_t )((unsigned long )((off_t )uid) * sizeof(fl));
#line 455
  if ((unsigned long )offset + sizeof(fl) <= (unsigned long )statbuf.st_size) {
    {
#line 457
    tmp = fseeko(fail, offset, 0);
#line 457
    err = tmp;
    }
#line 458
    if (! (0 == err)) {
      {
#line 458
      __assert_fail("0 == err", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c",
                    458U, "set_locktime_one");
      }
    }
    {
#line 463
    tmp___1 = fread((void */* __restrict  */)((char *)(& fl)), sizeof(fl), (size_t )1,
                    (FILE */* __restrict  */)fail);
    }
#line 463
    if (tmp___1 != 1UL) {
      {
#line 464
      tmp___0 = gettext("%s: Failed to get the entry for UID %lu\n");
#line 464
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, (unsigned long )uid);
      }
#line 467
      return ((_Bool)1);
    }
  } else {
    {
#line 475
    memset((void *)(& fl), 0, sizeof(fl));
    }
  }
#line 478
  if (locktime == fl.fail_locktime) {
#line 484
    return ((_Bool)0);
  }
  {
#line 487
  fl.fail_locktime = locktime;
#line 489
  tmp___2 = fseeko(fail, offset, 0);
  }
#line 489
  if (tmp___2 == 0) {
    {
#line 489
    tmp___3 = fwrite((void const   */* __restrict  */)((char *)(& fl)), sizeof(fl),
                     (size_t )1, (FILE */* __restrict  */)fail);
    }
#line 489
    if (tmp___3 == 1UL) {
      {
#line 491
      fflush(fail);
      }
#line 492
      return ((_Bool)0);
    }
  }
  {
#line 495
  tmp___4 = gettext("%s: Failed to set locktime for UID %lu\n");
#line 495
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
          Prog, (unsigned long )uid);
  }
#line 498
  return ((_Bool)1);
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static void set_locktime(long locktime ) 
{ 
  _Bool tmp ;
  uid_t uid ;
  uid_t uidmax ;
  _Bool tmp___0 ;
  struct passwd *pwent___0 ;
  _Bool tmp___1 ;

  {
#line 503
  if (uflg) {
#line 503
    if (has_umin) {
#line 503
      if (has_umax) {
#line 503
        if (umin == umax) {
          {
#line 504
          tmp = set_locktime_one((uid_t )umin, locktime);
          }
#line 504
          if (tmp) {
#line 505
            errors = (_Bool)1;
          }
        } else {
#line 503
          goto _L___2;
        }
      } else {
#line 503
        goto _L___2;
      }
    } else {
#line 503
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 513
  if (aflg___0) {
#line 517
    uid = (uid_t )0;
#line 521
    uidmax = (uid_t )((unsigned long )statbuf.st_size / sizeof(struct faillog ));
#line 522
    if (uidmax > 1U) {
#line 523
      uidmax --;
    }
#line 527
    if (has_umin) {
#line 528
      uid = (uid_t )umin;
    }
#line 530
    if (has_umax) {
#line 531
      uidmax = (uid_t )umax;
    }
    {
#line 534
    while (1) {
      while_continue: /* CIL Label */ ;
#line 534
      if (! (uid <= uidmax)) {
#line 534
        goto while_break;
      }
      {
#line 535
      tmp___0 = set_locktime_one(uid, locktime);
      }
#line 535
      if (tmp___0) {
#line 536
        errors = (_Bool)1;
      }
#line 538
      uid ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 545
    setpwent();
    }
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 546
      pwent___0 = getpwent();
      }
#line 546
      if (! ((unsigned long )pwent___0 != (unsigned long )((void *)0))) {
#line 546
        goto while_break___0;
      }
#line 547
      if (uflg) {
#line 547
        if (has_umin) {
#line 547
          if (pwent___0->pw_uid < (uid_t )umin) {
#line 550
            goto while_continue___0;
          } else {
#line 547
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 547
        if (has_umax) {
#line 547
          if (pwent___0->pw_uid > (uid_t )umax) {
#line 550
            goto while_continue___0;
          }
        }
      }
      {
#line 552
      tmp___1 = set_locktime_one(pwent___0->pw_uid, locktime);
      }
#line 552
      if (tmp___1) {
#line 553
        errors = (_Bool)1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 556
    endpwent();
    }
  }
#line 559
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/faillog.c"
static struct option long_options___3[9]  = 
#line 581
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"lock-secs", 1, (int *)((void *)0), 'l'}, 
        {"maximum", 1, (int *)((void *)0), 'm'}, 
        {"reset", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"time", 1, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___5(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___5(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___5[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___5[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___5  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___5(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___6  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___11  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___5(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___11) {
#line 70
      size___11 = i + 100;
#line 71
      if (members___6) {
        {
#line 72
        tmp = realloc((void *)members___6, (unsigned long )size___11 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___11 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___6) {
          {
#line 81
          free((void *)members___6);
          }
        }
#line 82
        members___6 = (char **)0;
#line 83
        size___11 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___6 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___6 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___6 + i) = (char *)0;
#line 99
  return (members___6);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___5  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___12  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___5[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___5  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___5(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___5(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___5  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___5  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___5  ;
#line 72
static int copy_entry___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___5(char const   *filename___0 ) ;
#line 83
static int copy_symlink___5(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___5(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___5(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___5(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___5(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___5(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___5 == (unsigned long )ln) {
    {
#line 149
    links___5 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___5;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___5(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___5)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___5)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___5;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___5);
#line 199
  dst_len = strlen(dst_orig___5);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___5, name___3 + src_len);
#line 207
  lp->ln_next = links___5;
#line 208
  links___5 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___5(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___5(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___5(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___5(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___5(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___5(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___5(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___5(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___5(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___5)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___5)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___5(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___5);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___5, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___5);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___5);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___5);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___5, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___5(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___5(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___5(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___5(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___5(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___5(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___5(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___5(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___5(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___5[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___5[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___6(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___6(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 285 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 620 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 42 "../lib/getdef.h"
extern int putdef_str(char const   * , char const   * ) ;
#line 186 "../lib/prototypes.h"
extern struct group *__gr_dup(struct group  const  *grent ) ;
#line 336
extern struct sgrp *__sgr_dup(struct sgrp  const  *sgent ) ;
#line 44 "../lib/sgroupio.h"
extern struct sgrp  const  *sgr_next(void) ;
#line 47
extern int sgr_rewind(void) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static gid_t def_group  =    (gid_t )100;
#line 94 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *def_gname  =    "other";
#line 95 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *def_home  =    "/home";
#line 96 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *def_shell  =    "";
#line 97 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *def_template  =    "/etc/skel";
#line 98 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *def_create_mail_spool  =    "no";
#line 100 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static long def_inactive  =    -1L;
#line 101 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *def_expire  =    "";
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *user_name___0  =    "";
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *user_pass  =    "!";
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static uid_t user_id  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static gid_t user_gid  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *user_comment  =    "";
#line 110 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *user_home  =    "";
#line 111 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *user_shell  =    "";
#line 112 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char const   *create_mail_spool  =    "";
#line 117 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static long user_expire  =    -1L;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool is_shadow_pwd  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool is_shadow_grp___0  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool sgr_locked___0  =    (_Bool)0;
#line 124 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool pw_locked___2  =    (_Bool)0;
#line 125 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool gr_locked___0  =    (_Bool)0;
#line 126 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool spw_locked___2  =    (_Bool)0;
#line 127 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char **user_groups  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static long sys_ngroups  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool do_grp_update  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool bflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool cflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool dflg___1  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool Dflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool eflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool fflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool gflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool Gflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool kflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool lflg___1  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool mflg___1  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool Mflg___1  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool Nflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool oflg  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool rflg___2  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool sflg___0  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool uflg___0  =    (_Bool)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool Uflg  =    (_Bool)0;
#line 155 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static _Bool home_added  =    (_Bool)0;
#line 181
static void fail_exit___2(int code ) ;
#line 182
static void get_defaults___0(void) ;
#line 183
static void show_defaults(void) ;
#line 184
static int set_defaults(void) ;
#line 185
static int get_groups(char *list___30 ) ;
#line 186
static void usage___5(int status ) ;
#line 187
static void new_pwent(struct passwd *pwent___0 ) ;
#line 189
static long scale_age(long x ) ;
#line 190
static void new_spent(struct spwd *spent ) ;
#line 191
static void grp_update(void) ;
#line 193
static void process_flags___3(int argc , char **argv ) ;
#line 194
static void close_files___3(void) ;
#line 195
static void open_files___3(void) ;
#line 196
static void open_shadow(void) ;
#line 197
static void faillog_reset(uid_t uid ) ;
#line 198
static void lastlog_reset(uid_t uid ) ;
#line 199
static void usr_update(void) ;
#line 200
static void create_home(void) ;
#line 201
static void create_mail(void) ;
#line 206 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void fail_exit___2(int code ) 
{ 
  char *tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *old_locale___0 ;
  char *tmp___4 ;
  char *saved_locale___0 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *old_locale___1 ;
  char *tmp___9 ;
  char *saved_locale___1 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *old_locale___2 ;
  char *tmp___14 ;
  char *saved_locale___2 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *old_locale___3 ;
  char *tmp___19 ;
  char *saved_locale___3 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char *old_locale___4 ;
  char *tmp___22 ;
  char *saved_locale___4 ;

  {
#line 208
  if (home_added) {
    {
#line 209
    tmp___1 = rmdir(user_home);
    }
#line 209
    if (tmp___1 != 0) {
      {
#line 210
      tmp = gettext("%s: %s was created, but could not be removed\n");
#line 210
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, user_home);
      }
      {
#line 213
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 213
        tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 213
        old_locale = tmp___0;
#line 213
        saved_locale = (char *)((void *)0);
        }
#line 213
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 213
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 213
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 213
          setlocale(6, "C");
          }
        }
        {
#line 213
        syslog(3, "failed to remove %s", user_home);
        }
#line 213
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 213
          setlocale(6, (char const   *)saved_locale);
#line 213
          free((void *)saved_locale);
          }
        }
#line 213
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 217
  if (spw_locked___2) {
    {
#line 218
    tmp___6 = spw_unlock();
    }
#line 218
    if (tmp___6 == 0) {
      {
#line 219
      tmp___2 = spw_dbname();
#line 219
      tmp___3 = gettext("%s: failed to unlock %s\n");
#line 219
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2);
      }
      {
#line 220
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 220
        tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 220
        old_locale___0 = tmp___4;
#line 220
        saved_locale___0 = (char *)((void *)0);
        }
#line 220
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 220
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 220
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 220
          setlocale(6, "C");
          }
        }
        {
#line 220
        tmp___5 = spw_dbname();
#line 220
        syslog(3, "failed to unlock %s", tmp___5);
        }
#line 220
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 220
          setlocale(6, (char const   *)saved_locale___0);
#line 220
          free((void *)saved_locale___0);
          }
        }
#line 220
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 230
  if (pw_locked___2) {
    {
#line 231
    tmp___11 = pw_unlock();
    }
#line 231
    if (tmp___11 == 0) {
      {
#line 232
      tmp___7 = pw_dbname();
#line 232
      tmp___8 = gettext("%s: failed to unlock %s\n");
#line 232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7);
      }
      {
#line 233
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 233
        tmp___9 = setlocale(6, (char const   *)((void *)0));
#line 233
        old_locale___1 = tmp___9;
#line 233
        saved_locale___1 = (char *)((void *)0);
        }
#line 233
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 233
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 233
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 233
          setlocale(6, "C");
          }
        }
        {
#line 233
        tmp___10 = pw_dbname();
#line 233
        syslog(3, "failed to unlock %s", tmp___10);
        }
#line 233
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 233
          setlocale(6, (char const   *)saved_locale___1);
#line 233
          free((void *)saved_locale___1);
          }
        }
#line 233
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 243
  if (gr_locked___0) {
    {
#line 244
    tmp___16 = gr_unlock();
    }
#line 244
    if (tmp___16 == 0) {
      {
#line 245
      tmp___12 = gr_dbname();
#line 245
      tmp___13 = gettext("%s: failed to unlock %s\n");
#line 245
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
              Prog, tmp___12);
      }
      {
#line 246
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 246
        tmp___14 = setlocale(6, (char const   *)((void *)0));
#line 246
        old_locale___2 = tmp___14;
#line 246
        saved_locale___2 = (char *)((void *)0);
        }
#line 246
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 246
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 246
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 246
          setlocale(6, "C");
          }
        }
        {
#line 246
        tmp___15 = gr_dbname();
#line 246
        syslog(3, "failed to unlock %s", tmp___15);
        }
#line 246
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 246
          setlocale(6, (char const   *)saved_locale___2);
#line 246
          free((void *)saved_locale___2);
          }
        }
#line 246
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 257
  if (sgr_locked___0) {
    {
#line 258
    tmp___21 = sgr_unlock();
    }
#line 258
    if (tmp___21 == 0) {
      {
#line 259
      tmp___17 = sgr_dbname();
#line 259
      tmp___18 = gettext("%s: failed to unlock %s\n");
#line 259
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
              Prog, tmp___17);
      }
      {
#line 260
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 260
        tmp___19 = setlocale(6, (char const   *)((void *)0));
#line 260
        old_locale___3 = tmp___19;
#line 260
        saved_locale___3 = (char *)((void *)0);
        }
#line 260
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
          {
#line 260
          saved_locale___3 = strdup((char const   *)old_locale___3);
          }
        }
#line 260
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 260
          setlocale(6, "C");
          }
        }
        {
#line 260
        tmp___20 = sgr_dbname();
#line 260
        syslog(3, "failed to unlock %s", tmp___20);
        }
#line 260
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 260
          setlocale(6, (char const   *)saved_locale___3);
#line 260
          free((void *)saved_locale___3);
          }
        }
#line 260
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  {
#line 278
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 278
    tmp___22 = setlocale(6, (char const   *)((void *)0));
#line 278
    old_locale___4 = tmp___22;
#line 278
    saved_locale___4 = (char *)((void *)0);
    }
#line 278
    if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
      {
#line 278
      saved_locale___4 = strdup((char const   *)old_locale___4);
      }
    }
#line 278
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
      {
#line 278
      setlocale(6, "C");
      }
    }
    {
#line 278
    syslog(6, "failed adding user \'%s\', data deleted", user_name___0);
    }
#line 278
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
      {
#line 278
      setlocale(6, (char const   *)saved_locale___4);
#line 278
      free((void *)saved_locale___4);
      }
    }
#line 278
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 279
  exit(code);
  }
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void get_defaults___0(void) 
{ 
  FILE *fp ;
  char buf___0[1024] ;
  char *cp ;
  struct group  const  *grp ;
  struct group *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;

  {
  {
#line 301
  fp = fopen((char const   */* __restrict  */)"/etc/default/useradd", (char const   */* __restrict  */)"r");
  }
#line 302
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 303
    return;
  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 310
    tmp___25 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 310
    if (! ((unsigned long )tmp___25 == (unsigned long )(buf___0))) {
#line 310
      goto while_break;
    }
    {
#line 311
    cp = strrchr((char const   *)(buf___0), '\n');
    }
#line 312
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 313
      *cp = (char )'\000';
    }
    {
#line 316
    cp = strchr((char const   *)(buf___0), '=');
    }
#line 317
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 318
      goto while_continue;
    }
    {
#line 321
    cp ++;
#line 326
    tmp___23 = strlen("GROUP=");
#line 326
    tmp___24 = strncmp((char const   *)(buf___0), "GROUP=", tmp___23);
    }
#line 326
    if (tmp___24 == 0) {
      {
#line 327
      tmp = getgr_nam_gid((char const   *)cp);
#line 327
      grp = (struct group  const  *)tmp;
      }
#line 328
      if ((unsigned long )((void *)0) == (unsigned long )grp) {
        {
#line 329
        tmp___0 = gettext("%s: group \'%s\' does not exist\n");
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                Prog, cp);
#line 332
        tmp___1 = gettext("%s: the %s configuration in %s will be ignored\n");
#line 332
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                Prog, "GROUP=", "/etc/default/useradd");
        }
      } else {
        {
#line 336
        def_group = (gid_t )grp->gr_gid;
#line 337
        tmp___2 = xstrdup((char const   *)grp->gr_name);
#line 337
        def_gname = (char const   *)tmp___2;
        }
      }
    } else {
      {
#line 344
      tmp___21 = strlen("HOME=");
#line 344
      tmp___22 = strncmp((char const   *)(buf___0), "HOME=", tmp___21);
      }
#line 344
      if (tmp___22 == 0) {
        {
#line 345
        tmp___3 = xstrdup((char const   *)cp);
#line 345
        def_home = (char const   *)tmp___3;
        }
      } else {
        {
#line 351
        tmp___19 = strlen("SHELL=");
#line 351
        tmp___20 = strncmp((char const   *)(buf___0), "SHELL=", tmp___19);
        }
#line 351
        if (tmp___20 == 0) {
          {
#line 352
          tmp___4 = xstrdup((char const   *)cp);
#line 352
          def_shell = (char const   *)tmp___4;
          }
        } else {
          {
#line 358
          tmp___17 = strlen("INACTIVE=");
#line 358
          tmp___18 = strncmp((char const   *)(buf___0), "INACTIVE=", tmp___17);
          }
#line 358
          if (tmp___18 == 0) {
            {
#line 359
            tmp___7 = getlong((char const   *)cp, & def_inactive);
            }
#line 359
            if (tmp___7 == 0) {
              {
#line 361
              tmp___5 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 361
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                      Prog, cp);
#line 364
              tmp___6 = gettext("%s: the %s configuration in %s will be ignored\n");
#line 364
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                      Prog, "INACTIVE=", "/etc/default/useradd");
#line 367
              def_inactive = -1L;
              }
            } else
#line 359
            if (def_inactive < -1L) {
              {
#line 361
              tmp___5 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 361
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                      Prog, cp);
#line 364
              tmp___6 = gettext("%s: the %s configuration in %s will be ignored\n");
#line 364
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                      Prog, "INACTIVE=", "/etc/default/useradd");
#line 367
              def_inactive = -1L;
              }
            }
          } else {
            {
#line 374
            tmp___15 = strlen("EXPIRE=");
#line 374
            tmp___16 = strncmp((char const   *)(buf___0), "EXPIRE=", tmp___15);
            }
#line 374
            if (tmp___16 == 0) {
              {
#line 375
              tmp___8 = xstrdup((char const   *)cp);
#line 375
              def_expire = (char const   *)tmp___8;
              }
            } else {
              {
#line 381
              tmp___13 = strlen("SKEL=");
#line 381
              tmp___14 = strncmp((char const   *)(buf___0), "SKEL=", tmp___13);
              }
#line 381
              if (tmp___14 == 0) {
#line 382
                if (0 == (int )*cp) {
#line 383
                  cp = (char *)"/etc/skel";
                }
                {
#line 386
                tmp___9 = xstrdup((char const   *)cp);
#line 386
                def_template = (char const   *)tmp___9;
                }
              } else {
                {
#line 392
                tmp___11 = strlen("CREATE_MAIL_SPOOL=");
#line 392
                tmp___12 = strncmp((char const   *)(buf___0), "CREATE_MAIL_SPOOL=",
                                   tmp___11);
                }
#line 392
                if (tmp___12 == 0) {
#line 393
                  if ((int )*cp == 0) {
#line 394
                    cp = (char *)"no";
                  }
                  {
#line 397
                  tmp___10 = xstrdup((char const   *)cp);
#line 397
                  def_create_mail_spool = (char const   *)tmp___10;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  fclose(fp);
  }
#line 401
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void show_defaults(void) 
{ 


  {
  {
#line 411
  printf((char const   */* __restrict  */)"GROUP=%u\n", def_group);
#line 412
  printf((char const   */* __restrict  */)"HOME=%s\n", def_home);
#line 413
  printf((char const   */* __restrict  */)"INACTIVE=%ld\n", def_inactive);
#line 414
  printf((char const   */* __restrict  */)"EXPIRE=%s\n", def_expire);
#line 415
  printf((char const   */* __restrict  */)"SHELL=%s\n", def_shell);
#line 416
  printf((char const   */* __restrict  */)"SKEL=%s\n", def_template);
#line 417
  printf((char const   */* __restrict  */)"CREATE_MAIL_SPOOL=%s\n", def_create_mail_spool);
  }
#line 418
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char new_file[25]  = 
#line 432
  {      (char )'/',      (char )'e',      (char )'t',      (char )'c', 
        (char )'/',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )'/',      (char )'n',      (char )'u',      (char )'a', 
        (char )'d',      (char )'d',      (char )'X',      (char )'X', 
        (char )'X',      (char )'X',      (char )'X',      (char )'X', 
        (char )'\000'};
#line 427 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static int set_defaults(void) 
{ 
  FILE *ifp ;
  FILE *ofp ;
  char buf___0[1024] ;
  char *cp ;
  int ofd ;
  int wlen ;
  _Bool out_group ;
  _Bool out_home ;
  _Bool out_inactive ;
  _Bool out_expire ;
  _Bool out_shell ;
  _Bool out_skel ;
  _Bool out_create_mail_spool ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int err ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  int err___0 ;
  int *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *old_locale ;
  char *tmp___31 ;
  char *saved_locale ;

  {
  {
#line 436
  out_group = (_Bool)0;
#line 437
  out_home = (_Bool)0;
#line 438
  out_inactive = (_Bool)0;
#line 439
  out_expire = (_Bool)0;
#line 440
  out_shell = (_Bool)0;
#line 441
  out_skel = (_Bool)0;
#line 442
  out_create_mail_spool = (_Bool)0;
#line 447
  ofd = mkstemp(new_file);
  }
#line 448
  if (-1 == ofd) {
    {
#line 449
    tmp = gettext("%s: cannot create new defaults file\n");
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog);
    }
#line 452
    return (-1);
  }
  {
#line 455
  ofp = fdopen(ofd, "w");
  }
#line 456
  if ((unsigned long )((void *)0) == (unsigned long )ofp) {
    {
#line 457
    tmp___0 = gettext("%s: cannot open new defaults file\n");
#line 457
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog);
    }
#line 460
    return (-1);
  }
  {
#line 468
  ifp = fopen((char const   */* __restrict  */)"/etc/default/useradd", (char const   */* __restrict  */)"r");
  }
#line 469
  if ((unsigned long )((void *)0) == (unsigned long )ifp) {
    {
#line 470
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"# useradd defaults file\n");
    }
#line 471
    goto skip;
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 474
    tmp___17 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)ifp);
    }
#line 474
    if (! ((unsigned long )tmp___17 == (unsigned long )(buf___0))) {
#line 474
      goto while_break;
    }
    {
#line 475
    cp = strrchr((char const   *)(buf___0), '\n');
    }
#line 476
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 477
      *cp = (char )'\000';
    } else {
      {
#line 482
      tmp___2 = feof(ifp);
      }
#line 482
      if (tmp___2 == 0) {
        {
#line 483
        tmp___1 = gettext("%s: line too long in %s: %s...");
#line 483
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                Prog, "/etc/default/useradd", buf___0);
#line 486
        fclose(ifp);
        }
#line 487
        return (-1);
      }
    }
#line 491
    if (! out_group) {
      {
#line 491
      tmp___15 = strlen("GROUP=");
#line 491
      tmp___16 = strncmp((char const   *)(buf___0), "GROUP=", tmp___15);
      }
#line 491
      if (tmp___16 == 0) {
        {
#line 492
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"GROUP=%u\n",
                def_group);
#line 493
        out_group = (_Bool)1;
        }
      } else {
#line 491
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 494
    if (! out_home) {
      {
#line 494
      tmp___13 = strlen("HOME=");
#line 494
      tmp___14 = strncmp((char const   *)(buf___0), "HOME=", tmp___13);
      }
#line 494
      if (tmp___14 == 0) {
        {
#line 495
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"HOME=%s\n",
                def_home);
#line 496
        out_home = (_Bool)1;
        }
      } else {
#line 494
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 497
    if (! out_inactive) {
      {
#line 497
      tmp___11 = strlen("INACTIVE=");
#line 497
      tmp___12 = strncmp((char const   *)(buf___0), "INACTIVE=", tmp___11);
      }
#line 497
      if (tmp___12 == 0) {
        {
#line 498
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"INACTIVE=%ld\n",
                def_inactive);
#line 499
        out_inactive = (_Bool)1;
        }
      } else {
#line 497
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 500
    if (! out_expire) {
      {
#line 500
      tmp___9 = strlen("EXPIRE=");
#line 500
      tmp___10 = strncmp((char const   *)(buf___0), "EXPIRE=", tmp___9);
      }
#line 500
      if (tmp___10 == 0) {
        {
#line 501
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"EXPIRE=%s\n",
                def_expire);
#line 502
        out_expire = (_Bool)1;
        }
      } else {
#line 500
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 503
    if (! out_shell) {
      {
#line 503
      tmp___7 = strlen("SHELL=");
#line 503
      tmp___8 = strncmp((char const   *)(buf___0), "SHELL=", tmp___7);
      }
#line 503
      if (tmp___8 == 0) {
        {
#line 504
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"SHELL=%s\n",
                def_shell);
#line 505
        out_shell = (_Bool)1;
        }
      } else {
#line 503
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 506
    if (! out_skel) {
      {
#line 506
      tmp___5 = strlen("SKEL=");
#line 506
      tmp___6 = strncmp((char const   *)(buf___0), "SKEL=", tmp___5);
      }
#line 506
      if (tmp___6 == 0) {
        {
#line 507
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"SKEL=%s\n",
                def_template);
#line 508
        out_skel = (_Bool)1;
        }
      } else {
#line 506
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 509
    if (! out_create_mail_spool) {
      {
#line 509
      tmp___3 = strlen("CREATE_MAIL_SPOOL=");
#line 509
      tmp___4 = strncmp((char const   *)(buf___0), "CREATE_MAIL_SPOOL=", tmp___3);
      }
#line 509
      if (tmp___4 == 0) {
        {
#line 511
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"CREATE_MAIL_SPOOL=%s\n",
                def_create_mail_spool);
#line 514
        out_create_mail_spool = (_Bool)1;
        }
      } else {
        {
#line 516
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s\n",
                buf___0);
        }
      }
    } else {
      {
#line 516
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s\n",
              buf___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  fclose(ifp);
  }
  skip: 
#line 526
  if (! out_group) {
    {
#line 527
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"GROUP=%u\n",
            def_group);
    }
  }
#line 528
  if (! out_home) {
    {
#line 529
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"HOME=%s\n",
            def_home);
    }
  }
#line 530
  if (! out_inactive) {
    {
#line 531
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"INACTIVE=%ld\n",
            def_inactive);
    }
  }
#line 532
  if (! out_expire) {
    {
#line 533
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"EXPIRE=%s\n",
            def_expire);
    }
  }
#line 534
  if (! out_shell) {
    {
#line 535
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"SHELL=%s\n",
            def_shell);
    }
  }
#line 536
  if (! out_skel) {
    {
#line 537
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"SKEL=%s\n",
            def_template);
    }
  }
#line 539
  if (! out_create_mail_spool) {
    {
#line 540
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"CREATE_MAIL_SPOOL=%s\n",
            def_create_mail_spool);
    }
  }
  {
#line 546
  fflush(ofp);
#line 547
  tmp___18 = ferror(ofp);
  }
#line 547
  if (tmp___18 != 0) {
    {
#line 550
    unlink((char const   *)(new_file));
    }
#line 551
    return (-1);
  } else {
    {
#line 547
    tmp___19 = fileno(ofp);
#line 547
    tmp___20 = fsync(tmp___19);
    }
#line 547
    if (tmp___20 != 0) {
      {
#line 550
      unlink((char const   *)(new_file));
      }
#line 551
      return (-1);
    } else {
      {
#line 547
      tmp___21 = fclose(ofp);
      }
#line 547
      if (tmp___21 != 0) {
        {
#line 550
        unlink((char const   *)(new_file));
        }
#line 551
        return (-1);
      }
    }
  }
  {
#line 557
  wlen = snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%s-",
                  "/etc/default/useradd");
  }
#line 558
  if (! (wlen < (int )sizeof(buf___0))) {
    {
#line 558
    __assert_fail("wlen < (int) sizeof buf", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c",
                  558U, "set_defaults");
    }
  }
  {
#line 559
  unlink((char const   *)(buf___0));
#line 560
  tmp___25 = link("/etc/default/useradd", (char const   *)(buf___0));
  }
#line 560
  if (tmp___25 != 0) {
    {
#line 560
    tmp___26 = __errno_location();
    }
#line 560
    if (2 != *tmp___26) {
      {
#line 561
      tmp___22 = __errno_location();
#line 561
      err = *tmp___22;
#line 562
      tmp___23 = strerror(err);
#line 562
      tmp___24 = gettext("%s: Cannot create backup file (%s): %s\n");
#line 562
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              Prog, buf___0, tmp___23);
#line 565
      unlink((char const   *)(new_file));
      }
#line 566
      return (-1);
    }
  }
  {
#line 572
  tmp___30 = rename((char const   *)(new_file), "/etc/default/useradd");
  }
#line 572
  if (tmp___30 != 0) {
    {
#line 573
    tmp___27 = __errno_location();
#line 573
    err___0 = *tmp___27;
#line 574
    tmp___28 = strerror(err___0);
#line 574
    tmp___29 = gettext("%s: rename: %s: %s\n");
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___29,
            Prog, new_file, tmp___28);
    }
#line 577
    return (-1);
  }
  {
#line 585
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 585
    tmp___31 = setlocale(6, (char const   *)((void *)0));
#line 585
    old_locale = tmp___31;
#line 585
    saved_locale = (char *)((void *)0);
    }
#line 585
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 585
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 585
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 585
      setlocale(6, "C");
      }
    }
    {
#line 585
    syslog(6, "useradd defaults: GROUP=%u, HOME=%s, SHELL=%s, INACTIVE=%ld, EXPIRE=%s, SKEL=%s, CREATE_MAIL_SPOOL=%s",
           def_group, def_home, def_shell, def_inactive, def_expire, def_template,
           def_create_mail_spool);
    }
#line 585
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 585
      setlocale(6, (char const   *)saved_locale);
#line 585
      free((void *)saved_locale);
      }
    }
#line 585
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 591
  return (0);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static int get_groups(char *list___30 ) 
{ 
  char *cp ;
  struct group  const  *grp ;
  int errors___0 ;
  int ngroups___0 ;
  char *tmp ;
  struct group *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 605
  errors___0 = 0;
#line 606
  ngroups___0 = 0;
#line 608
  if (0 == (int )*list___30) {
#line 609
    return (0);
  }
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 621
    cp = strchr((char const   *)list___30, ',');
    }
#line 622
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 623
      tmp = cp;
#line 623
      cp ++;
#line 623
      *tmp = (char )'\000';
    }
    {
#line 630
    tmp___0 = getgr_nam_gid((char const   *)list___30);
#line 630
    grp = (struct group  const  *)tmp___0;
    }
#line 638
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
      {
#line 639
      tmp___1 = gettext("%s: group \'%s\' does not exist\n");
#line 639
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, list___30);
#line 642
      errors___0 ++;
      }
    }
#line 644
    list___30 = cp;
#line 650
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
#line 651
      goto __Cont;
    }
#line 667
    if ((long )ngroups___0 == sys_ngroups) {
      {
#line 668
      tmp___2 = gettext("%s: too many groups specified (max %d).\n");
#line 668
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, ngroups___0);
      }
#line 671
      goto while_break;
    }
    {
#line 677
    tmp___3 = ngroups___0;
#line 677
    ngroups___0 ++;
#line 677
    *(user_groups + tmp___3) = xstrdup((char const   *)grp->gr_name);
    }
    __Cont: /* CIL Label */ 
#line 617
    if (! ((unsigned long )((void *)0) != (unsigned long )list___30)) {
#line 617
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  *(user_groups + ngroups___0) = (char *)0;
#line 685
  if (0 != errors___0) {
#line 686
    return (-1);
  }
#line 689
  return (0);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void usage___5(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
#line 697
  if (0 != status) {
#line 697
    tmp = stderr;
  } else {
#line 697
    tmp = stdout;
  }
  {
#line 697
  usageout = tmp;
#line 698
  tmp___0 = gettext("Usage: %s [options] LOGIN\n       %s -D\n       %s -D [options]\n\nOptions:\n");
#line 698
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog, Prog, Prog);
#line 705
  tmp___1 = gettext("  -b, --base-dir BASE_DIR       base directory for the home directory of the\n                                new account\n");
#line 705
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 707
  tmp___2 = gettext("  -c, --comment COMMENT         GECOS field of the new account\n");
#line 707
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 708
  tmp___3 = gettext("  -d, --home-dir HOME_DIR       home directory of the new account\n");
#line 708
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 709
  tmp___4 = gettext("  -D, --defaults                print or change default useradd configuration\n");
#line 709
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 710
  tmp___5 = gettext("  -e, --expiredate EXPIRE_DATE  expiration date of the new account\n");
#line 710
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 711
  tmp___6 = gettext("  -f, --inactive INACTIVE       password inactivity period of the new account\n");
#line 711
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 712
  tmp___7 = gettext("  -g, --gid GROUP               name or ID of the primary group of the new\n                                account\n");
#line 712
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 714
  tmp___8 = gettext("  -G, --groups GROUPS           list of supplementary groups of the new\n                                account\n");
#line 714
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 716
  tmp___9 = gettext("  -h, --help                    display this help message and exit\n");
#line 716
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)usageout);
#line 717
  tmp___10 = gettext("  -k, --skel SKEL_DIR           use this alternative skeleton directory\n");
#line 717
  fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)usageout);
#line 718
  tmp___11 = gettext("  -K, --key KEY=VALUE           override /etc/login.defs defaults\n");
#line 718
  fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)usageout);
#line 719
  tmp___12 = gettext("  -l, --no-log-init             do not add the user to the lastlog and\n                                faillog databases\n");
#line 719
  fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)usageout);
#line 721
  tmp___13 = gettext("  -m, --create-home             create the user\'s home directory\n");
#line 721
  fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)usageout);
#line 722
  tmp___14 = gettext("  -M, --no-create-home          do not create the user\'s home directory\n");
#line 722
  fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)usageout);
#line 723
  tmp___15 = gettext("  -N, --no-user-group           do not create a group with the same name as\n                                the user\n");
#line 723
  fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)usageout);
#line 725
  tmp___16 = gettext("  -o, --non-unique              allow to create users with duplicate\n                                (non-unique) UID\n");
#line 725
  fputs((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)usageout);
#line 727
  tmp___17 = gettext("  -p, --password PASSWORD       encrypted password of the new account\n");
#line 727
  fputs((char const   */* __restrict  */)tmp___17, (FILE */* __restrict  */)usageout);
#line 728
  tmp___18 = gettext("  -r, --system                  create a system account\n");
#line 728
  fputs((char const   */* __restrict  */)tmp___18, (FILE */* __restrict  */)usageout);
#line 729
  tmp___19 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 729
  fputs((char const   */* __restrict  */)tmp___19, (FILE */* __restrict  */)usageout);
#line 730
  tmp___20 = gettext("  -s, --shell SHELL             login shell of the new account\n");
#line 730
  fputs((char const   */* __restrict  */)tmp___20, (FILE */* __restrict  */)usageout);
#line 731
  tmp___21 = gettext("  -u, --uid UID                 user ID of the new account\n");
#line 731
  fputs((char const   */* __restrict  */)tmp___21, (FILE */* __restrict  */)usageout);
#line 732
  tmp___22 = gettext("  -U, --user-group              create a group with the same name as the user\n");
#line 732
  fputs((char const   */* __restrict  */)tmp___22, (FILE */* __restrict  */)usageout);
#line 736
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 737
  exit(status);
  }
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void new_pwent(struct passwd *pwent___0 ) 
{ 


  {
  {
#line 748
  memset((void *)pwent___0, 0, sizeof(*pwent___0));
#line 749
  pwent___0->pw_name = (char *)user_name___0;
  }
#line 750
  if (is_shadow_pwd) {
#line 751
    pwent___0->pw_passwd = (char *)"x";
  } else {
#line 753
    pwent___0->pw_passwd = (char *)user_pass;
  }
#line 756
  pwent___0->pw_uid = user_id;
#line 757
  pwent___0->pw_gid = user_gid;
#line 758
  pwent___0->pw_gecos = (char *)user_comment;
#line 759
  pwent___0->pw_dir = (char *)user_home;
#line 760
  pwent___0->pw_shell = (char *)user_shell;
#line 761
  return;
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static long scale_age(long x ) 
{ 


  {
#line 765
  if (x <= 0L) {
#line 766
    return (x);
  }
#line 769
  return (x);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void new_spent(struct spwd *spent ) 
{ 
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 780
  memset((void *)spent, 0, sizeof(*spent));
#line 781
  spent->sp_namp = (char *)user_name___0;
#line 782
  spent->sp_pwdp = (char *)user_pass;
#line 783
  tmp = time((time_t *)0);
#line 783
  spent->sp_lstchg = tmp / 86400L;
  }
#line 784
  if (0L == spent->sp_lstchg) {
#line 786
    spent->sp_lstchg = -1L;
  }
#line 788
  if (! rflg___2) {
    {
#line 789
    tmp___0 = getdef_num("PASS_MIN_DAYS", -1);
#line 789
    spent->sp_min = scale_age((long )tmp___0);
#line 790
    tmp___1 = getdef_num("PASS_MAX_DAYS", -1);
#line 790
    spent->sp_max = scale_age((long )tmp___1);
#line 791
    tmp___2 = getdef_num("PASS_WARN_AGE", -1);
#line 791
    spent->sp_warn = scale_age((long )tmp___2);
#line 792
    spent->sp_inact = scale_age(def_inactive);
#line 793
    spent->sp_expire = scale_age(user_expire);
    }
  } else {
#line 795
    spent->sp_min = -1L;
#line 796
    spent->sp_max = -1L;
#line 797
    spent->sp_warn = -1L;
#line 798
    spent->sp_inact = -1L;
#line 799
    spent->sp_expire = -1L;
  }
#line 801
  spent->sp_flag = 0xffffffffffffffffUL;
#line 802
  return;
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void grp_update(void) 
{ 
  struct group  const  *grp ;
  struct group *ngrp ;
  struct sgrp  const  *sgrp ;
  struct sgrp *nsgrp ;
  _Bool tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *old_locale___1 ;
  char *tmp___9 ;
  char *saved_locale___1 ;
  struct group  const  *tmp___10 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *old_locale___2 ;
  char *tmp___14 ;
  char *saved_locale___2 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char *old_locale___3 ;
  char *tmp___18 ;
  char *saved_locale___3 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char *old_locale___4 ;
  char *tmp___21 ;
  char *saved_locale___4 ;

  {
  {
#line 831
  gr_rewind();
#line 831
  grp = gr_next();
  }
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 831
    if (! ((unsigned long )((void *)0) != (unsigned long )grp)) {
#line 831
      goto while_break;
    }
    {
#line 837
    tmp = is_on_list((char * const  *)user_groups, (char const   *)grp->gr_name);
    }
#line 837
    if (! tmp) {
#line 838
      goto __Cont;
    }
    {
#line 845
    ngrp = __gr_dup(grp);
    }
#line 846
    if ((unsigned long )((void *)0) == (unsigned long )ngrp) {
      {
#line 847
      tmp___0 = gr_dbname();
#line 847
      tmp___1 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 847
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, tmp___0);
      }
      {
#line 850
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 850
        tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 850
        old_locale = tmp___2;
#line 850
        saved_locale = (char *)((void *)0);
        }
#line 850
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 850
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 850
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 850
          setlocale(6, "C");
          }
        }
        {
#line 850
        tmp___3 = gr_dbname();
#line 850
        syslog(3, "failed to prepare the new %s entry \'%s\'", tmp___3, user_name___0);
        }
#line 850
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 850
          setlocale(6, (char const   *)saved_locale);
#line 850
          free((void *)saved_locale);
          }
        }
#line 850
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 857
      fail_exit___2(10);
      }
    }
    {
#line 864
    ngrp->gr_mem = add_list(ngrp->gr_mem, user_name___0);
#line 865
    tmp___8 = gr_update((struct group  const  *)ngrp);
    }
#line 865
    if (tmp___8 == 0) {
      {
#line 866
      tmp___4 = gr_dbname();
#line 866
      tmp___5 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 866
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4, ngrp->gr_name);
      }
      {
#line 869
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 869
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 869
        old_locale___0 = tmp___6;
#line 869
        saved_locale___0 = (char *)((void *)0);
        }
#line 869
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 869
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 869
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 869
          setlocale(6, "C");
          }
        }
        {
#line 869
        tmp___7 = gr_dbname();
#line 869
        syslog(3, "failed to prepare the new %s entry \'%s\'", tmp___7, user_name___0);
        }
#line 869
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 869
          setlocale(6, (char const   *)saved_locale___0);
#line 869
          free((void *)saved_locale___0);
          }
        }
#line 869
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 876
      fail_exit___2(10);
      }
    }
    {
#line 884
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 884
      tmp___9 = setlocale(6, (char const   *)((void *)0));
#line 884
      old_locale___1 = tmp___9;
#line 884
      saved_locale___1 = (char *)((void *)0);
      }
#line 884
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 884
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 884
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 884
        setlocale(6, "C");
        }
      }
      {
#line 884
      syslog(6, "add \'%s\' to group \'%s\'", user_name___0, ngrp->gr_name);
      }
#line 884
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 884
        setlocale(6, (char const   *)saved_locale___1);
#line 884
        free((void *)saved_locale___1);
        }
      }
#line 884
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
    {
#line 831
    grp = gr_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 890
  if (! is_shadow_grp___0) {
#line 891
    return;
  }
  {
#line 898
  sgr_rewind();
#line 898
  sgrp = sgr_next();
  }
  {
#line 898
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 898
    if (! ((unsigned long )((void *)0) != (unsigned long )sgrp)) {
#line 898
      goto while_break___3;
    }
    {
#line 908
    tmp___10 = gr_locate((char const   *)sgrp->sg_name);
    }
#line 908
    if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 909
      goto __Cont___0;
    }
    {
#line 912
    tmp___11 = is_on_list((char * const  *)user_groups, (char const   *)sgrp->sg_name);
    }
#line 912
    if (! tmp___11) {
#line 913
      goto __Cont___0;
    }
    {
#line 920
    nsgrp = __sgr_dup(sgrp);
    }
#line 921
    if ((unsigned long )((void *)0) == (unsigned long )nsgrp) {
      {
#line 922
      tmp___12 = sgr_dbname();
#line 922
      tmp___13 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 922
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
              Prog, tmp___12);
      }
      {
#line 925
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 925
        tmp___14 = setlocale(6, (char const   *)((void *)0));
#line 925
        old_locale___2 = tmp___14;
#line 925
        saved_locale___2 = (char *)((void *)0);
        }
#line 925
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 925
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 925
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 925
          setlocale(6, "C");
          }
        }
        {
#line 925
        tmp___15 = sgr_dbname();
#line 925
        syslog(3, "failed to prepare the new %s entry \'%s\'", tmp___15, user_name___0);
        }
#line 925
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 925
          setlocale(6, (char const   *)saved_locale___2);
#line 925
          free((void *)saved_locale___2);
          }
        }
#line 925
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 932
      fail_exit___2(10);
      }
    }
    {
#line 939
    nsgrp->sg_mem = add_list(nsgrp->sg_mem, user_name___0);
#line 940
    tmp___20 = sgr_update((struct sgrp  const  *)nsgrp);
    }
#line 940
    if (tmp___20 == 0) {
      {
#line 941
      tmp___16 = sgr_dbname();
#line 941
      tmp___17 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 941
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
              Prog, tmp___16, nsgrp->sg_name);
      }
      {
#line 944
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 944
        tmp___18 = setlocale(6, (char const   *)((void *)0));
#line 944
        old_locale___3 = tmp___18;
#line 944
        saved_locale___3 = (char *)((void *)0);
        }
#line 944
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
          {
#line 944
          saved_locale___3 = strdup((char const   *)old_locale___3);
          }
        }
#line 944
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 944
          setlocale(6, "C");
          }
        }
        {
#line 944
        tmp___19 = sgr_dbname();
#line 944
        syslog(3, "failed to prepare the new %s entry \'%s\'", tmp___19, user_name___0);
        }
#line 944
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 944
          setlocale(6, (char const   *)saved_locale___3);
#line 944
          free((void *)saved_locale___3);
          }
        }
#line 944
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 951
      fail_exit___2(10);
      }
    }
    {
#line 959
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 959
      tmp___21 = setlocale(6, (char const   *)((void *)0));
#line 959
      old_locale___4 = tmp___21;
#line 959
      saved_locale___4 = (char *)((void *)0);
      }
#line 959
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
        {
#line 959
        saved_locale___4 = strdup((char const   *)old_locale___4);
        }
      }
#line 959
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 959
        setlocale(6, "C");
        }
      }
      {
#line 959
      syslog(6, "add \'%s\' to shadow group \'%s\'", user_name___0, nsgrp->sg_name);
      }
#line 959
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 959
        setlocale(6, (char const   *)saved_locale___4);
#line 959
        free((void *)saved_locale___4);
        }
      }
#line 959
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
    {
#line 898
    sgrp = sgr_next();
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 964
  return;
}
}
#line 984 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static struct option long_options___4[23]  = 
#line 984
  {      {"base-dir", 1, (int *)((void *)0), 'b'}, 
        {"comment", 1, (int *)((void *)0), 'c'}, 
        {"home-dir", 1, (int *)((void *)0), 'd'}, 
        {"defaults", 0, (int *)((void *)0), 'D'}, 
        {"expiredate", 1, (int *)((void *)0), 'e'}, 
        {"inactive", 1, (int *)((void *)0), 'f'}, 
        {"gid", 1, (int *)((void *)0), 'g'}, 
        {"groups", 1, (int *)((void *)0), 'G'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"skel", 1, (int *)((void *)0), 'k'}, 
        {"key", 1, (int *)((void *)0), 'K'}, 
        {"no-log-init", 0, (int *)((void *)0), 'l'}, 
        {"create-home", 0, (int *)((void *)0), 'm'}, 
        {"no-create-home", 0, (int *)((void *)0), 'M'}, 
        {"no-user-group", 0, (int *)((void *)0), 'N'}, 
        {"non-unique", 0, (int *)((void *)0), 'o'}, 
        {"password", 1, (int *)((void *)0), 'p'}, 
        {"system", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"shell", 1, (int *)((void *)0), 's'}, 
        {"uid", 1, (int *)((void *)0), 'u'}, 
        {"user-group", 0, (int *)((void *)0), 'U'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 973 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void process_flags___3(int argc , char **argv ) 
{ 
  struct group  const  *grp ;
  _Bool anyflag___0 ;
  char *cp ;
  int c ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  struct group *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  _Bool tmp___32 ;
  char *uh ;
  size_t len ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  int wlen ;
  _Bool tmp___35 ;

  {
#line 976
  anyflag___0 = (_Bool)0;
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1012
    c = getopt_long(argc, (char * const  *)argv, "b:c:d:De:f:g:G:hk:K:lmMNop:rR:s:u:U",
                    (struct option  const  *)(long_options___4), (int *)((void *)0));
    }
#line 1012
    if (! (c != -1)) {
#line 1012
      goto while_break;
    }
    {
#line 1020
    if (c == 98) {
#line 1020
      goto case_98;
    }
#line 1031
    if (c == 99) {
#line 1031
      goto case_99;
    }
#line 1041
    if (c == 100) {
#line 1041
      goto case_100;
    }
#line 1052
    if (c == 68) {
#line 1052
      goto case_68;
    }
#line 1058
    if (c == 101) {
#line 1058
      goto case_101;
    }
#line 1086
    if (c == 102) {
#line 1086
      goto case_102;
    }
#line 1106
    if (c == 103) {
#line 1106
      goto case_103;
    }
#line 1122
    if (c == 71) {
#line 1122
      goto case_71;
    }
#line 1131
    if (c == 104) {
#line 1131
      goto case_104;
    }
#line 1134
    if (c == 107) {
#line 1134
      goto case_107;
    }
#line 1138
    if (c == 75) {
#line 1138
      goto case_75;
    }
#line 1158
    if (c == 108) {
#line 1158
      goto case_108;
    }
#line 1161
    if (c == 109) {
#line 1161
      goto case_109;
    }
#line 1164
    if (c == 77) {
#line 1164
      goto case_77;
    }
#line 1167
    if (c == 78) {
#line 1167
      goto case_78;
    }
#line 1170
    if (c == 111) {
#line 1170
      goto case_111;
    }
#line 1173
    if (c == 112) {
#line 1173
      goto case_112;
    }
#line 1182
    if (c == 114) {
#line 1182
      goto case_114;
    }
#line 1185
    if (c == 82) {
#line 1185
      goto case_82;
    }
#line 1187
    if (c == 115) {
#line 1187
      goto case_115;
    }
#line 1201
    if (c == 117) {
#line 1201
      goto case_117;
    }
#line 1211
    if (c == 85) {
#line 1211
      goto case_85;
    }
#line 1227
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 1021
    tmp___0 = strcspn((char const   *)optarg, ":\n");
#line 1021
    tmp___1 = strlen((char const   *)optarg);
    }
#line 1021
    if (tmp___0 == tmp___1) {
#line 1021
      if ((int )*(optarg + 0) != 47) {
        {
#line 1023
        tmp = gettext("%s: invalid base directory \'%s\'\n");
#line 1023
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                Prog, optarg);
#line 1026
        exit(3);
        }
      }
    } else {
      {
#line 1023
      tmp = gettext("%s: invalid base directory \'%s\'\n");
#line 1023
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 1026
      exit(3);
      }
    }
#line 1028
    def_home = (char const   *)optarg;
#line 1029
    bflg = (_Bool)1;
#line 1030
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 1032
    tmp___3 = strcspn((char const   *)optarg, ":\n");
#line 1032
    tmp___4 = strlen((char const   *)optarg);
    }
#line 1032
    if (! (tmp___3 == tmp___4)) {
      {
#line 1033
      tmp___2 = gettext("%s: invalid comment \'%s\'\n");
#line 1033
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, optarg);
#line 1036
      exit(3);
      }
    }
#line 1038
    user_comment = (char const   *)optarg;
#line 1039
    cflg = (_Bool)1;
#line 1040
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1042
    tmp___6 = strcspn((char const   *)optarg, ":\n");
#line 1042
    tmp___7 = strlen((char const   *)optarg);
    }
#line 1042
    if (tmp___6 == tmp___7) {
#line 1042
      if ((int )*(optarg + 0) != 47) {
        {
#line 1044
        tmp___5 = gettext("%s: invalid home directory \'%s\'\n");
#line 1044
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, optarg);
#line 1047
        exit(3);
        }
      }
    } else {
      {
#line 1044
      tmp___5 = gettext("%s: invalid home directory \'%s\'\n");
#line 1044
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, optarg);
#line 1047
      exit(3);
      }
    }
#line 1049
    user_home = (char const   *)optarg;
#line 1050
    dflg___1 = (_Bool)1;
#line 1051
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1053
    if (anyflag___0) {
      {
#line 1054
      usage___5(2);
      }
    }
#line 1056
    Dflg = (_Bool)1;
#line 1057
    goto switch_break;
    case_101: /* CIL Label */ 
#line 1059
    if (0 != (int )*optarg) {
      {
#line 1060
      user_expire = strtoday((char const   *)optarg);
      }
#line 1061
      if (user_expire < -1L) {
        {
#line 1062
        tmp___8 = gettext("%s: invalid date \'%s\'\n");
#line 1062
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
                Prog, optarg);
#line 1065
        exit(3);
        }
      }
    } else {
#line 1068
      user_expire = -1L;
    }
#line 1075
    if (-1L != user_expire) {
#line 1075
      if (! is_shadow_pwd) {
        {
#line 1076
        tmp___9 = gettext("%s: shadow passwords required for -e\n");
#line 1076
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
                Prog);
#line 1079
        exit(2);
        }
      }
    }
#line 1081
    if (Dflg) {
#line 1082
      def_expire = (char const   *)optarg;
    }
#line 1084
    eflg = (_Bool)1;
#line 1085
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 1087
    tmp___11 = getlong((char const   *)optarg, & def_inactive);
    }
#line 1087
    if (tmp___11 == 0) {
      {
#line 1089
      tmp___10 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 1089
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, optarg);
#line 1092
      exit(3);
      }
    } else
#line 1087
    if (def_inactive < -1L) {
      {
#line 1089
      tmp___10 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 1089
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, optarg);
#line 1092
      exit(3);
      }
    }
#line 1098
    if (-1L != def_inactive) {
#line 1098
      if (! is_shadow_pwd) {
        {
#line 1099
        tmp___12 = gettext("%s: shadow passwords required for -f\n");
#line 1099
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                Prog);
#line 1102
        exit(2);
        }
      }
    }
#line 1104
    fflg = (_Bool)1;
#line 1105
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 1107
    tmp___13 = getgr_nam_gid((char const   *)optarg);
#line 1107
    grp = (struct group  const  *)tmp___13;
    }
#line 1108
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
      {
#line 1109
      tmp___14 = gettext("%s: group \'%s\' does not exist\n");
#line 1109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
              Prog, optarg);
#line 1112
      exit(6);
      }
    }
#line 1114
    if (Dflg) {
#line 1115
      def_group = (gid_t )grp->gr_gid;
#line 1116
      def_gname = (char const   *)optarg;
    } else {
#line 1118
      user_gid = (gid_t )grp->gr_gid;
    }
#line 1120
    gflg = (_Bool)1;
#line 1121
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 1123
    tmp___15 = get_groups(optarg);
    }
#line 1123
    if (tmp___15 != 0) {
      {
#line 1124
      exit(6);
      }
    }
#line 1126
    if ((unsigned long )((void *)0) != (unsigned long )*(user_groups + 0)) {
#line 1127
      do_grp_update = (_Bool)1;
    }
#line 1129
    Gflg = (_Bool)1;
#line 1130
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1132
    usage___5(0);
    }
#line 1133
    goto switch_break;
    case_107: /* CIL Label */ 
#line 1135
    def_template = (char const   *)optarg;
#line 1136
    kflg = (_Bool)1;
#line 1137
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1144
    cp = strchr((char const   *)optarg, '=');
    }
#line 1145
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 1146
      tmp___16 = gettext("%s: -K requires KEY=VALUE\n");
#line 1146
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
              Prog);
#line 1149
      exit(3);
      }
    }
    {
#line 1152
    *cp = (char )'\000';
#line 1153
    cp ++;
#line 1154
    tmp___17 = putdef_str((char const   *)optarg, (char const   *)cp);
    }
#line 1154
    if (tmp___17 < 0) {
      {
#line 1155
      exit(3);
      }
    }
#line 1157
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1159
    lflg___1 = (_Bool)1;
#line 1160
    goto switch_break;
    case_109: /* CIL Label */ 
#line 1162
    mflg___1 = (_Bool)1;
#line 1163
    goto switch_break;
    case_77: /* CIL Label */ 
#line 1165
    Mflg___1 = (_Bool)1;
#line 1166
    goto switch_break;
    case_78: /* CIL Label */ 
#line 1168
    Nflg = (_Bool)1;
#line 1169
    goto switch_break;
    case_111: /* CIL Label */ 
#line 1171
    oflg = (_Bool)1;
#line 1172
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 1174
    tmp___19 = strcspn((char const   *)optarg, ":\n");
#line 1174
    tmp___20 = strlen((char const   *)optarg);
    }
#line 1174
    if (! (tmp___19 == tmp___20)) {
      {
#line 1175
      tmp___18 = gettext("%s: invalid field \'%s\'\n");
#line 1175
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
              Prog, optarg);
#line 1178
      exit(3);
      }
    }
#line 1180
    user_pass = (char const   *)optarg;
#line 1181
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1183
    rflg___2 = (_Bool)1;
#line 1184
    goto switch_break;
    case_82: /* CIL Label */ 
#line 1186
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1188
    tmp___22 = strcspn((char const   *)optarg, ":\n");
#line 1188
    tmp___23 = strlen((char const   *)optarg);
    }
#line 1188
    if (tmp___22 == tmp___23) {
#line 1188
      if (0 != (int )*(optarg + 0)) {
#line 1188
        if (47 != (int )*(optarg + 0)) {
#line 1188
          if (42 != (int )*(optarg + 0)) {
            {
#line 1192
            tmp___21 = gettext("%s: invalid shell \'%s\'\n");
#line 1192
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
                    Prog, optarg);
#line 1195
            exit(3);
            }
          }
        }
      }
    } else {
      {
#line 1192
      tmp___21 = gettext("%s: invalid shell \'%s\'\n");
#line 1192
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
              Prog, optarg);
#line 1195
      exit(3);
      }
    }
#line 1197
    user_shell = (char const   *)optarg;
#line 1198
    def_shell = (char const   *)optarg;
#line 1199
    sflg___0 = (_Bool)1;
#line 1200
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 1202
    tmp___25 = get_uid((char const   *)optarg, & user_id);
    }
#line 1202
    if (tmp___25 == 0) {
      {
#line 1204
      tmp___24 = gettext("%s: invalid user ID \'%s\'\n");
#line 1204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              Prog, optarg);
#line 1207
      exit(3);
      }
    } else
#line 1202
    if (user_id == 4294967295U) {
      {
#line 1204
      tmp___24 = gettext("%s: invalid user ID \'%s\'\n");
#line 1204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              Prog, optarg);
#line 1207
      exit(3);
      }
    }
#line 1209
    uflg___0 = (_Bool)1;
#line 1210
    goto switch_break;
    case_85: /* CIL Label */ 
#line 1212
    Uflg = (_Bool)1;
#line 1213
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1228
    usage___5(2);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1230
    anyflag___0 = (_Bool)1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1234
  if (! gflg) {
#line 1234
    if (! Nflg) {
#line 1234
      if (! Uflg) {
        {
#line 1236
        Uflg = getdef_bool("USERGROUPS_ENAB");
        }
      }
    }
  }
#line 1243
  if (oflg) {
#line 1243
    if (! uflg___0) {
      {
#line 1244
      tmp___26 = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 1244
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___26,
              Prog, "-o", "-u");
#line 1247
      usage___5(2);
      }
    }
  }
#line 1249
  if (kflg) {
#line 1249
    if (! mflg___1) {
      {
#line 1250
      tmp___27 = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 1250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___27,
              Prog, "-k", "-m");
#line 1253
      usage___5(2);
      }
    }
  }
#line 1255
  if (Uflg) {
#line 1255
    if (gflg) {
      {
#line 1256
      tmp___28 = gettext("%s: options %s and %s conflict\n");
#line 1256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
              Prog, "-U", "-g");
#line 1259
      usage___5(2);
      }
    }
  }
#line 1261
  if (Uflg) {
#line 1261
    if (Nflg) {
      {
#line 1262
      tmp___29 = gettext("%s: options %s and %s conflict\n");
#line 1262
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___29,
              Prog, "-U", "-N");
#line 1265
      usage___5(2);
      }
    }
  }
#line 1267
  if (mflg___1) {
#line 1267
    if (Mflg___1) {
      {
#line 1268
      tmp___30 = gettext("%s: options %s and %s conflict\n");
#line 1268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
              Prog, "-m", "-M");
#line 1271
      usage___5(2);
      }
    }
  }
#line 1278
  if (Dflg) {
#line 1279
    if (optind != argc) {
      {
#line 1280
      usage___5(2);
      }
    }
#line 1283
    if (uflg___0) {
      {
#line 1284
      usage___5(2);
      }
    } else
#line 1283
    if (Gflg) {
      {
#line 1284
      usage___5(2);
      }
    } else
#line 1283
    if (dflg___1) {
      {
#line 1284
      usage___5(2);
      }
    } else
#line 1283
    if (cflg) {
      {
#line 1284
      usage___5(2);
      }
    } else
#line 1283
    if (mflg___1) {
      {
#line 1284
      usage___5(2);
      }
    }
  } else {
#line 1287
    if (optind != argc - 1) {
      {
#line 1288
      usage___5(2);
      }
    }
    {
#line 1291
    user_name___0 = (char const   *)*(argv + optind);
#line 1292
    tmp___32 = is_valid_user_name(user_name___0);
    }
#line 1292
    if (! tmp___32) {
      {
#line 1293
      tmp___31 = gettext("%s: invalid user name \'%s\'\n");
#line 1293
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___31,
              Prog, user_name___0);
#line 1302
      exit(3);
      }
    }
#line 1304
    if (! dflg___1) {
      {
#line 1306
      tmp___33 = strlen(def_home);
#line 1306
      tmp___34 = strlen(user_name___0);
#line 1306
      len = (tmp___33 + tmp___34) + 2UL;
#line 1309
      uh = xmalloc(len);
#line 1310
      wlen = snprintf((char */* __restrict  */)uh, len, (char const   */* __restrict  */)"%s/%s",
                      def_home, user_name___0);
      }
#line 1311
      if (! (wlen == (int )len - 1)) {
        {
#line 1311
        __assert_fail("wlen == (int) len -1", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c",
                      1311U, "process_flags");
        }
      }
#line 1313
      user_home = (char const   *)uh;
    }
  }
#line 1317
  if (! eflg) {
    {
#line 1318
    user_expire = strtoday(def_expire);
    }
  }
#line 1321
  if (! gflg) {
#line 1322
    user_gid = def_group;
  }
#line 1325
  if (! sflg___0) {
#line 1326
    user_shell = def_shell;
  }
#line 1329
  create_mail_spool = def_create_mail_spool;
#line 1331
  if (! rflg___2) {
    {
#line 1334
    tmp___35 = getdef_bool("CREATE_HOME");
    }
#line 1334
    if (tmp___35) {
#line 1335
      mflg___1 = (_Bool)1;
    }
  }
#line 1339
  if (Mflg___1) {
#line 1341
    mflg___1 = (_Bool)0;
  }
#line 1343
  return;
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void close_files___3(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *old_locale___3 ;
  char *tmp___21 ;
  char *saved_locale___3 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char *old_locale___4 ;
  char *tmp___26 ;
  char *saved_locale___4 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char *old_locale___5 ;
  char *tmp___31 ;
  char *saved_locale___5 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  char *old_locale___6 ;
  char *tmp___36 ;
  char *saved_locale___6 ;
  char const   *tmp___37 ;
  int tmp___38 ;

  {
  {
#line 1353
  tmp___3 = pw_close();
  }
#line 1353
  if (tmp___3 == 0) {
    {
#line 1354
    tmp = pw_dbname();
#line 1354
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 1354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 1355
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1355
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 1355
      old_locale = tmp___1;
#line 1355
      saved_locale = (char *)((void *)0);
      }
#line 1355
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 1355
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 1355
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 1355
        setlocale(6, "C");
        }
      }
      {
#line 1355
      tmp___2 = pw_dbname();
#line 1355
      syslog(3, "failure while writing changes to %s", tmp___2);
      }
#line 1355
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 1355
        setlocale(6, (char const   *)saved_locale);
#line 1355
        free((void *)saved_locale);
        }
      }
#line 1355
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1356
    fail_exit___2(1);
    }
  }
#line 1358
  if (is_shadow_pwd) {
    {
#line 1358
    tmp___8 = spw_close();
    }
#line 1358
    if (tmp___8 == 0) {
      {
#line 1359
      tmp___4 = spw_dbname();
#line 1359
      tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 1359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 1361
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1361
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 1361
        old_locale___0 = tmp___6;
#line 1361
        saved_locale___0 = (char *)((void *)0);
        }
#line 1361
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 1361
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 1361
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 1361
          setlocale(6, "C");
          }
        }
        {
#line 1361
        tmp___7 = spw_dbname();
#line 1361
        syslog(3, "failure while writing changes to %s", tmp___7);
        }
#line 1361
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 1361
          setlocale(6, (char const   *)saved_locale___0);
#line 1361
          free((void *)saved_locale___0);
          }
        }
#line 1361
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1362
      fail_exit___2(1);
      }
    }
  }
#line 1364
  if (do_grp_update) {
    {
#line 1365
    tmp___13 = gr_close();
    }
#line 1365
    if (tmp___13 == 0) {
      {
#line 1366
      tmp___9 = gr_dbname();
#line 1366
      tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 1366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 1368
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1368
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 1368
        old_locale___1 = tmp___11;
#line 1368
        saved_locale___1 = (char *)((void *)0);
        }
#line 1368
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 1368
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 1368
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 1368
          setlocale(6, "C");
          }
        }
        {
#line 1368
        tmp___12 = gr_dbname();
#line 1368
        syslog(3, "failure while writing changes to %s", tmp___12);
        }
#line 1368
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 1368
          setlocale(6, (char const   *)saved_locale___1);
#line 1368
          free((void *)saved_locale___1);
          }
        }
#line 1368
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1369
      fail_exit___2(10);
      }
    }
#line 1372
    if (is_shadow_grp___0) {
      {
#line 1372
      tmp___18 = sgr_close();
      }
#line 1372
      if (tmp___18 == 0) {
        {
#line 1373
        tmp___14 = sgr_dbname();
#line 1373
        tmp___15 = gettext("%s: failure while writing changes to %s\n");
#line 1373
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                Prog, tmp___14);
        }
        {
#line 1376
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1376
          tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 1376
          old_locale___2 = tmp___16;
#line 1376
          saved_locale___2 = (char *)((void *)0);
          }
#line 1376
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
            {
#line 1376
            saved_locale___2 = strdup((char const   *)old_locale___2);
            }
          }
#line 1376
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 1376
            setlocale(6, "C");
            }
          }
          {
#line 1376
          tmp___17 = sgr_dbname();
#line 1376
          syslog(3, "failure while writing changes to %s", tmp___17);
          }
#line 1376
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 1376
            setlocale(6, (char const   *)saved_locale___2);
#line 1376
            free((void *)saved_locale___2);
            }
          }
#line 1376
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1377
        fail_exit___2(10);
        }
      }
    }
  }
#line 1381
  if (is_shadow_pwd) {
    {
#line 1382
    tmp___23 = spw_unlock();
    }
#line 1382
    if (tmp___23 == 0) {
      {
#line 1383
      tmp___19 = spw_dbname();
#line 1383
      tmp___20 = gettext("%s: failed to unlock %s\n");
#line 1383
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
              Prog, tmp___19);
      }
      {
#line 1384
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1384
        tmp___21 = setlocale(6, (char const   *)((void *)0));
#line 1384
        old_locale___3 = tmp___21;
#line 1384
        saved_locale___3 = (char *)((void *)0);
        }
#line 1384
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
          {
#line 1384
          saved_locale___3 = strdup((char const   *)old_locale___3);
          }
        }
#line 1384
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 1384
          setlocale(6, "C");
          }
        }
        {
#line 1384
        tmp___22 = spw_dbname();
#line 1384
        syslog(3, "failed to unlock %s", tmp___22);
        }
#line 1384
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 1384
          setlocale(6, (char const   *)saved_locale___3);
#line 1384
          free((void *)saved_locale___3);
          }
        }
#line 1384
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1393
    spw_locked___2 = (_Bool)0;
  }
  {
#line 1395
  tmp___28 = pw_unlock();
  }
#line 1395
  if (tmp___28 == 0) {
    {
#line 1396
    tmp___24 = pw_dbname();
#line 1396
    tmp___25 = gettext("%s: failed to unlock %s\n");
#line 1396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___25,
            Prog, tmp___24);
    }
    {
#line 1397
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1397
      tmp___26 = setlocale(6, (char const   *)((void *)0));
#line 1397
      old_locale___4 = tmp___26;
#line 1397
      saved_locale___4 = (char *)((void *)0);
      }
#line 1397
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
        {
#line 1397
        saved_locale___4 = strdup((char const   *)old_locale___4);
        }
      }
#line 1397
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 1397
        setlocale(6, "C");
        }
      }
      {
#line 1397
      tmp___27 = pw_dbname();
#line 1397
      syslog(3, "failed to unlock %s", tmp___27);
      }
#line 1397
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 1397
        setlocale(6, (char const   *)saved_locale___4);
#line 1397
        free((void *)saved_locale___4);
        }
      }
#line 1397
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1406
  pw_locked___2 = (_Bool)0;
#line 1407
  tmp___33 = gr_unlock();
  }
#line 1407
  if (tmp___33 == 0) {
    {
#line 1408
    tmp___29 = gr_dbname();
#line 1408
    tmp___30 = gettext("%s: failed to unlock %s\n");
#line 1408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
            Prog, tmp___29);
    }
    {
#line 1409
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1409
      tmp___31 = setlocale(6, (char const   *)((void *)0));
#line 1409
      old_locale___5 = tmp___31;
#line 1409
      saved_locale___5 = (char *)((void *)0);
      }
#line 1409
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
        {
#line 1409
        saved_locale___5 = strdup((char const   *)old_locale___5);
        }
      }
#line 1409
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
        {
#line 1409
        setlocale(6, "C");
        }
      }
      {
#line 1409
      tmp___32 = gr_dbname();
#line 1409
      syslog(3, "failed to unlock %s", tmp___32);
      }
#line 1409
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
        {
#line 1409
        setlocale(6, (char const   *)saved_locale___5);
#line 1409
        free((void *)saved_locale___5);
        }
      }
#line 1409
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1418
  gr_locked___0 = (_Bool)0;
#line 1420
  if (is_shadow_grp___0) {
    {
#line 1421
    tmp___38 = sgr_unlock();
    }
#line 1421
    if (tmp___38 == 0) {
      {
#line 1422
      tmp___34 = sgr_dbname();
#line 1422
      tmp___35 = gettext("%s: failed to unlock %s\n");
#line 1422
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
              Prog, tmp___34);
      }
      {
#line 1423
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1423
        tmp___36 = setlocale(6, (char const   *)((void *)0));
#line 1423
        old_locale___6 = tmp___36;
#line 1423
        saved_locale___6 = (char *)((void *)0);
        }
#line 1423
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___6) {
          {
#line 1423
          saved_locale___6 = strdup((char const   *)old_locale___6);
          }
        }
#line 1423
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
          {
#line 1423
          setlocale(6, "C");
          }
        }
        {
#line 1423
        tmp___37 = sgr_dbname();
#line 1423
        syslog(3, "failed to unlock %s", tmp___37);
        }
#line 1423
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
          {
#line 1423
          setlocale(6, (char const   *)saved_locale___6);
#line 1423
          free((void *)saved_locale___6);
          }
        }
#line 1423
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1432
    sgr_locked___0 = (_Bool)0;
  }
#line 1435
  return;
}
}
#line 1442 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void open_files___3(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
  {
#line 1444
  tmp___1 = pw_lock();
  }
#line 1444
  if (tmp___1 == 0) {
    {
#line 1445
    tmp = pw_dbname();
#line 1445
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 1445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 1448
    exit(1);
    }
  }
  {
#line 1450
  pw_locked___2 = (_Bool)1;
#line 1451
  tmp___4 = pw_open(2);
  }
#line 1451
  if (tmp___4 == 0) {
    {
#line 1452
    tmp___2 = pw_dbname();
#line 1452
    tmp___3 = gettext("%s: cannot open %s\n");
#line 1452
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 1453
    fail_exit___2(1);
    }
  }
  {
#line 1461
  tmp___7 = gr_lock();
  }
#line 1461
  if (tmp___7 == 0) {
    {
#line 1462
    tmp___5 = gr_dbname();
#line 1462
    tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 1462
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
#line 1465
    fail_exit___2(10);
    }
  }
  {
#line 1467
  gr_locked___0 = (_Bool)1;
#line 1468
  tmp___10 = gr_open(2);
  }
#line 1468
  if (tmp___10 == 0) {
    {
#line 1469
    tmp___8 = gr_dbname();
#line 1469
    tmp___9 = gettext("%s: cannot open %s\n");
#line 1469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
            Prog, tmp___8);
#line 1470
    fail_exit___2(10);
    }
  }
#line 1473
  if (is_shadow_grp___0) {
    {
#line 1474
    tmp___13 = sgr_lock();
    }
#line 1474
    if (tmp___13 == 0) {
      {
#line 1475
      tmp___11 = sgr_dbname();
#line 1475
      tmp___12 = gettext("%s: cannot lock %s; try again later.\n");
#line 1475
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
              Prog, tmp___11);
#line 1478
      fail_exit___2(10);
      }
    }
    {
#line 1480
    sgr_locked___0 = (_Bool)1;
#line 1481
    tmp___16 = sgr_open(2);
    }
#line 1481
    if (tmp___16 == 0) {
      {
#line 1482
      tmp___14 = sgr_dbname();
#line 1482
      tmp___15 = gettext("%s: cannot open %s\n");
#line 1482
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
#line 1485
      fail_exit___2(10);
      }
    }
  }
#line 1489
  return;
}
}
#line 1491 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void open_shadow(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1493
  if (! is_shadow_pwd) {
#line 1494
    return;
  }
  {
#line 1496
  tmp___1 = spw_lock();
  }
#line 1496
  if (tmp___1 == 0) {
    {
#line 1497
    tmp = spw_dbname();
#line 1497
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 1497
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 1500
    fail_exit___2(1);
    }
  }
  {
#line 1502
  spw_locked___2 = (_Bool)1;
#line 1503
  tmp___4 = spw_open(2);
  }
#line 1503
  if (tmp___4 == 0) {
    {
#line 1504
    tmp___2 = spw_dbname();
#line 1504
    tmp___3 = gettext("%s: cannot open %s\n");
#line 1504
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 1507
    fail_exit___2(1);
    }
  }
#line 1509
  return;
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static char *empty_list  =    (char *)((void *)0);
#line 1520 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void new_grent(struct group *grent___29 ) 
{ 


  {
  {
#line 1522
  memset((void *)grent___29, 0, sizeof(*grent___29));
#line 1523
  grent___29->gr_name = (char *)user_name___0;
  }
#line 1525
  if (is_shadow_grp___0) {
#line 1526
    grent___29->gr_passwd = (char *)"x";
  } else {
#line 1530
    grent___29->gr_passwd = (char *)"!";
  }
#line 1532
  grent___29->gr_gid = user_gid;
#line 1533
  grent___29->gr_mem = & empty_list;
#line 1534
  return;
}
}
#line 1544 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void new_sgent(struct sgrp *sgent ) 
{ 


  {
  {
#line 1546
  memset((void *)sgent, 0, sizeof(*sgent));
#line 1547
  sgent->sg_name = (char *)user_name___0;
#line 1548
  sgent->sg_passwd = (char *)"!";
#line 1549
  sgent->sg_adm = & empty_list;
#line 1550
  sgent->sg_mem = & empty_list;
  }
#line 1551
  return;
}
}
#line 1561 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void grp_add(void) 
{ 
  struct group grp ;
  struct sgrp sgrp ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *old_locale ;
  char *tmp___5 ;
  char *saved_locale ;

  {
  {
#line 1572
  new_grent(& grp);
#line 1574
  new_sgent(& sgrp);
#line 1580
  tmp___1 = gr_update((struct group  const  *)(& grp));
  }
#line 1580
  if (tmp___1 == 0) {
    {
#line 1581
    tmp = gr_dbname();
#line 1581
    tmp___0 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 1581
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp, grp.gr_name);
#line 1590
    fail_exit___2(10);
    }
  }
#line 1596
  if (is_shadow_grp___0) {
    {
#line 1596
    tmp___4 = sgr_update((struct sgrp  const  *)(& sgrp));
    }
#line 1596
    if (tmp___4 == 0) {
      {
#line 1597
      tmp___2 = sgr_dbname();
#line 1597
      tmp___3 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 1597
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2, sgrp.sg_name);
#line 1606
      fail_exit___2(10);
      }
    }
  }
  {
#line 1609
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1609
    tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 1609
    old_locale = tmp___5;
#line 1609
    saved_locale = (char *)((void *)0);
    }
#line 1609
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 1609
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 1609
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 1609
      setlocale(6, "C");
      }
    }
    {
#line 1609
    syslog(6, "new group: name=%s, GID=%u", user_name___0, user_gid);
    }
#line 1609
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 1609
      setlocale(6, (char const   *)saved_locale);
#line 1609
      free((void *)saved_locale);
      }
    }
#line 1609
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1616
  do_grp_update = (_Bool)1;
#line 1617
  return;
}
}
#line 1619 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void faillog_reset(uid_t uid ) 
{ 
  struct faillog fl ;
  int fd ;
  off_t offset_uid ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  __off_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1623
  offset_uid = (off_t )sizeof(fl) * (off_t )uid;
#line 1625
  tmp = access("/var/log/faillog", 0);
  }
#line 1625
  if (tmp != 0) {
#line 1626
    return;
  }
  {
#line 1629
  memset((void *)(& fl), 0, sizeof(fl));
#line 1631
  fd = open("/var/log/faillog", 2);
  }
#line 1632
  if (-1 == fd) {
#line 1632
    goto _L;
  } else {
    {
#line 1632
    tmp___4 = lseek(fd, offset_uid, 0);
    }
#line 1632
    if (tmp___4 != offset_uid) {
#line 1632
      goto _L;
    } else {
      {
#line 1632
      tmp___5 = write(fd, (void const   *)(& fl), sizeof(fl));
      }
#line 1632
      if (tmp___5 != (ssize_t )sizeof(fl)) {
#line 1632
        goto _L;
      } else {
        {
#line 1632
        tmp___6 = fsync(fd);
        }
#line 1632
        if (tmp___6 != 0) {
#line 1632
          goto _L;
        } else {
          {
#line 1632
          tmp___7 = close(fd);
          }
#line 1632
          if (tmp___7 != 0) {
            _L: /* CIL Label */ 
            {
#line 1637
            tmp___0 = __errno_location();
#line 1637
            tmp___1 = strerror(*tmp___0);
#line 1637
            tmp___2 = gettext("%s: failed to reset the faillog entry of UID %lu: %s\n");
#line 1637
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                    Prog, (unsigned long )uid, tmp___1);
            }
            {
#line 1640
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 1640
              tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 1640
              old_locale = tmp___3;
#line 1640
              saved_locale = (char *)((void *)0);
              }
#line 1640
              if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
                {
#line 1640
                saved_locale = strdup((char const   *)old_locale);
                }
              }
#line 1640
              if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
                {
#line 1640
                setlocale(6, "C");
                }
              }
              {
#line 1640
              syslog(4, "failed to reset the faillog entry of UID %lu", (unsigned long )uid);
              }
#line 1640
              if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
                {
#line 1640
                setlocale(6, (char const   *)saved_locale);
#line 1640
                free((void *)saved_locale);
                }
              }
#line 1640
              goto while_break;
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 1643
  return;
}
}
#line 1645 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void lastlog_reset(uid_t uid ) 
{ 
  struct lastlog ll___0 ;
  int fd ;
  off_t offset_uid ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  __off_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1649
  offset_uid = (off_t )sizeof(ll___0) * (off_t )uid;
#line 1651
  tmp = access("/var/log/lastlog", 0);
  }
#line 1651
  if (tmp != 0) {
#line 1652
    return;
  }
  {
#line 1655
  memset((void *)(& ll___0), 0, sizeof(ll___0));
#line 1657
  fd = open("/var/log/lastlog", 2);
  }
#line 1658
  if (-1 == fd) {
#line 1658
    goto _L;
  } else {
    {
#line 1658
    tmp___4 = lseek(fd, offset_uid, 0);
    }
#line 1658
    if (tmp___4 != offset_uid) {
#line 1658
      goto _L;
    } else {
      {
#line 1658
      tmp___5 = write(fd, (void const   *)(& ll___0), sizeof(ll___0));
      }
#line 1658
      if (tmp___5 != (ssize_t )sizeof(ll___0)) {
#line 1658
        goto _L;
      } else {
        {
#line 1658
        tmp___6 = fsync(fd);
        }
#line 1658
        if (tmp___6 != 0) {
#line 1658
          goto _L;
        } else {
          {
#line 1658
          tmp___7 = close(fd);
          }
#line 1658
          if (tmp___7 != 0) {
            _L: /* CIL Label */ 
            {
#line 1663
            tmp___0 = __errno_location();
#line 1663
            tmp___1 = strerror(*tmp___0);
#line 1663
            tmp___2 = gettext("%s: failed to reset the lastlog entry of UID %lu: %s\n");
#line 1663
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                    Prog, (unsigned long )uid, tmp___1);
            }
            {
#line 1666
            while (1) {
              while_continue: /* CIL Label */ ;
              {
#line 1666
              tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 1666
              old_locale = tmp___3;
#line 1666
              saved_locale = (char *)((void *)0);
              }
#line 1666
              if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
                {
#line 1666
                saved_locale = strdup((char const   *)old_locale);
                }
              }
#line 1666
              if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
                {
#line 1666
                setlocale(6, "C");
                }
              }
              {
#line 1666
              syslog(4, "failed to reset the lastlog entry of UID %lu", (unsigned long )uid);
              }
#line 1666
              if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
                {
#line 1666
                setlocale(6, (char const   *)saved_locale);
#line 1666
                free((void *)saved_locale);
                }
              }
#line 1666
              goto while_break;
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 1669
  return;
}
}
#line 1677 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void usr_update(void) 
{ 
  struct passwd pwent___0 ;
  struct spwd spent ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  struct passwd *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1686
  new_pwent(& pwent___0);
#line 1687
  new_spent(& spent);
  }
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1693
    tmp = setlocale(6, (char const   *)((void *)0));
#line 1693
    old_locale = tmp;
#line 1693
    saved_locale = (char *)((void *)0);
    }
#line 1693
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 1693
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 1693
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 1693
      setlocale(6, "C");
      }
    }
    {
#line 1693
    syslog(6, "new user: name=%s, UID=%u, GID=%u, home=%s, shell=%s", user_name___0,
           user_id, user_gid, user_home, user_shell);
    }
#line 1693
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 1693
      setlocale(6, (char const   *)saved_locale);
#line 1693
      free((void *)saved_locale);
      }
    }
#line 1693
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1705
  if (! lflg___1) {
    {
#line 1705
    tmp___0 = getpwuid(user_id);
    }
#line 1705
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 1706
      faillog_reset(user_id);
#line 1707
      lastlog_reset(user_id);
      }
    }
  }
  {
#line 1713
  tmp___3 = pw_update((struct passwd  const  *)(& pwent___0));
  }
#line 1713
  if (tmp___3 == 0) {
    {
#line 1714
    tmp___1 = pw_dbname();
#line 1714
    tmp___2 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 1714
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, tmp___1, pwent___0.pw_name);
#line 1717
    fail_exit___2(1);
    }
  }
#line 1723
  if (is_shadow_pwd) {
    {
#line 1723
    tmp___6 = spw_update((struct spwd  const  *)(& spent));
    }
#line 1723
    if (tmp___6 == 0) {
      {
#line 1724
      tmp___4 = spw_dbname();
#line 1724
      tmp___5 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 1724
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4, spent.sp_namp);
#line 1733
      fail_exit___2(1);
      }
    }
  }
#line 1745
  if (do_grp_update) {
    {
#line 1746
    grp_update();
    }
  }
#line 1748
  return;
}
}
#line 1757 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void create_home(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1759
  tmp___2 = access(user_home, 0);
  }
#line 1759
  if (tmp___2 != 0) {
    {
#line 1766
    tmp___0 = mkdir(user_home, (__mode_t )0);
    }
#line 1766
    if (tmp___0 != 0) {
      {
#line 1767
      tmp = gettext("%s: cannot create directory %s\n");
#line 1767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, user_home);
#line 1776
      fail_exit___2(12);
      }
    }
    {
#line 1778
    chown(user_home, user_id, user_gid);
#line 1779
    tmp___1 = getdef_num("UMASK", 18);
#line 1779
    chmod(user_home, (__mode_t )(511 & ~ tmp___1));
#line 1781
    home_added = (_Bool)1;
    }
  }
#line 1795
  return;
}
}
#line 1804 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/useradd.c"
static void create_mail(void) 
{ 
  char const   *spool ;
  char *file ;
  int fd ;
  struct group *gr ;
  gid_t gid ;
  mode_t mode ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1806
  tmp___7 = strcasecmp(create_mail_spool, "yes");
  }
#line 1806
  if (tmp___7 == 0) {
    {
#line 1814
    spool = getdef_str("MAIL_DIR");
    }
#line 1815
    if ((unsigned long )((void *)0) == (unsigned long )spool) {
#line 1816
      spool = "/var/mail";
    }
    {
#line 1818
    tmp = strlen(spool);
#line 1818
    tmp___0 = strlen(user_name___0);
#line 1818
    tmp___1 = __builtin_alloca((tmp + tmp___0) + 2UL);
#line 1818
    file = (char *)tmp___1;
#line 1819
    sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)"%s/%s",
            spool, user_name___0);
#line 1820
    fd = open((char const   *)file, 705, 0);
    }
#line 1821
    if (fd < 0) {
      {
#line 1822
      tmp___2 = gettext("Creating mailbox file");
#line 1822
      perror((char const   *)tmp___2);
      }
#line 1823
      return;
    }
    {
#line 1826
    gr = getgrnam("mail");
    }
#line 1827
    if ((unsigned long )((void *)0) == (unsigned long )gr) {
      {
#line 1828
      tmp___3 = gettext("Group \'mail\' not found. Creating the user mailbox file with 0600 mode.\n");
#line 1828
      fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stderr);
#line 1830
      gid = user_gid;
#line 1831
      mode = (mode_t )384;
      }
    } else {
#line 1833
      gid = gr->gr_gid;
#line 1834
      mode = (mode_t )432;
    }
    {
#line 1837
    tmp___5 = fchown(fd, user_id, gid);
    }
#line 1837
    if (tmp___5 != 0) {
      {
#line 1839
      tmp___4 = gettext("Setting mailbox file permissions");
#line 1839
      perror((char const   *)tmp___4);
      }
    } else {
      {
#line 1837
      tmp___6 = fchmod(fd, mode);
      }
#line 1837
      if (tmp___6 != 0) {
        {
#line 1839
        tmp___4 = gettext("Setting mailbox file permissions");
#line 1839
        perror((char const   *)tmp___4);
        }
      }
    }
    {
#line 1842
    fsync(fd);
#line 1843
    close(fd);
    }
  }
#line 1845
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___6[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___6[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___6  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___6(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___7  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___13  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___6(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___13) {
#line 70
      size___13 = i + 100;
#line 71
      if (members___7) {
        {
#line 72
        tmp = realloc((void *)members___7, (unsigned long )size___13 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___13 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___7) {
          {
#line 81
          free((void *)members___7);
          }
        }
#line 82
        members___7 = (char **)0;
#line 83
        size___13 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___7 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___7 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___7 + i) = (char *)0;
#line 99
  return (members___7);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___6  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___14  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___6[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___6  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___6(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___6(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___6  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___6  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___6  ;
#line 72
static int copy_entry___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___6(char const   *filename___0 ) ;
#line 83
static int copy_symlink___6(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___6(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___6(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___6(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___6(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___6(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___6 == (unsigned long )ln) {
    {
#line 149
    links___6 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___6;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___6(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___6)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___6)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___6;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___6);
#line 199
  dst_len = strlen(dst_orig___6);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___6, name___3 + src_len);
#line 207
  lp->ln_next = links___6;
#line 208
  links___6 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___6(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___6(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___6(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___6(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___6(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___6(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___6(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___6(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___6(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___6)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___6)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___6(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___6);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___6, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___6);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___6);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___6);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___6, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___6(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___6(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___6(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___6(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___6(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___6(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___6(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___6(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___6(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___6[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___6[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___7(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___7(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___7[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___7[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___7  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___7(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___8  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___15  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___7(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___15) {
#line 70
      size___15 = i + 100;
#line 71
      if (members___8) {
        {
#line 72
        tmp = realloc((void *)members___8, (unsigned long )size___15 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___15 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___8) {
          {
#line 81
          free((void *)members___8);
          }
        }
#line 82
        members___8 = (char **)0;
#line 83
        size___15 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___8 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___8 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___8 + i) = (char *)0;
#line 99
  return (members___8);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___7  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___16  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___7[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___7  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___7(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 46 "../lib/sgroupio.h"
extern int sgr_remove(char const   *name ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static _Bool gr_locked___1  =    (_Bool)0;
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static _Bool sgr_locked___1  =    (_Bool)0;
#line 66
static void fail_exit___3(int status ) ;
#line 67
static void usage___6(int status ) ;
#line 68
static void process_flags___4(int argc , char **argv ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static void fail_exit___3(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 72
  if (gr_locked___1) {
    {
#line 73
    tmp___3 = gr_unlock();
    }
#line 73
    if (tmp___3 == 0) {
      {
#line 74
      tmp = gr_dbname();
#line 74
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 74
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 75
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 75
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 75
        old_locale = tmp___1;
#line 75
        saved_locale = (char *)((void *)0);
        }
#line 75
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 75
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 75
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 75
          setlocale(6, "C");
          }
        }
        {
#line 75
        tmp___2 = gr_dbname();
#line 75
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 75
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 75
          setlocale(6, (char const   *)saved_locale);
#line 75
          free((void *)saved_locale);
          }
        }
#line 75
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 80
  if (sgr_locked___1) {
    {
#line 81
    tmp___8 = sgr_unlock();
    }
#line 81
    if (tmp___8 == 0) {
      {
#line 82
      tmp___4 = sgr_dbname();
#line 82
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 83
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 83
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 83
        old_locale___0 = tmp___6;
#line 83
        saved_locale___0 = (char *)((void *)0);
        }
#line 83
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 83
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 83
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 83
          setlocale(6, "C");
          }
        }
        {
#line 83
        tmp___7 = sgr_dbname();
#line 83
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 83
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 83
          setlocale(6, (char const   *)saved_locale___0);
#line 83
          free((void *)saved_locale___0);
          }
        }
#line 83
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 88
  exit(status);
  }
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static void usage___6(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 93
  if (0 != status) {
#line 93
    tmp = stderr;
  } else {
#line 93
    tmp = stdout;
  }
  {
#line 93
  usageout = tmp;
#line 94
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 94
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 99
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 99
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 100
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 100
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 101
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 102
  exit(status);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static struct option long_options___5[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 110 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static void process_flags___4(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    c = getopt_long(argc, (char * const  *)argv, "hR:", (struct option  const  *)(long_options___5),
                    (int *)((void *)0));
    }
#line 122
    if (! (c != -1)) {
#line 122
      goto while_break;
    }
    {
#line 125
    if (c == 104) {
#line 125
      goto case_104;
    }
#line 128
    if (c == 82) {
#line 128
      goto case_82;
    }
#line 130
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 126
    usage___6(0);
    }
#line 127
    goto switch_break;
    case_82: /* CIL Label */ 
#line 129
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 131
    usage___6(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (optind != argc) {
    {
#line 136
    usage___6(2);
    }
  }
#line 138
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpconv.c"
static char *empty  =    (char *)0;
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___7(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___7  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___7  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___7  ;
#line 72
static int copy_entry___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___7(char const   *filename___0 ) ;
#line 83
static int copy_symlink___7(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___7(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___7(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___7(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___7(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___7(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___7 == (unsigned long )ln) {
    {
#line 149
    links___7 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___7;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___7(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___7)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___7)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___7;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___7);
#line 199
  dst_len = strlen(dst_orig___7);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___7, name___3 + src_len);
#line 207
  lp->ln_next = links___7;
#line 208
  links___7 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___7(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___7(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___7(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___7(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___7(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___7(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___7(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___7(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___7(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___7)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___7)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___7(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___7);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___7, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___7);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___7);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___7);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___7, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___7(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___7(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___7(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___7(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___7(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___7(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___7(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___7(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___7(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___7[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___7[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___8(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___8(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 660 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgrp)(void) ;
#line 62 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) getutent)(void) ;
#line 65
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setutent)(void) ;
#line 68
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endutent)(void) ;
#line 259 "../lib/prototypes.h"
extern _Bool isttytime(char const   * , char const   * , time_t  ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/logoutd.c"
static int check_login(struct utmp  const  *ut ) ;
#line 62
static void send_mesg_to_tty(int tty_fd ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/logoutd.c"
static int check_login(struct utmp  const  *ut ) 
{ 
  char user___0[sizeof(ut->ut_user) + 1UL] ;
  time_t now ;
  _Bool tmp ;

  {
  {
#line 79
  strncpy((char */* __restrict  */)(user___0), (char const   */* __restrict  */)(ut->ut_user),
          sizeof(ut->ut_user));
#line 80
  user___0[sizeof(ut->ut_user)] = (char )'\000';
#line 82
  time(& now);
#line 87
  tmp = isttytime((char const   *)(user___0), (char const   *)(ut->ut_line), now);
  }
#line 87
  if (! tmp) {
#line 88
    return (0);
  }
#line 90
  return (1);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/logoutd.c"
static void send_mesg_to_tty(int tty_fd ) 
{ 
  struct termios oldt ;
  struct termios newt ;
  FILE *mesg_file ;
  FILE *tty_file ;
  _Bool is_tty ;
  int tmp ;
  int c ;
  char *tmp___0 ;

  {
  {
#line 100
  tty_file = fdopen(tty_fd, "w");
  }
#line 101
  if ((unsigned long )((void *)0) == (unsigned long )tty_file) {
#line 102
    return;
  }
  {
#line 105
  tmp = tcgetattr(tty_fd, & oldt);
#line 105
  is_tty = (_Bool )(tmp == 0);
  }
#line 106
  if (is_tty) {
    {
#line 109
    newt = oldt;
#line 110
    newt.c_oflag |= 1U;
#line 111
    tcsetattr(tty_fd, 0, (struct termios  const  *)(& newt));
    }
  }
  {
#line 114
  mesg_file = fopen((char const   */* __restrict  */)"/etc/logoutd.mesg", (char const   */* __restrict  */)"r");
  }
#line 115
  if ((unsigned long )((void *)0) != (unsigned long )mesg_file) {
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 117
      c = _IO_getc(mesg_file);
      }
#line 117
      if (! (c != -1)) {
#line 117
        goto while_break;
      }
#line 118
      if (c == 10) {
        {
#line 119
        _IO_putc('\r', tty_file);
        }
      }
      {
#line 121
      _IO_putc(c, tty_file);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 123
    fclose(mesg_file);
    }
  } else {
    {
#line 125
    tmp___0 = gettext("login time exceeded\n\n");
#line 125
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)tty_file);
    }
  }
  {
#line 127
  fflush(tty_file);
#line 128
  fclose(tty_file);
  }
#line 130
  if (is_tty) {
    {
#line 131
    tcsetattr(tty_fd, 0, (struct termios  const  *)(& oldt));
    }
  }
#line 133
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___8[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___8[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___8  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___8(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___9  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___17  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___8(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___17) {
#line 70
      size___17 = i + 100;
#line 71
      if (members___9) {
        {
#line 72
        tmp = realloc((void *)members___9, (unsigned long )size___17 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___17 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___9) {
          {
#line 81
          free((void *)members___9);
          }
        }
#line 82
        members___9 = (char **)0;
#line 83
        size___17 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___9 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___9 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___9 + i) = (char *)0;
#line 99
  return (members___9);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___8  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___18  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___8[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___8  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___8(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___8(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___8  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___8  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___8  ;
#line 72
static int copy_entry___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___8(char const   *filename___0 ) ;
#line 83
static int copy_symlink___8(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___8(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___8(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___8(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___8(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___8(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___8 == (unsigned long )ln) {
    {
#line 149
    links___8 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___8;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___8(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___8)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___8)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___8;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___8);
#line 199
  dst_len = strlen(dst_orig___8);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___8, name___3 + src_len);
#line 207
  lp->ln_next = links___8;
#line 208
  links___8 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___8(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___8(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___8(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___8(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___8(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___8(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___8(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___8(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___8(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___8)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___8)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___8(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___8);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___8, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___8);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___8);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___8);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___8, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___8(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___8(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___8(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___8(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___8(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___8(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___8(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___8(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___8(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___8[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___8[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___9(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___9(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___9  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___9  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___9  ;
#line 72
static int copy_entry___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___9(char const   *filename___0 ) ;
#line 83
static int copy_symlink___9(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___9(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) ;
#line 92
static int copy_special___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___9(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___9(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___9(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___9(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___9 == (unsigned long )ln) {
    {
#line 149
    links___9 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___9;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___9(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___9)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___9)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___9;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___9);
#line 199
  dst_len = strlen(dst_orig___9);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___9, name___3 + src_len);
#line 207
  lp->ln_next = links___9;
#line 208
  links___9 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___9(src, dst, reset_selinux, (struct stat  const  *)(& sb), (struct timeval  const  *)(mt),
                         old_uid, new_uid, old_gid, new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___9(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___9(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___9(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___9(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                               (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                               new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___9(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                            (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                            new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                        struct stat  const  *statp , struct timeval  const  *mt ,
                        uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___9(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___9(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___9(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___9)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___9)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___9(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___9);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___9, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___9);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___9);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___9);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___9, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___9(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___9(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___9(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                            struct stat  const  *statp , struct timeval  const  *mt ,
                            uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___9(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___9(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___9(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___9(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                               uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___9(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___9(int dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/tz.c"
static char tzbuf[8192]  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/tz.c"
char const   *tz(char const   *fname ) 
{ 
  FILE *fp ;
  char const   *def_tz ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 54
  fp = (FILE *)((void *)0);
#line 56
  def_tz = "TZ=CST6CDT";
#line 58
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 59
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 59
    goto _L;
  } else {
    {
#line 59
    tmp___0 = fgets((char */* __restrict  */)(tzbuf), (int )sizeof(tzbuf), (FILE */* __restrict  */)fp);
    }
#line 59
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 61
      def_tz = getdef_str("ENV_TZ");
      }
#line 62
      if ((unsigned long )((void *)0) == (unsigned long )def_tz) {
#line 63
        def_tz = "TZ=CST6CDT";
      } else
#line 62
      if (47 == (int )*(def_tz + 0)) {
#line 63
        def_tz = "TZ=CST6CDT";
      }
      {
#line 66
      strcpy((char */* __restrict  */)(tzbuf), (char const   */* __restrict  */)def_tz);
      }
    } else {
      {
#line 68
      tmp = strlen((char const   *)(tzbuf));
#line 68
      tzbuf[tmp - 1UL] = (char )'\000';
      }
    }
  }
#line 71
  if ((unsigned long )((void *)0) != (unsigned long )fp) {
    {
#line 72
    fclose(fp);
    }
  }
#line 75
  return ((char const   *)(tzbuf));
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___9(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/get_gid.c"
int get_gid(char const   *gidstr , gid_t *gid ) 
{ 
  long long val ;
  char *endptr ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 42
  tmp = __errno_location();
#line 42
  *tmp = 0;
#line 43
  val = strtoll((char const   */* __restrict  */)gidstr, (char **/* __restrict  */)(& endptr),
                10);
  }
#line 44
  if (0 == (int )*gidstr) {
#line 48
    return (0);
  } else
#line 44
  if (0 != (int )*endptr) {
#line 48
    return (0);
  } else {
    {
#line 44
    tmp___0 = __errno_location();
    }
#line 44
    if (34 == *tmp___0) {
#line 48
      return (0);
    } else
#line 44
    if (val != (long long )((gid_t )val)) {
#line 48
      return (0);
    }
  }
#line 51
  *gid = (gid_t )val;
#line 52
  return (1);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___9(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 551 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 929
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getusershell)(void) ;
#line 930
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endusershell)(void) ;
#line 931
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setusershell)(void) ;
#line 209 "../lib/prototypes.h"
extern void setup_limits(struct passwd  const  * ) ;
#line 281
extern void pw_free(struct passwd *pwent ) ;
#line 321
extern void setup_env(struct passwd * ) ;
#line 360
int check_su_auth(char const   *actual_id , char const   *wanted_id , _Bool su_to_root ) ;
#line 365
extern void sulog(char const   *tty , _Bool success , char const   *oldname , char const   *name ) ;
#line 371
extern void subsystem(struct passwd  const  * ) ;
#line 411
extern struct passwd *xgetpwnam(char const   * ) ;
#line 38 "../lib/pwauth.h"
extern int pw_auth(char const   *cipher , char const   *user , int flag , char const   *input ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static char const   *caller_tty  =    (char const   *)((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool caller_is_root  =    (_Bool)0;
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static uid_t caller_uid  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool caller_on_console  =    (_Bool)0;
#line 91 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static char *caller_pass  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool doshell  =    (_Bool)0;
#line 95 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool fakelogin  =    (_Bool)0;
#line 96 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static char const   *shellstr  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static char *command  =    (char *)((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static char name___0[8192]  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static char caller_name[8192]  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool change_environment  =    (_Bool)1;
#line 123
static void execve_shell(char const   *shellname , char **args , char * const  *envp ) ;
#line 130
static void die(int killed ) ;
#line 131
static _Bool iswheel(char const   *username___0 ) ;
#line 133
static _Bool restricted_shell(char const   *shellname ) ;
#line 134
static void su_failure(char const   *tty , _Bool su_to_root ) ;
#line 135
static struct passwd *check_perms___3(void) ;
#line 139
static void check_perms_nopam(struct passwd  const  *pw ) ;
#line 141
static void save_caller_context(char **argv ) ;
#line 142
static void process_flags___5(int argc , char **argv ) ;
#line 143
static void set_environment(struct passwd *pw ) ;
#line 155 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static struct termios sgtty___0  ;
#line 153 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void die(int killed ) 
{ 


  {
#line 157
  if (killed != 0) {
    {
#line 158
    tcsetattr(0, 0, (struct termios  const  *)(& sgtty___0));
    }
  } else {
    {
#line 160
    tcgetattr(0, & sgtty___0);
    }
  }
#line 163
  if (killed != 0) {
    {
#line 164
    closelog();
#line 165
    exit(128 + killed);
    }
  }
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool iswheel(char const   *username___0 ) 
{ 
  struct group *grp ;
  _Bool tmp ;

  {
  {
#line 173
  grp = getgrnam("wheel");
  }
#line 174
  if ((unsigned long )((void *)0) == (unsigned long )grp) {
#line 176
    return ((_Bool)0);
  } else
#line 174
  if ((unsigned long )((void *)0) == (unsigned long )grp->gr_mem) {
#line 176
    return ((_Bool)0);
  }
  {
#line 178
  tmp = is_on_list((char * const  *)grp->gr_mem, username___0);
  }
#line 178
  return (tmp);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static _Bool restricted_shell(char const   *shellname ) 
{ 
  char const   *line ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 199
  setusershell();
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 200
    tmp___0 = getusershell();
#line 200
    line = (char const   *)tmp___0;
    }
#line 200
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 200
      goto while_break;
    }
#line 201
    if (35 != (int )*line) {
      {
#line 201
      tmp = strcmp(line, shellname);
      }
#line 201
      if (tmp == 0) {
        {
#line 202
        endusershell();
        }
#line 203
        return ((_Bool)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  endusershell();
  }
#line 207
  return ((_Bool)1);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void su_failure(char const   *tty , _Bool su_to_root ) 
{ 
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 212
  sulog(tty, (_Bool)0, (char const   *)(caller_name), (char const   *)(name___0));
#line 214
  tmp___3 = getdef_bool("SYSLOG_SU_ENAB");
  }
#line 214
  if (tmp___3) {
    {
#line 215
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      tmp = setlocale(6, (char const   *)((void *)0));
#line 215
      old_locale = tmp;
#line 215
      saved_locale = (char *)((void *)0);
      }
#line 215
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 215
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 215
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 215
        setlocale(6, "C");
        }
      }
#line 215
      if (0 != (int )name___0[0]) {
#line 215
        tmp___0 = (char const   *)(name___0);
      } else {
#line 215
        tmp___0 = "???";
      }
#line 215
      if (0 != (int )caller_name[0]) {
#line 215
        tmp___1 = (char const   *)(caller_name);
      } else {
#line 215
        tmp___1 = "???";
      }
#line 215
      if (su_to_root) {
#line 215
        tmp___2 = 5;
      } else {
#line 215
        tmp___2 = 6;
      }
      {
#line 215
      syslog(tmp___2, "- %s %s:%s", tty, tmp___1, tmp___0);
      }
#line 215
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 215
        setlocale(6, (char const   *)saved_locale);
#line 215
        free((void *)saved_locale);
        }
      }
#line 215
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 220
  closelog();
#line 222
  exit(1);
  }
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void execve_shell(char const   *shellname , char **args , char * const  *envp ) 
{ 
  int err ;
  int *tmp ;
  size_t n_args ;
  char **targs ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 234
  execve(shellname, (char * const  *)args, envp);
#line 235
  tmp = __errno_location();
#line 235
  err = *tmp;
#line 237
  tmp___2 = access(shellname, 5);
  }
#line 237
  if (tmp___2 == 0) {
#line 242
    n_args = (size_t )0;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;
#line 244
      if (! ((unsigned long )((void *)0) != (unsigned long )*(args + n_args))) {
#line 244
        goto while_break;
      }
#line 245
      n_args ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 247
    tmp___0 = xmalloc((n_args + 3UL) * sizeof(*(args + 0)));
#line 247
    targs = (char **)tmp___0;
#line 248
    *(targs + 0) = (char *)"sh";
#line 249
    *(targs + 1) = (char *)"-";
#line 250
    *(targs + 2) = xstrdup(shellname);
#line 251
    *(targs + (n_args + 2UL)) = (char *)((void *)0);
    }
    {
#line 252
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 252
      if (! (1UL != n_args)) {
#line 252
        goto while_break___0;
      }
#line 253
      *(targs + (n_args + 1UL)) = *(args + (n_args - 1UL));
#line 254
      n_args --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 257
    execve("/bin/bash", (char * const  *)targs, envp);
    }
  } else {
    {
#line 259
    tmp___1 = __errno_location();
#line 259
    *tmp___1 = err;
    }
  }
#line 261
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void usage___7(int status ) 
{ 
  struct _IO_FILE *tmp ;
  char *tmp___0 ;

  {
#line 405
  if (0 != status) {
#line 405
    tmp = stderr;
  } else {
#line 405
    tmp = stdout;
  }
  {
#line 405
  tmp___0 = gettext("Usage: su [options] [LOGIN]\n\nOptions:\n  -c, --command COMMAND         pass COMMAND to the invoked shell\n  -h, --help                    display this help message and exit\n  -, -l, --login                make the shell a login shell\n  -m, -p,\n  --preserve-environment        do not reset environment variables, and\n                                keep the same shell\n  -s, --shell SHELL             use SHELL instead of the default in passwd\n\n");
#line 405
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)tmp);
#line 417
  exit(status);
  }
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void check_perms_nopam(struct passwd  const  *pw ) 
{ 
  struct spwd  const  *spwd ;
  char const   *password ;
  void (*oldsig)(int  ) ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  struct spwd *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *old_locale ;
  char *tmp___7 ;
  char *saved_locale ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *old_locale___0 ;
  char *tmp___11 ;
  char *saved_locale___0 ;
  int tmp___12 ;
  char *tmp___13 ;
  time_t tmp___14 ;
  _Bool tmp___15 ;

  {
#line 464
  spwd = (struct spwd  const  *)((void *)0);
#line 465
  password = (char const   *)pw->pw_passwd;
#line 468
  if (caller_is_root) {
#line 469
    return;
  }
#line 490
  if (0U == pw->pw_uid) {
    {
#line 490
    tmp___0 = getdef_bool("SU_WHEEL_ONLY");
    }
#line 490
    if (tmp___0) {
      {
#line 490
      tmp___1 = iswheel((char const   *)(caller_name));
      }
#line 490
      if (! tmp___1) {
        {
#line 493
        tmp = gettext("You are not authorized to su %s\n");
#line 493
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                name___0);
#line 496
        exit(1);
        }
      }
    }
  }
  {
#line 498
  tmp___2 = getspnam((char const   *)(name___0));
#line 498
  spwd = (struct spwd  const  *)tmp___2;
#line 500
  tmp___3 = strcmp((char const   *)pw->pw_passwd, "x");
  }
#line 500
  if (tmp___3 == 0) {
#line 501
    if ((unsigned long )((void *)0) != (unsigned long )spwd) {
#line 502
      password = (char const   *)spwd->sp_pwdp;
    }
  }
  {
#line 506
  tmp___4 = check_su_auth((char const   *)(caller_name), (char const   *)(name___0),
                          (_Bool )(0U == pw->pw_uid));
  }
  {
#line 507
  if (tmp___4 == 0) {
#line 507
    goto case_0;
  }
#line 509
  if (tmp___4 == 1) {
#line 509
    goto case_1;
  }
#line 512
  if (tmp___4 == 2) {
#line 512
    goto case_2;
  }
#line 516
  goto switch_default;
  case_0: /* CIL Label */ 
#line 508
  goto switch_break;
  case_1: /* CIL Label */ 
#line 510
  password = "";
#line 511
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 513
  tmp___5 = gettext("(Enter your own password)");
#line 513
  puts((char const   *)tmp___5);
#line 514
  password = (char const   *)caller_pass;
  }
#line 515
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 517
  tmp___6 = gettext("You are not authorized to su %s\n");
#line 517
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
          name___0);
#line 520
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 526
  die(0);
#line 527
  oldsig = signal(3, & die);
#line 534
  tmp___10 = pw_auth(password, (char const   *)(name___0), 1, (char const   *)((char *)0));
  }
#line 534
  if (tmp___10 != 0) {
    {
#line 535
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 535
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 535
      old_locale = tmp___7;
#line 535
      saved_locale = (char *)((void *)0);
      }
#line 535
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 535
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 535
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 535
        setlocale(6, "C");
        }
      }
#line 535
      if (pw->pw_uid != 0U) {
#line 535
        tmp___8 = 5;
      } else {
#line 535
        tmp___8 = 4;
      }
      {
#line 535
      syslog(tmp___8, "Authentication failed for %s", name___0);
      }
#line 535
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 535
        setlocale(6, (char const   *)saved_locale);
#line 535
        free((void *)saved_locale);
        }
      }
#line 535
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 537
    tmp___9 = gettext("%s: Authentication failure\n");
#line 537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
            Prog);
#line 538
    su_failure(caller_tty, (_Bool )(0U == pw->pw_uid));
    }
  }
  {
#line 540
  signal(3, oldsig);
  }
#line 547
  if ((unsigned long )((void *)0) != (unsigned long )spwd) {
    {
#line 548
    expire(pw, spwd);
    }
  }
  {
#line 557
  tmp___14 = time((time_t *)0);
#line 557
  tmp___15 = isttytime((char const   *)(name___0), "SU", tmp___14);
  }
#line 557
  if (! tmp___15) {
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 558
      tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 558
      old_locale___0 = tmp___11;
#line 558
      saved_locale___0 = (char *)((void *)0);
      }
#line 558
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 558
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 558
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 558
        setlocale(6, "C");
        }
      }
#line 558
      if (0U != pw->pw_uid) {
#line 558
        tmp___12 = 4;
      } else {
#line 558
        tmp___12 = 2;
      }
      {
#line 558
      syslog(tmp___12, "SU by %s to restricted account %s", caller_name, name___0);
      }
#line 558
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 558
        setlocale(6, (char const   *)saved_locale___0);
#line 558
        free((void *)saved_locale___0);
        }
      }
#line 558
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 561
    tmp___13 = gettext("%s: You are not authorized to su at that time\n");
#line 561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
            Prog);
#line 564
    su_failure(caller_tty, (_Bool )(0U == pw->pw_uid));
    }
  }
#line 566
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static struct passwd *check_perms___3(void) 
{ 
  struct passwd *pw ;
  struct passwd *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  struct passwd *tmp___2 ;

  {
  {
#line 585
  tmp = xgetpwnam((char const   *)(name___0));
#line 585
  pw = tmp;
  }
#line 586
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
    {
#line 587
    tmp___0 = gettext("No passwd entry for user \'%s\'\n");
#line 587
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            name___0);
    }
    {
#line 589
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 589
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 589
      old_locale = tmp___1;
#line 589
      saved_locale = (char *)((void *)0);
      }
#line 589
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 589
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 589
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 589
        setlocale(6, "C");
        }
      }
      {
#line 589
      syslog(3, "No passwd entry for user \'%s\'", name___0);
      }
#line 589
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 589
        setlocale(6, (char const   *)saved_locale);
#line 589
        free((void *)saved_locale);
        }
      }
#line 589
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 590
    su_failure(caller_tty, (_Bool)1);
    }
  }
  {
#line 593
  signal(2, (void (*)(int  ))1);
#line 594
  signal(3, (void (*)(int  ))1);
#line 625
  check_perms_nopam((struct passwd  const  *)pw);
#line 628
  signal(2, (void (*)(int  ))0);
#line 629
  signal(3, (void (*)(int  ))0);
  }
#line 636
  if (42 == (int )*(pw->pw_shell + 0)) {
    {
#line 637
    subsystem((struct passwd  const  *)pw);
#line 638
    endpwent();
#line 639
    endspent();
#line 640
    pw_free(pw);
#line 641
    tmp___2 = check_perms___3();
    }
#line 641
    return (tmp___2);
  }
#line 644
  return (pw);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void save_caller_context(char **argv ) 
{ 
  struct passwd *pw ;
  char const   *password ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  struct spwd  const  *spwd ;
  struct spwd *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 657
  pw = (struct passwd *)((void *)0);
#line 660
  password = (char const   *)((void *)0);
#line 667
  Prog = Basename((char const   *)*(argv + 0));
#line 669
  caller_uid = getuid();
#line 670
  caller_is_root = (_Bool )(caller_uid == 0U);
#line 676
  tmp = ttyname(0);
#line 676
  caller_tty = (char const   *)tmp;
#line 677
  tmp___1 = isatty(0);
  }
#line 677
  if (tmp___1 != 0) {
#line 677
    if ((unsigned long )((void *)0) != (unsigned long )caller_tty) {
      {
#line 679
      caller_on_console = console(caller_tty);
      }
    } else {
#line 677
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 685
    if (! caller_is_root) {
      {
#line 686
      tmp___0 = gettext("%s: must be run from a terminal\n");
#line 686
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 689
      exit(1);
      }
    }
#line 691
    caller_tty = "???";
  }
  {
#line 698
  pw = get_my_pwent();
  }
#line 699
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
    {
#line 700
    tmp___2 = gettext("%s: Cannot determine your user name.\n");
#line 700
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog);
    }
    {
#line 703
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 703
      tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 703
      old_locale = tmp___3;
#line 703
      saved_locale = (char *)((void *)0);
      }
#line 703
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 703
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 703
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 703
        setlocale(6, "C");
        }
      }
      {
#line 703
      syslog(4, "Cannot determine the user name of the caller (UID %lu)", (unsigned long )caller_uid);
      }
#line 703
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 703
        setlocale(6, (char const   *)saved_locale);
#line 703
        free((void *)saved_locale);
        }
      }
#line 703
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 705
    su_failure(caller_tty, (_Bool)1);
    }
  }
  {
#line 707
  strncpy((char */* __restrict  */)(caller_name), (char const   */* __restrict  */)pw->pw_name,
          sizeof(caller_name) - 1UL);
#line 707
  caller_name[sizeof(caller_name) - 1UL] = (char )'\000';
#line 715
  password = (char const   *)pw->pw_passwd;
#line 716
  tmp___5 = strcmp((char const   *)pw->pw_passwd, "x");
  }
#line 716
  if (tmp___5 == 0) {
    {
#line 717
    tmp___4 = getspnam((char const   *)(caller_name));
#line 717
    spwd = (struct spwd  const  *)tmp___4;
    }
#line 718
    if ((unsigned long )((void *)0) != (unsigned long )spwd) {
#line 719
      password = (char const   *)spwd->sp_pwdp;
    }
  }
  {
#line 722
  free((void *)caller_pass);
#line 723
  caller_pass = xstrdup(password);
#line 726
  pw_free(pw);
  }
#line 727
  return;
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static struct option long_options___6[6]  = {      {"command", 1, (int *)((void *)0), 'c'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"login", 0, (int *)((void *)0), 'l'}, 
        {"preserve-environment", 0, (int *)((void *)0), 'p'}, 
        {"shell", 1, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 736 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void process_flags___5(int argc , char **argv ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct passwd *root_pw ;
  struct passwd *tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;

  {
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 748
    c = getopt_long(argc, (char * const  *)argv, "c:hlmps:", (struct option  const  *)(long_options___6),
                    (int *)((void *)0));
    }
#line 748
    if (! (c != -1)) {
#line 748
      goto while_break;
    }
    {
#line 751
    if (c == 99) {
#line 751
      goto case_99;
    }
#line 754
    if (c == 104) {
#line 754
      goto case_104;
    }
#line 757
    if (c == 108) {
#line 757
      goto case_108;
    }
#line 761
    if (c == 112) {
#line 761
      goto case_112;
    }
#line 761
    if (c == 109) {
#line 761
      goto case_112;
    }
#line 768
    if (c == 115) {
#line 768
      goto case_115;
    }
#line 771
    goto switch_default;
    case_99: /* CIL Label */ 
#line 752
    command = optarg;
#line 753
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 755
    usage___7(0);
    }
#line 756
    goto switch_break;
    case_108: /* CIL Label */ 
#line 758
    fakelogin = (_Bool)1;
#line 759
    goto switch_break;
    case_112: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 766
    change_environment = (_Bool)0;
#line 767
    goto switch_break;
    case_115: /* CIL Label */ 
#line 769
    shellstr = (char const   *)optarg;
#line 770
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 772
    usage___7(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 776
  if (optind < argc) {
    {
#line 776
    tmp___0 = strcmp((char const   *)*(argv + optind), "-");
    }
#line 776
    if (tmp___0 == 0) {
#line 777
      fakelogin = (_Bool)1;
#line 778
      optind ++;
#line 779
      if (optind < argc) {
        {
#line 779
        tmp = strcmp((char const   *)*(argv + optind), "--");
        }
#line 779
        if (tmp == 0) {
#line 781
          optind ++;
        }
      }
    }
  }
#line 791
  if (optind < argc) {
#line 791
    if (45 != (int )*(*(argv + optind) + 0)) {
      {
#line 792
      tmp___1 = optind;
#line 792
      optind ++;
#line 792
      strncpy((char */* __restrict  */)(name___0), (char const   */* __restrict  */)*(argv + tmp___1),
              sizeof(name___0) - 1UL);
#line 792
      name___0[sizeof(name___0) - 1UL] = (char )'\000';
      }
#line 793
      if (optind < argc) {
        {
#line 793
        tmp___2 = strcmp((char const   *)*(argv + optind), "--");
        }
#line 793
        if (tmp___2 == 0) {
#line 794
          optind ++;
        }
      }
    }
  }
#line 797
  if (0 == (int )name___0[0]) {
    {
#line 798
    tmp___3 = getpwnam("root");
#line 798
    root_pw = tmp___3;
    }
#line 799
    if ((unsigned long )((void *)0) != (unsigned long )root_pw) {
#line 799
      if (0U == root_pw->pw_uid) {
        {
#line 800
        strcpy((char */* __restrict  */)(name___0), (char const   */* __restrict  */)"root");
        }
      } else {
#line 799
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 802
      root_pw = getpwuid((__uid_t )0);
      }
#line 803
      if ((unsigned long )((void *)0) == (unsigned long )root_pw) {
        {
#line 804
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 804
          tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 804
          old_locale = tmp___4;
#line 804
          saved_locale = (char *)((void *)0);
          }
#line 804
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 804
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 804
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 804
            setlocale(6, "C");
            }
          }
          {
#line 804
          syslog(2, "There is no UID 0 user.");
          }
#line 804
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 804
            setlocale(6, (char const   *)saved_locale);
#line 804
            free((void *)saved_locale);
            }
          }
#line 804
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 805
        su_failure(caller_tty, (_Bool)1);
        }
      }
      {
#line 807
      strcpy((char */* __restrict  */)(name___0), (char const   */* __restrict  */)root_pw->pw_name);
      }
    }
  }
#line 811
  doshell = (_Bool )(argc == optind);
#line 812
  if ((unsigned long )((void *)0) != (unsigned long )command) {
#line 813
    doshell = (_Bool)0;
  }
#line 815
  return;
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/su.c"
static void set_environment(struct passwd *pw ) 
{ 
  char const   *cp ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char **envp ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 824
  if (change_environment) {
#line 824
    if (fakelogin) {
      {
#line 829
      tmp = getenv("TERM");
#line 829
      cp = (char const   *)tmp;
      }
#line 830
      if ((unsigned long )((void *)0) != (unsigned long )cp) {
        {
#line 831
        addenv("TERM", cp);
        }
      }
      {
#line 842
      tmp___0 = getenv("COLORTERM");
#line 842
      cp = (char const   *)tmp___0;
      }
#line 843
      if ((unsigned long )((void *)0) != (unsigned long )cp) {
        {
#line 844
        addenv("COLORTERM", cp);
        }
      }
      {
#line 848
      cp = getdef_str("ENV_TZ");
      }
#line 849
      if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 850
        if (47 == (int )*cp) {
          {
#line 850
          tmp___1 = tz(cp);
#line 850
          tmp___2 = tmp___1;
          }
        } else {
#line 850
          tmp___2 = cp;
        }
        {
#line 850
        addenv(tmp___2, (char const   *)((void *)0));
        }
      }
      {
#line 856
      cp = getdef_str("ENV_HZ");
      }
#line 857
      if ((unsigned long )((void *)0) != (unsigned long )cp) {
        {
#line 858
        addenv(cp, (char const   *)((void *)0));
        }
      }
      {
#line 866
      tmp___3 = getenv("DISPLAY");
#line 866
      cp = (char const   *)tmp___3;
      }
#line 867
      if ((unsigned long )((void *)0) != (unsigned long )cp) {
        {
#line 868
        addenv("DISPLAY", cp);
        }
      }
      {
#line 870
      tmp___4 = getenv("XAUTHORITY");
#line 870
      cp = (char const   *)tmp___4;
      }
#line 871
      if ((unsigned long )((void *)0) != (unsigned long )cp) {
        {
#line 872
        addenv("XAUTHORITY", cp);
        }
      }
    } else {
#line 824
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 875
    envp = environ;
    {
#line 876
    while (1) {
      while_continue: /* CIL Label */ ;
#line 876
      if (! ((unsigned long )((void *)0) != (unsigned long )*envp)) {
#line 876
        goto while_break;
      }
      {
#line 877
      addenv((char const   *)*envp, (char const   *)((void *)0));
#line 878
      envp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 882
  if (pw->pw_uid == 0U) {
#line 882
    tmp___5 = "ENV_SUPATH";
  } else {
#line 882
    tmp___5 = "ENV_PATH";
  }
  {
#line 882
  cp = getdef_str(tmp___5);
  }
#line 883
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 884
    if (pw->pw_uid == 0U) {
#line 884
      tmp___6 = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
    } else {
#line 884
      tmp___6 = "PATH=/bin:/usr/bin";
    }
    {
#line 884
    addenv(tmp___6, (char const   *)((void *)0));
    }
  } else {
    {
#line 885
    tmp___7 = strchr(cp, '=');
    }
#line 885
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
      {
#line 886
      addenv(cp, (char const   *)((void *)0));
      }
    } else {
      {
#line 888
      addenv("PATH", cp);
      }
    }
  }
  {
#line 891
  tmp___8 = getenv("IFS");
  }
#line 891
  if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
    {
#line 892
    addenv("IFS= \t\n", (char const   *)((void *)0));
    }
  }
#line 914
  environ = newenvp;
#line 917
  if (change_environment) {
#line 918
    if (fakelogin) {
#line 919
      if ((unsigned long )shellstr != (unsigned long )pw->pw_shell) {
        {
#line 920
        free((void *)pw->pw_shell);
#line 921
        pw->pw_shell = xstrdup(shellstr);
        }
      }
      {
#line 923
      setup_env(pw);
      }
    } else {
      {
#line 925
      addenv("HOME", (char const   *)pw->pw_dir);
#line 926
      addenv("USER", (char const   *)pw->pw_name);
#line 927
      addenv("LOGNAME", (char const   *)pw->pw_name);
#line 928
      addenv("SHELL", shellstr);
      }
    }
  }
#line 932
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___9[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___9[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___9[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___9[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___9  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/suauth.c"
static int applies(char const   *single , char *list___30 ) ;
#line 58
static int isgrp(char const   *name___3 , char const   *group___0 ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/suauth.c"
static int lines  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/suauth.c"
int check_su_auth(char const   *actual_id , char const   *wanted_id , _Bool su_to_root ) 
{ 
  int posn ;
  int endline ;
  char field[2] ;
  FILE *authfile_fd ;
  char temp[1024] ;
  char *to_users ;
  char *from_users ;
  char *action ;
  int err ;
  int *tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  char *tmp___1 ;
  char *old_locale___0 ;
  char *tmp___2 ;
  char *saved_locale___0 ;
  size_t tmp___3 ;
  char *old_locale___1 ;
  char *tmp___4 ;
  char *saved_locale___1 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *old_locale___2 ;
  char *tmp___8 ;
  char *saved_locale___2 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *old_locale___3 ;
  char *tmp___11 ;
  char *saved_locale___3 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *old_locale___4 ;
  char *tmp___14 ;
  char *saved_locale___4 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *old_locale___5 ;
  char *tmp___17 ;
  char *saved_locale___5 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;

  {
  {
#line 68
  field[0] = (char )':';
#line 68
  field[1] = (char )'\000';
#line 75
  authfile_fd = fopen((char const   */* __restrict  */)"/etc/suauth", (char const   */* __restrict  */)"r");
  }
#line 75
  if (! authfile_fd) {
    {
#line 76
    tmp = __errno_location();
#line 76
    err = *tmp;
    }
#line 83
    if (2 == err) {
#line 84
      return (0);
    }
    {
#line 86
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 86
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 86
      old_locale = tmp___0;
#line 86
      saved_locale = (char *)((void *)0);
      }
#line 86
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 86
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 86
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 86
        setlocale(6, "C");
        }
      }
      {
#line 86
      tmp___1 = strerror(err);
#line 86
      syslog(3, "could not open/read config file \'%s\': %s\n", "/etc/suauth", tmp___1);
      }
#line 86
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 86
        setlocale(6, (char const   *)saved_locale);
#line 86
        free((void *)saved_locale);
        }
      }
#line 86
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 89
    return (-1);
  }
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 92
    tmp___21 = fgets((char */* __restrict  */)(temp), (int )sizeof(temp), (FILE */* __restrict  */)authfile_fd);
    }
#line 92
    if (! ((unsigned long )tmp___21 != (unsigned long )((void *)0))) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    lines ++;
#line 95
    tmp___3 = strlen((char const   *)(temp));
#line 95
    endline = (int )(tmp___3 - 1UL);
    }
#line 95
    if ((int )temp[endline] != 10) {
      {
#line 96
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 96
        tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 96
        old_locale___0 = tmp___2;
#line 96
        saved_locale___0 = (char *)((void *)0);
        }
#line 96
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 96
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 96
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 96
          setlocale(6, "C");
          }
        }
        {
#line 96
        syslog(3, "%s, line %d: line too long or missing newline", "/etc/suauth",
               lines);
        }
#line 96
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 96
          setlocale(6, (char const   *)saved_locale___0);
#line 96
          free((void *)saved_locale___0);
          }
        }
#line 96
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 99
      goto while_continue___0;
    }
    {
#line 102
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 102
      if (endline > 0) {
#line 102
        if (! ((int )temp[endline - 1] == 32)) {
#line 102
          if (! ((int )temp[endline - 1] == 9)) {
#line 102
            if (! ((int )temp[endline - 1] == 10)) {
#line 102
              goto while_break___2;
            }
          }
        }
      } else {
#line 102
        goto while_break___2;
      }
#line 105
      endline --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 106
    temp[endline] = (char )'\000';
#line 108
    posn = 0;
    {
#line 109
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 109
      if (! ((int )temp[posn] == 32)) {
#line 109
        if (! ((int )temp[posn] == 9)) {
#line 109
          goto while_break___3;
        }
      }
#line 110
      posn ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 112
    if ((int )temp[posn] == 10) {
#line 114
      goto while_continue___0;
    } else
#line 112
    if ((int )temp[posn] == 35) {
#line 114
      goto while_continue___0;
    } else
#line 112
    if ((int )temp[posn] == 0) {
#line 114
      goto while_continue___0;
    }
    {
#line 116
    to_users = strtok((char */* __restrict  */)(temp + posn), (char const   */* __restrict  */)(field));
    }
#line 116
    if (to_users) {
      {
#line 116
      from_users = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)(field));
      }
#line 116
      if (from_users) {
        {
#line 116
        action = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)(field));
        }
#line 116
        if (action) {
          {
#line 116
          tmp___5 = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)(field));
          }
#line 116
          if (tmp___5) {
            _L: /* CIL Label */ 
            {
#line 120
            while (1) {
              while_continue___4: /* CIL Label */ ;
              {
#line 120
              tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 120
              old_locale___1 = tmp___4;
#line 120
              saved_locale___1 = (char *)((void *)0);
              }
#line 120
              if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
                {
#line 120
                saved_locale___1 = strdup((char const   *)old_locale___1);
                }
              }
#line 120
              if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
                {
#line 120
                setlocale(6, "C");
                }
              }
              {
#line 120
              syslog(3, "%s, line %d. Bad number of fields.\n", "/etc/suauth", lines);
              }
#line 120
              if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
                {
#line 120
                setlocale(6, (char const   *)saved_locale___1);
#line 120
                free((void *)saved_locale___1);
                }
              }
#line 120
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 123
            goto while_continue___0;
          }
        } else {
#line 116
          goto _L;
        }
      } else {
#line 116
        goto _L;
      }
    } else {
#line 116
      goto _L;
    }
    {
#line 126
    tmp___6 = applies(wanted_id, to_users);
    }
#line 126
    if (! tmp___6) {
#line 127
      goto while_continue___0;
    }
    {
#line 128
    tmp___7 = applies(actual_id, from_users);
    }
#line 128
    if (! tmp___7) {
#line 129
      goto while_continue___0;
    }
    {
#line 130
    tmp___20 = strcmp((char const   *)action, "DENY");
    }
#line 130
    if (tmp___20) {
      {
#line 138
      tmp___19 = strcmp((char const   *)action, "NOPASS");
      }
#line 138
      if (tmp___19) {
        {
#line 145
        tmp___18 = strcmp((char const   *)action, "OWNPASS");
        }
#line 145
        if (tmp___18) {
          {
#line 154
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 154
            tmp___17 = setlocale(6, (char const   *)((void *)0));
#line 154
            old_locale___5 = tmp___17;
#line 154
            saved_locale___5 = (char *)((void *)0);
            }
#line 154
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
              {
#line 154
              saved_locale___5 = strdup((char const   *)old_locale___5);
              }
            }
#line 154
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
              {
#line 154
              setlocale(6, "C");
              }
            }
            {
#line 154
            syslog(3, "%s, line %d: unrecognised action!\n", "/etc/suauth", lines);
            }
#line 154
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
              {
#line 154
              setlocale(6, (char const   *)saved_locale___5);
#line 154
              free((void *)saved_locale___5);
              }
            }
#line 154
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
          {
#line 146
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 146
            tmp___14 = setlocale(6, (char const   *)((void *)0));
#line 146
            old_locale___4 = tmp___14;
#line 146
            saved_locale___4 = (char *)((void *)0);
            }
#line 146
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
              {
#line 146
              saved_locale___4 = strdup((char const   *)old_locale___4);
              }
            }
#line 146
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
              {
#line 146
              setlocale(6, "C");
              }
            }
#line 146
            if (su_to_root) {
#line 146
              tmp___15 = 5;
            } else {
#line 146
              tmp___15 = 6;
            }
            {
#line 146
            syslog(tmp___15, "su from \'%s\' to \'%s\': asking for user\'s own password (%s)\n",
                   actual_id, wanted_id, "/etc/suauth");
            }
#line 146
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
              {
#line 146
              setlocale(6, (char const   *)saved_locale___4);
#line 146
              free((void *)saved_locale___4);
              }
            }
#line 146
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 149
          tmp___16 = gettext("Please enter your OWN password as authentication.\n");
#line 149
          fputs((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)stderr);
#line 151
          fclose(authfile_fd);
          }
#line 152
          return (2);
        }
      } else {
        {
#line 139
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 139
          tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 139
          old_locale___3 = tmp___11;
#line 139
          saved_locale___3 = (char *)((void *)0);
          }
#line 139
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
            {
#line 139
            saved_locale___3 = strdup((char const   *)old_locale___3);
            }
          }
#line 139
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
            {
#line 139
            setlocale(6, "C");
            }
          }
#line 139
          if (su_to_root) {
#line 139
            tmp___12 = 5;
          } else {
#line 139
            tmp___12 = 6;
          }
          {
#line 139
          syslog(tmp___12, "NO password asked for su from \'%s\' to \'%s\' (%s)\n",
                 actual_id, wanted_id, "/etc/suauth");
          }
#line 139
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
            {
#line 139
            setlocale(6, (char const   *)saved_locale___3);
#line 139
            free((void *)saved_locale___3);
            }
          }
#line 139
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 142
        tmp___13 = gettext("Password authentication bypassed.\n");
#line 142
        fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)stderr);
#line 143
        fclose(authfile_fd);
        }
#line 144
        return (1);
      }
    } else {
      {
#line 131
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 131
        tmp___8 = setlocale(6, (char const   *)((void *)0));
#line 131
        old_locale___2 = tmp___8;
#line 131
        saved_locale___2 = (char *)((void *)0);
        }
#line 131
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 131
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 131
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 131
          setlocale(6, "C");
          }
        }
#line 131
        if (su_to_root) {
#line 131
          tmp___9 = 4;
        } else {
#line 131
          tmp___9 = 5;
        }
        {
#line 131
        syslog(tmp___9, "DENIED su from \'%s\' to \'%s\' (%s)\n", actual_id, wanted_id,
               "/etc/suauth");
        }
#line 131
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 131
          setlocale(6, (char const   *)saved_locale___2);
#line 131
          free((void *)saved_locale___2);
          }
        }
#line 131
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 134
      tmp___10 = gettext("Access to su to that account DENIED.\n");
#line 134
      fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stderr);
#line 136
      fclose(authfile_fd);
      }
#line 137
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 159
  fclose(authfile_fd);
  }
#line 160
  return (0);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/suauth.c"
static int applies(char const   *single , char *list___30 ) 
{ 
  char split[3] ;
  char *tok ;
  int state ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char *old_locale___0 ;
  char *tmp___0 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___1 ;
  char *saved_locale___1 ;
  int tmp___2 ;
  char *old_locale___2 ;
  char *tmp___3 ;
  char *saved_locale___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 165
  split[0] = (char )',';
#line 165
  split[1] = (char )' ';
#line 165
  split[2] = (char )'\000';
#line 168
  state = 0;
#line 170
  tok = strtok((char */* __restrict  */)list___30, (char const   */* __restrict  */)(split));
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 170
      goto while_break;
    }
    {
#line 173
    tmp___9 = strcmp((char const   *)tok, "ALL");
    }
#line 173
    if (tmp___9) {
      {
#line 181
      tmp___8 = strcmp((char const   *)tok, "EXCEPT");
      }
#line 181
      if (tmp___8) {
        {
#line 189
        tmp___7 = strcmp((char const   *)tok, "GROUP");
        }
#line 189
        if (tmp___7) {
          {
#line 199
          if (state == 0) {
#line 199
            goto case_0;
          }
#line 203
          if (state == 1) {
#line 203
            goto case_1;
          }
#line 208
          if (state == 2) {
#line 208
            goto case_2;
          }
#line 212
          if (state == 3) {
#line 212
            goto case_3;
          }
#line 216
          if (state == 4) {
#line 216
            goto case_4;
          }
#line 198
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 200
          tmp___2 = strcmp((char const   *)tok, single);
          }
#line 200
          if (! tmp___2) {
#line 201
            return (1);
          }
#line 202
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 204
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 204
            tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 204
            old_locale___2 = tmp___3;
#line 204
            saved_locale___2 = (char *)((void *)0);
            }
#line 204
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
              {
#line 204
              saved_locale___2 = strdup((char const   *)old_locale___2);
              }
            }
#line 204
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
              {
#line 204
              setlocale(6, "C");
              }
            }
            {
#line 204
            syslog(3, "%s, line %d: expect another token after ALL\n", "/etc/suauth",
                   lines);
            }
#line 204
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
              {
#line 204
              setlocale(6, (char const   *)saved_locale___2);
#line 204
              free((void *)saved_locale___2);
              }
            }
#line 204
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 207
          return (0);
          case_2: /* CIL Label */ 
          {
#line 209
          tmp___4 = strcmp((char const   *)tok, single);
          }
#line 209
          if (! tmp___4) {
#line 210
            return (0);
          }
#line 211
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 213
          tmp___5 = isgrp(single, (char const   *)tok);
          }
#line 213
          if (tmp___5) {
#line 214
            return (1);
          }
#line 215
          goto switch_break;
          case_4: /* CIL Label */ 
          {
#line 217
          tmp___6 = isgrp(single, (char const   *)tok);
          }
#line 217
          if (tmp___6) {
#line 218
            return (0);
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 190
          if (state != 0) {
#line 190
            if (state != 2) {
              {
#line 191
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
#line 191
                tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 191
                old_locale___1 = tmp___1;
#line 191
                saved_locale___1 = (char *)((void *)0);
                }
#line 191
                if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
                  {
#line 191
                  saved_locale___1 = strdup((char const   *)old_locale___1);
                  }
                }
#line 191
                if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
                  {
#line 191
                  setlocale(6, "C");
                  }
                }
                {
#line 191
                syslog(3, "%s, line %d: GROUP in bad place\n", "/etc/suauth", lines);
                }
#line 191
                if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
                  {
#line 191
                  setlocale(6, (char const   *)saved_locale___1);
#line 191
                  free((void *)saved_locale___1);
                  }
                }
#line 191
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 194
              return (0);
            }
          }
#line 196
          if (state == 0) {
#line 196
            state = 3;
          } else {
#line 196
            state = 4;
          }
        }
      } else {
#line 182
        if (state != 1) {
          {
#line 183
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 183
            tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 183
            old_locale___0 = tmp___0;
#line 183
            saved_locale___0 = (char *)((void *)0);
            }
#line 183
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
              {
#line 183
              saved_locale___0 = strdup((char const   *)old_locale___0);
              }
            }
#line 183
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 183
              setlocale(6, "C");
              }
            }
            {
#line 183
            syslog(3, "%s, line %d: EXCEPT in bas place\n", "/etc/suauth", lines);
            }
#line 183
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 183
              setlocale(6, (char const   *)saved_locale___0);
#line 183
              free((void *)saved_locale___0);
              }
            }
#line 183
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 186
          return (0);
        }
#line 188
        state = 2;
      }
    } else {
#line 174
      if (state != 0) {
        {
#line 175
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 175
          tmp = setlocale(6, (char const   *)((void *)0));
#line 175
          old_locale = tmp;
#line 175
          saved_locale = (char *)((void *)0);
          }
#line 175
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 175
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 175
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 175
            setlocale(6, "C");
            }
          }
          {
#line 175
          syslog(3, "%s, line %d: ALL in bad place\n", "/etc/suauth", lines);
          }
#line 175
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 175
            setlocale(6, (char const   *)saved_locale);
#line 175
            free((void *)saved_locale);
            }
          }
#line 175
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 178
        return (0);
      }
#line 180
      state = 1;
    }
    {
#line 170
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(split));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (state != 0) {
#line 223
    if (state != 3) {
#line 224
      return (1);
    }
  }
#line 225
  return (0);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/suauth.c"
static int isgrp(char const   *name___3 , char const   *group___0 ) 
{ 
  struct group *grp ;
  _Bool tmp ;

  {
  {
#line 232
  grp = getgrnam(group___0);
  }
#line 234
  if (! grp) {
#line 235
    return (0);
  } else
#line 234
  if (! grp->gr_mem) {
#line 235
    return (0);
  }
  {
#line 237
  tmp = is_on_list((char * const  *)grp->gr_mem, name___3);
  }
#line 237
  return ((int )tmp);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___10(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___10(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___10[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___10[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___10  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static _Bool eflg___0  =    (_Bool)0;
#line 62 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static _Bool md5flg  =    (_Bool)0;
#line 64 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static _Bool sflg___1  =    (_Bool)0;
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static char const   *crypt_method___0  =    (char const   *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static long sha_rounds___0  =    5000L;
#line 74 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static _Bool is_shadow_grp___1  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static _Bool sgr_locked___2  =    (_Bool)0;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static _Bool gr_locked___2  =    (_Bool)0;
#line 80
static void fail_exit___4(int code ) ;
#line 81
static void usage___8(int status ) ;
#line 82
static void process_flags___6(int argc , char **argv ) ;
#line 83
static void check_flags___2(void) ;
#line 84
static void check_perms___4(void) ;
#line 85
static void open_files___4(void) ;
#line 86
static void close_files___4(void) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void fail_exit___4(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 93
  if (gr_locked___2) {
    {
#line 94
    tmp___3 = gr_unlock();
    }
#line 94
    if (tmp___3 == 0) {
      {
#line 95
      tmp = gr_dbname();
#line 95
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 95
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 96
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 96
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 96
        old_locale = tmp___1;
#line 96
        saved_locale = (char *)((void *)0);
        }
#line 96
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 96
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 96
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 96
          setlocale(6, "C");
          }
        }
        {
#line 96
        tmp___2 = gr_dbname();
#line 96
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 96
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 96
          setlocale(6, (char const   *)saved_locale);
#line 96
          free((void *)saved_locale);
          }
        }
#line 96
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 102
  if (sgr_locked___2) {
    {
#line 103
    tmp___8 = sgr_unlock();
    }
#line 103
    if (tmp___8 == 0) {
      {
#line 104
      tmp___4 = sgr_dbname();
#line 104
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 105
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 105
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 105
        old_locale___0 = tmp___6;
#line 105
        saved_locale___0 = (char *)((void *)0);
        }
#line 105
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 105
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 105
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 105
          setlocale(6, "C");
          }
        }
        {
#line 105
        tmp___7 = sgr_dbname();
#line 105
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 105
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 105
          setlocale(6, (char const   *)saved_locale___0);
#line 105
          free((void *)saved_locale___0);
          }
        }
#line 105
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 111
  exit(code);
  }
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void usage___8(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 119
  if (0 != status) {
#line 119
    tmp = stderr;
  } else {
#line 119
    tmp = stdout;
  }
  {
#line 119
  usageout = tmp;
#line 120
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 120
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 125
  tmp___1 = gettext("  -c, --crypt-method METHOD     the crypt method (one of %s)\n");
#line 125
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___1,
          "NONE DES MD5 SHA256 SHA512");
#line 133
  tmp___2 = gettext("  -e, --encrypted               supplied passwords are encrypted\n");
#line 133
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 134
  tmp___3 = gettext("  -h, --help                    display this help message and exit\n");
#line 134
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 135
  tmp___4 = gettext("  -m, --md5                     encrypt the clear text password using\n                                the MD5 algorithm\n");
#line 135
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 138
  tmp___5 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 138
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 140
  tmp___6 = gettext("  -s, --sha-rounds              number of SHA rounds for the SHA*\n                                crypt algorithms\n");
#line 140
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 144
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 146
  exit(status);
  }
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static struct option long_options___7[7]  = {      {"crypt-method", 1, (int *)((void *)0), 'c'}, 
        {"encrypted", 0, (int *)((void *)0), 'e'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"md5", 0, (int *)((void *)0), 'm'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"sha-rounds", 1, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 154 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void process_flags___6(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    c = getopt_long(argc, (char * const  *)argv, "c:ehmR:s:", (struct option  const  *)(long_options___7),
                    (int *)((void *)0));
    }
#line 169
    if (! (c != -1)) {
#line 169
      goto while_break;
    }
    {
#line 177
    if (c == 99) {
#line 177
      goto case_99;
    }
#line 180
    if (c == 101) {
#line 180
      goto case_101;
    }
#line 183
    if (c == 104) {
#line 183
      goto case_104;
    }
#line 186
    if (c == 109) {
#line 186
      goto case_109;
    }
#line 189
    if (c == 82) {
#line 189
      goto case_82;
    }
#line 192
    if (c == 115) {
#line 192
      goto case_115;
    }
#line 202
    goto switch_default;
    case_99: /* CIL Label */ 
#line 178
    crypt_method___0 = (char const   *)optarg;
#line 179
    goto switch_break;
    case_101: /* CIL Label */ 
#line 181
    eflg___0 = (_Bool)1;
#line 182
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 184
    usage___8(0);
    }
#line 185
    goto switch_break;
    case_109: /* CIL Label */ 
#line 187
    md5flg = (_Bool)1;
#line 188
    goto switch_break;
    case_82: /* CIL Label */ 
#line 190
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 193
    sflg___1 = (_Bool)1;
#line 194
    tmp___0 = getlong((char const   *)optarg, & sha_rounds___0);
    }
#line 194
    if (tmp___0 == 0) {
      {
#line 195
      tmp = gettext("%s: invalid numeric argument \'%s\'\n");
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 198
      usage___8(2);
      }
    }
#line 200
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 203
    usage___8(2);
    }
#line 204
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  check_flags___2();
  }
#line 210
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void check_flags___2(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 220
  if (sflg___1) {
#line 220
    if (! ((unsigned long )((void *)0) != (unsigned long )crypt_method___0)) {
      {
#line 221
      tmp = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, "-s", "-c");
#line 224
      usage___8(2);
      }
    }
  }
#line 228
  if (eflg___0) {
#line 228
    if (md5flg) {
      {
#line 230
      tmp___0 = gettext("%s: the -c, -e, and -m flags are exclusive\n");
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 233
      usage___8(2);
      }
    } else
#line 228
    if ((unsigned long )((void *)0) != (unsigned long )crypt_method___0) {
      {
#line 230
      tmp___0 = gettext("%s: the -c, -e, and -m flags are exclusive\n");
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 233
      usage___8(2);
      }
    } else {
#line 228
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 228
  if (md5flg) {
#line 228
    if ((unsigned long )((void *)0) != (unsigned long )crypt_method___0) {
      {
#line 230
      tmp___0 = gettext("%s: the -c, -e, and -m flags are exclusive\n");
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 233
      usage___8(2);
      }
    }
  }
#line 236
  if ((unsigned long )((void *)0) != (unsigned long )crypt_method___0) {
    {
#line 237
    tmp___2 = strcmp(crypt_method___0, "DES");
    }
#line 237
    if (0 != tmp___2) {
      {
#line 237
      tmp___3 = strcmp(crypt_method___0, "MD5");
      }
#line 237
      if (0 != tmp___3) {
        {
#line 237
        tmp___4 = strcmp(crypt_method___0, "NONE");
        }
#line 237
        if (0 != tmp___4) {
          {
#line 237
          tmp___5 = strcmp(crypt_method___0, "SHA256");
          }
#line 237
          if (0 != tmp___5) {
            {
#line 237
            tmp___6 = strcmp(crypt_method___0, "SHA512");
            }
#line 237
            if (0 != tmp___6) {
              {
#line 245
              tmp___1 = gettext("%s: unsupported crypt method: %s\n");
#line 245
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                      Prog, crypt_method___0);
#line 248
              usage___8(2);
              }
            }
          }
        }
      }
    }
  }
#line 251
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void check_perms___4(void) 
{ 


  {
#line 301
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void open_files___4(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 312
  tmp___1 = gr_lock();
  }
#line 312
  if (tmp___1 == 0) {
    {
#line 313
    tmp = gr_dbname();
#line 313
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 316
    fail_exit___4(1);
    }
  }
  {
#line 318
  gr_locked___2 = (_Bool)1;
#line 319
  tmp___4 = gr_open(2);
  }
#line 319
  if (tmp___4 == 0) {
    {
#line 320
    tmp___2 = gr_dbname();
#line 320
    tmp___3 = gettext("%s: cannot open %s\n");
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 322
    fail_exit___4(1);
    }
  }
#line 327
  if (is_shadow_grp___1) {
    {
#line 328
    tmp___7 = sgr_lock();
    }
#line 328
    if (tmp___7 == 0) {
      {
#line 329
      tmp___5 = sgr_dbname();
#line 329
      tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 329
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, tmp___5);
#line 332
      fail_exit___4(1);
      }
    }
    {
#line 334
    sgr_locked___2 = (_Bool)1;
#line 335
    tmp___10 = sgr_open(2);
    }
#line 335
    if (tmp___10 == 0) {
      {
#line 336
      tmp___8 = sgr_dbname();
#line 336
      tmp___9 = gettext("%s: cannot open %s\n");
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
#line 338
      fail_exit___4(1);
      }
    }
  }
#line 342
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static void close_files___4(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 350
  if (is_shadow_grp___1) {
    {
#line 351
    tmp___3 = sgr_close();
    }
#line 351
    if (tmp___3 == 0) {
      {
#line 352
      tmp = sgr_dbname();
#line 352
      tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 352
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 355
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 355
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 355
        old_locale = tmp___1;
#line 355
        saved_locale = (char *)((void *)0);
        }
#line 355
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 355
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 355
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 355
          setlocale(6, "C");
          }
        }
        {
#line 355
        tmp___2 = sgr_dbname();
#line 355
        syslog(3, "failure while writing changes to %s", tmp___2);
        }
#line 355
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 355
          setlocale(6, (char const   *)saved_locale);
#line 355
          free((void *)saved_locale);
          }
        }
#line 355
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 356
      fail_exit___4(1);
      }
    }
    {
#line 358
    tmp___8 = sgr_unlock();
    }
#line 358
    if (tmp___8 == 0) {
      {
#line 359
      tmp___4 = sgr_dbname();
#line 359
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 360
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 360
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 360
        old_locale___0 = tmp___6;
#line 360
        saved_locale___0 = (char *)((void *)0);
        }
#line 360
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 360
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 360
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 360
          setlocale(6, "C");
          }
        }
        {
#line 360
        tmp___7 = sgr_dbname();
#line 360
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 360
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 360
          setlocale(6, (char const   *)saved_locale___0);
#line 360
          free((void *)saved_locale___0);
          }
        }
#line 360
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 363
    sgr_locked___2 = (_Bool)0;
  }
  {
#line 367
  tmp___13 = gr_close();
  }
#line 367
  if (tmp___13 == 0) {
    {
#line 368
    tmp___9 = gr_dbname();
#line 368
    tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
            Prog, tmp___9);
    }
    {
#line 371
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 371
      tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 371
      old_locale___1 = tmp___11;
#line 371
      saved_locale___1 = (char *)((void *)0);
      }
#line 371
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 371
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 371
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 371
        setlocale(6, "C");
        }
      }
      {
#line 371
      tmp___12 = gr_dbname();
#line 371
      syslog(3, "failure while writing changes to %s", tmp___12);
      }
#line 371
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 371
        setlocale(6, (char const   *)saved_locale___1);
#line 371
        free((void *)saved_locale___1);
        }
      }
#line 371
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 372
    fail_exit___4(1);
    }
  }
  {
#line 374
  tmp___18 = gr_unlock();
  }
#line 374
  if (tmp___18 == 0) {
    {
#line 375
    tmp___14 = gr_dbname();
#line 375
    tmp___15 = gettext("%s: failed to unlock %s\n");
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
            Prog, tmp___14);
    }
    {
#line 376
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 376
      tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 376
      old_locale___2 = tmp___16;
#line 376
      saved_locale___2 = (char *)((void *)0);
      }
#line 376
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 376
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 376
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 376
        setlocale(6, "C");
        }
      }
      {
#line 376
      tmp___17 = gr_dbname();
#line 376
      syslog(3, "failed to unlock %s", tmp___17);
      }
#line 376
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 376
        setlocale(6, (char const   *)saved_locale___2);
#line 376
        free((void *)saved_locale___2);
        }
      }
#line 376
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 379
  gr_locked___2 = (_Bool)0;
#line 380
  return;
}
}
#line 499
int main(int argc , char **argv ) ;
#line 499 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chgpasswd.c"
static char *empty___0  =    (char *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___9(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___10  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___19  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___9(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___19) {
#line 70
      size___19 = i + 100;
#line 71
      if (members___10) {
        {
#line 72
        tmp = realloc((void *)members___10, (unsigned long )size___19 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___19 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___10) {
          {
#line 81
          free((void *)members___10);
          }
        }
#line 82
        members___10 = (char **)0;
#line 83
        size___19 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___10 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___10 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___10 + i) = (char *)0;
#line 99
  return (members___10);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___9  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___20  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___9[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___9  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___10(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___10(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___10  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___10  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___10  ;
#line 72
static int copy_entry___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___10(char const   *filename___0 ) ;
#line 83
static int copy_symlink___10(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___10(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___10(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___10(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___10(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___10(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___10 == (unsigned long )ln) {
    {
#line 149
    links___10 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___10;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___10(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___10)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___10)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___10;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___10);
#line 199
  dst_len = strlen(dst_orig___10);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___10, name___3 + src_len);
#line 207
  lp->ln_next = links___10;
#line 208
  links___10 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___10(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___10(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___10(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___10(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___10(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___10(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___10(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___10(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___10(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___10)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___10)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___10(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___10);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___10, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___10);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___10);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___10);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___10, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___10(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___10(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___10(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___10(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___10(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___10(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___10(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___10(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___10(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___10[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___10[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___11(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___11(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___11[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___11[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___11  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___10(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___11  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___21  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___10(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___21) {
#line 70
      size___21 = i + 100;
#line 71
      if (members___11) {
        {
#line 72
        tmp = realloc((void *)members___11, (unsigned long )size___21 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___21 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___11) {
          {
#line 81
          free((void *)members___11);
          }
        }
#line 82
        members___11 = (char **)0;
#line 83
        size___21 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___11 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___11 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___11 + i) = (char *)0;
#line 99
  return (members___11);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___10  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___22  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___10[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___10  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___11(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___11(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___11  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___11  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___11  ;
#line 72
static int copy_entry___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___11(char const   *filename___0 ) ;
#line 83
static int copy_symlink___11(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___11(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___11(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___11(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___11(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___11(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___11 == (unsigned long )ln) {
    {
#line 149
    links___11 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___11;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___11(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___11)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___11)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___11;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___11);
#line 199
  dst_len = strlen(dst_orig___11);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___11, name___3 + src_len);
#line 207
  lp->ln_next = links___11;
#line 208
  links___11 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___11(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___11(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___11(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___11(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___11(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___11(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___11(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___11(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___11(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___11)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___11)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___11(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___11);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___11, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___11);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___11);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___11);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___11, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___11(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___11(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___11(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___11(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___11(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___11(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___11(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___11(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___11(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 47 "../lib/pwio.h"
extern struct passwd  const  *pw_next(void) ;
#line 50
extern int pw_rewind(void) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwunconv.c"
static _Bool spw_locked___3  =    (_Bool)0;
#line 57 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwunconv.c"
static _Bool pw_locked___3  =    (_Bool)0;
#line 60
static void fail_exit___5(int status ) ;
#line 61
static void usage___9(int status ) ;
#line 62
static void process_flags___7(int argc , char **argv ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwunconv.c"
static void fail_exit___5(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 66
  if (spw_locked___3) {
    {
#line 67
    tmp___3 = spw_unlock();
    }
#line 67
    if (tmp___3 == 0) {
      {
#line 68
      tmp = spw_dbname();
#line 68
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 68
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 69
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 69
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 69
        old_locale = tmp___1;
#line 69
        saved_locale = (char *)((void *)0);
        }
#line 69
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 69
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 69
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 69
          setlocale(6, "C");
          }
        }
        {
#line 69
        tmp___2 = spw_dbname();
#line 69
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 69
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 69
          setlocale(6, (char const   *)saved_locale);
#line 69
          free((void *)saved_locale);
          }
        }
#line 69
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 73
  if (pw_locked___3) {
    {
#line 74
    tmp___8 = pw_unlock();
    }
#line 74
    if (tmp___8 == 0) {
      {
#line 75
      tmp___4 = pw_dbname();
#line 75
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 75
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 76
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 76
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 76
        old_locale___0 = tmp___6;
#line 76
        saved_locale___0 = (char *)((void *)0);
        }
#line 76
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 76
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 76
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 76
          setlocale(6, "C");
          }
        }
        {
#line 76
        tmp___7 = pw_dbname();
#line 76
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 76
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 76
          setlocale(6, (char const   *)saved_locale___0);
#line 76
          free((void *)saved_locale___0);
          }
        }
#line 76
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 80
  exit(status);
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwunconv.c"
static void usage___9(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 85
  if (0 != status) {
#line 85
    tmp = stderr;
  } else {
#line 85
    tmp = stdout;
  }
  {
#line 85
  usageout = tmp;
#line 86
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 86
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 91
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 91
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 92
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 92
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 93
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 94
  exit(status);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwunconv.c"
static struct option long_options___8[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 102 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwunconv.c"
static void process_flags___7(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 114
    c = getopt_long(argc, (char * const  *)argv, "hR:", (struct option  const  *)(long_options___8),
                    (int *)((void *)0));
    }
#line 114
    if (! (c != -1)) {
#line 114
      goto while_break;
    }
    {
#line 117
    if (c == 104) {
#line 117
      goto case_104;
    }
#line 120
    if (c == 82) {
#line 120
      goto case_82;
    }
#line 122
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 118
    usage___9(0);
    }
#line 119
    goto switch_break;
    case_82: /* CIL Label */ 
#line 121
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 123
    usage___9(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if (optind != argc) {
    {
#line 128
    usage___9(2);
    }
  }
#line 130
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___11[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___11[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___12(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___12(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___12[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___12[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___12  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___11(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___12  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___23  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___11(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___23) {
#line 70
      size___23 = i + 100;
#line 71
      if (members___12) {
        {
#line 72
        tmp = realloc((void *)members___12, (unsigned long )size___23 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___23 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___12) {
          {
#line 81
          free((void *)members___12);
          }
        }
#line 82
        members___12 = (char **)0;
#line 83
        size___23 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___12 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___12 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___12 + i) = (char *)0;
#line 99
  return (members___12);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___11  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___24  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___11[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___11  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___12(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static _Bool eflg___1  =    (_Bool)0;
#line 59 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static _Bool md5flg___0  =    (_Bool)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static _Bool sflg___2  =    (_Bool)0;
#line 64 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static char const   *crypt_method___1  =    (char const   *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static long sha_rounds___1  =    5000L;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static _Bool is_shadow_pwd___0  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static _Bool pw_locked___4  =    (_Bool)0;
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static _Bool spw_locked___4  =    (_Bool)0;
#line 75
static void fail_exit___6(int code ) ;
#line 76
static void usage___10(int status ) ;
#line 77
static void process_flags___8(int argc , char **argv ) ;
#line 78
static void check_flags___3(void) ;
#line 79
static void check_perms___5(void) ;
#line 80
static void open_files___5(void) ;
#line 81
static void close_files___5(void) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void fail_exit___6(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 88
  if (pw_locked___4) {
    {
#line 89
    tmp___3 = pw_unlock();
    }
#line 89
    if (tmp___3 == 0) {
      {
#line 90
      tmp = pw_dbname();
#line 90
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 91
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 91
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 91
        old_locale = tmp___1;
#line 91
        saved_locale = (char *)((void *)0);
        }
#line 91
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 91
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 91
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 91
          setlocale(6, "C");
          }
        }
        {
#line 91
        tmp___2 = pw_dbname();
#line 91
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 91
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 91
          setlocale(6, (char const   *)saved_locale);
#line 91
          free((void *)saved_locale);
          }
        }
#line 91
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 96
  if (spw_locked___4) {
    {
#line 97
    tmp___8 = spw_unlock();
    }
#line 97
    if (tmp___8 == 0) {
      {
#line 98
      tmp___4 = spw_dbname();
#line 98
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 98
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 99
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 99
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 99
        old_locale___0 = tmp___6;
#line 99
        saved_locale___0 = (char *)((void *)0);
        }
#line 99
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 99
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 99
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 99
          setlocale(6, "C");
          }
        }
        {
#line 99
        tmp___7 = spw_dbname();
#line 99
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 99
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 99
          setlocale(6, (char const   *)saved_locale___0);
#line 99
          free((void *)saved_locale___0);
          }
        }
#line 99
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 104
  exit(code);
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void usage___10(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 112
  if (0 != status) {
#line 112
    tmp = stderr;
  } else {
#line 112
    tmp = stdout;
  }
  {
#line 112
  usageout = tmp;
#line 113
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 113
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 118
  tmp___1 = gettext("  -c, --crypt-method METHOD     the crypt method (one of %s)\n");
#line 118
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___1,
          "NONE DES MD5 SHA256 SHA512");
#line 126
  tmp___2 = gettext("  -e, --encrypted               supplied passwords are encrypted\n");
#line 126
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 127
  tmp___3 = gettext("  -h, --help                    display this help message and exit\n");
#line 127
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 128
  tmp___4 = gettext("  -m, --md5                     encrypt the clear text password using\n                                the MD5 algorithm\n");
#line 128
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 131
  tmp___5 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 131
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 133
  tmp___6 = gettext("  -s, --sha-rounds              number of SHA rounds for the SHA*\n                                crypt algorithms\n");
#line 133
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 137
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 139
  exit(status);
  }
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static struct option long_options___9[7]  = {      {"crypt-method", 1, (int *)((void *)0), 'c'}, 
        {"encrypted", 0, (int *)((void *)0), 'e'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"md5", 0, (int *)((void *)0), 'm'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"sha-rounds", 1, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 147 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void process_flags___8(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    c = getopt_long(argc, (char * const  *)argv, "c:ehmR:s:", (struct option  const  *)(long_options___9),
                    (int *)((void *)0));
    }
#line 162
    if (! (c != -1)) {
#line 162
      goto while_break;
    }
    {
#line 170
    if (c == 99) {
#line 170
      goto case_99;
    }
#line 173
    if (c == 101) {
#line 173
      goto case_101;
    }
#line 176
    if (c == 104) {
#line 176
      goto case_104;
    }
#line 179
    if (c == 109) {
#line 179
      goto case_109;
    }
#line 182
    if (c == 82) {
#line 182
      goto case_82;
    }
#line 185
    if (c == 115) {
#line 185
      goto case_115;
    }
#line 195
    goto switch_default;
    case_99: /* CIL Label */ 
#line 171
    crypt_method___1 = (char const   *)optarg;
#line 172
    goto switch_break;
    case_101: /* CIL Label */ 
#line 174
    eflg___1 = (_Bool)1;
#line 175
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 177
    usage___10(0);
    }
#line 178
    goto switch_break;
    case_109: /* CIL Label */ 
#line 180
    md5flg___0 = (_Bool)1;
#line 181
    goto switch_break;
    case_82: /* CIL Label */ 
#line 183
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 186
    sflg___2 = (_Bool)1;
#line 187
    tmp___0 = getlong((char const   *)optarg, & sha_rounds___1);
    }
#line 187
    if (tmp___0 == 0) {
      {
#line 188
      tmp = gettext("%s: invalid numeric argument \'%s\'\n");
#line 188
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 191
      usage___10(2);
      }
    }
#line 193
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 196
    usage___10(2);
    }
#line 197
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  check_flags___3();
  }
#line 203
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void check_flags___3(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 213
  if (sflg___2) {
#line 213
    if (! ((unsigned long )((void *)0) != (unsigned long )crypt_method___1)) {
      {
#line 214
      tmp = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 214
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, "-s", "-c");
#line 217
      usage___10(2);
      }
    }
  }
#line 221
  if (eflg___1) {
#line 221
    if (md5flg___0) {
      {
#line 223
      tmp___0 = gettext("%s: the -c, -e, and -m flags are exclusive\n");
#line 223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 226
      usage___10(2);
      }
    } else
#line 221
    if ((unsigned long )((void *)0) != (unsigned long )crypt_method___1) {
      {
#line 223
      tmp___0 = gettext("%s: the -c, -e, and -m flags are exclusive\n");
#line 223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 226
      usage___10(2);
      }
    } else {
#line 221
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 221
  if (md5flg___0) {
#line 221
    if ((unsigned long )((void *)0) != (unsigned long )crypt_method___1) {
      {
#line 223
      tmp___0 = gettext("%s: the -c, -e, and -m flags are exclusive\n");
#line 223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog);
#line 226
      usage___10(2);
      }
    }
  }
#line 229
  if ((unsigned long )((void *)0) != (unsigned long )crypt_method___1) {
    {
#line 230
    tmp___2 = strcmp(crypt_method___1, "DES");
    }
#line 230
    if (0 != tmp___2) {
      {
#line 230
      tmp___3 = strcmp(crypt_method___1, "MD5");
      }
#line 230
      if (0 != tmp___3) {
        {
#line 230
        tmp___4 = strcmp(crypt_method___1, "NONE");
        }
#line 230
        if (0 != tmp___4) {
          {
#line 230
          tmp___5 = strcmp(crypt_method___1, "SHA256");
          }
#line 230
          if (0 != tmp___5) {
            {
#line 230
            tmp___6 = strcmp(crypt_method___1, "SHA512");
            }
#line 230
            if (0 != tmp___6) {
              {
#line 238
              tmp___1 = gettext("%s: unsupported crypt method: %s\n");
#line 238
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                      Prog, crypt_method___1);
#line 241
              usage___10(2);
              }
            }
          }
        }
      }
    }
  }
#line 244
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void check_perms___5(void) 
{ 


  {
#line 298
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void open_files___5(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 309
  tmp___1 = pw_lock();
  }
#line 309
  if (tmp___1 == 0) {
    {
#line 310
    tmp = pw_dbname();
#line 310
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 313
    fail_exit___6(1);
    }
  }
  {
#line 315
  pw_locked___4 = (_Bool)1;
#line 316
  tmp___4 = pw_open(2);
  }
#line 316
  if (tmp___4 == 0) {
    {
#line 317
    tmp___2 = pw_dbname();
#line 317
    tmp___3 = gettext("%s: cannot open %s\n");
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 319
    fail_exit___6(1);
    }
  }
#line 323
  if (is_shadow_pwd___0) {
    {
#line 324
    tmp___7 = spw_lock();
    }
#line 324
    if (tmp___7 == 0) {
      {
#line 325
      tmp___5 = spw_dbname();
#line 325
      tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 325
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, tmp___5);
#line 328
      fail_exit___6(1);
      }
    }
    {
#line 330
    spw_locked___4 = (_Bool)1;
#line 331
    tmp___10 = spw_open(2);
    }
#line 331
    if (tmp___10 == 0) {
      {
#line 332
      tmp___8 = spw_dbname();
#line 332
      tmp___9 = gettext("%s: cannot open %s\n");
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
#line 335
      fail_exit___6(1);
      }
    }
  }
#line 338
  return;
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chpasswd.c"
static void close_files___5(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 345
  if (is_shadow_pwd___0) {
    {
#line 346
    tmp___3 = spw_close();
    }
#line 346
    if (tmp___3 == 0) {
      {
#line 347
      tmp = spw_dbname();
#line 347
      tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 350
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 350
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 350
        old_locale = tmp___1;
#line 350
        saved_locale = (char *)((void *)0);
        }
#line 350
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 350
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 350
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 350
          setlocale(6, "C");
          }
        }
        {
#line 350
        tmp___2 = spw_dbname();
#line 350
        syslog(3, "failure while writing changes to %s", tmp___2);
        }
#line 350
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 350
          setlocale(6, (char const   *)saved_locale);
#line 350
          free((void *)saved_locale);
          }
        }
#line 350
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 351
      fail_exit___6(1);
      }
    }
    {
#line 353
    tmp___8 = spw_unlock();
    }
#line 353
    if (tmp___8 == 0) {
      {
#line 354
      tmp___4 = spw_dbname();
#line 354
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 354
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 355
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 355
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 355
        old_locale___0 = tmp___6;
#line 355
        saved_locale___0 = (char *)((void *)0);
        }
#line 355
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 355
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 355
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 355
          setlocale(6, "C");
          }
        }
        {
#line 355
        tmp___7 = spw_dbname();
#line 355
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 355
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 355
          setlocale(6, (char const   *)saved_locale___0);
#line 355
          free((void *)saved_locale___0);
          }
        }
#line 355
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 358
    spw_locked___4 = (_Bool)0;
  }
  {
#line 361
  tmp___13 = pw_close();
  }
#line 361
  if (tmp___13 == 0) {
    {
#line 362
    tmp___9 = pw_dbname();
#line 362
    tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
            Prog, tmp___9);
    }
    {
#line 365
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 365
      tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 365
      old_locale___1 = tmp___11;
#line 365
      saved_locale___1 = (char *)((void *)0);
      }
#line 365
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 365
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 365
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 365
        setlocale(6, "C");
        }
      }
      {
#line 365
      tmp___12 = pw_dbname();
#line 365
      syslog(3, "failure while writing changes to %s", tmp___12);
      }
#line 365
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 365
        setlocale(6, (char const   *)saved_locale___1);
#line 365
        free((void *)saved_locale___1);
        }
      }
#line 365
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 366
    fail_exit___6(1);
    }
  }
  {
#line 368
  tmp___18 = pw_unlock();
  }
#line 368
  if (tmp___18 == 0) {
    {
#line 369
    tmp___14 = pw_dbname();
#line 369
    tmp___15 = gettext("%s: failed to unlock %s\n");
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
            Prog, tmp___14);
    }
    {
#line 370
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 370
      tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 370
      old_locale___2 = tmp___16;
#line 370
      saved_locale___2 = (char *)((void *)0);
      }
#line 370
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 370
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 370
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 370
        setlocale(6, "C");
        }
      }
      {
#line 370
      tmp___17 = pw_dbname();
#line 370
      syslog(3, "failed to unlock %s", tmp___17);
      }
#line 370
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 370
        setlocale(6, (char const   *)saved_locale___2);
#line 370
        free((void *)saved_locale___2);
        }
      }
#line 370
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 373
  pw_locked___4 = (_Bool)0;
#line 374
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___12(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___12  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___12  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___12  ;
#line 72
static int copy_entry___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___12(char const   *filename___0 ) ;
#line 83
static int copy_symlink___12(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___12(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___12(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___12(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___12(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___12(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___12 == (unsigned long )ln) {
    {
#line 149
    links___12 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___12;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___12(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___12)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___12)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___12;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___12);
#line 199
  dst_len = strlen(dst_orig___12);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___12, name___3 + src_len);
#line 207
  lp->ln_next = links___12;
#line 208
  links___12 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___12(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___12(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___12(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___12(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___12(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___12(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___12(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___12(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___12(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___12)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___12)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___12(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___12);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___12, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___12);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___12);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___12);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___12, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___12(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___12(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___12(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___12(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___12(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___12(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___12(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___12(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___12(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___12[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___12[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___13(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___13(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___13[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___13[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___13  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___12(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___13  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___25  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___12(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___25) {
#line 70
      size___25 = i + 100;
#line 71
      if (members___13) {
        {
#line 72
        tmp = realloc((void *)members___13, (unsigned long )size___25 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___25 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___13) {
          {
#line 81
          free((void *)members___13);
          }
        }
#line 82
        members___13 = (char **)0;
#line 83
        size___25 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___13 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___13 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___13 + i) = (char *)0;
#line 99
  return (members___13);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___12  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___26  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___12[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___12  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___13(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 187 "../lib/prototypes.h"
extern void gr_free(struct group *grent ) ;
#line 284
extern int remove_tree(char const   *root , _Bool remove_root ) ;
#line 385
extern int user_busy(char const   *name , uid_t uid ) ;
#line 49 "../lib/pwio.h"
extern int pw_remove(char const   *name ) ;
#line 47 "../lib/shadowio.h"
extern int spw_remove(char const   *name ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_name___1  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_newname  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_pass___0  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static uid_t user_id___0  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static uid_t user_newid  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static gid_t user_gid___0  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static gid_t user_newgid  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_comment___0  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_newcomment  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_home___0  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_newhome  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_shell___0  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *user_newshell  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static long user_expire___0  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static long user_newexpire  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static long user_inactive  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static long user_newinactive  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static long sys_ngroups___0  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char **user_groups___0  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool aflg___1  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool cflg___0  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool dflg___2  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool eflg___2  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool fflg___0  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool gflg___0  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool Gflg___0  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool Lflg  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool lflg___2  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool mflg___2  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool oflg___0  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool pflg  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool sflg___3  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool uflg___1  =    (_Bool)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool Uflg___0  =    (_Bool)0;
#line 138 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool is_shadow_pwd___1  ;
#line 141 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool is_shadow_grp___2  ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool pw_locked___5  =    (_Bool)0;
#line 145 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool spw_locked___5  =    (_Bool)0;
#line 146 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool gr_locked___3  =    (_Bool)0;
#line 148 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static _Bool sgr_locked___3  =    (_Bool)0;
#line 153
static void date_to_str___0(char *buf___0 , size_t maxsize , long date ) ;
#line 155
static int get_groups___0(char *list___30 ) ;
#line 156
static void usage___11(int status ) ;
#line 157
static void new_pwent___0(struct passwd *pwent___0 ) ;
#line 158
static void new_spent___0(struct spwd *spent ) ;
#line 159
static void fail_exit___7(int code ) ;
#line 160
static void update_group___0(void) ;
#line 163
static void update_gshadow(void) ;
#line 165
static void grp_update___0(void) ;
#line 167
static void process_flags___9(int argc , char **argv ) ;
#line 168
static void close_files___6(void) ;
#line 169
static void open_files___6(void) ;
#line 170
static void usr_update___0(void) ;
#line 171
static void move_home(void) ;
#line 172
static void update_lastlog(void) ;
#line 173
static void update_faillog(void) ;
#line 176
static void move_mailbox(void) ;
#line 179 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void date_to_str___0(char *buf___0 , size_t maxsize , long date ) 
{ 
  struct tm *tp ;
  time_t t ;

  {
#line 184
  if (date < 0L) {
    {
#line 185
    strncpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"never",
            maxsize);
    }
  } else {
    {
#line 187
    t = date;
#line 188
    tp = gmtime((time_t const   *)(& t));
#line 190
    strftime((char */* __restrict  */)buf___0, maxsize, (char const   */* __restrict  */)"%Y-%m-%d",
             (struct tm  const  */* __restrict  */)tp);
    }
  }
#line 198
  *(buf___0 + (maxsize - 1UL)) = (char )'\000';
#line 199
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static int get_groups___0(char *list___30 ) 
{ 
  char *cp ;
  struct group  const  *grp ;
  int errors___0 ;
  int ngroups___0 ;
  struct group *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 212
  errors___0 = 0;
#line 213
  ngroups___0 = 0;
#line 218
  *(user_groups___0 + 0) = (char *)0;
#line 220
  if (0 == (int )*list___30) {
#line 221
    return (0);
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    cp = strchr((char const   *)list___30, ',');
    }
#line 234
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 235
      *cp = (char )'\000';
#line 236
      cp ++;
    }
    {
#line 243
    tmp = getgr_nam_gid((char const   *)list___30);
#line 243
    grp = (struct group  const  *)tmp;
    }
#line 249
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
      {
#line 250
      tmp___0 = gettext("%s: group \'%s\' does not exist\n");
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, list___30);
#line 252
      errors___0 ++;
      }
    }
#line 254
    list___30 = cp;
#line 260
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
#line 261
      goto __Cont;
    }
#line 278
    if ((long )ngroups___0 == sys_ngroups___0) {
      {
#line 279
      tmp___1 = gettext("%s: too many groups specified (max %d).\n");
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, ngroups___0);
#line 282
      gr_free((struct group *)grp);
      }
#line 283
      goto while_break;
    }
    {
#line 289
    tmp___2 = ngroups___0;
#line 289
    ngroups___0 ++;
#line 289
    *(user_groups___0 + tmp___2) = xstrdup((char const   *)grp->gr_name);
#line 290
    gr_free((struct group *)grp);
    }
    __Cont: /* CIL Label */ 
#line 229
    if (! ((unsigned long )((void *)0) != (unsigned long )list___30)) {
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  *(user_groups___0 + ngroups___0) = (char *)0;
#line 298
  if (0 != errors___0) {
#line 299
    return (-1);
  }
#line 302
  return (0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void usage___11(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 310
  if (0 != status) {
#line 310
    tmp = stderr;
  } else {
#line 310
    tmp = stdout;
  }
  {
#line 310
  usageout = tmp;
#line 311
  tmp___0 = gettext("Usage: %s [options] LOGIN\n\nOptions:\n");
#line 311
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 316
  tmp___1 = gettext("  -c, --comment COMMENT         new value of the GECOS field\n");
#line 316
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 317
  tmp___2 = gettext("  -d, --home HOME_DIR           new home directory for the user account\n");
#line 317
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 318
  tmp___3 = gettext("  -e, --expiredate EXPIRE_DATE  set account expiration date to EXPIRE_DATE\n");
#line 318
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 319
  tmp___4 = gettext("  -f, --inactive INACTIVE       set password inactive after expiration\n                                to INACTIVE\n");
#line 319
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 321
  tmp___5 = gettext("  -g, --gid GROUP               force use GROUP as new primary group\n");
#line 321
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 322
  tmp___6 = gettext("  -G, --groups GROUPS           new list of supplementary GROUPS\n");
#line 322
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 323
  tmp___7 = gettext("  -a, --append                  append the user to the supplemental GROUPS\n                                mentioned by the -G option without removing\n                                him/her from other groups\n");
#line 323
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 326
  tmp___8 = gettext("  -h, --help                    display this help message and exit\n");
#line 326
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 327
  tmp___9 = gettext("  -l, --login NEW_LOGIN         new value of the login name\n");
#line 327
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)usageout);
#line 328
  tmp___10 = gettext("  -L, --lock                    lock the user account\n");
#line 328
  fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)usageout);
#line 329
  tmp___11 = gettext("  -m, --move-home               move contents of the home directory to the\n                                new location (use only with -d)\n");
#line 329
  fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)usageout);
#line 331
  tmp___12 = gettext("  -o, --non-unique              allow using duplicate (non-unique) UID\n");
#line 331
  fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)usageout);
#line 332
  tmp___13 = gettext("  -p, --password PASSWORD       use encrypted password for the new password\n");
#line 332
  fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)usageout);
#line 333
  tmp___14 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 333
  fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)usageout);
#line 334
  tmp___15 = gettext("  -s, --shell SHELL             new login shell for the user account\n");
#line 334
  fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)usageout);
#line 335
  tmp___16 = gettext("  -u, --uid UID                 new UID for the user account\n");
#line 335
  fputs((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)usageout);
#line 336
  tmp___17 = gettext("  -U, --unlock                  unlock the user account\n");
#line 336
  fputs((char const   */* __restrict  */)tmp___17, (FILE */* __restrict  */)usageout);
#line 340
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 341
  exit(status);
  }
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static char *new_pw_passwd(char *pw_pass ) 
{ 
  char *buf___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char *s ;
  char *tmp___2 ;
  char *old_locale___0 ;
  char *tmp___3 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___4 ;
  char *saved_locale___1 ;

  {
#line 350
  if (Lflg) {
#line 350
    if (33 != (int )*(pw_pass + 0)) {
      {
#line 351
      tmp = strlen((char const   *)pw_pass);
#line 351
      tmp___0 = xmalloc(tmp + 2UL);
#line 351
      buf___0 = tmp___0;
      }
      {
#line 358
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 358
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 358
        old_locale = tmp___1;
#line 358
        saved_locale = (char *)((void *)0);
        }
#line 358
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 358
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 358
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 358
          setlocale(6, "C");
          }
        }
        {
#line 358
        syslog(6, "lock user \'%s\' password", user_newname);
        }
#line 358
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 358
          setlocale(6, (char const   *)saved_locale);
#line 358
          free((void *)saved_locale);
          }
        }
#line 358
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 359
      strcpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"!");
#line 360
      strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)pw_pass);
#line 361
      pw_pass = buf___0;
      }
    } else {
#line 350
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 362
  if (Uflg___0) {
#line 362
    if ((int )*(pw_pass + 0) == 33) {
#line 365
      if ((int )*(pw_pass + 1) == 0) {
        {
#line 366
        tmp___2 = gettext("%s: unlocking the user\'s password would result in a passwordless account.\nYou should set a password with usermod -p to unlock this user\'s password.\n");
#line 366
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                Prog);
        }
#line 370
        return (pw_pass);
      }
      {
#line 378
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 378
        tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 378
        old_locale___0 = tmp___3;
#line 378
        saved_locale___0 = (char *)((void *)0);
        }
#line 378
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 378
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 378
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 378
          setlocale(6, "C");
          }
        }
        {
#line 378
        syslog(6, "unlock user \'%s\' password", user_newname);
        }
#line 378
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 378
          setlocale(6, (char const   *)saved_locale___0);
#line 378
          free((void *)saved_locale___0);
          }
        }
#line 378
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 379
      s = pw_pass;
      {
#line 380
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 380
        if (! (0 != (int )*s)) {
#line 380
          goto while_break___1;
        }
#line 381
        *s = *(s + 1);
#line 382
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 362
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 384
  if (pflg) {
    {
#line 390
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 390
      tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 390
      old_locale___1 = tmp___4;
#line 390
      saved_locale___1 = (char *)((void *)0);
      }
#line 390
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 390
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 390
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 390
        setlocale(6, "C");
        }
      }
      {
#line 390
      syslog(6, "change user \'%s\' password", user_newname);
      }
#line 390
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 390
        setlocale(6, (char const   *)saved_locale___1);
#line 390
        free((void *)saved_locale___1);
        }
      }
#line 390
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 391
    pw_pass = xstrdup((char const   *)user_pass___0);
    }
  }
#line 393
  return (pw_pass);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void new_pwent___0(struct passwd *pwent___0 ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  struct passwd  const  *tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  int tmp___3 ;
  char *old_locale___0 ;
  char *tmp___4 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___5 ;
  char *saved_locale___1 ;
  char *old_locale___2 ;
  char *tmp___6 ;
  char *saved_locale___2 ;
  char *old_locale___3 ;
  char *tmp___7 ;
  char *saved_locale___3 ;

  {
#line 404
  if (lflg___2) {
    {
#line 405
    tmp___1 = pw_locate((char const   *)user_newname);
    }
#line 405
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 410
      tmp = pw_dbname();
#line 410
      tmp___0 = gettext("%s: user \'%s\' already exists in %s\n");
#line 410
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, user_newname, tmp);
#line 413
      fail_exit___7(9);
      }
    }
    {
#line 420
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 420
      tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 420
      old_locale = tmp___2;
#line 420
      saved_locale = (char *)((void *)0);
      }
#line 420
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 420
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 420
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 420
        setlocale(6, "C");
        }
      }
      {
#line 420
      syslog(6, "change user name \'%s\' to \'%s\'", pwent___0->pw_name, user_newname);
      }
#line 420
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 420
        setlocale(6, (char const   *)saved_locale);
#line 420
        free((void *)saved_locale);
        }
      }
#line 420
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 423
    pwent___0->pw_name = xstrdup((char const   *)user_newname);
    }
  }
#line 430
  if (! is_shadow_pwd___1) {
    {
#line 432
    pwent___0->pw_passwd = new_pw_passwd(pwent___0->pw_passwd);
    }
  } else {
    {
#line 430
    tmp___3 = strcmp((char const   *)pwent___0->pw_passwd, "x");
    }
#line 430
    if (tmp___3 != 0) {
      {
#line 432
      pwent___0->pw_passwd = new_pw_passwd(pwent___0->pw_passwd);
      }
    }
  }
#line 435
  if (uflg___1) {
    {
#line 441
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 441
      tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 441
      old_locale___0 = tmp___4;
#line 441
      saved_locale___0 = (char *)((void *)0);
      }
#line 441
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 441
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 441
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 441
        setlocale(6, "C");
        }
      }
      {
#line 441
      syslog(6, "change user \'%s\' UID from \'%d\' to \'%d\'", pwent___0->pw_name,
             pwent___0->pw_uid, user_newid);
      }
#line 441
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 441
        setlocale(6, (char const   *)saved_locale___0);
#line 441
        free((void *)saved_locale___0);
        }
      }
#line 441
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 444
    pwent___0->pw_uid = user_newid;
  }
#line 446
  if (gflg___0) {
    {
#line 452
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 452
      tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 452
      old_locale___1 = tmp___5;
#line 452
      saved_locale___1 = (char *)((void *)0);
      }
#line 452
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 452
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 452
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 452
        setlocale(6, "C");
        }
      }
      {
#line 452
      syslog(6, "change user \'%s\' GID from \'%d\' to \'%d\'", pwent___0->pw_name,
             pwent___0->pw_gid, user_newgid);
      }
#line 452
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 452
        setlocale(6, (char const   *)saved_locale___1);
#line 452
        free((void *)saved_locale___1);
        }
      }
#line 452
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 455
    pwent___0->pw_gid = user_newgid;
  }
#line 457
  if (cflg___0) {
#line 463
    pwent___0->pw_gecos = user_newcomment;
  }
#line 466
  if (dflg___2) {
    {
#line 472
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 472
      tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 472
      old_locale___2 = tmp___6;
#line 472
      saved_locale___2 = (char *)((void *)0);
      }
#line 472
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 472
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 472
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 472
        setlocale(6, "C");
        }
      }
      {
#line 472
      syslog(6, "change user \'%s\' home from \'%s\' to \'%s\'", pwent___0->pw_name,
             pwent___0->pw_dir, user_newhome);
      }
#line 472
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 472
        setlocale(6, (char const   *)saved_locale___2);
#line 472
        free((void *)saved_locale___2);
        }
      }
#line 472
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 475
    pwent___0->pw_dir = user_newhome;
  }
#line 477
  if (sflg___3) {
    {
#line 483
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 483
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 483
      old_locale___3 = tmp___7;
#line 483
      saved_locale___3 = (char *)((void *)0);
      }
#line 483
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
        {
#line 483
        saved_locale___3 = strdup((char const   *)old_locale___3);
        }
      }
#line 483
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
        {
#line 483
        setlocale(6, "C");
        }
      }
      {
#line 483
      syslog(6, "change user \'%s\' shell from \'%s\' to \'%s\'", pwent___0->pw_name,
             pwent___0->pw_shell, user_newshell);
      }
#line 483
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
        {
#line 483
        setlocale(6, (char const   *)saved_locale___3);
#line 483
        free((void *)saved_locale___3);
        }
      }
#line 483
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 486
    pwent___0->pw_shell = user_newshell;
  }
#line 488
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void new_spent___0(struct spwd *spent ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  struct spwd  const  *tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  char new_exp[16] ;
  char old_exp[16] ;
  char *old_locale___0 ;
  char *tmp___3 ;
  char *saved_locale___0 ;
  time_t tmp___4 ;

  {
#line 498
  if (lflg___2) {
    {
#line 499
    tmp___1 = spw_locate((char const   *)user_newname);
    }
#line 499
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 500
      tmp = spw_dbname();
#line 500
      tmp___0 = gettext("%s: user \'%s\' already exists in %s\n");
#line 500
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, user_newname, tmp);
#line 503
      fail_exit___7(9);
      }
    }
    {
#line 505
    spent->sp_namp = xstrdup((char const   *)user_newname);
    }
  }
#line 508
  if (fflg___0) {
    {
#line 514
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 514
      tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 514
      old_locale = tmp___2;
#line 514
      saved_locale = (char *)((void *)0);
      }
#line 514
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 514
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 514
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 514
        setlocale(6, "C");
        }
      }
      {
#line 514
      syslog(6, "change user \'%s\' inactive from \'%ld\' to \'%ld\'", spent->sp_namp,
             spent->sp_inact, user_newinactive);
      }
#line 514
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 514
        setlocale(6, (char const   *)saved_locale);
#line 514
        free((void *)saved_locale);
        }
      }
#line 514
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 517
    spent->sp_inact = user_newinactive;
  }
#line 519
  if (eflg___2) {
    {
#line 522
    date_to_str___0(new_exp, sizeof(new_exp), user_newexpire * 86400L);
#line 524
    date_to_str___0(old_exp, sizeof(old_exp), user_expire___0 * 86400L);
    }
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 531
      tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 531
      old_locale___0 = tmp___3;
#line 531
      saved_locale___0 = (char *)((void *)0);
      }
#line 531
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 531
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 531
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 531
        setlocale(6, "C");
        }
      }
      {
#line 531
      syslog(6, "change user \'%s\' expiration from \'%s\' to \'%s\'", spent->sp_namp,
             old_exp, new_exp);
      }
#line 531
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 531
        setlocale(6, (char const   *)saved_locale___0);
#line 531
        free((void *)saved_locale___0);
        }
      }
#line 531
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 534
    spent->sp_expire = user_newexpire;
  }
  {
#line 546
  spent->sp_pwdp = new_pw_passwd(spent->sp_pwdp);
  }
#line 548
  if (pflg) {
    {
#line 549
    tmp___4 = time((time_t *)0);
#line 549
    spent->sp_lstchg = tmp___4 / 86400L;
    }
#line 550
    if (0L == spent->sp_lstchg) {
#line 553
      spent->sp_lstchg = -1L;
    }
  }
#line 556
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void fail_exit___7(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 563
  if (gr_locked___3) {
    {
#line 564
    tmp___3 = gr_unlock();
    }
#line 564
    if (tmp___3 == 0) {
      {
#line 565
      tmp = gr_dbname();
#line 565
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 566
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 566
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 566
        old_locale = tmp___1;
#line 566
        saved_locale = (char *)((void *)0);
        }
#line 566
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 566
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 566
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 566
          setlocale(6, "C");
          }
        }
        {
#line 566
        tmp___2 = gr_dbname();
#line 566
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 566
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 566
          setlocale(6, (char const   *)saved_locale);
#line 566
          free((void *)saved_locale);
          }
        }
#line 566
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 571
  if (sgr_locked___3) {
    {
#line 572
    tmp___8 = sgr_unlock();
    }
#line 572
    if (tmp___8 == 0) {
      {
#line 573
      tmp___4 = sgr_dbname();
#line 573
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 573
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 574
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 574
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 574
        old_locale___0 = tmp___6;
#line 574
        saved_locale___0 = (char *)((void *)0);
        }
#line 574
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 574
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 574
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 574
          setlocale(6, "C");
          }
        }
        {
#line 574
        tmp___7 = sgr_dbname();
#line 574
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 574
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 574
          setlocale(6, (char const   *)saved_locale___0);
#line 574
          free((void *)saved_locale___0);
          }
        }
#line 574
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 579
  if (spw_locked___5) {
    {
#line 580
    tmp___13 = spw_unlock();
    }
#line 580
    if (tmp___13 == 0) {
      {
#line 581
      tmp___9 = spw_dbname();
#line 581
      tmp___10 = gettext("%s: failed to unlock %s\n");
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 582
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 582
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 582
        old_locale___1 = tmp___11;
#line 582
        saved_locale___1 = (char *)((void *)0);
        }
#line 582
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 582
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 582
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 582
          setlocale(6, "C");
          }
        }
        {
#line 582
        tmp___12 = spw_dbname();
#line 582
        syslog(3, "failed to unlock %s", tmp___12);
        }
#line 582
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 582
          setlocale(6, (char const   *)saved_locale___1);
#line 582
          free((void *)saved_locale___1);
          }
        }
#line 582
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 586
  if (pw_locked___5) {
    {
#line 587
    tmp___18 = pw_unlock();
    }
#line 587
    if (tmp___18 == 0) {
      {
#line 588
      tmp___14 = pw_dbname();
#line 588
      tmp___15 = gettext("%s: failed to unlock %s\n");
#line 588
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
      }
      {
#line 589
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 589
        tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 589
        old_locale___2 = tmp___16;
#line 589
        saved_locale___2 = (char *)((void *)0);
        }
#line 589
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 589
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 589
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 589
          setlocale(6, "C");
          }
        }
        {
#line 589
        tmp___17 = pw_dbname();
#line 589
        syslog(3, "failed to unlock %s", tmp___17);
        }
#line 589
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 589
          setlocale(6, (char const   *)saved_locale___2);
#line 589
          free((void *)saved_locale___2);
          }
        }
#line 589
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 599
  exit(code);
  }
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void update_group___0(void) 
{ 
  _Bool is_member ;
  _Bool was_member ;
  _Bool changed ;
  struct group  const  *grp ;
  struct group *ngrp ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  char *old_locale___0 ;
  char *tmp___4 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___5 ;
  char *saved_locale___1 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *old_locale___2 ;
  char *tmp___8 ;
  char *saved_locale___2 ;
  char const   *tmp___9 ;
  int tmp___10 ;

  {
#line 611
  changed = (_Bool)0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 617
    grp = gr_next();
    }
#line 617
    if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 617
      goto while_break;
    }
    {
#line 622
    was_member = is_on_list((char * const  *)grp->gr_mem, (char const   *)user_name___1);
    }
#line 623
    if (Gflg___0) {
#line 623
      if (was_member) {
#line 623
        if (aflg___1) {
#line 623
          tmp___0 = 1;
        } else {
#line 623
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 623
        tmp = is_on_list((char * const  *)user_groups___0, (char const   *)grp->gr_name);
        }
#line 623
        if (tmp) {
#line 623
          tmp___0 = 1;
        } else {
#line 623
          tmp___0 = 0;
        }
      }
    } else {
#line 623
      tmp___0 = 0;
    }
#line 623
    is_member = (_Bool )tmp___0;
#line 626
    if (! was_member) {
#line 626
      if (! is_member) {
#line 627
        goto while_continue;
      }
    }
    {
#line 630
    ngrp = __gr_dup(grp);
    }
#line 631
    if ((unsigned long )((void *)0) == (unsigned long )ngrp) {
      {
#line 632
      tmp___1 = gr_dbname();
#line 632
      tmp___2 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 632
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, tmp___1);
#line 635
      fail_exit___7(10);
      }
    }
#line 638
    if (was_member) {
#line 639
      if (! Gflg___0) {
#line 639
        goto _L___0;
      } else
#line 639
      if (is_member) {
        _L___0: /* CIL Label */ 
#line 644
        if (lflg___2) {
          {
#line 645
          ngrp->gr_mem = del_list(ngrp->gr_mem, (char const   *)user_name___1);
#line 647
          ngrp->gr_mem = add_list(ngrp->gr_mem, (char const   *)user_newname);
#line 649
          changed = (_Bool)1;
          }
          {
#line 655
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 655
            tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 655
            old_locale = tmp___3;
#line 655
            saved_locale = (char *)((void *)0);
            }
#line 655
            if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
              {
#line 655
              saved_locale = strdup((char const   *)old_locale);
              }
            }
#line 655
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
              {
#line 655
              setlocale(6, "C");
              }
            }
            {
#line 655
            syslog(6, "change \'%s\' to \'%s\' in group \'%s\'", user_name___1, user_newname,
                   ngrp->gr_name);
            }
#line 655
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
              {
#line 655
              setlocale(6, (char const   *)saved_locale);
#line 655
              free((void *)saved_locale);
              }
            }
#line 655
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 664
        ngrp->gr_mem = del_list(ngrp->gr_mem, (char const   *)user_name___1);
#line 665
        changed = (_Bool)1;
        }
        {
#line 671
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 671
          tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 671
          old_locale___0 = tmp___4;
#line 671
          saved_locale___0 = (char *)((void *)0);
          }
#line 671
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
            {
#line 671
            saved_locale___0 = strdup((char const   *)old_locale___0);
            }
          }
#line 671
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 671
            setlocale(6, "C");
            }
          }
          {
#line 671
          syslog(6, "delete \'%s\' from group \'%s\'", user_name___1, ngrp->gr_name);
          }
#line 671
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 671
            setlocale(6, (char const   *)saved_locale___0);
#line 671
            free((void *)saved_locale___0);
            }
          }
#line 671
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 679
      ngrp->gr_mem = add_list(ngrp->gr_mem, (char const   *)user_newname);
#line 680
      changed = (_Bool)1;
      }
      {
#line 686
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 686
        tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 686
        old_locale___1 = tmp___5;
#line 686
        saved_locale___1 = (char *)((void *)0);
        }
#line 686
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 686
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 686
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 686
          setlocale(6, "C");
          }
        }
        {
#line 686
        syslog(6, "add \'%s\' to group \'%s\'", user_newname, ngrp->gr_name);
        }
#line 686
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 686
          setlocale(6, (char const   *)saved_locale___1);
#line 686
          free((void *)saved_locale___1);
          }
        }
#line 686
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 689
    if (! changed) {
#line 690
      goto while_continue;
    }
    {
#line 693
    changed = (_Bool)0;
#line 694
    tmp___10 = gr_update((struct group  const  *)ngrp);
    }
#line 694
    if (tmp___10 == 0) {
      {
#line 695
      tmp___6 = gr_dbname();
#line 695
      tmp___7 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 695
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              Prog, tmp___6, ngrp->gr_name);
      }
      {
#line 698
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 698
        tmp___8 = setlocale(6, (char const   *)((void *)0));
#line 698
        old_locale___2 = tmp___8;
#line 698
        saved_locale___2 = (char *)((void *)0);
        }
#line 698
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 698
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 698
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 698
          setlocale(6, "C");
          }
        }
        {
#line 698
        tmp___9 = gr_dbname();
#line 698
        syslog(4, "failed to prepare the new %s entry \'%s\'", tmp___9, ngrp->gr_name);
        }
#line 698
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 698
          setlocale(6, (char const   *)saved_locale___2);
#line 698
          free((void *)saved_locale___2);
          }
        }
#line 698
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 699
      fail_exit___7(10);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  return;
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void update_gshadow(void) 
{ 
  _Bool is_member ;
  _Bool was_member ;
  _Bool was_admin ;
  _Bool changed ;
  struct sgrp  const  *sgrp ;
  struct sgrp *nsgrp ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  char *old_locale___0 ;
  char *tmp___4 ;
  char *saved_locale___0 ;
  char *old_locale___1 ;
  char *tmp___5 ;
  char *saved_locale___1 ;
  char *old_locale___2 ;
  char *tmp___6 ;
  char *saved_locale___2 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *old_locale___3 ;
  char *tmp___9 ;
  char *saved_locale___3 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
#line 714
  changed = (_Bool)0;
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 720
    sgrp = sgr_next();
    }
#line 720
    if (! ((unsigned long )sgrp != (unsigned long )((void *)0))) {
#line 720
      goto while_break;
    }
    {
#line 725
    was_member = is_on_list((char * const  *)sgrp->sg_mem, (char const   *)user_name___1);
#line 730
    was_admin = is_on_list((char * const  *)sgrp->sg_adm, (char const   *)user_name___1);
    }
#line 736
    if (Gflg___0) {
#line 736
      if (was_member) {
#line 736
        if (aflg___1) {
#line 736
          tmp___0 = 1;
        } else {
#line 736
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 736
        tmp = is_on_list((char * const  *)user_groups___0, (char const   *)sgrp->sg_name);
        }
#line 736
        if (tmp) {
#line 736
          tmp___0 = 1;
        } else {
#line 736
          tmp___0 = 0;
        }
      }
    } else {
#line 736
      tmp___0 = 0;
    }
#line 736
    is_member = (_Bool )tmp___0;
#line 739
    if (! was_member) {
#line 739
      if (! was_admin) {
#line 739
        if (! is_member) {
#line 740
          goto while_continue;
        }
      }
    }
    {
#line 743
    nsgrp = __sgr_dup(sgrp);
    }
#line 744
    if ((unsigned long )((void *)0) == (unsigned long )nsgrp) {
      {
#line 745
      tmp___1 = sgr_dbname();
#line 745
      tmp___2 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 745
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, tmp___1);
#line 748
      fail_exit___7(10);
      }
    }
#line 751
    if (was_admin) {
#line 751
      if (lflg___2) {
        {
#line 755
        nsgrp->sg_adm = del_list(nsgrp->sg_adm, (char const   *)user_name___1);
#line 756
        nsgrp->sg_adm = add_list(nsgrp->sg_adm, (char const   *)user_newname);
#line 757
        changed = (_Bool)1;
        }
        {
#line 763
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 763
          tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 763
          old_locale = tmp___3;
#line 763
          saved_locale = (char *)((void *)0);
          }
#line 763
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 763
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 763
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 763
            setlocale(6, "C");
            }
          }
          {
#line 763
          syslog(6, "change admin \'%s\' to \'%s\' in shadow group \'%s\'", user_name___1,
                 user_newname, nsgrp->sg_name);
          }
#line 763
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 763
            setlocale(6, (char const   *)saved_locale);
#line 763
            free((void *)saved_locale);
            }
          }
#line 763
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 768
    if (was_member) {
#line 769
      if (! Gflg___0) {
#line 769
        goto _L___0;
      } else
#line 769
      if (is_member) {
        _L___0: /* CIL Label */ 
#line 774
        if (lflg___2) {
          {
#line 775
          nsgrp->sg_mem = del_list(nsgrp->sg_mem, (char const   *)user_name___1);
#line 777
          nsgrp->sg_mem = add_list(nsgrp->sg_mem, (char const   *)user_newname);
#line 779
          changed = (_Bool)1;
          }
          {
#line 785
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 785
            tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 785
            old_locale___0 = tmp___4;
#line 785
            saved_locale___0 = (char *)((void *)0);
            }
#line 785
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
              {
#line 785
              saved_locale___0 = strdup((char const   *)old_locale___0);
              }
            }
#line 785
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 785
              setlocale(6, "C");
              }
            }
            {
#line 785
            syslog(6, "change \'%s\' to \'%s\' in shadow group \'%s\'", user_name___1,
                   user_newname, nsgrp->sg_name);
            }
#line 785
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 785
              setlocale(6, (char const   *)saved_locale___0);
#line 785
              free((void *)saved_locale___0);
              }
            }
#line 785
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 794
        nsgrp->sg_mem = del_list(nsgrp->sg_mem, (char const   *)user_name___1);
#line 795
        changed = (_Bool)1;
        }
        {
#line 801
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 801
          tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 801
          old_locale___1 = tmp___5;
#line 801
          saved_locale___1 = (char *)((void *)0);
          }
#line 801
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
            {
#line 801
            saved_locale___1 = strdup((char const   *)old_locale___1);
            }
          }
#line 801
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
            {
#line 801
            setlocale(6, "C");
            }
          }
          {
#line 801
          syslog(6, "delete \'%s\' from shadow group \'%s\'", user_name___1, nsgrp->sg_name);
          }
#line 801
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
            {
#line 801
            setlocale(6, (char const   *)saved_locale___1);
#line 801
            free((void *)saved_locale___1);
            }
          }
#line 801
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else
#line 805
    if (is_member) {
      {
#line 809
      nsgrp->sg_mem = add_list(nsgrp->sg_mem, (char const   *)user_newname);
#line 810
      changed = (_Bool)1;
      }
      {
#line 816
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 816
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 816
        old_locale___2 = tmp___6;
#line 816
        saved_locale___2 = (char *)((void *)0);
        }
#line 816
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 816
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 816
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 816
          setlocale(6, "C");
          }
        }
        {
#line 816
        syslog(6, "add \'%s\' to shadow group \'%s\'", user_newname, nsgrp->sg_name);
        }
#line 816
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 816
          setlocale(6, (char const   *)saved_locale___2);
#line 816
          free((void *)saved_locale___2);
          }
        }
#line 816
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 819
    if (! changed) {
#line 820
      goto while_continue;
    }
    {
#line 823
    changed = (_Bool)0;
#line 828
    tmp___11 = sgr_update((struct sgrp  const  *)nsgrp);
    }
#line 828
    if (tmp___11 == 0) {
      {
#line 829
      tmp___7 = sgr_dbname();
#line 829
      tmp___8 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 829
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7, nsgrp->sg_name);
      }
      {
#line 832
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 832
        tmp___9 = setlocale(6, (char const   *)((void *)0));
#line 832
        old_locale___3 = tmp___9;
#line 832
        saved_locale___3 = (char *)((void *)0);
        }
#line 832
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
          {
#line 832
          saved_locale___3 = strdup((char const   *)old_locale___3);
          }
        }
#line 832
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 832
          setlocale(6, "C");
          }
        }
        {
#line 832
        tmp___10 = sgr_dbname();
#line 832
        syslog(4, "failed to prepare the new %s entry \'%s\'", tmp___10, nsgrp->sg_name);
        }
#line 832
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
          {
#line 832
          setlocale(6, (char const   *)saved_locale___3);
#line 832
          free((void *)saved_locale___3);
          }
        }
#line 832
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 834
      fail_exit___7(10);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 837
  return;
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void grp_update___0(void) 
{ 


  {
  {
#line 848
  update_group___0();
  }
#line 850
  if (is_shadow_grp___2) {
    {
#line 851
    update_gshadow();
    }
  }
#line 854
  return;
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static struct option long_options___10[18]  = 
#line 874
  {      {"append", 0, (int *)((void *)0), 'a'}, 
        {"comment", 1, (int *)((void *)0), 'c'}, 
        {"home", 1, (int *)((void *)0), 'd'}, 
        {"expiredate", 1, (int *)((void *)0), 'e'}, 
        {"inactive", 1, (int *)((void *)0), 'f'}, 
        {"gid", 1, (int *)((void *)0), 'g'}, 
        {"groups", 1, (int *)((void *)0), 'G'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"login", 1, (int *)((void *)0), 'l'}, 
        {"lock", 0, (int *)((void *)0), 'L'}, 
        {"move-home", 0, (int *)((void *)0), 'm'}, 
        {"non-unique", 0, (int *)((void *)0), 'o'}, 
        {"password", 1, (int *)((void *)0), 'p'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"shell", 1, (int *)((void *)0), 's'}, 
        {"uid", 1, (int *)((void *)0), 'u'}, 
        {"unlock", 0, (int *)((void *)0), 'U'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 863 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void process_flags___9(int argc , char **argv ) 
{ 
  struct group  const  *grp ;
  _Bool anyflag___0 ;
  int c ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  struct group *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  _Bool tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  struct passwd  const  *pwd ;
  struct passwd *tmp___18 ;
  char *tmp___19 ;
  struct spwd  const  *spwd ;
  struct spwd *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  struct passwd *tmp___33 ;
  char *tmp___34 ;
  struct passwd *tmp___35 ;

  {
#line 867
  anyflag___0 = (_Bool)0;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 897
    c = getopt_long(argc, (char * const  *)argv, "ac:d:e:f:g:G:hl:Lmop:R:s:u:U", (struct option  const  *)(long_options___10),
                    (int *)((void *)0));
    }
#line 897
    if (! (c != -1)) {
#line 897
      goto while_break;
    }
    {
#line 905
    if (c == 97) {
#line 905
      goto case_97;
    }
#line 908
    if (c == 99) {
#line 908
      goto case_99;
    }
#line 918
    if (c == 100) {
#line 918
      goto case_100;
    }
#line 928
    if (c == 101) {
#line 928
      goto case_101;
    }
#line 943
    if (c == 102) {
#line 943
      goto case_102;
    }
#line 953
    if (c == 103) {
#line 953
      goto case_103;
    }
#line 964
    if (c == 71) {
#line 964
      goto case_71;
    }
#line 970
    if (c == 104) {
#line 970
      goto case_104;
    }
#line 973
    if (c == 108) {
#line 973
      goto case_108;
    }
#line 983
    if (c == 76) {
#line 983
      goto case_76;
    }
#line 986
    if (c == 109) {
#line 986
      goto case_109;
    }
#line 989
    if (c == 111) {
#line 989
      goto case_111;
    }
#line 992
    if (c == 112) {
#line 992
      goto case_112;
    }
#line 996
    if (c == 82) {
#line 996
      goto case_82;
    }
#line 998
    if (c == 115) {
#line 998
      goto case_115;
    }
#line 1008
    if (c == 117) {
#line 1008
      goto case_117;
    }
#line 1018
    if (c == 85) {
#line 1018
      goto case_85;
    }
#line 1034
    goto switch_default;
    case_97: /* CIL Label */ 
#line 906
    aflg___1 = (_Bool)1;
#line 907
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 909
    tmp___0 = strcspn((char const   *)optarg, ":\n");
#line 909
    tmp___1 = strlen((char const   *)optarg);
    }
#line 909
    if (! (tmp___0 == tmp___1)) {
      {
#line 910
      tmp = gettext("%s: invalid field \'%s\'\n");
#line 910
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 913
      exit(3);
      }
    }
#line 915
    user_newcomment = optarg;
#line 916
    cflg___0 = (_Bool)1;
#line 917
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 919
    tmp___3 = strcspn((char const   *)optarg, ":\n");
#line 919
    tmp___4 = strlen((char const   *)optarg);
    }
#line 919
    if (! (tmp___3 == tmp___4)) {
      {
#line 920
      tmp___2 = gettext("%s: invalid field \'%s\'\n");
#line 920
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, optarg);
#line 923
      exit(3);
      }
    }
#line 925
    dflg___2 = (_Bool)1;
#line 926
    user_newhome = optarg;
#line 927
    goto switch_break;
    case_101: /* CIL Label */ 
#line 929
    if (0 != (int )*optarg) {
      {
#line 930
      user_newexpire = strtoday((char const   *)optarg);
      }
#line 931
      if (user_newexpire < -1L) {
        {
#line 932
        tmp___5 = gettext("%s: invalid date \'%s\'\n");
#line 932
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, optarg);
#line 935
        exit(3);
        }
      }
#line 937
      user_newexpire = user_newexpire;
    } else {
#line 939
      user_newexpire = -1L;
    }
#line 941
    eflg___2 = (_Bool)1;
#line 942
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 944
    tmp___7 = getlong((char const   *)optarg, & user_newinactive);
    }
#line 944
    if (tmp___7 == 0) {
      {
#line 946
      tmp___6 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 946
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, optarg);
#line 949
      exit(3);
      }
    } else
#line 944
    if (user_newinactive < -1L) {
      {
#line 946
      tmp___6 = gettext("%s: invalid numeric argument \'%s\'\n");
#line 946
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, optarg);
#line 949
      exit(3);
      }
    }
#line 951
    fflg___0 = (_Bool)1;
#line 952
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 954
    tmp___8 = getgr_nam_gid((char const   *)optarg);
#line 954
    grp = (struct group  const  *)tmp___8;
    }
#line 955
    if ((unsigned long )((void *)0) == (unsigned long )grp) {
      {
#line 956
      tmp___9 = gettext("%s: group \'%s\' does not exist\n");
#line 956
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, optarg);
#line 959
      exit(6);
      }
    }
#line 961
    user_newgid = (gid_t )grp->gr_gid;
#line 962
    gflg___0 = (_Bool)1;
#line 963
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 965
    tmp___10 = get_groups___0(optarg);
    }
#line 965
    if (tmp___10 != 0) {
      {
#line 966
      exit(6);
      }
    }
#line 968
    Gflg___0 = (_Bool)1;
#line 969
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 971
    usage___11(0);
    }
#line 972
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 974
    tmp___12 = is_valid_user_name((char const   *)optarg);
    }
#line 974
    if (! tmp___12) {
      {
#line 975
      tmp___11 = gettext("%s: invalid user name \'%s\'\n");
#line 975
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
              Prog, optarg);
#line 978
      exit(3);
      }
    }
#line 980
    lflg___2 = (_Bool)1;
#line 981
    user_newname = optarg;
#line 982
    goto switch_break;
    case_76: /* CIL Label */ 
#line 984
    Lflg = (_Bool)1;
#line 985
    goto switch_break;
    case_109: /* CIL Label */ 
#line 987
    mflg___2 = (_Bool)1;
#line 988
    goto switch_break;
    case_111: /* CIL Label */ 
#line 990
    oflg___0 = (_Bool)1;
#line 991
    goto switch_break;
    case_112: /* CIL Label */ 
#line 993
    user_pass___0 = optarg;
#line 994
    pflg = (_Bool)1;
#line 995
    goto switch_break;
    case_82: /* CIL Label */ 
#line 997
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 999
    tmp___14 = strcspn((char const   *)optarg, ":\n");
#line 999
    tmp___15 = strlen((char const   *)optarg);
    }
#line 999
    if (! (tmp___14 == tmp___15)) {
      {
#line 1000
      tmp___13 = gettext("%s: invalid field \'%s\'\n");
#line 1000
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
              Prog, optarg);
#line 1003
      exit(3);
      }
    }
#line 1005
    user_newshell = optarg;
#line 1006
    sflg___3 = (_Bool)1;
#line 1007
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 1009
    tmp___17 = get_uid((char const   *)optarg, & user_newid);
    }
#line 1009
    if (tmp___17 == 0) {
      {
#line 1011
      tmp___16 = gettext("%s: invalid user ID \'%s\'\n");
#line 1011
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
              Prog, optarg);
#line 1014
      exit(3);
      }
    } else
#line 1009
    if (user_newid == 4294967295U) {
      {
#line 1011
      tmp___16 = gettext("%s: invalid user ID \'%s\'\n");
#line 1011
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
              Prog, optarg);
#line 1014
      exit(3);
      }
    }
#line 1016
    uflg___1 = (_Bool)1;
#line 1017
    goto switch_break;
    case_85: /* CIL Label */ 
#line 1019
    Uflg___0 = (_Bool)1;
#line 1020
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1035
    usage___11(2);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1037
    anyflag___0 = (_Bool)1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  if (optind != argc - 1) {
    {
#line 1042
    usage___11(2);
    }
  }
  {
#line 1045
  user_name___1 = *(argv + (argc - 1));
#line 1050
  tmp___18 = getpwnam((char const   *)user_name___1);
#line 1050
  pwd = (struct passwd  const  *)tmp___18;
  }
#line 1051
  if ((unsigned long )((void *)0) == (unsigned long )pwd) {
    {
#line 1052
    tmp___19 = gettext("%s: user \'%s\' does not exist\n");
#line 1052
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
            Prog, user_name___1);
#line 1055
    exit(6);
    }
  }
  {
#line 1058
  user_id___0 = (uid_t )pwd->pw_uid;
#line 1059
  user_gid___0 = (gid_t )pwd->pw_gid;
#line 1060
  user_comment___0 = xstrdup((char const   *)pwd->pw_gecos);
#line 1061
  user_home___0 = xstrdup((char const   *)pwd->pw_dir);
#line 1062
  user_shell___0 = xstrdup((char const   *)pwd->pw_shell);
  }
#line 1067
  if (! lflg___2) {
#line 1068
    user_newname = user_name___1;
  }
#line 1070
  if (! uflg___1) {
#line 1071
    user_newid = user_id___0;
  }
#line 1073
  if (! gflg___0) {
#line 1074
    user_newgid = user_gid___0;
  }
#line 1100
  spwd = (struct spwd  const  *)((void *)0);
#line 1102
  if (is_shadow_pwd___1) {
    {
#line 1102
    tmp___20 = getspnam((char const   *)user_name___1);
#line 1102
    spwd = (struct spwd  const  *)tmp___20;
    }
#line 1102
    if ((unsigned long )spwd != (unsigned long )((void *)0)) {
#line 1103
      user_expire___0 = (long )spwd->sp_expire;
#line 1104
      user_inactive = (long )spwd->sp_inact;
    }
  }
#line 1108
  if (! anyflag___0) {
    {
#line 1109
    tmp___21 = gettext("%s: no options\n");
#line 1109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
            Prog);
#line 1110
    usage___11(2);
    }
  }
#line 1113
  if (aflg___1) {
#line 1113
    if (! Gflg___0) {
      {
#line 1114
      tmp___22 = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 1114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
              Prog, "-a", "-G");
#line 1117
      usage___11(2);
      }
    }
  }
#line 1120
  if (Lflg) {
#line 1120
    if (pflg) {
      {
#line 1121
      tmp___23 = gettext("%s: the -L, -p, and -U flags are exclusive\n");
#line 1121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
              Prog);
#line 1124
      usage___11(2);
      }
    } else
#line 1120
    if (Uflg___0) {
      {
#line 1121
      tmp___23 = gettext("%s: the -L, -p, and -U flags are exclusive\n");
#line 1121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
              Prog);
#line 1124
      usage___11(2);
      }
    } else {
#line 1120
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1120
  if (pflg) {
#line 1120
    if (Uflg___0) {
      {
#line 1121
      tmp___23 = gettext("%s: the -L, -p, and -U flags are exclusive\n");
#line 1121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
              Prog);
#line 1124
      usage___11(2);
      }
    }
  }
#line 1127
  if (oflg___0) {
#line 1127
    if (! uflg___1) {
      {
#line 1128
      tmp___24 = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 1128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              Prog, "-o", "-u");
#line 1131
      usage___11(2);
      }
    }
  }
#line 1134
  if (mflg___2) {
#line 1134
    if (! dflg___2) {
      {
#line 1135
      tmp___25 = gettext("%s: %s flag is only allowed with the %s flag\n");
#line 1135
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___25,
              Prog, "-m", "-d");
#line 1138
      usage___11(2);
      }
    }
  }
#line 1141
  if (user_newid == user_id___0) {
#line 1142
    uflg___1 = (_Bool)0;
#line 1143
    oflg___0 = (_Bool)0;
  }
#line 1145
  if (user_newgid == user_gid___0) {
#line 1146
    gflg___0 = (_Bool)0;
  }
#line 1148
  if ((unsigned long )((void *)0) != (unsigned long )user_newshell) {
    {
#line 1148
    tmp___26 = strcmp((char const   *)user_newshell, (char const   *)user_shell___0);
    }
#line 1148
    if (tmp___26 == 0) {
#line 1150
      sflg___3 = (_Bool)0;
    }
  }
  {
#line 1152
  tmp___27 = strcmp((char const   *)user_newname, (char const   *)user_name___1);
  }
#line 1152
  if (tmp___27 == 0) {
#line 1153
    lflg___2 = (_Bool)0;
  }
#line 1155
  if (user_newinactive == user_inactive) {
#line 1156
    fflg___0 = (_Bool)0;
  }
#line 1158
  if (user_newexpire == user_expire___0) {
#line 1159
    eflg___2 = (_Bool)0;
  }
#line 1161
  if ((unsigned long )((void *)0) != (unsigned long )user_newhome) {
    {
#line 1161
    tmp___28 = strcmp((char const   *)user_newhome, (char const   *)user_home___0);
    }
#line 1161
    if (tmp___28 == 0) {
#line 1163
      dflg___2 = (_Bool)0;
#line 1164
      mflg___2 = (_Bool)0;
    }
  }
#line 1166
  if ((unsigned long )((void *)0) != (unsigned long )user_newcomment) {
    {
#line 1166
    tmp___29 = strcmp((char const   *)user_newcomment, (char const   *)user_comment___0);
    }
#line 1166
    if (tmp___29 == 0) {
#line 1168
      cflg___0 = (_Bool)0;
    }
  }
#line 1171
  if (! Uflg___0) {
#line 1171
    if (! uflg___1) {
#line 1171
      if (! sflg___3) {
#line 1171
        if (! pflg) {
#line 1171
          if (! mflg___2) {
#line 1171
            if (! Lflg) {
#line 1171
              if (! lflg___2) {
#line 1171
                if (! Gflg___0) {
#line 1171
                  if (! gflg___0) {
#line 1171
                    if (! fflg___0) {
#line 1171
                      if (! eflg___2) {
#line 1171
                        if (! dflg___2) {
#line 1171
                          if (! cflg___0) {
                            {
#line 1177
                            tmp___30 = gettext("%s: no changes\n");
#line 1177
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
                                    Prog);
#line 1178
                            exit(0);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1181
  if (! is_shadow_pwd___1) {
#line 1181
    if (eflg___2) {
      {
#line 1182
      tmp___31 = gettext("%s: shadow passwords required for -e and -f\n");
#line 1182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___31,
              Prog);
#line 1185
      exit(2);
      }
    } else
#line 1181
    if (fflg___0) {
      {
#line 1182
      tmp___31 = gettext("%s: shadow passwords required for -e and -f\n");
#line 1182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___31,
              Prog);
#line 1185
      exit(2);
      }
    }
  }
#line 1189
  if (lflg___2) {
    {
#line 1189
    tmp___33 = getpwnam((char const   *)user_newname);
    }
#line 1189
    if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
      {
#line 1190
      tmp___32 = gettext("%s: user \'%s\' already exists\n");
#line 1190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___32,
              Prog, user_newname);
#line 1193
      exit(9);
      }
    }
  }
#line 1197
  if (uflg___1) {
#line 1197
    if (! oflg___0) {
      {
#line 1197
      tmp___35 = getpwuid(user_newid);
      }
#line 1197
      if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
        {
#line 1198
        tmp___34 = gettext("%s: UID \'%lu\' already exists\n");
#line 1198
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___34,
                Prog, (unsigned long )user_newid);
#line 1201
        exit(4);
        }
      }
    }
  }
#line 1203
  return;
}
}
#line 1211 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void close_files___6(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *old_locale___3 ;
  char *tmp___21 ;
  char *saved_locale___3 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char *old_locale___4 ;
  char *tmp___26 ;
  char *saved_locale___4 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char *old_locale___5 ;
  char *tmp___31 ;
  char *saved_locale___5 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  char *old_locale___6 ;
  char *tmp___36 ;
  char *saved_locale___6 ;
  char const   *tmp___37 ;
  int tmp___38 ;

  {
  {
#line 1213
  tmp___3 = pw_close();
  }
#line 1213
  if (tmp___3 == 0) {
    {
#line 1214
    tmp = pw_dbname();
#line 1214
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 1214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 1217
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1217
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 1217
      old_locale = tmp___1;
#line 1217
      saved_locale = (char *)((void *)0);
      }
#line 1217
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 1217
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 1217
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 1217
        setlocale(6, "C");
        }
      }
      {
#line 1217
      tmp___2 = pw_dbname();
#line 1217
      syslog(3, "failure while writing changes to %s", tmp___2);
      }
#line 1217
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 1217
        setlocale(6, (char const   *)saved_locale);
#line 1217
        free((void *)saved_locale);
        }
      }
#line 1217
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1218
    fail_exit___7(1);
    }
  }
#line 1220
  if (is_shadow_pwd___1) {
    {
#line 1220
    tmp___8 = spw_close();
    }
#line 1220
    if (tmp___8 == 0) {
      {
#line 1221
      tmp___4 = spw_dbname();
#line 1221
      tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 1221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 1224
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1224
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 1224
        old_locale___0 = tmp___6;
#line 1224
        saved_locale___0 = (char *)((void *)0);
        }
#line 1224
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 1224
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 1224
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 1224
          setlocale(6, "C");
          }
        }
        {
#line 1224
        tmp___7 = spw_dbname();
#line 1224
        syslog(3, "failure while writing changes to %s", tmp___7);
        }
#line 1224
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 1224
          setlocale(6, (char const   *)saved_locale___0);
#line 1224
          free((void *)saved_locale___0);
          }
        }
#line 1224
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1227
      fail_exit___7(1);
      }
    }
  }
#line 1230
  if (Gflg___0) {
#line 1230
    goto _L;
  } else
#line 1230
  if (lflg___2) {
    _L: /* CIL Label */ 
    {
#line 1231
    tmp___13 = gr_close();
    }
#line 1231
    if (tmp___13 == 0) {
      {
#line 1232
      tmp___9 = gr_dbname();
#line 1232
      tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 1232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 1235
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1235
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 1235
        old_locale___1 = tmp___11;
#line 1235
        saved_locale___1 = (char *)((void *)0);
        }
#line 1235
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 1235
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 1235
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 1235
          setlocale(6, "C");
          }
        }
        {
#line 1235
        tmp___12 = gr_dbname();
#line 1235
        syslog(3, "failure while writing changes to %s", tmp___12);
        }
#line 1235
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 1235
          setlocale(6, (char const   *)saved_locale___1);
#line 1235
          free((void *)saved_locale___1);
          }
        }
#line 1235
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1238
      fail_exit___7(10);
      }
    }
#line 1241
    if (is_shadow_grp___2) {
      {
#line 1242
      tmp___18 = sgr_close();
      }
#line 1242
      if (tmp___18 == 0) {
        {
#line 1243
        tmp___14 = sgr_dbname();
#line 1243
        tmp___15 = gettext("%s: failure while writing changes to %s\n");
#line 1243
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                Prog, tmp___14);
        }
        {
#line 1246
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1246
          tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 1246
          old_locale___2 = tmp___16;
#line 1246
          saved_locale___2 = (char *)((void *)0);
          }
#line 1246
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
            {
#line 1246
            saved_locale___2 = strdup((char const   *)old_locale___2);
            }
          }
#line 1246
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 1246
            setlocale(6, "C");
            }
          }
          {
#line 1246
          tmp___17 = sgr_dbname();
#line 1246
          syslog(3, "failure while writing changes to %s", tmp___17);
          }
#line 1246
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 1246
            setlocale(6, (char const   *)saved_locale___2);
#line 1246
            free((void *)saved_locale___2);
            }
          }
#line 1246
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1249
        fail_exit___7(10);
        }
      }
      {
#line 1251
      tmp___23 = sgr_unlock();
      }
#line 1251
      if (tmp___23 == 0) {
        {
#line 1252
        tmp___19 = sgr_dbname();
#line 1252
        tmp___20 = gettext("%s: failed to unlock %s\n");
#line 1252
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
                Prog, tmp___19);
        }
        {
#line 1255
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1255
          tmp___21 = setlocale(6, (char const   *)((void *)0));
#line 1255
          old_locale___3 = tmp___21;
#line 1255
          saved_locale___3 = (char *)((void *)0);
          }
#line 1255
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
            {
#line 1255
            saved_locale___3 = strdup((char const   *)old_locale___3);
            }
          }
#line 1255
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
            {
#line 1255
            setlocale(6, "C");
            }
          }
          {
#line 1255
          tmp___22 = sgr_dbname();
#line 1255
          syslog(3, "failed to unlock %s", tmp___22);
          }
#line 1255
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
            {
#line 1255
            setlocale(6, (char const   *)saved_locale___3);
#line 1255
            free((void *)saved_locale___3);
            }
          }
#line 1255
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    {
#line 1262
    tmp___28 = gr_unlock();
    }
#line 1262
    if (tmp___28 == 0) {
      {
#line 1263
      tmp___24 = gr_dbname();
#line 1263
      tmp___25 = gettext("%s: failed to unlock %s\n");
#line 1263
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___25,
              Prog, tmp___24);
      }
      {
#line 1266
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1266
        tmp___26 = setlocale(6, (char const   *)((void *)0));
#line 1266
        old_locale___4 = tmp___26;
#line 1266
        saved_locale___4 = (char *)((void *)0);
        }
#line 1266
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
          {
#line 1266
          saved_locale___4 = strdup((char const   *)old_locale___4);
          }
        }
#line 1266
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
          {
#line 1266
          setlocale(6, "C");
          }
        }
        {
#line 1266
        tmp___27 = gr_dbname();
#line 1266
        syslog(3, "failed to unlock %s", tmp___27);
        }
#line 1266
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
          {
#line 1266
          setlocale(6, (char const   *)saved_locale___4);
#line 1266
          free((void *)saved_locale___4);
          }
        }
#line 1266
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1273
  if (is_shadow_pwd___1) {
    {
#line 1274
    tmp___33 = spw_unlock();
    }
#line 1274
    if (tmp___33 == 0) {
      {
#line 1275
      tmp___29 = spw_dbname();
#line 1275
      tmp___30 = gettext("%s: failed to unlock %s\n");
#line 1275
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
              Prog, tmp___29);
      }
      {
#line 1278
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1278
        tmp___31 = setlocale(6, (char const   *)((void *)0));
#line 1278
        old_locale___5 = tmp___31;
#line 1278
        saved_locale___5 = (char *)((void *)0);
        }
#line 1278
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
          {
#line 1278
          saved_locale___5 = strdup((char const   *)old_locale___5);
          }
        }
#line 1278
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
          {
#line 1278
          setlocale(6, "C");
          }
        }
        {
#line 1278
        tmp___32 = spw_dbname();
#line 1278
        syslog(3, "failed to unlock %s", tmp___32);
        }
#line 1278
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
          {
#line 1278
          setlocale(6, (char const   *)saved_locale___5);
#line 1278
          free((void *)saved_locale___5);
          }
        }
#line 1278
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  {
#line 1284
  tmp___38 = pw_unlock();
  }
#line 1284
  if (tmp___38 == 0) {
    {
#line 1285
    tmp___34 = pw_dbname();
#line 1285
    tmp___35 = gettext("%s: failed to unlock %s\n");
#line 1285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
            Prog, tmp___34);
    }
    {
#line 1288
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1288
      tmp___36 = setlocale(6, (char const   *)((void *)0));
#line 1288
      old_locale___6 = tmp___36;
#line 1288
      saved_locale___6 = (char *)((void *)0);
      }
#line 1288
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___6) {
        {
#line 1288
        saved_locale___6 = strdup((char const   *)old_locale___6);
        }
      }
#line 1288
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
        {
#line 1288
        setlocale(6, "C");
        }
      }
      {
#line 1288
      tmp___37 = pw_dbname();
#line 1288
      syslog(3, "failed to unlock %s", tmp___37);
      }
#line 1288
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
        {
#line 1288
        setlocale(6, (char const   *)saved_locale___6);
#line 1288
        free((void *)saved_locale___6);
        }
      }
#line 1288
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1292
  pw_locked___5 = (_Bool)0;
#line 1293
  spw_locked___5 = (_Bool)0;
#line 1294
  gr_locked___3 = (_Bool)0;
#line 1296
  sgr_locked___3 = (_Bool)0;
#line 1302
  endpwent();
#line 1303
  endspent();
#line 1304
  endgrent();
#line 1306
  endsgent();
  }
#line 1308
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void open_files___6(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 1317
  tmp___1 = pw_lock();
  }
#line 1317
  if (tmp___1 == 0) {
    {
#line 1318
    tmp = pw_dbname();
#line 1318
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 1318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 1321
    fail_exit___7(1);
    }
  }
  {
#line 1323
  pw_locked___5 = (_Bool)1;
#line 1324
  tmp___4 = pw_open(2);
  }
#line 1324
  if (tmp___4 == 0) {
    {
#line 1325
    tmp___2 = pw_dbname();
#line 1325
    tmp___3 = gettext("%s: cannot open %s\n");
#line 1325
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 1328
    fail_exit___7(1);
    }
  }
#line 1330
  if (is_shadow_pwd___1) {
    {
#line 1330
    tmp___7 = spw_lock();
    }
#line 1330
    if (tmp___7 == 0) {
      {
#line 1331
      tmp___5 = spw_dbname();
#line 1331
      tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 1331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, tmp___5);
#line 1334
      fail_exit___7(1);
      }
    }
  }
#line 1336
  spw_locked___5 = (_Bool)1;
#line 1337
  if (is_shadow_pwd___1) {
    {
#line 1337
    tmp___10 = spw_open(2);
    }
#line 1337
    if (tmp___10 == 0) {
      {
#line 1338
      tmp___8 = spw_dbname();
#line 1338
      tmp___9 = gettext("%s: cannot open %s\n");
#line 1338
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
#line 1341
      fail_exit___7(1);
      }
    }
  }
#line 1344
  if (Gflg___0) {
#line 1344
    goto _L;
  } else
#line 1344
  if (lflg___2) {
    _L: /* CIL Label */ 
    {
#line 1349
    tmp___13 = gr_lock();
    }
#line 1349
    if (tmp___13 == 0) {
      {
#line 1350
      tmp___11 = gr_dbname();
#line 1350
      tmp___12 = gettext("%s: cannot lock %s; try again later.\n");
#line 1350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
              Prog, tmp___11);
#line 1353
      fail_exit___7(10);
      }
    }
    {
#line 1355
    gr_locked___3 = (_Bool)1;
#line 1356
    tmp___16 = gr_open(2);
    }
#line 1356
    if (tmp___16 == 0) {
      {
#line 1357
      tmp___14 = gr_dbname();
#line 1357
      tmp___15 = gettext("%s: cannot open %s\n");
#line 1357
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
#line 1360
      fail_exit___7(10);
      }
    }
#line 1363
    if (is_shadow_grp___2) {
      {
#line 1363
      tmp___19 = sgr_lock();
      }
#line 1363
      if (tmp___19 == 0) {
        {
#line 1364
        tmp___17 = sgr_dbname();
#line 1364
        tmp___18 = gettext("%s: cannot lock %s; try again later.\n");
#line 1364
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
                Prog, tmp___17);
#line 1367
        fail_exit___7(10);
        }
      }
    }
#line 1369
    sgr_locked___3 = (_Bool)1;
#line 1370
    if (is_shadow_grp___2) {
      {
#line 1370
      tmp___22 = sgr_open(2);
      }
#line 1370
      if (tmp___22 == 0) {
        {
#line 1371
        tmp___20 = sgr_dbname();
#line 1371
        tmp___21 = gettext("%s: cannot open %s\n");
#line 1371
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
                Prog, tmp___20);
#line 1374
        fail_exit___7(10);
        }
      }
    }
  }
#line 1378
  return;
}
}
#line 1386 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void usr_update___0(void) 
{ 
  struct passwd pwent___0 ;
  struct passwd  const  *pwd ;
  struct spwd spent ;
  struct spwd  const  *spwd ;
  char const   *tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
  {
#line 1392
  spwd = (struct spwd  const  *)((void *)0);
#line 1397
  pwd = pw_locate((char const   *)user_name___1);
  }
#line 1398
  if ((unsigned long )((void *)0) == (unsigned long )pwd) {
    {
#line 1399
    tmp = pw_dbname();
#line 1399
    tmp___0 = gettext("%s: user \'%s\' does not exist in %s\n");
#line 1399
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, user_name___1, tmp);
#line 1402
    fail_exit___7(6);
    }
  }
  {
#line 1404
  pwent___0 = (struct passwd )*pwd;
#line 1405
  new_pwent___0(& pwent___0);
  }
#line 1409
  if (is_shadow_pwd___1) {
    {
#line 1410
    spwd = spw_locate((char const   *)user_name___1);
    }
#line 1411
    if ((unsigned long )((void *)0) != (unsigned long )spwd) {
      {
#line 1413
      spent = (struct spwd )*spwd;
#line 1414
      new_spent___0(& spent);
      }
    } else
#line 1415
    if (pflg) {
      {
#line 1415
      tmp___5 = strcmp((char const   *)pwent___0.pw_passwd, "x");
      }
#line 1415
      if (tmp___5 == 0) {
#line 1415
        goto _L;
      } else {
#line 1415
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1415
    if (eflg___2) {
#line 1415
      goto _L;
    } else
#line 1415
    if (fflg___0) {
      _L: /* CIL Label */ 
      {
#line 1424
      memset((void *)(& spent), 0, sizeof(spent));
#line 1425
      spent.sp_namp = user_name___1;
#line 1430
      spent.sp_pwdp = xstrdup((char const   *)pwent___0.pw_passwd);
#line 1431
      pwent___0.pw_passwd = xstrdup("x");
#line 1433
      tmp___1 = time((time_t *)0);
#line 1433
      spent.sp_lstchg = tmp___1 / 86400L;
      }
#line 1434
      if (0L == spent.sp_lstchg) {
#line 1437
        spent.sp_lstchg = -1L;
      }
      {
#line 1439
      tmp___2 = getdef_num("PASS_MIN_DAYS", -1);
#line 1439
      spent.sp_min = (long )tmp___2;
#line 1440
      tmp___3 = getdef_num("PASS_MAX_DAYS", -1);
#line 1440
      spent.sp_max = (long )tmp___3;
#line 1441
      tmp___4 = getdef_num("PASS_WARN_AGE", -1);
#line 1441
      spent.sp_warn = (long )tmp___4;
#line 1442
      spent.sp_inact = -1L;
#line 1443
      spent.sp_expire = -1L;
#line 1444
      spent.sp_flag = 0xffffffffffffffffUL;
#line 1445
      new_spent___0(& spent);
#line 1446
      spwd = (struct spwd  const  *)(& spent);
      }
    }
  }
#line 1450
  if (lflg___2) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (uflg___1) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (gflg___0) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (cflg___0) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (dflg___2) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (sflg___3) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (pflg) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (Lflg) {
#line 1450
    goto _L___1;
  } else
#line 1450
  if (Uflg___0) {
    _L___1: /* CIL Label */ 
    {
#line 1452
    tmp___8 = pw_update((struct passwd  const  *)(& pwent___0));
    }
#line 1452
    if (tmp___8 == 0) {
      {
#line 1453
      tmp___6 = pw_dbname();
#line 1453
      tmp___7 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 1453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              Prog, tmp___6, pwent___0.pw_name);
#line 1456
      fail_exit___7(1);
      }
    }
#line 1458
    if (lflg___2) {
      {
#line 1458
      tmp___11 = pw_remove((char const   *)user_name___1);
      }
#line 1458
      if (tmp___11 == 0) {
        {
#line 1459
        tmp___9 = pw_dbname();
#line 1459
        tmp___10 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 1459
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                Prog, user_name___1, tmp___9);
#line 1462
        fail_exit___7(1);
        }
      }
    }
  }
#line 1465
  if ((unsigned long )((void *)0) != (unsigned long )spwd) {
#line 1465
    if (lflg___2) {
#line 1465
      goto _L___2;
    } else
#line 1465
    if (eflg___2) {
#line 1465
      goto _L___2;
    } else
#line 1465
    if (fflg___0) {
#line 1465
      goto _L___2;
    } else
#line 1465
    if (pflg) {
#line 1465
      goto _L___2;
    } else
#line 1465
    if (Lflg) {
#line 1465
      goto _L___2;
    } else
#line 1465
    if (Uflg___0) {
      _L___2: /* CIL Label */ 
      {
#line 1466
      tmp___14 = spw_update((struct spwd  const  *)(& spent));
      }
#line 1466
      if (tmp___14 == 0) {
        {
#line 1467
        tmp___12 = spw_dbname();
#line 1467
        tmp___13 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 1467
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
                Prog, tmp___12, spent.sp_namp);
#line 1470
        fail_exit___7(1);
        }
      }
#line 1472
      if (lflg___2) {
        {
#line 1472
        tmp___17 = spw_remove((char const   *)user_name___1);
        }
#line 1472
        if (tmp___17 == 0) {
          {
#line 1473
          tmp___15 = spw_dbname();
#line 1473
          tmp___16 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 1473
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
                  Prog, user_name___1, tmp___15);
#line 1476
          fail_exit___7(1);
          }
        }
      }
    }
  }
#line 1479
  return;
}
}
#line 1487 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void move_home(void) 
{ 
  struct stat sb ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  gid_t tmp___3 ;
  uid_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  gid_t tmp___8 ;
  uid_t tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 1491
  tmp___0 = access((char const   *)user_newhome, 0);
  }
#line 1491
  if (tmp___0 == 0) {
    {
#line 1496
    tmp = gettext("%s: directory %s exists\n");
#line 1496
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, user_newhome);
#line 1499
    fail_exit___7(12);
    }
  }
  {
#line 1502
  tmp___14 = stat((char const   */* __restrict  */)user_home___0, (struct stat */* __restrict  */)(& sb));
  }
#line 1502
  if (tmp___14 == 0) {
#line 1507
    if (! ((sb.st_mode & 61440U) == 16384U)) {
      {
#line 1508
      tmp___1 = gettext("%s: The previous home directory (%s) was not a directory. It is not removed and no home directories are created.\n");
#line 1508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, user_home___0);
#line 1513
      fail_exit___7(12);
      }
    }
    {
#line 1516
    tmp___13 = rename((char const   *)user_home___0, (char const   *)user_newhome);
    }
#line 1516
    if (tmp___13 == 0) {
#line 1520
      if (gflg___0) {
#line 1520
        tmp___3 = user_newgid;
      } else {
#line 1520
        tmp___3 = (gid_t )-1;
      }
#line 1520
      if (uflg___1) {
#line 1520
        tmp___4 = user_newid;
      } else {
#line 1520
        tmp___4 = (uid_t )-1;
      }
      {
#line 1520
      tmp___5 = chown_tree((char const   *)user_newhome, user_id___0, tmp___4, user_gid___0,
                           tmp___3);
      }
#line 1520
      if (tmp___5 != 0) {
        {
#line 1523
        tmp___2 = gettext("%s: Failed to change ownership of the home directory");
#line 1523
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                Prog);
#line 1526
        fail_exit___7(12);
        }
      }
#line 1534
      return;
    } else {
      {
#line 1536
      tmp___11 = __errno_location();
      }
#line 1536
      if (18 == *tmp___11) {
#line 1537
        if (gflg___0) {
#line 1537
          tmp___8 = user_newgid;
        } else {
#line 1537
          tmp___8 = (gid_t )-1;
        }
#line 1537
        if (uflg___1) {
#line 1537
          tmp___9 = user_newid;
        } else {
#line 1537
          tmp___9 = (uid_t )-1;
        }
        {
#line 1537
        tmp___10 = copy_tree((char const   *)user_home___0, (char const   *)user_newhome,
                             (_Bool)1, (_Bool)1, user_id___0, tmp___9, user_gid___0,
                             tmp___8);
        }
#line 1537
        if (tmp___10 == 0) {
          {
#line 1543
          tmp___7 = remove_tree((char const   *)user_home___0, (_Bool)1);
          }
#line 1543
          if (tmp___7 != 0) {
            {
#line 1544
            tmp___6 = gettext("%s: warning: failed to completely remove old home directory %s");
#line 1544
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                    Prog, user_home___0);
            }
          }
#line 1556
          return;
        }
        {
#line 1559
        remove_tree((char const   *)user_newhome, (_Bool)1);
        }
      }
      {
#line 1561
      tmp___12 = gettext("%s: cannot rename directory %s to %s\n");
#line 1561
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
              Prog, user_home___0, user_newhome);
#line 1564
      fail_exit___7(12);
      }
    }
  }
#line 1567
  return;
}
}
#line 1576 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void update_lastlog(void) 
{ 
  struct lastlog ll___0 ;
  int fd ;
  off_t off_uid ;
  off_t off_newuid ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  __off_t tmp___13 ;
  ssize_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  __off_t tmp___17 ;
  ssize_t tmp___18 ;
  __off_t tmp___19 ;
  ssize_t tmp___20 ;

  {
  {
#line 1580
  off_uid = (off_t )((unsigned long )((off_t )user_id___0) * sizeof(ll___0));
#line 1581
  off_newuid = (off_t )((unsigned long )((off_t )user_newid) * sizeof(ll___0));
#line 1583
  tmp = access("/var/log/lastlog", 0);
  }
#line 1583
  if (tmp != 0) {
#line 1584
    return;
  }
  {
#line 1587
  fd = open("/var/log/lastlog", 2);
  }
#line 1589
  if (-1 == fd) {
    {
#line 1590
    tmp___0 = __errno_location();
#line 1590
    tmp___1 = strerror(*tmp___0);
#line 1590
    tmp___2 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1590
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___1);
    }
#line 1593
    return;
  }
  {
#line 1596
  tmp___19 = lseek(fd, off_uid, 0);
  }
#line 1596
  if (tmp___19 == off_uid) {
    {
#line 1596
    tmp___20 = read(fd, (void *)(& ll___0), sizeof(ll___0));
    }
#line 1596
    if (tmp___20 == (ssize_t )sizeof(ll___0)) {
      {
#line 1599
      tmp___6 = lseek(fd, off_newuid, 0);
      }
#line 1599
      if (tmp___6 != off_newuid) {
        {
#line 1603
        tmp___3 = __errno_location();
#line 1603
        tmp___4 = strerror(*tmp___3);
#line 1603
        tmp___5 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1603
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___4);
        }
      } else {
        {
#line 1599
        tmp___7 = write(fd, (void const   *)(& ll___0), sizeof(ll___0));
        }
#line 1599
        if (tmp___7 != (ssize_t )sizeof(ll___0)) {
          {
#line 1603
          tmp___3 = __errno_location();
#line 1603
          tmp___4 = strerror(*tmp___3);
#line 1603
          tmp___5 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1603
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                  Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___4);
          }
        } else {
          {
#line 1599
          tmp___8 = fsync(fd);
          }
#line 1599
          if (tmp___8 != 0) {
            {
#line 1603
            tmp___3 = __errno_location();
#line 1603
            tmp___4 = strerror(*tmp___3);
#line 1603
            tmp___5 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1603
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                    Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                    tmp___4);
            }
          } else {
            {
#line 1599
            tmp___9 = close(fd);
            }
#line 1599
            if (tmp___9 != 0) {
              {
#line 1603
              tmp___3 = __errno_location();
#line 1603
              tmp___4 = strerror(*tmp___3);
#line 1603
              tmp___5 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1603
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                      Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                      tmp___4);
              }
            }
          }
        }
      }
    } else {
#line 1596
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1612
    tmp___17 = lseek(fd, off_newuid, 0);
    }
#line 1612
    if (tmp___17 == off_newuid) {
      {
#line 1612
      tmp___18 = read(fd, (void *)(& ll___0), sizeof(ll___0));
      }
#line 1612
      if (tmp___18 == (ssize_t )sizeof(ll___0)) {
        {
#line 1615
        memset((void *)(& ll___0), 0, sizeof(ll___0));
#line 1616
        tmp___13 = lseek(fd, off_newuid, 0);
        }
#line 1616
        if (tmp___13 != off_newuid) {
          {
#line 1620
          tmp___10 = __errno_location();
#line 1620
          tmp___11 = strerror(*tmp___10);
#line 1620
          tmp___12 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1620
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                  Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___11);
          }
        } else {
          {
#line 1616
          tmp___14 = write(fd, (void const   *)(& ll___0), sizeof(ll___0));
          }
#line 1616
          if (tmp___14 != (ssize_t )sizeof(ll___0)) {
            {
#line 1620
            tmp___10 = __errno_location();
#line 1620
            tmp___11 = strerror(*tmp___10);
#line 1620
            tmp___12 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1620
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                    Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                    tmp___11);
            }
          } else {
            {
#line 1616
            tmp___15 = fsync(fd);
            }
#line 1616
            if (tmp___15 != 0) {
              {
#line 1620
              tmp___10 = __errno_location();
#line 1620
              tmp___11 = strerror(*tmp___10);
#line 1620
              tmp___12 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1620
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                      Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                      tmp___11);
              }
            } else {
              {
#line 1616
              tmp___16 = close(fd);
              }
#line 1616
              if (tmp___16 != 0) {
                {
#line 1620
                tmp___10 = __errno_location();
#line 1620
                tmp___11 = strerror(*tmp___10);
#line 1620
                tmp___12 = gettext("%s: failed to copy the lastlog entry of user %lu to user %lu: %s\n");
#line 1620
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                        Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                        tmp___11);
                }
              }
            }
          }
        }
      } else {
        {
#line 1625
        close(fd);
        }
      }
    } else {
      {
#line 1625
      close(fd);
      }
    }
  }
#line 1628
  return;
}
}
#line 1637 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void update_faillog(void) 
{ 
  struct faillog fl ;
  int fd ;
  off_t off_uid ;
  off_t off_newuid ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  __off_t tmp___13 ;
  ssize_t tmp___14 ;
  int tmp___15 ;
  __off_t tmp___16 ;
  ssize_t tmp___17 ;
  __off_t tmp___18 ;
  ssize_t tmp___19 ;

  {
  {
#line 1641
  off_uid = (off_t )((unsigned long )((off_t )user_id___0) * sizeof(fl));
#line 1642
  off_newuid = (off_t )((unsigned long )((off_t )user_newid) * sizeof(fl));
#line 1644
  tmp = access("/var/log/faillog", 0);
  }
#line 1644
  if (tmp != 0) {
#line 1645
    return;
  }
  {
#line 1648
  fd = open("/var/log/faillog", 2);
  }
#line 1650
  if (-1 == fd) {
    {
#line 1651
    tmp___0 = __errno_location();
#line 1651
    tmp___1 = strerror(*tmp___0);
#line 1651
    tmp___2 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1651
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___1);
    }
#line 1654
    return;
  }
  {
#line 1657
  tmp___18 = lseek(fd, off_uid, 0);
  }
#line 1657
  if (tmp___18 == off_uid) {
    {
#line 1657
    tmp___19 = read(fd, (void *)((char *)(& fl)), sizeof(fl));
    }
#line 1657
    if (tmp___19 == (ssize_t )sizeof(fl)) {
      {
#line 1660
      tmp___6 = lseek(fd, off_newuid, 0);
      }
#line 1660
      if (tmp___6 != off_newuid) {
        {
#line 1664
        tmp___3 = __errno_location();
#line 1664
        tmp___4 = strerror(*tmp___3);
#line 1664
        tmp___5 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1664
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___4);
        }
      } else {
        {
#line 1660
        tmp___7 = write(fd, (void const   *)(& fl), sizeof(fl));
        }
#line 1660
        if (tmp___7 != (ssize_t )sizeof(fl)) {
          {
#line 1664
          tmp___3 = __errno_location();
#line 1664
          tmp___4 = strerror(*tmp___3);
#line 1664
          tmp___5 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1664
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                  Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___4);
          }
        } else {
          {
#line 1660
          tmp___8 = fsync(fd);
          }
#line 1660
          if (tmp___8 != 0) {
            {
#line 1664
            tmp___3 = __errno_location();
#line 1664
            tmp___4 = strerror(*tmp___3);
#line 1664
            tmp___5 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1664
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                    Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                    tmp___4);
            }
          } else {
            {
#line 1660
            tmp___9 = close(fd);
            }
#line 1660
            if (tmp___9 != 0) {
              {
#line 1664
              tmp___3 = __errno_location();
#line 1664
              tmp___4 = strerror(*tmp___3);
#line 1664
              tmp___5 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1664
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                      Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                      tmp___4);
              }
            }
          }
        }
      }
    } else {
#line 1657
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1673
    tmp___16 = lseek(fd, off_newuid, 0);
    }
#line 1673
    if (tmp___16 == off_newuid) {
      {
#line 1673
      tmp___17 = read(fd, (void *)(& fl), sizeof(fl));
      }
#line 1673
      if (tmp___17 == (ssize_t )sizeof(fl)) {
        {
#line 1676
        memset((void *)(& fl), 0, sizeof(fl));
#line 1677
        tmp___13 = lseek(fd, off_newuid, 0);
        }
#line 1677
        if (tmp___13 != off_newuid) {
          {
#line 1680
          tmp___10 = __errno_location();
#line 1680
          tmp___11 = strerror(*tmp___10);
#line 1680
          tmp___12 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1680
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                  Prog, (unsigned long )user_id___0, (unsigned long )user_newid, tmp___11);
          }
        } else {
          {
#line 1677
          tmp___14 = write(fd, (void const   *)(& fl), sizeof(fl));
          }
#line 1677
          if (tmp___14 != (ssize_t )sizeof(fl)) {
            {
#line 1680
            tmp___10 = __errno_location();
#line 1680
            tmp___11 = strerror(*tmp___10);
#line 1680
            tmp___12 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1680
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                    Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                    tmp___11);
            }
          } else {
            {
#line 1677
            tmp___15 = close(fd);
            }
#line 1677
            if (tmp___15 != 0) {
              {
#line 1680
              tmp___10 = __errno_location();
#line 1680
              tmp___11 = strerror(*tmp___10);
#line 1680
              tmp___12 = gettext("%s: failed to copy the faillog entry of user %lu to user %lu: %s\n");
#line 1680
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                      Prog, (unsigned long )user_id___0, (unsigned long )user_newid,
                      tmp___11);
              }
            }
          }
        }
      } else {
        {
#line 1685
        close(fd);
        }
      }
    } else {
      {
#line 1685
      close(fd);
      }
    }
  }
#line 1688
  return;
}
}
#line 1698 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/usermod.c"
static void move_mailbox(void) 
{ 
  char const   *maildir ;
  char mailfile[1024] ;
  char newmailfile[1024] ;
  int fd ;
  struct stat st ;
  char const   *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1705
  maildir = getdef_str("MAIL_DIR");
  }
#line 1707
  if ((unsigned long )((void *)0) == (unsigned long )maildir) {
    {
#line 1707
    tmp = getdef_str("MAIL_FILE");
    }
#line 1707
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1708
      maildir = "/var/mail";
    }
  }
#line 1711
  if ((unsigned long )((void *)0) == (unsigned long )maildir) {
#line 1712
    return;
  }
  {
#line 1721
  snprintf((char */* __restrict  */)(mailfile), sizeof(mailfile), (char const   */* __restrict  */)"%s/%s",
           maildir, user_name___1);
#line 1723
  mailfile[sizeof(mailfile) - 1UL] = (char )'\000';
#line 1724
  fd = open((char const   *)(mailfile), 2048, 0);
  }
#line 1725
  if (fd < 0) {
    {
#line 1727
    tmp___0 = __errno_location();
    }
#line 1727
    if (*tmp___0 != 2) {
      {
#line 1728
      perror((char const   *)(mailfile));
      }
    }
#line 1730
    return;
  }
  {
#line 1732
  tmp___1 = fstat(fd, & st);
  }
#line 1732
  if (tmp___1 < 0) {
    {
#line 1733
    perror("fstat");
#line 1734
    close(fd);
    }
#line 1735
    return;
  }
#line 1737
  if (st.st_uid != user_id___0) {
    {
#line 1739
    tmp___2 = gettext("%s: warning: %s not owned by %s\n");
#line 1739
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, mailfile, user_name___1);
#line 1741
    close(fd);
    }
#line 1742
    return;
  }
#line 1744
  if (uflg___1) {
    {
#line 1745
    tmp___4 = fchown(fd, user_newid, (gid_t )-1);
    }
#line 1745
    if (tmp___4 < 0) {
      {
#line 1746
      tmp___3 = gettext("failed to change mailbox owner");
#line 1746
      perror((char const   *)tmp___3);
      }
    }
  }
  {
#line 1757
  close(fd);
  }
#line 1759
  if (lflg___2) {
    {
#line 1760
    snprintf((char */* __restrict  */)(newmailfile), sizeof(newmailfile), (char const   */* __restrict  */)"%s/%s",
             maildir, user_newname);
#line 1762
    newmailfile[sizeof(newmailfile) - 1UL] = (char )'\000';
#line 1763
    tmp___6 = link((char const   *)(mailfile), (char const   *)(newmailfile));
    }
#line 1763
    if (tmp___6 != 0) {
      {
#line 1765
      tmp___5 = gettext("failed to rename mailbox");
#line 1765
      perror((char const   *)tmp___5);
      }
    } else {
      {
#line 1763
      tmp___7 = unlink((char const   *)(mailfile));
      }
#line 1763
      if (tmp___7 != 0) {
        {
#line 1765
        tmp___5 = gettext("failed to rename mailbox");
#line 1765
        perror((char const   *)tmp___5);
        }
      }
    }
  }
#line 1775
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___13(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___13  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___13  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___13  ;
#line 72
static int copy_entry___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___13(char const   *filename___0 ) ;
#line 83
static int copy_symlink___13(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___13(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___13(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___13(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___13(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___13(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___13 == (unsigned long )ln) {
    {
#line 149
    links___13 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___13;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___13(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___13)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___13)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___13;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___13);
#line 199
  dst_len = strlen(dst_orig___13);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___13, name___3 + src_len);
#line 207
  lp->ln_next = links___13;
#line 208
  links___13 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___13(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___13(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___13(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___13(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___13(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___13(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___13(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___13(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___13(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___13)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___13)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___13(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___13);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___13, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___13);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___13);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___13);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___13, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___13(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___13(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___13(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___13(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___13(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___13(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___13(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___13(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___13(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___13[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___13[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___14(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___14(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___14[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___14[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___14  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___13(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___14  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___27  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___13(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___27) {
#line 70
      size___27 = i + 100;
#line 71
      if (members___14) {
        {
#line 72
        tmp = realloc((void *)members___14, (unsigned long )size___27 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___27 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___14) {
          {
#line 81
          free((void *)members___14);
          }
        }
#line 82
        members___14 = (char **)0;
#line 83
        size___27 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___14 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___14 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___14 + i) = (char *)0;
#line 99
  return (members___14);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___13  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___28  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___13[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___13  ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/id.c"
static void usage___12(void) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/id.c"
static void usage___12(void) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("Usage: id [-a]\n");
#line 56
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 60
  exit(1);
  }
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___14(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___14(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___14  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___14  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___14  ;
#line 72
static int copy_entry___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___14(char const   *filename___0 ) ;
#line 83
static int copy_symlink___14(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___14(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___14(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___14(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___14(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___14(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___14 == (unsigned long )ln) {
    {
#line 149
    links___14 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___14;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___14(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___14)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___14)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___14;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___14);
#line 199
  dst_len = strlen(dst_orig___14);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___14, name___3 + src_len);
#line 207
  lp->ln_next = links___14;
#line 208
  links___14 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___14(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___14(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___14(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___14(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___14(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___14(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___14(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___14(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___14(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___14)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___14)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___14(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___14);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___14, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___14);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___14);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___14);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___14, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___14(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___14(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___14(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___14(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___14(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___14(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___14(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___14(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___14(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___14[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___14[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___15(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___15(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___15[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___15[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___15  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___14(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___15  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___29  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___14(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___29) {
#line 70
      size___29 = i + 100;
#line 71
      if (members___15) {
        {
#line 72
        tmp = realloc((void *)members___15, (unsigned long )size___29 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___29 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___15) {
          {
#line 81
          free((void *)members___15);
          }
        }
#line 82
        members___15 = (char **)0;
#line 83
        size___29 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___15 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___15 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___15 + i) = (char *)0;
#line 99
  return (members___15);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___14  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___30  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___14[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___14  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___15(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 49 "../lib/groupio.h"
extern int gr_remove(char const   *name ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static char *group_name  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static gid_t group_id  =    (gid_t )-1;
#line 65 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static _Bool is_shadow_grp___3  ;
#line 79
static void usage___13(int status ) ;
#line 80
static void grp_update___1(void) ;
#line 81
static void close_files___7(void) ;
#line 82
static void open_files___7(void) ;
#line 83
static void group_busy(gid_t gid ) ;
#line 84
static void process_flags___10(int argc , char **argv ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static void usage___13(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 91
  if (0 != status) {
#line 91
    tmp = stderr;
  } else {
#line 91
    tmp = stdout;
  }
  {
#line 91
  usageout = tmp;
#line 92
  tmp___0 = gettext("Usage: %s [options] GROUP\n\nOptions:\n");
#line 92
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 97
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 97
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 98
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 98
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 99
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 100
  exit(status);
  }
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static void grp_update___1(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct sgrp  const  *tmp___5 ;

  {
  {
#line 114
  add_cleanup(& cleanup_report_del_group_group, (void *)group_name);
  }
#line 116
  if (is_shadow_grp___3) {
    {
#line 118
    add_cleanup(& cleanup_report_del_group_gshadow, (void *)group_name);
    }
  }
  {
#line 125
  tmp___1 = gr_remove((char const   *)group_name);
  }
#line 125
  if (tmp___1 == 0) {
    {
#line 126
    tmp = gr_dbname();
#line 126
    tmp___0 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, group_name, tmp);
#line 129
    exit(10);
    }
  }
#line 136
  if (is_shadow_grp___3) {
    {
#line 136
    tmp___5 = sgr_locate((char const   *)group_name);
    }
#line 136
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
      {
#line 137
      tmp___4 = sgr_remove((char const   *)group_name);
      }
#line 137
      if (tmp___4 == 0) {
        {
#line 138
        tmp___2 = sgr_dbname();
#line 138
        tmp___3 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 138
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                Prog, group_name, tmp___2);
#line 141
        exit(10);
        }
      }
    }
  }
#line 145
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static void close_files___7(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *old_locale___0 ;
  char *tmp___7 ;
  char *saved_locale___0 ;
  char const   *tmp___8 ;
  char *old_locale___1 ;
  char *tmp___9 ;
  char *saved_locale___1 ;

  {
  {
#line 156
  tmp___1 = gr_close();
  }
#line 156
  if (tmp___1 == 0) {
    {
#line 157
    tmp = gr_dbname();
#line 157
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 160
    exit(10);
    }
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 169
    old_locale = tmp___2;
#line 169
    saved_locale = (char *)((void *)0);
    }
#line 169
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 169
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 169
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 169
      setlocale(6, "C");
      }
    }
    {
#line 169
    tmp___3 = gr_dbname();
#line 169
    syslog(6, "group \'%s\' removed from %s", group_name, tmp___3);
    }
#line 169
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 169
      setlocale(6, (char const   *)saved_locale);
#line 169
      free((void *)saved_locale);
      }
    }
#line 169
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  del_cleanup(& cleanup_report_del_group_group);
#line 174
  cleanup_unlock_group((void *)0);
#line 175
  del_cleanup(& cleanup_unlock_group);
  }
#line 180
  if (is_shadow_grp___3) {
    {
#line 181
    tmp___6 = sgr_close();
    }
#line 181
    if (tmp___6 == 0) {
      {
#line 182
      tmp___4 = sgr_dbname();
#line 182
      tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
#line 185
      exit(10);
      }
    }
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 194
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 194
      old_locale___0 = tmp___7;
#line 194
      saved_locale___0 = (char *)((void *)0);
      }
#line 194
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 194
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 194
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 194
        setlocale(6, "C");
        }
      }
      {
#line 194
      tmp___8 = sgr_dbname();
#line 194
      syslog(6, "group \'%s\' removed from %s", group_name, tmp___8);
      }
#line 194
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 194
        setlocale(6, (char const   *)saved_locale___0);
#line 194
        free((void *)saved_locale___0);
        }
      }
#line 194
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 197
    del_cleanup(& cleanup_report_del_group_gshadow);
#line 199
    cleanup_unlock_gshadow((void *)0);
#line 200
    del_cleanup(& cleanup_unlock_gshadow);
    }
  }
  {
#line 211
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 211
    tmp___9 = setlocale(6, (char const   *)((void *)0));
#line 211
    old_locale___1 = tmp___9;
#line 211
    saved_locale___1 = (char *)((void *)0);
    }
#line 211
    if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
      {
#line 211
      saved_locale___1 = strdup((char const   *)old_locale___1);
      }
    }
#line 211
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
      {
#line 211
      setlocale(6, "C");
      }
    }
    {
#line 211
    syslog(6, "group \'%s\' removed\n", group_name);
    }
#line 211
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
      {
#line 211
      setlocale(6, (char const   *)saved_locale___1);
#line 211
      free((void *)saved_locale___1);
      }
    }
#line 211
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 212
  del_cleanup(& cleanup_report_del_group);
  }
#line 213
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static void open_files___7(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *old_locale ;
  char *tmp___7 ;
  char *saved_locale ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *old_locale___0 ;
  char *tmp___12 ;
  char *saved_locale___0 ;
  char const   *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 223
  tmp___1 = gr_lock();
  }
#line 223
  if (tmp___1 == 0) {
    {
#line 224
    tmp = gr_dbname();
#line 224
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 227
    exit(10);
    }
  }
  {
#line 229
  add_cleanup(& cleanup_unlock_group, (void *)0);
  }
#line 231
  if (is_shadow_grp___3) {
    {
#line 232
    tmp___4 = sgr_lock();
    }
#line 232
    if (tmp___4 == 0) {
      {
#line 233
      tmp___2 = sgr_dbname();
#line 233
      tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2);
#line 236
      exit(10);
      }
    }
    {
#line 238
    add_cleanup(& cleanup_unlock_gshadow, (void *)0);
    }
  }
  {
#line 246
  add_cleanup(& cleanup_report_del_group, (void *)group_name);
#line 249
  tmp___9 = gr_open(2);
  }
#line 249
  if (tmp___9 == 0) {
    {
#line 250
    tmp___5 = gr_dbname();
#line 250
    tmp___6 = gettext("%s: cannot open %s\n");
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
    }
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 253
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 253
      old_locale = tmp___7;
#line 253
      saved_locale = (char *)((void *)0);
      }
#line 253
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 253
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 253
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 253
        setlocale(6, "C");
        }
      }
      {
#line 253
      tmp___8 = gr_dbname();
#line 253
      syslog(4, "cannot open %s", tmp___8);
      }
#line 253
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 253
        setlocale(6, (char const   *)saved_locale);
#line 253
        free((void *)saved_locale);
        }
      }
#line 253
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 254
    exit(10);
    }
  }
#line 257
  if (is_shadow_grp___3) {
    {
#line 258
    tmp___14 = sgr_open(2);
    }
#line 258
    if (tmp___14 == 0) {
      {
#line 259
      tmp___10 = sgr_dbname();
#line 259
      tmp___11 = gettext("%s: cannot open %s\n");
#line 259
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
              Prog, tmp___10);
      }
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 262
        tmp___12 = setlocale(6, (char const   *)((void *)0));
#line 262
        old_locale___0 = tmp___12;
#line 262
        saved_locale___0 = (char *)((void *)0);
        }
#line 262
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 262
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 262
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 262
          setlocale(6, "C");
          }
        }
        {
#line 262
        tmp___13 = sgr_dbname();
#line 262
        syslog(4, "cannot open %s", tmp___13);
        }
#line 262
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 262
          setlocale(6, (char const   *)saved_locale___0);
#line 262
          free((void *)saved_locale___0);
          }
        }
#line 262
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 263
      exit(10);
      }
    }
  }
#line 267
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static void group_busy(gid_t gid ) 
{ 
  struct passwd *pwd ;
  char *tmp ;

  {
  {
#line 284
  setpwent();
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    pwd = getpwent();
    }
#line 286
    if ((unsigned long )pwd != (unsigned long )((void *)0)) {
#line 286
      if (! (pwd->pw_gid != gid)) {
#line 286
        goto while_break;
      }
    } else {
#line 286
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  endpwent();
  }
#line 294
  if ((unsigned long )pwd == (unsigned long )((struct passwd *)0)) {
#line 295
    return;
  }
  {
#line 301
  tmp = gettext("%s: cannot remove the primary group of user \'%s\'\n");
#line 301
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, Prog,
          pwd->pw_name);
#line 304
  exit(8);
  }
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static struct option long_options___11[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 312 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupdel.c"
static void process_flags___10(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    c = getopt_long(argc, (char * const  *)argv, "hR:", (struct option  const  *)(long_options___11),
                    (int *)((void *)0));
    }
#line 324
    if (! (c != -1)) {
#line 324
      goto while_break;
    }
    {
#line 327
    if (c == 104) {
#line 327
      goto case_104;
    }
#line 330
    if (c == 82) {
#line 330
      goto case_82;
    }
#line 332
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 328
    usage___13(0);
    }
#line 329
    goto switch_break;
    case_82: /* CIL Label */ 
#line 331
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 333
    usage___13(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (optind != argc - 1) {
    {
#line 338
    usage___13(2);
    }
  }
#line 340
  group_name = *(argv + optind);
#line 341
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___15(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___15  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___15  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___15  ;
#line 72
static int copy_entry___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___15(char const   *filename___0 ) ;
#line 83
static int copy_symlink___15(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___15(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___15(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___15(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___15(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___15(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___15 == (unsigned long )ln) {
    {
#line 149
    links___15 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___15;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___15(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___15)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___15)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___15;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___15);
#line 199
  dst_len = strlen(dst_orig___15);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___15, name___3 + src_len);
#line 207
  lp->ln_next = links___15;
#line 208
  links___15 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___15(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___15(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___15(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___15(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___15(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___15(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___15(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___15(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___15(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___15)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___15)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___15(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___15);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___15, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___15);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___15);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___15);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___15, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___15(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___15(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___15(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___15(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___15(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___15(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___15(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___15(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___15(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___15[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___15[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___16(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___16(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___16[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___16[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___16  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___15(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___16  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___31  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___15(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___31) {
#line 70
      size___31 = i + 100;
#line 71
      if (members___16) {
        {
#line 72
        tmp = realloc((void *)members___16, (unsigned long )size___31 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___31 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___16) {
          {
#line 81
          free((void *)members___16);
          }
        }
#line 82
        members___16 = (char **)0;
#line 83
        size___31 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___16 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___16 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___16 + i) = (char *)0;
#line 99
  return (members___16);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___15  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___32  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___15[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___15  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___16(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static char *group_name___0  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static gid_t group_id___0  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static char *group_passwd  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static char *empty_list___0  =    (char *)((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static _Bool oflg___1  =    (_Bool)0;
#line 81 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static _Bool gflg___1  =    (_Bool)0;
#line 82 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static _Bool fflg___1  =    (_Bool)0;
#line 83 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static _Bool rflg___3  =    (_Bool)0;
#line 84 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static _Bool pflg___0  =    (_Bool)0;
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static _Bool is_shadow_grp___4  ;
#line 91
static void usage___14(int status ) ;
#line 92
static void new_grent___0(struct group *grent___29 ) ;
#line 95
static void new_sgent___0(struct sgrp *sgent ) ;
#line 97
static void grp_update___2(void) ;
#line 98
static void check_new_name(void) ;
#line 99
static void close_files___8(void) ;
#line 100
static void open_files___8(void) ;
#line 101
static void process_flags___11(int argc , char **argv ) ;
#line 102
static void check_flags___4(void) ;
#line 103
static void check_perms___6(void) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void usage___14(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 110
  if (0 != status) {
#line 110
    tmp = stderr;
  } else {
#line 110
    tmp = stdout;
  }
  {
#line 110
  usageout = tmp;
#line 111
  tmp___0 = gettext("Usage: %s [options] GROUP\n\nOptions:\n");
#line 111
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 116
  tmp___1 = gettext("  -f, --force                   exit successfully if the group already exists,\n                                and cancel -g if the GID is already used\n");
#line 116
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 118
  tmp___2 = gettext("  -g, --gid GID                 use GID for the new group\n");
#line 118
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 119
  tmp___3 = gettext("  -h, --help                    display this help message and exit\n");
#line 119
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 120
  tmp___4 = gettext("  -K, --key KEY=VALUE           override /etc/login.defs defaults\n");
#line 120
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 121
  tmp___5 = gettext("  -o, --non-unique              allow to create groups with duplicate\n                                (non-unique) GID\n");
#line 121
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 123
  tmp___6 = gettext("  -p, --password PASSWORD       use this encrypted password for the new group\n");
#line 123
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 124
  tmp___7 = gettext("  -r, --system                  create a system account\n");
#line 124
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 125
  tmp___8 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 125
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 126
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 127
  exit(status);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void new_grent___0(struct group *grent___29 ) 
{ 


  {
  {
#line 138
  memset((void *)grent___29, 0, sizeof(*grent___29));
#line 139
  grent___29->gr_name = group_name___0;
  }
#line 140
  if (pflg___0) {
#line 141
    grent___29->gr_passwd = group_passwd;
  } else {
#line 143
    grent___29->gr_passwd = (char *)"x";
  }
#line 145
  grent___29->gr_gid = group_id___0;
#line 146
  grent___29->gr_mem = & empty_list___0;
#line 147
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void new_sgent___0(struct sgrp *sgent ) 
{ 


  {
  {
#line 158
  memset((void *)sgent, 0, sizeof(*sgent));
#line 159
  sgent->sg_name = group_name___0;
  }
#line 160
  if (pflg___0) {
#line 161
    sgent->sg_passwd = group_passwd;
  } else {
#line 163
    sgent->sg_passwd = (char *)"!";
  }
#line 165
  sgent->sg_adm = & empty_list___0;
#line 166
  sgent->sg_mem = & empty_list___0;
#line 167
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void grp_update___2(void) 
{ 
  struct group grp ;
  struct sgrp sgrp ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 187
  add_cleanup(& cleanup_report_add_group_group, (void *)group_name___0);
  }
#line 189
  if (is_shadow_grp___4) {
    {
#line 191
    add_cleanup(& cleanup_report_add_group_gshadow, (void *)group_name___0);
    }
  }
  {
#line 198
  new_grent___0(& grp);
#line 200
  new_sgent___0(& sgrp);
  }
#line 201
  if (is_shadow_grp___4) {
#line 201
    if (pflg___0) {
#line 202
      grp.gr_passwd = (char *)"x";
    }
  }
  {
#line 209
  tmp___1 = gr_update((struct group  const  *)(& grp));
  }
#line 209
  if (tmp___1 == 0) {
    {
#line 210
    tmp = gr_dbname();
#line 210
    tmp___0 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp, grp.gr_name);
#line 213
    exit(10);
    }
  }
#line 219
  if (is_shadow_grp___4) {
    {
#line 219
    tmp___4 = sgr_update((struct sgrp  const  *)(& sgrp));
    }
#line 219
    if (tmp___4 == 0) {
      {
#line 220
      tmp___2 = sgr_dbname();
#line 220
      tmp___3 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 220
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2, sgrp.sg_name);
#line 223
      exit(10);
      }
    }
  }
#line 226
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void check_new_name(void) 
{ 
  _Bool tmp ;
  char *tmp___0 ;

  {
  {
#line 236
  tmp = is_valid_group_name((char const   *)group_name___0);
  }
#line 236
  if (tmp) {
#line 237
    return;
  }
  {
#line 244
  tmp___0 = gettext("%s: \'%s\' is not a valid group name\n");
#line 244
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          Prog, group_name___0);
#line 247
  exit(3);
  }
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void close_files___8(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *old_locale___0 ;
  char *tmp___7 ;
  char *saved_locale___0 ;
  char const   *tmp___8 ;
  char *old_locale___1 ;
  char *tmp___9 ;
  char *saved_locale___1 ;

  {
  {
#line 259
  tmp___1 = gr_close();
  }
#line 259
  if (tmp___1 == 0) {
    {
#line 260
    tmp = gr_dbname();
#line 260
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 263
    exit(10);
    }
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 271
    tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 271
    old_locale = tmp___2;
#line 271
    saved_locale = (char *)((void *)0);
    }
#line 271
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 271
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 271
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 271
      setlocale(6, "C");
      }
    }
    {
#line 271
    tmp___3 = gr_dbname();
#line 271
    syslog(6, "group added to %s: name=%s, GID=%u", tmp___3, group_name___0, group_id___0);
    }
#line 271
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 271
      setlocale(6, (char const   *)saved_locale);
#line 271
      free((void *)saved_locale);
      }
    }
#line 271
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  del_cleanup(& cleanup_report_add_group_group);
#line 275
  cleanup_unlock_group((void *)0);
#line 276
  del_cleanup(& cleanup_unlock_group);
  }
#line 280
  if (is_shadow_grp___4) {
    {
#line 281
    tmp___6 = sgr_close();
    }
#line 281
    if (tmp___6 == 0) {
      {
#line 282
      tmp___4 = sgr_dbname();
#line 282
      tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
#line 285
      exit(10);
      }
    }
    {
#line 293
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 293
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 293
      old_locale___0 = tmp___7;
#line 293
      saved_locale___0 = (char *)((void *)0);
      }
#line 293
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 293
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 293
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 293
        setlocale(6, "C");
        }
      }
      {
#line 293
      tmp___8 = sgr_dbname();
#line 293
      syslog(6, "group added to %s: name=%s", tmp___8, group_name___0);
      }
#line 293
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 293
        setlocale(6, (char const   *)saved_locale___0);
#line 293
        free((void *)saved_locale___0);
        }
      }
#line 293
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 295
    del_cleanup(& cleanup_report_add_group_gshadow);
#line 297
    cleanup_unlock_gshadow((void *)0);
#line 298
    del_cleanup(& cleanup_unlock_gshadow);
    }
  }
  {
#line 309
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 309
    tmp___9 = setlocale(6, (char const   *)((void *)0));
#line 309
    old_locale___1 = tmp___9;
#line 309
    saved_locale___1 = (char *)((void *)0);
    }
#line 309
    if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
      {
#line 309
      saved_locale___1 = strdup((char const   *)old_locale___1);
      }
    }
#line 309
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
      {
#line 309
      setlocale(6, "C");
      }
    }
    {
#line 309
    syslog(6, "new group: name=%s, GID=%u", group_name___0, group_id___0);
    }
#line 309
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
      {
#line 309
      setlocale(6, (char const   *)saved_locale___1);
#line 309
      free((void *)saved_locale___1);
      }
    }
#line 309
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 311
  del_cleanup(& cleanup_report_add_group);
  }
#line 312
  return;
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void open_files___8(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *old_locale ;
  char *tmp___7 ;
  char *saved_locale ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *old_locale___0 ;
  char *tmp___12 ;
  char *saved_locale___0 ;
  char const   *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 322
  tmp___1 = gr_lock();
  }
#line 322
  if (tmp___1 == 0) {
    {
#line 323
    tmp = gr_dbname();
#line 323
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 326
    exit(10);
    }
  }
  {
#line 328
  add_cleanup(& cleanup_unlock_group, (void *)0);
  }
#line 331
  if (is_shadow_grp___4) {
    {
#line 332
    tmp___4 = sgr_lock();
    }
#line 332
    if (tmp___4 == 0) {
      {
#line 333
      tmp___2 = sgr_dbname();
#line 333
      tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2);
#line 336
      exit(10);
      }
    }
    {
#line 338
    add_cleanup(& cleanup_unlock_gshadow, (void *)0);
    }
  }
  {
#line 346
  add_cleanup(& cleanup_report_add_group, (void *)group_name___0);
#line 349
  tmp___9 = gr_open(2);
  }
#line 349
  if (tmp___9 == 0) {
    {
#line 350
    tmp___5 = gr_dbname();
#line 350
    tmp___6 = gettext("%s: cannot open %s\n");
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
    }
    {
#line 351
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 351
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 351
      old_locale = tmp___7;
#line 351
      saved_locale = (char *)((void *)0);
      }
#line 351
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 351
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 351
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 351
        setlocale(6, "C");
        }
      }
      {
#line 351
      tmp___8 = gr_dbname();
#line 351
      syslog(4, "cannot open %s", tmp___8);
      }
#line 351
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 351
        setlocale(6, (char const   *)saved_locale);
#line 351
        free((void *)saved_locale);
        }
      }
#line 351
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 352
    exit(10);
    }
  }
#line 356
  if (is_shadow_grp___4) {
    {
#line 357
    tmp___14 = sgr_open(2);
    }
#line 357
    if (tmp___14 == 0) {
      {
#line 358
      tmp___10 = sgr_dbname();
#line 358
      tmp___11 = gettext("%s: cannot open %s\n");
#line 358
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
              Prog, tmp___10);
      }
      {
#line 361
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 361
        tmp___12 = setlocale(6, (char const   *)((void *)0));
#line 361
        old_locale___0 = tmp___12;
#line 361
        saved_locale___0 = (char *)((void *)0);
        }
#line 361
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 361
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 361
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 361
          setlocale(6, "C");
          }
        }
        {
#line 361
        tmp___13 = sgr_dbname();
#line 361
        syslog(4, "cannot open %s", tmp___13);
        }
#line 361
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 361
          setlocale(6, (char const   *)saved_locale___0);
#line 361
          free((void *)saved_locale___0);
          }
        }
#line 361
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 362
      exit(10);
      }
    }
  }
#line 366
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static struct option long_options___12[9]  = 
#line 380
  {      {"force", 0, (int *)((void *)0), 'f'}, 
        {"gid", 1, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"key", 1, (int *)((void *)0), 'K'}, 
        {"non-unique", 0, (int *)((void *)0), 'o'}, 
        {"password", 1, (int *)((void *)0), 'p'}, 
        {"system", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 373 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void process_flags___11(int argc , char **argv ) 
{ 
  char *cp ;
  int c ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 392
    c = getopt_long(argc, (char * const  *)argv, "fg:hK:op:rR:", (struct option  const  *)(long_options___12),
                    (int *)((void *)0));
    }
#line 392
    if (! (c != -1)) {
#line 392
      goto while_break;
    }
    {
#line 395
    if (c == 102) {
#line 395
      goto case_102;
    }
#line 405
    if (c == 103) {
#line 405
      goto case_103;
    }
#line 415
    if (c == 104) {
#line 415
      goto case_104;
    }
#line 418
    if (c == 75) {
#line 418
      goto case_75;
    }
#line 437
    if (c == 111) {
#line 437
      goto case_111;
    }
#line 440
    if (c == 112) {
#line 440
      goto case_112;
    }
#line 444
    if (c == 114) {
#line 444
      goto case_114;
    }
#line 447
    if (c == 82) {
#line 447
      goto case_82;
    }
#line 449
    goto switch_default;
    case_102: /* CIL Label */ 
#line 403
    fflg___1 = (_Bool)1;
#line 404
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 406
    gflg___1 = (_Bool)1;
#line 407
    tmp___0 = get_gid((char const   *)optarg, & group_id___0);
    }
#line 407
    if (tmp___0 == 0) {
      {
#line 409
      tmp = gettext("%s: invalid group ID \'%s\'\n");
#line 409
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 412
      exit(3);
      }
    } else
#line 407
    if (group_id___0 == 4294967295U) {
      {
#line 409
      tmp = gettext("%s: invalid group ID \'%s\'\n");
#line 409
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 412
      exit(3);
      }
    }
#line 414
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 416
    usage___14(0);
    }
#line 417
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 424
    cp = strchr((char const   *)optarg, '=');
    }
#line 425
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 426
      tmp___1 = gettext("%s: -K requires KEY=VALUE\n");
#line 426
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog);
#line 429
      exit(3);
      }
    }
    {
#line 432
    tmp___2 = cp;
#line 432
    cp ++;
#line 432
    *tmp___2 = (char )'\000';
#line 433
    tmp___3 = putdef_str((char const   *)optarg, (char const   *)cp);
    }
#line 433
    if (tmp___3 < 0) {
      {
#line 434
      exit(3);
      }
    }
#line 436
    goto switch_break;
    case_111: /* CIL Label */ 
#line 438
    oflg___1 = (_Bool)1;
#line 439
    goto switch_break;
    case_112: /* CIL Label */ 
#line 441
    pflg___0 = (_Bool)1;
#line 442
    group_passwd = optarg;
#line 443
    goto switch_break;
    case_114: /* CIL Label */ 
#line 445
    rflg___3 = (_Bool)1;
#line 446
    goto switch_break;
    case_82: /* CIL Label */ 
#line 448
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 450
    usage___14(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  if (optind != argc - 1) {
    {
#line 458
    usage___14(2);
    }
  }
  {
#line 460
  group_name___0 = *(argv + optind);
#line 462
  check_flags___4();
  }
#line 463
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void check_flags___4(void) 
{ 
  char *tmp ;
  struct group *tmp___0 ;
  char *tmp___1 ;
  struct group *tmp___2 ;

  {
#line 473
  if (oflg___1) {
#line 473
    if (! gflg___1) {
      {
#line 474
      usage___14(2);
      }
    }
  }
  {
#line 477
  check_new_name();
#line 483
  tmp___0 = getgrnam((char const   *)group_name___0);
  }
#line 483
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 485
    if (fflg___1) {
      {
#line 487
      exit(0);
      }
    }
    {
#line 489
    tmp = gettext("%s: group \'%s\' already exists\n");
#line 489
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, group_name___0);
#line 492
    exit(9);
    }
  }
#line 495
  if (gflg___1) {
    {
#line 495
    tmp___2 = getgrgid(group_id___0);
    }
#line 495
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 502
      if (! oflg___1) {
#line 504
        if (fflg___1) {
#line 506
          gflg___1 = (_Bool)0;
        } else {
          {
#line 508
          tmp___1 = gettext("%s: GID \'%lu\' already exists\n");
#line 508
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                  Prog, (unsigned long )group_id___0);
#line 511
          exit(4);
          }
        }
      }
    }
  }
#line 514
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupadd.c"
static void check_perms___6(void) 
{ 


  {
#line 564
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___16(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___16  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___16  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___16  ;
#line 72
static int copy_entry___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___16(char const   *filename___0 ) ;
#line 83
static int copy_symlink___16(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___16(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___16(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___16(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___16(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___16(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___16 == (unsigned long )ln) {
    {
#line 149
    links___16 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___16;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___16(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___16)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___16)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___16;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___16);
#line 199
  dst_len = strlen(dst_orig___16);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___16, name___3 + src_len);
#line 207
  lp->ln_next = links___16;
#line 208
  links___16 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___16(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___16(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___16(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___16(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___16(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___16(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___16(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___16(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___16(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___16)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___16)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___16(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___16);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___16, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___16);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___16);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___16);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___16, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___16(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___16(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___16(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___16(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___16(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___16(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___16(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___16(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___16(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___16[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___16[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___17(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___17(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___17[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___17[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___17  =    0;
#line 45 "../lib/shadowio.h"
extern struct spwd  const  *spw_next(void) ;
#line 48
extern int spw_rewind(void) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwconv.c"
static _Bool spw_locked___6  =    (_Bool)0;
#line 93 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwconv.c"
static _Bool pw_locked___6  =    (_Bool)0;
#line 96
static void fail_exit___8(int status ) ;
#line 97
static void usage___15(int status ) ;
#line 98
static void process_flags___12(int argc , char **argv ) ;
#line 100 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwconv.c"
static void fail_exit___8(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 102
  if (pw_locked___6) {
    {
#line 103
    tmp___3 = pw_unlock();
    }
#line 103
    if (tmp___3 == 0) {
      {
#line 104
      tmp = pw_dbname();
#line 104
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 105
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 105
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 105
        old_locale = tmp___1;
#line 105
        saved_locale = (char *)((void *)0);
        }
#line 105
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 105
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 105
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 105
          setlocale(6, "C");
          }
        }
        {
#line 105
        tmp___2 = pw_dbname();
#line 105
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 105
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 105
          setlocale(6, (char const   *)saved_locale);
#line 105
          free((void *)saved_locale);
          }
        }
#line 105
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 110
  if (spw_locked___6) {
    {
#line 111
    tmp___8 = spw_unlock();
    }
#line 111
    if (tmp___8 == 0) {
      {
#line 112
      tmp___4 = spw_dbname();
#line 112
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 112
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 113
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 113
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 113
        old_locale___0 = tmp___6;
#line 113
        saved_locale___0 = (char *)((void *)0);
        }
#line 113
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 113
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 113
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 113
          setlocale(6, "C");
          }
        }
        {
#line 113
        tmp___7 = spw_dbname();
#line 113
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 113
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 113
          setlocale(6, (char const   *)saved_locale___0);
#line 113
          free((void *)saved_locale___0);
          }
        }
#line 113
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 118
  exit(status);
  }
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwconv.c"
static void usage___15(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 123
  if (0 != status) {
#line 123
    tmp = stderr;
  } else {
#line 123
    tmp = stdout;
  }
  {
#line 123
  usageout = tmp;
#line 124
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 124
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 129
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 129
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 130
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 130
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 131
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 132
  exit(status);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwconv.c"
static struct option long_options___13[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 140 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/pwconv.c"
static void process_flags___12(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 152
    c = getopt_long(argc, (char * const  *)argv, "hR:", (struct option  const  *)(long_options___13),
                    (int *)((void *)0));
    }
#line 152
    if (! (c != -1)) {
#line 152
      goto while_break;
    }
    {
#line 155
    if (c == 104) {
#line 155
      goto case_104;
    }
#line 158
    if (c == 82) {
#line 158
      goto case_82;
    }
#line 160
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 156
    usage___15(0);
    }
#line 157
    goto switch_break;
    case_82: /* CIL Label */ 
#line 159
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 161
    usage___15(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (optind != argc) {
    {
#line 166
    usage___15(2);
    }
  }
#line 168
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___16(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___17  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___33  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___16(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___33) {
#line 70
      size___33 = i + 100;
#line 71
      if (members___17) {
        {
#line 72
        tmp = realloc((void *)members___17, (unsigned long )size___33 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___33 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___17) {
          {
#line 81
          free((void *)members___17);
          }
        }
#line 82
        members___17 = (char **)0;
#line 83
        size___33 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___17 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___17 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___17 + i) = (char *)0;
#line 99
  return (members___17);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___16  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___34  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___16[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___16  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___17(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___17(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___17  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___17  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___17  ;
#line 72
static int copy_entry___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___17(char const   *filename___0 ) ;
#line 83
static int copy_symlink___17(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___17(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___17(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___17(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___17(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___17(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___17 == (unsigned long )ln) {
    {
#line 149
    links___17 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___17;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___17(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___17)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___17)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___17;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___17);
#line 199
  dst_len = strlen(dst_orig___17);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___17, name___3 + src_len);
#line 207
  lp->ln_next = links___17;
#line 208
  links___17 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___17(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___17(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___17(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___17(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___17(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___17(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___17(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___17(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___17(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___17)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___17)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___17(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___17);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___17, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___17);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___17);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___17);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___17, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___17(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___17(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___17(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___17(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___17(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___17(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___17(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___17(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___17(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___17[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___17[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 879 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 897
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) getdomainname)(char *__name ,
                                                                                                    size_t __len ) ;
#line 227 "../lib/prototypes.h"
int login_access(char const   *user___0 , char const   *from ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 423
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *__domain ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char fs[2]  = {      (char )':',      (char )'\000'};
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char sep[4]  = {      (char )',',      (char )' ',      (char )'\t',      (char )'\000'};
#line 69
static _Bool list_match(char *list___30 , char const   *item , _Bool (*match_fn)(char const   * ,
                                                                                 char const   * ) ) ;
#line 70
static _Bool user_match(char const   *tok , char const   *string ) ;
#line 71
static _Bool from_match(char const   *tok , char const   *string ) ;
#line 72
static _Bool string_match(char const   *tok , char const   *string ) ;
#line 73
static char const   *resolve_hostname(char const   *string ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
int login_access(char const   *user___0 , char const   *from ) 
{ 
  FILE *fp ;
  char line[8192] ;
  char *perm ;
  char *users ;
  char *froms ;
  _Bool match ;
  int lineno ;
  int end ;
  size_t tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  unsigned short const   **tmp___1 ;
  char *old_locale___0 ;
  char *tmp___2 ;
  char *saved_locale___0 ;
  char *tmp___3 ;
  char *old_locale___1 ;
  char *tmp___4 ;
  char *saved_locale___1 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int err ;
  int *tmp___9 ;
  char *old_locale___2 ;
  char *tmp___10 ;
  char *saved_locale___2 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 83
  match = (_Bool)0;
#line 92
  fp = fopen((char const   */* __restrict  */)"/etc/login.access", (char const   */* __restrict  */)"r");
  }
#line 93
  if ((unsigned long )((void *)0) != (unsigned long )fp) {
#line 94
    lineno = 0;
    {
#line 95
    while (1) {
      while_continue: /* CIL Label */ ;
#line 95
      if (! match) {
        {
#line 95
        tmp___8 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
        }
#line 95
        if (! ((unsigned long )tmp___8 == (unsigned long )(line))) {
#line 95
          goto while_break;
        }
      } else {
#line 95
        goto while_break;
      }
      {
#line 98
      lineno ++;
#line 99
      tmp = strlen((char const   *)(line));
#line 99
      end = (int )tmp - 1;
      }
#line 100
      if ((int )line[end] != 10) {
        {
#line 101
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 101
          tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 101
          old_locale = tmp___0;
#line 101
          saved_locale = (char *)((void *)0);
          }
#line 101
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 101
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 101
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 101
            setlocale(6, "C");
            }
          }
          {
#line 101
          syslog(3, "%s: line %d: missing newline or line too long", "/etc/login.access",
                 lineno);
          }
#line 101
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 101
            setlocale(6, (char const   *)saved_locale);
#line 101
            free((void *)saved_locale);
            }
          }
#line 101
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 104
        goto while_continue;
      }
#line 106
      if ((int )line[0] == 35) {
#line 107
        goto while_continue;
      }
      {
#line 109
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 109
        if (end > 0) {
          {
#line 109
          tmp___1 = __ctype_b_loc();
          }
#line 109
          if (! ((int const   )*(*tmp___1 + (int )line[end - 1]) & 8192)) {
#line 109
            goto while_break___1;
          }
        } else {
#line 109
          goto while_break___1;
        }
#line 110
        end --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 112
      line[end] = (char )'\000';
#line 113
      if ((int )line[0] == 0) {
#line 114
        goto while_continue;
      }
      {
#line 116
      perm = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)(fs));
      }
#line 116
      if ((unsigned long )perm == (unsigned long )((void *)0)) {
#line 116
        goto _L;
      } else {
        {
#line 116
        users = strtok((char */* __restrict  */)((char *)0), (char const   */* __restrict  */)(fs));
        }
#line 116
        if ((unsigned long )users == (unsigned long )((void *)0)) {
#line 116
          goto _L;
        } else {
          {
#line 116
          froms = strtok((char */* __restrict  */)((char *)0), (char const   */* __restrict  */)(fs));
          }
#line 116
          if ((unsigned long )froms == (unsigned long )((void *)0)) {
#line 116
            goto _L;
          } else {
            {
#line 116
            tmp___3 = strtok((char */* __restrict  */)((char *)0), (char const   */* __restrict  */)(fs));
            }
#line 116
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
              _L: /* CIL Label */ 
              {
#line 120
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 120
                tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 120
                old_locale___0 = tmp___2;
#line 120
                saved_locale___0 = (char *)((void *)0);
                }
#line 120
                if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
                  {
#line 120
                  saved_locale___0 = strdup((char const   *)old_locale___0);
                  }
                }
#line 120
                if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
                  {
#line 120
                  setlocale(6, "C");
                  }
                }
                {
#line 120
                syslog(3, "%s: line %d: bad field count", "/etc/login.access", lineno);
                }
#line 120
                if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
                  {
#line 120
                  setlocale(6, (char const   *)saved_locale___0);
#line 120
                  free((void *)saved_locale___0);
                  }
                }
#line 120
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 123
              goto while_continue;
            }
          }
        }
      }
#line 125
      if ((int )*(perm + 0) != 43) {
#line 125
        if ((int )*(perm + 0) != 45) {
          {
#line 126
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 126
            tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 126
            old_locale___1 = tmp___4;
#line 126
            saved_locale___1 = (char *)((void *)0);
            }
#line 126
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
              {
#line 126
              saved_locale___1 = strdup((char const   *)old_locale___1);
              }
            }
#line 126
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
              {
#line 126
              setlocale(6, "C");
              }
            }
            {
#line 126
            syslog(3, "%s: line %d: bad first field", "/etc/login.access", lineno);
            }
#line 126
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
              {
#line 126
              setlocale(6, (char const   *)saved_locale___1);
#line 126
              free((void *)saved_locale___1);
              }
            }
#line 126
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 129
          goto while_continue;
        }
      }
      {
#line 131
      tmp___5 = list_match(froms, from, & from_match);
      }
#line 131
      if (tmp___5) {
        {
#line 131
        tmp___6 = list_match(users, user___0, & user_match);
        }
#line 131
        if (tmp___6) {
#line 131
          tmp___7 = 1;
        } else {
#line 131
          tmp___7 = 0;
        }
      } else {
#line 131
        tmp___7 = 0;
      }
#line 131
      match = (_Bool )tmp___7;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 134
    fclose(fp);
    }
  } else {
    {
#line 135
    tmp___12 = __errno_location();
    }
#line 135
    if (*tmp___12 != 2) {
      {
#line 136
      tmp___9 = __errno_location();
#line 136
      err = *tmp___9;
      }
      {
#line 137
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 137
        tmp___10 = setlocale(6, (char const   *)((void *)0));
#line 137
        old_locale___2 = tmp___10;
#line 137
        saved_locale___2 = (char *)((void *)0);
        }
#line 137
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 137
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 137
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 137
          setlocale(6, "C");
          }
        }
        {
#line 137
        tmp___11 = strerror(err);
#line 137
        syslog(3, "cannot open %s: %s", "/etc/login.access", tmp___11);
        }
#line 137
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 137
          setlocale(6, (char const   *)saved_locale___2);
#line 137
          free((void *)saved_locale___2);
          }
        }
#line 137
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 139
  if (! match) {
#line 139
    tmp___13 = 1;
  } else
#line 139
  if ((int )line[0] == 43) {
#line 139
    tmp___13 = 1;
  } else {
#line 139
    tmp___13 = 0;
  }
#line 139
  return (tmp___13);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static _Bool list_match(char *list___30 , char const   *item , _Bool (*match_fn)(char const   * ,
                                                                                 char const   * ) ) 
{ 
  char *tok ;
  _Bool match ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 146
  match = (_Bool)0;
#line 154
  tok = strtok((char */* __restrict  */)list___30, (char const   */* __restrict  */)(sep));
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )tok != (unsigned long )((void *)0))) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp = strcasecmp((char const   *)tok, "EXCEPT");
    }
#line 155
    if (tmp == 0) {
#line 156
      goto while_break;
    }
    {
#line 158
    match = (*match_fn)((char const   *)tok, item);
    }
#line 159
    if (match) {
#line 160
      goto while_break;
    }
    {
#line 154
    tok = strtok((char */* __restrict  */)((char *)0), (char const   */* __restrict  */)(sep));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (match) {
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 166
      tok = strtok((char */* __restrict  */)((char *)0), (char const   */* __restrict  */)(sep));
      }
#line 166
      if ((unsigned long )tok != (unsigned long )((void *)0)) {
        {
#line 166
        tmp___0 = strcasecmp((char const   *)tok, "EXCEPT");
        }
#line 166
        if (! (tmp___0 != 0)) {
#line 166
          goto while_break___0;
        }
      } else {
#line 166
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    if ((unsigned long )tok == (unsigned long )((char *)0)) {
#line 170
      return (match);
    } else {
      {
#line 169
      tmp___1 = list_match((char *)0, item, match_fn);
      }
#line 169
      if (! tmp___1) {
#line 170
        return (match);
      }
    }
  }
#line 173
  return ((_Bool)0);
}
}
#line 179
static char *myhostname(void) ;
#line 179 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char name___1[257]  = {      (char )'\000'};
#line 177 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char *myhostname(void) 
{ 


  {
#line 181
  if ((int )name___1[0] == 0) {
    {
#line 182
    gethostname(name___1, sizeof(name___1));
#line 183
    name___1[256] = (char )'\000';
    }
  }
#line 185
  return (name___1);
}
}
#line 193
static _Bool netgroup_match(char const   *group___0 , char const   *machine , char const   *user___0 ) ;
#line 193 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char *mydomain  =    (char *)0;
#line 196 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char domain[257]  ;
#line 190 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static _Bool netgroup_match(char const   *group___0 , char const   *machine , char const   *user___0 ) 
{ 
  int tmp ;

  {
#line 195
  if ((unsigned long )mydomain == (unsigned long )((char *)0)) {
    {
#line 198
    getdomainname(domain, (size_t )256);
#line 199
    mydomain = domain;
    }
  }
  {
#line 202
  tmp = innetgr(group___0, machine, user___0, (char const   *)mydomain);
  }
#line 202
  return ((_Bool )(tmp != 0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static _Bool user_match(char const   *tok , char const   *string ) 
{ 
  struct group *group___0 ;
  char *at ;
  _Bool tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int i ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 221
  at = strchr(tok + 1, '@');
  }
#line 222
  if ((unsigned long )((void *)0) != (unsigned long )at) {
    {
#line 223
    *at = (char )'\000';
#line 224
    tmp = user_match(tok, string);
    }
#line 224
    if (tmp) {
      {
#line 224
      tmp___0 = myhostname();
#line 224
      tmp___1 = from_match((char const   *)(at + 1), (char const   *)tmp___0);
      }
#line 224
      if (tmp___1) {
#line 224
        tmp___2 = 1;
      } else {
#line 224
        tmp___2 = 0;
      }
    } else {
#line 224
      tmp___2 = 0;
    }
#line 224
    return ((_Bool )tmp___2);
  } else
#line 227
  if ((int const   )*(tok + 0) == 64) {
    {
#line 228
    tmp___3 = netgroup_match(tok + 1, (char const   *)((char *)0), string);
    }
#line 228
    return (tmp___3);
  } else {
    {
#line 230
    tmp___5 = string_match(tok, string);
    }
#line 230
    if (tmp___5) {
#line 231
      return ((_Bool)1);
    } else {
      {
#line 233
      group___0 = getgrnam(tok);
      }
#line 233
      if ((unsigned long )group___0 != (unsigned long )((void *)0)) {
#line 235
        i = 0;
        {
#line 235
        while (1) {
          while_continue: /* CIL Label */ ;
#line 235
          if (! ((unsigned long )((void *)0) != (unsigned long )*(group___0->gr_mem + i))) {
#line 235
            goto while_break;
          }
          {
#line 236
          tmp___4 = strcasecmp(string, (char const   *)*(group___0->gr_mem + i));
          }
#line 236
          if (tmp___4 == 0) {
#line 237
            return ((_Bool)1);
          }
#line 235
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 258
  return ((_Bool)0);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static char const   *resolve_hostname(char const   *string ) 
{ 
  struct hostent *hp ;
  char *tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;

  {
  {
#line 269
  hp = gethostbyname(string);
  }
#line 270
  if ((unsigned long )((void *)0) != (unsigned long )hp) {
    {
#line 271
    tmp = inet_ntoa(*((struct in_addr *)*(hp->h_addr_list)));
    }
#line 271
    return ((char const   *)tmp);
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 274
    tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 274
    old_locale = tmp___0;
#line 274
    saved_locale = (char *)((void *)0);
    }
#line 274
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 274
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 274
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 274
      setlocale(6, "C");
      }
    }
    {
#line 274
    syslog(3, "%s - unknown host", string);
    }
#line 274
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 274
      setlocale(6, (char const   *)saved_locale);
#line 274
      free((void *)saved_locale);
      }
    }
#line 274
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return (string);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static _Bool from_match(char const   *tok , char const   *string ) 
{ 
  size_t tok_len ;
  _Bool tmp ;
  size_t str_len ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
#line 293
  if ((int const   )*(tok + 0) == 64) {
    {
#line 294
    tmp = netgroup_match(tok + 1, string, (char const   *)((char *)0));
    }
#line 294
    return (tmp);
  } else {
    {
#line 297
    tmp___5 = string_match(tok, string);
    }
#line 297
    if (tmp___5) {
#line 298
      return ((_Bool)1);
    } else
#line 299
    if ((int const   )*(tok + 0) == 46) {
      {
#line 301
      str_len = strlen(string);
#line 302
      tok_len = strlen(tok);
      }
#line 303
      if (str_len > tok_len) {
        {
#line 303
        tmp___0 = strcasecmp(tok, (string + str_len) - tok_len);
        }
#line 303
        if (tmp___0 == 0) {
#line 305
          return ((_Bool)1);
        }
      }
    } else {
      {
#line 307
      tmp___4 = strcasecmp(tok, "LOCAL");
      }
#line 307
      if (tmp___4 == 0) {
        {
#line 308
        tmp___1 = strchr(string, '.');
        }
#line 308
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 309
          return ((_Bool)1);
        }
      } else {
        {
#line 311
        tok_len = strlen(tok);
        }
#line 311
        if ((int const   )*(tok + (tok_len - 1UL)) == 46) {
          {
#line 311
          tmp___2 = resolve_hostname(string);
#line 311
          tmp___3 = strncmp(tok, tmp___2, tok_len);
          }
#line 311
          if (tmp___3 == 0) {
#line 313
            return ((_Bool)1);
          }
        }
      }
    }
  }
#line 315
  return ((_Bool)0);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login_nopam.c"
static _Bool string_match(char const   *tok , char const   *string ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 326
  tmp___0 = strcasecmp(tok, "ALL");
  }
#line 326
  if (tmp___0 == 0) {
#line 327
    return ((_Bool)1);
  } else {
    {
#line 328
    tmp = strcasecmp(tok, string);
    }
#line 328
    if (tmp == 0) {
#line 329
      return ((_Bool)1);
    }
  }
#line 331
  return ((_Bool)0);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___18(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___18(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___18  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___18  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___18  ;
#line 72
static int copy_entry___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___18(char const   *filename___0 ) ;
#line 83
static int copy_symlink___18(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___18(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___18(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___18(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___18(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___18(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___18 == (unsigned long )ln) {
    {
#line 149
    links___18 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___18;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___18(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___18)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___18)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___18;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___18);
#line 199
  dst_len = strlen(dst_orig___18);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___18, name___3 + src_len);
#line 207
  lp->ln_next = links___18;
#line 208
  links___18 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___18(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___18(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___18(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___18(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___18(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___18(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___18(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___18(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___18(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___18)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___18)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___18(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___18);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___18, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___18);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___18);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___18);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___18, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___18(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___18(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___18(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___18(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___18(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___18(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___18(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___18(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___18(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/tz.c"
static char tzbuf___0[8192]  ;
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___18(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___18(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___18[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___18[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 150 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 37 "../lib/getdef.h"
extern long getdef_long(char const   * , long  ) ;
#line 40
extern unsigned int getdef_unum(char const   * , unsigned int  ) ;
#line 190 "../lib/prototypes.h"
extern _Bool hushed(char const   *username ) ;
#line 220
extern void dolastlog(struct lastlog *ll , struct passwd  const  *pw , char const   *line ,
                      char const   *host ) ;
#line 230
extern void login_prompt(char const   * , char * , int  ) ;
#line 233
extern void mailcheck(void) ;
#line 236
extern void motd(void) ;
#line 287
extern int do_rlogin(char const   *remote_host , char *name , size_t namelen , char *term ,
                     size_t termlen ) ;
#line 347
extern void spw_free(struct spwd *spent ) ;
#line 374
extern void ttytype(char const   * ) ;
#line 388
extern struct utmp *get_current_utmp(void) ;
#line 389
extern struct utmp *prepare_utmp(char const   *name , char const   *line , char const   *host ,
                                 struct utmp  const  *ut ) ;
#line 393
extern int setutmp(struct utmp *ut ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static char const   *hostname  =    "";
#line 88 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static char *username  =    (char *)((void *)0);
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static int reason  =    2;
#line 92 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static struct lastlog ll  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static _Bool pflg___1  =    (_Bool)0;
#line 95 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static _Bool fflg___2  =    (_Bool)0;
#line 98 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static _Bool rflg___4  =    (_Bool)0;
#line 102 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static _Bool hflg  =    (_Bool)0;
#line 103 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static _Bool preauth_flag  =    (_Bool)0;
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static _Bool amroot___0  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static unsigned int timeout  ;
#line 125
static void usage___16(void) ;
#line 126
static void setup_tty(void) ;
#line 127
static void process_flags___13(int argc , char * const  *argv ) ;
#line 128
static char const   *get_failent_user(char const   *user___0 ) ;
#line 129
static void update_utmp(char const   *user___0 , char const   *tty , char const   *host ,
                        struct utmp  const  *utent ) ;
#line 135 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static struct faillog faillog  ;
#line 137
static void bad_time_notify(void) ;
#line 138
static void check_nologin(_Bool login_to_root ) ;
#line 143
static void init_env(void) ;
#line 144
static void alarm_handler(int sig  __attribute__((__unused__)) ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void usage___16(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 156
  tmp = gettext("Usage: %s [-p] [name]\n");
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, Prog);
  }
#line 157
  if (! amroot___0) {
    {
#line 158
    exit(1);
    }
  }
  {
#line 160
  tmp___0 = gettext("       %s [-p] [-h host] [-f name]\n");
#line 160
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 162
  tmp___1 = gettext("       %s [-p] -r host\n");
#line 162
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
          Prog);
#line 164
  exit(1);
  }
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void setup_tty(void) 
{ 
  struct termios termio ;
  int erasechar ;
  int killchar ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 171
  tmp___1 = tcgetattr(0, & termio);
  }
#line 171
  if (tmp___1 == 0) {
    {
#line 178
    termio.c_lflag |= 27U;
#line 179
    termio.c_iflag |= 256U;
#line 182
    termio.c_lflag |= 2560U;
#line 185
    termio.c_lflag &= 4294965887U;
#line 188
    termio.c_oflag |= 4U;
#line 192
    erasechar = getdef_num("ERASECHAR", (int )termio.c_cc[2]);
#line 193
    killchar = getdef_num("KILLCHAR", (int )termio.c_cc[3]);
#line 194
    termio.c_cc[2] = (cc_t )erasechar;
#line 195
    termio.c_cc[3] = (cc_t )killchar;
    }
#line 199
    if (erasechar != (int )termio.c_cc[2]) {
      {
#line 200
      tmp = gettext("configuration error - cannot parse %s value: \'%d\'");
#line 200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              "ERASECHAR", erasechar);
#line 203
      exit(1);
      }
    }
#line 205
    if (killchar != (int )termio.c_cc[3]) {
      {
#line 206
      tmp___0 = gettext("configuration error - cannot parse %s value: \'%d\'");
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              "KILLCHAR", killchar);
#line 209
      exit(1);
      }
    }
    {
#line 216
    tcsetattr(0, 0, (struct termios  const  *)(& termio));
    }
  }
#line 218
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void bad_time_notify(void) 
{ 
  char *tmp ;

  {
  {
#line 227
  tmp = gettext("Invalid login time");
#line 227
  puts((char const   *)tmp);
#line 228
  fflush(stdout);
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void check_nologin(_Bool login_to_root ) 
{ 
  char *fname ;
  char const   *tmp ;
  FILE *nlfp ;
  int c ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 242
  tmp = getdef_str("NOLOGINS_FILE");
#line 242
  fname = (char *)tmp;
  }
#line 243
  if ((unsigned long )((void *)0) != (unsigned long )fname) {
    {
#line 243
    tmp___2 = access((char const   *)fname, 0);
    }
#line 243
    if (tmp___2 == 0) {
      {
#line 250
      nlfp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
      }
#line 251
      if ((unsigned long )((void *)0) != (unsigned long )nlfp) {
        {
#line 253
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 253
          c = _IO_getc(nlfp);
          }
#line 253
          if (! (c != -1)) {
#line 253
            goto while_break;
          }
#line 254
          if (c == 10) {
            {
#line 255
            putchar('\r');
            }
          }
          {
#line 258
          putchar(c);
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 260
        fflush(stdout);
#line 261
        fclose(nlfp);
        }
      } else {
        {
#line 263
        tmp___0 = gettext("\nSystem closed for routine maintenance");
#line 263
        puts((char const   *)tmp___0);
        }
      }
#line 270
      if (! login_to_root) {
        {
#line 271
        closelog();
#line 272
        exit(0);
        }
      }
      {
#line 274
      tmp___1 = gettext("\n[Disconnect bypassed -- root login allowed.]");
#line 274
      puts((char const   *)tmp___1);
      }
    }
  }
#line 276
  return;
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void process_flags___13(int argc , char * const  *argv ) 
{ 
  int arg ;
  int flag ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 289
  arg = 1;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (arg < argc)) {
#line 289
      goto while_break;
    }
#line 290
    if ((int )*(*(argv + arg) + 0) == 45) {
      {
#line 290
      tmp = strlen((char const   *)*(argv + arg));
      }
#line 290
      if (tmp > 2UL) {
        {
#line 291
        usage___16();
        }
      }
    }
    {
#line 293
    tmp___0 = strcmp((char const   *)*(argv + arg), "--");
    }
#line 293
    if (tmp___0 == 0) {
#line 294
      goto while_break;
    }
#line 289
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 301
    flag = getopt(argc, argv, "d:fh:pr:");
    }
#line 301
    if (! (flag != -1)) {
#line 301
      goto while_break___0;
    }
    {
#line 303
    if (flag == 100) {
#line 303
      goto case_100;
    }
#line 306
    if (flag == 102) {
#line 306
      goto case_102;
    }
#line 309
    if (flag == 104) {
#line 309
      goto case_104;
    }
#line 315
    if (flag == 114) {
#line 315
      goto case_114;
    }
#line 321
    if (flag == 112) {
#line 321
      goto case_112;
    }
#line 324
    goto switch_default;
    case_100: /* CIL Label */ 
#line 305
    goto switch_break;
    case_102: /* CIL Label */ 
#line 307
    fflg___2 = (_Bool)1;
#line 308
    goto switch_break;
    case_104: /* CIL Label */ 
#line 310
    hflg = (_Bool)1;
#line 311
    hostname = (char const   *)optarg;
#line 312
    reason = 201;
#line 313
    goto switch_break;
    case_114: /* CIL Label */ 
#line 316
    rflg___4 = (_Bool)1;
#line 317
    hostname = (char const   *)optarg;
#line 318
    reason = 202;
#line 319
    goto switch_break;
    case_112: /* CIL Label */ 
#line 322
    pflg___1 = (_Bool)1;
#line 323
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 325
    usage___16();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 334
  if (rflg___4) {
#line 334
    if (hflg) {
      {
#line 335
      usage___16();
      }
    } else
#line 334
    if (fflg___2) {
      {
#line 335
      usage___16();
      }
    }
  }
#line 343
  if (rflg___4) {
#line 343
    goto _L;
  } else
#line 343
  if (fflg___2) {
#line 343
    goto _L;
  } else
#line 343
  if (hflg) {
    _L: /* CIL Label */ 
#line 343
    if (! amroot___0) {
      {
#line 344
      tmp___1 = gettext("%s: Permission denied.\n");
#line 344
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog);
#line 345
      exit(1);
      }
    }
  }
#line 351
  if (optind < argc) {
#line 352
    if (! ((unsigned long )((void *)0) == (unsigned long )username)) {
      {
#line 352
      __assert_fail("((void *)0) == username", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c",
                    352U, "process_flags");
      }
    }
    {
#line 353
    username = xstrdup((char const   *)*(argv + optind));
#line 354
    tmp___2 = strlen((char const   *)*(argv + optind));
#line 354
    memset((void *)*(argv + optind), 0, tmp___2);
#line 355
    optind ++;
    }
  }
#line 359
  if (rflg___4) {
#line 359
    if ((unsigned long )((void *)0) != (unsigned long )username) {
      {
#line 360
      usage___16();
      }
    }
  }
#line 363
  if (fflg___2) {
#line 363
    if ((unsigned long )((void *)0) == (unsigned long )username) {
      {
#line 364
      usage___16();
      }
    }
  }
#line 367
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void init_env(void) 
{ 
  char *cp ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 377
  tmp = getenv("LANG");
  }
#line 378
  if ((unsigned long )((void *)0) != (unsigned long )tmp) {
    {
#line 379
    addenv("LANG", (char const   *)tmp);
    }
  }
  {
#line 386
  tmp = getenv("TZ");
  }
#line 387
  if ((unsigned long )((void *)0) != (unsigned long )tmp) {
    {
#line 388
    addenv("TZ", (char const   *)tmp);
    }
  } else {
    {
#line 392
    tmp___0 = getdef_str("ENV_TZ");
#line 392
    cp = (char *)tmp___0;
    }
#line 393
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 394
      if (47 == (int )*cp) {
        {
#line 394
        tmp___1 = tz((char const   *)cp);
#line 394
        tmp___2 = tmp___1;
        }
      } else {
#line 394
        tmp___2 = (char const   *)cp;
      }
      {
#line 394
      addenv(tmp___2, (char const   *)((void *)0));
      }
    }
  }
  {
#line 402
  tmp = getenv("HZ");
  }
#line 403
  if ((unsigned long )((void *)0) != (unsigned long )tmp) {
    {
#line 404
    addenv("HZ", (char const   *)tmp);
    }
  } else {
    {
#line 408
    tmp___3 = getdef_str("ENV_HZ");
#line 408
    cp = (char *)tmp___3;
    }
#line 409
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
      {
#line 410
      addenv((char const   *)cp, (char const   *)((void *)0));
      }
    }
  }
#line 414
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void alarm_handler(int sig  __attribute__((__unused__)) ) 
{ 
  char *tmp ;

  {
  {
#line 419
  tmp = gettext("\nLogin timed out after %u seconds.\n");
#line 419
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, timeout);
#line 420
  exit(0);
  }
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static char const   *get_failent_user(char const   *user___0 ) 
{ 
  char const   *failent_user ;
  _Bool log_unkfail_enab ;
  _Bool tmp ;
  struct passwd *tmp___0 ;

  {
  {
#line 461
  failent_user = "UNKNOWN";
#line 462
  tmp = getdef_bool("LOG_UNKFAIL_ENAB");
#line 462
  log_unkfail_enab = tmp;
  }
#line 464
  if ((unsigned long )((void *)0) != (unsigned long )user___0) {
#line 464
    if (0 != (int )*(user___0 + 0)) {
#line 465
      if (log_unkfail_enab) {
#line 467
        failent_user = user___0;
      } else {
        {
#line 465
        tmp___0 = getpwnam(user___0);
        }
#line 465
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 467
          failent_user = user___0;
        }
      }
    }
  }
#line 471
  return (failent_user);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/login.c"
static void update_utmp(char const   *user___0 , char const   *tty , char const   *host ,
                        struct utmp  const  *utent ) 
{ 
  struct utmp *ut ;
  struct utmp *tmp ;

  {
  {
#line 486
  tmp = prepare_utmp(user___0, tty, host, utent);
#line 486
  ut = tmp;
#line 491
  setutmp(ut);
#line 492
  free((void *)ut);
  }
#line 498
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___18[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___18[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___18  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___19(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___19(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___19[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___19[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___19  =    0;
#line 353 "../lib/prototypes.h"
extern int run_command(char const   *cmd , char const   **argv , char const   **envp ,
                       int *status ) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static char *user_name___2  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static uid_t user_id___1  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static gid_t user_gid___1  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static char *user_home___1  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool fflg___3  =    (_Bool)0;
#line 90 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool rflg___5  =    (_Bool)0;
#line 93 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool is_shadow_pwd___2  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool is_shadow_grp___5  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool sgr_locked___4  =    (_Bool)0;
#line 99 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool pw_locked___7  =    (_Bool)0;
#line 100 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool gr_locked___4  =    (_Bool)0;
#line 101 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static _Bool spw_locked___7  =    (_Bool)0;
#line 104
static void usage___17(int status ) ;
#line 105
static void update_groups(void) ;
#line 106
static void remove_usergroup(void) ;
#line 107
static void close_files___9(void) ;
#line 108
static void fail_exit___9(int code ) ;
#line 109
static void open_files___9(void) ;
#line 110
static void update_user(void) ;
#line 111
static void user_cancel(char const   *user___0 ) ;
#line 116
static int is_owner(uid_t uid , char const   *path ) ;
#line 117
static int remove_mailbox(void) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void usage___17(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 127
  if (0 != status) {
#line 127
    tmp = stderr;
  } else {
#line 127
    tmp = stdout;
  }
  {
#line 127
  usageout = tmp;
#line 128
  tmp___0 = gettext("Usage: %s [options] LOGIN\n\nOptions:\n");
#line 128
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 133
  tmp___1 = gettext("  -f, --force                   force removal of files,\n                                even if not owned by user\n");
#line 133
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 136
  tmp___2 = gettext("  -h, --help                    display this help message and exit\n");
#line 136
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 137
  tmp___3 = gettext("  -r, --remove                  remove home directory and mail spool\n");
#line 137
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 138
  tmp___4 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 138
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 142
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 143
  exit(status);
  }
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void update_groups(void) 
{ 
  struct group  const  *grp ;
  struct group *ngrp ;
  struct sgrp  const  *sgrp ;
  struct sgrp *nsgrp ;
  _Bool tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *old_locale ;
  char *tmp___5 ;
  char *saved_locale ;
  _Bool tmp___6 ;
  _Bool was_member ;
  _Bool was_admin ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *old_locale___0 ;
  char *tmp___12 ;
  char *saved_locale___0 ;

  {
  {
#line 170
  gr_rewind();
#line 170
  grp = gr_next();
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )((void *)0) != (unsigned long )grp)) {
#line 170
      goto while_break;
    }
    {
#line 176
    tmp = is_on_list((char * const  *)grp->gr_mem, (char const   *)user_name___2);
    }
#line 176
    if (! tmp) {
#line 177
      goto __Cont;
    }
    {
#line 184
    ngrp = __gr_dup(grp);
    }
#line 185
    if ((unsigned long )((void *)0) == (unsigned long )ngrp) {
      {
#line 186
      tmp___0 = gr_dbname();
#line 186
      tmp___1 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog, tmp___0);
#line 189
      exit(13);
      }
    }
    {
#line 191
    ngrp->gr_mem = del_list(ngrp->gr_mem, (char const   *)user_name___2);
#line 192
    tmp___4 = gr_update((struct group  const  *)ngrp);
    }
#line 192
    if (tmp___4 == 0) {
      {
#line 193
      tmp___2 = gr_dbname();
#line 193
      tmp___3 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 193
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, tmp___2, ngrp->gr_name);
#line 196
      exit(10);
      }
    }
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 208
      tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 208
      old_locale = tmp___5;
#line 208
      saved_locale = (char *)((void *)0);
      }
#line 208
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 208
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 208
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 208
        setlocale(6, "C");
        }
      }
      {
#line 208
      syslog(6, "delete \'%s\' from group \'%s\'\n", user_name___2, ngrp->gr_name);
      }
#line 208
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 208
        setlocale(6, (char const   *)saved_locale);
#line 208
        free((void *)saved_locale);
        }
      }
#line 208
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
    {
#line 170
    grp = gr_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  tmp___6 = getdef_bool("USERGROUPS_ENAB");
  }
#line 212
  if (tmp___6) {
    {
#line 213
    remove_usergroup();
    }
  }
#line 217
  if (! is_shadow_grp___5) {
#line 218
    return;
  }
  {
#line 226
  sgr_rewind();
#line 226
  sgrp = sgr_next();
  }
  {
#line 226
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 226
    if (! ((unsigned long )((void *)0) != (unsigned long )sgrp)) {
#line 226
      goto while_break___1;
    }
    {
#line 235
    was_member = is_on_list((char * const  *)sgrp->sg_mem, (char const   *)user_name___2);
#line 236
    was_admin = is_on_list((char * const  *)sgrp->sg_adm, (char const   *)user_name___2);
    }
#line 238
    if (! was_member) {
#line 238
      if (! was_admin) {
#line 239
        goto __Cont___0;
      }
    }
    {
#line 242
    nsgrp = __sgr_dup(sgrp);
    }
#line 243
    if ((unsigned long )((void *)0) == (unsigned long )nsgrp) {
      {
#line 244
      tmp___7 = sgr_dbname();
#line 244
      tmp___8 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 244
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7);
#line 247
      exit(13);
      }
    }
#line 250
    if (was_member) {
      {
#line 251
      nsgrp->sg_mem = del_list(nsgrp->sg_mem, (char const   *)user_name___2);
      }
    }
#line 254
    if (was_admin) {
      {
#line 255
      nsgrp->sg_adm = del_list(nsgrp->sg_adm, (char const   *)user_name___2);
      }
    }
    {
#line 258
    tmp___11 = sgr_update((struct sgrp  const  *)nsgrp);
    }
#line 258
    if (tmp___11 == 0) {
      {
#line 259
      tmp___9 = sgr_dbname();
#line 259
      tmp___10 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 259
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9, nsgrp->sg_name);
#line 262
      exit(10);
      }
    }
    {
#line 270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 270
      tmp___12 = setlocale(6, (char const   *)((void *)0));
#line 270
      old_locale___0 = tmp___12;
#line 270
      saved_locale___0 = (char *)((void *)0);
      }
#line 270
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 270
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 270
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 270
        setlocale(6, "C");
        }
      }
      {
#line 270
      syslog(6, "delete \'%s\' from shadow group \'%s\'\n", user_name___2, nsgrp->sg_name);
      }
#line 270
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 270
        setlocale(6, (char const   *)saved_locale___0);
#line 270
        free((void *)saved_locale___0);
        }
      }
#line 270
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
    {
#line 226
    sgrp = sgr_next();
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void remove_usergroup(void) 
{ 
  struct group  const  *grp ;
  struct passwd  const  *pwd ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  struct passwd *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *old_locale ;
  char *tmp___7 ;
  char *saved_locale ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *old_locale___0 ;
  char *tmp___11 ;
  char *saved_locale___0 ;
  struct sgrp  const  *tmp___12 ;

  {
  {
#line 288
  pwd = (struct passwd  const  *)((void *)0);
#line 290
  grp = gr_locate((char const   *)user_name___2);
  }
#line 291
  if ((unsigned long )((void *)0) == (unsigned long )grp) {
#line 293
    return;
  }
#line 296
  if (grp->gr_gid != (__gid_t const   )user_gid___1) {
    {
#line 297
    tmp = gettext("%s: group %s not removed because it is not the primary group of user %s.\n");
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, grp->gr_name, user_name___2);
    }
#line 300
    return;
  }
#line 303
  if ((unsigned long )((void *)0) != (unsigned long )*(grp->gr_mem + 0)) {
    {
#line 305
    tmp___0 = gettext("%s: group %s not removed because it has other members.\n");
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, grp->gr_name);
    }
#line 308
    return;
  }
#line 311
  if (! fflg___3) {
    {
#line 316
    setpwent();
    }
    {
#line 317
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 317
      tmp___3 = getpwent();
#line 317
      pwd = (struct passwd  const  *)tmp___3;
      }
#line 317
      if (! ((unsigned long )pwd != (unsigned long )((void *)0))) {
#line 317
        goto while_break;
      }
      {
#line 318
      tmp___1 = strcmp((char const   *)pwd->pw_name, (char const   *)user_name___2);
      }
#line 318
      if (tmp___1 == 0) {
#line 319
        goto while_continue;
      }
#line 321
      if (pwd->pw_gid == grp->gr_gid) {
        {
#line 322
        tmp___2 = gettext("%s: group %s is the primary group of another user and is not removed.\n");
#line 322
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                Prog, grp->gr_name);
        }
#line 325
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 328
    endpwent();
    }
  }
#line 331
  if ((unsigned long )((void *)0) == (unsigned long )pwd) {
    {
#line 336
    tmp___6 = gr_remove((char const   *)user_name___2);
    }
#line 336
    if (tmp___6 == 0) {
      {
#line 337
      tmp___4 = gr_dbname();
#line 337
      tmp___5 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 337
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, user_name___2, tmp___4);
#line 340
      fail_exit___9(10);
      }
    }
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 349
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 349
      old_locale = tmp___7;
#line 349
      saved_locale = (char *)((void *)0);
      }
#line 349
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 349
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 349
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 349
        setlocale(6, "C");
        }
      }
      {
#line 349
      syslog(6, "removed group \'%s\' owned by \'%s\'\n", user_name___2, user_name___2);
      }
#line 349
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 349
        setlocale(6, (char const   *)saved_locale);
#line 349
        free((void *)saved_locale);
        }
      }
#line 349
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 354
    tmp___12 = sgr_locate((char const   *)user_name___2);
    }
#line 354
    if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
      {
#line 355
      tmp___10 = sgr_remove((char const   *)user_name___2);
      }
#line 355
      if (tmp___10 == 0) {
        {
#line 356
        tmp___8 = sgr_dbname();
#line 356
        tmp___9 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 356
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
                Prog, user_name___2, tmp___8);
#line 359
        fail_exit___9(10);
        }
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 367
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 367
        old_locale___0 = tmp___11;
#line 367
        saved_locale___0 = (char *)((void *)0);
        }
#line 367
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 367
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 367
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 367
          setlocale(6, "C");
          }
        }
        {
#line 367
        syslog(6, "removed shadow group \'%s\' owned by \'%s\'\n", user_name___2,
               user_name___2);
        }
#line 367
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 367
          setlocale(6, (char const   *)saved_locale___0);
#line 367
          free((void *)saved_locale___0);
          }
        }
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 374
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void close_files___9(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *old_locale___3 ;
  char *tmp___21 ;
  char *saved_locale___3 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  char *tmp___25 ;
  char *old_locale___4 ;
  char *tmp___26 ;
  char *saved_locale___4 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char *old_locale___5 ;
  char *tmp___31 ;
  char *saved_locale___5 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  char *old_locale___6 ;
  char *tmp___36 ;
  char *saved_locale___6 ;
  char const   *tmp___37 ;
  int tmp___38 ;

  {
  {
#line 384
  tmp___3 = pw_close();
  }
#line 384
  if (tmp___3 == 0) {
    {
#line 385
    tmp = pw_dbname();
#line 385
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 386
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 386
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 386
      old_locale = tmp___1;
#line 386
      saved_locale = (char *)((void *)0);
      }
#line 386
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 386
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 386
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 386
        setlocale(6, "C");
        }
      }
      {
#line 386
      tmp___2 = pw_dbname();
#line 386
      syslog(3, "failure while writing changes to %s", tmp___2);
      }
#line 386
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 386
        setlocale(6, (char const   *)saved_locale);
#line 386
        free((void *)saved_locale);
        }
      }
#line 386
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 387
    fail_exit___9(1);
    }
  }
  {
#line 389
  tmp___8 = pw_unlock();
  }
#line 389
  if (tmp___8 == 0) {
    {
#line 390
    tmp___4 = pw_dbname();
#line 390
    tmp___5 = gettext("%s: failed to unlock %s\n");
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            Prog, tmp___4);
    }
    {
#line 391
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 391
      tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 391
      old_locale___0 = tmp___6;
#line 391
      saved_locale___0 = (char *)((void *)0);
      }
#line 391
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 391
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 391
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 391
        setlocale(6, "C");
        }
      }
      {
#line 391
      tmp___7 = pw_dbname();
#line 391
      syslog(3, "failed to unlock %s", tmp___7);
      }
#line 391
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 391
        setlocale(6, (char const   *)saved_locale___0);
#line 391
        free((void *)saved_locale___0);
        }
      }
#line 391
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 394
  pw_locked___7 = (_Bool)0;
#line 396
  if (is_shadow_pwd___2) {
    {
#line 397
    tmp___13 = spw_close();
    }
#line 397
    if (tmp___13 == 0) {
      {
#line 398
      tmp___9 = spw_dbname();
#line 398
      tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 398
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 400
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 400
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 400
        old_locale___1 = tmp___11;
#line 400
        saved_locale___1 = (char *)((void *)0);
        }
#line 400
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 400
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 400
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 400
          setlocale(6, "C");
          }
        }
        {
#line 400
        tmp___12 = spw_dbname();
#line 400
        syslog(3, "failure while writing changes to %s", tmp___12);
        }
#line 400
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 400
          setlocale(6, (char const   *)saved_locale___1);
#line 400
          free((void *)saved_locale___1);
          }
        }
#line 400
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 401
      fail_exit___9(1);
      }
    }
    {
#line 403
    tmp___18 = spw_unlock();
    }
#line 403
    if (tmp___18 == 0) {
      {
#line 404
      tmp___14 = spw_dbname();
#line 404
      tmp___15 = gettext("%s: failed to unlock %s\n");
#line 404
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
      }
      {
#line 405
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 405
        tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 405
        old_locale___2 = tmp___16;
#line 405
        saved_locale___2 = (char *)((void *)0);
        }
#line 405
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 405
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 405
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 405
          setlocale(6, "C");
          }
        }
        {
#line 405
        tmp___17 = spw_dbname();
#line 405
        syslog(3, "failed to unlock %s", tmp___17);
        }
#line 405
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 405
          setlocale(6, (char const   *)saved_locale___2);
#line 405
          free((void *)saved_locale___2);
          }
        }
#line 405
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 408
    spw_locked___7 = (_Bool)0;
  }
  {
#line 411
  tmp___23 = gr_close();
  }
#line 411
  if (tmp___23 == 0) {
    {
#line 412
    tmp___19 = gr_dbname();
#line 412
    tmp___20 = gettext("%s: failure while writing changes to %s\n");
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
            Prog, tmp___19);
    }
    {
#line 413
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 413
      tmp___21 = setlocale(6, (char const   *)((void *)0));
#line 413
      old_locale___3 = tmp___21;
#line 413
      saved_locale___3 = (char *)((void *)0);
      }
#line 413
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___3) {
        {
#line 413
        saved_locale___3 = strdup((char const   *)old_locale___3);
        }
      }
#line 413
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
        {
#line 413
        setlocale(6, "C");
        }
      }
      {
#line 413
      tmp___22 = gr_dbname();
#line 413
      syslog(3, "failure while writing changes to %s", tmp___22);
      }
#line 413
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___3) {
        {
#line 413
        setlocale(6, (char const   *)saved_locale___3);
#line 413
        free((void *)saved_locale___3);
        }
      }
#line 413
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 414
    fail_exit___9(10);
    }
  }
  {
#line 416
  tmp___28 = gr_unlock();
  }
#line 416
  if (tmp___28 == 0) {
    {
#line 417
    tmp___24 = gr_dbname();
#line 417
    tmp___25 = gettext("%s: failed to unlock %s\n");
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___25,
            Prog, tmp___24);
    }
    {
#line 418
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 418
      tmp___26 = setlocale(6, (char const   *)((void *)0));
#line 418
      old_locale___4 = tmp___26;
#line 418
      saved_locale___4 = (char *)((void *)0);
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___4) {
        {
#line 418
        saved_locale___4 = strdup((char const   *)old_locale___4);
        }
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 418
        setlocale(6, "C");
        }
      }
      {
#line 418
      tmp___27 = gr_dbname();
#line 418
      syslog(3, "failed to unlock %s", tmp___27);
      }
#line 418
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___4) {
        {
#line 418
        setlocale(6, (char const   *)saved_locale___4);
#line 418
        free((void *)saved_locale___4);
        }
      }
#line 418
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 421
  gr_locked___4 = (_Bool)0;
#line 424
  if (is_shadow_grp___5) {
    {
#line 425
    tmp___33 = sgr_close();
    }
#line 425
    if (tmp___33 == 0) {
      {
#line 426
      tmp___29 = sgr_dbname();
#line 426
      tmp___30 = gettext("%s: failure while writing changes to %s\n");
#line 426
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___30,
              Prog, tmp___29);
      }
      {
#line 428
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 428
        tmp___31 = setlocale(6, (char const   *)((void *)0));
#line 428
        old_locale___5 = tmp___31;
#line 428
        saved_locale___5 = (char *)((void *)0);
        }
#line 428
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___5) {
          {
#line 428
          saved_locale___5 = strdup((char const   *)old_locale___5);
          }
        }
#line 428
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
          {
#line 428
          setlocale(6, "C");
          }
        }
        {
#line 428
        tmp___32 = sgr_dbname();
#line 428
        syslog(3, "failure while writing changes to %s", tmp___32);
        }
#line 428
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___5) {
          {
#line 428
          setlocale(6, (char const   *)saved_locale___5);
#line 428
          free((void *)saved_locale___5);
          }
        }
#line 428
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 429
      fail_exit___9(10);
      }
    }
    {
#line 432
    tmp___38 = sgr_unlock();
    }
#line 432
    if (tmp___38 == 0) {
      {
#line 433
      tmp___34 = sgr_dbname();
#line 433
      tmp___35 = gettext("%s: failed to unlock %s\n");
#line 433
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
              Prog, tmp___34);
      }
      {
#line 434
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 434
        tmp___36 = setlocale(6, (char const   *)((void *)0));
#line 434
        old_locale___6 = tmp___36;
#line 434
        saved_locale___6 = (char *)((void *)0);
        }
#line 434
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___6) {
          {
#line 434
          saved_locale___6 = strdup((char const   *)old_locale___6);
          }
        }
#line 434
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
          {
#line 434
          setlocale(6, "C");
          }
        }
        {
#line 434
        tmp___37 = sgr_dbname();
#line 434
        syslog(3, "failed to unlock %s", tmp___37);
        }
#line 434
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___6) {
          {
#line 434
          setlocale(6, (char const   *)saved_locale___6);
#line 434
          free((void *)saved_locale___6);
          }
        }
#line 434
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 437
    sgr_locked___4 = (_Bool)0;
  }
#line 440
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void fail_exit___9(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
#line 447
  if (pw_locked___7) {
    {
#line 448
    tmp___3 = pw_unlock();
    }
#line 448
    if (tmp___3 == 0) {
      {
#line 449
      tmp = pw_dbname();
#line 449
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 449
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 450
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 450
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 450
        old_locale = tmp___1;
#line 450
        saved_locale = (char *)((void *)0);
        }
#line 450
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 450
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 450
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 450
          setlocale(6, "C");
          }
        }
        {
#line 450
        tmp___2 = pw_dbname();
#line 450
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 450
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 450
          setlocale(6, (char const   *)saved_locale);
#line 450
          free((void *)saved_locale);
          }
        }
#line 450
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 454
  if (gr_locked___4) {
    {
#line 455
    tmp___8 = gr_unlock();
    }
#line 455
    if (tmp___8 == 0) {
      {
#line 456
      tmp___4 = gr_dbname();
#line 456
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 456
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 457
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 457
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 457
        old_locale___0 = tmp___6;
#line 457
        saved_locale___0 = (char *)((void *)0);
        }
#line 457
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 457
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 457
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 457
          setlocale(6, "C");
          }
        }
        {
#line 457
        tmp___7 = gr_dbname();
#line 457
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 457
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 457
          setlocale(6, (char const   *)saved_locale___0);
#line 457
          free((void *)saved_locale___0);
          }
        }
#line 457
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 461
  if (spw_locked___7) {
    {
#line 462
    tmp___13 = spw_unlock();
    }
#line 462
    if (tmp___13 == 0) {
      {
#line 463
      tmp___9 = spw_dbname();
#line 463
      tmp___10 = gettext("%s: failed to unlock %s\n");
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 464
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 464
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 464
        old_locale___1 = tmp___11;
#line 464
        saved_locale___1 = (char *)((void *)0);
        }
#line 464
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 464
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 464
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 464
          setlocale(6, "C");
          }
        }
        {
#line 464
        tmp___12 = spw_dbname();
#line 464
        syslog(3, "failed to unlock %s", tmp___12);
        }
#line 464
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 464
          setlocale(6, (char const   *)saved_locale___1);
#line 464
          free((void *)saved_locale___1);
          }
        }
#line 464
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 469
  if (sgr_locked___4) {
    {
#line 470
    tmp___18 = sgr_unlock();
    }
#line 470
    if (tmp___18 == 0) {
      {
#line 471
      tmp___14 = sgr_dbname();
#line 471
      tmp___15 = gettext("%s: failed to unlock %s\n");
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              Prog, tmp___14);
      }
      {
#line 472
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 472
        tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 472
        old_locale___2 = tmp___16;
#line 472
        saved_locale___2 = (char *)((void *)0);
        }
#line 472
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
          {
#line 472
          saved_locale___2 = strdup((char const   *)old_locale___2);
          }
        }
#line 472
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 472
          setlocale(6, "C");
          }
        }
        {
#line 472
        tmp___17 = sgr_dbname();
#line 472
        syslog(3, "failed to unlock %s", tmp___17);
        }
#line 472
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
          {
#line 472
          setlocale(6, (char const   *)saved_locale___2);
#line 472
          free((void *)saved_locale___2);
          }
        }
#line 472
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 485
  exit(code);
  }
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void open_files___9(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 496
  tmp___1 = pw_lock();
  }
#line 496
  if (tmp___1 == 0) {
    {
#line 497
    tmp = pw_dbname();
#line 497
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 497
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 506
    fail_exit___9(1);
    }
  }
  {
#line 508
  pw_locked___7 = (_Bool)1;
#line 509
  tmp___4 = pw_open(2);
  }
#line 509
  if (tmp___4 == 0) {
    {
#line 510
    tmp___2 = pw_dbname();
#line 510
    tmp___3 = gettext("%s: cannot open %s\n");
#line 510
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 518
    fail_exit___9(1);
    }
  }
#line 520
  if (is_shadow_pwd___2) {
    {
#line 521
    tmp___7 = spw_lock();
    }
#line 521
    if (tmp___7 == 0) {
      {
#line 522
      tmp___5 = spw_dbname();
#line 522
      tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, tmp___5);
#line 531
      fail_exit___9(1);
      }
    }
    {
#line 533
    spw_locked___7 = (_Bool)1;
#line 534
    tmp___10 = spw_open(2);
    }
#line 534
    if (tmp___10 == 0) {
      {
#line 535
      tmp___8 = spw_dbname();
#line 535
      tmp___9 = gettext("%s: cannot open %s\n");
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
#line 544
      fail_exit___9(1);
      }
    }
  }
  {
#line 547
  tmp___13 = gr_lock();
  }
#line 547
  if (tmp___13 == 0) {
    {
#line 548
    tmp___11 = gr_dbname();
#line 548
    tmp___12 = gettext("%s: cannot lock %s; try again later.\n");
#line 548
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
            Prog, tmp___11);
#line 557
    fail_exit___9(10);
    }
  }
  {
#line 559
  gr_locked___4 = (_Bool)1;
#line 560
  tmp___16 = gr_open(2);
  }
#line 560
  if (tmp___16 == 0) {
    {
#line 561
    tmp___14 = gr_dbname();
#line 561
    tmp___15 = gettext("%s: cannot open %s\n");
#line 561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
            Prog, tmp___14);
#line 568
    fail_exit___9(10);
    }
  }
#line 571
  if (is_shadow_grp___5) {
    {
#line 572
    tmp___19 = sgr_lock();
    }
#line 572
    if (tmp___19 == 0) {
      {
#line 573
      tmp___17 = sgr_dbname();
#line 573
      tmp___18 = gettext("%s: cannot lock %s; try again later.\n");
#line 573
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
              Prog, tmp___17);
#line 582
      fail_exit___9(10);
      }
    }
    {
#line 584
    sgr_locked___4 = (_Bool)1;
#line 585
    tmp___22 = sgr_open(2);
    }
#line 585
    if (tmp___22 == 0) {
      {
#line 586
      tmp___20 = sgr_dbname();
#line 586
      tmp___21 = gettext("%s: cannot open %s\n");
#line 586
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
              Prog, tmp___20);
#line 594
      fail_exit___9(10);
      }
    }
  }
#line 598
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void update_user(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  struct spwd  const  *tmp___4 ;
  int tmp___5 ;
  char *old_locale ;
  char *tmp___6 ;
  char *saved_locale ;

  {
  {
#line 608
  tmp___1 = pw_remove((char const   *)user_name___2);
  }
#line 608
  if (tmp___1 == 0) {
    {
#line 609
    tmp = pw_dbname();
#line 609
    tmp___0 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 609
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, user_name___2, tmp);
#line 612
    fail_exit___9(1);
    }
  }
#line 614
  if (is_shadow_pwd___2) {
    {
#line 614
    tmp___4 = spw_locate((char const   *)user_name___2);
    }
#line 614
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
      {
#line 614
      tmp___5 = spw_remove((char const   *)user_name___2);
      }
#line 614
      if (tmp___5 == 0) {
        {
#line 617
        tmp___2 = spw_dbname();
#line 617
        tmp___3 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 617
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                Prog, user_name___2, tmp___2);
#line 620
        fail_exit___9(1);
        }
      }
    }
  }
  {
#line 628
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 628
    tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 628
    old_locale = tmp___6;
#line 628
    saved_locale = (char *)((void *)0);
    }
#line 628
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 628
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 628
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 628
      setlocale(6, "C");
      }
    }
    {
#line 628
    syslog(6, "delete user \'%s\'\n", user_name___2);
    }
#line 628
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 628
      setlocale(6, (char const   *)saved_locale);
#line 628
      free((void *)saved_locale);
      }
    }
#line 628
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static void user_cancel(char const   *user___0 ) 
{ 
  char const   *cmd ;
  char const   *argv[3] ;
  int status ;

  {
  {
#line 644
  cmd = getdef_str("USERDEL_CMD");
  }
#line 645
  if ((unsigned long )((void *)0) == (unsigned long )cmd) {
#line 646
    return;
  }
  {
#line 648
  argv[0] = cmd;
#line 649
  argv[1] = user___0;
#line 650
  argv[2] = (char const   *)((char *)0);
#line 651
  run_command(cmd, argv, (char const   **)((void *)0), & status);
  }
#line 652
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static int is_owner(uid_t uid , char const   *path ) 
{ 
  struct stat st ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 675
  tmp = __errno_location();
#line 675
  *tmp = 0;
#line 676
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 676
  if (tmp___2 != 0) {
    {
#line 677
    tmp___0 = __errno_location();
    }
#line 677
    if (2 == *tmp___0) {
#line 679
      return (-1);
    } else {
      {
#line 677
      tmp___1 = __errno_location();
      }
#line 677
      if (20 == *tmp___1) {
#line 679
        return (-1);
      } else {
#line 681
        return (0);
      }
    }
  }
#line 684
  if (st.st_uid == uid) {
#line 684
    tmp___3 = 1;
  } else {
#line 684
    tmp___3 = 0;
  }
#line 684
  return (tmp___3);
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static int remove_mailbox(void) 
{ 
  char const   *maildir ;
  char mailfile[1024] ;
  int i ;
  int errors___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *old_locale___0 ;
  char *tmp___12 ;
  char *saved_locale___0 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *old_locale___1 ;
  char *tmp___17 ;
  char *saved_locale___1 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *old_locale___2 ;
  char *tmp___23 ;
  char *saved_locale___2 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;

  {
  {
#line 692
  errors___0 = 0;
#line 694
  maildir = getdef_str("MAIL_DIR");
  }
#line 696
  if ((unsigned long )((void *)0) == (unsigned long )maildir) {
    {
#line 696
    tmp = getdef_str("MAIL_FILE");
    }
#line 696
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 697
      maildir = "/var/mail";
    }
  }
#line 700
  if ((unsigned long )((void *)0) == (unsigned long )maildir) {
#line 701
    return (0);
  }
  {
#line 703
  snprintf((char */* __restrict  */)(mailfile), sizeof(mailfile), (char const   */* __restrict  */)"%s/%s",
           maildir, user_name___2);
#line 705
  tmp___8 = access((char const   *)(mailfile), 0);
  }
#line 705
  if (tmp___8 != 0) {
    {
#line 706
    tmp___7 = __errno_location();
    }
#line 706
    if (2 == *tmp___7) {
      {
#line 707
      tmp___0 = gettext("%s: %s mail spool (%s) not found\n");
#line 707
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, user_name___2, mailfile);
      }
#line 710
      return (0);
    } else {
      {
#line 712
      tmp___1 = __errno_location();
#line 712
      tmp___2 = strerror(*tmp___1);
#line 712
      tmp___3 = gettext("%s: warning: can\'t remove %s: %s\n");
#line 712
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog, mailfile, tmp___2);
      }
      {
#line 715
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 715
        tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 715
        old_locale = tmp___4;
#line 715
        saved_locale = (char *)((void *)0);
        }
#line 715
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 715
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 715
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 715
          setlocale(6, "C");
          }
        }
        {
#line 715
        tmp___5 = __errno_location();
#line 715
        tmp___6 = strerror(*tmp___5);
#line 715
        syslog(3, "Cannot remove %s: %s", mailfile, tmp___6);
        }
#line 715
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 715
          setlocale(6, (char const   *)saved_locale);
#line 715
          free((void *)saved_locale);
          }
        }
#line 715
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 722
      return (-1);
    }
  }
#line 726
  if (fflg___3) {
    {
#line 727
    tmp___15 = unlink((char const   *)(mailfile));
    }
#line 727
    if (tmp___15 != 0) {
      {
#line 728
      tmp___9 = __errno_location();
#line 728
      tmp___10 = strerror(*tmp___9);
#line 728
      tmp___11 = gettext("%s: warning: can\'t remove %s: %s\n");
#line 728
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
              Prog, mailfile, tmp___10);
      }
      {
#line 731
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 731
        tmp___12 = setlocale(6, (char const   *)((void *)0));
#line 731
        old_locale___0 = tmp___12;
#line 731
        saved_locale___0 = (char *)((void *)0);
        }
#line 731
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 731
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 731
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 731
          setlocale(6, "C");
          }
        }
        {
#line 731
        tmp___13 = __errno_location();
#line 731
        tmp___14 = strerror(*tmp___13);
#line 731
        syslog(3, "Cannot remove %s: %s", mailfile, tmp___14);
        }
#line 731
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 731
          setlocale(6, (char const   *)saved_locale___0);
#line 731
          free((void *)saved_locale___0);
          }
        }
#line 731
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 738
      errors___0 = 1;
    }
#line 750
    return (errors___0);
  }
  {
#line 752
  i = is_owner(user_id___1, (char const   *)(mailfile));
  }
#line 753
  if (i == 0) {
    {
#line 754
    tmp___16 = gettext("%s: %s not owned by %s, not removing\n");
#line 754
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
            Prog, mailfile, user_name___2);
    }
    {
#line 757
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 757
      tmp___17 = setlocale(6, (char const   *)((void *)0));
#line 757
      old_locale___1 = tmp___17;
#line 757
      saved_locale___1 = (char *)((void *)0);
      }
#line 757
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 757
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 757
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 757
        setlocale(6, "C");
        }
      }
      {
#line 757
      tmp___18 = __errno_location();
#line 757
      tmp___19 = strerror(*tmp___18);
#line 757
      syslog(3, "%s not owned by %s, not removed", mailfile, tmp___19);
      }
#line 757
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 757
        setlocale(6, (char const   *)saved_locale___1);
#line 757
        free((void *)saved_locale___1);
        }
      }
#line 757
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 766
    return (1);
  } else
#line 767
  if (i == -1) {
#line 768
    return (0);
  }
  {
#line 770
  tmp___26 = unlink((char const   *)(mailfile));
  }
#line 770
  if (tmp___26 != 0) {
    {
#line 771
    tmp___20 = __errno_location();
#line 771
    tmp___21 = strerror(*tmp___20);
#line 771
    tmp___22 = gettext("%s: warning: can\'t remove %s: %s\n");
#line 771
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
            Prog, mailfile, tmp___21);
    }
    {
#line 774
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 774
      tmp___23 = setlocale(6, (char const   *)((void *)0));
#line 774
      old_locale___2 = tmp___23;
#line 774
      saved_locale___2 = (char *)((void *)0);
      }
#line 774
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 774
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 774
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 774
        setlocale(6, "C");
        }
      }
      {
#line 774
      tmp___24 = __errno_location();
#line 774
      tmp___25 = strerror(*tmp___24);
#line 774
      syslog(3, "Cannot remove %s: %s", mailfile, tmp___25);
      }
#line 774
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 774
        setlocale(6, (char const   *)saved_locale___2);
#line 774
        free((void *)saved_locale___2);
        }
      }
#line 774
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 781
    errors___0 = 1;
  }
#line 793
  return (errors___0);
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/userdel.c"
static struct option long_options___14[5]  = {      {"force", 0, (int *)((void *)0), 'f'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"remove", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___17(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___18  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___35  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___17(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___35) {
#line 70
      size___35 = i + 100;
#line 71
      if (members___18) {
        {
#line 72
        tmp = realloc((void *)members___18, (unsigned long )size___35 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___35 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___18) {
          {
#line 81
          free((void *)members___18);
          }
        }
#line 82
        members___18 = (char **)0;
#line 83
        size___35 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___18 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___18 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___18 + i) = (char *)0;
#line 99
  return (members___18);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___17  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___36  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___17[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___17  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___19(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___19(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___19  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___19  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___19  ;
#line 72
static int copy_entry___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___19(char const   *filename___0 ) ;
#line 83
static int copy_symlink___19(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___19(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___19(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___19(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___19(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___19(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___19 == (unsigned long )ln) {
    {
#line 149
    links___19 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___19;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___19(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___19)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___19)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___19;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___19);
#line 199
  dst_len = strlen(dst_orig___19);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___19, name___3 + src_len);
#line 207
  lp->ln_next = links___19;
#line 208
  links___19 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___19(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___19(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___19(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___19(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___19(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___19(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___19(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___19(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___19(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___19)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___19)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___19(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___19);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___19, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___19);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___19);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___19);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___19, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___19(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___19(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___19(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___19(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___19(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___19(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___19(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___19(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___19(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___19[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___19[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___20(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___20(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___20[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___20[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___20  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___18(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___19  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___37  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___18(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___37) {
#line 70
      size___37 = i + 100;
#line 71
      if (members___19) {
        {
#line 72
        tmp = realloc((void *)members___19, (unsigned long )size___37 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___37 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___19) {
          {
#line 81
          free((void *)members___19);
          }
        }
#line 82
        members___19 = (char **)0;
#line 83
        size___37 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___19 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___19 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___19 + i) = (char *)0;
#line 99
  return (members___19);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___18  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___38  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___18[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___18  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___20(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___20(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groups.c"
static void print_groups(char const   *member ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groups.c"
static void print_groups(char const   *member ) 
{ 
  int groups ;
  struct group *grp ;
  struct passwd *pwd ;
  _Bool flag ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 58
  groups = 0;
#line 61
  flag = (_Bool)0;
#line 63
  pwd = getpwnam(member);
  }
#line 64
  if ((unsigned long )((void *)0) == (unsigned long )pwd) {
    {
#line 65
    tmp = gettext("%s: unknown user %s\n");
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, member);
#line 67
    exit(1);
    }
  }
  {
#line 70
  setgrent();
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    grp = getgrent();
    }
#line 71
    if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 71
      goto while_break;
    }
    {
#line 72
    tmp___0 = is_on_list((char * const  *)grp->gr_mem, member);
    }
#line 72
    if (tmp___0) {
#line 73
      if (0 != groups) {
        {
#line 74
        putchar(' ');
        }
      }
      {
#line 76
      groups ++;
#line 78
      printf((char const   */* __restrict  */)"%s", grp->gr_name);
      }
#line 79
      if (grp->gr_gid == pwd->pw_gid) {
#line 80
        flag = (_Bool)1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  endgrent();
  }
#line 87
  if (! flag) {
    {
#line 88
    grp = getgrgid(pwd->pw_gid);
    }
#line 89
    if ((unsigned long )((void *)0) != (unsigned long )grp) {
#line 90
      if (0 != groups) {
        {
#line 91
        putchar(' ');
        }
      }
      {
#line 93
      groups ++;
#line 95
      printf((char const   */* __restrict  */)"%s", grp->gr_name);
      }
    }
  }
#line 99
  if (0 != groups) {
    {
#line 100
    putchar('\n');
    }
  }
#line 102
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___20  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___20  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___20  ;
#line 72
static int copy_entry___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___20(char const   *filename___0 ) ;
#line 83
static int copy_symlink___20(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___20(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___20(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___20(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___20(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___20(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___20 == (unsigned long )ln) {
    {
#line 149
    links___20 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___20;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___20(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___20)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___20)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___20;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___20);
#line 199
  dst_len = strlen(dst_orig___20);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___20, name___3 + src_len);
#line 207
  lp->ln_next = links___20;
#line 208
  links___20 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___20(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___20(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___20(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___20(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___20(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___20(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___20(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___20(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___20(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___20)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___20)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___20(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___20);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___20, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___20);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___20);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___20);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___20, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___20(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___20(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___20(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___20(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___20(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___20(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___20(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___20(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___20(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___20[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___20[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___21(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___21(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___21[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___21[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___21  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___19(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___20  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___39  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___19(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___39) {
#line 70
      size___39 = i + 100;
#line 71
      if (members___20) {
        {
#line 72
        tmp = realloc((void *)members___20, (unsigned long )size___39 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___39 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___20) {
          {
#line 81
          free((void *)members___20);
          }
        }
#line 82
        members___20 = (char **)0;
#line 83
        size___39 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___20 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___20 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___20 + i) = (char *)0;
#line 99
  return (members___20);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___19  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___40  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___19[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___19  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___21(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___21(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___21  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___21  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___21  ;
#line 72
static int copy_entry___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___21(char const   *filename___0 ) ;
#line 83
static int copy_symlink___21(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___21(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___21(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___21(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___21(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___21(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___21 == (unsigned long )ln) {
    {
#line 149
    links___21 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___21;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___21(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___21)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___21)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___21;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___21);
#line 199
  dst_len = strlen(dst_orig___21);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___21, name___3 + src_len);
#line 207
  lp->ln_next = links___21;
#line 208
  links___21 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___21(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___21(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___21(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___21(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___21(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___21(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___21(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___21(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___21(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___21)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___21)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___21(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___21);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___21, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___21);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___21);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___21);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___21, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___21(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___21(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___21(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___21(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___21(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___21(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___21(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___21(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___21(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 140 "../lib/prototypes.h"
extern int valid_field(char const   * , char const   * ) ;
#line 268
extern void passwd_check(char const   * , char const   * , char const   * ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static _Bool amroot___1  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static char loginsh[8192]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static _Bool sflg___4  =    (_Bool)0;
#line 69 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static _Bool pw_locked___8  =    (_Bool)0;
#line 74
static void fail_exit___10(int code ) ;
#line 75
static void usage___18(int status ) ;
#line 76
static void new_fields___0(void) ;
#line 77
static _Bool shell_is_listed(char const   *sh ) ;
#line 78
static _Bool is_restricted_shell(char const   *sh ) ;
#line 79
static void process_flags___14(int argc , char **argv ) ;
#line 80
static void check_perms___7(struct passwd  const  *pw ) ;
#line 81
static void update_shell(char const   *user___0 , char *newshell ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static void fail_exit___10(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 88
  if (pw_locked___8) {
    {
#line 89
    tmp___3 = pw_unlock();
    }
#line 89
    if (tmp___3 == 0) {
      {
#line 90
      tmp = pw_dbname();
#line 90
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 91
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 91
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 91
        old_locale = tmp___1;
#line 91
        saved_locale = (char *)((void *)0);
        }
#line 91
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 91
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 91
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 91
          setlocale(6, "C");
          }
        }
        {
#line 91
        tmp___2 = pw_dbname();
#line 91
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 91
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 91
          setlocale(6, (char const   *)saved_locale);
#line 91
          free((void *)saved_locale);
          }
        }
#line 91
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 96
  closelog();
#line 98
  exit(code);
  }
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static void usage___18(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 106
  if (0 != status) {
#line 106
    tmp = stderr;
  } else {
#line 106
    tmp = stdout;
  }
  {
#line 106
  usageout = tmp;
#line 107
  tmp___0 = gettext("Usage: %s [options] [LOGIN]\n\nOptions:\n");
#line 107
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 112
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 112
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 113
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 113
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 114
  tmp___3 = gettext("  -s, --shell SHELL             new login shell for the user account\n");
#line 114
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 115
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 116
  exit(status);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static void new_fields___0(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 127
  tmp = gettext("Enter the new value, or press ENTER for the default");
#line 127
  puts((char const   *)tmp);
#line 128
  tmp___0 = gettext("Login Shell");
#line 128
  change_field(loginsh, sizeof(loginsh), (char const   *)tmp___0);
  }
#line 129
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static _Bool is_restricted_shell(char const   *sh ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 142
  tmp = shell_is_listed(sh);
  }
#line 142
  if (tmp) {
#line 142
    tmp___0 = 0;
  } else {
#line 142
    tmp___0 = 1;
  }
#line 142
  return ((_Bool )tmp___0);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static _Bool shell_is_listed(char const   *sh ) 
{ 
  char *cp ;
  _Bool found ;
  int tmp ;

  {
  {
#line 158
  found = (_Bool)0;
#line 166
  setusershell();
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    cp = getusershell();
    }
#line 167
    if (! cp) {
#line 167
      goto while_break;
    }
    {
#line 168
    tmp = strcmp((char const   *)cp, sh);
    }
#line 168
    if (tmp == 0) {
#line 169
      found = (_Bool)1;
#line 170
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  endusershell();
  }
#line 197
  return (found);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static struct option long_options___15[4]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"shell", 1, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 205 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static void process_flags___14(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 215
    c = getopt_long(argc, (char * const  *)argv, "hR:s:", (struct option  const  *)(long_options___15),
                    (int *)((void *)0));
    }
#line 215
    if (! (c != -1)) {
#line 215
      goto while_break;
    }
    {
#line 218
    if (c == 104) {
#line 218
      goto case_104;
    }
#line 221
    if (c == 82) {
#line 221
      goto case_82;
    }
#line 223
    if (c == 115) {
#line 223
      goto case_115;
    }
#line 227
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 219
    usage___18(0);
    }
#line 220
    goto switch_break;
    case_82: /* CIL Label */ 
#line 222
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 224
    sflg___4 = (_Bool)1;
#line 225
    strncpy((char */* __restrict  */)(loginsh), (char const   */* __restrict  */)optarg,
            sizeof(loginsh) - 1UL);
#line 225
    loginsh[sizeof(loginsh) - 1UL] = (char )'\000';
    }
#line 226
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 228
    usage___18(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (argc > optind + 1) {
    {
#line 237
    usage___18(2);
    }
  }
#line 239
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static void check_perms___7(struct passwd  const  *pw ) 
{ 
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char *tmp___0 ;
  __uid_t tmp___1 ;
  char *old_locale___0 ;
  char *tmp___2 ;
  char *saved_locale___0 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
#line 263
  if (! amroot___1) {
    {
#line 263
    tmp___1 = getuid();
    }
#line 263
    if (pw->pw_uid != (__uid_t const   )tmp___1) {
      {
#line 264
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 264
        tmp = setlocale(6, (char const   *)((void *)0));
#line 264
        old_locale = tmp;
#line 264
        saved_locale = (char *)((void *)0);
        }
#line 264
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 264
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 264
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 264
          setlocale(6, "C");
          }
        }
        {
#line 264
        syslog(4, "can\'t change shell for \'%s\'", pw->pw_name);
        }
#line 264
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 264
          setlocale(6, (char const   *)saved_locale);
#line 264
          free((void *)saved_locale);
          }
        }
#line 264
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 265
      tmp___0 = gettext("You may not change the shell for \'%s\'.\n");
#line 265
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              pw->pw_name);
#line 268
      fail_exit___10(1);
      }
    }
  }
#line 275
  if (! amroot___1) {
    {
#line 275
    tmp___4 = is_restricted_shell((char const   *)pw->pw_shell);
    }
#line 275
    if (tmp___4) {
      {
#line 276
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 276
        tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 276
        old_locale___0 = tmp___2;
#line 276
        saved_locale___0 = (char *)((void *)0);
        }
#line 276
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 276
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 276
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 276
          setlocale(6, "C");
          }
        }
        {
#line 276
        syslog(4, "can\'t change shell for \'%s\'", pw->pw_name);
        }
#line 276
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 276
          setlocale(6, (char const   *)saved_locale___0);
#line 276
          free((void *)saved_locale___0);
          }
        }
#line 276
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 277
      tmp___3 = gettext("You may not change the shell for \'%s\'.\n");
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              pw->pw_name);
#line 280
      fail_exit___10(1);
      }
    }
  }
#line 305
  if (! amroot___1) {
    {
#line 305
    tmp___5 = getdef_bool("CHSH_AUTH");
    }
#line 305
    if (tmp___5) {
      {
#line 306
      passwd_check((char const   *)pw->pw_name, (char const   *)pw->pw_passwd, "chsh");
      }
    }
  }
#line 339
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chsh.c"
static void update_shell(char const   *user___0 , char *newshell ) 
{ 
  struct passwd  const  *pw ;
  struct passwd pwent___0 ;
  char *old_locale ;
  char *tmp ;
  char *saved_locale ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *old_locale___0 ;
  char *tmp___7 ;
  char *saved_locale___0 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char *old_locale___1 ;
  char *tmp___17 ;
  char *saved_locale___1 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char *old_locale___2 ;
  char *tmp___22 ;
  char *saved_locale___2 ;
  char const   *tmp___23 ;
  int tmp___24 ;

  {
  {
#line 359
  tmp___1 = setuid((__uid_t )0);
  }
#line 359
  if (tmp___1 != 0) {
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 360
      tmp = setlocale(6, (char const   *)((void *)0));
#line 360
      old_locale = tmp;
#line 360
      saved_locale = (char *)((void *)0);
      }
#line 360
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 360
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 360
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 360
        setlocale(6, "C");
        }
      }
      {
#line 360
      syslog(3, "can\'t setuid(0)");
      }
#line 360
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 360
        setlocale(6, (char const   *)saved_locale);
#line 360
        free((void *)saved_locale);
        }
      }
#line 360
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 361
    tmp___0 = gettext("Cannot change ID to root.\n");
#line 361
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 362
    fail_exit___10(1);
    }
  }
  {
#line 364
  pwd_init();
#line 370
  tmp___4 = pw_lock();
  }
#line 370
  if (tmp___4 == 0) {
    {
#line 371
    tmp___2 = pw_dbname();
#line 371
    tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 373
    fail_exit___10(1);
    }
  }
  {
#line 375
  pw_locked___8 = (_Bool)1;
#line 376
  tmp___9 = pw_open(2);
  }
#line 376
  if (tmp___9 == 0) {
    {
#line 377
    tmp___5 = pw_dbname();
#line 377
    tmp___6 = gettext("%s: cannot open %s\n");
#line 377
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
    }
    {
#line 378
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 378
      tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 378
      old_locale___0 = tmp___7;
#line 378
      saved_locale___0 = (char *)((void *)0);
      }
#line 378
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 378
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 378
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 378
        setlocale(6, "C");
        }
      }
      {
#line 378
      tmp___8 = pw_dbname();
#line 378
      syslog(4, "cannot open %s", tmp___8);
      }
#line 378
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 378
        setlocale(6, (char const   *)saved_locale___0);
#line 378
        free((void *)saved_locale___0);
        }
      }
#line 378
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 379
    fail_exit___10(1);
    }
  }
  {
#line 388
  pw = pw_locate(user___0);
  }
#line 389
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
    {
#line 390
    tmp___10 = pw_dbname();
#line 390
    tmp___11 = gettext("%s: user \'%s\' does not exist in %s\n");
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            Prog, user___0, tmp___10);
#line 393
    fail_exit___10(1);
    }
  }
  {
#line 400
  pwent___0 = (struct passwd )*pw;
#line 401
  pwent___0.pw_shell = newshell;
#line 407
  tmp___14 = pw_update((struct passwd  const  *)(& pwent___0));
  }
#line 407
  if (tmp___14 == 0) {
    {
#line 408
    tmp___12 = pw_dbname();
#line 408
    tmp___13 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
            Prog, tmp___12, pwent___0.pw_name);
#line 411
    fail_exit___10(1);
    }
  }
  {
#line 417
  tmp___19 = pw_close();
  }
#line 417
  if (tmp___19 == 0) {
    {
#line 418
    tmp___15 = pw_dbname();
#line 418
    tmp___16 = gettext("%s: failure while writing changes to %s\n");
#line 418
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
            Prog, tmp___15);
    }
    {
#line 419
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 419
      tmp___17 = setlocale(6, (char const   *)((void *)0));
#line 419
      old_locale___1 = tmp___17;
#line 419
      saved_locale___1 = (char *)((void *)0);
      }
#line 419
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 419
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 419
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 419
        setlocale(6, "C");
        }
      }
      {
#line 419
      tmp___18 = pw_dbname();
#line 419
      syslog(3, "failure while writing changes to %s", tmp___18);
      }
#line 419
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 419
        setlocale(6, (char const   *)saved_locale___1);
#line 419
        free((void *)saved_locale___1);
        }
      }
#line 419
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 420
    fail_exit___10(1);
    }
  }
  {
#line 422
  tmp___24 = pw_unlock();
  }
#line 422
  if (tmp___24 == 0) {
    {
#line 423
    tmp___20 = pw_dbname();
#line 423
    tmp___21 = gettext("%s: failed to unlock %s\n");
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
            Prog, tmp___20);
    }
    {
#line 424
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 424
      tmp___22 = setlocale(6, (char const   *)((void *)0));
#line 424
      old_locale___2 = tmp___22;
#line 424
      saved_locale___2 = (char *)((void *)0);
      }
#line 424
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 424
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 424
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 424
        setlocale(6, "C");
        }
      }
      {
#line 424
      tmp___23 = pw_dbname();
#line 424
      syslog(3, "failed to unlock %s", tmp___23);
      }
#line 424
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 424
        setlocale(6, (char const   *)saved_locale___2);
#line 424
        free((void *)saved_locale___2);
        }
      }
#line 424
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 427
  pw_locked___8 = (_Bool)0;
#line 428
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___21[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___21[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___22(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___22(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___22[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___22[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___22  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___20(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___21  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___41  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___20(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___41) {
#line 70
      size___41 = i + 100;
#line 71
      if (members___21) {
        {
#line 72
        tmp = realloc((void *)members___21, (unsigned long )size___41 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___41 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___21) {
          {
#line 81
          free((void *)members___21);
          }
        }
#line 82
        members___21 = (char **)0;
#line 83
        size___41 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___21 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___21 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___21 + i) = (char *)0;
#line 99
  return (members___21);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___20  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___42  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___20[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___20  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___22(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___22(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 45 "../lib/groupio.h"
extern int gr_setdbname(char const   *filename ) ;
#line 53
extern int gr_sort(void) ;
#line 180 "../lib/prototypes.h"
extern void __gr_del_entry(struct commonio_entry  const  *ent ) ;
#line 182
extern struct commonio_entry *__gr_get_head(void) ;
#line 183
extern void __gr_set_changed(void) ;
#line 335
extern void __sgr_del_entry(struct commonio_entry  const  *ent ) ;
#line 338
extern struct commonio_entry *__sgr_get_head(void) ;
#line 339
extern void __sgr_set_changed(void) ;
#line 42 "../lib/sgroupio.h"
extern int sgr_setdbname(char const   *filename ) ;
#line 50
extern int sgr_sort(void) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static char const   *grp_file  =    "/etc/group";
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool use_system_grp_file  =    (_Bool)1;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static char const   *sgr_file  =    "/etc/gshadow";
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool use_system_sgr_file  =    (_Bool)1;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool is_shadow___1  =    (_Bool)0;
#line 78 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool sgr_locked___5  =    (_Bool)0;
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool gr_locked___5  =    (_Bool)0;
#line 82 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool read_only___0  =    (_Bool)0;
#line 83 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static _Bool sort_mode___0  =    (_Bool)0;
#line 86
static void fail_exit___11(int status ) ;
#line 87
static void usage___19(int status ) ;
#line 88
static void delete_member(char **list___30 , char const   *member ) ;
#line 89
static void process_flags___15(int argc , char **argv ) ;
#line 90
static void open_files___10(void) ;
#line 91
static void close_files___10(_Bool changed ) ;
#line 92
static int check_members(char const   *groupname , char **members___30 , char const   *fmt_info ,
                         char const   *fmt_prompt , char const   *fmt_syslog , int *errors___0 ) ;
#line 98
static void check_grp_file(int *errors___0 , _Bool *changed ) ;
#line 100
static void compare_members_lists(char const   *groupname , char **members___30 ,
                                  char **other_members , char const   *file , char const   *other_file ) ;
#line 105
static void check_sgr_file(int *errors___0 , _Bool *changed ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void fail_exit___11(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 113
  if (gr_locked___5) {
    {
#line 114
    tmp___3 = gr_unlock();
    }
#line 114
    if (tmp___3 == 0) {
      {
#line 115
      tmp = gr_dbname();
#line 115
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 115
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 116
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 116
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 116
        old_locale = tmp___1;
#line 116
        saved_locale = (char *)((void *)0);
        }
#line 116
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 116
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 116
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 116
          setlocale(6, "C");
          }
        }
        {
#line 116
        tmp___2 = gr_dbname();
#line 116
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 116
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 116
          setlocale(6, (char const   *)saved_locale);
#line 116
          free((void *)saved_locale);
          }
        }
#line 116
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 122
  if (sgr_locked___5) {
    {
#line 123
    tmp___8 = sgr_unlock();
    }
#line 123
    if (tmp___8 == 0) {
      {
#line 124
      tmp___4 = sgr_dbname();
#line 124
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 125
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 125
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 125
        old_locale___0 = tmp___6;
#line 125
        saved_locale___0 = (char *)((void *)0);
        }
#line 125
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 125
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 125
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 125
          setlocale(6, "C");
          }
        }
        {
#line 125
        tmp___7 = sgr_dbname();
#line 125
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 125
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 125
          setlocale(6, (char const   *)saved_locale___0);
#line 125
          free((void *)saved_locale___0);
          }
        }
#line 125
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 131
  closelog();
#line 133
  exit(status);
  }
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void usage___19(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 141
  if (0 != status) {
#line 141
    tmp = stderr;
  } else {
#line 141
    tmp = stdout;
  }
  {
#line 141
  usageout = tmp;
#line 143
  tmp___0 = gettext("Usage: %s [options] [group [gshadow]]\n\nOptions:\n");
#line 143
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 155
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 155
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 156
  tmp___2 = gettext("  -r, --read-only               display errors and warnings\n                                but do not change files\n");
#line 156
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 158
  tmp___3 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 158
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 159
  tmp___4 = gettext("  -s, --sort                    sort entries by UID\n");
#line 159
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 160
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 161
  exit(status);
  }
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void delete_member(char **list___30 , char const   *member ) 
{ 
  int i ;

  {
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! ((unsigned long )((void *)0) != (unsigned long )*(list___30 + i))) {
#line 175
      goto while_break;
    }
#line 176
    if ((unsigned long )*(list___30 + i) == (unsigned long )member) {
#line 177
      goto while_break;
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )((void *)0) != (unsigned long )*(list___30 + i))) {
#line 181
      goto while_break___0;
    }
#line 182
    *(list___30 + i) = *(list___30 + (i + 1));
#line 181
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static struct option long_options___16[6]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"read-only", 0, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"sort", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 191 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void process_flags___15(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;

  {
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    c = getopt_long(argc, (char * const  *)argv, "hqrR:s", (struct option  const  *)(long_options___16),
                    (int *)((void *)0));
    }
#line 206
    if (! (c != -1)) {
#line 206
      goto while_break;
    }
    {
#line 209
    if (c == 104) {
#line 209
      goto case_104;
    }
#line 212
    if (c == 113) {
#line 212
      goto case_113;
    }
#line 215
    if (c == 114) {
#line 215
      goto case_114;
    }
#line 218
    if (c == 82) {
#line 218
      goto case_82;
    }
#line 220
    if (c == 115) {
#line 220
      goto case_115;
    }
#line 223
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 210
    usage___19(0);
    }
#line 211
    goto switch_break;
    case_113: /* CIL Label */ 
#line 214
    goto switch_break;
    case_114: /* CIL Label */ 
#line 216
    read_only___0 = (_Bool)1;
#line 217
    goto switch_break;
    case_82: /* CIL Label */ 
#line 219
    goto switch_break;
    case_115: /* CIL Label */ 
#line 221
    sort_mode___0 = (_Bool)1;
#line 222
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 224
    usage___19(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if (sort_mode___0) {
#line 228
    if (read_only___0) {
      {
#line 229
      tmp = gettext("%s: -s and -r are incompatible\n");
#line 229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 230
      exit(1);
      }
    }
  }
#line 237
  if (argc > optind + 2) {
    {
#line 242
    usage___19(1);
    }
  }
#line 249
  if (optind != argc) {
    {
#line 250
    grp_file = (char const   *)*(argv + optind);
#line 251
    gr_setdbname(grp_file);
#line 252
    use_system_grp_file = (_Bool)0;
    }
  }
#line 255
  if (optind + 2 == argc) {
    {
#line 256
    sgr_file = (char const   *)*(argv + (optind + 1));
#line 257
    sgr_setdbname(sgr_file);
#line 258
    is_shadow___1 = (_Bool)1;
#line 259
    use_system_sgr_file = (_Bool)0;
    }
  } else
#line 260
  if (optind == argc) {
    {
#line 261
    is_shadow___1 = sgr_file_present();
    }
  }
#line 264
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void open_files___10(void) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *old_locale___0 ;
  char *tmp___8 ;
  char *saved_locale___0 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 277
  if (! read_only___0) {
    {
#line 278
    tmp___0 = gr_lock();
    }
#line 278
    if (tmp___0 == 0) {
      {
#line 279
      tmp = gettext("%s: cannot lock %s; try again later.\n");
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, grp_file);
#line 282
      fail_exit___11(4);
      }
    }
#line 284
    gr_locked___5 = (_Bool)1;
#line 286
    if (is_shadow___1) {
      {
#line 287
      tmp___2 = sgr_lock();
      }
#line 287
      if (tmp___2 == 0) {
        {
#line 288
        tmp___1 = gettext("%s: cannot lock %s; try again later.\n");
#line 288
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                Prog, sgr_file);
#line 291
        fail_exit___11(4);
        }
      }
#line 293
      sgr_locked___5 = (_Bool)1;
    }
  }
#line 302
  if (read_only___0) {
#line 302
    tmp___5 = 0;
  } else {
#line 302
    tmp___5 = 2;
  }
  {
#line 302
  tmp___6 = gr_open(tmp___5);
  }
#line 302
  if (tmp___6 == 0) {
    {
#line 303
    tmp___3 = gettext("%s: cannot open %s\n");
#line 303
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, grp_file);
    }
#line 305
    if (use_system_grp_file) {
      {
#line 306
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 306
        tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 306
        old_locale = tmp___4;
#line 306
        saved_locale = (char *)((void *)0);
        }
#line 306
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 306
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 306
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 306
          setlocale(6, "C");
          }
        }
        {
#line 306
        syslog(4, "cannot open %s", grp_file);
        }
#line 306
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 306
          setlocale(6, (char const   *)saved_locale);
#line 306
          free((void *)saved_locale);
          }
        }
#line 306
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 308
    fail_exit___11(3);
    }
  }
#line 311
  if (is_shadow___1) {
#line 311
    if (read_only___0) {
#line 311
      tmp___9 = 0;
    } else {
#line 311
      tmp___9 = 2;
    }
    {
#line 311
    tmp___10 = sgr_open(tmp___9);
    }
#line 311
    if (tmp___10 == 0) {
      {
#line 312
      tmp___7 = gettext("%s: cannot open %s\n");
#line 312
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              Prog, sgr_file);
      }
#line 314
      if (use_system_sgr_file) {
        {
#line 315
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 315
          tmp___8 = setlocale(6, (char const   *)((void *)0));
#line 315
          old_locale___0 = tmp___8;
#line 315
          saved_locale___0 = (char *)((void *)0);
          }
#line 315
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
            {
#line 315
            saved_locale___0 = strdup((char const   *)old_locale___0);
            }
          }
#line 315
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 315
            setlocale(6, "C");
            }
          }
          {
#line 315
          syslog(4, "cannot open %s", sgr_file);
          }
#line 315
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 315
            setlocale(6, (char const   *)saved_locale___0);
#line 315
            free((void *)saved_locale___0);
            }
          }
#line 315
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 317
      fail_exit___11(3);
      }
    }
  }
#line 320
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void close_files___10(_Bool changed ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *old_locale ;
  char *tmp___5 ;
  char *saved_locale ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *old_locale___0 ;
  char *tmp___10 ;
  char *saved_locale___0 ;
  char const   *tmp___11 ;
  int tmp___12 ;

  {
#line 335
  if (changed) {
    {
#line 336
    tmp___0 = gr_close();
    }
#line 336
    if (tmp___0 == 0) {
      {
#line 337
      tmp = gettext("%s: failure while writing changes to %s\n");
#line 337
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, grp_file);
#line 339
      fail_exit___11(5);
      }
    }
#line 342
    if (is_shadow___1) {
      {
#line 342
      tmp___2 = sgr_close();
      }
#line 342
      if (tmp___2 == 0) {
        {
#line 343
        tmp___1 = gettext("%s: failure while writing changes to %s\n");
#line 343
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                Prog, sgr_file);
#line 345
        fail_exit___11(5);
        }
      }
    }
  }
#line 354
  if (sgr_locked___5) {
    {
#line 355
    tmp___7 = sgr_unlock();
    }
#line 355
    if (tmp___7 == 0) {
      {
#line 356
      tmp___3 = sgr_dbname();
#line 356
      tmp___4 = gettext("%s: failed to unlock %s\n");
#line 356
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              Prog, tmp___3);
      }
      {
#line 357
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 357
        tmp___5 = setlocale(6, (char const   *)((void *)0));
#line 357
        old_locale = tmp___5;
#line 357
        saved_locale = (char *)((void *)0);
        }
#line 357
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 357
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 357
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 357
          setlocale(6, "C");
          }
        }
        {
#line 357
        tmp___6 = sgr_dbname();
#line 357
        syslog(3, "failed to unlock %s", tmp___6);
        }
#line 357
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 357
          setlocale(6, (char const   *)saved_locale);
#line 357
          free((void *)saved_locale);
          }
        }
#line 357
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 360
    sgr_locked___5 = (_Bool)0;
  }
#line 363
  if (gr_locked___5) {
    {
#line 364
    tmp___12 = gr_unlock();
    }
#line 364
    if (tmp___12 == 0) {
      {
#line 365
      tmp___8 = gr_dbname();
#line 365
      tmp___9 = gettext("%s: failed to unlock %s\n");
#line 365
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8);
      }
      {
#line 366
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 366
        tmp___10 = setlocale(6, (char const   *)((void *)0));
#line 366
        old_locale___0 = tmp___10;
#line 366
        saved_locale___0 = (char *)((void *)0);
        }
#line 366
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 366
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 366
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 366
          setlocale(6, "C");
          }
        }
        {
#line 366
        tmp___11 = gr_dbname();
#line 366
        syslog(3, "failed to unlock %s", tmp___11);
        }
#line 366
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 366
          setlocale(6, (char const   *)saved_locale___0);
#line 366
          free((void *)saved_locale___0);
          }
        }
#line 366
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 369
    gr_locked___5 = (_Bool)0;
  }
#line 371
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static int check_members(char const   *groupname , char **members___30 , char const   *fmt_info ,
                         char const   *fmt_prompt , char const   *fmt_syslog , int *errors___0 ) 
{ 
  int i ;
  int members_changed ;
  struct passwd *tmp ;
  _Bool tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;

  {
#line 400
  members_changed = 0;
#line 405
  i = 0;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! ((unsigned long )((void *)0) != (unsigned long )*(members___30 + i))) {
#line 405
      goto while_break;
    }
    {
#line 407
    tmp = getpwnam((char const   *)*(members___30 + i));
    }
#line 407
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 408
      goto __Cont;
    }
    {
#line 414
    (*errors___0) ++;
#line 415
    printf((char const   */* __restrict  */)fmt_info, groupname, *(members___30 + i));
#line 416
    printf((char const   */* __restrict  */)fmt_prompt, *(members___30 + i));
#line 418
    tmp___0 = yes_or_no(read_only___0);
    }
#line 418
    if (! tmp___0) {
#line 419
      goto __Cont;
    }
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 422
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 422
      old_locale = tmp___1;
#line 422
      saved_locale = (char *)((void *)0);
      }
#line 422
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 422
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 422
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 422
        setlocale(6, "C");
        }
      }
      {
#line 422
      syslog(6, fmt_syslog, *(members___30 + i), groupname);
      }
#line 422
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 422
        setlocale(6, (char const   *)saved_locale);
#line 422
        free((void *)saved_locale);
        }
      }
#line 422
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 423
    members_changed = 1;
#line 424
    delete_member(members___30, (char const   *)*(members___30 + i));
#line 427
    i --;
    }
    __Cont: /* CIL Label */ 
#line 405
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return (members_changed);
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void compare_members_lists(char const   *groupname , char **members___30 ,
                                  char **other_members , char const   *file , char const   *other_file ) 
{ 
  char **pmem ;
  char **other_pmem ;
  int tmp ;

  {
#line 452
  pmem = members___30;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! ((unsigned long )((void *)0) != (unsigned long )*pmem)) {
#line 452
      goto while_break;
    }
#line 453
    other_pmem = other_members;
    {
#line 453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 453
      if (! ((unsigned long )((void *)0) != (unsigned long )*other_pmem)) {
#line 453
        goto while_break___0;
      }
      {
#line 454
      tmp = strcmp((char const   *)*pmem, (char const   *)*other_pmem);
      }
#line 454
      if (tmp == 0) {
#line 455
        goto while_break___0;
      }
#line 453
      other_pmem ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 458
    if ((unsigned long )*other_pmem == (unsigned long )((void *)0)) {
      {
#line 459
      printf((char const   */* __restrict  */)"\'%s\' is a member of the \'%s\' group in %s but not in %s\n",
             *pmem, groupname, file, other_file);
      }
    }
#line 452
    pmem ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static char *empty___1  =    (char *)((void *)0);
#line 470 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void check_grp_file(int *errors___0 , _Bool *changed ) 
{ 
  struct commonio_entry *gre ;
  struct commonio_entry *tgre ;
  struct group *grp ;
  struct sgrp *sgr ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  struct group  const  *ent ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  struct sgrp  const  *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  struct sgrp sg ;
  struct group gr ;
  char *old_locale___0 ;
  char *tmp___16 ;
  char *saved_locale___0 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  _Bool tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
  {
#line 481
  gre = __gr_get_head();
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )((void *)0) != (unsigned long )gre)) {
#line 481
      goto while_break;
    }
#line 486
    if ((int )*(gre->line + 0) == 43) {
#line 487
      goto __Cont;
    } else
#line 486
    if ((int )*(gre->line + 0) == 45) {
#line 487
      goto __Cont;
    }
#line 495
    if ((unsigned long )((void *)0) == (unsigned long )gre->eptr) {
      {
#line 501
      tmp = gettext("invalid group file entry");
#line 501
      puts((char const   *)tmp);
#line 502
      tmp___0 = gettext("delete line \'%s\'? ");
#line 502
      printf((char const   */* __restrict  */)tmp___0, gre->line);
#line 503
      (*errors___0) ++;
#line 508
      tmp___1 = yes_or_no(read_only___0);
      }
#line 508
      if (! tmp___1) {
#line 509
        goto __Cont;
      }
      delete_gr: 
      {
#line 519
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 519
        tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 519
        old_locale = tmp___2;
#line 519
        saved_locale = (char *)((void *)0);
        }
#line 519
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 519
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 519
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 519
          setlocale(6, "C");
          }
        }
        {
#line 519
        syslog(6, "delete group line \'%s\'", gre->line);
        }
#line 519
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 519
          setlocale(6, (char const   *)saved_locale);
#line 519
          free((void *)saved_locale);
          }
        }
#line 519
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 521
      *changed = (_Bool)1;
#line 523
      __gr_del_entry((struct commonio_entry  const  *)gre);
      }
#line 524
      goto __Cont;
    }
    {
#line 530
    grp = (struct group *)gre->eptr;
#line 535
    tgre = __gr_get_head();
    }
    {
#line 535
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 535
      if (! ((unsigned long )((void *)0) != (unsigned long )tgre)) {
#line 535
        goto while_break___1;
      }
#line 537
      ent = (struct group  const  *)tgre->eptr;
#line 542
      if ((unsigned long )tgre == (unsigned long )gre) {
#line 543
        goto __Cont___0;
      }
#line 549
      if ((unsigned long )((void *)0) == (unsigned long )ent) {
#line 550
        goto __Cont___0;
      }
      {
#line 553
      tmp___3 = strcmp((char const   *)grp->gr_name, (char const   *)ent->gr_name);
      }
#line 553
      if (tmp___3 != 0) {
#line 554
        goto __Cont___0;
      }
      {
#line 561
      tmp___4 = gettext("duplicate group entry");
#line 561
      puts((char const   *)tmp___4);
#line 562
      tmp___5 = gettext("delete line \'%s\'? ");
#line 562
      printf((char const   */* __restrict  */)tmp___5, gre->line);
#line 563
      (*errors___0) ++;
#line 568
      tmp___6 = yes_or_no(read_only___0);
      }
#line 568
      if (tmp___6) {
#line 569
        goto delete_gr;
      }
      __Cont___0: /* CIL Label */ 
#line 535
      tgre = tgre->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 576
    tmp___8 = is_valid_group_name((char const   *)grp->gr_name);
    }
#line 576
    if (! tmp___8) {
      {
#line 577
      (*errors___0) ++;
#line 578
      tmp___7 = gettext("invalid group name \'%s\'\n");
#line 578
      printf((char const   */* __restrict  */)tmp___7, grp->gr_name);
      }
    }
#line 584
    if (grp->gr_gid == 4294967295U) {
      {
#line 585
      tmp___9 = gettext("invalid group ID \'%lu\'\n");
#line 585
      printf((char const   */* __restrict  */)tmp___9, (unsigned long )grp->gr_gid);
#line 586
      (*errors___0) ++;
      }
    }
#line 594
    if ((unsigned long )((void *)0) != (unsigned long )*(grp->gr_mem + 0)) {
#line 594
      if ((unsigned long )((void *)0) == (unsigned long )*(grp->gr_mem + 1)) {
#line 594
        if (0 == (int )*(*(grp->gr_mem + 0) + 0)) {
#line 597
          *(grp->gr_mem + 0) = (char *)((void *)0);
        }
      }
    }
    {
#line 600
    tmp___10 = gettext("delete member \'%s\'? ");
#line 600
    tmp___11 = gettext("group %s: no user %s\n");
#line 600
    tmp___12 = check_members((char const   *)grp->gr_name, grp->gr_mem, (char const   *)tmp___11,
                             (char const   *)tmp___10, "delete member \'%s\' from group \'%s\'",
                             errors___0);
    }
#line 600
    if (tmp___12 == 1) {
      {
#line 605
      *changed = (_Bool)1;
#line 606
      gre->changed = (_Bool)1;
#line 607
      __gr_set_changed();
      }
    }
#line 615
    if (is_shadow___1) {
      {
#line 616
      tmp___13 = sgr_locate((char const   *)grp->gr_name);
#line 616
      sgr = (struct sgrp *)tmp___13;
      }
#line 617
      if ((unsigned long )sgr == (unsigned long )((void *)0)) {
        {
#line 618
        tmp___14 = gettext("no matching group file entry in %s\n");
#line 618
        printf((char const   */* __restrict  */)tmp___14, sgr_file);
#line 620
        tmp___15 = gettext("add group \'%s\' in %s? ");
#line 620
        printf((char const   */* __restrict  */)tmp___15, grp->gr_name, sgr_file);
#line 622
        (*errors___0) ++;
#line 623
        tmp___23 = yes_or_no(read_only___0);
        }
#line 623
        if (tmp___23) {
#line 628
          sg.sg_name = grp->gr_name;
#line 629
          sg.sg_passwd = grp->gr_passwd;
#line 630
          sg.sg_adm = & empty___1;
#line 631
          sg.sg_mem = grp->gr_mem;
          {
#line 632
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 632
            tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 632
            old_locale___0 = tmp___16;
#line 632
            saved_locale___0 = (char *)((void *)0);
            }
#line 632
            if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
              {
#line 632
              saved_locale___0 = strdup((char const   *)old_locale___0);
              }
            }
#line 632
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 632
              setlocale(6, "C");
              }
            }
            {
#line 632
            syslog(6, "add group \'%s\' to \'%s\'", grp->gr_name, sgr_file);
            }
#line 632
            if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
              {
#line 632
              setlocale(6, (char const   *)saved_locale___0);
#line 632
              free((void *)saved_locale___0);
              }
            }
#line 632
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 635
          *changed = (_Bool)1;
#line 637
          tmp___19 = sgr_update((struct sgrp  const  *)(& sg));
          }
#line 637
          if (tmp___19 == 0) {
            {
#line 638
            tmp___17 = sgr_dbname();
#line 638
            tmp___18 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 638
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
                    Prog, tmp___17, sg.sg_name);
#line 641
            fail_exit___11(5);
            }
          }
          {
#line 644
          gr = *grp;
#line 645
          gr.gr_passwd = (char *)"x";
#line 646
          tmp___22 = gr_update((struct group  const  *)(& gr));
          }
#line 646
          if (tmp___22 == 0) {
            {
#line 647
            tmp___20 = gr_dbname();
#line 647
            tmp___21 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 647
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
                    Prog, tmp___20, gr.gr_name);
#line 650
            fail_exit___11(5);
            }
          }
        }
      } else {
        {
#line 658
        compare_members_lists((char const   *)grp->gr_name, grp->gr_mem, sgr->sg_mem,
                              grp_file, sgr_file);
#line 665
        tmp___25 = strcmp((char const   *)grp->gr_passwd, "x");
        }
#line 665
        if (tmp___25 != 0) {
          {
#line 666
          tmp___24 = gettext("group %s has an entry in %s, but its password field in %s is not set to \'x\'\n");
#line 666
          printf((char const   */* __restrict  */)tmp___24, grp->gr_name, sgr_file,
                 grp_file);
#line 668
          (*errors___0) ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 481
    gre = gre->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpck.c"
static void check_sgr_file(int *errors___0 , _Bool *changed ) 
{ 
  struct group *grp ;
  struct commonio_entry *sge ;
  struct commonio_entry *tsge ;
  struct sgrp *sgr ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  struct sgrp  const  *ent ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  struct group  const  *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
  {
#line 690
  sge = __sgr_get_head();
  }
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! ((unsigned long )((void *)0) != (unsigned long )sge)) {
#line 690
      goto while_break;
    }
#line 697
    if ((unsigned long )((void *)0) == (unsigned long )sge->eptr) {
      {
#line 703
      tmp = gettext("invalid shadow group file entry");
#line 703
      puts((char const   *)tmp);
#line 704
      tmp___0 = gettext("delete line \'%s\'? ");
#line 704
      printf((char const   */* __restrict  */)tmp___0, sge->line);
#line 705
      (*errors___0) ++;
#line 710
      tmp___1 = yes_or_no(read_only___0);
      }
#line 710
      if (! tmp___1) {
#line 711
        goto __Cont;
      }
      delete_sg: 
      {
#line 721
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 721
        tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 721
        old_locale = tmp___2;
#line 721
        saved_locale = (char *)((void *)0);
        }
#line 721
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 721
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 721
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 721
          setlocale(6, "C");
          }
        }
        {
#line 721
        syslog(6, "delete shadow line \'%s\'", sge->line);
        }
#line 721
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 721
          setlocale(6, (char const   *)saved_locale);
#line 721
          free((void *)saved_locale);
          }
        }
#line 721
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 723
      *changed = (_Bool)1;
#line 725
      __sgr_del_entry((struct commonio_entry  const  *)sge);
      }
#line 726
      goto __Cont;
    }
    {
#line 732
    sgr = (struct sgrp *)sge->eptr;
#line 737
    tsge = __sgr_get_head();
    }
    {
#line 737
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 737
      if (! ((unsigned long )((void *)0) != (unsigned long )tsge)) {
#line 737
        goto while_break___1;
      }
#line 739
      ent = (struct sgrp  const  *)tsge->eptr;
#line 744
      if ((unsigned long )tsge == (unsigned long )sge) {
#line 745
        goto __Cont___0;
      }
#line 751
      if ((unsigned long )((void *)0) == (unsigned long )ent) {
#line 752
        goto __Cont___0;
      }
      {
#line 755
      tmp___3 = strcmp((char const   *)sgr->sg_name, (char const   *)ent->sg_name);
      }
#line 755
      if (tmp___3 != 0) {
#line 756
        goto __Cont___0;
      }
      {
#line 763
      tmp___4 = gettext("duplicate shadow group entry");
#line 763
      puts((char const   *)tmp___4);
#line 764
      tmp___5 = gettext("delete line \'%s\'? ");
#line 764
      printf((char const   */* __restrict  */)tmp___5, sge->line);
#line 765
      (*errors___0) ++;
#line 770
      tmp___6 = yes_or_no(read_only___0);
      }
#line 770
      if (tmp___6) {
#line 771
        goto delete_sg;
      }
      __Cont___0: /* CIL Label */ 
#line 737
      tsge = tsge->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 778
    tmp___7 = gr_locate((char const   *)sgr->sg_name);
#line 778
    grp = (struct group *)tmp___7;
    }
#line 779
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
      {
#line 780
      tmp___8 = gettext("no matching group file entry in %s\n");
#line 780
      printf((char const   */* __restrict  */)tmp___8, grp_file);
#line 782
      tmp___9 = gettext("delete line \'%s\'? ");
#line 782
      printf((char const   */* __restrict  */)tmp___9, sge->line);
#line 783
      (*errors___0) ++;
#line 784
      tmp___10 = yes_or_no(read_only___0);
      }
#line 784
      if (tmp___10) {
#line 785
        goto delete_sg;
      }
    } else {
      {
#line 792
      compare_members_lists((char const   *)sgr->sg_name, sgr->sg_mem, grp->gr_mem,
                            sgr_file, grp_file);
      }
    }
    {
#line 800
    tmp___11 = gettext("delete administrative member \'%s\'? ");
#line 800
    tmp___12 = gettext("shadow group %s: no administrative user %s\n");
#line 800
    tmp___13 = check_members((char const   *)sgr->sg_name, sgr->sg_adm, (char const   *)tmp___12,
                             (char const   *)tmp___11, "delete admin \'%s\' from shadow group \'%s\'",
                             errors___0);
    }
#line 800
    if (tmp___13 == 1) {
      {
#line 805
      *changed = (_Bool)1;
#line 806
      sge->changed = (_Bool)1;
#line 807
      __sgr_set_changed();
      }
    }
    {
#line 813
    tmp___14 = gettext("delete member \'%s\'? ");
#line 813
    tmp___15 = gettext("shadow group %s: no user %s\n");
#line 813
    tmp___16 = check_members((char const   *)sgr->sg_name, sgr->sg_mem, (char const   *)tmp___15,
                             (char const   *)tmp___14, "delete member \'%s\' from shadow group \'%s\'",
                             errors___0);
    }
#line 813
    if (tmp___16 == 1) {
      {
#line 818
      *changed = (_Bool)1;
#line 819
      sge->changed = (_Bool)1;
#line 820
      __sgr_set_changed();
      }
    }
    __Cont: /* CIL Label */ 
#line 690
    sge = sge->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___22  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___22  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___22  ;
#line 72
static int copy_entry___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___22(char const   *filename___0 ) ;
#line 83
static int copy_symlink___22(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___22(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___22(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___22(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___22(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___22(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___22 == (unsigned long )ln) {
    {
#line 149
    links___22 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___22;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___22(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___22)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___22)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___22;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___22);
#line 199
  dst_len = strlen(dst_orig___22);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___22, name___3 + src_len);
#line 207
  lp->ln_next = links___22;
#line 208
  links___22 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___22(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___22(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___22(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___22(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___22(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___22(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___22(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___22(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___22(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___22)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___22)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___22(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___22);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___22, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___22);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___22);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___22);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___22, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___22(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___22(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___22(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___22(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___22(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___22(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___22(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___22(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___22(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___22[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___22[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___23(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___23(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___23[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___23[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___23  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___21(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___22  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___43  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___21(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___43) {
#line 70
      size___43 = i + 100;
#line 71
      if (members___22) {
        {
#line 72
        tmp = realloc((void *)members___22, (unsigned long )size___43 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___43 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___22) {
          {
#line 81
          free((void *)members___22);
          }
        }
#line 82
        members___22 = (char **)0;
#line 83
        size___43 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___22 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___22 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___22 + i) = (char *)0;
#line 99
  return (members___22);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___21  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___44  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___21[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___21  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___23(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___23(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___23  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___23  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___23  ;
#line 72
static int copy_entry___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___23(char const   *filename___0 ) ;
#line 83
static int copy_symlink___23(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___23(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___23(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___23(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___23(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___23(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___23 == (unsigned long )ln) {
    {
#line 149
    links___23 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___23;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___23(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___23)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___23)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___23;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___23);
#line 199
  dst_len = strlen(dst_orig___23);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___23, name___3 + src_len);
#line 207
  lp->ln_next = links___23;
#line 208
  links___23 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___23(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___23(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___23(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___23(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___23(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___23(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___23(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___23(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___23(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___23)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___23)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___23(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___23);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___23, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___23);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___23);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___23);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___23, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___23(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___23(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___23(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___23(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___23(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___23(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___23(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___23(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___23(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static _Bool is_shadow_grp___6  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static char *group_name___1  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static char *group_newname  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static char *group_passwd___0  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static gid_t group_id___1  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static gid_t group_newid  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static struct cleanup_info_mod info_passwd  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static struct cleanup_info_mod info_group  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static struct cleanup_info_mod info_gshadow  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static _Bool oflg___2  =    (_Bool)0;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static _Bool gflg___2  =    (_Bool)0;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static _Bool nflg  =    (_Bool)0;
#line 89 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static _Bool pflg___2  =    (_Bool)0;
#line 96
static void usage___20(int status ) ;
#line 97
static void new_grent___1(struct group *grent___29 ) ;
#line 100
static void new_sgent___1(struct sgrp *sgent ) ;
#line 102
static void grp_update___3(void) ;
#line 103
static void check_new_gid(void) ;
#line 104
static void check_new_name___0(void) ;
#line 105
static void process_flags___16(int argc , char **argv ) ;
#line 106
static void lock_files(void) ;
#line 107
static void prepare_failure_reports(void) ;
#line 108
static void open_files___11(void) ;
#line 109
static void close_files___11(void) ;
#line 110
static void update_primary_groups(gid_t ogid , gid_t ngid ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void usage___20(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 118
  if (0 != status) {
#line 118
    tmp = stderr;
  } else {
#line 118
    tmp = stdout;
  }
  {
#line 118
  usageout = tmp;
#line 119
  tmp___0 = gettext("Usage: %s [options] GROUP\n\nOptions:\n");
#line 119
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 124
  tmp___1 = gettext("  -g, --gid GID                 change the group ID to GID\n");
#line 124
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 125
  tmp___2 = gettext("  -h, --help                    display this help message and exit\n");
#line 125
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 126
  tmp___3 = gettext("  -n, --new-name NEW_GROUP      change the name to NEW_GROUP\n");
#line 126
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 127
  tmp___4 = gettext("  -o, --non-unique              allow to use a duplicate (non-unique) GID\n");
#line 127
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 128
  tmp___5 = gettext("  -p, --password PASSWORD       change the password to this (encrypted)\n                                PASSWORD\n");
#line 128
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 130
  tmp___6 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 130
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 131
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 132
  exit(status);
  }
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void new_grent___1(struct group *grent___29 ) 
{ 
  int tmp ;

  {
#line 143
  if (nflg) {
    {
#line 144
    grent___29->gr_name = xstrdup((char const   *)group_newname);
    }
  }
#line 147
  if (gflg___2) {
#line 148
    grent___29->gr_gid = group_newid;
  }
#line 151
  if (pflg___2) {
#line 151
    if (! is_shadow_grp___6) {
#line 162
      grent___29->gr_passwd = group_passwd___0;
    } else {
      {
#line 151
      tmp = strcmp((char const   *)grent___29->gr_passwd, "x");
      }
#line 151
      if (tmp != 0) {
#line 162
        grent___29->gr_passwd = group_passwd___0;
      }
    }
  }
#line 164
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void new_sgent___1(struct sgrp *sgent ) 
{ 


  {
#line 175
  if (nflg) {
    {
#line 176
    sgent->sg_name = xstrdup((char const   *)group_newname);
    }
  }
#line 186
  if (pflg___2) {
#line 187
    sgent->sg_passwd = group_passwd___0;
  }
#line 189
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static char *empty___2  =    (char *)((void *)0);
#line 197 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void grp_update___3(void) 
{ 
  struct group grp ;
  struct group  const  *ogrp ;
  struct sgrp sgrp ;
  struct sgrp  const  *osgrp ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 204
  osgrp = (struct sgrp  const  *)((void *)0);
#line 210
  ogrp = gr_locate((char const   *)group_name___1);
  }
#line 211
  if ((unsigned long )((void *)0) == (unsigned long )ogrp) {
    {
#line 212
    tmp = gr_dbname();
#line 212
    tmp___0 = gettext("%s: group \'%s\' does not exist in %s\n");
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, group_name___1, tmp);
#line 215
    exit(10);
    }
  }
  {
#line 217
  grp = (struct group )*ogrp;
#line 218
  new_grent___1(& grp);
  }
#line 220
  if (is_shadow_grp___6) {
#line 220
    if (pflg___2) {
#line 220
      goto _L;
    } else
#line 220
    if (nflg) {
      _L: /* CIL Label */ 
      {
#line 222
      osgrp = sgr_locate((char const   *)group_name___1);
      }
#line 223
      if ((unsigned long )((void *)0) != (unsigned long )osgrp) {
        {
#line 224
        sgrp = (struct sgrp )*osgrp;
#line 225
        new_sgent___1(& sgrp);
        }
      } else
#line 226
      if (pflg___2) {
        {
#line 226
        tmp___1 = strcmp((char const   *)grp.gr_passwd, "x");
        }
#line 226
        if (tmp___1 == 0) {
          {
#line 234
          memset((void *)(& sgrp), 0, sizeof(sgrp));
#line 235
          sgrp.sg_name = xstrdup((char const   *)grp.gr_name);
#line 236
          sgrp.sg_passwd = xstrdup((char const   *)grp.gr_passwd);
#line 237
          sgrp.sg_adm = & empty___2;
#line 238
          sgrp.sg_mem = dup_list((char * const  *)grp.gr_mem);
#line 239
          new_sgent___1(& sgrp);
#line 240
          osgrp = (struct sgrp  const  *)(& sgrp);
          }
        }
      }
    }
  }
#line 245
  if (gflg___2) {
    {
#line 246
    update_primary_groups((gid_t )ogrp->gr_gid, group_newid);
    }
  }
  {
#line 252
  tmp___4 = gr_update((struct group  const  *)(& grp));
  }
#line 252
  if (tmp___4 == 0) {
    {
#line 253
    tmp___2 = gr_dbname();
#line 253
    tmp___3 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2, grp.gr_name);
#line 256
    exit(10);
    }
  }
#line 258
  if (nflg) {
    {
#line 258
    tmp___7 = gr_remove((char const   *)group_name___1);
    }
#line 258
    if (tmp___7 == 0) {
      {
#line 259
      tmp___5 = gr_dbname();
#line 259
      tmp___6 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 259
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, grp.gr_name, tmp___5);
#line 262
      exit(10);
      }
    }
  }
#line 269
  if ((unsigned long )((void *)0) != (unsigned long )osgrp) {
    {
#line 273
    tmp___10 = sgr_update((struct sgrp  const  *)(& sgrp));
    }
#line 273
    if (tmp___10 == 0) {
      {
#line 274
      tmp___8 = sgr_dbname();
#line 274
      tmp___9 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 274
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
              Prog, tmp___8, sgrp.sg_name);
#line 277
      exit(10);
      }
    }
#line 279
    if (nflg) {
      {
#line 279
      tmp___13 = sgr_remove((char const   *)group_name___1);
      }
#line 279
      if (tmp___13 == 0) {
        {
#line 280
        tmp___11 = sgr_dbname();
#line 280
        tmp___12 = gettext("%s: cannot remove entry \'%s\' from %s\n");
#line 280
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                Prog, group_name___1, tmp___11);
#line 283
        exit(10);
        }
      }
    }
  }
#line 287
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void check_new_gid(void) 
{ 
  struct group *tmp ;
  char *tmp___0 ;

  {
#line 301
  if (group_id___1 == group_newid) {
#line 302
    gflg___2 = (_Bool)0;
#line 303
    return;
  }
#line 306
  if (oflg___2) {
#line 309
    return;
  } else {
    {
#line 306
    tmp = getgrgid(group_newid);
    }
#line 306
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 309
      return;
    }
  }
  {
#line 315
  tmp___0 = gettext("%s: GID \'%lu\' already exists\n");
#line 315
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          Prog, (unsigned long )group_newid);
#line 318
  exit(4);
  }
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void check_new_name___0(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  struct group *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 332
  tmp = strcmp((char const   *)group_name___1, (char const   *)group_newname);
  }
#line 332
  if (tmp == 0) {
#line 333
    nflg = (_Bool)0;
#line 334
    return;
  }
  {
#line 337
  tmp___2 = is_valid_group_name((char const   *)group_newname);
  }
#line 337
  if (tmp___2) {
    {
#line 343
    tmp___1 = getgrnam((char const   *)group_newname);
    }
#line 343
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 344
      tmp___0 = gettext("%s: group \'%s\' already exists\n");
#line 344
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, group_newname);
#line 347
      exit(9);
      }
    }
#line 349
    return;
  }
  {
#line 356
  tmp___3 = gettext("%s: invalid group name \'%s\'\n");
#line 356
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
          Prog, group_newname);
#line 359
  exit(3);
  }
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static struct option long_options___17[7]  = {      {"gid", 1, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"new-name", 1, (int *)((void *)0), 'n'}, 
        {"non-unique", 0, (int *)((void *)0), 'o'}, 
        {"password", 1, (int *)((void *)0), 'p'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 369 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void process_flags___16(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    c = getopt_long(argc, (char * const  *)argv, "g:hn:op:R:", (struct option  const  *)(long_options___17),
                    (int *)((void *)0));
    }
#line 381
    if (! (c != -1)) {
#line 381
      goto while_break;
    }
    {
#line 384
    if (c == 103) {
#line 384
      goto case_103;
    }
#line 394
    if (c == 104) {
#line 394
      goto case_104;
    }
#line 397
    if (c == 110) {
#line 397
      goto case_110;
    }
#line 401
    if (c == 111) {
#line 401
      goto case_111;
    }
#line 404
    if (c == 112) {
#line 404
      goto case_112;
    }
#line 408
    if (c == 82) {
#line 408
      goto case_82;
    }
#line 410
    goto switch_default;
    case_103: /* CIL Label */ 
    {
#line 385
    gflg___2 = (_Bool)1;
#line 386
    tmp___0 = get_gid((char const   *)optarg, & group_newid);
    }
#line 386
    if (tmp___0 == 0) {
      {
#line 388
      tmp = gettext("%s: invalid group ID \'%s\'\n");
#line 388
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 391
      exit(3);
      }
    } else
#line 386
    if (group_newid == 4294967295U) {
      {
#line 388
      tmp = gettext("%s: invalid group ID \'%s\'\n");
#line 388
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, optarg);
#line 391
      exit(3);
      }
    }
#line 393
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 395
    usage___20(0);
    }
#line 396
    goto switch_break;
    case_110: /* CIL Label */ 
#line 398
    nflg = (_Bool)1;
#line 399
    group_newname = optarg;
#line 400
    goto switch_break;
    case_111: /* CIL Label */ 
#line 402
    oflg___2 = (_Bool)1;
#line 403
    goto switch_break;
    case_112: /* CIL Label */ 
#line 405
    group_passwd___0 = optarg;
#line 406
    pflg___2 = (_Bool)1;
#line 407
    goto switch_break;
    case_82: /* CIL Label */ 
#line 409
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 411
    usage___20(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if (oflg___2) {
#line 415
    if (! gflg___2) {
      {
#line 416
      usage___20(2);
      }
    }
  }
#line 419
  if (optind != argc - 1) {
    {
#line 420
    usage___20(2);
    }
  }
#line 423
  group_name___1 = *(argv + (argc - 1));
#line 424
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void close_files___11(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *old_locale___0 ;
  char *tmp___7 ;
  char *saved_locale___0 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *old_locale___1 ;
  char *tmp___12 ;
  char *saved_locale___1 ;
  char const   *tmp___13 ;

  {
  {
#line 434
  tmp___1 = gr_close();
  }
#line 434
  if (tmp___1 == 0) {
    {
#line 435
    tmp = gr_dbname();
#line 435
    tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 435
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 438
    exit(10);
    }
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 446
    tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 446
    old_locale = tmp___2;
#line 446
    saved_locale = (char *)((void *)0);
    }
#line 446
    if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
      {
#line 446
      saved_locale = strdup((char const   *)old_locale);
      }
    }
#line 446
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 446
      setlocale(6, "C");
      }
    }
    {
#line 446
    tmp___3 = gr_dbname();
#line 446
    syslog(6, "group changed in %s (%s)", tmp___3, info_group.action);
    }
#line 446
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
      {
#line 446
      setlocale(6, (char const   *)saved_locale);
#line 446
      free((void *)saved_locale);
      }
    }
#line 446
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  del_cleanup(& cleanup_report_mod_group);
#line 451
  cleanup_unlock_group((void *)0);
#line 452
  del_cleanup(& cleanup_unlock_group);
  }
#line 455
  if (is_shadow_grp___6) {
#line 455
    if (pflg___2) {
#line 455
      goto _L;
    } else
#line 455
    if (nflg) {
      _L: /* CIL Label */ 
      {
#line 457
      tmp___6 = sgr_close();
      }
#line 457
      if (tmp___6 == 0) {
        {
#line 458
        tmp___4 = sgr_dbname();
#line 458
        tmp___5 = gettext("%s: failure while writing changes to %s\n");
#line 458
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, tmp___4);
#line 461
        exit(10);
        }
      }
      {
#line 469
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 469
        tmp___7 = setlocale(6, (char const   *)((void *)0));
#line 469
        old_locale___0 = tmp___7;
#line 469
        saved_locale___0 = (char *)((void *)0);
        }
#line 469
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 469
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 469
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 469
          setlocale(6, "C");
          }
        }
        {
#line 469
        tmp___8 = sgr_dbname();
#line 469
        syslog(6, "group changed in %s (%s)", tmp___8, info_gshadow.action);
        }
#line 469
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 469
          setlocale(6, (char const   *)saved_locale___0);
#line 469
          free((void *)saved_locale___0);
          }
        }
#line 469
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 472
      del_cleanup(& cleanup_report_mod_gshadow);
#line 474
      cleanup_unlock_gshadow((void *)0);
#line 475
      del_cleanup(& cleanup_unlock_gshadow);
      }
    }
  }
#line 479
  if (gflg___2) {
    {
#line 480
    tmp___11 = pw_close();
    }
#line 480
    if (tmp___11 == 0) {
      {
#line 481
      tmp___9 = pw_dbname();
#line 481
      tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
#line 484
      exit(10);
      }
    }
    {
#line 492
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 492
      tmp___12 = setlocale(6, (char const   *)((void *)0));
#line 492
      old_locale___1 = tmp___12;
#line 492
      saved_locale___1 = (char *)((void *)0);
      }
#line 492
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 492
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 492
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 492
        setlocale(6, "C");
        }
      }
      {
#line 492
      tmp___13 = pw_dbname();
#line 492
      syslog(6, "group changed in %s (%s)", tmp___13, info_passwd.action);
      }
#line 492
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 492
        setlocale(6, (char const   *)saved_locale___1);
#line 492
        free((void *)saved_locale___1);
        }
      }
#line 492
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 495
    del_cleanup(& cleanup_report_mod_passwd);
#line 497
    cleanup_unlock_passwd((void *)0);
#line 498
    del_cleanup(& cleanup_unlock_passwd);
    }
  }
#line 507
  return;
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void prepare_failure_reports(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;

  {
  {
#line 515
  info_group.name = (char const   *)group_name___1;
#line 517
  info_gshadow.name = (char const   *)group_name___1;
#line 519
  info_passwd.name = (char const   *)group_name___1;
#line 521
  info_group.audit_msg = xmalloc((size_t )512);
#line 523
  info_gshadow.audit_msg = xmalloc((size_t )512);
#line 525
  info_passwd.audit_msg = xmalloc((size_t )512);
#line 527
  tmp = gr_dbname();
#line 527
  snprintf((char */* __restrict  */)info_group.audit_msg, (size_t )511, (char const   */* __restrict  */)"changing %s; ",
           tmp);
#line 530
  tmp___0 = sgr_dbname();
#line 530
  snprintf((char */* __restrict  */)info_gshadow.audit_msg, (size_t )511, (char const   */* __restrict  */)"changing %s; ",
           tmp___0);
#line 533
  tmp___1 = pw_dbname();
#line 533
  snprintf((char */* __restrict  */)info_passwd.audit_msg, (size_t )511, (char const   */* __restrict  */)"changing %s; ",
           tmp___1);
#line 536
  tmp___2 = strlen((char const   *)info_group.audit_msg);
#line 536
  info_group.action = info_group.audit_msg + tmp___2;
#line 539
  tmp___3 = strlen((char const   *)info_gshadow.audit_msg);
#line 539
  info_gshadow.action = info_gshadow.audit_msg + tmp___3;
#line 542
  tmp___4 = strlen((char const   *)info_passwd.audit_msg);
#line 542
  info_passwd.action = info_passwd.audit_msg + tmp___4;
#line 545
  tmp___5 = strlen((char const   *)info_group.audit_msg);
#line 545
  snprintf((char */* __restrict  */)info_group.action, 511UL - tmp___5, (char const   */* __restrict  */)"group %s/%lu",
           group_name___1, (unsigned long )group_id___1);
#line 550
  tmp___6 = strlen((char const   *)info_group.audit_msg);
#line 550
  snprintf((char */* __restrict  */)info_gshadow.action, 511UL - tmp___6, (char const   */* __restrict  */)"group %s",
           group_name___1);
#line 554
  tmp___7 = strlen((char const   *)info_group.audit_msg);
#line 554
  snprintf((char */* __restrict  */)info_passwd.action, 511UL - tmp___7, (char const   */* __restrict  */)"group %s/%lu",
           group_name___1, (unsigned long )group_id___1);
  }
#line 559
  if (nflg) {
    {
#line 560
    tmp___8 = strlen((char const   *)info_group.audit_msg);
#line 560
    strncat((char */* __restrict  */)info_group.action, (char const   */* __restrict  */)", new name: ",
            511UL - tmp___8);
#line 562
    tmp___9 = strlen((char const   *)info_group.audit_msg);
#line 562
    strncat((char */* __restrict  */)info_group.action, (char const   */* __restrict  */)group_newname,
            511UL - tmp___9);
#line 566
    tmp___10 = strlen((char const   *)info_gshadow.audit_msg);
#line 566
    strncat((char */* __restrict  */)info_gshadow.action, (char const   */* __restrict  */)", new name: ",
            511UL - tmp___10);
#line 568
    tmp___11 = strlen((char const   *)info_gshadow.audit_msg);
#line 568
    strncat((char */* __restrict  */)info_gshadow.action, (char const   */* __restrict  */)group_newname,
            511UL - tmp___11);
#line 572
    tmp___12 = strlen((char const   *)info_passwd.audit_msg);
#line 572
    strncat((char */* __restrict  */)info_passwd.action, (char const   */* __restrict  */)", new name: ",
            511UL - tmp___12);
#line 574
    tmp___13 = strlen((char const   *)info_passwd.audit_msg);
#line 574
    strncat((char */* __restrict  */)info_passwd.action, (char const   */* __restrict  */)group_newname,
            511UL - tmp___13);
    }
  }
#line 577
  if (pflg___2) {
    {
#line 578
    tmp___14 = strlen((char const   *)info_group.audit_msg);
#line 578
    strncat((char */* __restrict  */)info_group.action, (char const   */* __restrict  */)", new password",
            511UL - tmp___14);
#line 582
    tmp___15 = strlen((char const   *)info_gshadow.audit_msg);
#line 582
    strncat((char */* __restrict  */)info_gshadow.action, (char const   */* __restrict  */)", new password",
            511UL - tmp___15);
    }
  }
#line 586
  if (gflg___2) {
    {
#line 587
    tmp___16 = strlen((char const   *)info_group.audit_msg);
#line 587
    strncat((char */* __restrict  */)info_group.action, (char const   */* __restrict  */)", new gid: ",
            511UL - tmp___16);
#line 589
    tmp___17 = strlen((char const   *)info_group.audit_msg);
#line 589
    tmp___18 = strlen((char const   *)info_group.action);
#line 589
    snprintf((char */* __restrict  */)(info_group.action + tmp___18), 511UL - tmp___17,
             (char const   */* __restrict  */)"%lu", (unsigned long )group_newid);
#line 593
    tmp___19 = strlen((char const   *)info_passwd.audit_msg);
#line 593
    strncat((char */* __restrict  */)info_passwd.action, (char const   */* __restrict  */)", new gid: ",
            511UL - tmp___19);
#line 595
    tmp___20 = strlen((char const   *)info_passwd.audit_msg);
#line 595
    tmp___21 = strlen((char const   *)info_passwd.action);
#line 595
    snprintf((char */* __restrict  */)(info_passwd.action + tmp___21), 511UL - tmp___20,
             (char const   */* __restrict  */)"%lu", (unsigned long )group_newid);
    }
  }
  {
#line 599
  *(info_group.audit_msg + 511) = (char )'\000';
#line 601
  *(info_gshadow.audit_msg + 511) = (char )'\000';
#line 603
  *(info_passwd.audit_msg + 511) = (char )'\000';
#line 606
  add_cleanup(& cleanup_report_mod_group, (void *)(& info_group));
  }
#line 608
  if (is_shadow_grp___6) {
#line 608
    if (pflg___2) {
      {
#line 610
      add_cleanup(& cleanup_report_mod_gshadow, (void *)(& info_gshadow));
      }
    } else
#line 608
    if (nflg) {
      {
#line 610
      add_cleanup(& cleanup_report_mod_gshadow, (void *)(& info_gshadow));
      }
    }
  }
#line 613
  if (gflg___2) {
    {
#line 614
    add_cleanup(& cleanup_report_mod_passwd, (void *)(& info_passwd));
    }
  }
#line 617
  return;
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void lock_files(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 626
  tmp___1 = gr_lock();
  }
#line 626
  if (tmp___1 == 0) {
    {
#line 627
    tmp = gr_dbname();
#line 627
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 627
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 630
    exit(10);
    }
  }
  {
#line 632
  add_cleanup(& cleanup_unlock_group, (void *)0);
  }
#line 635
  if (is_shadow_grp___6) {
#line 635
    if (pflg___2) {
#line 635
      goto _L;
    } else
#line 635
    if (nflg) {
      _L: /* CIL Label */ 
      {
#line 637
      tmp___4 = sgr_lock();
      }
#line 637
      if (tmp___4 == 0) {
        {
#line 638
        tmp___2 = sgr_dbname();
#line 638
        tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 638
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                Prog, tmp___2);
#line 641
        exit(10);
        }
      }
      {
#line 643
      add_cleanup(& cleanup_unlock_gshadow, (void *)0);
      }
    }
  }
#line 647
  if (gflg___2) {
    {
#line 648
    tmp___7 = pw_lock();
    }
#line 648
    if (tmp___7 == 0) {
      {
#line 649
      tmp___5 = pw_dbname();
#line 649
      tmp___6 = gettext("%s: cannot lock %s; try again later.\n");
#line 649
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog, tmp___5);
#line 652
      exit(10);
      }
    }
    {
#line 654
    add_cleanup(& cleanup_unlock_passwd, (void *)0);
    }
  }
#line 656
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void open_files___11(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 666
  tmp___3 = gr_open(2);
  }
#line 666
  if (tmp___3 == 0) {
    {
#line 667
    tmp = gr_dbname();
#line 667
    tmp___0 = gettext("%s: cannot open %s\n");
#line 667
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
    }
    {
#line 668
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 668
      tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 668
      old_locale = tmp___1;
#line 668
      saved_locale = (char *)((void *)0);
      }
#line 668
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 668
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 668
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 668
        setlocale(6, "C");
        }
      }
      {
#line 668
      tmp___2 = gr_dbname();
#line 668
      syslog(4, "cannot open %s", tmp___2);
      }
#line 668
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 668
        setlocale(6, (char const   *)saved_locale);
#line 668
        free((void *)saved_locale);
        }
      }
#line 668
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 669
    exit(10);
    }
  }
#line 673
  if (is_shadow_grp___6) {
#line 673
    if (pflg___2) {
#line 673
      goto _L;
    } else
#line 673
    if (nflg) {
      _L: /* CIL Label */ 
      {
#line 675
      tmp___8 = sgr_open(2);
      }
#line 675
      if (tmp___8 == 0) {
        {
#line 676
        tmp___4 = sgr_dbname();
#line 676
        tmp___5 = gettext("%s: cannot open %s\n");
#line 676
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                Prog, tmp___4);
        }
        {
#line 679
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 679
          tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 679
          old_locale___0 = tmp___6;
#line 679
          saved_locale___0 = (char *)((void *)0);
          }
#line 679
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
            {
#line 679
            saved_locale___0 = strdup((char const   *)old_locale___0);
            }
          }
#line 679
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 679
            setlocale(6, "C");
            }
          }
          {
#line 679
          tmp___7 = sgr_dbname();
#line 679
          syslog(4, "cannot open %s", tmp___7);
          }
#line 679
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
            {
#line 679
            setlocale(6, (char const   *)saved_locale___0);
#line 679
            free((void *)saved_locale___0);
            }
          }
#line 679
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 680
        exit(10);
        }
      }
    }
  }
#line 685
  if (gflg___2) {
    {
#line 686
    tmp___13 = pw_open(2);
    }
#line 686
    if (tmp___13 == 0) {
      {
#line 687
      tmp___9 = pw_dbname();
#line 687
      tmp___10 = gettext("%s: cannot open %s\n");
#line 687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
      }
      {
#line 690
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 690
        tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 690
        old_locale___1 = tmp___11;
#line 690
        saved_locale___1 = (char *)((void *)0);
        }
#line 690
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
          {
#line 690
          saved_locale___1 = strdup((char const   *)old_locale___1);
          }
        }
#line 690
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 690
          setlocale(6, "C");
          }
        }
        {
#line 690
        tmp___12 = gr_dbname();
#line 690
        syslog(4, "cannot open %s", tmp___12);
        }
#line 690
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
          {
#line 690
          setlocale(6, (char const   *)saved_locale___1);
#line 690
          free((void *)saved_locale___1);
          }
        }
#line 690
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 691
      exit(10);
      }
    }
  }
#line 694
  return;
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmod.c"
static void update_primary_groups(gid_t ogid , gid_t ngid ) 
{ 
  struct passwd *pwd ;
  struct passwd  const  *lpwd ;
  struct passwd npwd ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 700
  setpwent();
  }
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 701
    pwd = getpwent();
    }
#line 701
    if (! ((unsigned long )pwd != (unsigned long )((void *)0))) {
#line 701
      goto while_break;
    }
#line 702
    if (pwd->pw_gid == ogid) {
      {
#line 705
      lpwd = pw_locate((char const   *)pwd->pw_name);
      }
#line 706
      if ((unsigned long )((void *)0) == (unsigned long )lpwd) {
        {
#line 707
        tmp = pw_dbname();
#line 707
        tmp___0 = gettext("%s: user \'%s\' does not exist in %s\n");
#line 707
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                Prog, pwd->pw_name, tmp);
#line 710
        exit(10);
        }
      } else {
        {
#line 712
        npwd = (struct passwd )*lpwd;
#line 713
        npwd.pw_gid = ngid;
#line 714
        tmp___3 = pw_update((struct passwd  const  *)(& npwd));
        }
#line 714
        if (tmp___3 == 0) {
          {
#line 715
          tmp___1 = pw_dbname();
#line 715
          tmp___2 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 715
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                  Prog, tmp___1, npwd.pw_name);
#line 718
          exit(10);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  endpwent();
  }
#line 724
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___23[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___23[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___24(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___24(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___24[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___24[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___24  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___22(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___23  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___45  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___22(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___45) {
#line 70
      size___45 = i + 100;
#line 71
      if (members___23) {
        {
#line 72
        tmp = realloc((void *)members___23, (unsigned long )size___45 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___45 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___23) {
          {
#line 81
          free((void *)members___23);
          }
        }
#line 82
        members___23 = (char **)0;
#line 83
        size___45 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___23 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___23 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___23 + i) = (char *)0;
#line 99
  return (members___23);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___22  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___46  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___22[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___22  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___24(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___24(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___24  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___24  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___24  ;
#line 72
static int copy_entry___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___24(char const   *filename___0 ) ;
#line 83
static int copy_symlink___24(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___24(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___24(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___24(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___24(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___24(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___24 == (unsigned long )ln) {
    {
#line 149
    links___24 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___24;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___24(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___24)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___24)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___24;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___24);
#line 199
  dst_len = strlen(dst_orig___24);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___24, name___3 + src_len);
#line 207
  lp->ln_next = links___24;
#line 208
  links___24 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___24(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___24(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___24(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___24(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___24(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___24(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___24(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___24(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___24(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___24)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___24)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___24(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___24);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___24, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___24);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___24);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___24);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___24, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___24(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___24(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___24(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___24(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___24(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___24(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___24(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___24(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___24(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static char const   *filename  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static char const   *fileeditname  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static _Bool filelocked  =    (_Bool)0;
#line 68 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static _Bool createedit  =    (_Bool)0;
#line 69 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static int (*unlock)(void)  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static _Bool quiet___0  =    (_Bool)0;
#line 78
static void usage___21(int status ) ;
#line 79
static int create_backup_file(FILE *fp , char const   *backup , struct stat *sb ) ;
#line 80
static void vipwexit(char const   *msg , int syserr , int ret ) ;
#line 81
static void vipwedit(char const   *file , int (*file_lock)(void) , int (*file_unlock)(void) ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static void usage___21(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 88
  if (0 != status) {
#line 88
    tmp = stderr;
  } else {
#line 88
    tmp = stdout;
  }
  {
#line 88
  usageout = tmp;
#line 89
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 94
  tmp___1 = gettext("  -g, --group                   edit group database\n");
#line 94
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 95
  tmp___2 = gettext("  -h, --help                    display this help message and exit\n");
#line 95
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 96
  tmp___3 = gettext("  -p, --passwd                  edit passwd database\n");
#line 96
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 97
  tmp___4 = gettext("  -q, --quiet                   quiet mode\n");
#line 97
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 98
  tmp___5 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 98
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 99
  tmp___6 = gettext("  -s, --shadow                  edit shadow or gshadow database\n");
#line 99
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 103
  tmp___7 = gettext("\n");
#line 103
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 104
  exit(status);
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static int create_backup_file(FILE *fp , char const   *backup , struct stat *sb ) 
{ 
  struct utimbuf ub ;
  FILE *bkfp ;
  int c ;
  mode_t mask ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 117
  mask = umask((__mode_t )63);
#line 118
  bkfp = fopen((char const   */* __restrict  */)backup, (char const   */* __restrict  */)"w");
#line 119
  umask(mask);
  }
#line 120
  if ((unsigned long )((void *)0) == (unsigned long )bkfp) {
#line 121
    return (-1);
  }
  {
#line 124
  c = 0;
#line 125
  tmp___0 = fseeko(fp, (__off_t )0, 0);
  }
#line 125
  if (tmp___0 == 0) {
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 126
      c = _IO_getc(fp);
      }
#line 126
      if (! (c != -1)) {
#line 126
        goto while_break;
      }
      {
#line 127
      tmp = _IO_putc(c, bkfp);
      }
#line 127
      if (tmp == -1) {
#line 128
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 131
  if (-1 != c) {
    {
#line 132
    fclose(bkfp);
#line 133
    unlink(backup);
    }
#line 134
    return (-1);
  } else {
    {
#line 131
    tmp___1 = ferror(fp);
    }
#line 131
    if (tmp___1 != 0) {
      {
#line 132
      fclose(bkfp);
#line 133
      unlink(backup);
      }
#line 134
      return (-1);
    } else {
      {
#line 131
      tmp___2 = fflush(bkfp);
      }
#line 131
      if (tmp___2 != 0) {
        {
#line 132
        fclose(bkfp);
#line 133
        unlink(backup);
        }
#line 134
        return (-1);
      }
    }
  }
  {
#line 136
  tmp___3 = fileno(bkfp);
#line 136
  tmp___4 = fsync(tmp___3);
  }
#line 136
  if (tmp___4 != 0) {
    {
#line 137
    fclose(bkfp);
#line 138
    unlink(backup);
    }
#line 139
    return (-1);
  }
  {
#line 141
  tmp___5 = fclose(bkfp);
  }
#line 141
  if (tmp___5 != 0) {
    {
#line 142
    unlink(backup);
    }
#line 143
    return (-1);
  }
  {
#line 146
  ub.actime = sb->st_atim.tv_sec;
#line 147
  ub.modtime = sb->st_mtim.tv_sec;
#line 148
  tmp___6 = utime(backup, (struct utimbuf  const  *)(& ub));
  }
#line 148
  if (tmp___6 != 0) {
    {
#line 151
    unlink(backup);
    }
#line 152
    return (-1);
  } else {
    {
#line 148
    tmp___7 = chmod(backup, sb->st_mode);
    }
#line 148
    if (tmp___7 != 0) {
      {
#line 151
      unlink(backup);
      }
#line 152
      return (-1);
    } else {
      {
#line 148
      tmp___8 = chown(backup, sb->st_uid, sb->st_gid);
      }
#line 148
      if (tmp___8 != 0) {
        {
#line 151
        unlink(backup);
        }
#line 152
        return (-1);
      }
    }
  }
#line 154
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static void vipwexit(char const   *msg , int syserr , int ret ) 
{ 
  int err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *old_locale ;
  char *tmp___3 ;
  char *saved_locale ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 162
  tmp = __errno_location();
#line 162
  err = *tmp;
  }
#line 164
  if (createedit) {
    {
#line 165
    tmp___1 = unlink(fileeditname);
    }
#line 165
    if (tmp___1 != 0) {
      {
#line 166
      tmp___0 = gettext("%s: failed to remove %s\n");
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, fileeditname);
      }
    }
  }
#line 170
  if (filelocked) {
    {
#line 171
    tmp___4 = (*unlock)();
    }
#line 171
    if (tmp___4 == 0) {
      {
#line 172
      tmp___2 = gettext("%s: failed to unlock %s\n");
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              Prog, fileeditname);
      }
      {
#line 173
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 173
        tmp___3 = setlocale(6, (char const   *)((void *)0));
#line 173
        old_locale = tmp___3;
#line 173
        saved_locale = (char *)((void *)0);
        }
#line 173
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 173
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 173
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 173
          setlocale(6, "C");
          }
        }
        {
#line 173
        syslog(3, "failed to unlock %s", fileeditname);
        }
#line 173
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 173
          setlocale(6, (char const   *)saved_locale);
#line 173
          free((void *)saved_locale);
          }
        }
#line 173
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 177
  if ((unsigned long )((void *)0) != (unsigned long )msg) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s",
            Prog, msg);
    }
  }
#line 180
  if (0 != syserr) {
    {
#line 181
    tmp___5 = strerror(err);
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp___5);
    }
  }
  {
#line 183
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
  }
#line 184
  if (! quiet___0) {
    {
#line 185
    tmp___6 = gettext("%s: %s is unchanged\n");
#line 185
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)tmp___6,
            Prog, filename);
    }
  }
  {
#line 188
  exit(ret);
  }
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static void vipwedit(char const   *file , int (*file_lock)(void) , int (*file_unlock)(void) ) 
{ 
  char const   *editor ;
  pid_t pid ;
  struct stat st1 ;
  struct stat st2 ;
  int status ;
  FILE *f ;
  char filebackup[1024] ;
  char fileedit[1024] ;
  char *to_rename ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *buf___0 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  __pid_t tmp___17 ;
  union __anonunion_57 __constr_expr_0 ;
  union __anonunion_58 __constr_expr_1 ;
  union __anonunion_59 __constr_expr_2 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *old_locale ;
  char *tmp___24 ;
  char *saved_locale ;
  int tmp___25 ;
  char *old_locale___0 ;
  char *tmp___26 ;
  char *saved_locale___0 ;

  {
  {
#line 210
  snprintf((char */* __restrict  */)(filebackup), sizeof(filebackup), (char const   */* __restrict  */)"%s-",
           file);
#line 225
  snprintf((char */* __restrict  */)(fileedit), sizeof(fileedit), (char const   */* __restrict  */)"%s.edit",
           file);
#line 229
  unlock = file_unlock;
#line 230
  filename = file;
#line 231
  fileeditname = (char const   *)(fileedit);
#line 233
  tmp = access(file, 0);
  }
#line 233
  if (tmp != 0) {
    {
#line 234
    vipwexit(file, 1, 1);
    }
  }
  {
#line 257
  tmp___2 = (*file_lock)();
  }
#line 257
  if (tmp___2 == 0) {
    {
#line 258
    tmp___0 = __errno_location();
#line 258
    tmp___1 = gettext("Couldn\'t lock file");
#line 258
    vipwexit((char const   *)tmp___1, *tmp___0, 5);
    }
  }
  {
#line 260
  filelocked = (_Bool)1;
#line 268
  tmp___3 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st1));
  }
#line 268
  if (tmp___3 != 0) {
    {
#line 269
    vipwexit(file, 1, 1);
    }
  }
  {
#line 271
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 272
  if ((unsigned long )((void *)0) == (unsigned long )f) {
    {
#line 273
    vipwexit(file, 1, 1);
    }
  }
  {
#line 279
  tmp___6 = create_backup_file(f, (char const   *)(fileedit), & st1);
  }
#line 279
  if (tmp___6 != 0) {
    {
#line 280
    tmp___4 = __errno_location();
#line 280
    tmp___5 = gettext("Couldn\'t make backup");
#line 280
    vipwexit((char const   *)tmp___5, *tmp___4, 1);
    }
  }
  {
#line 282
  fclose(f);
#line 283
  createedit = (_Bool)1;
#line 285
  tmp___7 = getenv("VISUAL");
#line 285
  editor = (char const   *)tmp___7;
  }
#line 286
  if ((unsigned long )((void *)0) == (unsigned long )editor) {
    {
#line 287
    tmp___8 = getenv("EDITOR");
#line 287
    editor = (char const   *)tmp___8;
    }
  }
#line 289
  if ((unsigned long )((void *)0) == (unsigned long )editor) {
#line 290
    editor = "vi";
  }
  {
#line 293
  pid = fork();
  }
#line 294
  if (-1 == pid) {
    {
#line 295
    vipwexit("fork", 1, 1);
    }
  } else
#line 296
  if (0 == pid) {
    {
#line 301
    tmp___9 = strlen(editor);
#line 301
    tmp___10 = strlen((char const   *)(fileedit));
#line 301
    tmp___11 = malloc((tmp___9 + tmp___10) + 2UL);
#line 301
    buf___0 = (char *)tmp___11;
#line 302
    tmp___12 = strlen(editor);
#line 302
    tmp___13 = strlen((char const   *)(fileedit));
#line 302
    snprintf((char */* __restrict  */)buf___0, (tmp___12 + tmp___13) + 2UL, (char const   */* __restrict  */)"%s %s",
             editor, fileedit);
#line 304
    tmp___16 = system((char const   *)buf___0);
    }
#line 304
    if (tmp___16 != 0) {
      {
#line 305
      tmp___14 = __errno_location();
#line 305
      tmp___15 = strerror(*tmp___14);
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              Prog, editor, tmp___15);
#line 307
      exit(1);
      }
    } else {
      {
#line 309
      exit(0);
      }
    }
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    pid = waitpid(pid, & status, 2);
    }
#line 315
    if (pid != -1) {
#line 315
      __constr_expr_0.__in = status;
#line 315
      if (((__constr_expr_0.__i & 255) == 127) != 0) {
        {
#line 318
        tmp___17 = getpid();
#line 318
        kill(tmp___17, 19);
#line 320
        kill(pid, 18);
        }
      } else {
#line 322
        goto while_break;
      }
    } else {
#line 322
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (-1 == pid) {
    {
#line 329
    vipwexit(editor, 1, 1);
    }
  } else {
#line 326
    __constr_expr_1.__in = status;
#line 326
    if (((__constr_expr_1.__i & 127) == 0) == 0) {
      {
#line 329
      vipwexit(editor, 1, 1);
      }
    } else {
#line 326
      __constr_expr_2.__in = status;
#line 326
      if ((__constr_expr_2.__i & 65280) >> 8 != 0) {
        {
#line 329
        vipwexit(editor, 1, 1);
        }
      }
    }
  }
  {
#line 332
  tmp___18 = stat((char const   */* __restrict  */)(fileedit), (struct stat */* __restrict  */)(& st2));
  }
#line 332
  if (tmp___18 != 0) {
    {
#line 333
    vipwexit((char const   *)(fileedit), 1, 1);
    }
  }
#line 335
  if (st1.st_mtim.tv_sec == st2.st_mtim.tv_sec) {
    {
#line 336
    vipwexit((char const   *)0, 0, 0);
    }
  }
  {
#line 352
  createedit = (_Bool)0;
#line 380
  to_rename = fileedit;
#line 384
  unlink((char const   *)(filebackup));
#line 385
  link(file, (char const   *)(filebackup));
#line 386
  tmp___22 = rename((char const   *)to_rename, file);
  }
#line 386
  if (tmp___22 == -1) {
    {
#line 387
    tmp___19 = __errno_location();
#line 387
    tmp___20 = strerror(*tmp___19);
#line 387
    tmp___21 = gettext("%s: can\'t restore %s: %s (your changes are in %s)\n");
#line 387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21,
            Prog, file, tmp___20, to_rename);
#line 395
    vipwexit((char const   *)0, 0, 1);
    }
  }
  {
#line 407
  tmp___25 = (*file_unlock)();
  }
#line 407
  if (tmp___25 == 0) {
    {
#line 408
    tmp___23 = gettext("%s: failed to unlock %s\n");
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
            Prog, fileeditname);
    }
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 409
      tmp___24 = setlocale(6, (char const   *)((void *)0));
#line 409
      old_locale = tmp___24;
#line 409
      saved_locale = (char *)((void *)0);
      }
#line 409
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 409
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 409
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 409
        setlocale(6, "C");
        }
      }
      {
#line 409
      syslog(3, "failed to unlock %s", fileeditname);
      }
#line 409
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 409
        setlocale(6, (char const   *)saved_locale);
#line 409
        free((void *)saved_locale);
        }
      }
#line 409
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 412
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 412
    tmp___26 = setlocale(6, (char const   *)((void *)0));
#line 412
    old_locale___0 = tmp___26;
#line 412
    saved_locale___0 = (char *)((void *)0);
    }
#line 412
    if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
      {
#line 412
      saved_locale___0 = strdup((char const   *)old_locale___0);
      }
    }
#line 412
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
      {
#line 412
      setlocale(6, "C");
      }
    }
    {
#line 412
    syslog(6, "file %s edited", fileeditname);
    }
#line 412
    if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
      {
#line 412
      setlocale(6, (char const   *)saved_locale___0);
#line 412
      free((void *)saved_locale___0);
      }
    }
#line 412
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 413
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/vipw.c"
static struct option long_options___18[7]  = {      {"group", 0, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"passwd", 0, (int *)((void *)0), 'p'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"shadow", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___24[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___24[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___25(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___25(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___25[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___25[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___25  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___23(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___24  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___47  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___23(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___47) {
#line 70
      size___47 = i + 100;
#line 71
      if (members___24) {
        {
#line 72
        tmp = realloc((void *)members___24, (unsigned long )size___47 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___47 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___24) {
          {
#line 81
          free((void *)members___24);
          }
        }
#line 82
        members___24 = (char **)0;
#line 83
        size___47 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___24 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___24 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___24 + i) = (char *)0;
#line 99
  return (members___24);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___23  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___48  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___23[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___23  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___25(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static char *adduser  =    (char *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static char *deluser  =    (char *)((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static char *thisgroup  =    (char *)((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static _Bool purge  =    (_Bool)0;
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static _Bool list___24  =    (_Bool)0;
#line 74 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static int exclusive  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static _Bool gr_locked___6  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static _Bool is_shadowgrp___0  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static _Bool sgr_locked___6  =    (_Bool)0;
#line 84
static char *whoami(void) ;
#line 85
static void add_user___0(char const   *user___0 , struct group  const  *grp ) ;
#line 87
static void remove_user(char const   *user___0 , struct group  const  *grp ) ;
#line 89
static void purge_members(struct group  const  *grp ) ;
#line 90
static void display_members(char const   * const  *members___30 ) ;
#line 91
static void usage___22(int status ) ;
#line 92
static void process_flags___17(int argc , char **argv ) ;
#line 93
static void check_perms___8(void) ;
#line 94
static void fail_exit___12(int code ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static char *whoami(void) 
{ 
  struct group *grp ;
  __gid_t tmp ;
  struct group *tmp___0 ;
  struct passwd *usr ;
  __uid_t tmp___1 ;
  struct passwd *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 100
  tmp = getgid();
#line 100
  tmp___0 = getgrgid(tmp);
#line 100
  grp = tmp___0;
#line 102
  tmp___1 = getuid();
#line 102
  tmp___2 = getpwuid(tmp___1);
#line 102
  usr = tmp___2;
  }
#line 104
  if ((unsigned long )((void *)0) != (unsigned long )usr) {
#line 104
    if ((unsigned long )((void *)0) != (unsigned long )grp) {
      {
#line 104
      tmp___4 = strcmp((char const   *)usr->pw_name, (char const   *)grp->gr_name);
      }
#line 104
      if (0 == tmp___4) {
        {
#line 107
        tmp___3 = xstrdup((char const   *)usr->pw_name);
        }
#line 107
        return (tmp___3);
      } else {
#line 109
        return ((char *)((void *)0));
      }
    } else {
#line 109
      return ((char *)((void *)0));
    }
  } else {
#line 109
    return ((char *)((void *)0));
  }
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static struct sgrp sgrent  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void add_user___0(char const   *user___0 , struct group  const  *grp ) 
{ 
  struct group *newgrp ;
  char *tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  struct sgrp  const  *sg ;
  struct sgrp  const  *tmp___3 ;
  struct sgrp *newsg ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 122
  tmp___0 = is_on_list((char * const  *)grp->gr_mem, user___0);
  }
#line 122
  if (tmp___0) {
    {
#line 123
    tmp = gettext("%s: user \'%s\' is already a member of \'%s\'\n");
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, user___0, grp->gr_name);
#line 126
    fail_exit___12(7);
    }
  }
  {
#line 129
  newgrp = __gr_dup(grp);
  }
#line 130
  if ((unsigned long )((void *)0) == (unsigned long )newgrp) {
    {
#line 131
    tmp___1 = gr_dbname();
#line 131
    tmp___2 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, tmp___1);
#line 134
    fail_exit___12(13);
    }
  }
  {
#line 138
  newgrp->gr_mem = add_list(newgrp->gr_mem, user___0);
  }
#line 141
  if (is_shadowgrp___0) {
    {
#line 142
    tmp___3 = sgr_locate((char const   *)newgrp->gr_name);
#line 142
    sg = tmp___3;
    }
#line 145
    if ((unsigned long )((void *)0) == (unsigned long )sg) {
      {
#line 148
      sgrent.sg_name = xstrdup((char const   *)newgrp->gr_name);
#line 149
      sgrent.sg_mem = dup_list((char * const  *)newgrp->gr_mem);
#line 150
      tmp___4 = xmalloc(sizeof(char *));
#line 150
      sgrent.sg_adm = (char **)tmp___4;
#line 158
      *(sgrent.sg_adm + 0) = (char *)((void *)0);
#line 162
      sgrent.sg_passwd = newgrp->gr_passwd;
#line 163
      newgrp->gr_passwd = (char *)"x";
#line 165
      newsg = & sgrent;
      }
    } else {
      {
#line 167
      newsg = __sgr_dup(sg);
      }
#line 168
      if ((unsigned long )((void *)0) == (unsigned long )newsg) {
        {
#line 169
        tmp___5 = sgr_dbname();
#line 169
        tmp___6 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                Prog, tmp___5);
#line 172
        fail_exit___12(13);
        }
      }
      {
#line 175
      newsg->sg_mem = add_list(newsg->sg_mem, user___0);
      }
    }
    {
#line 179
    tmp___9 = sgr_update((struct sgrp  const  *)newsg);
    }
#line 179
    if (tmp___9 == 0) {
      {
#line 180
      tmp___7 = sgr_dbname();
#line 180
      tmp___8 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 180
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7, newsg->sg_name);
#line 183
      fail_exit___12(13);
      }
    }
  }
  {
#line 188
  tmp___12 = gr_update((struct group  const  *)newgrp);
  }
#line 188
  if (tmp___12 == 0) {
    {
#line 189
    tmp___10 = gr_dbname();
#line 189
    tmp___11 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 189
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            Prog, tmp___10, newgrp->gr_name);
#line 192
    fail_exit___12(13);
    }
  }
#line 194
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static struct sgrp sgrent___0  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void remove_user(char const   *user___0 , struct group  const  *grp ) 
{ 
  struct group *newgrp ;
  char *tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  struct sgrp  const  *sg ;
  struct sgrp  const  *tmp___3 ;
  struct sgrp *newsg ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 205
  tmp___0 = is_on_list((char * const  *)grp->gr_mem, user___0);
  }
#line 205
  if (! tmp___0) {
    {
#line 206
    tmp = gettext("%s: user \'%s\' is not a member of \'%s\'\n");
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, user___0, grp->gr_name);
#line 209
    fail_exit___12(6);
    }
  }
  {
#line 212
  newgrp = __gr_dup(grp);
  }
#line 213
  if ((unsigned long )((void *)0) == (unsigned long )newgrp) {
    {
#line 214
    tmp___1 = gr_dbname();
#line 214
    tmp___2 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, tmp___1);
#line 217
    fail_exit___12(13);
    }
  }
  {
#line 221
  newgrp->gr_mem = del_list(newgrp->gr_mem, user___0);
  }
#line 224
  if (is_shadowgrp___0) {
    {
#line 225
    tmp___3 = sgr_locate((char const   *)newgrp->gr_name);
#line 225
    sg = tmp___3;
    }
#line 228
    if ((unsigned long )((void *)0) == (unsigned long )sg) {
      {
#line 231
      sgrent___0.sg_name = xstrdup((char const   *)newgrp->gr_name);
#line 232
      sgrent___0.sg_mem = dup_list((char * const  *)newgrp->gr_mem);
#line 233
      tmp___4 = xmalloc(sizeof(char *));
#line 233
      sgrent___0.sg_adm = (char **)tmp___4;
#line 241
      *(sgrent___0.sg_adm + 0) = (char *)((void *)0);
#line 245
      sgrent___0.sg_passwd = newgrp->gr_passwd;
#line 246
      newgrp->gr_passwd = (char *)"x";
#line 248
      newsg = & sgrent___0;
      }
    } else {
      {
#line 250
      newsg = __sgr_dup(sg);
      }
#line 251
      if ((unsigned long )((void *)0) == (unsigned long )newsg) {
        {
#line 252
        tmp___5 = sgr_dbname();
#line 252
        tmp___6 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 252
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                Prog, tmp___5);
#line 255
        fail_exit___12(13);
        }
      }
      {
#line 258
      newsg->sg_mem = del_list(newsg->sg_mem, user___0);
#line 260
      newsg->sg_adm = del_list(newsg->sg_adm, user___0);
      }
    }
    {
#line 263
    tmp___9 = sgr_update((struct sgrp  const  *)newsg);
    }
#line 263
    if (tmp___9 == 0) {
      {
#line 264
      tmp___7 = sgr_dbname();
#line 264
      tmp___8 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7, newsg->sg_name);
#line 267
      fail_exit___12(13);
      }
    }
  }
  {
#line 272
  tmp___12 = gr_update((struct group  const  *)newgrp);
  }
#line 272
  if (tmp___12 == 0) {
    {
#line 273
    tmp___10 = gr_dbname();
#line 273
    tmp___11 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 273
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            Prog, tmp___10, newgrp->gr_name);
#line 276
    fail_exit___12(13);
    }
  }
#line 278
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static struct sgrp sgrent___1  ;
#line 283 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void purge_members(struct group  const  *grp ) 
{ 
  struct group *newgrp ;
  struct group *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  struct sgrp  const  *sg ;
  struct sgrp  const  *tmp___2 ;
  struct sgrp *newsg ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 285
  tmp = __gr_dup(grp);
#line 285
  newgrp = tmp;
  }
#line 287
  if ((unsigned long )((void *)0) == (unsigned long )newgrp) {
    {
#line 288
    tmp___0 = gr_dbname();
#line 288
    tmp___1 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            Prog, tmp___0);
#line 291
    fail_exit___12(13);
    }
  }
#line 295
  *(newgrp->gr_mem + 0) = (char *)((void *)0);
#line 298
  if (is_shadowgrp___0) {
    {
#line 299
    tmp___2 = sgr_locate((char const   *)newgrp->gr_name);
#line 299
    sg = tmp___2;
    }
#line 302
    if ((unsigned long )((void *)0) == (unsigned long )sg) {
      {
#line 305
      sgrent___1.sg_name = xstrdup((char const   *)newgrp->gr_name);
#line 306
      tmp___3 = xmalloc(sizeof(char *));
#line 306
      sgrent___1.sg_mem = (char **)tmp___3;
#line 307
      *(sgrent___1.sg_mem + 0) = (char *)((void *)0);
#line 308
      tmp___4 = xmalloc(sizeof(char *));
#line 308
      sgrent___1.sg_adm = (char **)tmp___4;
#line 309
      *(sgrent___1.sg_adm + 0) = (char *)((void *)0);
#line 312
      sgrent___1.sg_passwd = newgrp->gr_passwd;
#line 313
      newgrp->gr_passwd = xstrdup("x");
#line 315
      newsg = & sgrent___1;
      }
    } else {
      {
#line 317
      newsg = __sgr_dup(sg);
      }
#line 318
      if ((unsigned long )((void *)0) == (unsigned long )newsg) {
        {
#line 319
        tmp___5 = sgr_dbname();
#line 319
        tmp___6 = gettext("%s: Out of memory. Cannot update %s.\n");
#line 319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                Prog, tmp___5);
#line 322
        fail_exit___12(13);
        }
      }
#line 326
      *(newsg->sg_mem + 0) = (char *)((void *)0);
#line 329
      *(newsg->sg_adm + 0) = (char *)((void *)0);
    }
    {
#line 332
    tmp___9 = sgr_update((struct sgrp  const  *)newsg);
    }
#line 332
    if (tmp___9 == 0) {
      {
#line 333
      tmp___7 = sgr_dbname();
#line 333
      tmp___8 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7, newsg->sg_name);
#line 336
      fail_exit___12(13);
      }
    }
  }
  {
#line 341
  tmp___12 = gr_update((struct group  const  *)newgrp);
  }
#line 341
  if (tmp___12 == 0) {
    {
#line 342
    tmp___10 = gr_dbname();
#line 342
    tmp___11 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            Prog, tmp___10, newgrp->gr_name);
#line 345
    fail_exit___12(13);
    }
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void display_members(char const   * const  *members___30 ) 
{ 
  int i ;

  {
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! ((unsigned long )((void *)0) != (unsigned long )*(members___30 + i))) {
#line 353
      goto while_break;
    }
    {
#line 354
    printf((char const   */* __restrict  */)"%s ", *(members___30 + i));
    }
#line 356
    if ((unsigned long )((void *)0) == (unsigned long )*(members___30 + (i + 1))) {
      {
#line 357
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 359
      printf((char const   */* __restrict  */)" ");
      }
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void usage___22(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 366
  if (0 != status) {
#line 366
    tmp = stderr;
  } else {
#line 366
    tmp = stdout;
  }
  {
#line 366
  usageout = tmp;
#line 367
  tmp___0 = gettext("Usage: %s [options] [action]\n\nOptions:\n");
#line 367
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 372
  tmp___1 = gettext("  -g, --group groupname         change groupname instead of the user\'s group\n                                (root only)\n");
#line 372
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 374
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 374
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 375
  tmp___3 = gettext("\n");
#line 375
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 376
  tmp___4 = gettext("Actions:\n");
#line 376
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 377
  tmp___5 = gettext("  -a, --add username            add username to the members of the group\n");
#line 377
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 378
  tmp___6 = gettext("  -d, --delete username         remove username from the members of the group\n");
#line 378
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 379
  tmp___7 = gettext("  -h, --help                    display this help message and exit\n");
#line 379
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 380
  tmp___8 = gettext("  -p, --purge                   purge all members from the group\n");
#line 380
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 381
  tmp___9 = gettext("  -l, --list                    list the members of the group\n");
#line 381
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)usageout);
#line 382
  exit(status);
  }
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static struct option long_options___19[8]  = 
#line 391
  {      {"add", 1, (int *)((void *)0), 'a'}, 
        {"delete", 1, (int *)((void *)0), 'd'}, 
        {"group", 1, (int *)((void *)0), 'g'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"list", 0, (int *)((void *)0), 'l'}, 
        {"purge", 0, (int *)((void *)0), 'p'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 388 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void process_flags___17(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  struct passwd *tmp___0 ;

  {
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 402
    c = getopt_long(argc, (char * const  *)argv, "a:d:g:hlpR:", (struct option  const  *)(long_options___19),
                    (int *)((void *)0));
    }
#line 402
    if (! (c != -1)) {
#line 402
      goto while_break;
    }
    {
#line 405
    if (c == 97) {
#line 405
      goto case_97;
    }
#line 409
    if (c == 100) {
#line 409
      goto case_100;
    }
#line 413
    if (c == 103) {
#line 413
      goto case_103;
    }
#line 416
    if (c == 104) {
#line 416
      goto case_104;
    }
#line 419
    if (c == 108) {
#line 419
      goto case_108;
    }
#line 423
    if (c == 112) {
#line 423
      goto case_112;
    }
#line 427
    if (c == 82) {
#line 427
      goto case_82;
    }
#line 429
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 406
    adduser = xstrdup((char const   *)optarg);
#line 407
    exclusive ++;
    }
#line 408
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 410
    deluser = xstrdup((char const   *)optarg);
#line 411
    exclusive ++;
    }
#line 412
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 414
    thisgroup = xstrdup((char const   *)optarg);
    }
#line 415
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 417
    usage___22(0);
    }
#line 418
    goto switch_break;
    case_108: /* CIL Label */ 
#line 420
    list___24 = (_Bool)1;
#line 421
    exclusive ++;
#line 422
    goto switch_break;
    case_112: /* CIL Label */ 
#line 424
    purge = (_Bool)1;
#line 425
    exclusive ++;
#line 426
    goto switch_break;
    case_82: /* CIL Label */ 
#line 428
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 430
    usage___22(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  if (exclusive > 1) {
    {
#line 435
    usage___22(1);
    }
  } else
#line 434
  if (optind < argc) {
    {
#line 435
    usage___22(1);
    }
  }
#line 439
  if ((unsigned long )((void *)0) != (unsigned long )adduser) {
    {
#line 439
    tmp___0 = getpwnam((char const   *)adduser);
    }
#line 439
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 441
      tmp = gettext("%s: user \'%s\' does not exist\n");
#line 441
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, adduser);
#line 443
      fail_exit___12(8);
      }
    }
  }
#line 446
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void check_perms___8(void) 
{ 


  {
#line 486
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void fail_exit___12(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 490
  if (gr_locked___6) {
    {
#line 491
    tmp___3 = gr_unlock();
    }
#line 491
    if (tmp___3 == 0) {
      {
#line 492
      tmp = gr_dbname();
#line 492
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 492
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 495
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 495
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 495
        old_locale = tmp___1;
#line 495
        saved_locale = (char *)((void *)0);
        }
#line 495
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 495
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 495
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 495
          setlocale(6, "C");
          }
        }
        {
#line 495
        tmp___2 = gr_dbname();
#line 495
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 495
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 495
          setlocale(6, (char const   *)saved_locale);
#line 495
          free((void *)saved_locale);
          }
        }
#line 495
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 501
  if (sgr_locked___6) {
    {
#line 502
    tmp___8 = sgr_unlock();
    }
#line 502
    if (tmp___8 == 0) {
      {
#line 503
      tmp___4 = sgr_dbname();
#line 503
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 503
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 506
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 506
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 506
        old_locale___0 = tmp___6;
#line 506
        saved_locale___0 = (char *)((void *)0);
        }
#line 506
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 506
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 506
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 506
          setlocale(6, "C");
          }
        }
        {
#line 506
        tmp___7 = sgr_dbname();
#line 506
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 506
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 506
          setlocale(6, (char const   *)saved_locale___0);
#line 506
          free((void *)saved_locale___0);
          }
        }
#line 506
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 512
  exit(code);
  }
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void open_files___12(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 517
  if (! list___24) {
    {
#line 518
    tmp___1 = gr_lock();
    }
#line 518
    if (tmp___1 == 0) {
      {
#line 519
      tmp = gr_dbname();
#line 519
      tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
#line 522
      fail_exit___12(2);
      }
    }
#line 524
    gr_locked___6 = (_Bool)1;
#line 527
    if (is_shadowgrp___0) {
      {
#line 528
      tmp___4 = sgr_lock();
      }
#line 528
      if (tmp___4 == 0) {
        {
#line 529
        tmp___2 = sgr_dbname();
#line 529
        tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 529
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                Prog, tmp___2);
#line 532
        fail_exit___12(2);
        }
      }
#line 534
      sgr_locked___6 = (_Bool)1;
    }
  }
#line 539
  if (list___24) {
#line 539
    tmp___7 = 0;
  } else {
#line 539
    tmp___7 = 2;
  }
  {
#line 539
  tmp___8 = gr_open(tmp___7);
  }
#line 539
  if (tmp___8 == 0) {
    {
#line 540
    tmp___5 = gr_dbname();
#line 540
    tmp___6 = gettext("%s: cannot open %s\n");
#line 540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
#line 541
    fail_exit___12(2);
    }
  }
#line 545
  if (is_shadowgrp___0) {
#line 546
    if (list___24) {
#line 546
      tmp___11 = 0;
    } else {
#line 546
      tmp___11 = 2;
    }
    {
#line 546
    tmp___12 = sgr_open(tmp___11);
    }
#line 546
    if (tmp___12 == 0) {
      {
#line 547
      tmp___9 = sgr_dbname();
#line 547
      tmp___10 = gettext("%s: cannot open %s\n");
#line 547
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              Prog, tmp___9);
#line 548
      fail_exit___12(2);
      }
    }
  }
#line 552
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/groupmems.c"
static void close_files___12(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *old_locale___1 ;
  char *tmp___11 ;
  char *saved_locale___1 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *old_locale___2 ;
  char *tmp___16 ;
  char *saved_locale___2 ;
  char const   *tmp___17 ;
  int tmp___18 ;

  {
  {
#line 556
  tmp___3 = gr_close();
  }
#line 556
  if (tmp___3 == 0) {
#line 556
    if (! list___24) {
      {
#line 557
      tmp = gr_dbname();
#line 557
      tmp___0 = gettext("%s: failure while writing changes to %s\n");
#line 557
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 558
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 558
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 558
        old_locale = tmp___1;
#line 558
        saved_locale = (char *)((void *)0);
        }
#line 558
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 558
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 558
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 558
          setlocale(6, "C");
          }
        }
        {
#line 558
        tmp___2 = gr_dbname();
#line 558
        syslog(3, "failure while writing changes to %s", tmp___2);
        }
#line 558
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 558
          setlocale(6, (char const   *)saved_locale);
#line 558
          free((void *)saved_locale);
          }
        }
#line 558
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 559
      fail_exit___12(2);
      }
    }
  }
#line 561
  if (gr_locked___6) {
    {
#line 562
    tmp___8 = gr_unlock();
    }
#line 562
    if (tmp___8 == 0) {
      {
#line 563
      tmp___4 = gr_dbname();
#line 563
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 563
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 564
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 564
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 564
        old_locale___0 = tmp___6;
#line 564
        saved_locale___0 = (char *)((void *)0);
        }
#line 564
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 564
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 564
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 564
          setlocale(6, "C");
          }
        }
        {
#line 564
        tmp___7 = gr_dbname();
#line 564
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 564
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 564
          setlocale(6, (char const   *)saved_locale___0);
#line 564
          free((void *)saved_locale___0);
          }
        }
#line 564
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 567
    gr_locked___6 = (_Bool)0;
  }
#line 571
  if (is_shadowgrp___0) {
    {
#line 572
    tmp___13 = sgr_close();
    }
#line 572
    if (tmp___13 == 0) {
#line 572
      if (! list___24) {
        {
#line 573
        tmp___9 = sgr_dbname();
#line 573
        tmp___10 = gettext("%s: failure while writing changes to %s\n");
#line 573
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
                Prog, tmp___9);
        }
        {
#line 574
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 574
          tmp___11 = setlocale(6, (char const   *)((void *)0));
#line 574
          old_locale___1 = tmp___11;
#line 574
          saved_locale___1 = (char *)((void *)0);
          }
#line 574
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
            {
#line 574
            saved_locale___1 = strdup((char const   *)old_locale___1);
            }
          }
#line 574
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
            {
#line 574
            setlocale(6, "C");
            }
          }
          {
#line 574
          tmp___12 = sgr_dbname();
#line 574
          syslog(3, "failure while writing changes to %s", tmp___12);
          }
#line 574
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
            {
#line 574
            setlocale(6, (char const   *)saved_locale___1);
#line 574
            free((void *)saved_locale___1);
            }
          }
#line 574
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 575
        fail_exit___12(2);
        }
      }
    }
#line 577
    if (sgr_locked___6) {
      {
#line 578
      tmp___18 = sgr_unlock();
      }
#line 578
      if (tmp___18 == 0) {
        {
#line 579
        tmp___14 = sgr_dbname();
#line 579
        tmp___15 = gettext("%s: failed to unlock %s\n");
#line 579
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                Prog, tmp___14);
        }
        {
#line 580
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 580
          tmp___16 = setlocale(6, (char const   *)((void *)0));
#line 580
          old_locale___2 = tmp___16;
#line 580
          saved_locale___2 = (char *)((void *)0);
          }
#line 580
          if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
            {
#line 580
            saved_locale___2 = strdup((char const   *)old_locale___2);
            }
          }
#line 580
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 580
            setlocale(6, "C");
            }
          }
          {
#line 580
          tmp___17 = sgr_dbname();
#line 580
          syslog(3, "failed to unlock %s", tmp___17);
          }
#line 580
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
            {
#line 580
            setlocale(6, (char const   *)saved_locale___2);
#line 580
            free((void *)saved_locale___2);
            }
          }
#line 580
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 583
      sgr_locked___6 = (_Bool)0;
    }
  }
#line 587
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___25(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___25  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___25  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___25  ;
#line 72
static int copy_entry___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___25(char const   *filename___0 ) ;
#line 83
static int copy_symlink___25(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___25(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___25(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___25(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___25(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___25(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___25 == (unsigned long )ln) {
    {
#line 149
    links___25 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___25;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___25(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___25)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___25)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___25;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___25);
#line 199
  dst_len = strlen(dst_orig___25);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___25, name___3 + src_len);
#line 207
  lp->ln_next = links___25;
#line 208
  links___25 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___25(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___25(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___25(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___25(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___25(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___25(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___25(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___25(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___25(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___25)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___25)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___25(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___25);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___25, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___25);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___25);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___25);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___25, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___25(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___25(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___25(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___25(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___25(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___25(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___25(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___25(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___25(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___25[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___25[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___26(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___26(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___26[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___26[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___26  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___25(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___25  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___49  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___25(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___49) {
#line 70
      size___49 = i + 100;
#line 71
      if (members___25) {
        {
#line 72
        tmp = realloc((void *)members___25, (unsigned long )size___49 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___49 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___25) {
          {
#line 81
          free((void *)members___25);
          }
        }
#line 82
        members___25 = (char **)0;
#line 83
        size___49 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___25 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___25 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___25 + i) = (char *)0;
#line 99
  return (members___25);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___24  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___50  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___24[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___24  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___26(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___26(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___26  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___26  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___26  ;
#line 72
static int copy_entry___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___26(char const   *filename___0 ) ;
#line 83
static int copy_symlink___26(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___26(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___26(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___26(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___26(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___26(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___26 == (unsigned long )ln) {
    {
#line 149
    links___26 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___26;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___26(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___26)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___26)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___26;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___26);
#line 199
  dst_len = strlen(dst_orig___26);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___26, name___3 + src_len);
#line 207
  lp->ln_next = links___26;
#line 208
  links___26 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___26(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___26(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___26(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___26(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___26(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___26(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___26(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___26(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___26(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___26)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___26)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___26(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___26);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___26, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___26);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___26);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___26);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___26, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___26(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___26(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___26(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___26(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___26(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___26(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___26(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___26(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___26(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/expiry.c"
static _Bool cflg___1  =    (_Bool)0;
#line 52
static void catch_signals___1(int sig  __attribute__((__unused__)) ) ;
#line 53
static void usage___23(int status ) ;
#line 54
static void process_flags___18(int argc , char **argv ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/expiry.c"
static void catch_signals___1(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 61
  exit(10);
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/expiry.c"
static void usage___23(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 69
  if (0 != status) {
#line 69
    tmp = stderr;
  } else {
#line 69
    tmp = stdout;
  }
  {
#line 69
  usageout = tmp;
#line 70
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 70
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 75
  tmp___1 = gettext("  -c, --check                   check the user\'s password expiration\n");
#line 75
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 76
  tmp___2 = gettext("  -f, --force                   force password change if the user\'s password\n                                is expired\n");
#line 76
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 78
  tmp___3 = gettext("  -h, --help                    display this help message and exit\n");
#line 78
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 79
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 80
  exit(status);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/expiry.c"
static struct option long_options___20[4]  = {      {"check", 0, (int *)((void *)0), 'c'}, 
        {"force", 0, (int *)((void *)0), 'f'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 88 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/expiry.c"
static void process_flags___18(int argc , char **argv ) 
{ 
  _Bool fflg___5 ;
  int c ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 90
  fflg___5 = (_Bool)0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    c = getopt_long(argc, (char * const  *)argv, "cfh", (struct option  const  *)(long_options___20),
                    (int *)((void *)0));
    }
#line 99
    if (! (c != -1)) {
#line 99
      goto while_break;
    }
    {
#line 102
    if (c == 99) {
#line 102
      goto case_99;
    }
#line 105
    if (c == 102) {
#line 105
      goto case_102;
    }
#line 108
    if (c == 104) {
#line 108
      goto case_104;
    }
#line 111
    goto switch_default;
    case_99: /* CIL Label */ 
#line 103
    cflg___1 = (_Bool)1;
#line 104
    goto switch_break;
    case_102: /* CIL Label */ 
#line 106
    fflg___5 = (_Bool)1;
#line 107
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 109
    usage___23(0);
    }
#line 110
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 112
    usage___23(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (! cflg___1) {
#line 116
    if (! fflg___5) {
      {
#line 117
      usage___23(2);
      }
    }
  }
#line 120
  if (cflg___1) {
#line 120
    if (fflg___5) {
      {
#line 121
      tmp = gettext("%s: options %s and %s conflict\n");
#line 121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog, "-c", "-f");
#line 124
      usage___23(2);
      }
    }
  }
#line 127
  if (argc != optind) {
    {
#line 128
    tmp___0 = gettext("%s: unexpected argument: %s\n");
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, *(argv + optind));
#line 131
    usage___23(2);
    }
  }
#line 133
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___26[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___26[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___27(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___27(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 250 "../lib/prototypes.h"
extern _Bool obscure(char const   * , char const   * , struct passwd  const  * ) ;
#line 263
extern struct spwd *pwd_to_spwd(struct passwd  const  * ) ;
#line 280
extern struct passwd *__pw_dup(struct passwd  const  *pwent ) ;
#line 346
extern struct spwd *__spw_dup(struct spwd  const  *spent ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char *name___2  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char *myname___0  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool amroot___2  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool aflg___2  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool dflg___3  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool eflg___3  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool iflg  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool kflg___0  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool lflg___3  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool nflg___0  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool qflg  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool Sflg  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool uflg___2  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool wflg  =    (_Bool)0;
#line 79 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool xflg  =    (_Bool)0;
#line 97 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool anyflag  =    (_Bool)0;
#line 99 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static long age_min  =    0L;
#line 100 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static long age_max  =    0L;
#line 101 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static long warn  =    0L;
#line 102 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static long inact  =    0L;
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool do_update_age  =    (_Bool)0;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool pw_locked___9  =    (_Bool)0;
#line 109 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool spw_locked___8  =    (_Bool)0;
#line 125 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char crypt_passwd[256]  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool do_update_pwd  =    (_Bool)0;
#line 134
static void usage___24(int status ) ;
#line 137
static _Bool reuse(char const   *pass___1 , struct passwd  const  *pw ) ;
#line 138
static int new_password(struct passwd  const  *pw ) ;
#line 140
static void check_password(struct passwd  const  *pw , struct spwd  const  *sp ) ;
#line 142
static char const   *date_to_str___1(time_t t ) ;
#line 143
static char const   *pw_status(char const   *pass___1 ) ;
#line 144
static void print_status(struct passwd  const  *pw ) ;
#line 145
static void fail_exit___13(int status ) ;
#line 146
static void oom(void) ;
#line 147
static char *update_crypt_pw(char *cp ) ;
#line 148
static void update_noshadow(void) ;
#line 150
static void update_shadow(void) ;
#line 160 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void usage___24(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 162
  if (0 != status) {
#line 162
    tmp = stderr;
  } else {
#line 162
    tmp = stdout;
  }
  {
#line 162
  usageout = tmp;
#line 163
  tmp___0 = gettext("Usage: %s [options] [LOGIN]\n\nOptions:\n");
#line 163
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 168
  tmp___1 = gettext("  -a, --all                     report password status on all accounts\n");
#line 168
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 169
  tmp___2 = gettext("  -d, --delete                  delete the password for the named account\n");
#line 169
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 170
  tmp___3 = gettext("  -e, --expire                  force expire the password for the named account\n");
#line 170
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 171
  tmp___4 = gettext("  -h, --help                    display this help message and exit\n");
#line 171
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 172
  tmp___5 = gettext("  -k, --keep-tokens             change password only if expired\n");
#line 172
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 173
  tmp___6 = gettext("  -i, --inactive INACTIVE       set password inactive after expiration\n                                to INACTIVE\n");
#line 173
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 175
  tmp___7 = gettext("  -l, --lock                    lock the password of the named account\n");
#line 175
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 176
  tmp___8 = gettext("  -n, --mindays MIN_DAYS        set minimum number of days before password\n                                change to MIN_DAYS\n");
#line 176
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)usageout);
#line 178
  tmp___9 = gettext("  -q, --quiet                   quiet mode\n");
#line 178
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)usageout);
#line 179
  tmp___10 = gettext("  -r, --repository REPOSITORY   change password in REPOSITORY repository\n");
#line 179
  fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)usageout);
#line 180
  tmp___11 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 180
  fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)usageout);
#line 181
  tmp___12 = gettext("  -S, --status                  report password status on the named account\n");
#line 181
  fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)usageout);
#line 182
  tmp___13 = gettext("  -u, --unlock                  unlock the password of the named account\n");
#line 182
  fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)usageout);
#line 183
  tmp___14 = gettext("  -w, --warndays WARN_DAYS      set expiration warning days to WARN_DAYS\n");
#line 183
  fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)usageout);
#line 184
  tmp___15 = gettext("  -x, --maxdays MAX_DAYS        set maximum number of days before password\n                                change to MAX_DAYS\n");
#line 184
  fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)usageout);
#line 186
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 187
  exit(status);
  }
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static _Bool reuse(char const   *pass___1 , struct passwd  const  *pw ) 
{ 


  {
#line 210
  return ((_Bool)0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static int new_password(struct passwd  const  *pw ) 
{ 
  char *clear ;
  char *cipher ;
  char *cp ;
  char orig[200] ;
  char pass___1[200] ;
  int i ;
  _Bool warned ;
  int pass_max_len ;
  char const   *method ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *old_locale ;
  char *tmp___2 ;
  char *saved_locale ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  char *tmp___18 ;
  _Bool tmp___19 ;
  _Bool tmp___20 ;
  char *tmp___21 ;
  _Bool tmp___22 ;
  _Bool tmp___23 ;
  _Bool tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;

  {
#line 226
  pass_max_len = -1;
#line 238
  if (! amroot___2) {
#line 238
    if (0 != (int )crypt_passwd[0]) {
      {
#line 239
      tmp = gettext("Old password: ");
#line 239
      clear = getpass((char const   *)tmp);
      }
#line 240
      if ((unsigned long )((void *)0) == (unsigned long )clear) {
#line 241
        return (-1);
      }
      {
#line 244
      cipher = pw_encrypt((char const   *)clear, (char const   *)(crypt_passwd));
#line 245
      tmp___4 = strcmp((char const   *)cipher, (char const   *)(crypt_passwd));
      }
#line 245
      if (tmp___4 != 0) {
        {
#line 246
        tmp___0 = strlen((char const   *)clear);
#line 246
        memset((void *)clear, 0, tmp___0);
#line 247
        tmp___1 = strlen((char const   *)cipher);
#line 247
        memset((void *)cipher, 0, tmp___1);
        }
        {
#line 248
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 248
          tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 248
          old_locale = tmp___2;
#line 248
          saved_locale = (char *)((void *)0);
          }
#line 248
          if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
            {
#line 248
            saved_locale = strdup((char const   *)old_locale);
            }
          }
#line 248
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 248
            setlocale(6, "C");
            }
          }
          {
#line 248
          syslog(4, "incorrect password for %s", pw->pw_name);
          }
#line 248
          if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
            {
#line 248
            setlocale(6, (char const   *)saved_locale);
#line 248
            free((void *)saved_locale);
            }
          }
#line 248
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 250
        sleep(1U);
#line 251
        tmp___3 = gettext("Incorrect password for %s.\n");
#line 251
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                pw->pw_name);
        }
#line 254
        return (-1);
      }
      {
#line 256
      strncpy((char */* __restrict  */)(orig), (char const   */* __restrict  */)clear,
              sizeof(orig) - 1UL);
#line 256
      orig[sizeof(orig) - 1UL] = (char )'\000';
#line 257
      tmp___5 = strlen((char const   *)clear);
#line 257
      memset((void *)clear, 0, tmp___5);
#line 258
      tmp___6 = strlen((char const   *)cipher);
#line 258
      memset((void *)cipher, 0, tmp___6);
      }
    } else {
#line 260
      orig[0] = (char )'\000';
    }
  } else {
#line 260
    orig[0] = (char )'\000';
  }
  {
#line 269
  method = getdef_str("ENCRYPT_METHOD");
  }
#line 270
  if ((unsigned long )((void *)0) == (unsigned long )method) {
    {
#line 271
    tmp___7 = getdef_bool("MD5_CRYPT_ENAB");
    }
#line 271
    if (! tmp___7) {
      {
#line 272
      pass_max_len = getdef_num("PASS_MAX_LEN", 8);
      }
    }
  } else {
    {
#line 275
    tmp___8 = strcmp(method, "MD5");
    }
#line 275
    if (tmp___8 == 0) {
#line 281
      pass_max_len = -1;
    } else {
      {
#line 275
      tmp___9 = strcmp(method, "SHA256");
      }
#line 275
      if (tmp___9 == 0) {
#line 281
        pass_max_len = -1;
      } else {
        {
#line 275
        tmp___10 = strcmp(method, "SHA512");
        }
#line 275
        if (tmp___10 == 0) {
#line 281
          pass_max_len = -1;
        } else {
          {
#line 283
          pass_max_len = getdef_num("PASS_MAX_LEN", 8);
          }
        }
      }
    }
  }
#line 286
  if (! qflg) {
#line 287
    if (pass_max_len == -1) {
      {
#line 288
      tmp___11 = getdef_num("PASS_MIN_LEN", 5);
#line 288
      tmp___12 = gettext("Enter the new password (minimum of %d characters)\nPlease use a combination of upper and lower case letters and numbers.\n");
#line 288
      printf((char const   */* __restrict  */)tmp___12, tmp___11);
      }
    } else {
      {
#line 293
      tmp___13 = getdef_num("PASS_MIN_LEN", 5);
#line 293
      tmp___14 = gettext("Enter the new password (minimum of %d, maximum of %d characters)\nPlease use a combination of upper and lower case letters and numbers.\n");
#line 293
      printf((char const   */* __restrict  */)tmp___14, tmp___13, pass_max_len);
      }
    }
  }
  {
#line 300
  warned = (_Bool)0;
#line 301
  i = getdef_num("PASS_CHANGE_TRIES", 5);
  }
  {
#line 301
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 301
    if (! (i > 0)) {
#line 301
      goto while_break___0;
    }
    {
#line 302
    tmp___15 = gettext("New password: ");
#line 302
    cp = getpass((char const   *)tmp___15);
    }
#line 303
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 304
      memset((void *)(orig), 0, sizeof(orig));
      }
#line 305
      return (-1);
    }
#line 307
    if (warned) {
      {
#line 307
      tmp___16 = strcmp((char const   *)(pass___1), (char const   *)cp);
      }
#line 307
      if (tmp___16 != 0) {
#line 308
        warned = (_Bool)0;
      }
    }
    {
#line 310
    strncpy((char */* __restrict  */)(pass___1), (char const   */* __restrict  */)cp,
            sizeof(pass___1) - 1UL);
#line 310
    pass___1[sizeof(pass___1) - 1UL] = (char )'\000';
#line 311
    tmp___17 = strlen((char const   *)cp);
#line 311
    memset((void *)cp, 0, tmp___17);
    }
#line 313
    if (! amroot___2) {
      {
#line 313
      tmp___19 = obscure((char const   *)(orig), (char const   *)(pass___1), pw);
      }
#line 313
      if (tmp___19) {
        {
#line 313
        tmp___20 = reuse((char const   *)(pass___1), pw);
        }
#line 313
        if (tmp___20) {
          {
#line 314
          tmp___18 = gettext("Try again.");
#line 314
          puts((char const   *)tmp___18);
          }
#line 315
          goto __Cont;
        }
      } else {
        {
#line 314
        tmp___18 = gettext("Try again.");
#line 314
        puts((char const   *)tmp___18);
        }
#line 315
        goto __Cont;
      }
    }
#line 323
    if (amroot___2) {
#line 323
      if (! warned) {
        {
#line 323
        tmp___22 = getdef_bool("PASS_ALWAYS_WARN");
        }
#line 323
        if (tmp___22) {
          {
#line 323
          tmp___23 = obscure((char const   *)(orig), (char const   *)(pass___1), pw);
          }
#line 323
          if (tmp___23) {
            {
#line 323
            tmp___24 = reuse((char const   *)(pass___1), pw);
            }
#line 323
            if (tmp___24) {
              {
#line 325
              tmp___21 = gettext("\nWarning: weak password (enter it again to use it anyway).");
#line 325
              puts((char const   *)tmp___21);
#line 326
              warned = (_Bool)1;
              }
#line 327
              goto __Cont;
            }
          } else {
            {
#line 325
            tmp___21 = gettext("\nWarning: weak password (enter it again to use it anyway).");
#line 325
            puts((char const   *)tmp___21);
#line 326
            warned = (_Bool)1;
            }
#line 327
            goto __Cont;
          }
        }
      }
    }
    {
#line 329
    tmp___25 = gettext("Re-enter new password: ");
#line 329
    cp = getpass((char const   *)tmp___25);
    }
#line 330
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 331
      memset((void *)(orig), 0, sizeof(orig));
      }
#line 332
      return (-1);
    }
    {
#line 334
    tmp___28 = strcmp((char const   *)cp, (char const   *)(pass___1));
    }
#line 334
    if (tmp___28 != 0) {
      {
#line 335
      tmp___26 = gettext("They don\'t match; try again.\n");
#line 335
      fputs((char const   */* __restrict  */)tmp___26, (FILE */* __restrict  */)stderr);
      }
    } else {
      {
#line 337
      tmp___27 = strlen((char const   *)cp);
#line 337
      memset((void *)cp, 0, tmp___27);
      }
#line 338
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 301
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 341
  memset((void *)(orig), 0, sizeof(orig));
  }
#line 343
  if (i == 0) {
    {
#line 344
    memset((void *)(pass___1), 0, sizeof(pass___1));
    }
#line 345
    return (-1);
  }
  {
#line 351
  tmp___29 = crypt_make_salt((char const   *)((void *)0), (void *)0);
#line 351
  cp = pw_encrypt((char const   *)(pass___1), tmp___29);
#line 352
  memset((void *)(pass___1), 0, sizeof(pass___1));
#line 357
  strncpy((char */* __restrict  */)(crypt_passwd), (char const   */* __restrict  */)cp,
          sizeof(crypt_passwd) - 1UL);
#line 357
  crypt_passwd[sizeof(crypt_passwd) - 1UL] = (char )'\000';
  }
#line 358
  return (0);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void check_password(struct passwd  const  *pw , struct spwd  const  *sp ) 
{ 
  time_t now ;
  int exp_status ;
  char *tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  time_t ok ;
  char *tmp___1 ;
  char *old_locale___0 ;
  char *tmp___2 ;
  char *saved_locale___0 ;

  {
  {
#line 372
  exp_status = isexpired(pw, sp);
  }
#line 378
  if (kflg___0) {
#line 378
    if (0 == exp_status) {
      {
#line 379
      exit(0);
      }
    }
  }
#line 385
  if (amroot___2) {
#line 386
    return;
  }
  {
#line 389
  time(& now);
  }
#line 397
  if ((int )*(sp->sp_pwdp + 0) == 33) {
#line 397
    goto _L;
  } else
#line 397
  if (exp_status > 1) {
#line 397
    goto _L;
  } else
#line 397
  if (sp->sp_max >= 0L) {
#line 397
    if (sp->sp_min > sp->sp_max) {
      _L: /* CIL Label */ 
      {
#line 401
      tmp = gettext("The password for %s cannot be changed.\n");
#line 401
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              sp->sp_namp);
      }
      {
#line 404
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 404
        tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 404
        old_locale = tmp___0;
#line 404
        saved_locale = (char *)((void *)0);
        }
#line 404
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 404
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 404
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 404
          setlocale(6, "C");
          }
        }
        {
#line 404
        syslog(4, "password locked for \'%s\'", sp->sp_namp);
        }
#line 404
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 404
          setlocale(6, (char const   *)saved_locale);
#line 404
          free((void *)saved_locale);
          }
        }
#line 404
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 405
      closelog();
#line 406
      exit(1);
      }
    }
  }
#line 412
  if (sp->sp_lstchg > 0L) {
#line 414
    ok = (time_t )sp->sp_lstchg * 86400L;
#line 415
    if (sp->sp_min > 0L) {
#line 416
      ok += (time_t )sp->sp_min * 86400L;
    }
#line 419
    if (now < ok) {
      {
#line 420
      tmp___1 = gettext("The password for %s cannot be changed yet.\n");
#line 420
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              pw->pw_name);
      }
      {
#line 423
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 423
        tmp___2 = setlocale(6, (char const   *)((void *)0));
#line 423
        old_locale___0 = tmp___2;
#line 423
        saved_locale___0 = (char *)((void *)0);
        }
#line 423
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 423
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 423
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 423
          setlocale(6, "C");
          }
        }
        {
#line 423
        syslog(4, "now < minimum age for \'%s\'", pw->pw_name);
        }
#line 423
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 423
          setlocale(6, (char const   *)saved_locale___0);
#line 423
          free((void *)saved_locale___0);
          }
        }
#line 423
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 424
      closelog();
#line 425
      exit(1);
      }
    }
  }
#line 428
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char buf[80]  ;
#line 431 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char const   *date_to_str___1(time_t t ) 
{ 
  struct tm *tm ;

  {
  {
#line 436
  tm = gmtime((time_t const   *)(& t));
#line 438
  strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%m/%d/%Y",
           (struct tm  const  */* __restrict  */)tm);
  }
#line 443
  return ((char const   *)(buf));
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char const   *pw_status(char const   *pass___1 ) 
{ 


  {
#line 448
  if ((int const   )*pass___1 == 42) {
#line 449
    return ("L");
  } else
#line 448
  if ((int const   )*pass___1 == 33) {
#line 449
    return ("L");
  }
#line 451
  if ((int const   )*pass___1 == 0) {
#line 452
    return ("NP");
  }
#line 454
  return ("P");
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void print_status(struct passwd  const  *pw ) 
{ 
  struct spwd *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 464
  sp = getspnam((char const   *)pw->pw_name);
  }
#line 465
  if ((unsigned long )((void *)0) != (unsigned long )sp) {
    {
#line 466
    tmp = date_to_str___1(sp->sp_lstchg * 86400L);
#line 466
    tmp___0 = pw_status((char const   *)sp->sp_pwdp);
#line 466
    printf((char const   */* __restrict  */)"%s %s %s %lld %lld %lld %lld\n", pw->pw_name,
           tmp___0, tmp, ((long long )sp->sp_min * 86400LL) / 86400LL, ((long long )sp->sp_max * 86400LL) / 86400LL,
           ((long long )sp->sp_warn * 86400LL) / 86400LL, ((long long )sp->sp_inact * 86400LL) / 86400LL);
    }
  } else {
    {
#line 475
    tmp___1 = pw_status((char const   *)pw->pw_passwd);
#line 475
    printf((char const   */* __restrict  */)"%s %s\n", pw->pw_name, tmp___1);
    }
  }
#line 478
  return;
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void fail_exit___13(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 483
  if (pw_locked___9) {
    {
#line 484
    tmp___3 = pw_unlock();
    }
#line 484
    if (tmp___3 == 0) {
      {
#line 485
      tmp = pw_dbname();
#line 485
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 485
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 486
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 486
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 486
        old_locale = tmp___1;
#line 486
        saved_locale = (char *)((void *)0);
        }
#line 486
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 486
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 486
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 486
          setlocale(6, "C");
          }
        }
        {
#line 486
        tmp___2 = pw_dbname();
#line 486
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 486
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 486
          setlocale(6, (char const   *)saved_locale);
#line 486
          free((void *)saved_locale);
          }
        }
#line 486
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 491
  if (spw_locked___8) {
    {
#line 492
    tmp___8 = spw_unlock();
    }
#line 492
    if (tmp___8 == 0) {
      {
#line 493
      tmp___4 = spw_dbname();
#line 493
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 493
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 494
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 494
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 494
        old_locale___0 = tmp___6;
#line 494
        saved_locale___0 = (char *)((void *)0);
        }
#line 494
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 494
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 494
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 494
          setlocale(6, "C");
          }
        }
        {
#line 494
        tmp___7 = spw_dbname();
#line 494
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 494
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 494
          setlocale(6, (char const   *)saved_locale___0);
#line 494
          free((void *)saved_locale___0);
          }
        }
#line 494
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 499
  exit(status);
  }
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void oom(void) 
{ 
  char *tmp ;

  {
  {
#line 504
  tmp = gettext("%s: out of memory\n");
#line 504
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, Prog);
#line 505
  fail_exit___13(3);
  }
#line 506
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static char *update_crypt_pw(char *cp ) 
{ 
  char *tmp ;
  char *newpw ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 511
  if (do_update_pwd) {
    {
#line 512
    cp = xstrdup((char const   *)(crypt_passwd));
    }
  }
#line 516
  if (dflg___3) {
#line 517
    *cp = (char )'\000';
  }
#line 520
  if (uflg___2) {
#line 520
    if ((int )*cp == 33) {
#line 521
      if ((int )*(cp + 1) == 0) {
        {
#line 522
        tmp = gettext("%s: unlocking the password would result in a passwordless account.\nYou should set a password with usermod -p to unlock the password of this account.\n");
#line 522
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                Prog);
#line 526
        fail_exit___13(3);
        }
      } else {
#line 528
        cp ++;
      }
    }
  }
#line 532
  if (lflg___3) {
#line 532
    if ((int )*cp != 33) {
      {
#line 533
      tmp___0 = strlen((char const   *)cp);
#line 533
      tmp___1 = xmalloc(tmp___0 + 2UL);
#line 533
      newpw = tmp___1;
#line 535
      strcpy((char */* __restrict  */)newpw, (char const   */* __restrict  */)"!");
#line 536
      strcat((char */* __restrict  */)newpw, (char const   */* __restrict  */)cp);
#line 537
      cp = newpw;
      }
    }
  }
#line 539
  return (cp);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void update_noshadow(void) 
{ 
  struct passwd  const  *pw ;
  struct passwd *npw ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *old_locale___0 ;
  char *tmp___14 ;
  char *saved_locale___0 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *old_locale___1 ;
  char *tmp___19 ;
  char *saved_locale___1 ;
  char const   *tmp___20 ;
  int tmp___21 ;

  {
  {
#line 548
  tmp___1 = pw_lock();
  }
#line 548
  if (tmp___1 == 0) {
    {
#line 549
    tmp = pw_dbname();
#line 549
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 552
    exit(5);
    }
  }
  {
#line 554
  pw_locked___9 = (_Bool)1;
#line 555
  tmp___6 = pw_open(2);
  }
#line 555
  if (tmp___6 == 0) {
    {
#line 556
    tmp___2 = pw_dbname();
#line 556
    tmp___3 = gettext("%s: cannot open %s\n");
#line 556
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
    }
    {
#line 559
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 559
      tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 559
      old_locale = tmp___4;
#line 559
      saved_locale = (char *)((void *)0);
      }
#line 559
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 559
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 559
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 559
        setlocale(6, "C");
        }
      }
      {
#line 559
      tmp___5 = pw_dbname();
#line 559
      syslog(4, "cannot open %s", tmp___5);
      }
#line 559
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 559
        setlocale(6, (char const   *)saved_locale);
#line 559
        free((void *)saved_locale);
        }
      }
#line 559
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 560
    fail_exit___13(4);
    }
  }
  {
#line 562
  pw = pw_locate((char const   *)name___2);
  }
#line 563
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
    {
#line 564
    tmp___7 = pw_dbname();
#line 564
    tmp___8 = gettext("%s: user \'%s\' does not exist in %s\n");
#line 564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            Prog, name___2, tmp___7);
#line 567
    fail_exit___13(1);
    }
  }
  {
#line 569
  npw = __pw_dup(pw);
  }
#line 570
  if ((unsigned long )((void *)0) == (unsigned long )npw) {
    {
#line 571
    oom();
    }
  }
  {
#line 573
  npw->pw_passwd = update_crypt_pw(npw->pw_passwd);
#line 574
  tmp___11 = pw_update((struct passwd  const  *)npw);
  }
#line 574
  if (tmp___11 == 0) {
    {
#line 575
    tmp___9 = pw_dbname();
#line 575
    tmp___10 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 575
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
            Prog, tmp___9, npw->pw_name);
#line 578
    fail_exit___13(3);
    }
  }
  {
#line 580
  tmp___16 = pw_close();
  }
#line 580
  if (tmp___16 == 0) {
    {
#line 581
    tmp___12 = pw_dbname();
#line 581
    tmp___13 = gettext("%s: failure while writing changes to %s\n");
#line 581
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
            Prog, tmp___12);
    }
    {
#line 584
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 584
      tmp___14 = setlocale(6, (char const   *)((void *)0));
#line 584
      old_locale___0 = tmp___14;
#line 584
      saved_locale___0 = (char *)((void *)0);
      }
#line 584
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 584
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 584
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 584
        setlocale(6, "C");
        }
      }
      {
#line 584
      tmp___15 = pw_dbname();
#line 584
      syslog(3, "failure while writing changes to %s", tmp___15);
      }
#line 584
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 584
        setlocale(6, (char const   *)saved_locale___0);
#line 584
        free((void *)saved_locale___0);
        }
      }
#line 584
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 585
    fail_exit___13(3);
    }
  }
  {
#line 587
  tmp___21 = pw_unlock();
  }
#line 587
  if (tmp___21 == 0) {
    {
#line 588
    tmp___17 = pw_dbname();
#line 588
    tmp___18 = gettext("%s: failed to unlock %s\n");
#line 588
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18,
            Prog, tmp___17);
    }
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 591
      tmp___19 = setlocale(6, (char const   *)((void *)0));
#line 591
      old_locale___1 = tmp___19;
#line 591
      saved_locale___1 = (char *)((void *)0);
      }
#line 591
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 591
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 591
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 591
        setlocale(6, "C");
        }
      }
      {
#line 591
      tmp___20 = pw_dbname();
#line 591
      syslog(3, "failed to unlock %s", tmp___20);
      }
#line 591
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 591
        setlocale(6, (char const   *)saved_locale___1);
#line 591
        free((void *)saved_locale___1);
        }
      }
#line 591
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 594
  pw_locked___9 = (_Bool)0;
#line 595
  return;
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static void update_shadow(void) 
{ 
  struct spwd  const  *sp ;
  struct spwd *nsp ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *old_locale ;
  char *tmp___4 ;
  char *saved_locale ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *old_locale___0 ;
  char *tmp___9 ;
  char *saved_locale___0 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  time_t tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char *old_locale___1 ;
  char *tmp___18 ;
  char *saved_locale___1 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char *old_locale___2 ;
  char *tmp___23 ;
  char *saved_locale___2 ;
  char const   *tmp___24 ;
  int tmp___25 ;

  {
  {
#line 602
  tmp___1 = spw_lock();
  }
#line 602
  if (tmp___1 == 0) {
    {
#line 603
    tmp = spw_dbname();
#line 603
    tmp___0 = gettext("%s: cannot lock %s; try again later.\n");
#line 603
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, tmp);
#line 606
    exit(5);
    }
  }
  {
#line 608
  spw_locked___8 = (_Bool)1;
#line 609
  tmp___6 = spw_open(2);
  }
#line 609
  if (tmp___6 == 0) {
    {
#line 610
    tmp___2 = spw_dbname();
#line 610
    tmp___3 = gettext("%s: cannot open %s\n");
#line 610
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
    }
    {
#line 613
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 613
      tmp___4 = setlocale(6, (char const   *)((void *)0));
#line 613
      old_locale = tmp___4;
#line 613
      saved_locale = (char *)((void *)0);
      }
#line 613
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 613
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 613
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 613
        setlocale(6, "C");
        }
      }
      {
#line 613
      tmp___5 = spw_dbname();
#line 613
      syslog(4, "cannot open %s", tmp___5);
      }
#line 613
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 613
        setlocale(6, (char const   *)saved_locale);
#line 613
        free((void *)saved_locale);
        }
      }
#line 613
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 614
    fail_exit___13(3);
    }
  }
  {
#line 616
  sp = spw_locate((char const   *)name___2);
  }
#line 617
  if ((unsigned long )((void *)0) == (unsigned long )sp) {
    {
#line 619
    spw_close();
#line 620
    update_noshadow();
#line 621
    tmp___11 = spw_unlock();
    }
#line 621
    if (tmp___11 == 0) {
      {
#line 622
      tmp___7 = spw_dbname();
#line 622
      tmp___8 = gettext("%s: failed to unlock %s\n");
#line 622
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
              Prog, tmp___7);
      }
      {
#line 625
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 625
        tmp___9 = setlocale(6, (char const   *)((void *)0));
#line 625
        old_locale___0 = tmp___9;
#line 625
        saved_locale___0 = (char *)((void *)0);
        }
#line 625
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 625
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 625
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 625
          setlocale(6, "C");
          }
        }
        {
#line 625
        tmp___10 = spw_dbname();
#line 625
        syslog(3, "failed to unlock %s", tmp___10);
        }
#line 625
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 625
          setlocale(6, (char const   *)saved_locale___0);
#line 625
          free((void *)saved_locale___0);
          }
        }
#line 625
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 628
    spw_locked___8 = (_Bool)0;
#line 629
    return;
  }
  {
#line 631
  nsp = __spw_dup(sp);
  }
#line 632
  if ((unsigned long )((void *)0) == (unsigned long )nsp) {
    {
#line 633
    oom();
    }
  }
  {
#line 635
  nsp->sp_pwdp = update_crypt_pw(nsp->sp_pwdp);
  }
#line 636
  if (xflg) {
#line 637
    nsp->sp_max = (age_max * 86400L) / 86400L;
  }
#line 639
  if (nflg___0) {
#line 640
    nsp->sp_min = (age_min * 86400L) / 86400L;
  }
#line 642
  if (wflg) {
#line 643
    nsp->sp_warn = (warn * 86400L) / 86400L;
  }
#line 645
  if (iflg) {
#line 646
    nsp->sp_inact = (inact * 86400L) / 86400L;
  }
#line 649
  if (do_update_age) {
    {
#line 650
    tmp___12 = time((time_t *)0);
#line 650
    nsp->sp_lstchg = tmp___12 / 86400L;
    }
#line 651
    if (0L == nsp->sp_lstchg) {
#line 654
      nsp->sp_lstchg = -1L;
    }
  }
#line 664
  if (eflg___3) {
#line 665
    nsp->sp_lstchg = 0L;
  }
  {
#line 668
  tmp___15 = spw_update((struct spwd  const  *)nsp);
  }
#line 668
  if (tmp___15 == 0) {
    {
#line 669
    tmp___13 = spw_dbname();
#line 669
    tmp___14 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 669
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
            Prog, tmp___13, nsp->sp_namp);
#line 672
    fail_exit___13(3);
    }
  }
  {
#line 674
  tmp___20 = spw_close();
  }
#line 674
  if (tmp___20 == 0) {
    {
#line 675
    tmp___16 = spw_dbname();
#line 675
    tmp___17 = gettext("%s: failure while writing changes to %s\n");
#line 675
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
            Prog, tmp___16);
    }
    {
#line 678
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 678
      tmp___18 = setlocale(6, (char const   *)((void *)0));
#line 678
      old_locale___1 = tmp___18;
#line 678
      saved_locale___1 = (char *)((void *)0);
      }
#line 678
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 678
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 678
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 678
        setlocale(6, "C");
        }
      }
      {
#line 678
      tmp___19 = spw_dbname();
#line 678
      syslog(3, "failure while writing changes to %s", tmp___19);
      }
#line 678
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 678
        setlocale(6, (char const   *)saved_locale___1);
#line 678
        free((void *)saved_locale___1);
        }
      }
#line 678
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 679
    fail_exit___13(3);
    }
  }
  {
#line 681
  tmp___25 = spw_unlock();
  }
#line 681
  if (tmp___25 == 0) {
    {
#line 682
    tmp___21 = spw_dbname();
#line 682
    tmp___22 = gettext("%s: failed to unlock %s\n");
#line 682
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
            Prog, tmp___21);
    }
    {
#line 685
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 685
      tmp___23 = setlocale(6, (char const   *)((void *)0));
#line 685
      old_locale___2 = tmp___23;
#line 685
      saved_locale___2 = (char *)((void *)0);
      }
#line 685
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___2) {
        {
#line 685
        saved_locale___2 = strdup((char const   *)old_locale___2);
        }
      }
#line 685
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 685
        setlocale(6, "C");
        }
      }
      {
#line 685
      tmp___24 = spw_dbname();
#line 685
      syslog(3, "failed to unlock %s", tmp___24);
      }
#line 685
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___2) {
        {
#line 685
        setlocale(6, (char const   *)saved_locale___2);
#line 685
        free((void *)saved_locale___2);
        }
      }
#line 685
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 688
  spw_locked___8 = (_Bool)0;
#line 689
  return;
}
}
#line 806 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/passwd.c"
static struct option long_options___21[16]  = 
#line 806
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"delete", 0, (int *)((void *)0), 'd'}, 
        {"expire", 0, (int *)((void *)0), 'e'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"inactive", 1, (int *)((void *)0), 'i'}, 
        {"keep-tokens", 0, (int *)((void *)0), 'k'}, 
        {"lock", 0, (int *)((void *)0), 'l'}, 
        {"mindays", 1, (int *)((void *)0), 'n'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"repository", 1, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"status", 0, (int *)((void *)0), 'S'}, 
        {"unlock", 0, (int *)((void *)0), 'u'}, 
        {"warndays", 1, (int *)((void *)0), 'w'}, 
        {"maxdays", 1, (int *)((void *)0), 'x'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___27[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___27[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___27  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___26(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___26  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___51  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___26(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___51) {
#line 70
      size___51 = i + 100;
#line 71
      if (members___26) {
        {
#line 72
        tmp = realloc((void *)members___26, (unsigned long )size___51 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___51 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___26) {
          {
#line 81
          free((void *)members___26);
          }
        }
#line 82
        members___26 = (char **)0;
#line 83
        size___51 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___26 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___26 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___26 + i) = (char *)0;
#line 99
  return (members___26);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___25  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___52  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___25[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___25  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___27(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___27(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___27  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___27  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___27  ;
#line 72
static int copy_entry___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___27(char const   *filename___0 ) ;
#line 83
static int copy_symlink___27(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___27(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___27(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___27(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___27(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___27(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___27 == (unsigned long )ln) {
    {
#line 149
    links___27 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___27;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___27(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___27)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___27)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___27;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___27);
#line 199
  dst_len = strlen(dst_orig___27);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___27, name___3 + src_len);
#line 207
  lp->ln_next = links___27;
#line 208
  links___27 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___27(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___27(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___27(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___27(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___27(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___27(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___27(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___27(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___27(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___27)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___27)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___27(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___27);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___27, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___27);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___27);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___27);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___27, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___27(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___27(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___27(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___27(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___27(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___27(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___27(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___27(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___27(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___27[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___27[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___28(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___28(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___28[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___28[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___28  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static char fullnm[8192]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static char roomno[8192]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static char workph[8192]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static char homeph[8192]  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static char slop[8192]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool amroot___3  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool fflg___4  =    (_Bool)0;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool rflg___6  =    (_Bool)0;
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool wflg___0  =    (_Bool)0;
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool hflg___0  =    (_Bool)0;
#line 74 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool oflg___3  =    (_Bool)0;
#line 75 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool pw_locked___10  =    (_Bool)0;
#line 82
static void fail_exit___14(int code ) ;
#line 83
static void usage___25(int status ) ;
#line 84
static _Bool may_change_field(int field ) ;
#line 85
static void new_fields___1(void) ;
#line 86
static char *copy_field(char *in , char *out , char *extra ) ;
#line 87
static void process_flags___19(int argc , char **argv ) ;
#line 88
static void check_perms___9(struct passwd  const  *pw ) ;
#line 89
static void update_gecos(char const   *user___0 , char *gecos ) ;
#line 90
static void get_old_fields(char const   *gecos ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void fail_exit___14(int code ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 97
  if (pw_locked___10) {
    {
#line 98
    tmp___3 = pw_unlock();
    }
#line 98
    if (tmp___3 == 0) {
      {
#line 99
      tmp = pw_dbname();
#line 99
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 100
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 100
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 100
        old_locale = tmp___1;
#line 100
        saved_locale = (char *)((void *)0);
        }
#line 100
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 100
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 100
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 100
          setlocale(6, "C");
          }
        }
        {
#line 100
        tmp___2 = pw_dbname();
#line 100
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 100
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 100
          setlocale(6, (char const   *)saved_locale);
#line 100
          free((void *)saved_locale);
          }
        }
#line 100
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 104
  pw_locked___10 = (_Bool)0;
#line 106
  closelog();
#line 108
  exit(code);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void usage___25(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 116
  if (0 != status) {
#line 116
    tmp = stderr;
  } else {
#line 116
    tmp = stdout;
  }
  {
#line 116
  usageout = tmp;
#line 117
  tmp___0 = gettext("Usage: %s [options] [LOGIN]\n\nOptions:\n");
#line 117
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 122
  tmp___1 = gettext("  -f, --full-name FULL_NAME     change user\'s full name\n");
#line 122
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 123
  tmp___2 = gettext("  -h, --home-phone HOME_PHONE   change user\'s home phone number\n");
#line 123
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 124
  tmp___3 = gettext("  -o, --other OTHER_INFO        change user\'s other GECOS information\n");
#line 124
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 125
  tmp___4 = gettext("  -r, --room ROOM_NUMBER        change user\'s room number\n");
#line 125
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 126
  tmp___5 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 126
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 127
  tmp___6 = gettext("  -u, --help                    display this help message and exit\n");
#line 127
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)usageout);
#line 128
  tmp___7 = gettext("  -w, --work-phone WORK_PHONE   change user\'s office phone number\n");
#line 128
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)usageout);
#line 129
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 130
  exit(status);
  }
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static _Bool may_change_field(int field ) 
{ 
  char const   *cp ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 164
  if (amroot___3) {
#line 165
    return ((_Bool)1);
  }
  {
#line 168
  cp = getdef_str("CHFN_RESTRICT");
  }
#line 169
  if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 170
    cp = "";
  } else {
    {
#line 171
    tmp___0 = strcmp(cp, "yes");
    }
#line 171
    if (tmp___0 == 0) {
#line 172
      cp = "rwh";
    } else {
      {
#line 173
      tmp = strcmp(cp, "no");
      }
#line 173
      if (tmp == 0) {
#line 174
        cp = "frwh";
      }
    }
  }
  {
#line 177
  tmp___1 = strchr(cp, field);
  }
#line 177
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 178
    return ((_Bool)1);
  }
#line 181
  return ((_Bool)0);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void new_fields___1(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  _Bool tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  _Bool tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  _Bool tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 192
  tmp = gettext("Enter the new value, or press ENTER for the default");
#line 192
  puts((char const   *)tmp);
#line 194
  tmp___3 = may_change_field('f');
  }
#line 194
  if (tmp___3) {
    {
#line 195
    tmp___0 = gettext("Full Name");
#line 195
    change_field(fullnm, sizeof(fullnm), (char const   *)tmp___0);
    }
  } else {
    {
#line 197
    tmp___1 = gettext("Full Name");
#line 197
    tmp___2 = gettext("\t%s: %s\n");
#line 197
    printf((char const   */* __restrict  */)tmp___2, tmp___1, fullnm);
    }
  }
  {
#line 200
  tmp___7 = may_change_field('r');
  }
#line 200
  if (tmp___7) {
    {
#line 201
    tmp___4 = gettext("Room Number");
#line 201
    change_field(roomno, sizeof(roomno), (char const   *)tmp___4);
    }
  } else {
    {
#line 203
    tmp___5 = gettext("Room Number");
#line 203
    tmp___6 = gettext("\t%s: %s\n");
#line 203
    printf((char const   */* __restrict  */)tmp___6, tmp___5, fullnm);
    }
  }
  {
#line 206
  tmp___11 = may_change_field('w');
  }
#line 206
  if (tmp___11) {
    {
#line 207
    tmp___8 = gettext("Work Phone");
#line 207
    change_field(workph, sizeof(workph), (char const   *)tmp___8);
    }
  } else {
    {
#line 209
    tmp___9 = gettext("Work Phone");
#line 209
    tmp___10 = gettext("\t%s: %s\n");
#line 209
    printf((char const   */* __restrict  */)tmp___10, tmp___9, fullnm);
    }
  }
  {
#line 212
  tmp___15 = may_change_field('h');
  }
#line 212
  if (tmp___15) {
    {
#line 213
    tmp___12 = gettext("Home Phone");
#line 213
    change_field(homeph, sizeof(homeph), (char const   *)tmp___12);
    }
  } else {
    {
#line 215
    tmp___13 = gettext("Home Phone");
#line 215
    tmp___14 = gettext("\t%s: %s\n");
#line 215
    printf((char const   */* __restrict  */)tmp___14, tmp___13, fullnm);
    }
  }
#line 218
  if (amroot___3) {
    {
#line 219
    tmp___16 = gettext("Other");
#line 219
    change_field(slop, sizeof(slop), (char const   *)tmp___16);
    }
  }
#line 221
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static char *copy_field(char *in , char *out , char *extra ) 
{ 
  char *cp ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 235
  cp = (char *)((void *)0);
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! ((unsigned long )((void *)0) != (unsigned long )in)) {
#line 237
      goto while_break;
    }
    {
#line 238
    cp = strchr((char const   *)in, ',');
    }
#line 239
    if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 240
      tmp = cp;
#line 240
      cp ++;
#line 240
      *tmp = (char )'\000';
    }
    {
#line 243
    tmp___0 = strchr((char const   *)in, '=');
    }
#line 243
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 244
      goto while_break;
    }
#line 247
    if ((unsigned long )((void *)0) != (unsigned long )extra) {
#line 248
      if (0 != (int )*(extra + 0)) {
        {
#line 249
        strcat((char */* __restrict  */)extra, (char const   */* __restrict  */)",");
        }
      }
      {
#line 252
      strcat((char */* __restrict  */)extra, (char const   */* __restrict  */)in);
      }
    }
#line 254
    in = cp;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if ((unsigned long )((void *)0) != (unsigned long )in) {
#line 256
    if ((unsigned long )((void *)0) != (unsigned long )out) {
      {
#line 257
      strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)in);
      }
    }
  }
#line 260
  return (cp);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static struct option long_options___22[8]  = 
#line 271
  {      {"full-name", 1, (int *)((void *)0), 'f'}, 
        {"home-phone", 1, (int *)((void *)0), 'h'}, 
        {"other", 1, (int *)((void *)0), 'o'}, 
        {"room", 1, (int *)((void *)0), 'r'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"help", 0, (int *)((void *)0), 'u'}, 
        {"work-phone", 1, (int *)((void *)0), 'w'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 268 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void process_flags___19(int argc , char **argv ) 
{ 
  int c ;
  char *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    c = getopt_long(argc, (char * const  *)argv, "f:h:o:r:R:uw:", (struct option  const  *)(long_options___22),
                    (int *)((void *)0));
    }
#line 289
    if (! (c != -1)) {
#line 289
      goto while_break;
    }
    {
#line 292
    if (c == 102) {
#line 292
      goto case_102;
    }
#line 301
    if (c == 104) {
#line 301
      goto case_104;
    }
#line 310
    if (c == 111) {
#line 310
      goto case_111;
    }
#line 319
    if (c == 114) {
#line 319
      goto case_114;
    }
#line 328
    if (c == 82) {
#line 328
      goto case_82;
    }
#line 330
    if (c == 117) {
#line 330
      goto case_117;
    }
#line 333
    if (c == 119) {
#line 333
      goto case_119;
    }
#line 342
    goto switch_default;
    case_102: /* CIL Label */ 
    {
#line 293
    tmp___0 = may_change_field('f');
    }
#line 293
    if (! tmp___0) {
      {
#line 294
      tmp = gettext("%s: Permission denied.\n");
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 296
      exit(1);
      }
    }
    {
#line 298
    fflg___4 = (_Bool)1;
#line 299
    strncpy((char */* __restrict  */)(fullnm), (char const   */* __restrict  */)optarg,
            sizeof(fullnm) - 1UL);
#line 299
    fullnm[sizeof(fullnm) - 1UL] = (char )'\000';
    }
#line 300
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 302
    tmp___2 = may_change_field('h');
    }
#line 302
    if (! tmp___2) {
      {
#line 303
      tmp___1 = gettext("%s: Permission denied.\n");
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              Prog);
#line 305
      exit(1);
      }
    }
    {
#line 307
    hflg___0 = (_Bool)1;
#line 308
    strncpy((char */* __restrict  */)(homeph), (char const   */* __restrict  */)optarg,
            sizeof(homeph) - 1UL);
#line 308
    homeph[sizeof(homeph) - 1UL] = (char )'\000';
    }
#line 309
    goto switch_break;
    case_111: /* CIL Label */ 
#line 311
    if (! amroot___3) {
      {
#line 312
      tmp___3 = gettext("%s: Permission denied.\n");
#line 312
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              Prog);
#line 314
      exit(1);
      }
    }
    {
#line 316
    oflg___3 = (_Bool)1;
#line 317
    strncpy((char */* __restrict  */)(slop), (char const   */* __restrict  */)optarg,
            sizeof(slop) - 1UL);
#line 317
    slop[sizeof(slop) - 1UL] = (char )'\000';
    }
#line 318
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 320
    tmp___5 = may_change_field('r');
    }
#line 320
    if (! tmp___5) {
      {
#line 321
      tmp___4 = gettext("%s: Permission denied.\n");
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              Prog);
#line 323
      exit(1);
      }
    }
    {
#line 325
    rflg___6 = (_Bool)1;
#line 326
    strncpy((char */* __restrict  */)(roomno), (char const   */* __restrict  */)optarg,
            sizeof(roomno) - 1UL);
#line 326
    roomno[sizeof(roomno) - 1UL] = (char )'\000';
    }
#line 327
    goto switch_break;
    case_82: /* CIL Label */ 
#line 329
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 331
    usage___25(0);
    }
#line 332
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 334
    tmp___7 = may_change_field('w');
    }
#line 334
    if (! tmp___7) {
      {
#line 335
      tmp___6 = gettext("%s: Permission denied.\n");
#line 335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              Prog);
#line 337
      exit(1);
      }
    }
    {
#line 339
    wflg___0 = (_Bool)1;
#line 340
    strncpy((char */* __restrict  */)(workph), (char const   */* __restrict  */)optarg,
            sizeof(workph) - 1UL);
#line 340
    workph[sizeof(workph) - 1UL] = (char )'\000';
    }
#line 341
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 343
    usage___25(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void check_perms___9(struct passwd  const  *pw ) 
{ 
  char *tmp ;
  __uid_t tmp___0 ;
  _Bool tmp___1 ;

  {
#line 370
  if (! amroot___3) {
    {
#line 370
    tmp___0 = getuid();
    }
#line 370
    if (pw->pw_uid != (__uid_t const   )tmp___0) {
      {
#line 371
      tmp = gettext("%s: Permission denied.\n");
#line 371
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              Prog);
#line 372
      closelog();
#line 373
      exit(1);
      }
    }
  }
#line 396
  if (! amroot___3) {
    {
#line 396
    tmp___1 = getdef_bool("CHFN_AUTH");
    }
#line 396
    if (tmp___1) {
      {
#line 397
      passwd_check((char const   *)pw->pw_name, (char const   *)pw->pw_passwd, "chfn");
      }
    }
  }
#line 430
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void update_gecos(char const   *user___0 , char *gecos ) 
{ 
  struct passwd  const  *pw ;
  struct passwd pwent___0 ;
  char *tmp ;
  char *old_locale ;
  char *tmp___0 ;
  char *saved_locale ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *old_locale___0 ;
  char *tmp___15 ;
  char *saved_locale___0 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  char *old_locale___1 ;
  char *tmp___20 ;
  char *saved_locale___1 ;
  char const   *tmp___21 ;
  int tmp___22 ;

  {
  {
#line 448
  tmp___1 = setuid((__uid_t )0);
  }
#line 448
  if (tmp___1 != 0) {
    {
#line 449
    tmp = gettext("Cannot change ID to root.\n");
#line 449
    fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
    }
    {
#line 450
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 450
      tmp___0 = setlocale(6, (char const   *)((void *)0));
#line 450
      old_locale = tmp___0;
#line 450
      saved_locale = (char *)((void *)0);
      }
#line 450
      if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
        {
#line 450
        saved_locale = strdup((char const   *)old_locale);
        }
      }
#line 450
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 450
        setlocale(6, "C");
        }
      }
      {
#line 450
      syslog(3, "can\'t setuid(0)");
      }
#line 450
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
        {
#line 450
        setlocale(6, (char const   *)saved_locale);
#line 450
        free((void *)saved_locale);
        }
      }
#line 450
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 451
    fail_exit___14(1);
    }
  }
  {
#line 453
  pwd_init();
#line 459
  tmp___4 = pw_lock();
  }
#line 459
  if (tmp___4 == 0) {
    {
#line 460
    tmp___2 = pw_dbname();
#line 460
    tmp___3 = gettext("%s: cannot lock %s; try again later.\n");
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, tmp___2);
#line 463
    fail_exit___14(1);
    }
  }
  {
#line 465
  pw_locked___10 = (_Bool)1;
#line 466
  tmp___7 = pw_open(2);
  }
#line 466
  if (tmp___7 == 0) {
    {
#line 467
    tmp___5 = pw_dbname();
#line 467
    tmp___6 = gettext("%s: cannot open %s\n");
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            Prog, tmp___5);
#line 469
    fail_exit___14(1);
    }
  }
  {
#line 478
  pw = pw_locate(user___0);
  }
#line 479
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
    {
#line 480
    tmp___8 = pw_dbname();
#line 480
    tmp___9 = gettext("%s: user \'%s\' does not exist in %s\n");
#line 480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
            Prog, user___0, tmp___8);
#line 483
    fail_exit___14(1);
    }
  }
  {
#line 490
  pwent___0 = (struct passwd )*pw;
#line 491
  pwent___0.pw_gecos = gecos;
#line 497
  tmp___12 = pw_update((struct passwd  const  *)(& pwent___0));
  }
#line 497
  if (tmp___12 == 0) {
    {
#line 498
    tmp___10 = pw_dbname();
#line 498
    tmp___11 = gettext("%s: failed to prepare the new %s entry \'%s\'\n");
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            Prog, tmp___10, pwent___0.pw_name);
#line 501
    fail_exit___14(1);
    }
  }
  {
#line 507
  tmp___17 = pw_close();
  }
#line 507
  if (tmp___17 == 0) {
    {
#line 508
    tmp___13 = pw_dbname();
#line 508
    tmp___14 = gettext("%s: failure while writing changes to %s\n");
#line 508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
            Prog, tmp___13);
    }
    {
#line 509
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 509
      tmp___15 = setlocale(6, (char const   *)((void *)0));
#line 509
      old_locale___0 = tmp___15;
#line 509
      saved_locale___0 = (char *)((void *)0);
      }
#line 509
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
        {
#line 509
        saved_locale___0 = strdup((char const   *)old_locale___0);
        }
      }
#line 509
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 509
        setlocale(6, "C");
        }
      }
      {
#line 509
      tmp___16 = pw_dbname();
#line 509
      syslog(3, "failure while writing changes to %s", tmp___16);
      }
#line 509
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
        {
#line 509
        setlocale(6, (char const   *)saved_locale___0);
#line 509
        free((void *)saved_locale___0);
        }
      }
#line 509
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 510
    fail_exit___14(1);
    }
  }
  {
#line 512
  tmp___22 = pw_unlock();
  }
#line 512
  if (tmp___22 == 0) {
    {
#line 513
    tmp___18 = pw_dbname();
#line 513
    tmp___19 = gettext("%s: failed to unlock %s\n");
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
            Prog, tmp___18);
    }
    {
#line 514
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 514
      tmp___20 = setlocale(6, (char const   *)((void *)0));
#line 514
      old_locale___1 = tmp___20;
#line 514
      saved_locale___1 = (char *)((void *)0);
      }
#line 514
      if ((unsigned long )((void *)0) != (unsigned long )old_locale___1) {
        {
#line 514
        saved_locale___1 = strdup((char const   *)old_locale___1);
        }
      }
#line 514
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 514
        setlocale(6, "C");
        }
      }
      {
#line 514
      tmp___21 = pw_dbname();
#line 514
      syslog(3, "failed to unlock %s", tmp___21);
      }
#line 514
      if ((unsigned long )((void *)0) != (unsigned long )saved_locale___1) {
        {
#line 514
        setlocale(6, (char const   *)saved_locale___1);
#line 514
        free((void *)saved_locale___1);
        }
      }
#line 514
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 517
  pw_locked___10 = (_Bool)0;
#line 518
  return;
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void get_old_fields(char const   *gecos ) 
{ 
  char *cp ;
  char old_gecos[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 528
  strncpy((char */* __restrict  */)(old_gecos), (char const   */* __restrict  */)gecos,
          sizeof(old_gecos) - 1UL);
#line 528
  old_gecos[sizeof(old_gecos) - 1UL] = (char )'\000';
  }
#line 534
  if (fflg___4) {
#line 534
    tmp = (char *)0;
  } else {
#line 534
    tmp = fullnm;
  }
  {
#line 534
  cp = copy_field(old_gecos, tmp, slop);
  }
#line 540
  if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 541
    if (rflg___6) {
#line 541
      tmp___0 = (char *)0;
    } else {
#line 541
      tmp___0 = roomno;
    }
    {
#line 541
    cp = copy_field(cp, tmp___0, slop);
    }
  }
#line 547
  if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 548
    if (wflg___0) {
#line 548
      tmp___1 = (char *)0;
    } else {
#line 548
      tmp___1 = workph;
    }
    {
#line 548
    cp = copy_field(cp, tmp___1, slop);
    }
  }
#line 554
  if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 555
    if (hflg___0) {
#line 555
      tmp___2 = (char *)0;
    } else {
#line 555
      tmp___2 = homeph;
    }
    {
#line 555
    cp = copy_field(cp, tmp___2, slop);
    }
  }
#line 561
  if ((unsigned long )((void *)0) != (unsigned long )cp) {
#line 561
    if (! oflg___3) {
#line 562
      if (0 != (int )slop[0]) {
        {
#line 563
        strcat((char */* __restrict  */)(slop), (char const   */* __restrict  */)",");
        }
      }
      {
#line 566
      strcat((char */* __restrict  */)(slop), (char const   */* __restrict  */)cp);
      }
    }
  }
#line 568
  return;
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/chfn.c"
static void check_fields(void) 
{ 
  int err ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 578
  err = valid_field((char const   *)(fullnm), ":,=\n");
  }
#line 579
  if (err > 0) {
    {
#line 580
    tmp = gettext("%s: name with non-ASCII characters: \'%s\'\n");
#line 580
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            Prog, fullnm);
    }
  } else
#line 581
  if (err < 0) {
    {
#line 582
    tmp___0 = gettext("%s: invalid name: \'%s\'\n");
#line 582
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            Prog, fullnm);
#line 583
    fail_exit___14(1);
    }
  }
  {
#line 585
  err = valid_field((char const   *)(roomno), ":,=\n");
  }
#line 586
  if (err > 0) {
    {
#line 587
    tmp___1 = gettext("%s: room number with non-ASCII characters: \'%s\'\n");
#line 587
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            Prog, roomno);
    }
  } else
#line 588
  if (err < 0) {
    {
#line 589
    tmp___2 = gettext("%s: invalid room number: \'%s\'\n");
#line 589
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            Prog, roomno);
#line 591
    fail_exit___14(1);
    }
  }
  {
#line 593
  tmp___4 = valid_field((char const   *)(workph), ":,=\n");
  }
#line 593
  if (tmp___4 != 0) {
    {
#line 594
    tmp___3 = gettext("%s: invalid work phone: \'%s\'\n");
#line 594
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            Prog, workph);
#line 596
    fail_exit___14(1);
    }
  }
  {
#line 598
  tmp___6 = valid_field((char const   *)(homeph), ":,=\n");
  }
#line 598
  if (tmp___6 != 0) {
    {
#line 599
    tmp___5 = gettext("%s: invalid home phone: \'%s\'\n");
#line 599
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            Prog, homeph);
#line 601
    fail_exit___14(1);
    }
  }
  {
#line 603
  err = valid_field((char const   *)(slop), ":\n");
  }
#line 604
  if (err > 0) {
    {
#line 605
    tmp___7 = gettext("%s: \'%s\' contains non-ASCII characters\n");
#line 605
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            Prog, slop);
    }
  } else
#line 606
  if (err < 0) {
    {
#line 607
    tmp___8 = gettext("%s: \'%s\' contains illegal characters\n");
#line 607
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            Prog, slop);
#line 610
    fail_exit___14(1);
    }
  }
#line 612
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___27(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___27  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___53  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___27(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___53) {
#line 70
      size___53 = i + 100;
#line 71
      if (members___27) {
        {
#line 72
        tmp = realloc((void *)members___27, (unsigned long )size___53 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___53 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___27) {
          {
#line 81
          free((void *)members___27);
          }
        }
#line 82
        members___27 = (char **)0;
#line 83
        size___53 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___27 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___27 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___27 + i) = (char *)0;
#line 99
  return (members___27);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___26  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___54  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___26[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___26  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___28(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___28(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___28  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___28  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___28  ;
#line 72
static int copy_entry___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___28(char const   *filename___0 ) ;
#line 83
static int copy_symlink___28(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___28(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___28(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___28(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___28(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___28(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___28 == (unsigned long )ln) {
    {
#line 149
    links___28 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___28;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___28(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___28)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___28)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___28;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___28);
#line 199
  dst_len = strlen(dst_orig___28);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___28, name___3 + src_len);
#line 207
  lp->ln_next = links___28;
#line 208
  links___28 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___28(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___28(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___28(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___28(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___28(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___28(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___28(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___28(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___28(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___28)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___28)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___28(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___28);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___28, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___28);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___28);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___28);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___28, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___28(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___28(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___28(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___28(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___28(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___28(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___28(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___28(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___28(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___28[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___28[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___29(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___29(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___29[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___29[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___29  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___28(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___28  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___55  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___28(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___55) {
#line 70
      size___55 = i + 100;
#line 71
      if (members___28) {
        {
#line 72
        tmp = realloc((void *)members___28, (unsigned long )size___55 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___55 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___28) {
          {
#line 81
          free((void *)members___28);
          }
        }
#line 82
        members___28 = (char **)0;
#line 83
        size___55 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___28 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___28 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___28 + i) = (char *)0;
#line 99
  return (members___28);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___27  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___56  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___27[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___27  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___29(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpunconv.c"
static _Bool gr_locked___7  =    (_Bool)0;
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpunconv.c"
static _Bool sgr_locked___7  =    (_Bool)0;
#line 66
static void fail_exit___15(int status ) ;
#line 67
static void usage___26(int status ) ;
#line 68
static void process_flags___20(int argc , char **argv ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpunconv.c"
static void fail_exit___15(int status ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *old_locale ;
  char *tmp___1 ;
  char *saved_locale ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *old_locale___0 ;
  char *tmp___6 ;
  char *saved_locale___0 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
#line 72
  if (gr_locked___7) {
    {
#line 73
    tmp___3 = gr_unlock();
    }
#line 73
    if (tmp___3 == 0) {
      {
#line 74
      tmp = gr_dbname();
#line 74
      tmp___0 = gettext("%s: failed to unlock %s\n");
#line 74
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, tmp);
      }
      {
#line 75
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 75
        tmp___1 = setlocale(6, (char const   *)((void *)0));
#line 75
        old_locale = tmp___1;
#line 75
        saved_locale = (char *)((void *)0);
        }
#line 75
        if ((unsigned long )((void *)0) != (unsigned long )old_locale) {
          {
#line 75
          saved_locale = strdup((char const   *)old_locale);
          }
        }
#line 75
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 75
          setlocale(6, "C");
          }
        }
        {
#line 75
        tmp___2 = gr_dbname();
#line 75
        syslog(3, "failed to unlock %s", tmp___2);
        }
#line 75
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale) {
          {
#line 75
          setlocale(6, (char const   *)saved_locale);
#line 75
          free((void *)saved_locale);
          }
        }
#line 75
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 80
  if (sgr_locked___7) {
    {
#line 81
    tmp___8 = sgr_unlock();
    }
#line 81
    if (tmp___8 == 0) {
      {
#line 82
      tmp___4 = sgr_dbname();
#line 82
      tmp___5 = gettext("%s: failed to unlock %s\n");
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              Prog, tmp___4);
      }
      {
#line 83
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 83
        tmp___6 = setlocale(6, (char const   *)((void *)0));
#line 83
        old_locale___0 = tmp___6;
#line 83
        saved_locale___0 = (char *)((void *)0);
        }
#line 83
        if ((unsigned long )((void *)0) != (unsigned long )old_locale___0) {
          {
#line 83
          saved_locale___0 = strdup((char const   *)old_locale___0);
          }
        }
#line 83
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 83
          setlocale(6, "C");
          }
        }
        {
#line 83
        tmp___7 = sgr_dbname();
#line 83
        syslog(3, "failed to unlock %s", tmp___7);
        }
#line 83
        if ((unsigned long )((void *)0) != (unsigned long )saved_locale___0) {
          {
#line 83
          setlocale(6, (char const   *)saved_locale___0);
#line 83
          free((void *)saved_locale___0);
          }
        }
#line 83
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 88
  exit(status);
  }
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpunconv.c"
static void usage___26(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 93
  if (0 != status) {
#line 93
    tmp = stderr;
  } else {
#line 93
    tmp = stdout;
  }
  {
#line 93
  usageout = tmp;
#line 94
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 94
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 99
  tmp___1 = gettext("  -h, --help                    display this help message and exit\n");
#line 99
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 100
  tmp___2 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 100
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 101
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 102
  exit(status);
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpunconv.c"
static struct option long_options___23[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 110 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/grpunconv.c"
static void process_flags___20(int argc , char **argv ) 
{ 
  int c ;

  {
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    c = getopt_long(argc, (char * const  *)argv, "hR:", (struct option  const  *)(long_options___23),
                    (int *)((void *)0));
    }
#line 122
    if (! (c != -1)) {
#line 122
      goto while_break;
    }
    {
#line 125
    if (c == 104) {
#line 125
      goto case_104;
    }
#line 128
    if (c == 82) {
#line 128
      goto case_82;
    }
#line 130
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 126
    usage___26(0);
    }
#line 127
    goto switch_break;
    case_82: /* CIL Label */ 
#line 129
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 131
    usage___26(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (optind != argc) {
    {
#line 136
    usage___26(2);
    }
  }
#line 138
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___29(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___29  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___29  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___29  ;
#line 72
static int copy_entry___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___29(char const   *filename___0 ) ;
#line 83
static int copy_symlink___29(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___29(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___29(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___29(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___29(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___29(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___29 == (unsigned long )ln) {
    {
#line 149
    links___29 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___29;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___29(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___29)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___29)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___29;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___29);
#line 199
  dst_len = strlen(dst_orig___29);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___29, name___3 + src_len);
#line 207
  lp->ln_next = links___29;
#line 208
  links___29 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___29(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___29(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___29(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___29(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___29(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___29(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___29(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___29(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___29(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___29)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___29)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___29(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___29);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___29, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___29);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___29);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___29);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___29, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___29(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___29(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___29(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___29(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___29(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___29(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___29(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___29(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___29(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___29[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___29[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
#line 43 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___30(char const   *cfgin , char const   *tty , _Bool def ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/console.c"
static _Bool is_listed___30(char const   *cfgin , char const   *tty , _Bool def ) 
{ 
  FILE *fp ;
  char buf___0[200] ;
  char *s ;
  char const   *cons ;
  char *pbuf ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 61
  cons = getdef_str(cfgin);
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )cons) {
#line 63
    return (def);
  }
#line 71
  if ((int const   )*cons != 47) {
    {
#line 73
    strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)cons);
#line 74
    pbuf = & buf___0[0];
    }
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 75
      s = strtok((char */* __restrict  */)pbuf, (char const   */* __restrict  */)":");
      }
#line 75
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
        goto while_break;
      }
      {
#line 76
      tmp = strcmp((char const   *)s, tty);
      }
#line 76
      if (tmp == 0) {
#line 77
        return ((_Bool)1);
      }
#line 80
      pbuf = (char *)((void *)0);
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    return ((_Bool)0);
  }
  {
#line 90
  fp = fopen((char const   */* __restrict  */)cons, (char const   */* __restrict  */)"r");
  }
#line 91
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 92
    return (def);
  }
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 99
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 99
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 99
      goto while_break___0;
    }
    {
#line 100
    tmp___0 = strlen((char const   *)(buf___0));
#line 100
    buf___0[tmp___0 - 1UL] = (char )'\000';
#line 101
    tmp___1 = strcmp((char const   *)(buf___0), tty);
    }
#line 101
    if (tmp___1 == 0) {
      {
#line 102
      fclose(fp);
      }
#line 103
      return ((_Bool)1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  fclose(fp);
  }
#line 112
  return ((_Bool)0);
}
}
#line 173 "../lib/prototypes.h"
extern int getulong(char const   *numstr , unsigned long *result ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static FILE *lastlogfile  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static unsigned long umin___0  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static _Bool has_umin___0  =    (_Bool)0;
#line 64 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static unsigned long umax___0  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static _Bool has_umax___0  =    (_Bool)0;
#line 66 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static time_t seconds___0  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static time_t inverse_seconds  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static struct stat statbuf___0  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static _Bool uflg___3  =    (_Bool)0;
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static _Bool tflg___0  =    (_Bool)0;
#line 73 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static _Bool bflg___0  =    (_Bool)0;
#line 77 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static void usage___27(int status ) 
{ 
  FILE *usageout ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 79
  if (0 != status) {
#line 79
    tmp = stderr;
  } else {
#line 79
    tmp = stdout;
  }
  {
#line 79
  usageout = tmp;
#line 80
  tmp___0 = gettext("Usage: %s [options]\n\nOptions:\n");
#line 80
  fprintf((FILE */* __restrict  */)usageout, (char const   */* __restrict  */)tmp___0,
          Prog);
#line 85
  tmp___1 = gettext("  -b, --before DAYS             print only lastlog records older than DAYS\n");
#line 85
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)usageout);
#line 86
  tmp___2 = gettext("  -h, --help                    display this help message and exit\n");
#line 86
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)usageout);
#line 87
  tmp___3 = gettext("  -R, --root CHROOT_DIR         directory to chroot into\n");
#line 87
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)usageout);
#line 88
  tmp___4 = gettext("  -t, --time DAYS               print only lastlog records more recent than DAYS\n");
#line 88
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)usageout);
#line 89
  tmp___5 = gettext("  -u, --user LOGIN              print lastlog record of the specified LOGIN\n");
#line 89
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)usageout);
#line 90
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)usageout);
#line 91
  exit(status);
  }
}
}
#line 96
static void print_one___0(struct passwd  const  *pw ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static _Bool once___0  =    (_Bool)0;
#line 94 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static void print_one___0(struct passwd  const  *pw ) 
{ 
  char *cp ;
  struct tm *tm ;
  time_t ll_time ;
  off_t offset ;
  struct lastlog ll___0 ;
  char ptime[80] ;
  int err ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  char *tmp___4 ;

  {
#line 107
  if ((unsigned long )((void *)0) == (unsigned long )pw) {
#line 108
    return;
  }
#line 112
  offset = (off_t )((unsigned long )((off_t )pw->pw_uid) * sizeof(ll___0));
#line 113
  if ((unsigned long )offset + sizeof(ll___0) <= (unsigned long )statbuf___0.st_size) {
    {
#line 115
    tmp = fseeko(lastlogfile, offset, 0);
#line 115
    err = tmp;
    }
#line 116
    if (! (0 == err)) {
      {
#line 116
      __assert_fail("0 == err", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c",
                    116U, "print_one");
      }
    }
    {
#line 121
    tmp___1 = fread((void */* __restrict  */)((char *)(& ll___0)), sizeof(ll___0),
                    (size_t )1, (FILE */* __restrict  */)lastlogfile);
    }
#line 121
    if (tmp___1 != 1UL) {
      {
#line 122
      tmp___0 = gettext("%s: Failed to get the entry for UID %lu\n");
#line 122
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              Prog, (unsigned long )pw->pw_uid);
#line 125
      exit(1);
      }
    }
  } else {
    {
#line 133
    memset((void *)(& ll___0), 0, sizeof(ll___0));
    }
  }
#line 137
  if (tflg___0) {
    {
#line 137
    tmp___2 = time((time_t *)0);
    }
#line 137
    if (tmp___2 - (time_t )ll___0.ll_time > seconds___0) {
#line 138
      return;
    }
  }
#line 141
  if (bflg___0) {
    {
#line 141
    tmp___3 = time((time_t *)0);
    }
#line 141
    if (tmp___3 - (time_t )ll___0.ll_time < inverse_seconds) {
#line 142
      return;
    }
  }
#line 146
  if (! once___0) {
    {
#line 148
    tmp___4 = gettext("Username         Port     From             Latest");
#line 148
    puts((char const   *)tmp___4);
#line 152
    once___0 = (_Bool)1;
    }
  }
  {
#line 155
  ll_time = (time_t )ll___0.ll_time;
#line 156
  tm = localtime((time_t const   *)(& ll_time));
#line 158
  strftime((char */* __restrict  */)(ptime), sizeof(ptime), (char const   */* __restrict  */)"%a %b %e %H:%M:%S %z %Y",
           (struct tm  const  */* __restrict  */)tm);
#line 159
  cp = ptime;
  }
#line 165
  if ((time_t )ll___0.ll_time == 0L) {
    {
#line 166
    cp = gettext("**Never logged in**\000");
    }
  }
  {
#line 170
  printf((char const   */* __restrict  */)"%-16s %-8.8s %-16.16s %s\n", pw->pw_name,
         ll___0.ll_line, ll___0.ll_host, cp);
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static void print___0(void) 
{ 
  struct passwd  const  *pwent___0 ;
  struct passwd *tmp ;
  struct passwd *tmp___0 ;

  {
#line 181
  if (uflg___3) {
#line 181
    if (has_umin___0) {
#line 181
      if (has_umax___0) {
#line 181
        if (umin___0 == umax___0) {
          {
#line 182
          tmp = getpwuid((uid_t )umin___0);
#line 182
          print_one___0((struct passwd  const  *)tmp);
          }
        } else {
#line 181
          goto _L___2;
        }
      } else {
#line 181
        goto _L___2;
      }
    } else {
#line 181
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 184
    setpwent();
    }
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 185
      tmp___0 = getpwent();
#line 185
      pwent___0 = (struct passwd  const  *)tmp___0;
      }
#line 185
      if (! ((unsigned long )pwent___0 != (unsigned long )((void *)0))) {
#line 185
        goto while_break;
      }
#line 186
      if (uflg___3) {
#line 186
        if (has_umin___0) {
#line 186
          if (pwent___0->pw_uid < (__uid_t const   )((uid_t )umin___0)) {
#line 189
            goto while_continue;
          } else {
#line 186
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 186
        if (has_umax___0) {
#line 186
          if (pwent___0->pw_uid > (__uid_t const   )((uid_t )umax___0)) {
#line 189
            goto while_continue;
          }
        }
      }
      {
#line 191
      print_one___0(pwent___0);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 193
    endpwent();
    }
  }
#line 195
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/src/lastlog.c"
static struct option  const  longopts[6]  = {      {"before", 1, (int *)((void *)0), 'b'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"root", 1, (int *)((void *)0), 'R'}, 
        {"time", 1, (int *)((void *)0), 't'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 44 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static cleanup_function cleanup_functions___30[10]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static parg_t cleanup_function_args___30[10]  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/cleanup.c"
static pid_t cleanup_pid___30  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___29(char *s ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **members___29  =    (char **)0;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static int size___57  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char **list___29(char *s ) 
{ 
  int i ;
  char **rbuf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 65
  i = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (i >= size___57) {
#line 70
      size___57 = i + 100;
#line 71
      if (members___29) {
        {
#line 72
        tmp = realloc((void *)members___29, (unsigned long )size___57 * sizeof(char *));
#line 72
        rbuf = (char **)tmp;
        }
      } else {
        {
#line 77
        tmp___0 = malloc((unsigned long )size___57 * sizeof(char *));
#line 77
        rbuf = (char **)tmp___0;
        }
      }
#line 79
      if (! rbuf) {
#line 80
        if (members___29) {
          {
#line 81
          free((void *)members___29);
          }
        }
#line 82
        members___29 = (char **)0;
#line 83
        size___57 = 0;
#line 84
        return ((char **)0);
      }
#line 86
      members___29 = rbuf;
    }
#line 88
    if (! s) {
#line 89
      goto while_break;
    } else
#line 88
    if ((int )*(s + 0) == 0) {
#line 89
      goto while_break;
    }
#line 90
    tmp___1 = i;
#line 90
    i ++;
#line 90
    *(members___29 + tmp___1) = s;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (0 != (int )*s) {
#line 91
        if (! (44 != (int )*s)) {
#line 91
          goto while_break___0;
        }
      } else {
#line 91
        goto while_break___0;
      }
#line 92
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (0 != (int )*s) {
#line 95
      tmp___2 = s;
#line 95
      s ++;
#line 95
      *tmp___2 = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  *(members___29 + i) = (char *)0;
#line 99
  return (members___29);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpbuf___28  =    (char *)0;
#line 106 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static size_t size___58  =    (size_t )0;
#line 107 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static char *grpfields___28[4]  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/lib/sgetgrent.c"
static struct group grent___28  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/chkname.c"
static _Bool is_valid_name___30(char const   *name___3 ) 
{ 


  {
#line 54
  if (0 == (int )*name___3) {
#line 56
    return ((_Bool)0);
  } else
#line 54
  if (97 <= (int )*name___3) {
#line 54
    if (! (122 >= (int )*name___3)) {
#line 54
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (! (95 == (int )*name___3)) {
#line 56
    return ((_Bool)0);
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    name___3 ++;
#line 59
    if (! (0 != (int )*name___3)) {
#line 59
      goto while_break;
    }
#line 60
    if (97 <= (int )*name___3) {
#line 60
      if (! (122 >= (int )*name___3)) {
#line 60
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (48 <= (int )*name___3) {
#line 60
      if (! (57 >= (int )*name___3)) {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 60
    if (! (95 == (int )*name___3)) {
#line 60
      if (! (45 == (int )*name___3)) {
#line 60
        if (36 == (int )*name___3) {
#line 60
          if (! (0 == (int )*(name___3 + 1))) {
#line 66
            return ((_Bool)0);
          }
        } else {
#line 66
          return ((_Bool)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((_Bool)1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/failure.c"
static _Bool too_many_failures___30(struct faillog  const  *fl ) 
{ 
  time_t now ;

  {
#line 125
  if (0 == (int )fl->fail_max) {
#line 126
    return ((_Bool)0);
  } else
#line 125
  if ((int const   )fl->fail_cnt < (int const   )fl->fail_max) {
#line 126
    return ((_Bool)0);
  }
#line 129
  if (0L == fl->fail_locktime) {
#line 130
    return ((_Bool)1);
  }
  {
#line 133
  time(& now);
  }
#line 134
  if (fl->fail_time + fl->fail_locktime < (time_t const   )now) {
#line 135
    return ((_Bool)0);
  }
#line 138
  return ((_Bool)1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *src_orig___30  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char const   *dst_orig___30  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *links___30  ;
#line 72
static int copy_entry___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 76
static int copy_dir___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 82
static char *readlink_malloc___30(char const   *filename___0 ) ;
#line 83
static int copy_symlink___30(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 89
static int copy_hardlink___30(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) ;
#line 92
static int copy_special___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 97
static int copy_file___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 102
static int chown_if_needed___30(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 105
static int lchown_if_needed___30(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 108
static int fchown_if_needed___30(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static void remove_link___30(struct link_name *ln ) 
{ 
  struct link_name *lp ;

  {
#line 148
  if ((unsigned long )links___30 == (unsigned long )ln) {
    {
#line 149
    links___30 = ln->ln_next;
#line 150
    free((void *)ln->ln_name);
#line 151
    free((void *)ln);
    }
#line 152
    return;
  }
#line 154
  lp = links___30;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )lp->ln_next == (unsigned long )ln) {
#line 156
      goto while_break;
    }
#line 154
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if ((unsigned long )((void *)0) == (unsigned long )lp) {
    {
#line 161
    free((void *)ln->ln_name);
#line 162
    free((void *)ln);
    }
#line 163
    return;
  }
  {
#line 166
  lp->ln_next = (lp->ln_next)->ln_next;
#line 167
  free((void *)ln->ln_name);
#line 168
  free((void *)ln);
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static struct link_name *check_link___30(char const   *name___3 , struct stat  const  *sb ) 
{ 
  struct link_name *lp ;
  size_t src_len ;
  size_t dst_len ;
  size_t name_len ;
  size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 184
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___30)) {
    {
#line 184
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  184U, "check_link");
    }
  }
#line 185
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___30)) {
    {
#line 185
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  185U, "check_link");
    }
  }
#line 187
  lp = links___30;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )((void *)0) != (unsigned long )lp)) {
#line 187
      goto while_break;
    }
#line 188
    if (lp->ln_dev == (dev_t )sb->st_dev) {
#line 188
      if (lp->ln_ino == (ino_t )sb->st_ino) {
#line 189
        return (lp);
      }
    }
#line 187
    lp = lp->ln_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (sb->st_nlink == 1UL) {
#line 194
    return ((struct link_name *)((void *)0));
  }
  {
#line 197
  tmp = xmalloc(sizeof(*lp));
#line 197
  lp = (struct link_name *)tmp;
#line 198
  src_len = strlen(src_orig___30);
#line 199
  dst_len = strlen(dst_orig___30);
#line 200
  name_len = strlen(name___3);
#line 201
  lp->ln_dev = (dev_t )sb->st_dev;
#line 202
  lp->ln_ino = (ino_t )sb->st_ino;
#line 203
  lp->ln_count = (nlink_t )sb->st_nlink;
#line 204
  len = ((name_len - src_len) + dst_len) + 1UL;
#line 205
  tmp___0 = xmalloc(len);
#line 205
  lp->ln_name = tmp___0;
#line 206
  snprintf((char */* __restrict  */)lp->ln_name, len, (char const   */* __restrict  */)"%s%s",
           dst_orig___30, name___3 + src_len);
#line 207
  lp->ln_next = links___30;
#line 208
  links___30 = lp;
  }
#line 210
  return ((struct link_name *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_entry___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                           uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  struct stat sb ;
  struct link_name *lp ;
  struct timeval mt[2] ;
  int tmp ;

  {
  {
#line 382
  err = 0;
#line 387
  tmp = lstat((char const   */* __restrict  */)src, (struct stat */* __restrict  */)(& sb));
  }
#line 387
  if (! (tmp == -1)) {
#line 391
    mt[0].tv_sec = sb.st_atim.tv_sec;
#line 392
    mt[0].tv_usec = sb.st_atim.tv_nsec / 1000L;
#line 403
    mt[1].tv_sec = sb.st_mtim.tv_sec;
#line 404
    mt[1].tv_usec = sb.st_mtim.tv_nsec / 1000L;
#line 414
    if ((sb.st_mode & 61440U) == 16384U) {
      {
#line 415
      err = copy_dir___30(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                          (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                          new_gid);
      }
    } else
#line 424
    if ((sb.st_mode & 61440U) == 40960U) {
      {
#line 425
      err = copy_symlink___30(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                              (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                              new_gid);
      }
    } else {
      {
#line 434
      lp = check_link___30(src, (struct stat  const  *)(& sb));
      }
#line 434
      if ((unsigned long )lp != (unsigned long )((void *)0)) {
        {
#line 435
        err = copy_hardlink___30(dst, reset_selinux, lp);
        }
      } else
#line 444
      if (! ((sb.st_mode & 61440U) == 32768U)) {
        {
#line 445
        err = copy_special___30(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                                (struct timeval  const  *)(mt), old_uid, new_uid,
                                old_gid, new_gid);
        }
      } else {
        {
#line 455
        err = copy_file___30(src, dst, reset_selinux, (struct stat  const  *)(& sb),
                             (struct timeval  const  *)(mt), old_uid, new_uid, old_gid,
                             new_gid);
        }
      }
    }
  }
#line 460
  return (err);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_dir___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                         struct stat  const  *statp , struct timeval  const  *mt ,
                         uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 479
  err = 0;
#line 491
  tmp = mkdir(dst, (__mode_t )statp->st_mode);
  }
#line 491
  if (tmp != 0) {
#line 515
    err = -1;
  } else {
    {
#line 491
    tmp___0 = chown_if_needed___30(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 491
    if (tmp___0 != 0) {
#line 515
      err = -1;
    } else {
      {
#line 491
      tmp___1 = chmod(dst, (__mode_t )statp->st_mode);
      }
#line 491
      if (tmp___1 != 0) {
#line 515
        err = -1;
      } else {
        {
#line 491
        tmp___2 = copy_tree(src, dst, (_Bool)0, reset_selinux, old_uid, new_uid, old_gid,
                            new_gid);
        }
#line 491
        if (tmp___2 != 0) {
#line 515
          err = -1;
        } else {
          {
#line 491
          tmp___3 = utimes(dst, (struct timeval  const  *)mt);
          }
#line 491
          if (tmp___3 != 0) {
#line 515
            err = -1;
          }
        }
      }
    }
  }
#line 518
  return (err);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static char *readlink_malloc___30(char const   *filename___0 ) 
{ 
  size_t size___59 ;
  ssize_t nchars ;
  char *buffer ;
  void *tmp ;

  {
#line 530
  size___59 = (size_t )1024;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    tmp = malloc(size___59);
#line 534
    buffer = (char *)tmp;
    }
#line 535
    if ((unsigned long )((void *)0) == (unsigned long )buffer) {
#line 536
      return ((char *)((void *)0));
    }
    {
#line 539
    nchars = readlink((char const   */* __restrict  */)filename___0, (char */* __restrict  */)buffer,
                      size___59);
    }
#line 541
    if (nchars < 0L) {
      {
#line 542
      free((void *)buffer);
      }
#line 543
      return ((char *)((void *)0));
    }
#line 546
    if ((size_t )nchars < size___59) {
#line 548
      *(buffer + nchars) = (char )'\000';
#line 549
      return (buffer);
    }
    {
#line 553
    free((void *)buffer);
#line 554
    size___59 *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_symlink___30(char const   *src , char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  char *oldlink ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *dummy ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 577
  if (! ((unsigned long )((void *)0) != (unsigned long )src_orig___30)) {
    {
#line 577
    __assert_fail("((void *)0) != src_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  577U, "copy_symlink");
    }
  }
#line 578
  if (! ((unsigned long )((void *)0) != (unsigned long )dst_orig___30)) {
    {
#line 578
    __assert_fail("((void *)0) != dst_orig", "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c",
                  578U, "copy_symlink");
    }
  }
  {
#line 588
  oldlink = readlink_malloc___30(src);
  }
#line 589
  if ((unsigned long )((void *)0) == (unsigned long )oldlink) {
#line 590
    return (-1);
  }
  {
#line 597
  tmp___4 = strlen(src_orig___30);
#line 597
  tmp___5 = strncmp((char const   *)oldlink, src_orig___30, tmp___4);
  }
#line 597
  if (tmp___5 == 0) {
    {
#line 598
    tmp = strlen(dst_orig___30);
#line 598
    tmp___0 = strlen((char const   *)oldlink);
#line 598
    tmp___1 = strlen(src_orig___30);
#line 598
    len = ((tmp + tmp___0) - tmp___1) + 1UL;
#line 599
    tmp___2 = xmalloc(len);
#line 599
    dummy = tmp___2;
#line 600
    tmp___3 = strlen(src_orig___30);
#line 600
    snprintf((char */* __restrict  */)dummy, len, (char const   */* __restrict  */)"%s%s",
             dst_orig___30, oldlink + tmp___3);
#line 603
    free((void *)oldlink);
#line 604
    oldlink = dummy;
    }
  }
  {
#line 613
  tmp___6 = symlink((char const   *)oldlink, dst);
  }
#line 613
  if (tmp___6 != 0) {
    {
#line 623
    free((void *)oldlink);
    }
#line 624
    return (-1);
  } else {
    {
#line 613
    tmp___7 = lchown_if_needed___30(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 613
    if (tmp___7 != 0) {
      {
#line 623
      free((void *)oldlink);
      }
#line 624
      return (-1);
    }
  }
  {
#line 626
  free((void *)oldlink);
#line 634
  lutimes(dst, (struct timeval  const  *)mt);
  }
#line 637
  return (0);
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_hardlink___30(char const   *dst , _Bool reset_selinux  __attribute__((__unused__)) ,
                              struct link_name *lp ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = link((char const   *)lp->ln_name, dst);
  }
#line 654
  if (tmp != 0) {
#line 655
    return (-1);
  }
#line 660
  (lp->ln_count) --;
#line 661
  if (lp->ln_count <= 0UL) {
    {
#line 662
    remove_link___30(lp);
    }
  }
#line 665
  return (0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_special___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                             struct stat  const  *statp , struct timeval  const  *mt ,
                             uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 684
  err = 0;
#line 692
  tmp = mknod(dst, (__mode_t )(statp->st_mode & 4294963200U), (__dev_t )statp->st_rdev);
  }
#line 692
  if (tmp != 0) {
#line 714
    err = -1;
  } else {
    {
#line 692
    tmp___0 = chown_if_needed___30(dst, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 692
    if (tmp___0 != 0) {
#line 714
      err = -1;
    } else {
      {
#line 692
      tmp___1 = chmod(dst, (__mode_t )(statp->st_mode & 4095U));
      }
#line 692
      if (tmp___1 != 0) {
#line 714
        err = -1;
      } else {
        {
#line 692
        tmp___2 = utimes(dst, (struct timeval  const  *)mt);
        }
#line 692
        if (tmp___2 != 0) {
#line 714
          err = -1;
        }
      }
    }
  }
#line 717
  return (err);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int copy_file___30(char const   *src , char const   *dst , _Bool reset_selinux ,
                          struct stat  const  *statp , struct timeval  const  *mt ,
                          uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  int err ;
  int ifd ;
  int ofd ;
  char buf___0[1024] ;
  ssize_t cnt ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 736
  err = 0;
#line 742
  ifd = open(src, 0);
  }
#line 743
  if (ifd < 0) {
#line 744
    return (-1);
  }
  {
#line 751
  ofd = open(dst, 577, statp->st_mode & 4095U);
  }
#line 752
  if (ofd < 0) {
    {
#line 774
    close(ifd);
    }
#line 775
    return (-1);
  } else {
    {
#line 752
    tmp = fchown_if_needed___30(ofd, statp, old_uid, new_uid, old_gid, new_gid);
    }
#line 752
    if (tmp != 0) {
      {
#line 774
      close(ifd);
      }
#line 775
      return (-1);
    } else {
      {
#line 752
      tmp___0 = fchmod(ofd, (__mode_t )(statp->st_mode & 4095U));
      }
#line 752
      if (tmp___0 != 0) {
        {
#line 774
        close(ifd);
        }
#line 775
        return (-1);
      }
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    cnt = read(ifd, (void *)(buf___0), sizeof(buf___0));
    }
#line 778
    if (! (cnt > 0L)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp___1 = write(ofd, (void const   *)(buf___0), (size_t )cnt);
    }
#line 779
    if (tmp___1 != cnt) {
      {
#line 780
      close(ifd);
      }
#line 781
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 785
  close(ifd);
#line 788
  tmp___2 = futimes(ofd, (struct timeval  const  *)mt);
  }
#line 788
  if (tmp___2 != 0) {
#line 789
    return (-1);
  }
  {
#line 793
  tmp___3 = close(ofd);
  }
#line 793
  if (tmp___3 != 0) {
#line 794
    return (-1);
  }
#line 803
  return (err);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int chown_if_needed___30(char const   *dst , struct stat  const  *statp , uid_t old_uid ,
                                uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 836
  tmpuid = (uid_t )-1;
#line 836
  tmpgid = (gid_t )-1;
#line 836
  if (4294967295U == old_uid) {
#line 836
    tmpuid = new_uid;
  } else
#line 836
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 836
    tmpuid = new_uid;
  }
#line 836
  if (4294967295U == tmpuid) {
#line 836
    tmpuid = (uid_t )statp->st_uid;
  }
#line 836
  if (4294967295U == old_gid) {
#line 836
    tmpgid = new_gid;
  } else
#line 836
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 836
    tmpgid = new_gid;
  }
#line 836
  if (4294967295U == tmpgid) {
#line 836
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 836
  tmp = chown(dst, tmpuid, tmpgid);
  }
#line 836
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int lchown_if_needed___30(char const   *dst , struct stat  const  *statp ,
                                 uid_t old_uid , uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 837
  tmpuid = (uid_t )-1;
#line 837
  tmpgid = (gid_t )-1;
#line 837
  if (4294967295U == old_uid) {
#line 837
    tmpuid = new_uid;
  } else
#line 837
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 837
    tmpuid = new_uid;
  }
#line 837
  if (4294967295U == tmpuid) {
#line 837
    tmpuid = (uid_t )statp->st_uid;
  }
#line 837
  if (4294967295U == old_gid) {
#line 837
    tmpgid = new_gid;
  } else
#line 837
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 837
    tmpgid = new_gid;
  }
#line 837
  if (4294967295U == tmpgid) {
#line 837
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 837
  tmp = lchown(dst, tmpuid, tmpgid);
  }
#line 837
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/copydir.c"
static int fchown_if_needed___30(int dst , struct stat  const  *statp , uid_t old_uid ,
                                 uid_t new_uid , gid_t old_gid , gid_t new_gid ) 
{ 
  uid_t tmpuid ;
  gid_t tmpgid ;
  int tmp ;

  {
#line 838
  tmpuid = (uid_t )-1;
#line 838
  tmpgid = (gid_t )-1;
#line 838
  if (4294967295U == old_uid) {
#line 838
    tmpuid = new_uid;
  } else
#line 838
  if (statp->st_uid == (__uid_t const   )old_uid) {
#line 838
    tmpuid = new_uid;
  }
#line 838
  if (4294967295U == tmpuid) {
#line 838
    tmpuid = (uid_t )statp->st_uid;
  }
#line 838
  if (4294967295U == old_gid) {
#line 838
    tmpgid = new_gid;
  } else
#line 838
  if (statp->st_gid == (__gid_t const   )old_gid) {
#line 838
    tmpgid = new_gid;
  }
#line 838
  if (4294967295U == tmpgid) {
#line 838
    tmpgid = (gid_t )statp->st_gid;
  }
  {
#line 838
  tmp = fchown(dst, tmpuid, tmpgid);
  }
#line 838
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *forbid___30[14]  = 
#line 53 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
  {      "_RLD_=",      "BASH_ENV=",      "ENV=",      "HOME=", 
        "IFS=",      "KRB_CONF=",      "LD_",      "LIBPATH=", 
        "MAIL=",      "NLSPATH=",      "PATH=",      "SHELL=", 
        "SHLIB_PATH=",      (char const   *)((char *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/shadow-4.1.5.1/libmisc/env.c"
static char const   *noslash___30[4]  = {      "LANG=",      "LANGUAGE=",      "LC_",      (char const   *)((char *)0)};
