/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 36 "/home/june/collector/temp/bosh-0.6/stray.h"
struct __anonstruct_stray_t_25 {
   int c ;
   char **v ;
};
#line 36 "/home/june/collector/temp/bosh-0.6/stray.h"
typedef struct __anonstruct_stray_t_25 stray_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_26 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_26 regmatch_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/home/june/collector/temp/bosh-0.6/list.h"
struct node {
   void *data ;
   int size ;
   struct node *next ;
};
#line 37 "/home/june/collector/temp/bosh-0.6/list.h"
struct list {
   struct node *root ;
   struct node *last ;
   struct node *next ;
   struct node *iter ;
   int items ;
};
#line 42 "/home/june/collector/temp/bosh-0.6/list.h"
typedef struct list LIST;
#line 103 "/home/june/collector/temp/bosh-0.6/bosh.h"
struct bosh_action_t {
   int dest ;
   char *command ;
   char *prompt ;
};
#line 103 "/home/june/collector/temp/bosh-0.6/bosh.h"
typedef struct bosh_action_t ACTION;
#line 111 "/home/june/collector/temp/bosh-0.6/bosh.h"
struct __anonstruct_bosh_t_55 {
   char *command ;
   char *common ;
   int exit ;
   int childin ;
   int childout ;
   int childerr ;
   pid_t childpid ;
   char tmpfscript[18] ;
   char tmpfpipe[18] ;
   LIST *buf ;
   int width ;
   int offset ;
   int cursor ;
   int line ;
   char *pipe ;
   char *title ;
   int autorefresh ;
   int cursorsize ;
   int cursormovement ;
   char *multilineseperator ;
   char *preaction ;
   int refresh ;
   int searchwrap ;
   int header ;
   int footer ;
   ACTION action[37] ;
};
#line 111 "/home/june/collector/temp/bosh-0.6/bosh.h"
typedef struct __anonstruct_bosh_t_55 bosh_t;
#line 222 "/home/june/collector/temp/bosh-0.6/system.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 221 "/home/june/collector/temp/bosh-0.6/system.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 592 "/home/june/collector/temp/bosh-0.6/system.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 597 "/home/june/collector/temp/bosh-0.6/system.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 596 "/home/june/collector/temp/bosh-0.6/system.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 591 "/home/june/collector/temp/bosh-0.6/system.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 151 "/usr/include/curses.h"
typedef unsigned long mmask_t;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 1597 "/usr/include/curses.h"
struct __anonstruct_MEVENT_6 {
   short id ;
   int x ;
   int y ;
   int z ;
   mmask_t bstate ;
};
#line 1597 "/usr/include/curses.h"
typedef struct __anonstruct_MEVENT_6 MEVENT;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 41 "/home/june/collector/temp/bosh-0.6/stray.h"
stray_t *stray_new(int c , char **v ) ;
#line 42
stray_t *stray_new_d(int c , char **v ) ;
#line 44
stray_t *stray_dup(stray_t *a ) ;
#line 46
void stray_debug(stray_t *a , FILE *stream ) ;
#line 48
void stray_addstr(stray_t *a , char *s ) ;
#line 49
void stray_addstr_d(stray_t *a , char const   *s ) ;
#line 51
void stray_addarr(stray_t *a , stray_t *b ) ;
#line 52
void stray_addarr_d(stray_t *a , stray_t *b ) ;
#line 54
void stray_clr(stray_t *a ) ;
#line 55
void stray_free(stray_t *a ) ;
#line 57
char *stray_get(stray_t *a , uint32_t ind ) ;
#line 58
void stray_del(stray_t *a , uint32_t ind ) ;
#line 32 "/home/june/collector/temp/bosh-0.6/stray.c"
static void stray_realloc(stray_t *a , int e ) 
{ 
  void *tmp ;

  {
  {
#line 33
  tmp = realloc((void *)a->v, (unsigned long )(a->c + 2) * sizeof(char *));
#line 33
  a->v = (char **)tmp;
  }
#line 34
  return;
}
}
#line 36 "/home/june/collector/temp/bosh-0.6/stray.c"
stray_t *stray_new(int c , char **v ) 
{ 
  stray_t *r ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 37
  tmp = malloc(sizeof(stray_t ));
#line 37
  r = (stray_t *)tmp;
  }
#line 38
  if (r) {
#line 39
    if (c) {
#line 40
      r->c = c;
#line 41
      r->v = v;
    } else
#line 39
    if (v) {
#line 40
      r->c = c;
#line 41
      r->v = v;
    } else {
      {
#line 43
      r->c = 0;
#line 44
      tmp___0 = malloc(sizeof(char *));
#line 44
      r->v = (char **)tmp___0;
#line 45
      *(r->v + 0) = (char *)((void *)0);
      }
    }
  }
#line 48
  return (r);
}
}
#line 51 "/home/june/collector/temp/bosh-0.6/stray.c"
stray_t *stray_new_d(int c , char **v ) 
{ 
  stray_t *r ;
  stray_t *a ;
  stray_t *tmp ;

  {
  {
#line 52
  r = (stray_t *)((void *)0);
#line 52
  tmp = stray_new(c, v);
#line 52
  a = tmp;
  }
#line 53
  if (a) {
    {
#line 54
    r = stray_dup(a);
#line 55
    free((void *)a);
    }
  }
#line 57
  return (r);
}
}
#line 60 "/home/june/collector/temp/bosh-0.6/stray.c"
stray_t *stray_dup(stray_t *a ) 
{ 
  int i ;
  stray_t *r ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 62
  tmp = malloc(sizeof(stray_t ));
#line 62
  r = (stray_t *)tmp;
#line 63
  r->c = a->c;
#line 64
  tmp___0 = malloc(sizeof(char *) * (unsigned long )r->c + 1UL);
#line 64
  r->v = (char **)tmp___0;
#line 65
  i = 0;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i <= r->c)) {
#line 65
      goto while_break;
    }
#line 66
    if (*(a->v + i)) {
      {
#line 66
      tmp___1 = strdup((char const   *)*(a->v + i));
#line 66
      *(r->v + i) = tmp___1;
      }
    } else {
#line 66
      *(r->v + i) = (char *)((void *)0);
    }
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (r);
}
}
#line 70 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_free(stray_t *a ) 
{ 


  {
#line 72
  return;
}
}
#line 74 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_clr(stray_t *a ) 
{ 
  void *tmp ;

  {
  {
#line 75
  stray_free(a);
#line 76
  a->c = 0;
#line 77
  tmp = malloc(sizeof(char *));
#line 77
  a->v = (char **)tmp;
#line 78
  *(a->v + 0) = (char *)((void *)0);
  }
#line 79
  return;
}
}
#line 81 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_debug(stray_t *a , FILE *stream ) 
{ 
  int i ;
  char const   *tmp ;

  {
  {
#line 83
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"== ->c: %d\n",
          a->c);
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i <= a->c)) {
#line 84
      goto while_break;
    }
#line 85
    if (*(a->v + i)) {
#line 85
      tmp = (char const   *)*(a->v + i);
    } else {
#line 85
      tmp = "NULL";
    }
    {
#line 85
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"== ->v[%02d]: [%08X] %s\n",
            i, (unsigned int )*(a->v + i), tmp);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_addstr(stray_t *a , char *s ) 
{ 


  {
  {
#line 90
  stray_realloc(a, 2);
  }
#line 91
  if (a->v) {
#line 92
    *(a->v + a->c) = s;
#line 93
    (a->c) ++;
#line 94
    *(a->v + a->c) = (char *)((void *)0);
  }
#line 96
  return;
}
}
#line 98 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_addstr_d(stray_t *a , char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 99
  tmp = strdup(s);
#line 99
  stray_addstr(a, tmp);
  }
#line 100
  return;
}
}
#line 102 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_addarr(stray_t *a , stray_t *b ) 
{ 
  char **p ;

  {
  {
#line 103
  stray_realloc(a, b->c);
  }
#line 104
  if (a->v) {
#line 105
    p = b->v;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 106
      if (! *p) {
#line 106
        goto while_break;
      }
      {
#line 107
      stray_addstr(a, *p);
#line 108
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 111
  return;
}
}
#line 113 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_addarr_d(stray_t *a , stray_t *b ) 
{ 
  char **p ;

  {
  {
#line 114
  stray_realloc(a, b->c);
  }
#line 115
  if (a->v) {
#line 116
    p = b->v;
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! *p) {
#line 117
        goto while_break;
      }
      {
#line 118
      stray_addstr_d(a, (char const   *)*p);
#line 119
      p ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/collector/temp/bosh-0.6/stray.c"
char *stray_get(stray_t *a , uint32_t ind ) 
{ 


  {
#line 125
  return (*(a->v + ind));
}
}
#line 128 "/home/june/collector/temp/bosh-0.6/stray.c"
void stray_del(stray_t *a , uint32_t ind ) 
{ 
  char **p ;

  {
#line 129
  p = a->v + ind;
#line 130
  if (ind <= (uint32_t )a->c) {
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 131
      if (! *p) {
#line 131
        goto while_break;
      }
#line 132
      *(p + 0) = *(p + 1);
#line 133
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 135
    if (a->c) {
#line 136
      (a->c) --;
    }
  }
#line 138
  return;
}
}
#line 142 "/home/june/collector/temp/bosh-0.6/stray.c"
stray_t *stray_cut(stray_t *a ) 
{ 


  {
#line 143
  return ((stray_t *)((void *)0));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 41 "/home/june/collector/temp/bosh-0.6/misc.h"
char *strdup2(char const   *s1 , char const   *s2 ) ;
#line 42
char *strmak(size_t len , int c ) ;
#line 43
char *strswp(char *s , int c , int replace ) ;
#line 45
char *getopt_mkoptstring(struct option *longopts ) ;
#line 48
void bosh_fatal_err(int code , char *format  , ...) ;
#line 49
void bosh_fprintfl(FILE *stream , char *logprefix , char const   *format  , ...) ;
#line 57
int bosh_regex_init(char *s ) ;
#line 58
int bosh_regex_try(char *s ) ;
#line 36 "/home/june/collector/temp/bosh-0.6/misc.c"
char *strdup2(char const   *s1 , char const   *s2 ) 
{ 
  char *r ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 38
  tmp = strlen(s1);
#line 38
  tmp___0 = strlen(s2);
#line 38
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 38
  r = (char *)tmp___1;
  }
#line 39
  if (r) {
    {
#line 40
    sprintf((char */* __restrict  */)r, (char const   */* __restrict  */)"%s%s", s1,
            s2);
    }
  }
#line 42
  return (r);
}
}
#line 47 "/home/june/collector/temp/bosh-0.6/misc.c"
static char *buf  =    (char *)((void *)0);
#line 46 "/home/june/collector/temp/bosh-0.6/misc.c"
char *strmak(size_t len , int c ) 
{ 
  void *tmp ;

  {
  {
#line 48
  free((void *)buf);
#line 49
  tmp = malloc(len + 1UL);
#line 49
  buf = (char *)tmp;
  }
#line 50
  if (buf) {
    {
#line 51
    memset((void *)buf, c, len);
#line 52
    *(buf + len) = (char)0;
    }
  }
#line 54
  return (buf);
}
}
#line 57 "/home/june/collector/temp/bosh-0.6/misc.c"
char *strswp(char *s , int c , int replace ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 58
  tmp = strchr((char const   *)s, c);
#line 58
  p = tmp;
  }
#line 59
  if (p) {
#line 60
    *p = (char )replace;
  }
#line 61
  return (p);
}
}
#line 66 "/home/june/collector/temp/bosh-0.6/misc.c"
char *getopt_mkoptstring(struct option *longopts ) 
{ 
  int n ;
  char *optstring ;
  char *p ;
  struct option *o ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 68
  n = 0;
#line 70
  o = longopts;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! o->name) {
#line 72
      if (! o->has_arg) {
#line 72
        if (! o->flag) {
#line 72
          if (! o->val) {
#line 72
            goto while_break;
          }
        }
      }
    }
#line 73
    n += 1 + o->has_arg;
#line 74
    if (o->flag) {
#line 75
      return ((char *)((void *)0));
    }
#line 76
    o ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  tmp = malloc((size_t )(n + 1));
#line 79
  optstring = (char *)tmp;
#line 79
  p = optstring;
#line 80
  o = longopts;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! o->name) {
#line 82
      if (! o->has_arg) {
#line 82
        if (! o->flag) {
#line 82
          if (! o->val) {
#line 82
            goto while_break___0;
          }
        }
      }
    }
#line 83
    tmp___0 = p;
#line 83
    p ++;
#line 83
    *tmp___0 = (char )o->val;
#line 84
    n = o->has_arg;
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      tmp___2 = n;
#line 85
      n --;
#line 85
      if (! tmp___2) {
#line 85
        goto while_break___1;
      }
#line 86
      tmp___1 = p;
#line 86
      p ++;
#line 86
      *tmp___1 = (char )':';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 87
    o ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 89
  *p = (char)0;
#line 91
  return (optstring);
}
}
#line 96 "/home/june/collector/temp/bosh-0.6/misc.c"
void bosh_fatal_err(int code , char *format  , ...) 
{ 
  va_list v ;

  {
  {
#line 106
  __builtin_va_start(v, format);
#line 107
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           v);
#line 108
  __builtin_va_end(v);
#line 110
  exit(code);
  }
}
}
#line 114 "/home/june/collector/temp/bosh-0.6/misc.c"
void bosh_fprintfl(FILE *stream , char *logprefix , char const   *format  , ...) 
{ 
  va_list v ;

  {
  {
#line 124
  __builtin_va_start(v, format);
#line 125
  vfprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
           v);
#line 126
  __builtin_va_end(v);
  }
#line 128
  return;
}
}
#line 165 "/home/june/collector/temp/bosh-0.6/misc.c"
regex_t *bosh_regex  =    (regex_t *)((void *)0);
#line 167 "/home/june/collector/temp/bosh-0.6/misc.c"
int bosh_regex_init(char *s ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 168
  free((void *)bosh_regex);
#line 169
  tmp = malloc(sizeof(regex_t ));
#line 169
  bosh_regex = (regex_t *)tmp;
#line 170
  tmp___0 = regcomp((regex_t */* __restrict  */)bosh_regex, (char const   */* __restrict  */)s,
                    (1 | (1 << 1)) | (((1 << 1) << 1) << 1));
  }
#line 170
  return (tmp___0);
}
}
#line 173 "/home/june/collector/temp/bosh-0.6/misc.c"
int bosh_regex_try(char *s ) 
{ 
  int tmp ;

  {
  {
#line 174
  tmp = regexec((regex_t const   */* __restrict  */)bosh_regex, (char const   */* __restrict  */)s,
                (size_t )0, (regmatch_t */* __restrict  */)0, 0);
  }
#line 174
  return (tmp);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 611 "/usr/include/curses.h"
extern int endwin(void) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 46 "/home/june/collector/temp/bosh-0.6/list.h"
int list_reinit(struct list *l ) ;
#line 47
int list_add(struct list *l , void *data ) ;
#line 48
int list_adddup(struct list *l , void *data , int size ) ;
#line 51
int list_del(struct list *l , int index___0 ) ;
#line 52
void *list_get(struct list *l , int index___0 ) ;
#line 54
int list_items(struct list *l ) ;
#line 56
int list_start(struct list *l , int index___0 ) ;
#line 57
void *list_next(struct list *l ) ;
#line 151 "/home/june/collector/temp/bosh-0.6/bosh.h"
bosh_t *bosh_t_new(void) ;
#line 152
int bosh_t_free(bosh_t *b ) ;
#line 157
LIST *boshlist ;
#line 158
int boshlistpos ;
#line 159
char *conf ;
#line 160
char *confpath ;
#line 167
char *BOSH ;
#line 168
char *BOSHPARAM ;
#line 169
char BOSHVARFILE[18] ;
#line 170
char *BOSHERR ;
#line 171
int boshuservars ;
#line 172
char **boshuservar ;
#line 174 "/home/june/collector/temp/bosh-0.6/bosh.h"
stray_t *childarg  ;
#line 178
void bosh_finish(int s ) ;
#line 180
int bosh_redraw(void) ;
#line 18 "/home/june/collector/temp/bosh-0.6/system.h"
int bosh_open(bosh_t *bosh___0 ) ;
#line 19
int bosh_pipe(bosh_t *bosh___0 , char *command ) ;
#line 20
int bosh_action(bosh_t *bosh___0 , int a ) ;
#line 22
int bosh_read(bosh_t *bosh___0 ) ;
#line 23
int bosh_write(bosh_t *bosh___0 , char c ) ;
#line 24
void bosh_close(bosh_t *bosh___0 ) ;
#line 25
int bosh_unlink(char const   *path ) ;
#line 59 "/home/june/collector/temp/bosh-0.6/system.c"
static stray_t *bosh_prepare_bash(bosh_t *bosh___0 , char *command , FILE *script ) 
{ 
  int n ;
  stray_t *execvarg ;
  char *p ;
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 63
  p = (char *)((void *)0);
#line 71
  bosh_fprintfl(script, p, "BOSHVARFILE=%s\n", BOSHVARFILE);
#line 72
  bosh_fprintfl(script, p, "BOSHCONF=\"%s\"\n", conf);
#line 73
  tmp = getpid();
#line 73
  bosh_fprintfl(script, p, "BOSHPID=%d\n", tmp);
#line 74
  tmp___0 = getppid();
#line 74
  bosh_fprintfl(script, p, "BOSHPPID=%d\n", tmp___0);
  }
#line 75
  if (BOSHPARAM) {
    {
#line 76
    bosh_fprintfl(script, p, "BOSHPARAM=\"%s\"\n", BOSHPARAM);
    }
  }
#line 77
  if (bosh___0->title) {
    {
#line 78
    bosh_fprintfl(script, p, "BOSHTITLE=\"%s\"\n", bosh___0->title);
    }
  }
#line 79
  n = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (n < boshuservars)) {
#line 79
      goto while_break;
    }
#line 80
    if (*(boshuservar + n)) {
      {
#line 81
      bosh_fprintfl(script, p, "BOSHVAR%d=\"%s\"\n", n + 1, *(boshuservar + n));
      }
    }
#line 79
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  bosh_fprintfl(script, p, "BOSHFUNCTION() {\n");
  }
#line 84
  if (bosh___0->common) {
    {
#line 85
    bosh_fprintfl(script, p, "%s\n", bosh___0->common);
    }
  }
#line 86
  if (bosh___0->tmpfpipe[0]) {
    {
#line 87
    bosh_fprintfl(script, p, "cat %s | %s\n", bosh___0->tmpfpipe, command);
    }
  } else {
    {
#line 89
    bosh_fprintfl(script, p, "%s\n", command);
    }
  }
  {
#line 90
  bosh_fprintfl(script, p, "}\n");
#line 92
  bosh_fprintfl(script, p, "BOSHFUNCTION \"$@\"\n");
#line 93
  bosh_fprintfl(script, p, "BOSHRETURN=$?\n");
#line 95
  bosh_fprintfl(script, p, "echo \"$BOSHERR\" > $BOSHVARFILE\n");
#line 96
  bosh_fprintfl(script, p, "echo \"$BOSHTITLE\" >> $BOSHVARFILE\n");
#line 97
  n = 0;
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 97
    if (! (n < boshuservars)) {
#line 97
      goto while_break___0;
    }
    {
#line 98
    bosh_fprintfl(script, p, "echo \"$BOSHVAR%d\" >> $BOSHVARFILE\n", n + 1);
#line 97
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 100
  bosh_fprintfl(script, p, "exit $BOSHRETURN\n");
#line 103
  execvarg = stray_new(0, (char **)0);
#line 104
  stray_addstr_d(execvarg, "/bin/bash");
#line 105
  stray_addstr_d(execvarg, "--");
#line 106
  stray_addstr_d(execvarg, (char const   *)(bosh___0->tmpfscript));
#line 107
  stray_addarr_d(execvarg, childarg);
  }
#line 108
  return (execvarg);
}
}
#line 161 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_popen(bosh_t *bosh___0 , char *cmd , int cmdtype ) 
{ 
  int fd[2] ;
  int parent[3] ;
  int child[3] ;
  int n ;
  int r ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  union __anonunion_56 __constr_expr_0 ;
  union __anonunion_57 __constr_expr_1 ;
  __pid_t tmp___1 ;
  FILE *f ;
  stray_t *a ;
  char *p ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 163
  r = -1;
#line 166
  if (bosh___0->childpid) {
    {
#line 168
    kill(bosh___0->childpid, 15);
#line 172
    usleep((__useconds_t )500);
    }
  }
  {
#line 180
  memset((void *)(parent), -1, sizeof(int ) * 3UL);
#line 181
  memset((void *)(child), -1, sizeof(int ) * 3UL);
#line 184
  n = 0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (n <= 2)) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp = pipe((int *)(fd));
    }
#line 185
    if (tmp) {
#line 186
      goto pipecleanup;
    }
#line 187
    if (n == 0) {
#line 189
      parent[n] = fd[1];
#line 190
      child[n] = fd[0];
    } else {
#line 193
      parent[n] = fd[0];
#line 194
      child[n] = fd[1];
    }
#line 184
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  strcpy((char */* __restrict  */)(bosh___0->tmpfscript), (char const   */* __restrict  */)"/tmp/boshs_XXXXXX");
#line 199
  tmp___0 = mkstemp(bosh___0->tmpfscript);
#line 199
  close(tmp___0);
#line 205
  pid = fork();
  }
#line 208
  if (pid > 0) {
#line 215
    n = 0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (n <= 2)) {
#line 215
        goto while_break___0;
      }
      {
#line 216
      close(child[n]);
#line 215
      n ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 219
    usleep((__useconds_t )1000);
#line 220
    tmp___1 = waitpid(pid, & n, 1);
    }
#line 220
    if (pid == tmp___1) {
#line 221
      __constr_expr_1.__in = n;
#line 221
      if ((__constr_expr_1.__i & 127) == 0) {
#line 222
        __constr_expr_0.__in = n;
#line 222
        if ((__constr_expr_0.__i & 65280) >> 8 == 127) {
#line 223
          goto pipecleanup;
        }
      }
    }
    {
#line 226
    list_reinit(bosh___0->buf);
#line 229
    bosh___0->childin = parent[0];
#line 230
    bosh___0->childout = parent[1];
#line 231
    bosh___0->childerr = parent[2];
#line 232
    bosh___0->childpid = pid;
#line 233
    bosh___0->exit = -100;
    }
#line 235
    if (cmdtype & 4) {
      {
#line 239
      waitpid(bosh___0->childpid, (int *)0, 0);
#line 240
      bosh_close(bosh___0);
      }
    }
#line 243
    return (0);
  }
#line 247
  if (pid == 0) {
    {
#line 252
    pid = getpid();
#line 261
    signal(15, (void (*)(int  ))0);
#line 262
    signal(1, (void (*)(int  ))0);
#line 264
    signal(2, (void (*)(int  ))0);
#line 265
    signal(13, (void (*)(int  ))0);
#line 268
    n = 0;
    }
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (n <= 2)) {
#line 268
        goto while_break___1;
      }
      {
#line 269
      close(parent[n]);
      }
#line 270
      if (! (cmdtype & 2)) {
        {
#line 271
        dup2(child[n], n);
#line 272
        close(child[n]);
        }
      }
#line 268
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 276
    if (cmdtype & 16) {
      {
#line 279
      strcpy((char */* __restrict  */)(bosh___0->tmpfpipe), (char const   */* __restrict  */)"/tmp/bosht_XXXXXX");
#line 283
      tmp___2 = mkstemp(bosh___0->tmpfpipe);
#line 283
      f = fdopen(tmp___2, "w");
#line 284
      list_start(bosh___0->buf, 0);
      }
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 286
        tmp___3 = list_next(bosh___0->buf);
#line 286
        p = (char *)tmp___3;
        }
#line 287
        if (! p) {
#line 288
          goto while_break___2;
        }
        {
#line 289
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
                p);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 291
      fclose(f);
      }
    } else {
#line 293
      bosh___0->tmpfpipe[0] = (char)0;
#line 294
      if (! cmd) {
#line 295
        cmd = bosh___0->command;
      }
    }
    {
#line 299
    f = fopen((char const   */* __restrict  */)(bosh___0->tmpfscript), (char const   */* __restrict  */)"w");
    }
#line 300
    if (! f) {
#line 301
      return (-1);
    }
    {
#line 305
    a = bosh_prepare_bash(bosh___0, cmd, f);
#line 306
    fclose(f);
#line 307
    chmod((char const   *)(bosh___0->tmpfscript), (__mode_t )448);
#line 315
    execv((char const   *)*(a->v + 0), (char * const  *)a->v);
#line 323
    _exit(1);
    }
  }
  pipecleanup: 
#line 328
  n = 0;
  {
#line 328
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 328
    if (! (n <= 2)) {
#line 328
      goto while_break___3;
    }
    {
#line 329
    close(parent[n]);
#line 330
    close(child[n]);
#line 328
    n ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 333
  return (r);
}
}
#line 337 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_open(bosh_t *bosh___0 ) 
{ 
  int tmp ;

  {
  {
#line 338
  tmp = bosh_popen(bosh___0, (char *)((void *)0), 0);
  }
#line 338
  return (tmp);
}
}
#line 341 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_pipe(bosh_t *bosh___0 , char *command ) 
{ 
  int tmp ;

  {
  {
#line 342
  tmp = bosh_popen(bosh___0, command, 16);
  }
#line 342
  return (tmp);
}
}
#line 357 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_action(bosh_t *bosh___0 , int a ) 
{ 
  char *action ;
  char *seperator ;
  char *p ;
  int dest ;
  int i ;
  int n ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;

  {
#line 359
  action = (char *)((void *)0);
#line 359
  seperator = (char *)((void *)0);
#line 362
  if (a == 40) {
#line 363
    dest = '>';
#line 364
    if (confpath) {
      {
#line 365
      tmp = strlen((char const   *)confpath);
#line 365
      tmp___0 = malloc(tmp + 7UL);
#line 365
      action = (char *)tmp___0;
      }
#line 366
      if (action) {
        {
#line 367
        sprintf((char */* __restrict  */)action, (char const   */* __restrict  */)"cat \'%s\'",
                confpath);
        }
      }
    }
#line 369
    if (! action) {
#line 370
      return (-1);
    }
  } else {
#line 373
    if (bosh___0->cursorsize > 1) {
#line 374
      if (bosh___0->multilineseperator) {
#line 374
        seperator = bosh___0->multilineseperator;
      } else {
#line 374
        seperator = (char *)"";
      }
#line 375
      n = 0;
#line 375
      i = 0;
      {
#line 375
      while (1) {
        while_continue: /* CIL Label */ ;
#line 375
        if (! (i < bosh___0->cursorsize)) {
#line 375
          goto while_break;
        }
        {
#line 376
        tmp___1 = list_get(bosh___0->buf, (bosh___0->offset + bosh___0->cursor) + i);
#line 376
        p = (char *)tmp___1;
#line 377
        tmp___2 = strlen((char const   *)p);
#line 377
        tmp___3 = strlen((char const   *)seperator);
#line 377
        n = (int )((size_t )n + (tmp___2 + tmp___3));
#line 375
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 379
      tmp___4 = malloc((size_t )n);
#line 379
      BOSH = (char *)tmp___4;
      }
#line 380
      if (! BOSH) {
#line 381
        return (-1);
      }
#line 382
      *BOSH = (char)0;
#line 383
      i = 0;
      {
#line 383
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 383
        if (! (i < bosh___0->cursorsize)) {
#line 383
          goto while_break___0;
        }
        {
#line 384
        tmp___5 = list_get(bosh___0->buf, (bosh___0->offset + bosh___0->cursor) + i);
#line 384
        p = (char *)tmp___5;
#line 385
        tmp___6 = strlen((char const   *)BOSH);
#line 385
        sprintf((char */* __restrict  */)(BOSH + tmp___6), (char const   */* __restrict  */)"%s%s",
                p, seperator);
#line 383
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 389
      tmp___7 = list_get(bosh___0->buf, bosh___0->offset + bosh___0->cursor);
#line 389
      BOSH = strdup((char const   *)tmp___7);
      }
    }
#line 391
    if (bosh___0->preaction) {
      {
#line 392
      action = strdup2((char const   *)bosh___0->preaction, (char const   *)bosh___0->action[a].command);
      }
    } else {
      {
#line 394
      action = strdup((char const   *)bosh___0->action[a].command);
      }
    }
    {
#line 395
    dest = bosh___0->action[a].dest;
#line 397
    setenv("BOSH", (char const   *)BOSH, 1);
    }
#line 398
    if (BOSHPARAM) {
      {
#line 399
      setenv("BOSHPARAM", (char const   *)BOSHPARAM, 1);
      }
    }
  }
  {
#line 404
  if (dest == 46) {
#line 404
    goto case_46;
  }
#line 414
  if (dest == 62) {
#line 414
    goto case_62;
  }
#line 435
  if (dest == 33) {
#line 435
    goto case_33;
  }
#line 447
  if (dest == 32) {
#line 447
    goto case_32;
  }
#line 456
  goto switch_default;
  case_46: /* CIL Label */ 
  {
#line 409
  tmp___9 = 0;
#line 409
  bosh___0->cursor = tmp___9;
#line 409
  tmp___8 = tmp___9;
#line 409
  bosh___0->offset = tmp___8;
#line 409
  bosh___0->line = tmp___8;
#line 410
  bosh_popen(bosh___0, action, 1);
  }
#line 411
  goto switch_break;
  case_62: /* CIL Label */ 
#line 418
  p = (char *)((void *)0);
#line 420
  if (bosh___0->common) {
    {
#line 421
    p = strdup((char const   *)bosh___0->common);
    }
  }
  {
#line 422
  bosh___0 = bosh_t_new();
#line 423
  bosh___0->command = strdup((char const   *)action);
#line 424
  bosh___0->common = p;
#line 425
  bosh_popen(bosh___0, (char *)((void *)0), 1);
#line 426
  tmp___11 = list_items(boshlist);
  }
#line 426
  if (tmp___11 > 1) {
    {
#line 427
    tmp___10 = list_get(boshlist, 1);
#line 427
    bosh_t_free((bosh_t *)tmp___10);
#line 428
    list_del(boshlist, 1);
    }
  }
  {
#line 430
  list_add(boshlist, (void *)bosh___0);
#line 431
  boshlistpos = 1;
  }
#line 432
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 439
  endwin();
#line 440
  bosh_popen(bosh___0, action, 7);
  }
#line 441
  if (bosh___0->refresh) {
    {
#line 442
    bosh_open(bosh___0);
    }
  }
  {
#line 443
  bosh_redraw();
  }
#line 444
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 451
  bosh_popen(bosh___0, action, 5);
  }
#line 452
  if (bosh___0->refresh) {
    {
#line 453
    bosh_open(bosh___0);
    }
  }
#line 454
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 457
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 460
  free((void *)action);
#line 461
  free((void *)BOSH);
#line 462
  free((void *)BOSHPARAM);
#line 463
  BOSH = (char *)((void *)0);
#line 464
  BOSHPARAM = (char *)((void *)0);
  }
#line 465
  return (0);
}
}
#line 484 "/home/june/collector/temp/bosh-0.6/system.c"
static unsigned int readbuflen  =    1024U;
#line 485 "/home/june/collector/temp/bosh-0.6/system.c"
static unsigned int readbufpos  =    0U;
#line 486 "/home/june/collector/temp/bosh-0.6/system.c"
static unsigned char *readbuf  =    (unsigned char *)((void *)0);
#line 483 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_read(bosh_t *bosh___0 ) 
{ 
  fd_set fdsetr ;
  int n ;
  int r ;
  int loop ;
  unsigned char c ;
  void *tmp ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;

  {
#line 488
  loop = 1;
#line 491
  if (! readbuf) {
    {
#line 492
    tmp = malloc((size_t )readbuflen);
#line 492
    readbuf = (unsigned char *)tmp;
    }
  }
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! loop) {
#line 494
      goto while_break;
    }
#line 495
    tv.tv_sec = (__time_t )0;
#line 495
    tv.tv_usec = (__suseconds_t )0;
#line 496
    loop = 0;
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdsetr.__fds_bits[0]): "memory");
#line 497
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 498
    if (bosh___0->childout >= 0) {
#line 498
      fdsetr.__fds_bits[bosh___0->childout / (8 * (int )sizeof(__fd_mask ))] |= 1L << bosh___0->childout % (8 * (int )sizeof(__fd_mask ));
#line 498
      if (n > bosh___0->childout) {
#line 498
        n = n;
      } else {
#line 498
        n = bosh___0->childout;
      }
    }
#line 499
    if (bosh___0->childerr >= 0) {
#line 499
      fdsetr.__fds_bits[bosh___0->childerr / (8 * (int )sizeof(__fd_mask ))] |= 1L << bosh___0->childerr % (8 * (int )sizeof(__fd_mask ));
#line 499
      if (n > bosh___0->childerr) {
#line 499
        n = n;
      } else {
#line 499
        n = bosh___0->childerr;
      }
    }
    {
#line 500
    tmp___4 = select(n + 1, (fd_set */* __restrict  */)(& fdsetr), (fd_set */* __restrict  */)0,
                     (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
    }
#line 500
    if (tmp___4 > 0) {
#line 501
      n = -1;
#line 502
      if (bosh___0->childout >= 0) {
#line 502
        tmp___1 = (fdsetr.__fds_bits[bosh___0->childout / (8 * (int )sizeof(__fd_mask ))] & (1L << bosh___0->childout % (8 * (int )sizeof(__fd_mask )))) != 0L;
      } else {
#line 502
        tmp___1 = 0;
      }
#line 502
      if (tmp___1) {
#line 503
        n = bosh___0->childout;
      } else {
#line 504
        if (bosh___0->childerr >= 0) {
#line 504
          tmp___0 = (fdsetr.__fds_bits[bosh___0->childerr / (8 * (int )sizeof(__fd_mask ))] & (1L << bosh___0->childerr % (8 * (int )sizeof(__fd_mask )))) != 0L;
        } else {
#line 504
          tmp___0 = 0;
        }
#line 504
        if (tmp___0) {
#line 505
          n = bosh___0->childerr;
        }
      }
#line 506
      if (n >= 0) {
        {
#line 508
        tmp___3 = read(n, (void *)(& c), (size_t )1);
        }
#line 508
        if (tmp___3 > 0L) {
#line 514
          if ((int )c == 10) {
#line 514
            goto _L;
          } else
#line 514
          if ((int )c == 13) {
            _L: /* CIL Label */ 
#line 515
            *(readbuf + readbufpos) = (unsigned char)0;
#line 516
            if ((int )c == 13) {
#line 517
              if ((bosh___0->buf)->items) {
                {
#line 518
                list_del(bosh___0->buf, (bosh___0->buf)->items - 1);
                }
              }
            }
            {
#line 519
            list_adddup(bosh___0->buf, (void *)readbuf, (int )(readbufpos + 1U));
            }
#line 520
            if ((unsigned int )bosh___0->width < readbufpos) {
#line 521
              bosh___0->width = (int )readbufpos;
            }
#line 528
            readbufpos = 0U;
#line 529
            r = 1;
          } else {
#line 531
            *(readbuf + readbufpos) = c;
#line 532
            readbufpos ++;
#line 533
            if (readbufpos >= readbuflen) {
              {
#line 534
              readbuflen *= 2U;
#line 535
              tmp___2 = realloc((void *)readbuf, (size_t )readbuflen);
#line 535
              readbuf = (unsigned char *)tmp___2;
              }
            }
          }
#line 538
          loop = 1;
        } else {
#line 544
          if (n == bosh___0->childout) {
            {
#line 545
            bosh___0->childout = -1;
#line 546
            close(n);
            }
          } else
#line 548
          if (n == bosh___0->childerr) {
            {
#line 549
            bosh___0->childerr = -1;
#line 550
            close(n);
            }
          }
#line 552
          if (bosh___0->childout == -1) {
#line 552
            if (bosh___0->childerr == -1) {
              {
#line 553
              bosh_close(bosh___0);
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  return (r);
}
}
#line 563 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_write(bosh_t *bosh___0 , char c ) 
{ 
  ssize_t tmp ;

  {
  {
#line 564
  tmp = write(bosh___0->childin, (void const   *)(& c), (size_t )1);
  }
#line 564
  return ((int )tmp);
}
}
#line 578 "/home/june/collector/temp/bosh-0.6/system.c"
void bosh_close(bosh_t *bosh___0 ) 
{ 
  int i ;
  FILE *b ;
  union __anonunion_58 __constr_expr_2 ;
  union __anonunion_59 __constr_expr_3 ;
  union __anonunion_60 __constr_expr_4 ;
  union __anonunion_61 __constr_expr_5 ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 582
  close(bosh___0->childin);
#line 583
  bosh___0->childin = -1;
  }
#line 585
  if (bosh___0->childpid) {
    {
#line 590
    waitpid(bosh___0->childpid, & i, 0);
#line 591
    __constr_expr_5.__in = i;
    }
#line 591
    if ((__constr_expr_5.__i & 127) == 0) {
#line 592
      __constr_expr_2.__in = i;
#line 592
      bosh___0->exit = (__constr_expr_2.__i & 65280) >> 8;
    } else {
#line 596
      __constr_expr_4.__in = i;
#line 596
      if ((int )((signed char )((__constr_expr_4.__i & 127) + 1)) >> 1 > 0) {
#line 597
        __constr_expr_3.__in = i;
#line 597
        bosh___0->exit = (__constr_expr_3.__i & 127) * -1;
      }
    }
#line 602
    bosh___0->childpid = 0;
  }
  {
#line 605
  bosh_unlink((char const   *)(bosh___0->tmpfscript));
#line 608
  b = fopen((char const   */* __restrict  */)(BOSHVARFILE), (char const   */* __restrict  */)"r");
  }
#line 609
  if (b) {
    {
#line 613
    tmp = malloc((size_t )256);
#line 613
    BOSHERR = (char *)tmp;
#line 614
    fgets((char */* __restrict  */)BOSHERR, 256, (FILE */* __restrict  */)b);
#line 615
    strswp(BOSHERR, '\n', 0);
#line 616
    tmp___0 = strlen((char const   *)BOSHERR);
    }
#line 616
    if (tmp___0) {
      {
#line 618
      fclose(b);
#line 619
      bosh_finish(bosh___0->exit);
      }
    }
    {
#line 621
    free((void *)BOSHERR);
#line 622
    BOSHERR = (char *)((void *)0);
#line 625
    free((void *)bosh___0->title);
#line 626
    tmp___1 = malloc((size_t )256);
#line 626
    bosh___0->title = (char *)tmp___1;
#line 627
    fgets((char */* __restrict  */)bosh___0->title, 256, (FILE */* __restrict  */)b);
#line 628
    strswp(bosh___0->title, '\n', 0);
#line 629
    tmp___2 = strlen((char const   *)bosh___0->title);
    }
#line 629
    if (! tmp___2) {
      {
#line 630
      free((void *)bosh___0->title);
#line 631
      bosh___0->title = (char *)((void *)0);
      }
    }
#line 639
    i = 0;
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;
#line 639
      if (! (i < boshuservars)) {
#line 639
        goto while_break;
      }
      {
#line 640
      free((void *)*(boshuservar + i));
#line 641
      tmp___3 = malloc((size_t )256);
#line 641
      *(boshuservar + i) = (char *)tmp___3;
#line 642
      tmp___4 = fgets((char */* __restrict  */)*(boshuservar + i), 256, (FILE */* __restrict  */)b);
      }
#line 642
      if (! tmp___4) {
        {
#line 643
        free((void *)*(boshuservar + i));
#line 644
        *(boshuservar + i) = (char *)((void *)0);
        }
#line 645
        goto while_break;
      }
      {
#line 647
      strswp(*(boshuservar + i), '\n', 0);
#line 651
      tmp___5 = strlen((char const   *)*(boshuservar + i));
      }
#line 651
      if (! tmp___5) {
        {
#line 652
        free((void *)*(boshuservar + i));
#line 653
        *(boshuservar + i) = (char *)((void *)0);
        }
      }
#line 639
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 656
    fclose(b);
#line 658
    bosh_unlink((char const   *)(BOSHVARFILE));
#line 659
    bosh_unlink((char const   *)(bosh___0->tmpfpipe));
    }
  }
#line 661
  return;
}
}
#line 672 "/home/june/collector/temp/bosh-0.6/system.c"
int bosh_unlink(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 689
  tmp = unlink(path);
  }
#line 689
  return (tmp);
}
}
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 621
extern int halfdelay(int  ) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 711
extern int noecho(void) ;
#line 723
extern int printw(char const   *  , ...) ;
#line 774
extern int ungetch(int  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 1608
extern mmask_t mousemask(mmask_t  , mmask_t * ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 44 "/home/june/collector/temp/bosh-0.6/list.h"
int list_init(struct list *l ) ;
#line 45
int list_free(struct list *l ) ;
#line 50
int list_insdup(struct list *l , int index___0 , void *data , int size ) ;
#line 161 "/home/june/collector/temp/bosh-0.6/bosh.h"
char *shell ;
#line 163 "/home/june/collector/temp/bosh-0.6/bosh.h"
int ULINES  ;
#line 164
char *REPLY ;
#line 165
char *search ;
#line 169 "/home/june/collector/temp/bosh-0.6/bosh.h"
char BOSHVARFILE[18]  ;
#line 171 "/home/june/collector/temp/bosh-0.6/bosh.h"
int boshuservars  ;
#line 172 "/home/june/collector/temp/bosh-0.6/bosh.h"
char **boshuservar  ;
#line 177
void bosh_init(void) ;
#line 179
int bosh_mainloop(int mode ) ;
#line 182
int readstr(char *prompt ) ;
#line 183
int readstrp(char *prompt , char *previous ) ;
#line 34 "/home/june/collector/temp/bosh-0.6/rc.h"
int bosh_parseargs(bosh_t *bosh___0 , stray_t *arg ) ;
#line 47 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *REPLY  =    (char *)((void *)0);
#line 49 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *conf  =    (char *)((void *)0);
#line 50 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *confpath  =    (char *)((void *)0);
#line 51 "/home/june/collector/temp/bosh-0.6/bosh.c"
bosh_t *bosh  =    (bosh_t *)((void *)0);
#line 52 "/home/june/collector/temp/bosh-0.6/bosh.c"
LIST *boshlist  =    (LIST *)((void *)0);
#line 53 "/home/june/collector/temp/bosh-0.6/bosh.c"
int boshlistpos  =    0;
#line 54 "/home/june/collector/temp/bosh-0.6/bosh.c"
MEVENT *mouse  =    (MEVENT *)((void *)0);
#line 55 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *search  =    (char *)((void *)0);
#line 56 "/home/june/collector/temp/bosh-0.6/bosh.c"
time_t autorefreshtime  ;
#line 57 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *shell  =    (char *)"/bin/bash";
#line 59 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *BOSH  =    (char *)((void *)0);
#line 60 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *BOSHPARAM  =    (char *)((void *)0);
#line 62 "/home/june/collector/temp/bosh-0.6/bosh.c"
char *BOSHERR  =    (char *)((void *)0);
#line 66 "/home/june/collector/temp/bosh-0.6/bosh.c"
stray_t *mainarg  =    (stray_t *)((void *)0);
#line 67 "/home/june/collector/temp/bosh-0.6/bosh.c"
stray_t *childarg  =    (stray_t *)((void *)0);
#line 73 "/home/june/collector/temp/bosh-0.6/bosh.c"
bosh_t *bosh_t_new(void) 
{ 
  bosh_t *r ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 75
  tmp = malloc(sizeof(bosh_t ));
#line 75
  r = (bosh_t *)tmp;
  }
#line 76
  if (r) {
    {
#line 77
    memset((void *)r, 0, sizeof(bosh_t ));
#line 78
    r->exit = -100;
#line 79
    r->childin = -1;
#line 80
    r->childout = -1;
#line 81
    r->childerr = -1;
#line 82
    r->width = 32;
#line 83
    r->cursorsize = 1;
#line 84
    r->cursormovement = 1;
#line 85
    tmp___0 = malloc(sizeof(LIST ));
#line 85
    r->buf = (LIST *)tmp___0;
#line 86
    list_init(r->buf);
#line 87
    r->searchwrap = 1;
    }
  }
#line 89
  return (r);
}
}
#line 93 "/home/june/collector/temp/bosh-0.6/bosh.c"
int bosh_t_free(bosh_t *b ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 95
  free((void *)b->command);
#line 96
  free((void *)b->pipe);
#line 97
  free((void *)b->preaction);
  }
#line 98
  if (b->multilineseperator) {
    {
#line 99
    tmp = strlen((char const   *)b->multilineseperator);
    }
#line 99
    if (tmp) {
      {
#line 100
      free((void *)b->multilineseperator);
      }
    }
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < 37)) {
#line 101
      goto while_break;
    }
    {
#line 102
    free((void *)b->action[i].command);
#line 101
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  close(b->childin);
#line 104
  close(b->childout);
#line 105
  close(b->childerr);
  }
#line 106
  if (b->childpid) {
    {
#line 107
    kill(b->childpid, 9);
    }
  }
  {
#line 108
  list_free(b->buf);
#line 109
  free((void *)b);
  }
#line 110
  return (0);
}
}
#line 114 "/home/june/collector/temp/bosh-0.6/bosh.c"
void bosh_init(void) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 117
  if (boshlist) {
    {
#line 118
    free((void *)boshlist);
    }
  }
  {
#line 120
  tmp = malloc(sizeof(LIST ));
#line 120
  boshlist = (LIST *)tmp;
#line 121
  list_init(boshlist);
#line 122
  bosh = bosh_t_new();
#line 123
  list_add(boshlist, (void *)bosh);
  }
#line 125
  if (boshuservars) {
#line 126
    i = 0;
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! (i < boshuservars)) {
#line 126
        goto while_break;
      }
      {
#line 127
      free((void *)*(boshuservar + i));
#line 126
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 128
    free((void *)boshuservar);
    }
  }
  {
#line 131
  bosh_parseargs(bosh, mainarg);
  }
#line 133
  if (boshuservars) {
    {
#line 134
    tmp___0 = malloc((unsigned long )boshuservars * sizeof(char *));
#line 134
    boshuservar = (char **)tmp___0;
#line 135
    memset((void *)boshuservar, 0, (unsigned long )boshuservars * sizeof(char *));
    }
  }
#line 137
  return;
}
}
#line 140 "/home/june/collector/temp/bosh-0.6/bosh.c"
void bosh_finish(int s ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 141
  if (s == 11) {
#line 142
    BOSHERR = (char *)"received SIGSEGV :-(";
  }
  {
#line 143
  tmp___0 = wmove(stdscr, LINES - 1, 0);
  }
#line 143
  if (! (tmp___0 == -1)) {
    {
#line 143
    tmp = strmak((size_t )COLS, ' ');
#line 143
    waddnstr(stdscr, (char const   *)tmp, -1);
    }
  }
  {
#line 144
  wrefresh(stdscr);
#line 145
  endwin();
#line 146
  bosh_unlink((char const   *)(BOSHVARFILE));
#line 147
  bosh_unlink((char const   *)(bosh->tmpfscript));
#line 148
  bosh_unlink((char const   *)(bosh->tmpfpipe));
  }
#line 152
  if (BOSHERR) {
    {
#line 153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            "bosh", BOSHERR);
    }
  }
  {
#line 154
  exit(s);
  }
}
}
#line 158 "/home/june/collector/temp/bosh-0.6/bosh.c"
void ctrlc(int s ) 
{ 


  {
  {
#line 159
  ungetch(3);
  }
#line 160
  return;
}
}
#line 162 "/home/june/collector/temp/bosh-0.6/bosh.c"
int keyup(int n ) 
{ 


  {
#line 163
  if (! n) {
#line 164
    n = bosh->cursormovement;
  }
#line 165
  if (bosh->cursor >= n) {
#line 166
    bosh->cursor -= n;
  } else
#line 167
  if (bosh->offset >= n) {
#line 168
    bosh->offset -= n;
  }
#line 169
  if (bosh->offset == 0) {
#line 169
    if (bosh->cursor < bosh->header) {
#line 170
      bosh->cursor = bosh->header;
    }
  }
#line 171
  bosh->line = bosh->offset + bosh->cursor;
#line 172
  return (n);
}
}
#line 175 "/home/june/collector/temp/bosh-0.6/bosh.c"
int keydown(int n ) 
{ 


  {
#line 176
  if (! n) {
#line 177
    n = bosh->cursormovement;
  }
#line 178
  if (bosh->line + bosh->cursormovement >= (bosh->buf)->items) {
#line 179
    return (0);
  }
#line 180
  if (bosh->cursor + n < ULINES) {
#line 181
    bosh->cursor += n;
  } else {
#line 183
    bosh->offset += n;
  }
#line 184
  bosh->line = bosh->offset + bosh->cursor;
#line 185
  return (n);
}
}
#line 189 "/home/june/collector/temp/bosh-0.6/bosh.c"
static int *intalloc(int n ) 
{ 
  int *r ;
  void *tmp ;

  {
  {
#line 190
  tmp = malloc(sizeof(int ));
#line 190
  r = (int *)tmp;
  }
#line 191
  if (r) {
    {
#line 192
    memcpy((void */* __restrict  */)r, (void const   */* __restrict  */)(& n), sizeof(int ));
    }
  }
#line 193
  return (r);
}
}
#line 202 "/home/june/collector/temp/bosh-0.6/bosh.c"
int *keyhandler_normal(int key ) 
{ 
  int n ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *p ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *p___0 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  int tmp___24 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;

  {
  {
#line 205
  if (key == 259) {
#line 205
    goto case_259;
  }
#line 206
  if (key == 258) {
#line 206
    goto case_258;
  }
#line 207
  if (key == 339) {
#line 207
    goto case_339;
  }
#line 208
  if (key == 338) {
#line 208
    goto case_338;
  }
#line 210
  if (key == 260) {
#line 210
    goto case_260;
  }
#line 219
  if (key == 261) {
#line 219
    goto case_261;
  }
#line 227
  if (key == 9) {
#line 227
    goto case_9;
  }
#line 229
  if (key == 32) {
#line 229
    goto case_32;
  }
#line 232
  if (key == 1) {
#line 232
    goto case_1;
  }
#line 250
  if (key == 10) {
#line 250
    goto case_10;
  }
#line 266
  if (key == 11) {
#line 266
    goto case_11;
  }
#line 278
  if (key == 15) {
#line 278
    goto case_15;
  }
#line 289
  if (key == 124) {
#line 289
    goto case_124;
  }
#line 289
  if (key == 16) {
#line 289
    goto case_124;
  }
#line 315
  if (key == 269) {
#line 315
    goto case_269;
  }
#line 315
  if (key == 18) {
#line 315
    goto case_269;
  }
#line 332
  if (key == 47) {
#line 332
    goto case_47;
  }
#line 332
  if (key == 23) {
#line 332
    goto case_47;
  }
#line 332
  if (key == 267) {
#line 332
    goto case_47;
  }
#line 346
  if (key == 14) {
#line 346
    goto case_14;
  }
#line 346
  if (key == 268) {
#line 346
    goto case_14;
  }
#line 381
  if (key == 22) {
#line 381
    goto case_22;
  }
#line 386
  if (key == 24) {
#line 386
    goto case_24;
  }
#line 398
  if (key == 270) {
#line 398
    goto case_270;
  }
#line 414
  if (key == 276) {
#line 414
    goto case_276;
  }
#line 414
  if (key == 12) {
#line 414
    goto case_276;
  }
#line 417
  if (key == 410) {
#line 417
    goto case_410;
  }
#line 422
  goto switch_default;
  case_259: /* CIL Label */ 
  {
#line 205
  keyup(0);
  }
#line 205
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 206
  keydown(0);
  }
#line 206
  goto switch_break;
  case_339: /* CIL Label */ 
#line 207
  n = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (n < 8)) {
#line 207
      goto while_break;
    }
    {
#line 207
    keyup(0);
#line 207
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  goto switch_break;
  case_338: /* CIL Label */ 
#line 208
  n = 0;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! (n < 8)) {
#line 208
      goto while_break___0;
    }
    {
#line 208
    keydown(0);
#line 208
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 208
  goto switch_break;
  case_260: /* CIL Label */ 
#line 211
  if (boshlistpos) {
    {
#line 212
    boshlistpos --;
#line 213
    tmp = list_get(boshlist, boshlistpos);
#line 213
    bosh = (bosh_t *)tmp;
    }
#line 214
    if (bosh->refresh) {
      {
#line 215
      bosh_open(bosh);
      }
    }
  }
#line 217
  goto switch_break;
  case_261: /* CIL Label */ 
#line 220
  if (boshlistpos + 1 < boshlist->items) {
    {
#line 221
    boshlistpos ++;
#line 222
    tmp___0 = list_get(boshlist, boshlistpos);
#line 222
    bosh = (bosh_t *)tmp___0;
    }
#line 223
    if (bosh->refresh) {
      {
#line 224
      bosh_open(bosh);
      }
    }
  }
#line 226
  goto switch_break;
  case_9: /* CIL Label */ 
#line 228
  goto switch_break;
  case_32: /* CIL Label */ 
#line 230
  goto switch_break;
  case_1: /* CIL Label */ 
#line 237
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 251
  readstr((char *)"line");
  }
#line 252
  if (REPLY) {
    {
#line 253
    tmp___1 = strtol((char const   */* __restrict  */)REPLY, (char **/* __restrict  */)0,
                     10);
#line 253
    n = (int )tmp___1;
    }
#line 254
    if (n > 0) {
#line 255
      n --;
#line 256
      if (n < bosh->line) {
        {
#line 257
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 257
          if (! (n < bosh->line)) {
#line 257
            goto while_break___1;
          }
          {
#line 258
          keyup(1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 260
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 260
          if (n > bosh->line) {
            {
#line 260
            tmp___2 = keydown(1);
            }
#line 260
            if (! tmp___2) {
#line 260
              goto while_break___2;
            }
          } else {
#line 260
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 263
  goto switch_break;
  case_11: /* CIL Label */ 
#line 267
  if (bosh->childpid) {
    {
#line 268
    n = kill(bosh->childpid, 15);
    }
  }
#line 275
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 279
  readstr((char *)"command");
  }
#line 280
  if (REPLY) {
    {
#line 281
    free((void *)bosh->command);
#line 282
    bosh->command = strdup((char const   *)REPLY);
#line 283
    ungetch(18);
    }
  }
#line 285
  goto switch_break;
  case_124: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 290
  readstrp((char *)"pipe", bosh->pipe);
  }
#line 291
  if (REPLY) {
    {
#line 292
    tmp___3 = strlen((char const   *)REPLY);
    }
#line 292
    if (tmp___3) {
      {
#line 293
      free((void *)bosh->pipe);
#line 294
      bosh->pipe = strdup((char const   *)REPLY);
      }
    }
#line 296
    if (bosh->pipe) {
      {
#line 297
      tmp___9 = bosh_pipe(bosh, bosh->pipe);
      }
#line 297
      if (tmp___9 == 0) {
#line 299
        if (bosh->command) {
          {
#line 300
          tmp___4 = strlen((char const   *)bosh->command);
#line 300
          tmp___5 = strlen((char const   *)bosh->pipe);
#line 300
          tmp___6 = malloc((tmp___4 + tmp___5) + 4UL);
#line 300
          p = (char *)tmp___6;
#line 301
          sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s | %s",
                  bosh->command, bosh->pipe);
#line 302
          free((void *)bosh->command);
          }
        } else {
          {
#line 304
          tmp___7 = strlen((char const   *)bosh->pipe);
#line 304
          tmp___8 = malloc(tmp___7 + 3UL);
#line 304
          p = (char *)tmp___8;
#line 305
          sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"| %s",
                  bosh->pipe);
          }
        }
#line 307
        bosh->command = p;
      }
    }
  }
#line 311
  goto switch_break;
  case_269: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 316
  if (conf) {
    {
#line 320
    bosh_open(bosh);
    }
  }
#line 322
  goto switch_break;
  case_47: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_267: /* CIL Label */ 
  {
#line 333
  readstrp((char *)"search", search);
  }
#line 334
  if (! REPLY) {
#line 335
    goto switch_break;
  }
  {
#line 336
  tmp___10 = strlen((char const   *)REPLY);
  }
#line 336
  if (tmp___10) {
    {
#line 337
    bosh_regex_init(REPLY);
#line 338
    free((void *)search);
#line 339
    search = strdup((char const   *)REPLY);
    }
  }
  case_14: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 347
  if (search) {
    {
#line 349
    n = bosh->line;
#line 353
    keydown(1);
    }
    {
#line 354
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 355
      if (n == bosh->line) {
#line 356
        goto while_break___3;
      }
      {
#line 357
      tmp___11 = list_get(bosh->buf, bosh->line);
#line 357
      p___0 = (char *)tmp___11;
      }
#line 358
      if (! p___0) {
#line 359
        goto while_break___3;
      }
      {
#line 363
      tmp___12 = bosh_regex_try(p___0);
      }
#line 363
      if (! tmp___12) {
#line 364
        goto while_break___3;
      }
#line 365
      if (bosh->line + 1 >= (bosh->buf)->items) {
#line 367
        if (bosh->searchwrap) {
#line 368
          tmp___14 = 0;
#line 368
          bosh->cursor = tmp___14;
#line 368
          tmp___13 = tmp___14;
#line 368
          bosh->offset = tmp___13;
#line 368
          bosh->line = tmp___13;
#line 369
          goto while_continue___3;
        } else {
#line 372
          goto while_break___3;
        }
      }
      {
#line 374
      tmp___15 = keydown(1);
      }
#line 374
      if (! tmp___15) {
#line 375
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 378
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 382
  bosh_action(bosh, 40);
  }
#line 383
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 387
  bosh_finish(0);
  }
  case_270: /* CIL Label */ 
#line 399
  if (conf) {
    {
#line 400
    bosh_init(bosh);
    }
#line 401
    if (bosh->command) {
      {
#line 405
      bosh_open(bosh);
#line 406
      tmp___17 = strlen((char const   *)bosh->command);
      }
#line 406
      if ((size_t )bosh->width < tmp___17) {
        {
#line 407
        tmp___16 = strlen((char const   *)bosh->command);
#line 407
        bosh->width = (int )tmp___16;
        }
      }
    }
  }
#line 410
  goto switch_break;
  case_276: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 415
  werase(stdscr);
  }
  case_410: /* CIL Label */ 
  {
#line 418
  wrefresh(stdscr);
  }
#line 419
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 423
  tmp___26 = __ctype_b_loc();
  }
#line 423
  if ((int const   )*(*tmp___26 + key) & 2048) {
#line 423
    n = key - 48;
  } else {
    {
#line 423
    tmp___25 = __ctype_b_loc();
    }
#line 423
    if ((int const   )*(*tmp___25 + key) & 256) {
#line 423
      tmp___24 = key - 55;
    } else {
      {
#line 423
      tmp___23 = __ctype_b_loc();
      }
#line 423
      if ((int const   )*(*tmp___23 + key) & 512) {
#line 423
        tmp___22 = key - 87;
      } else {
#line 423
        if (key == 10) {
#line 423
          tmp___21 = 36;
        } else {
#line 423
          tmp___21 = -1;
        }
#line 423
        tmp___22 = tmp___21;
      }
#line 423
      tmp___24 = tmp___22;
    }
#line 423
    n = tmp___24;
  }
#line 424
  if (n >= 0) {
#line 425
    if (bosh->action[n].command) {
#line 429
      if (bosh->action[n].prompt) {
        {
#line 430
        readstr(bosh->action[n].prompt);
        }
#line 431
        if (REPLY) {
          {
#line 432
          BOSHPARAM = strdup((char const   *)REPLY);
          }
        }
      }
      {
#line 434
      bosh_action(bosh, n);
      }
    }
  }
#line 436
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 438
  return ((int *)((void *)0));
}
}
#line 442 "/home/june/collector/temp/bosh-0.6/bosh.c"
int *keyhandler_readstr(int key ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 444
  if (key == 24) {
#line 444
    goto case_24;
  }
#line 446
  if (key == 3) {
#line 446
    goto case_3;
  }
#line 450
  if (key == 263) {
#line 450
    goto case_263;
  }
#line 450
  if (key == 127) {
#line 450
    goto case_263;
  }
#line 450
  if (key == 8) {
#line 450
    goto case_263;
  }
#line 457
  if (key == 10) {
#line 457
    goto case_10;
  }
#line 459
  goto switch_default;
  case_24: /* CIL Label */ 
  {
#line 445
  bosh_finish(0);
  }
  case_3: /* CIL Label */ 
  {
#line 447
  tmp = intalloc(-1);
  }
#line 447
  return (tmp);
  case_263: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 451
  tmp___2 = strlen((char const   *)REPLY);
  }
#line 451
  if (tmp___2) {
    {
#line 452
    tmp___0 = strlen((char const   *)REPLY);
#line 452
    *(REPLY + (tmp___0 - 1UL)) = (char)0;
#line 453
    tmp___1 = wmove(stdscr, (int )stdscr->_cury, (int )stdscr->_curx - 1);
    }
#line 453
    if (! (tmp___1 == -1)) {
      {
#line 453
      waddch(stdscr, (chtype const   )' ');
      }
    }
    {
#line 454
    wmove(stdscr, (int )stdscr->_cury, (int )stdscr->_curx - 1);
    }
  }
#line 456
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 458
  tmp___3 = intalloc(0);
  }
#line 458
  return (tmp___3);
  switch_default: /* CIL Label */ 
  {
#line 460
  tmp___5 = __ctype_b_loc();
  }
#line 460
  if ((int const   )*(*tmp___5 + key) & 16384) {
    {
#line 461
    tmp___4 = strlen((char const   *)REPLY);
#line 461
    *(REPLY + tmp___4) = (char )key;
#line 462
    waddch(stdscr, (chtype const   )key);
#line 463
    wrefresh(stdscr);
    }
  }
#line 465
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 467
  return ((int *)((void *)0));
}
}
#line 471 "/home/june/collector/temp/bosh-0.6/bosh.c"
int *keyhandler_thru(int key ) 
{ 
  int *tmp ;

  {
  {
#line 473
  if (key == 20) {
#line 473
    goto case_20;
  }
#line 475
  goto switch_default;
  case_20: /* CIL Label */ 
  {
#line 474
  tmp = intalloc(0);
  }
#line 474
  return (tmp);
  switch_default: /* CIL Label */ 
  {
#line 476
  bosh_write(bosh, (char )key);
  }
  switch_break: /* CIL Label */ ;
  }
#line 478
  return ((int *)((void *)0));
}
}
#line 488 "/home/june/collector/temp/bosh-0.6/bosh.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 494
  mainarg = stray_new_d(argc, argv);
#line 496
  bosh_init();
#line 498
  strcpy((char */* __restrict  */)(BOSHVARFILE), (char const   */* __restrict  */)"/tmp/boshv_XXXXXX");
#line 499
  tmp = mkstemp(BOSHVARFILE);
#line 499
  close(tmp);
  }
#line 501
  if (bosh->command) {
    {
#line 505
    bosh_open(bosh);
#line 506
    tmp___1 = strlen((char const   *)bosh->command);
    }
#line 506
    if ((size_t )bosh->width < tmp___1) {
      {
#line 507
      tmp___0 = strlen((char const   *)bosh->command);
#line 507
      bosh->width = (int )tmp___0;
      }
    }
  }
  {
#line 510
  tmp___2 = isatty(0);
  }
#line 510
  if (tmp___2) {
#line 515
    if (! bosh->command) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no input\n",
              "bosh");
      }
#line 517
      return (1);
    }
  } else {
    {
#line 512
    bosh->childout = dup(0);
#line 513
    dup2(1, 0);
#line 514
    bosh->command = (char *)((void *)0);
    }
  }
  {
#line 521
  signal(15, & bosh_finish);
#line 522
  signal(1, & bosh_finish);
#line 523
  signal(11, & bosh_finish);
#line 524
  signal(2, & ctrlc);
#line 525
  signal(13, (void (*)(int  ))1);
#line 528
  initscr();
#line 529
  keypad(stdscr, (_Bool)1);
#line 530
  cbreak();
#line 531
  noecho();
#line 532
  halfdelay(2);
  }
#line 533
  if (mouse) {
    {
#line 534
    mousemask((mmask_t )2L, (mmask_t *)((void *)0));
    }
  }
#line 536
  if (bosh->autorefresh > 0) {
    {
#line 537
    autorefreshtime = time((time_t *)((void *)0));
    }
  }
  {
#line 540
  keyup(0);
#line 543
  bosh_mainloop(0);
  }
#line 544
  return (0);
}
}
#line 558 "/home/june/collector/temp/bosh-0.6/bosh.c"
int bosh_mainloop(int mode ) 
{ 
  int key ;
  int n ;
  int needredraw ;
  int *r ;
  void *tmp ;
  time_t tmp___0 ;

  {
#line 560
  n = 0;
#line 562
  r = (int *)((void *)0);
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 565
    needredraw = 0;
#line 571
    tmp = list_get(boshlist, boshlistpos);
#line 571
    bosh = (bosh_t *)tmp;
    }
#line 572
    if (bosh->line > (bosh->buf)->items) {
      {
#line 573
      usleep((__useconds_t )100000);
      }
    }
#line 574
    if (bosh->autorefresh > 0) {
      {
#line 575
      tmp___0 = time((time_t *)((void *)0));
      }
#line 575
      if (tmp___0 >= autorefreshtime + (time_t )bosh->autorefresh) {
        {
#line 576
        bosh_open(bosh);
#line 577
        autorefreshtime = time((time_t *)((void *)0));
        }
      }
    }
    {
#line 581
    needredraw = bosh_read(bosh);
#line 583
    key = wgetch(stdscr);
    }
    {
#line 607
    if (mode == 0) {
#line 607
      goto case_0;
    }
#line 611
    if (mode == 1) {
#line 611
      goto case_1;
    }
#line 614
    if (mode == 2) {
#line 614
      goto case_2;
    }
#line 630
    if (mode == 3) {
#line 630
      goto case_3;
    }
#line 606
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 608
    r = keyhandler_normal(key);
#line 609
    bosh_redraw();
    }
#line 610
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 612
    r = keyhandler_readstr(key);
    }
#line 613
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 618
    if (key == 331) {
#line 618
      goto case_331;
    }
#line 618
    if (key == 21) {
#line 618
      goto case_331;
    }
#line 623
    if (key == 330) {
#line 623
      goto case_330;
    }
#line 623
    if (key == 11) {
#line 623
      goto case_330;
    }
#line 615
    goto switch_break___0;
    case_331: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 619
    list_insdup(bosh->buf, bosh->line, (void *)"\000", 1);
    }
#line 620
    goto switch_break___0;
    case_330: /* CIL Label */ 
    case_11: /* CIL Label */ 
    {
#line 624
    list_del(bosh->buf, bosh->line);
    }
#line 625
    if (bosh->line >= (bosh->buf)->items) {
      {
#line 626
      ungetch(259);
      }
    }
#line 627
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 629
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 631
    r = keyhandler_thru(key);
    }
#line 632
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 634
    if (r) {
      {
#line 635
      n = *r;
#line 636
      free((void *)r);
      }
#line 637
      return (n);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 650 "/home/june/collector/temp/bosh-0.6/bosh.c"
int bosh_redraw(void) 
{ 
  int i ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  time_t tmp___30 ;

  {
  {
#line 653
  ULINES = LINES - 4;
#line 654
  werase(stdscr);
#line 658
  wattr_on(stdscr, 1UL << 18, (void *)0);
#line 659
  tmp___0 = wmove(stdscr, 0, 0);
  }
#line 659
  if (! (tmp___0 == -1)) {
    {
#line 659
    tmp = strmak((size_t )COLS, ' ');
#line 659
    waddnstr(stdscr, (char const   *)tmp, -1);
    }
  }
#line 660
  if (conf) {
    {
#line 661
    mvprintw(0, 0, "%s", conf);
    }
  }
#line 662
  if (bosh->title) {
    {
#line 663
    printw(" (%s)", bosh->title);
    }
  }
  {
#line 664
  tmp___1 = strlen("bosh");
#line 664
  tmp___2 = strlen("0.6");
#line 664
  mvprintw(0, (int )((size_t )COLS - ((tmp___1 + tmp___2) + 1UL)), "%s %s", "bosh",
           "0.6");
#line 665
  wattr_off(stdscr, 1UL << 18, (void *)0);
#line 666
  list_start(bosh->buf, bosh->offset);
#line 667
  i = 0;
  }
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (i < ULINES)) {
#line 667
      goto while_break;
    }
    {
#line 668
    tmp___3 = list_next(bosh->buf);
#line 668
    p = (char *)tmp___3;
    }
#line 669
    if (p) {
#line 670
      if (i >= bosh->cursor) {
#line 670
        if (i < bosh->cursor + bosh->cursorsize) {
          {
#line 671
          wattr_on(stdscr, 1UL << 18, (void *)0);
          }
        }
      }
      {
#line 672
      tmp___6 = wmove(stdscr, 2 + i, 0);
      }
#line 672
      if (! (tmp___6 == -1)) {
#line 672
        if (COLS < bosh->width) {
#line 672
          tmp___4 = COLS;
        } else {
#line 672
          tmp___4 = bosh->width;
        }
        {
#line 672
        tmp___5 = strmak((size_t )tmp___4, ' ');
#line 672
        waddnstr(stdscr, (char const   *)tmp___5, -1);
        }
      }
      {
#line 673
      tmp___7 = wmove(stdscr, 2 + i, 0);
      }
#line 673
      if (! (tmp___7 == -1)) {
        {
#line 673
        waddnstr(stdscr, (char const   *)p, -1);
        }
      }
#line 675
      if (i >= bosh->cursor) {
#line 675
        if (i < bosh->cursor + bosh->cursorsize) {
          {
#line 676
          wattr_off(stdscr, 1UL << 18, (void *)0);
          }
        }
      }
    } else {
      {
#line 678
      tmp___10 = wmove(stdscr, 2 + i, 0);
      }
#line 678
      if (! (tmp___10 == -1)) {
#line 678
        if (COLS < bosh->width) {
#line 678
          tmp___8 = COLS;
        } else {
#line 678
          tmp___8 = bosh->width;
        }
        {
#line 678
        tmp___9 = strmak((size_t )tmp___8, ' ');
#line 678
        waddnstr(stdscr, (char const   *)tmp___9, -1);
        }
      }
    }
#line 667
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 682
  tmp___12 = wmove(stdscr, LINES - 2, 0);
  }
#line 682
  if (! (tmp___12 == -1)) {
    {
#line 682
    tmp___11 = strmak((size_t )COLS, ' ');
#line 682
    waddnstr(stdscr, (char const   *)tmp___11, -1);
    }
  }
  {
#line 685
  wattr_on(stdscr, 1UL << 18, (void *)0);
#line 688
  tmp___15 = wmove(stdscr, LINES - 1, 0);
  }
#line 688
  if (! (tmp___15 == -1)) {
#line 688
    if (COLS < bosh->width) {
#line 688
      tmp___13 = COLS;
    } else {
#line 688
      tmp___13 = bosh->width;
    }
    {
#line 688
    tmp___14 = strmak((size_t )tmp___13, ' ');
#line 688
    waddnstr(stdscr, (char const   *)tmp___14, -1);
    }
  }
#line 690
  i = (bosh->buf)->items;
#line 691
  if (bosh->cursorsize > 1) {
#line 692
    if (((bosh->line + 1) + bosh->cursorsize) - 1 < i) {
#line 692
      tmp___16 = ((bosh->line + 1) + bosh->cursorsize) - 1;
    } else {
#line 692
      tmp___16 = i;
    }
#line 692
    if (i < 10) {
#line 692
      tmp___20 = 1;
    } else {
#line 692
      if (i < 100) {
#line 692
        tmp___19 = 2;
      } else {
#line 692
        if (i < 1000) {
#line 692
          tmp___18 = 3;
        } else {
#line 692
          if (i < 10000) {
#line 692
            tmp___17 = 5;
          } else {
#line 692
            tmp___17 = 6;
          }
#line 692
          tmp___18 = tmp___17;
        }
#line 692
        tmp___19 = tmp___18;
      }
#line 692
      tmp___20 = tmp___19;
    }
#line 692
    if (i < 10) {
#line 692
      tmp___24 = 1;
    } else {
#line 692
      if (i < 100) {
#line 692
        tmp___23 = 2;
      } else {
#line 692
        if (i < 1000) {
#line 692
          tmp___22 = 3;
        } else {
#line 692
          if (i < 10000) {
#line 692
            tmp___21 = 5;
          } else {
#line 692
            tmp___21 = 6;
          }
#line 692
          tmp___22 = tmp___21;
        }
#line 692
        tmp___23 = tmp___22;
      }
#line 692
      tmp___24 = tmp___23;
    }
    {
#line 692
    mvprintw(LINES - 1, 0, "%*d-%*d/%d ", tmp___24, bosh->line + 1, tmp___20, tmp___16,
             i);
    }
  } else {
#line 694
    if (i < 10) {
#line 694
      tmp___28 = 1;
    } else {
#line 694
      if (i < 100) {
#line 694
        tmp___27 = 2;
      } else {
#line 694
        if (i < 1000) {
#line 694
          tmp___26 = 3;
        } else {
#line 694
          if (i < 10000) {
#line 694
            tmp___25 = 5;
          } else {
#line 694
            tmp___25 = 6;
          }
#line 694
          tmp___26 = tmp___25;
        }
#line 694
        tmp___27 = tmp___26;
      }
#line 694
      tmp___28 = tmp___27;
    }
    {
#line 694
    mvprintw(LINES - 1, 0, "%0*d/%d ", tmp___28, bosh->line, i);
    }
  }
#line 696
  if (bosh->exit > -100) {
    {
#line 697
    printw(" exit=");
    }
#line 698
    if (bosh->exit >= 0) {
      {
#line 699
      printw("%d", bosh->exit);
      }
    } else {
      {
#line 701
      printw("sig:%d", bosh->exit * -1);
      }
    }
  }
#line 704
  if (bosh->refresh) {
#line 704
    tmp___29 = "R";
  } else {
#line 704
    tmp___29 = " ";
  }
  {
#line 704
  printw(" %s ", tmp___29);
  }
#line 705
  if (bosh->autorefresh) {
    {
#line 706
    tmp___30 = time((time_t *)((void *)0));
#line 706
    printw("%d", (time_t )bosh->autorefresh - (tmp___30 - autorefreshtime));
    }
  }
  {
#line 707
  wattr_off(stdscr, 1UL << 18, (void *)0);
#line 708
  wmove(stdscr, LINES - 1, COLS - 1);
#line 710
  wrefresh(stdscr);
  }
#line 711
  return (0);
}
}
#line 714 "/home/june/collector/temp/bosh-0.6/bosh.c"
int readstr(char *prompt ) 
{ 
  int n ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 716
  free((void *)REPLY);
#line 717
  tmp = malloc((size_t )128);
#line 717
  REPLY = (char *)tmp;
  }
#line 718
  if (! REPLY) {
#line 719
    return (-1);
  }
  {
#line 720
  memset((void *)REPLY, 0, (size_t )128);
#line 721
  wattr_on(stdscr, 1UL << 18, (void *)0);
#line 722
  tmp___1 = wmove(stdscr, LINES - 1, 0);
  }
#line 722
  if (! (tmp___1 == -1)) {
    {
#line 722
    tmp___0 = strmak((size_t )bosh->width, ' ');
#line 722
    waddnstr(stdscr, (char const   *)tmp___0, -1);
    }
  }
  {
#line 723
  mvprintw(LINES - 1, 0, "%s: ", prompt);
#line 724
  n = bosh_mainloop(1);
#line 725
  wattr_off(stdscr, 1UL << 18, (void *)0);
  }
#line 726
  if (n) {
    {
#line 728
    free((void *)REPLY);
#line 729
    REPLY = (char *)((void *)0);
    }
#line 730
    return (-1);
  }
#line 732
  return (0);
}
}
#line 735 "/home/june/collector/temp/bosh-0.6/bosh.c"
int readstrp(char *prompt , char *previous ) 
{ 
  char *s ;
  int r ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 738
  if (previous) {
    {
#line 739
    tmp = strlen((char const   *)prompt);
#line 739
    tmp___0 = strlen((char const   *)previous);
#line 739
    tmp___1 = malloc((tmp + tmp___0) + 4UL);
#line 739
    s = (char *)tmp___1;
#line 740
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s [%s]",
            prompt, previous);
#line 741
    r = readstr(s);
#line 742
    free((void *)s);
    }
  } else {
    {
#line 744
    r = readstr(prompt);
    }
  }
#line 746
  return (r);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 32 "/home/june/collector/temp/bosh-0.6/rc.h"
int bosh_rc_read(char *name , bosh_t *bosh___0 , stray_t *arg ) ;
#line 35
int bosh_action_set(bosh_t *bosh___0 , char *a , char *v ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 39 "/home/june/collector/temp/bosh-0.6/rc.c"
int bosh_rc_read(char *name , bosh_t *bosh___0 , stray_t *arg ) 
{ 
  FILE *f ;
  char s[256] ;
  char *p ;
  char *a ;
  char *v ;
  int line ;
  stray_t *origarg ;
  int isaction ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;

  {
  {
#line 43
  line = 0;
#line 47
  origarg = stray_dup(arg);
#line 48
  stray_clr(arg);
#line 49
  tmp = stray_get(origarg, (uint32_t )0);
#line 49
  stray_addstr(arg, tmp);
#line 50
  stray_del(origarg, (uint32_t )0);
#line 53
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 54
  if (! f) {
    {
#line 55
    bosh_fatal_err(1, (char *)"file not found \'%s\'", name);
    }
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp___26 = feof(f);
    }
#line 57
    if (tmp___26) {
#line 57
      goto while_break;
    }
    {
#line 58
    tmp___1 = fgets((char */* __restrict  */)(s), (int )sizeof(s), (FILE */* __restrict  */)f);
    }
#line 58
    if (! tmp___1) {
      {
#line 59
      tmp___0 = ferror(f);
      }
#line 59
      if (tmp___0) {
        {
#line 60
        bosh_fatal_err(1, (char *)"[%s:%02d] read error", conf, line);
        }
      }
#line 61
      goto while_break;
    }
#line 64
    line ++;
#line 67
    if ((int )s[0] == 35) {
#line 68
      goto while_continue;
    }
    {
#line 71
    strswp(s, '\n', 0);
    }
#line 74
    if (! s[0]) {
#line 75
      goto while_continue;
    }
    {
#line 78
    p = strchr((char const   *)(s), '=');
    }
#line 79
    if (p) {
      {
#line 80
      *p = (char)0;
#line 81
      p ++;
#line 82
      a = strdup((char const   *)(s));
#line 83
      v = strdup((char const   *)p);
      }
#line 86
      if (! *v) {
        {
#line 87
        tmp___3 = fgets((char */* __restrict  */)(s), (int )sizeof(s), (FILE */* __restrict  */)f);
        }
#line 87
        if (! tmp___3) {
          {
#line 88
          tmp___2 = ferror(f);
          }
#line 88
          if (tmp___2) {
            {
#line 89
            bosh_fatal_err(1, (char *)"[%s:%02d] read error", conf, line);
            }
          }
#line 90
          goto while_break;
        }
        {
#line 92
        free((void *)v);
        }
#line 93
        if ((int )s[0] == 35) {
#line 94
          goto while_continue;
        }
        {
#line 95
        strswp(s, '\n', 0);
#line 96
        v = strdup((char const   *)(s));
        }
      }
      {
#line 100
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 100
        tmp___10 = strlen((char const   *)v);
        }
#line 100
        if (! ((int )*(v + (tmp___10 - 1UL)) == 92)) {
#line 100
          goto while_break___0;
        }
        {
#line 101
        tmp___4 = strlen((char const   *)v);
#line 101
        *(v + (tmp___4 - 1UL)) = (char )'\n';
#line 102
        tmp___6 = fgets((char */* __restrict  */)(s), (int )sizeof(s), (FILE */* __restrict  */)f);
        }
#line 102
        if (! tmp___6) {
          {
#line 103
          tmp___5 = ferror(f);
          }
#line 103
          if (tmp___5) {
            {
#line 104
            bosh_fatal_err(1, (char *)"[%s:%02d] read error", conf, line);
            }
          }
#line 105
          goto while_break___0;
        }
#line 107
        line ++;
#line 108
        if ((int )s[0] == 35) {
#line 109
          goto while_continue___0;
        }
        {
#line 110
        strswp(s, '\n', 0);
#line 111
        tmp___7 = strlen((char const   *)v);
#line 111
        tmp___8 = strlen((char const   *)(s));
#line 111
        tmp___9 = realloc((void *)v, (tmp___7 + tmp___8) + 1UL);
#line 111
        v = (char *)tmp___9;
#line 112
        strcat((char */* __restrict  */)v, (char const   */* __restrict  */)(s));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 117
      p = strstr((char const   *)(s), "{{");
      }
#line 118
      if (p) {
        {
#line 119
        *p = (char)0;
#line 120
        p ++;
#line 121
        a = strdup((char const   *)(s));
#line 122
        v = strdup("\000");
        }
        {
#line 123
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 124
          tmp___12 = fgets((char */* __restrict  */)(s), (int )sizeof(s), (FILE */* __restrict  */)f);
          }
#line 124
          if (! tmp___12) {
            {
#line 125
            tmp___11 = ferror(f);
            }
#line 125
            if (tmp___11) {
              {
#line 126
              bosh_fatal_err(1, (char *)"[%s:%02d] read error", conf, line);
              }
            }
#line 127
            goto while_break___1;
          }
          {
#line 129
          tmp___13 = strncmp((char const   *)(s), "}}", (size_t )2);
          }
#line 129
          if (tmp___13 == 0) {
#line 130
            goto while_break___1;
          }
          {
#line 131
          line ++;
#line 132
          tmp___14 = strlen((char const   *)v);
#line 132
          tmp___15 = strlen((char const   *)(s));
#line 132
          tmp___16 = realloc((void *)v, (tmp___14 + tmp___15) + 1UL);
#line 132
          v = (char *)tmp___16;
#line 133
          strcat((char */* __restrict  */)v, (char const   */* __restrict  */)(s));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 137
        bosh_fatal_err(1, (char *)"[%s:%02d] = or {{ expected", conf, line);
        }
      }
    }
    {
#line 146
    isaction = 0;
#line 148
    tmp___17 = strlen((char const   *)a);
    }
#line 148
    if (tmp___17 == 1UL) {
#line 149
      isaction = 1;
    }
    {
#line 151
    tmp___21 = strlen((char const   *)a);
    }
#line 151
    if (tmp___21 > 2UL) {
#line 152
      if ((int )*(a + 1) == 91) {
        {
#line 154
        tmp___18 = strlen((char const   *)(a + 1));
#line 154
        tmp___19 = strlen((char const   *)v);
#line 154
        tmp___20 = malloc((tmp___18 + tmp___19) + 1UL);
#line 154
        p = (char *)tmp___20;
#line 155
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s%s",
                a + 1, v);
#line 156
        free((void *)v);
#line 157
        v = p;
#line 158
        *(a + 1) = (char)0;
#line 159
        isaction = 1;
        }
      }
    }
#line 163
    if (isaction) {
      {
#line 165
      tmp___22 = bosh_action_set(bosh___0, a, v);
      }
      {
#line 166
      if (tmp___22 == -1) {
#line 166
        goto case_neg_1;
      }
#line 168
      if (tmp___22 == -2) {
#line 168
        goto case_neg_2;
      }
#line 170
      goto switch_default;
      case_neg_1: /* CIL Label */ 
      {
#line 167
      bosh_fatal_err(1, (char *)"[%s:%02d] invalid action \'%c\'", conf, line, (int )*(a + 0));
      }
      case_neg_2: /* CIL Label */ 
      {
#line 169
      bosh_fatal_err(1, (char *)"[%s:%02d] invalid action destination \'%c\'", conf,
                     line, (int )*(v + 1));
      }
      switch_default: /* CIL Label */ 
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 175
      tmp___23 = strlen((char const   *)a);
#line 175
      tmp___24 = strlen((char const   *)v);
#line 175
      tmp___25 = malloc((tmp___23 + tmp___24) + 4UL);
#line 175
      p = (char *)tmp___25;
#line 176
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"--%s=%s",
              a, v);
#line 177
      stray_addstr(arg, p);
      }
    }
    {
#line 180
    free((void *)a);
#line 181
    free((void *)v);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  fclose(f);
#line 187
  stray_addarr(arg, origarg);
  }
#line 189
  return (0);
}
}
#line 192 "/home/june/collector/temp/bosh-0.6/rc.c"
int rc_write(char *name , bosh_t *bosh___0 ) 
{ 


  {
#line 229
  return (0);
}
}
#line 235 "/home/june/collector/temp/bosh-0.6/rc.c"
long bosh_atoi(char const   *nptr ) 
{ 
  char *e ;
  long r ;

  {
  {
#line 238
  r = strtol((char const   */* __restrict  */)nptr, (char **/* __restrict  */)(& e),
             10);
  }
#line 239
  if (*e) {
    {
#line 240
    bosh_fatal_err(1, (char *)"%s: invalid numerical argument\n", "bosh");
    }
  }
#line 241
  return (r);
}
}
#line 244 "/home/june/collector/temp/bosh-0.6/rc.c"
int bosh_parseargs(bosh_t *bosh___0 , stray_t *arg ) 
{ 
  int i ;
  int n ;
  int argc ;
  char **argv ;
  struct option opts[15] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 246
  argc = arg->c;
#line 247
  argv = arg->v;
#line 249
  *(argv + 0) = strdup("bosh");
#line 251
  opts[0].name = "help";
#line 251
  opts[0].has_arg = 0;
#line 251
  opts[0].flag = (int *)0;
#line 251
  opts[0].val = 'h';
#line 251
  opts[1].name = "version";
#line 251
  opts[1].has_arg = 0;
#line 251
  opts[1].flag = (int *)0;
#line 251
  opts[1].val = 'v';
#line 251
  opts[2].name = "autorefresh";
#line 251
  opts[2].has_arg = 1;
#line 251
  opts[2].flag = (int *)0;
#line 251
  opts[2].val = 'a';
#line 251
  opts[3].name = "command";
#line 251
  opts[3].has_arg = 1;
#line 251
  opts[3].flag = (int *)0;
#line 251
  opts[3].val = 'c';
#line 251
  opts[4].name = "common";
#line 251
  opts[4].has_arg = 1;
#line 251
  opts[4].flag = (int *)0;
#line 251
  opts[4].val = 'C';
#line 251
  opts[5].name = "cursorsize";
#line 251
  opts[5].has_arg = 1;
#line 251
  opts[5].flag = (int *)0;
#line 251
  opts[5].val = 's';
#line 251
  opts[6].name = "cursormovement";
#line 251
  opts[6].has_arg = 1;
#line 251
  opts[6].flag = (int *)0;
#line 251
  opts[6].val = 'm';
#line 251
  opts[7].name = "multilineseperator";
#line 251
  opts[7].has_arg = 1;
#line 251
  opts[7].flag = (int *)0;
#line 251
  opts[7].val = 'M';
#line 251
  opts[8].name = "preaction";
#line 251
  opts[8].has_arg = 1;
#line 251
  opts[8].flag = (int *)0;
#line 251
  opts[8].val = 'p';
#line 251
  opts[9].name = "refresh";
#line 251
  opts[9].has_arg = 1;
#line 251
  opts[9].flag = (int *)0;
#line 251
  opts[9].val = 'r';
#line 251
  opts[10].name = "shell";
#line 251
  opts[10].has_arg = 1;
#line 251
  opts[10].flag = (int *)0;
#line 251
  opts[10].val = 'S';
#line 251
  opts[11].name = "header";
#line 251
  opts[11].has_arg = 1;
#line 251
  opts[11].flag = (int *)0;
#line 251
  opts[11].val = 'H';
#line 251
  opts[12].name = "footer";
#line 251
  opts[12].has_arg = 1;
#line 251
  opts[12].flag = (int *)0;
#line 251
  opts[12].val = 'F';
#line 251
  opts[13].name = "uservars";
#line 251
  opts[13].has_arg = 1;
#line 251
  opts[13].flag = (int *)0;
#line 251
  opts[13].val = 'u';
#line 251
  opts[14].name = (char const   *)0;
#line 251
  opts[14].has_arg = 0;
#line 251
  opts[14].flag = (int *)0;
#line 251
  opts[14].val = 0;
#line 273
  i = 1;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < argc)) {
#line 273
      goto while_break;
    }
#line 274
    if ((int )*(*(argv + i) + 0) != 45) {
      {
#line 275
      confpath = *(argv + i);
#line 276
      *(argv + i) = strdup("--");
      }
#line 277
      goto while_break;
    }
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  if (confpath) {
    {
#line 282
    conf = strrchr((char const   *)confpath, '/');
    }
#line 283
    if (conf) {
#line 283
      conf ++;
    } else {
#line 283
      conf = confpath;
    }
    {
#line 284
    conf = strdup((char const   *)conf);
#line 285
    bosh_rc_read(confpath, bosh___0, arg);
#line 286
    argc = arg->c;
#line 287
    argv = arg->v;
    }
  }
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 295
    n = getopt_long(argc, (char * const  *)argv, "hv", (struct option  const  *)(opts),
                    (int *)0);
    }
#line 296
    if (n < 0) {
#line 297
      goto while_break___0;
    }
    {
#line 300
    if (n == 97) {
#line 300
      goto case_97;
    }
#line 304
    if (n == 99) {
#line 304
      goto case_99;
    }
#line 311
    if (n == 67) {
#line 311
      goto case_67;
    }
#line 315
    if (n == 115) {
#line 315
      goto case_115;
    }
#line 321
    if (n == 109) {
#line 321
      goto case_109;
    }
#line 325
    if (n == 77) {
#line 325
      goto case_77;
    }
#line 329
    if (n == 112) {
#line 329
      goto case_112;
    }
#line 333
    if (n == 114) {
#line 333
      goto case_114;
    }
#line 337
    if (n == 83) {
#line 337
      goto case_83;
    }
#line 340
    if (n == 72) {
#line 340
      goto case_72;
    }
#line 344
    if (n == 70) {
#line 344
      goto case_70;
    }
#line 348
    if (n == 117) {
#line 348
      goto case_117;
    }
#line 352
    if (n == 104) {
#line 352
      goto case_104;
    }
#line 356
    if (n == 118) {
#line 356
      goto case_118;
    }
#line 367
    if (n == 63) {
#line 367
      goto case_63;
    }
#line 298
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 301
    tmp = bosh_atoi((char const   *)optarg);
#line 301
    bosh___0->autorefresh = (int )tmp;
    }
#line 302
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 308
    bosh___0->command = strdup((char const   *)optarg);
    }
#line 309
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 312
    bosh___0->common = strdup((char const   *)optarg);
    }
#line 313
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 316
    tmp___0 = bosh_atoi((char const   *)optarg);
#line 316
    bosh___0->cursorsize = (int )tmp___0;
    }
#line 317
    if (bosh___0->cursormovement == 1) {
#line 318
      bosh___0->cursormovement = bosh___0->cursorsize;
    }
#line 319
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 322
    tmp___1 = bosh_atoi((char const   *)optarg);
#line 322
    bosh___0->cursormovement = (int )tmp___1;
    }
#line 323
    goto switch_break;
    case_77: /* CIL Label */ 
#line 326
    if (*optarg) {
      {
#line 326
      tmp___2 = strdup((char const   *)optarg);
#line 326
      bosh___0->multilineseperator = tmp___2;
      }
    } else {
#line 326
      bosh___0->multilineseperator = (char *)((void *)0);
    }
#line 327
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 330
    bosh___0->preaction = strdup2((char const   *)optarg, "\n");
    }
#line 331
    goto switch_break;
    case_114: /* CIL Label */ 
#line 334
    bosh___0->refresh = (int )*optarg == 49;
#line 335
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 338
    bosh_fatal_err(1, (char *)"\'shell\' is deprecated for the time being. This release of bosh only supports bash");
    }
    case_72: /* CIL Label */ 
    {
#line 341
    tmp___3 = bosh_atoi((char const   *)optarg);
#line 341
    bosh___0->header = (int )tmp___3;
    }
#line 342
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 345
    tmp___4 = bosh_atoi((char const   *)optarg);
#line 345
    bosh___0->footer = (int )tmp___4;
    }
#line 346
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 349
    tmp___5 = bosh_atoi((char const   *)optarg);
#line 349
    boshuservars = (int )tmp___5;
    }
#line 350
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 353
    printf((char const   */* __restrict  */)"Please refer to the bosh(1) manpage for usage instructions\n");
#line 354
    exit(0);
    }
    case_118: /* CIL Label */ 
    {
#line 357
    printf((char const   */* __restrict  */)"%s %s", "bosh", "0.6");
#line 364
    printf((char const   */* __restrict  */)"\n");
#line 365
    exit(0);
    }
    case_63: /* CIL Label */ 
    {
#line 368
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 378
  if (childarg) {
    {
#line 379
    stray_free(childarg);
    }
  }
  {
#line 380
  childarg = stray_dup(arg);
#line 381
  n = optind;
  }
  {
#line 382
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 382
    tmp___6 = n;
#line 382
    n --;
#line 382
    if (! tmp___6) {
#line 382
      goto while_break___1;
    }
    {
#line 383
    stray_del(childarg, (uint32_t )0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 390
  return (0);
}
}
#line 399 "/home/june/collector/temp/bosh-0.6/rc.c"
int bosh_action_set(bosh_t *bosh___0 , char *a , char *v ) 
{ 
  int n ;
  int i ;
  int vo ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 407
  tmp___1 = __ctype_b_loc();
  }
#line 407
  if ((int const   )*(*tmp___1 + (int )*a) & 1024) {
    {
#line 408
    tmp = toupper((int )*a);
#line 408
    n = tmp - 55;
    }
  } else {
    {
#line 409
    tmp___0 = __ctype_b_loc();
    }
#line 409
    if ((int const   )*(*tmp___0 + (int )*a) & 2048) {
#line 410
      n = (int )*a - 48;
    } else {
#line 412
      return (-1);
    }
  }
#line 415
  if (bosh___0->action[n].command) {
    {
#line 416
    bosh_fatal_err(1, (char *)"duplicate action for \'%c\'", (int )*a);
    }
  }
#line 419
  bosh___0->action[n].dest = ' ';
#line 420
  vo = 0;
#line 421
  if ((int )*(v + 0) == 91) {
#line 422
    vo ++;
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 424
      if (! *(v + vo)) {
#line 425
        goto while_break;
      }
#line 427
      if ((int )*(v + vo) == 93) {
#line 428
        vo ++;
#line 429
        goto while_break;
      }
      {
#line 432
      if (vo == 1) {
#line 432
        goto case_1;
      }
#line 446
      if (vo == 2) {
#line 446
        goto case_2;
      }
#line 431
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 437
      if ((int )*(v + 1) == 33) {
#line 437
        goto case_33;
      }
#line 437
      if ((int )*(v + 1) == 62) {
#line 437
        goto case_33;
      }
#line 437
      if ((int )*(v + 1) == 46) {
#line 437
        goto case_33;
      }
#line 437
      if ((int )*(v + 1) == 32) {
#line 437
        goto case_33;
      }
#line 440
      goto switch_default;
      case_33: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_46: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 438
      bosh___0->action[n].dest = (int )*(v + 1);
#line 439
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 441
      return (-2);
      switch_break___0: /* CIL Label */ ;
      }
#line 443
      vo ++;
#line 444
      goto switch_break;
      case_2: /* CIL Label */ 
#line 447
      if ((int )*(v + vo) == 58) {
#line 448
        vo ++;
#line 449
        i = 0;
        {
#line 450
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 450
          if (! ((int )*(v + (vo + i)) != 93)) {
#line 450
            goto while_break___0;
          }
#line 451
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 452
        tmp___2 = malloc((size_t )(i + 1));
#line 452
        bosh___0->action[n].prompt = (char *)tmp___2;
#line 453
        i = 0;
        }
        {
#line 454
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 454
          if (! ((int )*(v + vo) != 93)) {
#line 454
            goto while_break___1;
          }
#line 455
          *(bosh___0->action[n].prompt + i) = *(v + vo);
#line 456
          vo ++;
#line 457
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 459
        *(bosh___0->action[n].prompt + i) = (char)0;
      }
#line 461
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 465
  if (*(v + vo)) {
    {
#line 466
    bosh___0->action[n].command = strdup((char const   *)(v + vo));
    }
  }
#line 468
  return (0);
}
}
#line 49 "/home/june/collector/temp/bosh-0.6/list.h"
int list_ins(struct list *l , int index___0 , void *data ) ;
#line 53
void *list_getdup(struct list *l , int index___0 ) ;
#line 55
int list_isdup(struct list *l , int index___0 ) ;
#line 58
int list_debug(struct list *l ) ;
#line 32 "/home/june/collector/temp/bosh-0.6/list.c"
int list_init(struct list *l ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 34
  tmp = malloc(sizeof(struct node ));
#line 34
  l->root = (struct node *)tmp;
#line 35
  (l->root)->data = (void *)0;
#line 36
  (l->root)->size = 0;
#line 37
  tmp___0 = malloc(sizeof(struct node ));
#line 37
  (l->root)->next = (struct node *)tmp___0;
#line 38
  ((l->root)->next)->data = (void *)0;
#line 39
  ((l->root)->next)->size = 0;
#line 40
  ((l->root)->next)->next = (struct node *)((void *)0);
#line 41
  l->last = (l->root)->next;
#line 42
  l->items = 0;
#line 43
  l->next = (struct node *)((void *)0);
  }
#line 44
  return (0);
}
}
#line 48 "/home/june/collector/temp/bosh-0.6/list.c"
int list_free(struct list *l ) 
{ 


  {
#line 49
  l->iter = l->root;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! l->iter) {
#line 50
      goto while_break;
    }
#line 51
    l->root = (l->root)->next;
#line 52
    if ((l->iter)->size) {
      {
#line 53
      free((l->iter)->data);
      }
    }
    {
#line 54
    free((void *)l->iter);
#line 55
    l->iter = l->root;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (0);
}
}
#line 61 "/home/june/collector/temp/bosh-0.6/list.c"
int list_reinit(struct list *l ) 
{ 


  {
  {
#line 62
  list_free(l);
#line 63
  list_init(l);
  }
#line 64
  return (0);
}
}
#line 68 "/home/june/collector/temp/bosh-0.6/list.c"
int list_add(struct list *l , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 69
  (l->last)->data = data;
#line 70
  tmp = malloc(sizeof(struct node ));
#line 70
  (l->last)->next = (struct node *)tmp;
#line 71
  ((l->last)->next)->next = (struct node *)((void *)0);
#line 72
  ((l->last)->next)->data = (void *)0;
#line 73
  ((l->last)->next)->size = 0;
#line 74
  l->last = (l->last)->next;
#line 75
  (l->items) ++;
  }
#line 76
  return (0);
}
}
#line 80 "/home/june/collector/temp/bosh-0.6/list.c"
int list_adddup(struct list *l , void *data , int size ) 
{ 
  void *tmp ;

  {
  {
#line 81
  (l->last)->data = malloc((size_t )size);
#line 82
  memcpy((void */* __restrict  */)(l->last)->data, (void const   */* __restrict  */)data,
         (size_t )size);
#line 83
  (l->last)->size = size;
#line 84
  tmp = malloc(sizeof(struct node ));
#line 84
  (l->last)->next = (struct node *)tmp;
#line 85
  ((l->last)->next)->next = (struct node *)((void *)0);
#line 86
  ((l->last)->next)->data = (void *)0;
#line 87
  ((l->last)->next)->size = 0;
#line 88
  l->last = (l->last)->next;
#line 89
  (l->items) ++;
  }
#line 90
  return (0);
}
}
#line 97 "/home/june/collector/temp/bosh-0.6/list.c"
int list_ins(struct list *l , int index___0 , void *data ) 
{ 
  struct node *temp ;
  void *tmp ;

  {
#line 100
  if (index___0 >= l->items) {
#line 101
    return (-1);
  }
#line 102
  l->iter = l->root;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! index___0) {
#line 103
      goto while_break;
    }
#line 104
    if (! (l->iter)->next) {
#line 105
      return (-1);
    }
#line 106
    l->iter = (l->iter)->next;
#line 107
    index___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  (l->iter)->data = data;
#line 110
  (l->iter)->size = 0;
#line 111
  temp = (l->iter)->next;
#line 112
  tmp = malloc(sizeof(struct node ));
#line 112
  (l->iter)->next = (struct node *)tmp;
#line 113
  ((l->iter)->next)->next = temp;
#line 114
  ((l->iter)->next)->data = (void *)0;
#line 115
  ((l->last)->next)->size = 0;
#line 116
  (l->items) ++;
  }
#line 117
  return (0);
}
}
#line 123 "/home/june/collector/temp/bosh-0.6/list.c"
int list_insdup(struct list *l , int index___0 , void *data , int size ) 
{ 
  struct node *temp ;
  void *tmp ;

  {
#line 126
  if (index___0 >= l->items) {
#line 127
    return (-1);
  }
#line 128
  l->iter = l->root;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! index___0) {
#line 129
      goto while_break;
    }
#line 130
    if (! (l->iter)->next) {
#line 131
      return (-1);
    }
#line 132
    l->iter = (l->iter)->next;
#line 133
    index___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  temp = (l->iter)->next;
#line 136
  tmp = malloc(sizeof(struct node ));
#line 136
  (l->iter)->next = (struct node *)tmp;
#line 137
  ((l->iter)->next)->next = temp;
#line 138
  ((l->iter)->next)->data = malloc((size_t )size);
#line 139
  memcpy((void */* __restrict  */)((l->iter)->next)->data, (void const   */* __restrict  */)data,
         (size_t )size);
#line 140
  ((l->iter)->next)->size = size;
#line 141
  (l->items) ++;
  }
#line 142
  return (0);
}
}
#line 148 "/home/june/collector/temp/bosh-0.6/list.c"
int list_del(struct list *l , int index___0 ) 
{ 
  struct node *temp ;
  int tmp ;

  {
#line 152
  if (index___0 >= l->items) {
#line 153
    return (-1);
  }
#line 155
  if (index___0) {
#line 156
    index___0 --;
#line 157
    l->iter = (l->root)->next;
    {
#line 158
    while (1) {
      while_continue: /* CIL Label */ ;
#line 158
      tmp = index___0;
#line 158
      index___0 --;
#line 158
      if (tmp) {
#line 158
        if (! ((l->iter)->next)->next) {
#line 158
          goto while_break;
        }
      } else {
#line 158
        goto while_break;
      }
#line 159
      l->iter = (l->iter)->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 166
    l->iter = l->root;
  }
#line 171
  if (((l->iter)->next)->size) {
    {
#line 172
    free(((l->iter)->next)->data);
    }
  }
  {
#line 173
  temp = (l->iter)->next;
#line 174
  (l->iter)->next = ((l->iter)->next)->next;
#line 175
  free((void *)temp);
#line 176
  (l->items) --;
  }
#line 177
  return (0);
}
}
#line 183 "/home/june/collector/temp/bosh-0.6/list.c"
void *list_get(struct list *l , int index___0 ) 
{ 
  int tmp ;

  {
#line 185
  l->iter = (l->root)->next;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    tmp = index___0;
#line 186
    index___0 --;
#line 186
    if (tmp) {
#line 186
      if (! (l->iter)->next) {
#line 186
        goto while_break;
      }
    } else {
#line 186
      goto while_break;
    }
#line 187
    l->iter = (l->iter)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return ((l->iter)->data);
}
}
#line 194 "/home/june/collector/temp/bosh-0.6/list.c"
void *list_getdup(struct list *l , int index___0 ) 
{ 


  {
#line 197
  l->iter = l->root;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    index___0 --;
#line 198
    if (index___0) {
#line 198
      if (! ((l->iter)->next)->next) {
#line 198
        goto while_break;
      }
    } else {
#line 198
      goto while_break;
    }
#line 199
    l->iter = (l->iter)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return ((void *)0);
}
}
#line 207 "/home/june/collector/temp/bosh-0.6/list.c"
int list_items(struct list *l ) 
{ 


  {
#line 209
  return (l->items);
}
}
#line 215 "/home/june/collector/temp/bosh-0.6/list.c"
int list_isdup(struct list *l , int index___0 ) 
{ 


  {
#line 217
  l->iter = l->root;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    index___0 --;
#line 218
    if (index___0) {
#line 218
      if (! ((l->iter)->next)->next) {
#line 218
        goto while_break;
      }
    } else {
#line 218
      goto while_break;
    }
#line 219
    l->iter = (l->iter)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (((l->iter)->next)->size > 0);
}
}
#line 226 "/home/june/collector/temp/bosh-0.6/list.c"
int list_start(struct list *l , int index___0 ) 
{ 


  {
#line 228
  l->next = (l->root)->next;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (index___0) {
#line 229
      if (! (l->next)->next) {
#line 229
        goto while_break;
      }
    } else {
#line 229
      goto while_break;
    }
#line 230
    l->next = (l->next)->next;
#line 231
    index___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 239 "/home/june/collector/temp/bosh-0.6/list.c"
void *list_next(struct list *l ) 
{ 


  {
#line 241
  l->iter = l->next;
#line 242
  if ((l->next)->next) {
#line 243
    l->next = (l->next)->next;
  }
#line 244
  return ((l->iter)->data);
}
}
#line 250 "/home/june/collector/temp/bosh-0.6/list.c"
int list_debug(struct list *l ) 
{ 
  int i ;

  {
  {
#line 252
  i = 0;
#line 253
  l->iter = (l->root)->next;
#line 254
  printf((char const   */* __restrict  */)"items: %d\n", l->items);
#line 255
  i = 0;
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i < l->items)) {
#line 255
      goto while_break;
    }
    {
#line 256
    printf((char const   */* __restrict  */)"%4d:contents=%s\n", i, (char *)(l->iter)->data);
#line 257
    l->iter = (l->iter)->next;
#line 255
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (0);
}
}
