/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 66 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
enum __anonenum_DmtxStatus_9 {
    DmtxStatusEncoding = 0,
    DmtxStatusComplete = 1,
    DmtxStatusInvalid = 2,
    DmtxStatusFatal = 3
} ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef enum __anonenum_DmtxStatus_9 DmtxStatus;
#line 73
enum __anonenum_DmtxScheme_10 {
    DmtxSchemeAutoFast = -2,
    DmtxSchemeAutoBest = -1,
    DmtxSchemeAscii = 0,
    DmtxSchemeC40 = 1,
    DmtxSchemeText = 2,
    DmtxSchemeX12 = 3,
    DmtxSchemeEdifact = 4,
    DmtxSchemeBase256 = 5
} ;
#line 73 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef enum __anonenum_DmtxScheme_10 DmtxScheme;
#line 120
enum __anonenum_DmtxDirection_12 {
    DmtxDirNone = 0,
    DmtxDirUp = 1,
    DmtxDirLeft = 2,
    DmtxDirDown = 4,
    DmtxDirRight = 8,
    DmtxDirHorizontal = 10,
    DmtxDirVertical = 5,
    DmtxDirRightUp = 9,
    DmtxDirLeftDown = 6
} ;
#line 120 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef enum __anonenum_DmtxDirection_12 DmtxDirection;
#line 220 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef double DmtxMatrix3[3][3];
#line 226 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxPixelLoc_struct {
   int X ;
   int Y ;
};
#line 226 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxPixelLoc_struct DmtxPixelLoc;
#line 235 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxVector2_struct {
   double X ;
   double Y ;
};
#line 235 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxVector2_struct DmtxVector2;
#line 244 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxRay2_struct {
   double tMin ;
   double tMax ;
   DmtxVector2 p ;
   DmtxVector2 v ;
};
#line 244 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxRay2_struct DmtxRay2;
#line 251 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef unsigned char DmtxByte;
#line 259
struct DmtxByteList_struct;
#line 259 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxByteList_struct DmtxByteList;
#line 260 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxByteList_struct {
   int length ;
   int capacity ;
   DmtxByte *b ;
};
#line 267
struct DmtxEncodeStream_struct;
#line 267 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxEncodeStream_struct DmtxEncodeStream;
#line 268 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxEncodeStream_struct {
   int currentScheme ;
   int inputNext ;
   int outputChainValueCount ;
   int outputChainWordCount ;
   char *reason ;
   int sizeIdx ;
   DmtxStatus status ;
   DmtxByteList *input ;
   DmtxByteList *output ;
};
#line 285 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxImage_struct {
   int width ;
   int height ;
   int pixelPacking ;
   int bitsPerPixel ;
   int bytesPerPixel ;
   int rowPadBytes ;
   int rowSizeBytes ;
   int imageFlip ;
   int channelCount ;
   int channelStart[4] ;
   int bitsPerChannel[4] ;
   unsigned char *pxl ;
};
#line 285 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxImage_struct DmtxImage;
#line 304 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxPointFlow_struct {
   int plane ;
   int arrive ;
   int depart ;
   int mag ;
   DmtxPixelLoc loc ;
};
#line 304 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxPointFlow_struct DmtxPointFlow;
#line 316 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxBestLine_struct {
   int angle ;
   int hOffset ;
   int mag ;
   int stepBeg ;
   int stepPos ;
   int stepNeg ;
   int distSq ;
   double devn ;
   DmtxPixelLoc locBeg ;
   DmtxPixelLoc locPos ;
   DmtxPixelLoc locNeg ;
};
#line 316 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxBestLine_struct DmtxBestLine;
#line 334 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxRegion_struct {
   int jumpToPos ;
   int jumpToNeg ;
   int stepsTotal ;
   DmtxPixelLoc finalPos ;
   DmtxPixelLoc finalNeg ;
   DmtxPixelLoc boundMin ;
   DmtxPixelLoc boundMax ;
   DmtxPointFlow flowBegin ;
   int polarity ;
   int stepR ;
   int stepT ;
   DmtxPixelLoc locR ;
   DmtxPixelLoc locT ;
   int leftKnown ;
   int leftAngle ;
   DmtxPixelLoc leftLoc ;
   DmtxBestLine leftLine ;
   int bottomKnown ;
   int bottomAngle ;
   DmtxPixelLoc bottomLoc ;
   DmtxBestLine bottomLine ;
   int topKnown ;
   int topAngle ;
   DmtxPixelLoc topLoc ;
   int rightKnown ;
   int rightAngle ;
   DmtxPixelLoc rightLoc ;
   int onColor ;
   int offColor ;
   int sizeIdx ;
   int symbolRows ;
   int symbolCols ;
   int mappingRows ;
   int mappingCols ;
   DmtxMatrix3 raw2fit ;
   DmtxMatrix3 fit2raw ;
};
#line 334 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxRegion_struct DmtxRegion;
#line 387 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxMessage_struct {
   size_t arraySize ;
   size_t codeSize ;
   size_t outputSize ;
   int outputIdx ;
   int padCount ;
   unsigned char *array ;
   unsigned char *code ;
   unsigned char *output ;
};
#line 387 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxMessage_struct DmtxMessage;
#line 402 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxScanGrid_struct {
   int minExtent ;
   int maxExtent ;
   int xOffset ;
   int yOffset ;
   int xMin ;
   int xMax ;
   int yMin ;
   int yMax ;
   int total ;
   int extent ;
   int jumpSize ;
   int pixelTotal ;
   int startPos ;
   int pixelCount ;
   int xCenter ;
   int yCenter ;
};
#line 402 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxScanGrid_struct DmtxScanGrid;
#line 430 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxTime_struct {
   time_t sec ;
   unsigned long usec ;
};
#line 430 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxTime_struct DmtxTime;
#line 439 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxDecode_struct {
   int edgeMin ;
   int edgeMax ;
   int scanGap ;
   double squareDevn ;
   int sizeIdxExpected ;
   int edgeThresh ;
   int xMin ;
   int xMax ;
   int yMin ;
   int yMax ;
   int scale ;
   unsigned char *cache ;
   DmtxImage *image ;
   DmtxScanGrid grid ;
};
#line 439 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxDecode_struct DmtxDecode;
#line 466 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
struct DmtxEncode_struct {
   int method ;
   int scheme ;
   int sizeIdxRequest ;
   int marginSize ;
   int moduleSize ;
   int pixelPacking ;
   int imageFlip ;
   int rowPadBytes ;
   DmtxMessage *message ;
   DmtxImage *image ;
   DmtxRegion region ;
   DmtxMatrix3 xfrm ;
   DmtxMatrix3 rxfrm ;
};
#line 466 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
typedef struct DmtxEncode_struct DmtxEncode;
#line 58 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
enum __anonenum_DmtxEncodeOption_18 {
    DmtxEncodeNormal = 0,
    DmtxEncodeCompact = 1,
    DmtxEncodeFull = 2
} ;
#line 58 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
typedef enum __anonenum_DmtxEncodeOption_18 DmtxEncodeOption;
#line 92 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
struct DmtxFollow_struct {
   unsigned char *ptr ;
   unsigned char neighbor ;
   int step ;
   DmtxPixelLoc loc ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
typedef struct DmtxFollow_struct DmtxFollow;
#line 103 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
struct DmtxBresLine_struct {
   int xStep ;
   int yStep ;
   int xDelta ;
   int yDelta ;
   int steep ;
   int xOut ;
   int yOut ;
   int travel ;
   int outward ;
   int error ;
   DmtxPixelLoc loc ;
   DmtxPixelLoc loc0 ;
   DmtxPixelLoc loc1 ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
typedef struct DmtxBresLine_struct DmtxBresLine;
#line 119 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
struct C40TextState_struct {
   int shift ;
   unsigned int upperShift ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
typedef struct C40TextState_struct C40TextState;
#line 14 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
enum SchemeState {
    AsciiFull = 0,
    AsciiCompactOffset0 = 1,
    AsciiCompactOffset1 = 2,
    C40Offset0 = 3,
    C40Offset1 = 4,
    C40Offset2 = 5,
    TextOffset0 = 6,
    TextOffset1 = 7,
    TextOffset2 = 8,
    X12Offset0 = 9,
    X12Offset1 = 10,
    X12Offset2 = 11,
    EdifactOffset0 = 12,
    EdifactOffset1 = 13,
    EdifactOffset2 = 14,
    EdifactOffset3 = 15,
    Base256 = 16,
    SchemeStateCount = 17
} ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 63 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef void * __restrict  __timezone_ptr_t;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 60
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 523 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.h"
extern DmtxTime dmtxTimeNow(void) ;
#line 524
extern DmtxTime dmtxTimeAdd(DmtxTime t , long msec ) ;
#line 525
extern int dmtxTimeExceeded(DmtxTime timeout ) ;
#line 528
extern DmtxEncode *dmtxEncodeCreate(void) ;
#line 529
extern unsigned int dmtxEncodeDestroy(DmtxEncode **enc ) ;
#line 530
extern unsigned int dmtxEncodeSetProp(DmtxEncode *enc , int prop , int value ) ;
#line 531
extern int dmtxEncodeGetProp(DmtxEncode *enc , int prop ) ;
#line 532
extern unsigned int dmtxEncodeDataMatrix(DmtxEncode *enc , int inputSize , unsigned char *inputString ) ;
#line 533
extern unsigned int dmtxEncodeDataMosaic(DmtxEncode *enc , int inputSize , unsigned char *inputString ) ;
#line 536
extern DmtxDecode *dmtxDecodeCreate(DmtxImage *img , int scale ) ;
#line 537
extern unsigned int dmtxDecodeDestroy(DmtxDecode **dec ) ;
#line 538
extern unsigned int dmtxDecodeSetProp(DmtxDecode *dec , int prop , int value ) ;
#line 539
extern int dmtxDecodeGetProp(DmtxDecode *dec , int prop ) ;
#line 540
extern unsigned char *dmtxDecodeGetCache(DmtxDecode *dec , int x , int y ) ;
#line 541
extern unsigned int dmtxDecodeGetPixelValue(DmtxDecode *dec , int x , int y , int channel ,
                                            int *value ) ;
#line 542
extern DmtxMessage *dmtxDecodeMatrixRegion(DmtxDecode *dec , DmtxRegion *reg , int fix ) ;
#line 543
extern DmtxMessage *dmtxDecodeMosaicRegion(DmtxDecode *dec , DmtxRegion *reg , int fix ) ;
#line 544
extern unsigned char *dmtxDecodeCreateDiagnostic(DmtxDecode *dec , int *totalBytes ,
                                                 int *headerBytes , int style ) ;
#line 547
extern DmtxRegion *dmtxRegionCreate(DmtxRegion *reg ) ;
#line 548
extern unsigned int dmtxRegionDestroy(DmtxRegion **reg ) ;
#line 549
extern DmtxRegion *dmtxRegionFindNext(DmtxDecode *dec , DmtxTime *timeout ) ;
#line 550
extern DmtxRegion *dmtxRegionScanPixel(DmtxDecode *dec , int x , int y ) ;
#line 551
extern unsigned int dmtxRegionUpdateCorners(DmtxDecode *dec , DmtxRegion *reg , DmtxVector2 p00 ,
                                            DmtxVector2 p10 , DmtxVector2 p11 , DmtxVector2 p01 ) ;
#line 553
extern unsigned int dmtxRegionUpdateXfrms(DmtxDecode *dec , DmtxRegion *reg ) ;
#line 556
extern DmtxMessage *dmtxMessageCreate(int sizeIdx , int symbolFormat ) ;
#line 557
extern unsigned int dmtxMessageDestroy(DmtxMessage **msg ) ;
#line 560
extern DmtxImage *dmtxImageCreate(unsigned char *pxl , int width , int height , int pack ) ;
#line 561
extern unsigned int dmtxImageDestroy(DmtxImage **img ) ;
#line 562
extern unsigned int dmtxImageSetChannel(DmtxImage *img , int channelStart , int bitsPerChannel ) ;
#line 563
extern unsigned int dmtxImageSetProp(DmtxImage *img , int prop , int value ) ;
#line 564
extern int dmtxImageGetProp(DmtxImage *img , int prop ) ;
#line 565
extern int dmtxImageGetByteOffset(DmtxImage *img , int x , int y ) ;
#line 566
extern unsigned int dmtxImageGetPixelValue(DmtxImage *img , int x , int y , int channel ,
                                           int *value ) ;
#line 567
extern unsigned int dmtxImageSetPixelValue(DmtxImage *img , int x , int y , int channel ,
                                           int value ) ;
#line 568
extern unsigned int dmtxImageContainsInt(DmtxImage *img , int margin , int x , int y ) ;
#line 569
extern unsigned int dmtxImageContainsFloat(DmtxImage *img , double x , double y ) ;
#line 572
extern DmtxVector2 *dmtxVector2AddTo(DmtxVector2 *v1 , DmtxVector2 const   *v2 ) ;
#line 573
extern DmtxVector2 *dmtxVector2Add(DmtxVector2 *vOut , DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) ;
#line 574
extern DmtxVector2 *dmtxVector2SubFrom(DmtxVector2 *v1 , DmtxVector2 const   *v2 ) ;
#line 575
extern DmtxVector2 *dmtxVector2Sub(DmtxVector2 *vOut , DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) ;
#line 576
extern DmtxVector2 *dmtxVector2ScaleBy(DmtxVector2 *v , double s ) ;
#line 577
extern DmtxVector2 *dmtxVector2Scale(DmtxVector2 *vOut , DmtxVector2 const   *v ,
                                     double s ) ;
#line 578
extern double dmtxVector2Cross(DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) ;
#line 579
extern double dmtxVector2Norm(DmtxVector2 *v ) ;
#line 580
extern double dmtxVector2Dot(DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) ;
#line 581
extern double dmtxVector2Mag(DmtxVector2 const   *v ) ;
#line 582
extern double dmtxDistanceFromRay2(DmtxRay2 const   *r , DmtxVector2 const   *q ) ;
#line 583
extern double dmtxDistanceAlongRay2(DmtxRay2 const   *r , DmtxVector2 const   *q ) ;
#line 584
extern unsigned int dmtxRay2Intersect(DmtxVector2 *point , DmtxRay2 const   *p0 ,
                                      DmtxRay2 const   *p1 ) ;
#line 585
extern unsigned int dmtxPointAlongRay2(DmtxVector2 *point , DmtxRay2 const   *r ,
                                       double t ) ;
#line 588
extern void dmtxMatrix3Copy(double (*m0)[3] , double (*m1)[3] ) ;
#line 589
extern void dmtxMatrix3Identity(double (*m)[3] ) ;
#line 590
void dmtxMatrix3Translate(double (*m)[3] , double tx , double ty ) ;
#line 591
extern void dmtxMatrix3Rotate(double (*m)[3] , double angle ) ;
#line 592
extern void dmtxMatrix3Scale(double (*m)[3] , double sx , double sy ) ;
#line 593
extern void dmtxMatrix3Shear(double (*m)[3] , double shx , double shy ) ;
#line 594
extern void dmtxMatrix3LineSkewTop(double (*m)[3] , double b0 , double b1 , double sz ) ;
#line 595
extern void dmtxMatrix3LineSkewTopInv(double (*m)[3] , double b0 , double b1 , double sz ) ;
#line 596
extern void dmtxMatrix3LineSkewSide(double (*m)[3] , double b0 , double b1 , double sz ) ;
#line 597
extern void dmtxMatrix3LineSkewSideInv(double (*m)[3] , double b0 , double b1 , double sz ) ;
#line 598
extern void dmtxMatrix3Multiply(double (*mOut)[3] , double (*m0)[3] , double (*m1)[3] ) ;
#line 599
extern void dmtxMatrix3MultiplyBy(double (*m0)[3] , double (*m1)[3] ) ;
#line 600
extern int dmtxMatrix3VMultiply(DmtxVector2 *vOut , DmtxVector2 *vIn , double (*m)[3] ) ;
#line 601
extern int dmtxMatrix3VMultiplyBy(DmtxVector2 *v , double (*m)[3] ) ;
#line 602
extern void dmtxMatrix3Print(double (*m)[3] ) ;
#line 605
int dmtxSymbolModuleStatus(DmtxMessage *message , int sizeIdx , int symbolRow , int symbolCol ) ;
#line 606
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 607
extern int dmtxGetBlockDataSize(int sizeIdx , int blockIdx ) ;
#line 610
extern DmtxByteList dmtxByteListBuild(DmtxByte *storage , int capacity ) ;
#line 611
extern void dmtxByteListInit(DmtxByteList *list , int length , DmtxByte value , unsigned int *passFail ) ;
#line 612
extern void dmtxByteListClear(DmtxByteList *list ) ;
#line 613
extern unsigned int dmtxByteListHasCapacity(DmtxByteList *list ) ;
#line 614
extern void dmtxByteListCopy(DmtxByteList *dst , DmtxByteList const   *src , unsigned int *passFail ) ;
#line 615
extern void dmtxByteListPush(DmtxByteList *list , DmtxByte value , unsigned int *passFail ) ;
#line 616
extern DmtxByte dmtxByteListPop(DmtxByteList *list , unsigned int *passFail ) ;
#line 617
extern void dmtxByteListPrint(DmtxByteList *list , char *prefix ) ;
#line 619
extern char *dmtxVersion(void) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static double RightAngleTrueness(DmtxVector2 c0 , DmtxVector2 c1 , DmtxVector2 c2 ,
                                 double angle ) ;
#line 126
static DmtxPointFlow MatrixRegionSeekEdge(DmtxDecode *dec , DmtxPixelLoc loc ) ;
#line 127
static unsigned int MatrixRegionOrientation(DmtxDecode *dec , DmtxRegion *reg , DmtxPointFlow begin ) ;
#line 128
static long DistanceSquared(DmtxPixelLoc a , DmtxPixelLoc b ) ;
#line 129
static int ReadModuleColor(DmtxDecode *dec , DmtxRegion *reg , int symbolRow , int symbolCol ,
                           int sizeIdx , int colorPlane ) ;
#line 131
static unsigned int MatrixRegionFindSize(DmtxDecode *dec , DmtxRegion *reg ) ;
#line 132
static int CountJumpTally(DmtxDecode *dec , DmtxRegion *reg , int xStart , int yStart ,
                          DmtxDirection dir ) ;
#line 133
static DmtxPointFlow GetPointFlow(DmtxDecode *dec , int colorPlane , DmtxPixelLoc loc ,
                                  int arrive ) ;
#line 134
static DmtxPointFlow FindStrongestNeighbor(DmtxDecode *dec , DmtxPointFlow center ,
                                           int sign ) ;
#line 135
static DmtxFollow FollowSeek(DmtxDecode *dec , DmtxRegion *reg , int seek ) ;
#line 136
static DmtxFollow FollowSeekLoc(DmtxDecode *dec , DmtxPixelLoc loc ) ;
#line 137
static DmtxFollow FollowStep(DmtxDecode *dec , DmtxRegion *reg , DmtxFollow followBeg ,
                             int sign ) ;
#line 138
static DmtxFollow FollowStep2(DmtxDecode *dec , DmtxFollow followBeg , int sign ) ;
#line 139
static unsigned int TrailBlazeContinuous(DmtxDecode *dec , DmtxRegion *reg , DmtxPointFlow flowBegin ,
                                         int maxDiagonal ) ;
#line 140
static int TrailBlazeGapped(DmtxDecode *dec , DmtxRegion *reg , DmtxBresLine line ,
                            int streamDir ) ;
#line 141
static int TrailClear(DmtxDecode *dec , DmtxRegion *reg , int clearMask ) ;
#line 142
static DmtxBestLine FindBestSolidLine(DmtxDecode *dec , DmtxRegion *reg , int step0 ,
                                      int step1 , int streamDir , int houghAvoid ) ;
#line 143
static DmtxBestLine FindBestSolidLine2(DmtxDecode *dec , DmtxPixelLoc loc0 , int tripSteps ,
                                       int sign , int houghAvoid ) ;
#line 144
static unsigned int FindTravelLimits(DmtxDecode *dec , DmtxRegion *reg , DmtxBestLine *line ) ;
#line 145
static unsigned int MatrixRegionAlignCalibEdge(DmtxDecode *dec , DmtxRegion *reg ,
                                               int edgeLoc ) ;
#line 146
static DmtxBresLine BresLineInit(DmtxPixelLoc loc0 , DmtxPixelLoc loc1 , DmtxPixelLoc locInside ) ;
#line 147
static unsigned int BresLineGetStep(DmtxBresLine line , DmtxPixelLoc target , int *travel ,
                                    int *outward ) ;
#line 148
static unsigned int BresLineStep(DmtxBresLine *line , int travel , int outward ) ;
#line 152
static void TallyModuleJumps(DmtxDecode *dec , DmtxRegion *reg , int (*tally)[24] ,
                             int xOrigin , int yOrigin , int mapWidth , int mapHeight ,
                             DmtxDirection dir ) ;
#line 153
static unsigned int PopulateArrayFromMatrix(DmtxDecode *dec , DmtxRegion *reg , DmtxMessage *msg ) ;
#line 156
static void DecodeDataStream(DmtxMessage *msg , int sizeIdx , unsigned char *outputStart ) ;
#line 157
static int GetEncodationScheme(unsigned char cw ) ;
#line 158
static void PushOutputWord(DmtxMessage *msg , int value ) ;
#line 159
static void PushOutputC40TextWord(DmtxMessage *msg , C40TextState *state , int value ) ;
#line 160
static void PushOutputMacroHeader(DmtxMessage *msg , int macroType ) ;
#line 161
static void PushOutputMacroTrailer(DmtxMessage *msg ) ;
#line 162
static unsigned char *DecodeSchemeAscii(DmtxMessage *msg , unsigned char *ptr , unsigned char *dataEnd ) ;
#line 163
static unsigned char *DecodeSchemeC40Text(DmtxMessage *msg , unsigned char *ptr ,
                                          unsigned char *dataEnd , DmtxScheme encScheme ) ;
#line 164
static unsigned char *DecodeSchemeX12(DmtxMessage *msg , unsigned char *ptr , unsigned char *dataEnd ) ;
#line 165
static unsigned char *DecodeSchemeEdifact(DmtxMessage *msg , unsigned char *ptr ,
                                          unsigned char *dataEnd ) ;
#line 166
static unsigned char *DecodeSchemeBase256(DmtxMessage *msg , unsigned char *ptr ,
                                          unsigned char *dataEnd ) ;
#line 169
static void PrintPattern(DmtxEncode *enc ) ;
#line 170
static int EncodeDataCodewords(DmtxByteList *input , DmtxByteList *output , int sizeIdxRequest ,
                               DmtxScheme scheme ) ;
#line 173
static int ModulePlacementEcc200(unsigned char *modules , unsigned char *codewords ,
                                 int sizeIdx , int moduleOnColor ) ;
#line 174
static void PatternShapeStandard(unsigned char *modules , int mappingRows , int mappingCols ,
                                 int row , int col , unsigned char *codeword , int moduleOnColor ) ;
#line 175
static void PatternShapeSpecial1(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) ;
#line 176
static void PatternShapeSpecial2(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) ;
#line 177
static void PatternShapeSpecial3(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) ;
#line 178
static void PatternShapeSpecial4(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) ;
#line 179
static void PlaceModule(unsigned char *modules , int mappingRows , int mappingCols ,
                        int row , int col , unsigned char *codeword , int mask , int moduleOnColor ) ;
#line 183
static unsigned int RsEncode(DmtxMessage *message , int sizeIdx ) ;
#line 184
static unsigned int RsDecode(unsigned char *code , int sizeIdx , int fix ) ;
#line 185
static unsigned int RsGenPoly(DmtxByteList *gen , int errorWordCount ) ;
#line 186
static unsigned int RsComputeSyndromes(DmtxByteList *syn , DmtxByteList const   *rec ,
                                       int blockErrorWords___0 ) ;
#line 187
static unsigned int RsFindErrorLocatorPoly(DmtxByteList *elpOut , DmtxByteList const   *syn ,
                                           int errorWordCount , int maxCorrectable ) ;
#line 188
static unsigned int RsFindErrorLocations(DmtxByteList *loc , DmtxByteList const   *elp ) ;
#line 189
static unsigned int RsRepairErrors(DmtxByteList *rec , DmtxByteList const   *loc ,
                                   DmtxByteList const   *elp , DmtxByteList const   *syn ) ;
#line 192
static DmtxScanGrid InitScanGrid(DmtxDecode *dec ) ;
#line 193
static int PopGridLocation(DmtxScanGrid *grid , DmtxPixelLoc *locPtr ) ;
#line 194
static int GetGridCoordinates(DmtxScanGrid *grid , DmtxPixelLoc *locPtr ) ;
#line 195
static void SetDerivedFields(DmtxScanGrid *grid ) ;
#line 198
static int FindSymbolSize(int dataWords , int sizeIdxRequest ) ;
#line 201
static int GetBitsPerPixel(int pack ) ;
#line 204
static DmtxEncodeStream StreamInit(DmtxByteList *input , DmtxByteList *output ) ;
#line 205
static void StreamCopy(DmtxEncodeStream *dst , DmtxEncodeStream *src ) ;
#line 206
static void StreamMarkComplete(DmtxEncodeStream *stream , int sizeIdx ) ;
#line 207
static void StreamMarkInvalid(DmtxEncodeStream *stream , int reasonIdx ) ;
#line 208
static void StreamMarkFatal(DmtxEncodeStream *stream , int reasonIdx ) ;
#line 209
static void StreamOutputChainAppend(DmtxEncodeStream *stream , DmtxByte value ) ;
#line 210
static DmtxByte StreamOutputChainRemoveLast(DmtxEncodeStream *stream ) ;
#line 211
static void StreamOutputSet(DmtxEncodeStream *stream , int index , DmtxByte value ) ;
#line 212
static unsigned int StreamInputHasNext(DmtxEncodeStream *stream ) ;
#line 213
static DmtxByte StreamInputPeekNext(DmtxEncodeStream *stream ) ;
#line 214
static DmtxByte StreamInputAdvanceNext(DmtxEncodeStream *stream ) ;
#line 215
static void StreamInputAdvancePrev(DmtxEncodeStream *stream ) ;
#line 218
static int EncodeSingleScheme(DmtxByteList *input , DmtxByteList *output , int sizeIdxRequest ,
                              DmtxScheme scheme ) ;
#line 219
static void EncodeNextChunk(DmtxEncodeStream *stream , int scheme , int option , int sizeIdxRequest ) ;
#line 220
static void EncodeChangeScheme(DmtxEncodeStream *stream , DmtxScheme targetScheme ,
                               int unlatchType ) ;
#line 221
static int GetRemainingSymbolCapacity(int outputLength , int sizeIdx ) ;
#line 224
static int EncodeOptimizeBest(DmtxByteList *input , DmtxByteList *output , int sizeIdxRequest ) ;
#line 225
static void StreamAdvanceFromBest(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                                  int targetState , int sizeIdxRequest ) ;
#line 227
static void AdvanceAsciiCompact(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                                int targetState , int inputNext , int sizeIdxRequest ) ;
#line 229
static void AdvanceCTX(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                       int targetState , int inputNext , int ctxValueCount , int sizeIdxRequest ) ;
#line 231
static void AdvanceEdifact(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                           int targetState , int inputNext , int sizeIdxRequest ) ;
#line 233
static int GetScheme(int state ) ;
#line 234
static unsigned int ValidStateSwitch(int fromState , int targetState ) ;
#line 237
static void EncodeNextChunkAscii(DmtxEncodeStream *stream , int option ) ;
#line 238
static void AppendValueAscii(DmtxEncodeStream *stream , DmtxByte value ) ;
#line 239
static void CompleteIfDoneAscii(DmtxEncodeStream *stream , int sizeIdxRequest ) ;
#line 240
static void PadRemainingInAscii(DmtxEncodeStream *stream , int sizeIdx ) ;
#line 241
static DmtxByteList EncodeTmpRemainingInAscii(DmtxEncodeStream *stream , DmtxByte *storage ,
                                              int capacity , unsigned int *passFail ) ;
#line 242
static DmtxByte Randomize253State(DmtxByte cwValue , int cwPosition ) ;
#line 245
static void EncodeNextChunkCTX(DmtxEncodeStream *stream , int sizeIdxRequest ) ;
#line 246
static void AppendValuesCTX(DmtxEncodeStream *stream , DmtxByteList *valueList ) ;
#line 247
static void AppendUnlatchCTX(DmtxEncodeStream *stream ) ;
#line 248
static void CompleteIfDoneCTX(DmtxEncodeStream *stream , int sizeIdxRequest ) ;
#line 249
static void CompletePartialC40Text(DmtxEncodeStream *stream , DmtxByteList *valueList ,
                                   int sizeIdxRequest ) ;
#line 250
static void CompletePartialX12(DmtxEncodeStream *stream , DmtxByteList *valueList ,
                               int sizeIdxRequest ) ;
#line 251
static unsigned int PartialX12ChunkRemains(DmtxEncodeStream *stream ) ;
#line 252
static void PushCTXValues(DmtxByteList *valueList , DmtxByte inputValue , int targetScheme ,
                          unsigned int *passFail ) ;
#line 253
static unsigned int IsCTX(int scheme ) ;
#line 254
static void ShiftValueListBy3(DmtxByteList *list , unsigned int *passFail ) ;
#line 257
static void EncodeNextChunkEdifact(DmtxEncodeStream *stream ) ;
#line 258
static void AppendValueEdifact(DmtxEncodeStream *stream , DmtxByte value ) ;
#line 259
static void CompleteIfDoneEdifact(DmtxEncodeStream *stream , int sizeIdxRequest ) ;
#line 262
static void EncodeNextChunkBase256(DmtxEncodeStream *stream ) ;
#line 263
static void AppendValueBase256(DmtxEncodeStream *stream , DmtxByte value ) ;
#line 264
static void CompleteIfDoneBase256(DmtxEncodeStream *stream , int sizeIdxRequest ) ;
#line 265
static void UpdateBase256ChainHeader(DmtxEncodeStream *stream , int perfectSizeIdx ) ;
#line 266
static void Base256OutputChainInsertFirst(DmtxEncodeStream *stream ) ;
#line 267
static void Base256OutputChainRemoveFirst(DmtxEncodeStream *stream ) ;
#line 268
static DmtxByte Randomize255State(DmtxByte value , int position ) ;
#line 269
static unsigned char UnRandomize255State(unsigned char value , int idx ) ;
#line 271 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static int const   dmtxNeighborNone  =    (int const   )8;
#line 272 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static int const   dmtxPatternX[8]  = 
#line 272
  {      (int const   )-1,      (int const   )0,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )0,      (int const   )-1,      (int const   )-1};
#line 273 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static int const   dmtxPatternY[8]  = 
#line 273
  {      (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )0};
#line 274 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static struct DmtxPointFlow_struct  const  dmtxBlankEdge  =    {0, 0, 0, -1, {-1, -1}};
#line 278 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static int rHvX[180]  = 
#line 278
  {      256,      256,      256,      256, 
        255,      255,      255,      254, 
        254,      253,      252,      251, 
        250,      249,      248,      247, 
        246,      245,      243,      242, 
        241,      239,      237,      236, 
        234,      232,      230,      228, 
        226,      224,      222,      219, 
        217,      215,      212,      210, 
        207,      204,      202,      199, 
        196,      193,      190,      187, 
        184,      181,      178,      175, 
        171,      168,      165,      161, 
        158,      154,      150,      147, 
        143,      139,      136,      132, 
        128,      124,      120,      116, 
        112,      108,      104,      100, 
        96,      92,      88,      83, 
        79,      75,      71,      66, 
        62,      58,      53,      49, 
        44,      40,      36,      31, 
        27,      22,      18,      13, 
        9,      4,      0,      -4, 
        -9,      -13,      -18,      -22, 
        -27,      -31,      -36,      -40, 
        -44,      -49,      -53,      -58, 
        -62,      -66,      -71,      -75, 
        -79,      -83,      -88,      -92, 
        -96,      -100,      -104,      -108, 
        -112,      -116,      -120,      -124, 
        -128,      -132,      -136,      -139, 
        -143,      -147,      -150,      -154, 
        -158,      -161,      -165,      -168, 
        -171,      -175,      -178,      -181, 
        -184,      -187,      -190,      -193, 
        -196,      -199,      -202,      -204, 
        -207,      -210,      -212,      -215, 
        -217,      -219,      -222,      -224, 
        -226,      -228,      -230,      -232, 
        -234,      -236,      -237,      -239, 
        -241,      -242,      -243,      -245, 
        -246,      -247,      -248,      -249, 
        -250,      -251,      -252,      -253, 
        -254,      -254,      -255,      -255, 
        -255,      -256,      -256,      -256};
#line 292 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static int rHvY[180]  = 
#line 292
  {      0,      4,      9,      13, 
        18,      22,      27,      31, 
        36,      40,      44,      49, 
        53,      58,      62,      66, 
        71,      75,      79,      83, 
        88,      92,      96,      100, 
        104,      108,      112,      116, 
        120,      124,      128,      132, 
        136,      139,      143,      147, 
        150,      154,      158,      161, 
        165,      168,      171,      175, 
        178,      181,      184,      187, 
        190,      193,      196,      199, 
        202,      204,      207,      210, 
        212,      215,      217,      219, 
        222,      224,      226,      228, 
        230,      232,      234,      236, 
        237,      239,      241,      242, 
        243,      245,      246,      247, 
        248,      249,      250,      251, 
        252,      253,      254,      254, 
        255,      255,      255,      256, 
        256,      256,      256,      256, 
        256,      256,      255,      255, 
        255,      254,      254,      253, 
        252,      251,      250,      249, 
        248,      247,      246,      245, 
        243,      242,      241,      239, 
        237,      236,      234,      232, 
        230,      228,      226,      224, 
        222,      219,      217,      215, 
        212,      210,      207,      204, 
        202,      199,      196,      193, 
        190,      187,      184,      181, 
        178,      175,      171,      168, 
        165,      161,      158,      154, 
        150,      147,      143,      139, 
        136,      132,      128,      124, 
        120,      116,      112,      108, 
        104,      100,      96,      92, 
        88,      83,      79,      75, 
        71,      66,      62,      58, 
        53,      49,      44,      40, 
        36,      31,      27,      22, 
        18,      13,      9,      4};
#line 321 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxstatic.h"
static char *dmtxErrorMessage[10]  = 
#line 321
  {      (char *)"Unknown error",      (char *)"Unsupported character",      (char *)"Not on byte boundary",      (char *)"Illegal parameter value", 
        (char *)"Encountered empty list",      (char *)"Out of bounds",      (char *)"Message too large",      (char *)"Can\'t compact non-digits", 
        (char *)"Encountered unexpected scheme",      (char *)"Encountered incomplete value list"};
#line 21 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
extern DmtxEncode *dmtxEncodeCreate(void) 
{ 
  DmtxEncode *enc ;
  void *tmp ;

  {
  {
#line 26
  tmp = calloc((size_t )1, sizeof(DmtxEncode ));
#line 26
  enc = (DmtxEncode *)tmp;
  }
#line 27
  if ((unsigned long )enc == (unsigned long )((void *)0)) {
#line 28
    return ((DmtxEncode *)((void *)0));
  }
  {
#line 30
  enc->scheme = 0;
#line 31
  enc->sizeIdxRequest = -2;
#line 32
  enc->marginSize = 10;
#line 33
  enc->moduleSize = 5;
#line 34
  enc->pixelPacking = 500;
#line 35
  enc->imageFlip = 0;
#line 36
  enc->rowPadBytes = 0;
#line 47
  dmtxMatrix3Identity((double (*)[3])(enc->xfrm));
  }
#line 49
  return (enc);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
extern unsigned int dmtxEncodeDestroy(DmtxEncode **enc ) 
{ 


  {
#line 60
  if ((unsigned long )enc == (unsigned long )((void *)0)) {
#line 61
    return (0U);
  } else
#line 60
  if ((unsigned long )*enc == (unsigned long )((void *)0)) {
#line 61
    return (0U);
  }
#line 64
  if ((unsigned long )(*enc)->image != (unsigned long )((void *)0)) {
#line 64
    if ((unsigned long )((*enc)->image)->pxl != (unsigned long )((void *)0)) {
      {
#line 65
      free((void *)((*enc)->image)->pxl);
#line 66
      ((*enc)->image)->pxl = (unsigned char *)((void *)0);
      }
    }
  }
  {
#line 69
  dmtxImageDestroy(& (*enc)->image);
#line 70
  dmtxMessageDestroy(& (*enc)->message);
#line 72
  free((void *)*enc);
#line 74
  *enc = (DmtxEncode *)((void *)0);
  }
#line 76
  return (1U);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
extern unsigned int dmtxEncodeSetProp(DmtxEncode *enc , int prop , int value ) 
{ 


  {
  {
#line 92
  if (prop == 100) {
#line 92
    goto case_100;
  }
#line 95
  if (prop == 101) {
#line 95
    goto case_101;
  }
#line 102
  if (prop == 102) {
#line 102
    goto case_102;
  }
#line 105
  if (prop == 103) {
#line 105
    goto case_103;
  }
#line 110
  if (prop == 302) {
#line 110
    goto case_302;
  }
#line 113
  if (prop == 307) {
#line 113
    goto case_307;
  }
#line 116
  if (prop == 305) {
#line 116
    goto case_305;
  }
#line 118
  goto switch_default;
  case_100: /* CIL Label */ 
#line 93
  enc->scheme = value;
#line 94
  goto switch_break;
  case_101: /* CIL Label */ 
#line 96
  if (value == -1) {
#line 97
    return (0U);
  }
#line 98
  enc->sizeIdxRequest = value;
#line 99
  goto switch_break;
  case_102: /* CIL Label */ 
#line 103
  enc->marginSize = value;
#line 104
  goto switch_break;
  case_103: /* CIL Label */ 
#line 106
  enc->moduleSize = value;
#line 107
  goto switch_break;
  case_302: /* CIL Label */ 
#line 111
  enc->pixelPacking = value;
#line 112
  goto switch_break;
  case_307: /* CIL Label */ 
#line 114
  enc->imageFlip = value;
#line 115
  goto switch_break;
  case_305: /* CIL Label */ 
#line 117
  enc->rowPadBytes = value;
  switch_default: /* CIL Label */ 
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 122
  return (1U);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
extern int dmtxEncodeGetProp(DmtxEncode *enc , int prop ) 
{ 


  {
  {
#line 135
  if (prop == 102) {
#line 135
    goto case_102;
  }
#line 137
  if (prop == 103) {
#line 137
    goto case_103;
  }
#line 139
  if (prop == 100) {
#line 139
    goto case_100;
  }
#line 141
  goto switch_default;
  case_102: /* CIL Label */ 
#line 136
  return (enc->marginSize);
  case_103: /* CIL Label */ 
#line 138
  return (enc->moduleSize);
  case_100: /* CIL Label */ 
#line 140
  return (enc->scheme);
  switch_default: /* CIL Label */ 
#line 142
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 145
  return (-1);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
extern unsigned int dmtxEncodeDataMatrix(DmtxEncode *enc , int inputSize , unsigned char *inputString ) 
{ 
  int sizeIdx ;
  int width ;
  int height ;
  int bitsPerPixel ;
  unsigned char *pxl ;
  DmtxByte outputStorage[4096] ;
  DmtxByteList output ;
  DmtxByteList tmp ;
  DmtxByteList input ;
  DmtxByteList tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 163
  tmp = dmtxByteListBuild(outputStorage, (int )sizeof(outputStorage));
#line 163
  output = tmp;
#line 164
  tmp___0 = dmtxByteListBuild(inputString, inputSize);
#line 164
  input = tmp___0;
#line 166
  input.length = inputSize;
#line 172
  sizeIdx = EncodeDataCodewords(& input, & output, enc->sizeIdxRequest, (DmtxScheme )enc->scheme);
  }
#line 173
  if (sizeIdx == -1) {
#line 174
    return (0U);
  } else
#line 173
  if (output.length <= 0) {
#line 174
    return (0U);
  }
#line 177
  if (sizeIdx != -2) {
#line 177
    if (! (sizeIdx != -3)) {
      {
#line 177
      __assert_fail("sizeIdx != DmtxSymbolSquareAuto && sizeIdx != DmtxSymbolRectAuto",
                    "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c",
                    177U, "dmtxEncodeDataMatrix");
      }
    }
  } else {
    {
#line 177
    __assert_fail("sizeIdx != DmtxSymbolSquareAuto && sizeIdx != DmtxSymbolRectAuto",
                  "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c",
                  177U, "dmtxEncodeDataMatrix");
    }
  }
  {
#line 180
  enc->region.sizeIdx = sizeIdx;
#line 181
  enc->region.symbolRows = dmtxGetSymbolAttribute(0, sizeIdx);
#line 182
  enc->region.symbolCols = dmtxGetSymbolAttribute(1, sizeIdx);
#line 183
  enc->region.mappingRows = dmtxGetSymbolAttribute(6, sizeIdx);
#line 184
  enc->region.mappingCols = dmtxGetSymbolAttribute(7, sizeIdx);
#line 187
  enc->message = dmtxMessageCreate(sizeIdx, 0);
#line 188
  (enc->message)->padCount = 0;
#line 189
  memcpy((void */* __restrict  */)(enc->message)->code, (void const   */* __restrict  */)output.b,
         (size_t )output.length);
#line 192
  RsEncode(enc->message, enc->region.sizeIdx);
#line 195
  ModulePlacementEcc200((enc->message)->array, (enc->message)->code, enc->region.sizeIdx,
                        7);
#line 198
  width = 2 * enc->marginSize + enc->region.symbolCols * enc->moduleSize;
#line 199
  height = 2 * enc->marginSize + enc->region.symbolRows * enc->moduleSize;
#line 200
  bitsPerPixel = GetBitsPerPixel(enc->pixelPacking);
  }
#line 201
  if (bitsPerPixel == -1) {
#line 202
    return (0U);
  }
#line 203
  if (! (bitsPerPixel % 8 == 0)) {
    {
#line 203
    __assert_fail("bitsPerPixel % 8 == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c",
                  203U, "dmtxEncodeDataMatrix");
    }
  }
  {
#line 206
  tmp___1 = malloc((size_t )((width * height) * (bitsPerPixel / 8) + enc->rowPadBytes));
#line 206
  pxl = (unsigned char *)tmp___1;
  }
#line 207
  if ((unsigned long )pxl == (unsigned long )((void *)0)) {
    {
#line 208
    perror("pixel malloc error");
    }
#line 209
    return (0U);
  }
  {
#line 212
  enc->image = dmtxImageCreate(pxl, width, height, enc->pixelPacking);
  }
#line 213
  if ((unsigned long )enc->image == (unsigned long )((void *)0)) {
    {
#line 214
    perror("image malloc error");
    }
#line 215
    return (0U);
  }
  {
#line 218
  dmtxImageSetProp(enc->image, 307, enc->imageFlip);
#line 219
  dmtxImageSetProp(enc->image, 305, enc->rowPadBytes);
#line 222
  PrintPattern(enc);
  }
#line 224
  return (1U);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
extern unsigned int dmtxEncodeDataMosaic(DmtxEncode *enc , int inputSize , unsigned char *inputString ) 
{ 
  unsigned char *inputStringR ;
  unsigned char *inputStringG ;
  unsigned char *inputStringB ;
  int tmpInputSize ;
  int inputSizeR ;
  int inputSizeG ;
  int inputSizeB ;
  int sizeIdxAttempt ;
  int sizeIdxFirst ;
  int sizeIdxLast ;
  int row ;
  int col ;
  int mappingRows ;
  int mappingCols ;
  DmtxEncode *encG ;
  DmtxEncode *encB ;

  {
  {
#line 256
  tmpInputSize = (inputSize + 2) / 3;
#line 257
  inputSizeR = tmpInputSize;
#line 258
  inputSizeG = tmpInputSize;
#line 259
  inputSizeB = inputSize - (inputSizeR + inputSizeG);
#line 261
  inputStringR = inputString;
#line 262
  inputStringG = inputStringR + inputSizeR;
#line 263
  inputStringB = inputStringG + inputSizeG;
#line 266
  sizeIdxFirst = FindSymbolSize(tmpInputSize, enc->sizeIdxRequest);
  }
#line 267
  if (sizeIdxFirst == -1) {
#line 268
    return (0U);
  }
#line 271
  if (enc->sizeIdxRequest == -2) {
#line 272
    sizeIdxLast = 23;
  } else
#line 273
  if (enc->sizeIdxRequest == -3) {
#line 274
    sizeIdxLast = 29;
  } else {
#line 276
    sizeIdxLast = sizeIdxFirst;
  }
#line 278
  encB = (DmtxEncode *)((void *)0);
#line 278
  encG = encB;
#line 281
  sizeIdxAttempt = sizeIdxFirst;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (sizeIdxAttempt <= sizeIdxLast)) {
#line 281
      goto while_break;
    }
    {
#line 283
    dmtxEncodeDestroy(& encG);
#line 284
    dmtxEncodeDestroy(& encB);
#line 286
    encG = dmtxEncodeCreate();
#line 287
    encB = dmtxEncodeCreate();
#line 290
    dmtxEncodeDataMatrix(enc, inputSizeR, inputStringR);
    }
#line 291
    if (enc->region.sizeIdx != sizeIdxAttempt) {
#line 292
      goto __Cont;
    }
    {
#line 295
    *encG = *enc;
#line 296
    dmtxEncodeDataMatrix(encG, inputSizeG, inputStringG);
    }
#line 297
    if (encG->region.sizeIdx != sizeIdxAttempt) {
#line 298
      goto __Cont;
    }
    {
#line 301
    *encB = *enc;
#line 302
    dmtxEncodeDataMatrix(encB, inputSizeB, inputStringB);
    }
#line 303
    if (encB->region.sizeIdx != sizeIdxAttempt) {
#line 304
      goto __Cont;
    }
#line 307
    goto while_break;
    __Cont: /* CIL Label */ 
#line 281
    sizeIdxAttempt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  if ((unsigned long )encG == (unsigned long )((void *)0)) {
    {
#line 312
    dmtxEncodeDestroy(& encG);
#line 313
    dmtxEncodeDestroy(& encB);
    }
#line 314
    return (0U);
  } else
#line 310
  if ((unsigned long )encB == (unsigned long )((void *)0)) {
    {
#line 312
    dmtxEncodeDestroy(& encG);
#line 313
    dmtxEncodeDestroy(& encB);
    }
#line 314
    return (0U);
  }
  {
#line 317
  dmtxEncodeSetProp(enc, 101, sizeIdxAttempt);
#line 321
  mappingRows = dmtxGetSymbolAttribute(6, sizeIdxAttempt);
#line 322
  mappingCols = dmtxGetSymbolAttribute(7, sizeIdxAttempt);
#line 324
  memset((void *)(enc->message)->array, 0, (sizeof(unsigned char ) * (unsigned long )enc->region.mappingRows) * (unsigned long )enc->region.mappingCols);
#line 327
  ModulePlacementEcc200((enc->message)->array, (enc->message)->code, sizeIdxAttempt,
                        1);
#line 330
  row = 0;
  }
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 330
    if (! (row < mappingRows)) {
#line 330
      goto while_break___0;
    }
#line 331
    col = 0;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (col < mappingCols)) {
#line 331
        goto while_break___1;
      }
#line 332
      *((enc->message)->array + (row * mappingCols + col)) = (unsigned char )((int )*((enc->message)->array + (row * mappingCols + col)) & 207);
#line 331
      col ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 330
    row ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 336
  ModulePlacementEcc200((enc->message)->array, (encG->message)->code, sizeIdxAttempt,
                        2);
#line 339
  row = 0;
  }
  {
#line 339
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 339
    if (! (row < mappingRows)) {
#line 339
      goto while_break___2;
    }
#line 340
    col = 0;
    {
#line 340
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 340
      if (! (col < mappingCols)) {
#line 340
        goto while_break___3;
      }
#line 341
      *((enc->message)->array + (row * mappingCols + col)) = (unsigned char )((int )*((enc->message)->array + (row * mappingCols + col)) & 207);
#line 340
      col ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 339
    row ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 345
  ModulePlacementEcc200((enc->message)->array, (encB->message)->code, sizeIdxAttempt,
                        4);
#line 348
  dmtxEncodeDestroy(& encG);
#line 349
  dmtxEncodeDestroy(& encB);
#line 351
  PrintPattern(enc);
  }
#line 353
  return (1U);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
static int EncodeDataCodewords(DmtxByteList *input , DmtxByteList *output , int sizeIdxRequest ,
                               DmtxScheme scheme ) 
{ 
  int sizeIdx ;

  {
  {
#line 376
  if ((int )scheme == -1) {
#line 376
    goto case_neg_1;
  }
#line 379
  if ((int )scheme == -2) {
#line 379
    goto case_neg_2;
  }
#line 382
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 377
  sizeIdx = EncodeOptimizeBest(input, output, sizeIdxRequest);
  }
#line 378
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 380
  sizeIdx = -1;
#line 381
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 383
  sizeIdx = EncodeSingleScheme(input, output, sizeIdxRequest, scheme);
  }
#line 384
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 387
  return (sizeIdx);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencode.c"
static void PrintPattern(DmtxEncode *enc ) 
{ 
  int i ;
  int j ;
  int symbolRow ;
  int symbolCol ;
  int pixelRow ;
  int pixelCol ;
  int moduleStatus ;
  size_t rowSize ;
  size_t height ;
  int rgb[3] ;
  double sxy ;
  double txy ;
  DmtxMatrix3 m1 ;
  DmtxMatrix3 m2 ;
  DmtxVector2 vIn ;
  DmtxVector2 vOut ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 408
  txy = (double )enc->marginSize;
#line 409
  sxy = 1.0 / (double )enc->moduleSize;
#line 411
  dmtxMatrix3Translate((double (*)[3])(m1), - txy, - txy);
#line 412
  dmtxMatrix3Scale((double (*)[3])(m2), sxy, - sxy);
#line 413
  dmtxMatrix3Multiply((double (*)[3])(enc->xfrm), (double (*)[3])(m1), (double (*)[3])(m2));
#line 415
  dmtxMatrix3Translate((double (*)[3])(m1), txy, txy);
#line 416
  dmtxMatrix3Scale((double (*)[3])(m2), (double )enc->moduleSize, (double )enc->moduleSize);
#line 417
  dmtxMatrix3Multiply((double (*)[3])(enc->rxfrm), (double (*)[3])(m2), (double (*)[3])(m1));
#line 419
  tmp = dmtxImageGetProp(enc->image, 306);
#line 419
  rowSize = (size_t )tmp;
#line 420
  tmp___0 = dmtxImageGetProp(enc->image, 301);
#line 420
  height = (size_t )tmp___0;
#line 422
  memset((void *)(enc->image)->pxl, 255, rowSize * height);
#line 424
  symbolRow = 0;
  }
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! (symbolRow < enc->region.symbolRows)) {
#line 424
      goto while_break;
    }
#line 425
    symbolCol = 0;
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! (symbolCol < enc->region.symbolCols)) {
#line 425
        goto while_break___0;
      }
      {
#line 427
      vIn.X = (double )symbolCol;
#line 428
      vIn.Y = (double )symbolRow;
#line 430
      dmtxMatrix3VMultiply(& vOut, & vIn, (double (*)[3])(enc->rxfrm));
#line 432
      pixelCol = (int )vOut.X;
#line 433
      pixelRow = (int )vOut.Y;
#line 435
      moduleStatus = dmtxSymbolModuleStatus(enc->message, enc->region.sizeIdx, symbolRow,
                                            symbolCol);
#line 438
      i = pixelRow;
      }
      {
#line 438
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 438
        if (! (i < pixelRow + enc->moduleSize)) {
#line 438
          goto while_break___1;
        }
#line 439
        j = pixelCol;
        {
#line 439
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 439
          if (! (j < pixelCol + enc->moduleSize)) {
#line 439
            goto while_break___2;
          }
#line 440
          if ((moduleStatus & 1) != 0) {
#line 440
            rgb[0] = 0;
          } else {
#line 440
            rgb[0] = 255;
          }
#line 441
          if ((moduleStatus & 2) != 0) {
#line 441
            rgb[1] = 0;
          } else {
#line 441
            rgb[1] = 255;
          }
#line 442
          if ((moduleStatus & 4) != 0) {
#line 442
            rgb[2] = 0;
          } else {
#line 442
            rgb[2] = 255;
          }
          {
#line 444
          dmtxImageSetPixelValue(enc->image, j, i, 0, rgb[0]);
#line 445
          dmtxImageSetPixelValue(enc->image, j, i, 1, rgb[1]);
#line 446
          dmtxImageSetPixelValue(enc->image, j, i, 2, rgb[2]);
#line 439
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 438
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 425
      symbolCol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 424
    symbolRow ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static DmtxEncodeStream StreamInit(DmtxByteList *input , DmtxByteList *output ) 
{ 
  DmtxEncodeStream stream ;

  {
#line 23
  stream.input = input;
#line 24
  stream.output = output;
#line 26
  stream.currentScheme = 0;
#line 27
  stream.inputNext = 0;
#line 28
  stream.outputChainValueCount = 0;
#line 29
  stream.outputChainWordCount = 0;
#line 30
  stream.reason = (char *)((void *)0);
#line 31
  stream.sizeIdx = -1;
#line 32
  stream.status = (DmtxStatus )0;
#line 34
  return (stream);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamCopy(DmtxEncodeStream *dst , DmtxEncodeStream *src ) 
{ 
  unsigned int passFail ;

  {
  {
#line 46
  dst->currentScheme = src->currentScheme;
#line 47
  dst->inputNext = src->inputNext;
#line 48
  dst->outputChainValueCount = src->outputChainValueCount;
#line 49
  dst->outputChainWordCount = src->outputChainWordCount;
#line 50
  dst->reason = src->reason;
#line 51
  dst->sizeIdx = src->sizeIdx;
#line 52
  dst->status = src->status;
#line 53
  dst->input = src->input;
#line 55
  dmtxByteListCopy(dst->output, (DmtxByteList const   *)src->output, & passFail);
  }
#line 56
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamMarkComplete(DmtxEncodeStream *stream , int sizeIdx ) 
{ 


  {
#line 65
  if ((unsigned int )stream->status == 0U) {
#line 67
    stream->sizeIdx = sizeIdx;
#line 68
    stream->status = (DmtxStatus )1;
#line 69
    if (! ((unsigned long )stream->reason == (unsigned long )((void *)0))) {
      {
#line 69
      __assert_fail("stream->reason == ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c",
                    69U, "StreamMarkComplete");
      }
    }
  }
#line 71
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamMarkInvalid(DmtxEncodeStream *stream , int reasonIdx ) 
{ 


  {
#line 80
  stream->status = (DmtxStatus )2;
#line 81
  stream->reason = dmtxErrorMessage[reasonIdx];
#line 82
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamMarkFatal(DmtxEncodeStream *stream , int reasonIdx ) 
{ 


  {
#line 91
  stream->status = (DmtxStatus )3;
#line 92
  stream->reason = dmtxErrorMessage[reasonIdx];
#line 93
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamOutputChainAppend(DmtxEncodeStream *stream , DmtxByte value ) 
{ 
  unsigned int passFail ;

  {
  {
#line 104
  dmtxByteListPush(stream->output, value, & passFail);
  }
#line 106
  if (passFail == 1U) {
#line 107
    (stream->outputChainWordCount) ++;
  } else {
    {
#line 109
    StreamMarkFatal(stream, 5);
    }
  }
#line 110
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static DmtxByte StreamOutputChainRemoveLast(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;
  unsigned int passFail ;

  {
#line 122
  if (stream->outputChainWordCount > 0) {
    {
#line 124
    value = dmtxByteListPop(stream->output, & passFail);
#line 125
    (stream->outputChainWordCount) --;
    }
  } else {
    {
#line 129
    value = (DmtxByte )0;
#line 130
    StreamMarkFatal(stream, 4);
    }
  }
#line 133
  return (value);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamOutputSet(DmtxEncodeStream *stream , int index , DmtxByte value ) 
{ 


  {
#line 143
  if (index < 0) {
    {
#line 144
    StreamMarkFatal(stream, 5);
    }
  } else
#line 143
  if (index >= (stream->output)->length) {
    {
#line 144
    StreamMarkFatal(stream, 5);
    }
  } else {
#line 146
    *((stream->output)->b + index) = value;
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static unsigned int StreamInputHasNext(DmtxEncodeStream *stream ) 
{ 
  int tmp ;

  {
#line 156
  if (stream->inputNext < (stream->input)->length) {
#line 156
    tmp = 1;
  } else {
#line 156
    tmp = 0;
  }
#line 156
  return ((unsigned int )tmp);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static DmtxByte StreamInputPeekNext(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;
  unsigned int tmp ;

  {
  {
#line 166
  value = (DmtxByte )0;
#line 168
  tmp = StreamInputHasNext(stream);
  }
#line 168
  if (tmp) {
#line 169
    value = *((stream->input)->b + stream->inputNext);
  } else {
    {
#line 171
    StreamMarkFatal(stream, 5);
    }
  }
#line 173
  return (value);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static DmtxByte StreamInputAdvanceNext(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;

  {
  {
#line 187
  value = StreamInputPeekNext(stream);
  }
#line 189
  if ((unsigned int )stream->status == 0U) {
#line 190
    (stream->inputNext) ++;
  }
#line 192
  return (value);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodestream.c"
static void StreamInputAdvancePrev(DmtxEncodeStream *stream ) 
{ 


  {
#line 204
  if (stream->inputNext > 0) {
#line 205
    (stream->inputNext) --;
  } else {
    {
#line 207
    StreamMarkFatal(stream, 5);
    }
  }
#line 208
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodescheme.c"
static int EncodeSingleScheme(DmtxByteList *input , DmtxByteList *output , int sizeIdxRequest ,
                              DmtxScheme scheme ) 
{ 
  DmtxEncodeStream stream ;
  unsigned int tmp ;

  {
  {
#line 89
  stream = StreamInit(input, output);
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((unsigned int )stream.status == 0U)) {
#line 92
      goto while_break;
    }
    {
#line 93
    EncodeNextChunk(& stream, (int )scheme, 0, sizeIdxRequest);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if ((unsigned int )stream.status != 1U) {
#line 97
    return (-1);
  } else {
    {
#line 96
    tmp = StreamInputHasNext(& stream);
    }
#line 96
    if (tmp) {
#line 97
      return (-1);
    }
  }
#line 99
  return (stream.sizeIdx);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodescheme.c"
static void EncodeNextChunk(DmtxEncodeStream *stream , int scheme , int option , int sizeIdxRequest ) 
{ 
  unsigned int tmp ;

  {
#line 113
  if (stream->currentScheme != 3) {
#line 113
    if (scheme == 3) {
      {
#line 115
      tmp = PartialX12ChunkRemains(stream);
      }
#line 115
      if (tmp) {
#line 116
        scheme = 0;
      }
    }
  }
#line 120
  if (stream->currentScheme != scheme) {
    {
#line 122
    EncodeChangeScheme(stream, (DmtxScheme )scheme, 0);
    }
#line 122
    if ((unsigned int )stream->status != 0U) {
#line 122
      return;
    }
#line 123
    if (stream->currentScheme != scheme) {
      {
#line 123
      StreamMarkFatal(stream, 8);
      }
#line 123
      return;
    }
  }
#line 127
  if (scheme == 4) {
    {
#line 128
    CompleteIfDoneEdifact(stream, sizeIdxRequest);
    }
  }
#line 128
  if ((unsigned int )stream->status != 0U) {
#line 128
    return;
  }
  {
#line 132
  if (stream->currentScheme == 0) {
#line 132
    goto case_0;
  }
#line 138
  if (stream->currentScheme == 3) {
#line 138
    goto case_3;
  }
#line 138
  if (stream->currentScheme == 2) {
#line 138
    goto case_3;
  }
#line 138
  if (stream->currentScheme == 1) {
#line 138
    goto case_3;
  }
#line 142
  if (stream->currentScheme == 4) {
#line 142
    goto case_4;
  }
#line 146
  if (stream->currentScheme == 5) {
#line 146
    goto case_5;
  }
#line 150
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 133
  EncodeNextChunkAscii(stream, option);
  }
#line 133
  if ((unsigned int )stream->status != 0U) {
#line 133
    return;
  }
  {
#line 134
  CompleteIfDoneAscii(stream, sizeIdxRequest);
  }
#line 134
  if ((unsigned int )stream->status != 0U) {
#line 134
    return;
  }
#line 135
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 139
  EncodeNextChunkCTX(stream, sizeIdxRequest);
  }
#line 139
  if ((unsigned int )stream->status != 0U) {
#line 139
    return;
  }
  {
#line 140
  CompleteIfDoneCTX(stream, sizeIdxRequest);
  }
#line 140
  if ((unsigned int )stream->status != 0U) {
#line 140
    return;
  }
#line 141
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 143
  EncodeNextChunkEdifact(stream);
  }
#line 143
  if ((unsigned int )stream->status != 0U) {
#line 143
    return;
  }
  {
#line 144
  CompleteIfDoneEdifact(stream, sizeIdxRequest);
  }
#line 144
  if ((unsigned int )stream->status != 0U) {
#line 144
    return;
  }
#line 145
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 147
  EncodeNextChunkBase256(stream);
  }
#line 147
  if ((unsigned int )stream->status != 0U) {
#line 147
    return;
  }
  {
#line 148
  CompleteIfDoneBase256(stream, sizeIdxRequest);
  }
#line 148
  if ((unsigned int )stream->status != 0U) {
#line 148
    return;
  }
#line 149
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 151
  StreamMarkFatal(stream, 0);
  }
#line 152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodescheme.c"
static void EncodeChangeScheme(DmtxEncodeStream *stream , DmtxScheme targetScheme ,
                               int unlatchType ) 
{ 


  {
#line 164
  if (stream->currentScheme == (int )targetScheme) {
#line 165
    return;
  }
  {
#line 172
  if (stream->currentScheme == 3) {
#line 172
    goto case_3;
  }
#line 172
  if (stream->currentScheme == 2) {
#line 172
    goto case_3;
  }
#line 172
  if (stream->currentScheme == 1) {
#line 172
    goto case_3;
  }
#line 178
  if (stream->currentScheme == 4) {
#line 178
    goto case_4;
  }
#line 184
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 173
  if (unlatchType == 0) {
    {
#line 175
    AppendUnlatchCTX(stream);
    }
#line 175
    if ((unsigned int )stream->status != 0U) {
#line 175
      return;
    }
  }
#line 177
  goto switch_break;
  case_4: /* CIL Label */ 
#line 179
  if (unlatchType == 0) {
    {
#line 181
    AppendValueEdifact(stream, (DmtxByte )31);
    }
#line 181
    if ((unsigned int )stream->status != 0U) {
#line 181
      return;
    }
  }
#line 183
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 186
  if (! (stream->currentScheme == 0)) {
#line 186
    if (! (stream->currentScheme == 5)) {
      {
#line 186
      __assert_fail("stream->currentScheme == DmtxSchemeAscii || stream->currentScheme == DmtxSchemeBase256",
                    "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodescheme.c",
                    187U, "EncodeChangeScheme");
      }
    }
  }
#line 188
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 190
  stream->currentScheme = 0;
  {
#line 195
  if ((int )targetScheme == 1) {
#line 195
    goto case_1___0;
  }
#line 198
  if ((int )targetScheme == 2) {
#line 198
    goto case_2___0;
  }
#line 201
  if ((int )targetScheme == 3) {
#line 201
    goto case_3___0;
  }
#line 204
  if ((int )targetScheme == 4) {
#line 204
    goto case_4___0;
  }
#line 207
  if ((int )targetScheme == 5) {
#line 207
    goto case_5;
  }
#line 210
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 196
  AppendValueAscii(stream, (DmtxByte )230);
  }
#line 196
  if ((unsigned int )stream->status != 0U) {
#line 196
    return;
  }
#line 197
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 199
  AppendValueAscii(stream, (DmtxByte )239);
  }
#line 199
  if ((unsigned int )stream->status != 0U) {
#line 199
    return;
  }
#line 200
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 202
  AppendValueAscii(stream, (DmtxByte )238);
  }
#line 202
  if ((unsigned int )stream->status != 0U) {
#line 202
    return;
  }
#line 203
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 205
  AppendValueAscii(stream, (DmtxByte )240);
  }
#line 205
  if ((unsigned int )stream->status != 0U) {
#line 205
    return;
  }
#line 206
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 208
  AppendValueAscii(stream, (DmtxByte )231);
  }
#line 208
  if ((unsigned int )stream->status != 0U) {
#line 208
    return;
  }
#line 209
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 212
  if (stream->currentScheme != 0) {
    {
#line 212
    StreamMarkFatal(stream, 8);
    }
#line 212
    return;
  }
#line 213
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 215
  stream->currentScheme = (int )targetScheme;
#line 218
  stream->outputChainWordCount = 0;
#line 219
  stream->outputChainValueCount = 0;
#line 222
  if ((int )targetScheme == 5) {
    {
#line 224
    UpdateBase256ChainHeader(stream, -1);
    }
#line 224
    if ((unsigned int )stream->status != 0U) {
#line 224
      return;
    }
  }
#line 226
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodescheme.c"
static int GetRemainingSymbolCapacity(int outputLength , int sizeIdx ) 
{ 
  int capacity ;
  int remaining ;

  {
#line 238
  if (sizeIdx == -1) {
#line 240
    remaining = -1;
  } else {
    {
#line 244
    capacity = dmtxGetSymbolAttribute(11, sizeIdx);
#line 245
    remaining = capacity - outputLength;
    }
  }
#line 248
  return (remaining);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static int EncodeOptimizeBest(DmtxByteList *input , DmtxByteList *output , int sizeIdxRequest ) 
{ 
  enum SchemeState state ;
  int inputNext ;
  int c40ValueCount ;
  int textValueCount ;
  int x12ValueCount ;
  int sizeIdx ;
  DmtxEncodeStream *winner ;
  unsigned int passFail ;
  DmtxEncodeStream streamsBest[17] ;
  DmtxEncodeStream streamsTemp[17] ;
  DmtxByte outputsBestStorage[17][4096] ;
  DmtxByte outputsTempStorage[17][4096] ;
  DmtxByte ctxTempStorage[4] ;
  DmtxByteList outputsBest[17] ;
  DmtxByteList outputsTemp[17] ;
  DmtxByteList ctxTemp ;
  DmtxByteList tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 88
  tmp = dmtxByteListBuild(ctxTempStorage, (int )sizeof(ctxTempStorage));
#line 88
  ctxTemp = tmp;
#line 91
  state = (enum SchemeState )0;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned int )state < 17U)) {
#line 91
      goto while_break;
    }
    {
#line 93
    outputsBest[state] = dmtxByteListBuild(outputsBestStorage[state], (int )sizeof(outputsBestStorage[state]));
#line 94
    outputsTemp[state] = dmtxByteListBuild(outputsTempStorage[state], (int )sizeof(outputsTempStorage[state]));
#line 95
    streamsBest[state] = StreamInit(input, & outputsBest[state]);
#line 96
    streamsTemp[state] = StreamInit(input, & outputsTemp[state]);
#line 91
    state = (enum SchemeState )((unsigned int )state + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  x12ValueCount = 0;
#line 99
  textValueCount = x12ValueCount;
#line 99
  c40ValueCount = textValueCount;
#line 101
  inputNext = 0;
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 101
    if (! (inputNext < input->length)) {
#line 101
      goto while_break___0;
    }
    {
#line 103
    StreamAdvanceFromBest(streamsTemp, streamsBest, 0, sizeIdxRequest);
#line 105
    AdvanceAsciiCompact(streamsTemp, streamsBest, 1, inputNext, sizeIdxRequest);
#line 106
    AdvanceAsciiCompact(streamsTemp, streamsBest, 2, inputNext, sizeIdxRequest);
#line 108
    AdvanceCTX(streamsTemp, streamsBest, 3, inputNext, c40ValueCount, sizeIdxRequest);
#line 109
    AdvanceCTX(streamsTemp, streamsBest, 4, inputNext, c40ValueCount, sizeIdxRequest);
#line 110
    AdvanceCTX(streamsTemp, streamsBest, 5, inputNext, c40ValueCount, sizeIdxRequest);
#line 112
    AdvanceCTX(streamsTemp, streamsBest, 6, inputNext, textValueCount, sizeIdxRequest);
#line 113
    AdvanceCTX(streamsTemp, streamsBest, 7, inputNext, textValueCount, sizeIdxRequest);
#line 114
    AdvanceCTX(streamsTemp, streamsBest, 8, inputNext, textValueCount, sizeIdxRequest);
#line 116
    AdvanceCTX(streamsTemp, streamsBest, 9, inputNext, x12ValueCount, sizeIdxRequest);
#line 117
    AdvanceCTX(streamsTemp, streamsBest, 10, inputNext, x12ValueCount, sizeIdxRequest);
#line 118
    AdvanceCTX(streamsTemp, streamsBest, 11, inputNext, x12ValueCount, sizeIdxRequest);
#line 120
    AdvanceEdifact(streamsTemp, streamsBest, 12, inputNext, sizeIdxRequest);
#line 121
    AdvanceEdifact(streamsTemp, streamsBest, 13, inputNext, sizeIdxRequest);
#line 122
    AdvanceEdifact(streamsTemp, streamsBest, 14, inputNext, sizeIdxRequest);
#line 123
    AdvanceEdifact(streamsTemp, streamsBest, 15, inputNext, sizeIdxRequest);
#line 125
    StreamAdvanceFromBest(streamsTemp, streamsBest, 16, sizeIdxRequest);
#line 128
    state = (enum SchemeState )0;
    }
    {
#line 128
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 128
      if (! ((unsigned int )state < 17U)) {
#line 128
        goto while_break___1;
      }
#line 130
      if ((unsigned int )streamsBest[state].status != 1U) {
        {
#line 131
        StreamCopy(& streamsBest[state], & streamsTemp[state]);
        }
      }
#line 128
      state = (enum SchemeState )((unsigned int )state + 1U);
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 134
    dmtxByteListClear(& ctxTemp);
#line 135
    PushCTXValues(& ctxTemp, *(input->b + inputNext), 1, & passFail);
    }
#line 136
    if (passFail == 1U) {
#line 136
      tmp___0 = ctxTemp.length;
    } else {
#line 136
      tmp___0 = 1;
    }
    {
#line 136
    c40ValueCount += tmp___0;
#line 138
    dmtxByteListClear(& ctxTemp);
#line 139
    PushCTXValues(& ctxTemp, *(input->b + inputNext), 2, & passFail);
    }
#line 140
    if (passFail == 1U) {
#line 140
      tmp___1 = ctxTemp.length;
    } else {
#line 140
      tmp___1 = 1;
    }
    {
#line 140
    textValueCount += tmp___1;
#line 142
    dmtxByteListClear(& ctxTemp);
#line 143
    PushCTXValues(& ctxTemp, *(input->b + inputNext), 3, & passFail);
    }
#line 144
    if (passFail == 1U) {
#line 144
      tmp___2 = ctxTemp.length;
    } else {
#line 144
      tmp___2 = 1;
    }
#line 144
    x12ValueCount += tmp___2;
#line 101
    inputNext ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  winner = (DmtxEncodeStream *)((void *)0);
#line 151
  state = (enum SchemeState )0;
  {
#line 151
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 151
    if (! ((unsigned int )state < 17U)) {
#line 151
      goto while_break___2;
    }
#line 153
    if ((unsigned int )streamsBest[state].status == 1U) {
#line 155
      if ((unsigned long )winner == (unsigned long )((void *)0)) {
#line 156
        winner = & streamsBest[state];
      } else
#line 155
      if ((streamsBest[state].output)->length < (winner->output)->length) {
#line 156
        winner = & streamsBest[state];
      }
    }
#line 151
    state = (enum SchemeState )((unsigned int )state + 1U);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 161
  if ((unsigned long )winner == (unsigned long )((void *)0)) {
#line 163
    sizeIdx = -1;
  } else {
    {
#line 167
    dmtxByteListCopy(output, (DmtxByteList const   *)winner->output, & passFail);
    }
#line 168
    if (passFail == 1U) {
#line 168
      sizeIdx = winner->sizeIdx;
    } else {
#line 168
      sizeIdx = -1;
    }
  }
#line 171
  return (sizeIdx);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static void StreamAdvanceFromBest(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                                  int targetState , int sizeIdxRequest ) 
{ 
  enum SchemeState fromState ;
  DmtxScheme targetScheme ;
  DmtxEncodeOption encodeOption ;
  DmtxByte outputTempStorage[4096] ;
  DmtxByteList outputTemp ;
  DmtxByteList tmp ;
  DmtxEncodeStream streamTemp ;
  DmtxEncodeStream *targetStream ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 187
  tmp = dmtxByteListBuild(outputTempStorage, (int )sizeof(outputTempStorage));
#line 187
  outputTemp = tmp;
#line 189
  targetStream = streamsNext + targetState;
#line 191
  streamTemp.output = & outputTemp;
#line 192
  tmp___0 = GetScheme(targetState);
#line 192
  targetScheme = (DmtxScheme )tmp___0;
  }
#line 194
  if (targetState == 0) {
#line 195
    encodeOption = (DmtxEncodeOption )2;
  } else
#line 196
  if (targetState == 1) {
#line 197
    encodeOption = (DmtxEncodeOption )1;
  } else
#line 196
  if (targetState == 2) {
#line 197
    encodeOption = (DmtxEncodeOption )1;
  } else {
#line 199
    encodeOption = (DmtxEncodeOption )0;
  }
#line 201
  fromState = (enum SchemeState )0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! ((unsigned int )fromState < 17U)) {
#line 201
      goto while_break;
    }
#line 203
    if ((unsigned int )(streamsBest + fromState)->status != 0U) {
#line 206
      goto __Cont;
    } else {
      {
#line 203
      tmp___1 = ValidStateSwitch((int )fromState, targetState);
      }
#line 203
      if (tmp___1 == 0U) {
#line 206
        goto __Cont;
      }
    }
    {
#line 209
    StreamCopy(& streamTemp, streamsBest + fromState);
#line 210
    EncodeNextChunk(& streamTemp, (int )targetScheme, (int )encodeOption, sizeIdxRequest);
    }
#line 212
    if ((unsigned int )fromState == 0U) {
      {
#line 215
      StreamCopy(targetStream, & streamTemp);
      }
    } else
#line 212
    if ((unsigned int )streamTemp.status != 2U) {
#line 212
      if ((streamTemp.output)->length < (targetStream->output)->length) {
        {
#line 215
        StreamCopy(targetStream, & streamTemp);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 201
    fromState = (enum SchemeState )((unsigned int )fromState + 1U);
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static void AdvanceAsciiCompact(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                                int targetState , int inputNext , int sizeIdxRequest ) 
{ 
  DmtxEncodeStream *currentStream ;
  DmtxEncodeStream *targetStream ;
  unsigned int isStartState ;

  {
#line 227
  currentStream = streamsBest + targetState;
#line 228
  targetStream = streamsNext + targetState;
  {
#line 233
  if (targetState == 1) {
#line 233
    goto case_1;
  }
#line 237
  if (targetState == 2) {
#line 237
    goto case_2;
  }
#line 241
  goto switch_default;
  case_1: /* CIL Label */ 
#line 234
  if (inputNext % 2 == 0) {
#line 234
    isStartState = 1U;
  } else {
#line 234
    isStartState = 0U;
  }
#line 235
  goto switch_break;
  case_2: /* CIL Label */ 
#line 238
  if (inputNext % 2 == 1) {
#line 238
    isStartState = 1U;
  } else {
#line 238
    isStartState = 0U;
  }
#line 239
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 242
  StreamMarkFatal(targetStream, 3);
  }
#line 243
  return;
  switch_break: /* CIL Label */ ;
  }
#line 246
  if (inputNext < currentStream->inputNext) {
    {
#line 248
    StreamCopy(targetStream, currentStream);
    }
  } else
#line 250
  if (isStartState == 1U) {
    {
#line 252
    StreamAdvanceFromBest(streamsNext, streamsBest, targetState, sizeIdxRequest);
    }
  } else {
    {
#line 256
    StreamCopy(targetStream, currentStream);
#line 257
    StreamMarkInvalid(targetStream, 0);
    }
  }
#line 259
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static void AdvanceCTX(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                       int targetState , int inputNext , int ctxValueCount , int sizeIdxRequest ) 
{ 
  DmtxEncodeStream *currentStream ;
  DmtxEncodeStream *targetStream ;
  unsigned int isStartState ;

  {
#line 268
  currentStream = streamsBest + targetState;
#line 269
  targetStream = streamsNext + targetState;
  {
#line 277
  if (targetState == 9) {
#line 277
    goto case_9;
  }
#line 277
  if (targetState == 6) {
#line 277
    goto case_9;
  }
#line 277
  if (targetState == 3) {
#line 277
    goto case_9;
  }
#line 283
  if (targetState == 10) {
#line 283
    goto case_10;
  }
#line 283
  if (targetState == 7) {
#line 283
    goto case_10;
  }
#line 283
  if (targetState == 4) {
#line 283
    goto case_10;
  }
#line 289
  if (targetState == 11) {
#line 289
    goto case_11;
  }
#line 289
  if (targetState == 8) {
#line 289
    goto case_11;
  }
#line 289
  if (targetState == 5) {
#line 289
    goto case_11;
  }
#line 293
  goto switch_default;
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 278
  if (ctxValueCount % 3 == 0) {
#line 278
    isStartState = 1U;
  } else {
#line 278
    isStartState = 0U;
  }
#line 279
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 284
  if (ctxValueCount % 3 == 1) {
#line 284
    isStartState = 1U;
  } else {
#line 284
    isStartState = 0U;
  }
#line 285
  goto switch_break;
  case_11: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 290
  if (ctxValueCount % 3 == 2) {
#line 290
    isStartState = 1U;
  } else {
#line 290
    isStartState = 0U;
  }
#line 291
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 294
  StreamMarkFatal(targetStream, 3);
  }
#line 295
  return;
  switch_break: /* CIL Label */ ;
  }
#line 298
  if (inputNext < currentStream->inputNext) {
    {
#line 300
    StreamCopy(targetStream, currentStream);
    }
  } else
#line 302
  if (isStartState == 1U) {
    {
#line 304
    StreamAdvanceFromBest(streamsNext, streamsBest, targetState, sizeIdxRequest);
    }
  } else {
    {
#line 308
    StreamCopy(targetStream, currentStream);
#line 309
    StreamMarkInvalid(targetStream, 0);
    }
  }
#line 311
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static void AdvanceEdifact(DmtxEncodeStream *streamsNext , DmtxEncodeStream *streamsBest ,
                           int targetState , int inputNext , int sizeIdxRequest ) 
{ 
  DmtxEncodeStream *currentStream ;
  DmtxEncodeStream *targetStream ;
  unsigned int isStartState ;

  {
#line 320
  currentStream = streamsBest + targetState;
#line 321
  targetStream = streamsNext + targetState;
  {
#line 326
  if (targetState == 12) {
#line 326
    goto case_12;
  }
#line 330
  if (targetState == 13) {
#line 330
    goto case_13;
  }
#line 334
  if (targetState == 14) {
#line 334
    goto case_14;
  }
#line 338
  if (targetState == 15) {
#line 338
    goto case_15;
  }
#line 342
  goto switch_default;
  case_12: /* CIL Label */ 
#line 327
  if (inputNext % 4 == 0) {
#line 327
    isStartState = 1U;
  } else {
#line 327
    isStartState = 0U;
  }
#line 328
  goto switch_break;
  case_13: /* CIL Label */ 
#line 331
  if (inputNext % 4 == 1) {
#line 331
    isStartState = 1U;
  } else {
#line 331
    isStartState = 0U;
  }
#line 332
  goto switch_break;
  case_14: /* CIL Label */ 
#line 335
  if (inputNext % 4 == 2) {
#line 335
    isStartState = 1U;
  } else {
#line 335
    isStartState = 0U;
  }
#line 336
  goto switch_break;
  case_15: /* CIL Label */ 
#line 339
  if (inputNext % 4 == 3) {
#line 339
    isStartState = 1U;
  } else {
#line 339
    isStartState = 0U;
  }
#line 340
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 343
  StreamMarkFatal(targetStream, 3);
  }
#line 344
  return;
  switch_break: /* CIL Label */ ;
  }
#line 347
  if (isStartState == 1U) {
    {
#line 349
    StreamAdvanceFromBest(streamsNext, streamsBest, targetState, sizeIdxRequest);
    }
  } else {
    {
#line 353
    StreamCopy(targetStream, currentStream);
    }
#line 354
    if ((unsigned int )currentStream->status == 0U) {
#line 354
      if (currentStream->currentScheme == 4) {
        {
#line 355
        EncodeNextChunk(targetStream, 4, 0, sizeIdxRequest);
        }
      } else {
        {
#line 357
        StreamMarkInvalid(targetStream, 0);
        }
      }
    } else {
      {
#line 357
      StreamMarkInvalid(targetStream, 0);
      }
    }
  }
#line 359
  return;
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static int GetScheme(int state ) 
{ 
  DmtxScheme scheme ;

  {
  {
#line 374
  if (state == 2) {
#line 374
    goto case_2;
  }
#line 374
  if (state == 1) {
#line 374
    goto case_2;
  }
#line 374
  if (state == 0) {
#line 374
    goto case_2;
  }
#line 379
  if (state == 5) {
#line 379
    goto case_5;
  }
#line 379
  if (state == 4) {
#line 379
    goto case_5;
  }
#line 379
  if (state == 3) {
#line 379
    goto case_5;
  }
#line 384
  if (state == 8) {
#line 384
    goto case_8;
  }
#line 384
  if (state == 7) {
#line 384
    goto case_8;
  }
#line 384
  if (state == 6) {
#line 384
    goto case_8;
  }
#line 389
  if (state == 11) {
#line 389
    goto case_11;
  }
#line 389
  if (state == 10) {
#line 389
    goto case_11;
  }
#line 389
  if (state == 9) {
#line 389
    goto case_11;
  }
#line 395
  if (state == 15) {
#line 395
    goto case_15;
  }
#line 395
  if (state == 14) {
#line 395
    goto case_15;
  }
#line 395
  if (state == 13) {
#line 395
    goto case_15;
  }
#line 395
  if (state == 12) {
#line 395
    goto case_15;
  }
#line 398
  if (state == 16) {
#line 398
    goto case_16;
  }
#line 401
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 375
  scheme = (DmtxScheme )0;
#line 376
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 380
  scheme = (DmtxScheme )1;
#line 381
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 385
  scheme = (DmtxScheme )2;
#line 386
  goto switch_break;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 390
  scheme = (DmtxScheme )3;
#line 391
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 396
  scheme = (DmtxScheme )4;
#line 397
  goto switch_break;
  case_16: /* CIL Label */ 
#line 399
  scheme = (DmtxScheme )5;
#line 400
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 402
  scheme = (DmtxScheme )-1;
#line 403
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 406
  return ((int )scheme);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeoptimize.c"
static unsigned int ValidStateSwitch(int fromState , int targetState ) 
{ 
  unsigned int validStateSwitch ;
  DmtxScheme fromScheme ;
  int tmp ;
  DmtxScheme toScheme ;
  int tmp___0 ;

  {
  {
#line 417
  tmp = GetScheme(fromState);
#line 417
  fromScheme = (DmtxScheme )tmp;
#line 418
  tmp___0 = GetScheme(targetState);
#line 418
  toScheme = (DmtxScheme )tmp___0;
  }
#line 420
  if ((int )fromScheme == (int )toScheme) {
#line 420
    if (fromState != targetState) {
#line 420
      if (fromState != 0) {
#line 420
        if (targetState != 0) {
#line 423
          validStateSwitch = 0U;
        } else {
#line 427
          validStateSwitch = 1U;
        }
      } else {
#line 427
        validStateSwitch = 1U;
      }
    } else {
#line 427
      validStateSwitch = 1U;
    }
  } else {
#line 427
    validStateSwitch = 1U;
  }
#line 430
  return (validStateSwitch);
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c"
static void EncodeNextChunkAscii(DmtxEncodeStream *stream , int option ) 
{ 
  DmtxByte v0 ;
  DmtxByte v1 ;
  unsigned int compactDigits ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 33
  tmp___0 = StreamInputHasNext(stream);
  }
#line 33
  if (tmp___0) {
    {
#line 35
    v0 = StreamInputAdvanceNext(stream);
    }
#line 35
    if ((unsigned int )stream->status != 0U) {
#line 35
      return;
    }
#line 37
    if (option == 1) {
#line 37
      goto _L;
    } else
#line 37
    if (option == 0) {
      _L: /* CIL Label */ 
      {
#line 37
      tmp = StreamInputHasNext(stream);
      }
#line 37
      if (tmp) {
        {
#line 40
        v1 = StreamInputPeekNext(stream);
        }
#line 40
        if ((unsigned int )stream->status != 0U) {
#line 40
          return;
        }
#line 41
        if ((int )v0 > 47) {
#line 41
          if ((int )v0 < 58) {
#line 41
            if ((int )v1 > 47) {
#line 41
              if ((int )v1 < 58) {
#line 41
                compactDigits = 1U;
              } else {
#line 41
                compactDigits = 0U;
              }
            } else {
#line 41
              compactDigits = 0U;
            }
          } else {
#line 41
            compactDigits = 0U;
          }
        } else {
#line 41
          compactDigits = 0U;
        }
      } else {
#line 45
        v1 = (DmtxByte )0;
#line 46
        compactDigits = 0U;
      }
    } else {
#line 45
      v1 = (DmtxByte )0;
#line 46
      compactDigits = 0U;
    }
#line 49
    if (compactDigits == 1U) {
      {
#line 52
      StreamInputAdvanceNext(stream);
      }
#line 52
      if ((unsigned int )stream->status != 0U) {
#line 52
        return;
      }
      {
#line 53
      AppendValueAscii(stream, (DmtxByte )((10 * ((int )v0 - 48) + ((int )v1 - 48)) + 130));
      }
#line 53
      if ((unsigned int )stream->status != 0U) {
#line 53
        return;
      }
    } else
#line 55
    if (option == 1) {
      {
#line 58
      StreamMarkInvalid(stream, 7);
      }
    } else
#line 63
    if ((int )v0 < 128) {
      {
#line 66
      AppendValueAscii(stream, (DmtxByte )((int )v0 + 1));
      }
#line 66
      if ((unsigned int )stream->status != 0U) {
#line 66
        return;
      }
    } else {
      {
#line 71
      AppendValueAscii(stream, (DmtxByte )235);
      }
#line 71
      if ((unsigned int )stream->status != 0U) {
#line 71
        return;
      }
      {
#line 72
      AppendValueAscii(stream, (DmtxByte )((int )v0 - 127));
      }
#line 72
      if ((unsigned int )stream->status != 0U) {
#line 72
        return;
      }
    }
  }
#line 76
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c"
static void AppendValueAscii(DmtxEncodeStream *stream , DmtxByte value ) 
{ 


  {
#line 85
  if (stream->currentScheme != 0) {
    {
#line 85
    StreamMarkFatal(stream, 8);
    }
#line 85
    return;
  }
  {
#line 87
  StreamOutputChainAppend(stream, value);
  }
#line 87
  if ((unsigned int )stream->status != 0U) {
#line 87
    return;
  }
#line 88
  (stream->outputChainValueCount) ++;
#line 89
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c"
static void CompleteIfDoneAscii(DmtxEncodeStream *stream , int sizeIdxRequest ) 
{ 
  int sizeIdx ;
  unsigned int tmp ;

  {
#line 100
  if ((unsigned int )stream->status == 1U) {
#line 101
    return;
  }
  {
#line 103
  tmp = StreamInputHasNext(stream);
  }
#line 103
  if (! tmp) {
    {
#line 105
    sizeIdx = FindSymbolSize((stream->output)->length, sizeIdxRequest);
    }
#line 105
    if (sizeIdx == -1) {
      {
#line 105
      StreamMarkInvalid(stream, 0);
      }
#line 105
      return;
    }
    {
#line 106
    PadRemainingInAscii(stream, sizeIdx);
    }
#line 106
    if ((unsigned int )stream->status != 0U) {
#line 106
      return;
    }
    {
#line 107
    StreamMarkComplete(stream, sizeIdx);
    }
  }
#line 109
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c"
static void PadRemainingInAscii(DmtxEncodeStream *stream , int sizeIdx ) 
{ 
  int symbolRemaining ;
  DmtxByte padValue ;

  {
#line 121
  if (stream->currentScheme != 0) {
    {
#line 121
    StreamMarkFatal(stream, 8);
    }
#line 121
    return;
  }
#line 122
  if (sizeIdx == -1) {
    {
#line 122
    StreamMarkInvalid(stream, 0);
    }
#line 122
    return;
  }
  {
#line 124
  symbolRemaining = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx);
  }
#line 127
  if (symbolRemaining > 0) {
    {
#line 129
    padValue = (DmtxByte )129;
#line 130
    StreamOutputChainAppend(stream, padValue);
    }
#line 130
    if ((unsigned int )stream->status != 0U) {
#line 130
      return;
    }
#line 131
    symbolRemaining --;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (symbolRemaining > 0)) {
#line 135
      goto while_break;
    }
    {
#line 137
    padValue = Randomize253State((DmtxByte )129, (stream->output)->length + 1);
#line 138
    StreamOutputChainAppend(stream, padValue);
    }
#line 138
    if ((unsigned int )stream->status != 0U) {
#line 138
      return;
    }
#line 139
    symbolRemaining --;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c"
static DmtxByteList EncodeTmpRemainingInAscii(DmtxEncodeStream *stream , DmtxByte *storage ,
                                              int capacity , unsigned int *passFail ) 
{ 
  DmtxEncodeStream streamAscii ;
  DmtxByteList output ;
  DmtxByteList tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 151
  tmp = dmtxByteListBuild(storage, capacity);
#line 151
  output = tmp;
#line 154
  streamAscii = *stream;
#line 155
  streamAscii.currentScheme = 0;
#line 156
  streamAscii.outputChainValueCount = 0;
#line 157
  streamAscii.outputChainWordCount = 0;
#line 158
  streamAscii.reason = (char *)((void *)0);
#line 159
  streamAscii.sizeIdx = -1;
#line 160
  streamAscii.status = (DmtxStatus )0;
#line 161
  streamAscii.output = & output;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    tmp___1 = dmtxByteListHasCapacity(streamAscii.output);
    }
#line 163
    if (! tmp___1) {
#line 163
      goto while_break;
    }
    {
#line 165
    tmp___0 = StreamInputHasNext(& streamAscii);
    }
#line 165
    if (tmp___0) {
      {
#line 166
      EncodeNextChunkAscii(& streamAscii, 0);
      }
    } else {
#line 168
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if ((unsigned int )streamAscii.status == 2U) {
#line 178
    *passFail = 0U;
  } else
#line 177
  if ((unsigned int )streamAscii.status == 3U) {
#line 178
    *passFail = 0U;
  } else {
#line 180
    *passFail = 1U;
  }
#line 182
  return (output);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c"
static DmtxByte Randomize253State(DmtxByte cwValue , int cwPosition ) 
{ 
  int pseudoRandom ;
  int tmp ;

  {
#line 196
  pseudoRandom = (149 * cwPosition) % 253 + 1;
#line 197
  tmp = (int )cwValue + pseudoRandom;
#line 198
  if (tmp > 254) {
#line 199
    tmp -= 254;
  }
#line 201
  if (tmp >= 0) {
#line 201
    if (! (tmp < 256)) {
      {
#line 201
      __assert_fail("tmp >= 0 && tmp < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c",
                    201U, "Randomize253State");
      }
    }
  } else {
    {
#line 201
    __assert_fail("tmp >= 0 && tmp < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeascii.c",
                  201U, "Randomize253State");
    }
  }
#line 203
  return ((DmtxByte )tmp);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void EncodeNextChunkCTX(DmtxEncodeStream *stream , int sizeIdxRequest ) 
{ 
  unsigned int passFail ;
  DmtxByte inputValue ;
  DmtxByte valueListStorage[6] ;
  DmtxByteList valueList ;
  DmtxByteList tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 36
  tmp = dmtxByteListBuild(valueListStorage, (int )sizeof(valueListStorage));
#line 36
  valueList = tmp;
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp___0 = StreamInputHasNext(stream);
    }
#line 38
    if (! tmp___0) {
#line 38
      goto while_break;
    }
    {
#line 40
    inputValue = StreamInputAdvanceNext(stream);
    }
#line 40
    if ((unsigned int )stream->status != 0U) {
#line 40
      return;
    }
    {
#line 43
    PushCTXValues(& valueList, inputValue, stream->currentScheme, & passFail);
    }
#line 44
    if (passFail == 0U) {
      {
#line 47
      StreamMarkInvalid(stream, 1);
      }
#line 48
      return;
    }
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      if (! (valueList.length >= 3)) {
#line 52
        goto while_break___0;
      }
      {
#line 54
      AppendValuesCTX(stream, & valueList);
      }
#line 54
      if ((unsigned int )stream->status != 0U) {
#line 54
        return;
      }
      {
#line 55
      ShiftValueListBy3(& valueList, & passFail);
      }
#line 55
      if (passFail == 0U) {
        {
#line 55
        StreamMarkFatal(stream, 0);
        }
#line 55
        return;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 59
    if (valueList.length == 0) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp___1 = StreamInputHasNext(stream);
  }
#line 68
  if (! tmp___1) {
#line 68
    if (valueList.length > 0) {
#line 70
      if (stream->currentScheme == 3) {
        {
#line 72
        CompletePartialX12(stream, & valueList, sizeIdxRequest);
        }
#line 72
        if ((unsigned int )stream->status != 0U) {
#line 72
          return;
        }
      } else {
        {
#line 76
        CompletePartialC40Text(stream, & valueList, sizeIdxRequest);
        }
#line 76
        if ((unsigned int )stream->status != 0U) {
#line 76
          return;
        }
      }
    }
  }
#line 79
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void AppendValuesCTX(DmtxEncodeStream *stream , DmtxByteList *valueList ) 
{ 
  int pairValue ;
  DmtxByte cw0 ;
  DmtxByte cw1 ;
  unsigned int tmp ;

  {
  {
#line 91
  tmp = IsCTX(stream->currentScheme);
  }
#line 91
  if (! tmp) {
    {
#line 93
    StreamMarkFatal(stream, 8);
    }
#line 94
    return;
  }
#line 97
  if (valueList->length < 3) {
    {
#line 99
    StreamMarkFatal(stream, 9);
    }
#line 100
    return;
  }
  {
#line 104
  pairValue = ((1600 * (int )*(valueList->b + 0) + 40 * (int )*(valueList->b + 1)) + (int )*(valueList->b + 2)) + 1;
#line 105
  cw0 = (DmtxByte )(pairValue / 256);
#line 106
  cw1 = (DmtxByte )(pairValue % 256);
#line 109
  StreamOutputChainAppend(stream, cw0);
  }
#line 109
  if ((unsigned int )stream->status != 0U) {
#line 109
    return;
  }
  {
#line 110
  StreamOutputChainAppend(stream, cw1);
  }
#line 110
  if ((unsigned int )stream->status != 0U) {
#line 110
    return;
  }
#line 113
  stream->outputChainValueCount += 3;
#line 114
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void AppendUnlatchCTX(DmtxEncodeStream *stream ) 
{ 
  unsigned int tmp ;

  {
  {
#line 123
  tmp = IsCTX(stream->currentScheme);
  }
#line 123
  if (! tmp) {
    {
#line 125
    StreamMarkFatal(stream, 8);
    }
#line 126
    return;
  }
#line 130
  if (stream->outputChainValueCount % 3 != 0) {
    {
#line 132
    StreamMarkInvalid(stream, 2);
    }
#line 133
    return;
  }
  {
#line 136
  StreamOutputChainAppend(stream, (DmtxByte )254);
  }
#line 136
  if ((unsigned int )stream->status != 0U) {
#line 136
    return;
  }
#line 138
  (stream->outputChainValueCount) ++;
#line 139
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void CompleteIfDoneCTX(DmtxEncodeStream *stream , int sizeIdxRequest ) 
{ 
  int sizeIdx ;
  int symbolRemaining ;
  unsigned int tmp ;

  {
#line 156
  if ((unsigned int )stream->status == 1U) {
#line 157
    return;
  }
  {
#line 159
  tmp = StreamInputHasNext(stream);
  }
#line 159
  if (! tmp) {
    {
#line 161
    sizeIdx = FindSymbolSize((stream->output)->length, sizeIdxRequest);
    }
#line 161
    if (sizeIdx == -1) {
      {
#line 161
      StreamMarkInvalid(stream, 0);
      }
#line 161
      return;
    }
    {
#line 162
    symbolRemaining = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx);
    }
#line 164
    if (symbolRemaining > 0) {
      {
#line 166
      EncodeChangeScheme(stream, (DmtxScheme )0, 0);
      }
#line 166
      if ((unsigned int )stream->status != 0U) {
#line 166
        return;
      }
      {
#line 167
      PadRemainingInAscii(stream, sizeIdx);
      }
    }
    {
#line 170
    StreamMarkComplete(stream, sizeIdx);
    }
  }
#line 172
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void CompletePartialC40Text(DmtxEncodeStream *stream , DmtxByteList *valueList ,
                                   int sizeIdxRequest ) 
{ 
  int i ;
  int sizeIdx1 ;
  int sizeIdx2 ;
  int symbolRemaining1 ;
  int symbolRemaining2 ;
  unsigned int passFail ;
  DmtxByte inputValue ;
  DmtxByte outputTmpStorage[4] ;
  DmtxByteList outputTmp ;
  DmtxByteList tmp ;

  {
  {
#line 208
  tmp = dmtxByteListBuild(outputTmpStorage, (int )sizeof(outputTmpStorage));
#line 208
  outputTmp = tmp;
  }
#line 210
  if (stream->currentScheme != 1) {
#line 210
    if (stream->currentScheme != 2) {
      {
#line 212
      StreamMarkFatal(stream, 8);
      }
#line 213
      return;
    }
  }
#line 217
  if (! (valueList->length == 1)) {
#line 217
    if (! (valueList->length == 2)) {
      {
#line 217
      __assert_fail("valueList->length == 1 || valueList->length == 2", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c",
                    217U, "CompletePartialC40Text");
      }
    }
  }
  {
#line 219
  sizeIdx1 = FindSymbolSize((stream->output)->length + 1, sizeIdxRequest);
#line 220
  sizeIdx2 = FindSymbolSize((stream->output)->length + 2, sizeIdxRequest);
#line 222
  symbolRemaining1 = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx1);
#line 223
  symbolRemaining2 = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx2);
  }
#line 225
  if (valueList->length == 2) {
#line 225
    if (symbolRemaining2 == 2) {
      {
#line 228
      dmtxByteListPush(valueList, (DmtxByte )0, & passFail);
      }
#line 228
      if (passFail == 0U) {
        {
#line 228
        StreamMarkFatal(stream, 0);
        }
#line 228
        return;
      }
      {
#line 229
      AppendValuesCTX(stream, valueList);
      }
#line 229
      if ((unsigned int )stream->status != 0U) {
#line 229
        return;
      }
      {
#line 230
      StreamMarkComplete(stream, sizeIdx2);
      }
    } else {
#line 225
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 240
    StreamInputAdvancePrev(stream);
    }
#line 240
    if ((unsigned int )stream->status != 0U) {
#line 240
      return;
    }
    {
#line 241
    inputValue = StreamInputPeekNext(stream);
    }
#line 241
    if ((unsigned int )stream->status != 0U) {
#line 241
      return;
    }
    {
#line 244
    PushCTXValues(& outputTmp, inputValue, stream->currentScheme, & passFail);
    }
#line 245
    if (valueList->length == 2) {
#line 245
      if (outputTmp.length == 1) {
        {
#line 246
        StreamInputAdvancePrev(stream);
        }
      }
    }
#line 246
    if ((unsigned int )stream->status != 0U) {
#line 246
      return;
    }
    {
#line 250
    outputTmp = EncodeTmpRemainingInAscii(stream, outputTmpStorage, (int )sizeof(outputTmpStorage),
                                          & passFail);
    }
#line 253
    if (passFail == 0U) {
      {
#line 255
      StreamMarkFatal(stream, 0);
      }
#line 256
      return;
    }
#line 259
    if (outputTmp.length == 1) {
#line 259
      if (symbolRemaining1 == 1) {
        {
#line 262
        EncodeChangeScheme(stream, (DmtxScheme )0, 1);
        }
#line 262
        if ((unsigned int )stream->status != 0U) {
#line 262
          return;
        }
        {
#line 263
        AppendValueAscii(stream, *(outputTmp.b + 0));
        }
#line 263
        if ((unsigned int )stream->status != 0U) {
#line 263
          return;
        }
        {
#line 266
        stream->inputNext = (stream->input)->length;
#line 267
        StreamMarkComplete(stream, sizeIdx1);
        }
      } else {
#line 259
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 272
      EncodeChangeScheme(stream, (DmtxScheme )0, 0);
      }
#line 272
      if ((unsigned int )stream->status != 0U) {
#line 272
        return;
      }
#line 273
      i = 0;
      {
#line 273
      while (1) {
        while_continue: /* CIL Label */ ;
#line 273
        if (! (i < outputTmp.length)) {
#line 273
          goto while_break;
        }
        {
#line 274
        AppendValueAscii(stream, *(outputTmp.b + i));
#line 273
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 274
      if ((unsigned int )stream->status != 0U) {
#line 274
        return;
      }
      {
#line 276
      sizeIdx1 = FindSymbolSize((stream->output)->length, sizeIdxRequest);
#line 277
      PadRemainingInAscii(stream, sizeIdx1);
#line 280
      stream->inputNext = (stream->input)->length;
#line 281
      StreamMarkComplete(stream, sizeIdx1);
      }
    }
  }
#line 284
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void CompletePartialX12(DmtxEncodeStream *stream , DmtxByteList *valueList ,
                               int sizeIdxRequest ) 
{ 
  int i ;
  int sizeIdx ;
  int symbolRemaining ;
  unsigned int passFail ;
  DmtxByte outputTmpStorage[2] ;
  DmtxByteList outputTmp ;

  {
#line 301
  if (stream->currentScheme != 3) {
    {
#line 303
    StreamMarkFatal(stream, 8);
    }
#line 304
    return;
  }
#line 308
  if (! (valueList->length == 1)) {
#line 308
    if (! (valueList->length == 2)) {
      {
#line 308
      __assert_fail("valueList->length == 1 || valueList->length == 2", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c",
                    308U, "CompletePartialX12");
      }
    }
  }
#line 311
  i = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i < valueList->length)) {
#line 311
      goto while_break;
    }
    {
#line 313
    StreamInputAdvancePrev(stream);
    }
#line 313
    if ((unsigned int )stream->status != 0U) {
#line 313
      return;
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  outputTmp = EncodeTmpRemainingInAscii(stream, outputTmpStorage, (int )sizeof(outputTmpStorage),
                                        & passFail);
#line 320
  sizeIdx = FindSymbolSize((stream->output)->length + 1, sizeIdxRequest);
#line 321
  symbolRemaining = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx);
  }
#line 323
  if (outputTmp.length == 1) {
#line 323
    if (symbolRemaining == 1) {
      {
#line 326
      EncodeChangeScheme(stream, (DmtxScheme )0, 1);
      }
#line 326
      if ((unsigned int )stream->status != 0U) {
#line 326
        return;
      }
      {
#line 327
      AppendValueAscii(stream, *(outputTmp.b + 0));
      }
#line 327
      if ((unsigned int )stream->status != 0U) {
#line 327
        return;
      }
      {
#line 330
      stream->inputNext = (stream->input)->length;
#line 331
      StreamMarkComplete(stream, sizeIdx);
      }
    } else {
#line 323
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 336
    EncodeChangeScheme(stream, (DmtxScheme )0, 0);
    }
#line 336
    if ((unsigned int )stream->status != 0U) {
#line 336
      return;
    }
#line 337
    i = 0;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      if (! (i < outputTmp.length)) {
#line 337
        goto while_break___0;
      }
      {
#line 338
      AppendValueAscii(stream, *(outputTmp.b + i));
#line 337
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 338
    if ((unsigned int )stream->status != 0U) {
#line 338
      return;
    }
    {
#line 340
    sizeIdx = FindSymbolSize((stream->output)->length, sizeIdxRequest);
#line 341
    PadRemainingInAscii(stream, sizeIdx);
#line 344
    stream->inputNext = (stream->input)->length;
#line 345
    StreamMarkComplete(stream, sizeIdx);
    }
  }
#line 347
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static unsigned int PartialX12ChunkRemains(DmtxEncodeStream *stream ) 
{ 
  DmtxEncodeStream streamTmp ;
  DmtxByte inputValue ;
  DmtxByte valueListStorage[6] ;
  DmtxByteList valueList ;
  DmtxByteList tmp ;
  unsigned int passFail ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 358
  tmp = dmtxByteListBuild(valueListStorage, (int )sizeof(valueListStorage));
#line 358
  valueList = tmp;
#line 362
  streamTmp = *stream;
#line 363
  streamTmp.currentScheme = 3;
#line 364
  streamTmp.outputChainValueCount = 0;
#line 365
  streamTmp.outputChainWordCount = 0;
#line 366
  streamTmp.reason = (char *)((void *)0);
#line 367
  streamTmp.sizeIdx = -1;
#line 368
  streamTmp.status = (DmtxStatus )0;
#line 369
  streamTmp.output = (DmtxByteList *)((void *)0);
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 371
    tmp___0 = StreamInputHasNext(& streamTmp);
    }
#line 371
    if (! tmp___0) {
#line 371
      goto while_break;
    }
    {
#line 373
    inputValue = StreamInputAdvanceNext(& streamTmp);
    }
#line 374
    if ((unsigned int )stream->status != 0U) {
      {
#line 376
      StreamMarkInvalid(stream, 0);
      }
#line 377
      return (0U);
    }
    {
#line 381
    PushCTXValues(& valueList, inputValue, streamTmp.currentScheme, & passFail);
    }
#line 382
    if (passFail == 0U) {
      {
#line 384
      StreamMarkInvalid(stream, 0);
      }
#line 385
      return (0U);
    }
#line 389
    if (valueList.length >= 3) {
#line 390
      return (0U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (valueList.length == 0) {
#line 393
    tmp___1 = 0;
  } else {
#line 393
    tmp___1 = 1;
  }
#line 393
  return ((unsigned int )tmp___1);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void PushCTXValues(DmtxByteList *valueList , DmtxByte inputValue , int targetScheme ,
                          unsigned int *passFail ) 
{ 


  {
#line 404
  if (! (valueList->length <= 2)) {
    {
#line 404
    __assert_fail("valueList->length <= 2", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c",
                  404U, "PushCTXValues");
    }
  }
#line 407
  if ((int )inputValue > 127) {
#line 409
    if (targetScheme == 3) {
#line 411
      *passFail = 0U;
#line 412
      return;
    } else {
      {
#line 416
      dmtxByteListPush(valueList, (DmtxByte )1, passFail);
      }
#line 416
      if (*passFail == 0U) {
#line 416
        return;
      }
      {
#line 417
      dmtxByteListPush(valueList, (DmtxByte )30, passFail);
      }
#line 417
      if (*passFail == 0U) {
#line 417
        return;
      }
#line 418
      inputValue = (DmtxByte )((int )inputValue - 128);
    }
  }
#line 423
  if (targetScheme == 3) {
#line 425
    if ((int )inputValue == 13) {
      {
#line 427
      dmtxByteListPush(valueList, (DmtxByte )0, passFail);
      }
#line 427
      if (*passFail == 0U) {
#line 427
        return;
      }
    } else
#line 429
    if ((int )inputValue == 42) {
      {
#line 431
      dmtxByteListPush(valueList, (DmtxByte )1, passFail);
      }
#line 431
      if (*passFail == 0U) {
#line 431
        return;
      }
    } else
#line 433
    if ((int )inputValue == 62) {
      {
#line 435
      dmtxByteListPush(valueList, (DmtxByte )2, passFail);
      }
#line 435
      if (*passFail == 0U) {
#line 435
        return;
      }
    } else
#line 437
    if ((int )inputValue == 32) {
      {
#line 439
      dmtxByteListPush(valueList, (DmtxByte )3, passFail);
      }
#line 439
      if (*passFail == 0U) {
#line 439
        return;
      }
    } else
#line 441
    if ((int )inputValue >= 48) {
#line 441
      if ((int )inputValue <= 57) {
        {
#line 443
        dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 44), passFail);
        }
#line 443
        if (*passFail == 0U) {
#line 443
          return;
        }
      } else {
#line 441
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 445
    if ((int )inputValue >= 65) {
#line 445
      if ((int )inputValue <= 90) {
        {
#line 447
        dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 51), passFail);
        }
#line 447
        if (*passFail == 0U) {
#line 447
          return;
        }
      } else {
#line 451
        *passFail = 0U;
#line 452
        return;
      }
    } else {
#line 451
      *passFail = 0U;
#line 452
      return;
    }
  } else
#line 458
  if ((int )inputValue <= 31) {
    {
#line 460
    dmtxByteListPush(valueList, (DmtxByte )0, passFail);
    }
#line 460
    if (*passFail == 0U) {
#line 460
      return;
    }
    {
#line 461
    dmtxByteListPush(valueList, inputValue, passFail);
    }
#line 461
    if (*passFail == 0U) {
#line 461
      return;
    }
  } else
#line 463
  if ((int )inputValue == 32) {
    {
#line 465
    dmtxByteListPush(valueList, (DmtxByte )3, passFail);
    }
#line 465
    if (*passFail == 0U) {
#line 465
      return;
    }
  } else
#line 467
  if ((int )inputValue <= 47) {
    {
#line 469
    dmtxByteListPush(valueList, (DmtxByte )1, passFail);
    }
#line 469
    if (*passFail == 0U) {
#line 469
      return;
    }
    {
#line 470
    dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 33), passFail);
    }
#line 470
    if (*passFail == 0U) {
#line 470
      return;
    }
  } else
#line 472
  if ((int )inputValue <= 57) {
    {
#line 474
    dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 44), passFail);
    }
#line 474
    if (*passFail == 0U) {
#line 474
      return;
    }
  } else
#line 476
  if ((int )inputValue <= 64) {
    {
#line 478
    dmtxByteListPush(valueList, (DmtxByte )1, passFail);
    }
#line 478
    if (*passFail == 0U) {
#line 478
      return;
    }
    {
#line 479
    dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 43), passFail);
    }
#line 479
    if (*passFail == 0U) {
#line 479
      return;
    }
  } else
#line 481
  if ((int )inputValue <= 90) {
#line 481
    if (targetScheme == 1) {
      {
#line 483
      dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 51), passFail);
      }
#line 483
      if (*passFail == 0U) {
#line 483
        return;
      }
    } else {
#line 481
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 485
  if ((int )inputValue <= 90) {
#line 485
    if (targetScheme == 2) {
      {
#line 487
      dmtxByteListPush(valueList, (DmtxByte )2, passFail);
      }
#line 487
      if (*passFail == 0U) {
#line 487
        return;
      }
      {
#line 488
      dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 64), passFail);
      }
#line 488
      if (*passFail == 0U) {
#line 488
        return;
      }
    } else {
#line 485
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 490
  if ((int )inputValue <= 95) {
    {
#line 492
    dmtxByteListPush(valueList, (DmtxByte )1, passFail);
    }
#line 492
    if (*passFail == 0U) {
#line 492
      return;
    }
    {
#line 493
    dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 69), passFail);
    }
#line 493
    if (*passFail == 0U) {
#line 493
      return;
    }
  } else
#line 495
  if ((int )inputValue == 96) {
#line 495
    if (targetScheme == 2) {
      {
#line 497
      dmtxByteListPush(valueList, (DmtxByte )2, passFail);
      }
#line 497
      if (*passFail == 0U) {
#line 497
        return;
      }
      {
#line 498
      dmtxByteListPush(valueList, (DmtxByte )0, passFail);
      }
#line 498
      if (*passFail == 0U) {
#line 498
        return;
      }
    } else {
#line 495
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 500
  if ((int )inputValue <= 122) {
#line 500
    if (targetScheme == 2) {
      {
#line 502
      dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 83), passFail);
      }
#line 502
      if (*passFail == 0U) {
#line 502
        return;
      }
    } else {
#line 500
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 504
  if ((int )inputValue <= 127) {
    {
#line 506
    dmtxByteListPush(valueList, (DmtxByte )2, passFail);
    }
#line 506
    if (*passFail == 0U) {
#line 506
      return;
    }
    {
#line 507
    dmtxByteListPush(valueList, (DmtxByte )((int )inputValue - 96), passFail);
    }
#line 507
    if (*passFail == 0U) {
#line 507
      return;
    }
  } else {
#line 511
    *passFail = 0U;
#line 512
    return;
  }
#line 516
  *passFail = 1U;
#line 517
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static unsigned int IsCTX(int scheme ) 
{ 
  unsigned int isCTX ;

  {
#line 528
  if (scheme == 1) {
#line 529
    isCTX = 1U;
  } else
#line 528
  if (scheme == 2) {
#line 529
    isCTX = 1U;
  } else
#line 528
  if (scheme == 3) {
#line 529
    isCTX = 1U;
  } else {
#line 531
    isCTX = 0U;
  }
#line 533
  return (isCTX);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodec40textx12.c"
static void ShiftValueListBy3(DmtxByteList *list , unsigned int *passFail ) 
{ 
  int i ;

  {
#line 546
  i = 0;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (i < list->length - 3)) {
#line 546
      goto while_break;
    }
#line 547
    *(list->b + i) = *(list->b + (i + 3));
#line 546
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  i = 0;
  {
#line 550
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 550
    if (! (i < 3)) {
#line 550
      goto while_break___0;
    }
    {
#line 552
    dmtxByteListPop(list, passFail);
    }
#line 553
    if (*passFail == 0U) {
#line 554
      return;
    }
#line 556
    if (list->length == 0) {
#line 557
      goto while_break___0;
    }
#line 550
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 560
  *passFail = 1U;
#line 561
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeedifact.c"
static void EncodeNextChunkEdifact(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;
  unsigned int tmp ;

  {
  {
#line 23
  tmp = StreamInputHasNext(stream);
  }
#line 23
  if (tmp) {
    {
#line 25
    value = StreamInputAdvanceNext(stream);
    }
#line 25
    if ((unsigned int )stream->status != 0U) {
#line 25
      return;
    }
    {
#line 26
    AppendValueEdifact(stream, value);
    }
#line 26
    if ((unsigned int )stream->status != 0U) {
#line 26
      return;
    }
  }
#line 28
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeedifact.c"
static void AppendValueEdifact(DmtxEncodeStream *stream , DmtxByte value ) 
{ 
  DmtxByte edifactValue ;
  DmtxByte previousOutput ;

  {
#line 39
  if (stream->currentScheme != 4) {
    {
#line 39
    StreamMarkFatal(stream, 8);
    }
#line 39
    return;
  }
#line 41
  if ((int )value < 31) {
    {
#line 43
    StreamMarkInvalid(stream, 1);
    }
#line 44
    return;
  } else
#line 41
  if ((int )value > 94) {
    {
#line 43
    StreamMarkInvalid(stream, 1);
    }
#line 44
    return;
  }
#line 47
  edifactValue = (DmtxByte )(((int )value & 63) << 2);
  {
#line 51
  if (stream->outputChainValueCount % 4 == 0) {
#line 51
    goto case_0;
  }
#line 54
  if (stream->outputChainValueCount % 4 == 1) {
#line 54
    goto case_1;
  }
#line 59
  if (stream->outputChainValueCount % 4 == 2) {
#line 59
    goto case_2;
  }
#line 64
  if (stream->outputChainValueCount % 4 == 3) {
#line 64
    goto case_3;
  }
#line 49
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 52
  StreamOutputChainAppend(stream, edifactValue);
  }
#line 52
  if ((unsigned int )stream->status != 0U) {
#line 52
    return;
  }
#line 53
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 55
  previousOutput = StreamOutputChainRemoveLast(stream);
  }
#line 55
  if ((unsigned int )stream->status != 0U) {
#line 55
    return;
  }
  {
#line 56
  StreamOutputChainAppend(stream, (DmtxByte )((int )previousOutput | ((int )edifactValue >> 6)));
  }
#line 56
  if ((unsigned int )stream->status != 0U) {
#line 56
    return;
  }
  {
#line 57
  StreamOutputChainAppend(stream, (DmtxByte )((int )edifactValue << 2));
  }
#line 57
  if ((unsigned int )stream->status != 0U) {
#line 57
    return;
  }
#line 58
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 60
  previousOutput = StreamOutputChainRemoveLast(stream);
  }
#line 60
  if ((unsigned int )stream->status != 0U) {
#line 60
    return;
  }
  {
#line 61
  StreamOutputChainAppend(stream, (DmtxByte )((int )previousOutput | ((int )edifactValue >> 4)));
  }
#line 61
  if ((unsigned int )stream->status != 0U) {
#line 61
    return;
  }
  {
#line 62
  StreamOutputChainAppend(stream, (DmtxByte )((int )edifactValue << 4));
  }
#line 62
  if ((unsigned int )stream->status != 0U) {
#line 62
    return;
  }
#line 63
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 65
  previousOutput = StreamOutputChainRemoveLast(stream);
  }
#line 65
  if ((unsigned int )stream->status != 0U) {
#line 65
    return;
  }
  {
#line 66
  StreamOutputChainAppend(stream, (DmtxByte )((int )previousOutput | ((int )edifactValue >> 2)));
  }
#line 66
  if ((unsigned int )stream->status != 0U) {
#line 66
    return;
  }
#line 67
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 70
  (stream->outputChainValueCount) ++;
#line 71
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodeedifact.c"
static void CompleteIfDoneEdifact(DmtxEncodeStream *stream , int sizeIdxRequest ) 
{ 
  int i ;
  int sizeIdx ;
  int symbolRemaining ;
  unsigned int cleanBoundary ;
  unsigned int passFail ;
  DmtxByte outputTmpStorage[3] ;
  DmtxByteList outputTmp ;
  unsigned int tmp ;

  {
#line 100
  if ((unsigned int )stream->status == 1U) {
#line 101
    return;
  }
#line 109
  if (stream->outputChainValueCount % 4 == 0) {
#line 109
    cleanBoundary = 1U;
  } else {
#line 109
    cleanBoundary = 0U;
  }
#line 111
  if (cleanBoundary == 1U) {
    {
#line 114
    outputTmp = EncodeTmpRemainingInAscii(stream, outputTmpStorage, (int )sizeof(outputTmpStorage),
                                          & passFail);
    }
#line 117
    if (passFail == 0U) {
      {
#line 119
      StreamMarkFatal(stream, 0);
      }
#line 120
      return;
    }
#line 123
    if (outputTmp.length < 3) {
      {
#line 126
      sizeIdx = FindSymbolSize((stream->output)->length + outputTmp.length, sizeIdxRequest);
      }
#line 126
      if (sizeIdx == -1) {
        {
#line 126
        StreamMarkInvalid(stream, 0);
        }
#line 126
        return;
      }
      {
#line 129
      symbolRemaining = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx);
      }
#line 129
      if ((unsigned int )stream->status != 0U) {
#line 129
        return;
      }
#line 131
      if (symbolRemaining < 3) {
#line 131
        if (outputTmp.length <= symbolRemaining) {
          {
#line 133
          EncodeChangeScheme(stream, (DmtxScheme )0, 1);
          }
#line 133
          if ((unsigned int )stream->status != 0U) {
#line 133
            return;
          }
#line 135
          i = 0;
          {
#line 135
          while (1) {
            while_continue: /* CIL Label */ ;
#line 135
            if (! (i < outputTmp.length)) {
#line 135
              goto while_break;
            }
            {
#line 137
            AppendValueAscii(stream, *(outputTmp.b + i));
            }
#line 137
            if ((unsigned int )stream->status != 0U) {
#line 137
              return;
            }
#line 135
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 141
          stream->inputNext = (stream->input)->length;
#line 144
          PadRemainingInAscii(stream, sizeIdx);
          }
#line 144
          if ((unsigned int )stream->status != 0U) {
#line 144
            return;
          }
          {
#line 145
          StreamMarkComplete(stream, sizeIdx);
          }
#line 146
          return;
        }
      }
    }
  }
  {
#line 151
  tmp = StreamInputHasNext(stream);
  }
#line 151
  if (! tmp) {
    {
#line 153
    sizeIdx = FindSymbolSize((stream->output)->length, sizeIdxRequest);
    }
#line 153
    if (sizeIdx == -1) {
      {
#line 153
      StreamMarkInvalid(stream, 0);
      }
#line 153
      return;
    }
    {
#line 154
    symbolRemaining = GetRemainingSymbolCapacity((stream->output)->length, sizeIdx);
    }
#line 154
    if ((unsigned int )stream->status != 0U) {
#line 154
      return;
    }
#line 157
    if (cleanBoundary == 0U) {
#line 157
      goto _L;
    } else
#line 157
    if (symbolRemaining > 0) {
      _L: /* CIL Label */ 
      {
#line 159
      EncodeChangeScheme(stream, (DmtxScheme )0, 0);
      }
#line 159
      if ((unsigned int )stream->status != 0U) {
#line 159
        return;
      }
      {
#line 160
      sizeIdx = FindSymbolSize((stream->output)->length, sizeIdxRequest);
      }
#line 160
      if (sizeIdx == -1) {
        {
#line 160
        StreamMarkInvalid(stream, 0);
        }
#line 160
        return;
      }
      {
#line 161
      PadRemainingInAscii(stream, sizeIdx);
      }
#line 161
      if ((unsigned int )stream->status != 0U) {
#line 161
        return;
      }
    }
    {
#line 164
    StreamMarkComplete(stream, sizeIdx);
    }
  }
#line 166
  return;
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static void EncodeNextChunkBase256(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;
  unsigned int tmp ;

  {
  {
#line 23
  tmp = StreamInputHasNext(stream);
  }
#line 23
  if (tmp) {
    {
#line 25
    value = StreamInputAdvanceNext(stream);
    }
#line 25
    if ((unsigned int )stream->status != 0U) {
#line 25
      return;
    }
    {
#line 26
    AppendValueBase256(stream, value);
    }
#line 26
    if ((unsigned int )stream->status != 0U) {
#line 26
      return;
    }
  }
#line 28
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static void AppendValueBase256(DmtxEncodeStream *stream , DmtxByte value ) 
{ 
  DmtxByte tmp ;

  {
#line 37
  if (stream->currentScheme != 5) {
    {
#line 37
    StreamMarkFatal(stream, 8);
    }
#line 37
    return;
  }
  {
#line 39
  tmp = Randomize255State(value, (stream->output)->length + 1);
#line 39
  StreamOutputChainAppend(stream, tmp);
  }
#line 39
  if ((unsigned int )stream->status != 0U) {
#line 39
    return;
  }
  {
#line 40
  (stream->outputChainValueCount) ++;
#line 42
  UpdateBase256ChainHeader(stream, -1);
  }
#line 42
  if ((unsigned int )stream->status != 0U) {
#line 42
    return;
  }
#line 43
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static void CompleteIfDoneBase256(DmtxEncodeStream *stream , int sizeIdxRequest ) 
{ 
  int sizeIdx ;
  int headerByteCount ;
  int outputLength ;
  int symbolRemaining ;
  unsigned int tmp ;

  {
#line 57
  if ((unsigned int )stream->status == 1U) {
#line 58
    return;
  }
  {
#line 60
  tmp = StreamInputHasNext(stream);
  }
#line 60
  if (! tmp) {
#line 62
    headerByteCount = stream->outputChainWordCount - stream->outputChainValueCount;
#line 63
    if (! (headerByteCount == 1)) {
#line 63
      if (! (headerByteCount == 2)) {
        {
#line 63
        __assert_fail("headerByteCount == 1 || headerByteCount == 2", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c",
                      63U, "CompleteIfDoneBase256");
        }
      }
    }
#line 66
    if (headerByteCount == 2) {
      {
#line 69
      outputLength = (stream->output)->length - 1;
#line 70
      sizeIdx = FindSymbolSize(outputLength, sizeIdxRequest);
      }
#line 71
      if (sizeIdx != -1) {
        {
#line 73
        symbolRemaining = GetRemainingSymbolCapacity(outputLength, sizeIdx);
        }
#line 75
        if (symbolRemaining == 0) {
          {
#line 78
          UpdateBase256ChainHeader(stream, sizeIdx);
          }
#line 78
          if ((unsigned int )stream->status != 0U) {
#line 78
            return;
          }
          {
#line 79
          StreamMarkComplete(stream, sizeIdx);
          }
#line 80
          return;
        }
      }
    }
    {
#line 86
    sizeIdx = FindSymbolSize((stream->output)->length, sizeIdxRequest);
    }
#line 86
    if (sizeIdx == -1) {
      {
#line 86
      StreamMarkInvalid(stream, 0);
      }
#line 86
      return;
    }
    {
#line 87
    EncodeChangeScheme(stream, (DmtxScheme )0, 1);
#line 88
    PadRemainingInAscii(stream, sizeIdx);
#line 89
    StreamMarkComplete(stream, sizeIdx);
    }
  }
#line 91
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static void UpdateBase256ChainHeader(DmtxEncodeStream *stream , int perfectSizeIdx ) 
{ 
  int headerIndex ;
  int outputLength ;
  int headerByteCount ;
  int symbolDataWords ;
  unsigned int perfectFit ;
  DmtxByte headerValue0 ;
  DmtxByte headerValue1 ;

  {
#line 108
  outputLength = stream->outputChainValueCount;
#line 109
  headerIndex = (stream->output)->length - stream->outputChainWordCount;
#line 110
  headerByteCount = stream->outputChainWordCount - stream->outputChainValueCount;
#line 111
  if (perfectSizeIdx == -1) {
#line 111
    perfectFit = 0U;
  } else {
#line 111
    perfectFit = 1U;
  }
#line 117
  if (perfectFit) {
    {
#line 119
    symbolDataWords = dmtxGetSymbolAttribute(11, perfectSizeIdx);
    }
#line 120
    if (symbolDataWords != (stream->output)->length - 1) {
      {
#line 122
      StreamMarkFatal(stream, 0);
      }
#line 123
      return;
    }
  }
#line 134
  if (headerByteCount == 0) {
#line 134
    if (stream->outputChainWordCount == 0) {
      {
#line 137
      StreamOutputChainAppend(stream, (DmtxByte )0);
      }
#line 137
      if ((unsigned int )stream->status != 0U) {
#line 137
        return;
      }
#line 138
      headerByteCount ++;
    } else {
#line 134
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 140
  if (! perfectFit) {
#line 140
    if (headerByteCount == 1) {
#line 140
      if (outputLength > 249) {
        {
#line 143
        Base256OutputChainInsertFirst(stream);
        }
#line 143
        if ((unsigned int )stream->status != 0U) {
#line 143
          return;
        }
#line 144
        headerByteCount ++;
      } else {
#line 140
        goto _L___0;
      }
    } else {
#line 140
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 146
  if (perfectFit) {
#line 146
    if (headerByteCount == 2) {
      {
#line 149
      Base256OutputChainRemoveFirst(stream);
      }
#line 149
      if ((unsigned int )stream->status != 0U) {
#line 149
        return;
      }
#line 150
      headerByteCount --;
    }
  }
#line 157
  if (! perfectFit) {
#line 157
    if (headerByteCount == 1) {
#line 157
      if (outputLength <= 249) {
        {
#line 160
        headerValue0 = Randomize255State((DmtxByte )outputLength, headerIndex + 1);
#line 161
        StreamOutputSet(stream, headerIndex, headerValue0);
        }
#line 161
        if ((unsigned int )stream->status != 0U) {
#line 161
          return;
        }
      } else {
#line 157
        goto _L___5;
      }
    } else {
#line 157
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 163
  if (! perfectFit) {
#line 163
    if (headerByteCount == 2) {
#line 163
      if (outputLength > 249) {
        {
#line 166
        headerValue0 = Randomize255State((DmtxByte )(outputLength / 250 + 249), headerIndex + 1);
#line 167
        StreamOutputSet(stream, headerIndex, headerValue0);
        }
#line 167
        if ((unsigned int )stream->status != 0U) {
#line 167
          return;
        }
        {
#line 169
        headerValue1 = Randomize255State((DmtxByte )(outputLength % 250), headerIndex + 2);
#line 170
        StreamOutputSet(stream, headerIndex + 1, headerValue1);
        }
#line 170
        if ((unsigned int )stream->status != 0U) {
#line 170
          return;
        }
      } else {
#line 163
        goto _L___3;
      }
    } else {
#line 163
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 172
  if (perfectFit) {
#line 172
    if (headerByteCount == 1) {
      {
#line 175
      headerValue0 = Randomize255State((DmtxByte )0, headerIndex + 1);
#line 176
      StreamOutputSet(stream, headerIndex, headerValue0);
      }
#line 176
      if ((unsigned int )stream->status != 0U) {
#line 176
        return;
      }
    } else {
      {
#line 180
      StreamMarkFatal(stream, 0);
      }
#line 181
      return;
    }
  } else {
    {
#line 180
    StreamMarkFatal(stream, 0);
    }
#line 181
    return;
  }
#line 183
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static void Base256OutputChainInsertFirst(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;
  unsigned int passFail ;
  int i ;
  int chainStart ;

  {
  {
#line 196
  chainStart = (stream->output)->length - stream->outputChainWordCount;
#line 197
  dmtxByteListPush(stream->output, (DmtxByte )0, & passFail);
  }
#line 198
  if (passFail == 1U) {
#line 200
    i = (stream->output)->length - 1;
    {
#line 200
    while (1) {
      while_continue: /* CIL Label */ ;
#line 200
      if (! (i > chainStart)) {
#line 200
        goto while_break;
      }
      {
#line 202
      value = UnRandomize255State(*((stream->output)->b + (i - 1)), i);
#line 203
      *((stream->output)->b + i) = Randomize255State(value, i + 1);
#line 200
      i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 206
    (stream->outputChainWordCount) ++;
  } else {
    {
#line 210
    StreamMarkFatal(stream, 0);
    }
  }
#line 212
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static void Base256OutputChainRemoveFirst(DmtxEncodeStream *stream ) 
{ 
  DmtxByte value ;
  unsigned int passFail ;
  int i ;
  int chainStart ;

  {
#line 225
  chainStart = (stream->output)->length - stream->outputChainWordCount;
#line 227
  i = chainStart;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < (stream->output)->length - 1)) {
#line 227
      goto while_break;
    }
    {
#line 229
    value = UnRandomize255State(*((stream->output)->b + (i + 1)), i + 2);
#line 230
    *((stream->output)->b + i) = Randomize255State(value, i + 1);
#line 227
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  dmtxByteListPop(stream->output, & passFail);
  }
#line 234
  if (passFail == 1U) {
#line 235
    (stream->outputChainWordCount) --;
  } else {
    {
#line 237
    StreamMarkFatal(stream, 0);
    }
  }
#line 238
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static DmtxByte Randomize255State(DmtxByte value , int position ) 
{ 
  int pseudoRandom ;
  int tmp ;
  int tmp___0 ;

  {
#line 251
  pseudoRandom = (149 * position) % 255 + 1;
#line 252
  tmp = (int )value + pseudoRandom;
#line 254
  if (tmp <= 255) {
#line 254
    tmp___0 = tmp;
  } else {
#line 254
    tmp___0 = tmp - 256;
  }
#line 254
  return ((DmtxByte )tmp___0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c"
static unsigned char UnRandomize255State(unsigned char value , int idx ) 
{ 
  int pseudoRandom ;
  int tmp ;

  {
#line 269
  pseudoRandom = (149 * idx) % 255 + 1;
#line 270
  tmp = (int )value - pseudoRandom;
#line 271
  if (tmp < 0) {
#line 272
    tmp += 256;
  }
#line 274
  if (tmp >= 0) {
#line 274
    if (! (tmp < 256)) {
      {
#line 274
      __assert_fail("tmp >= 0 && tmp < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c",
                    274U, "UnRandomize255State");
      }
    }
  } else {
    {
#line 274
    __assert_fail("tmp >= 0 && tmp < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxencodebase256.c",
                  274U, "UnRandomize255State");
    }
  }
#line 276
  return ((unsigned char )tmp);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern DmtxDecode *dmtxDecodeCreate(DmtxImage *img , int scale ) 
{ 
  DmtxDecode *dec ;
  int width ;
  int height ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 26
  tmp = calloc((size_t )1, sizeof(DmtxDecode ));
#line 26
  dec = (DmtxDecode *)tmp;
  }
#line 27
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 28
    return ((DmtxDecode *)((void *)0));
  }
  {
#line 30
  tmp___0 = dmtxImageGetProp(img, 300);
#line 30
  width = tmp___0 / scale;
#line 31
  tmp___1 = dmtxImageGetProp(img, 301);
#line 31
  height = tmp___1 / scale;
#line 33
  dec->edgeMin = -1;
#line 34
  dec->edgeMax = -1;
#line 35
  dec->scanGap = 1;
#line 36
  dec->squareDevn = cos((double )50 * (3.14159265358979323846 / (double )180));
#line 37
  dec->sizeIdxExpected = -1;
#line 38
  dec->edgeThresh = 10;
#line 40
  dec->xMin = 0;
#line 41
  dec->xMax = width - 1;
#line 42
  dec->yMin = 0;
#line 43
  dec->yMax = height - 1;
#line 44
  dec->scale = scale;
#line 46
  tmp___2 = calloc((size_t )(width * height), sizeof(unsigned char ));
#line 46
  dec->cache = (unsigned char *)tmp___2;
  }
#line 47
  if ((unsigned long )dec->cache == (unsigned long )((void *)0)) {
    {
#line 48
    free((void *)dec);
    }
#line 49
    return ((DmtxDecode *)((void *)0));
  }
  {
#line 52
  dec->image = img;
#line 53
  dec->grid = InitScanGrid(dec);
  }
#line 55
  return (dec);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern unsigned int dmtxDecodeDestroy(DmtxDecode **dec ) 
{ 


  {
#line 66
  if ((unsigned long )dec == (unsigned long )((void *)0)) {
#line 67
    return (0U);
  } else
#line 66
  if ((unsigned long )*dec == (unsigned long )((void *)0)) {
#line 67
    return (0U);
  }
#line 69
  if ((unsigned long )(*dec)->cache != (unsigned long )((void *)0)) {
    {
#line 70
    free((void *)(*dec)->cache);
    }
  }
  {
#line 72
  free((void *)*dec);
#line 74
  *dec = (DmtxDecode *)((void *)0);
  }
#line 76
  return (1U);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern unsigned int dmtxDecodeSetProp(DmtxDecode *dec , int prop , int value ) 
{ 


  {
  {
#line 90
  if (prop == 200) {
#line 90
    goto case_200;
  }
#line 93
  if (prop == 201) {
#line 93
    goto case_201;
  }
#line 96
  if (prop == 202) {
#line 96
    goto case_202;
  }
#line 99
  if (prop == 203) {
#line 99
    goto case_203;
  }
#line 102
  if (prop == 204) {
#line 102
    goto case_204;
  }
#line 105
  if (prop == 205) {
#line 105
    goto case_205;
  }
#line 109
  if (prop == 400) {
#line 109
    goto case_400;
  }
#line 112
  if (prop == 401) {
#line 112
    goto case_401;
  }
#line 115
  if (prop == 402) {
#line 115
    goto case_402;
  }
#line 118
  if (prop == 403) {
#line 118
    goto case_403;
  }
#line 121
  goto switch_default;
  case_200: /* CIL Label */ 
#line 91
  dec->edgeMin = value;
#line 92
  goto switch_break;
  case_201: /* CIL Label */ 
#line 94
  dec->edgeMax = value;
#line 95
  goto switch_break;
  case_202: /* CIL Label */ 
#line 97
  dec->scanGap = value;
#line 98
  goto switch_break;
  case_203: /* CIL Label */ 
  {
#line 100
  dec->squareDevn = cos((double )value * (3.14159265358979323846 / 180.0));
  }
#line 101
  goto switch_break;
  case_204: /* CIL Label */ 
#line 103
  dec->sizeIdxExpected = value;
#line 104
  goto switch_break;
  case_205: /* CIL Label */ 
#line 106
  dec->edgeThresh = value;
#line 107
  goto switch_break;
  case_400: /* CIL Label */ 
#line 110
  dec->xMin = value / dec->scale;
#line 111
  goto switch_break;
  case_401: /* CIL Label */ 
#line 113
  dec->xMax = value / dec->scale;
#line 114
  goto switch_break;
  case_402: /* CIL Label */ 
#line 116
  dec->yMin = value / dec->scale;
#line 117
  goto switch_break;
  case_403: /* CIL Label */ 
#line 119
  dec->yMax = value / dec->scale;
#line 120
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 125
  if (dec->squareDevn <= 0.0) {
#line 126
    return (0U);
  } else
#line 125
  if (dec->squareDevn >= 1.0) {
#line 126
    return (0U);
  }
#line 128
  if (dec->scanGap < 1) {
#line 129
    return (0U);
  }
#line 131
  if (dec->edgeThresh < 1) {
#line 132
    return (0U);
  } else
#line 131
  if (dec->edgeThresh > 100) {
#line 132
    return (0U);
  }
  {
#line 135
  dec->grid = InitScanGrid(dec);
  }
#line 137
  return (1U);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern int dmtxDecodeGetProp(DmtxDecode *dec , int prop ) 
{ 
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 150
  if (prop == 200) {
#line 150
    goto case_200;
  }
#line 152
  if (prop == 201) {
#line 152
    goto case_201;
  }
#line 154
  if (prop == 202) {
#line 154
    goto case_202;
  }
#line 156
  if (prop == 203) {
#line 156
    goto case_203;
  }
#line 158
  if (prop == 204) {
#line 158
    goto case_204;
  }
#line 160
  if (prop == 205) {
#line 160
    goto case_205;
  }
#line 162
  if (prop == 400) {
#line 162
    goto case_400;
  }
#line 164
  if (prop == 401) {
#line 164
    goto case_401;
  }
#line 166
  if (prop == 402) {
#line 166
    goto case_402;
  }
#line 168
  if (prop == 403) {
#line 168
    goto case_403;
  }
#line 170
  if (prop == 404) {
#line 170
    goto case_404;
  }
#line 172
  if (prop == 300) {
#line 172
    goto case_300;
  }
#line 174
  if (prop == 301) {
#line 174
    goto case_301;
  }
#line 176
  goto switch_default;
  case_200: /* CIL Label */ 
#line 151
  return (dec->edgeMin);
  case_201: /* CIL Label */ 
#line 153
  return (dec->edgeMax);
  case_202: /* CIL Label */ 
#line 155
  return (dec->scanGap);
  case_203: /* CIL Label */ 
  {
#line 157
  tmp = acos(dec->squareDevn);
  }
#line 157
  return ((int )((tmp * 180.0) / 3.14159265358979323846));
  case_204: /* CIL Label */ 
#line 159
  return (dec->sizeIdxExpected);
  case_205: /* CIL Label */ 
#line 161
  return (dec->edgeThresh);
  case_400: /* CIL Label */ 
#line 163
  return (dec->xMin);
  case_401: /* CIL Label */ 
#line 165
  return (dec->xMax);
  case_402: /* CIL Label */ 
#line 167
  return (dec->yMin);
  case_403: /* CIL Label */ 
#line 169
  return (dec->yMax);
  case_404: /* CIL Label */ 
#line 171
  return (dec->scale);
  case_300: /* CIL Label */ 
  {
#line 173
  tmp___0 = dmtxImageGetProp(dec->image, 300);
  }
#line 173
  return (tmp___0 / dec->scale);
  case_301: /* CIL Label */ 
  {
#line 175
  tmp___1 = dmtxImageGetProp(dec->image, 301);
  }
#line 175
  return (tmp___1 / dec->scale);
  switch_default: /* CIL Label */ 
#line 177
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 180
  return (-1);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern unsigned char *dmtxDecodeGetCache(DmtxDecode *dec , int x , int y ) 
{ 
  int width ;
  int height ;

  {
#line 195
  if (! ((unsigned long )dec != (unsigned long )((void *)0))) {
    {
#line 195
    __assert_fail("dec != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                  195U, "dmtxDecodeGetCache");
    }
  }
  {
#line 200
  width = dmtxDecodeGetProp(dec, 300);
#line 201
  height = dmtxDecodeGetProp(dec, 301);
  }
#line 203
  if (x < 0) {
#line 204
    return ((unsigned char *)((void *)0));
  } else
#line 203
  if (x >= width) {
#line 204
    return ((unsigned char *)((void *)0));
  } else
#line 203
  if (y < 0) {
#line 204
    return ((unsigned char *)((void *)0));
  } else
#line 203
  if (y >= height) {
#line 204
    return ((unsigned char *)((void *)0));
  }
#line 206
  return (dec->cache + (y * width + x));
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern unsigned int dmtxDecodeGetPixelValue(DmtxDecode *dec , int x , int y , int channel ,
                                            int *value ) 
{ 
  int xUnscaled ;
  int yUnscaled ;
  unsigned int err ;

  {
  {
#line 219
  xUnscaled = x * dec->scale;
#line 220
  yUnscaled = y * dec->scale;
#line 245
  err = dmtxImageGetPixelValue(dec->image, xUnscaled, yUnscaled, channel, value);
  }
#line 247
  return (err);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
static void CacheFillQuad(DmtxDecode *dec , DmtxPixelLoc p0 , DmtxPixelLoc p1 , DmtxPixelLoc p2 ,
                          DmtxPixelLoc p3 ) 
{ 
  DmtxBresLine lines[4] ;
  DmtxPixelLoc pEmpty ;
  unsigned char *cache ;
  int *scanlineMin ;
  int *scanlineMax ;
  int minY ;
  int maxY ;
  int sizeY ;
  int posY ;
  int posX ;
  int i ;
  int idx ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 257
  pEmpty.X = 0;
#line 257
  pEmpty.Y = 0;
#line 263
  lines[0] = BresLineInit(p0, p1, pEmpty);
#line 264
  lines[1] = BresLineInit(p1, p2, pEmpty);
#line 265
  lines[2] = BresLineInit(p2, p3, pEmpty);
#line 266
  lines[3] = BresLineInit(p3, p0, pEmpty);
#line 268
  minY = dec->yMax;
#line 269
  maxY = 0;
  }
#line 271
  if (minY < p0.Y) {
#line 271
    minY = minY;
  } else {
#line 271
    minY = p0.Y;
  }
#line 271
  if (maxY > p0.Y) {
#line 271
    maxY = maxY;
  } else {
#line 271
    maxY = p0.Y;
  }
#line 272
  if (minY < p1.Y) {
#line 272
    minY = minY;
  } else {
#line 272
    minY = p1.Y;
  }
#line 272
  if (maxY > p1.Y) {
#line 272
    maxY = maxY;
  } else {
#line 272
    maxY = p1.Y;
  }
#line 273
  if (minY < p2.Y) {
#line 273
    minY = minY;
  } else {
#line 273
    minY = p2.Y;
  }
#line 273
  if (maxY > p2.Y) {
#line 273
    maxY = maxY;
  } else {
#line 273
    maxY = p2.Y;
  }
#line 274
  if (minY < p3.Y) {
#line 274
    minY = minY;
  } else {
#line 274
    minY = p3.Y;
  }
#line 274
  if (maxY > p3.Y) {
#line 274
    maxY = maxY;
  } else {
#line 274
    maxY = p3.Y;
  }
  {
#line 276
  sizeY = (maxY - minY) + 1;
#line 278
  tmp = malloc((unsigned long )sizeY * sizeof(int ));
#line 278
  scanlineMin = (int *)tmp;
#line 279
  tmp___0 = calloc((size_t )sizeY, sizeof(int ));
#line 279
  scanlineMax = (int *)tmp___0;
  }
#line 281
  if (! scanlineMin) {
    {
#line 281
    __assert_fail("scanlineMin", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                  281U, "CacheFillQuad");
    }
  }
#line 282
  if (! scanlineMax) {
    {
#line 282
    __assert_fail("scanlineMax", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                  282U, "CacheFillQuad");
    }
  }
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (i < sizeY)) {
#line 284
      goto while_break;
    }
#line 285
    *(scanlineMin + i) = dec->xMax;
#line 284
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if (! (i < 4)) {
#line 287
      goto while_break___0;
    }
    {
#line 288
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 288
      if (! (lines[i].loc.X != lines[i].loc1.X)) {
#line 288
        if (! (lines[i].loc.Y != lines[i].loc1.Y)) {
#line 288
          goto while_break___1;
        }
      }
#line 289
      idx = lines[i].loc.Y - minY;
#line 290
      if (*(scanlineMin + idx) < lines[i].loc.X) {
#line 290
        *(scanlineMin + idx) = *(scanlineMin + idx);
      } else {
#line 290
        *(scanlineMin + idx) = lines[i].loc.X;
      }
#line 291
      if (*(scanlineMax + idx) > lines[i].loc.X) {
#line 291
        *(scanlineMax + idx) = *(scanlineMax + idx);
      } else {
#line 291
        *(scanlineMax + idx) = lines[i].loc.X;
      }
      {
#line 292
      BresLineStep(lines + i, 1, 0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 287
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 296
  posY = minY;
  {
#line 296
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 296
    if (posY < maxY) {
#line 296
      if (! (posY < dec->yMax)) {
#line 296
        goto while_break___2;
      }
    } else {
#line 296
      goto while_break___2;
    }
#line 297
    idx = posY - minY;
#line 298
    posX = *(scanlineMin + idx);
    {
#line 298
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 298
      if (posX < *(scanlineMax + idx)) {
#line 298
        if (! (posX < dec->xMax)) {
#line 298
          goto while_break___3;
        }
      } else {
#line 298
        goto while_break___3;
      }
      {
#line 299
      cache = dmtxDecodeGetCache(dec, posX, posY);
      }
#line 300
      if ((unsigned long )cache != (unsigned long )((void *)0)) {
#line 301
        *cache = (unsigned char )((int )*cache | 128);
      }
#line 298
      posX ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 296
    posY ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 305
  free((void *)scanlineMin);
#line 306
  free((void *)scanlineMax);
  }
#line 307
  return;
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern DmtxMessage *dmtxDecodeMatrixRegion(DmtxDecode *dec , DmtxRegion *reg , int fix ) 
{ 
  DmtxMessage *msg ;
  DmtxVector2 topLeft ;
  DmtxVector2 topRight ;
  DmtxVector2 bottomLeft ;
  DmtxVector2 bottomRight ;
  DmtxPixelLoc pxTopLeft ;
  DmtxPixelLoc pxTopRight ;
  DmtxPixelLoc pxBottomLeft ;
  DmtxPixelLoc pxBottomRight ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 323
  msg = dmtxMessageCreate(reg->sizeIdx, 0);
  }
#line 324
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 325
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 327
  tmp = PopulateArrayFromMatrix(dec, reg, msg);
  }
#line 327
  if (tmp != 1U) {
    {
#line 328
    dmtxMessageDestroy(& msg);
    }
#line 329
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 335
  ModulePlacementEcc200(msg->array, msg->code, reg->sizeIdx, 7);
#line 338
  tmp___0 = RsDecode(msg->code, reg->sizeIdx, fix);
  }
#line 338
  if (tmp___0 == 0U) {
    {
#line 340
    dmtxMessageDestroy(& msg);
    }
#line 341
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 344
  topRight.Y = - 0.1;
#line 344
  topLeft.Y = topRight.Y;
#line 344
  bottomLeft.X = topLeft.Y;
#line 344
  topLeft.X = bottomLeft.X;
#line 345
  bottomRight.Y = 1.1;
#line 345
  bottomLeft.Y = bottomRight.Y;
#line 345
  bottomRight.X = bottomLeft.Y;
#line 345
  topRight.X = bottomRight.X;
#line 347
  dmtxMatrix3VMultiplyBy(& topLeft, (double (*)[3])(reg->fit2raw));
#line 348
  dmtxMatrix3VMultiplyBy(& topRight, (double (*)[3])(reg->fit2raw));
#line 349
  dmtxMatrix3VMultiplyBy(& bottomLeft, (double (*)[3])(reg->fit2raw));
#line 350
  dmtxMatrix3VMultiplyBy(& bottomRight, (double (*)[3])(reg->fit2raw));
#line 352
  pxTopLeft.X = (int )(0.5 + topLeft.X);
#line 353
  pxTopLeft.Y = (int )(0.5 + topLeft.Y);
#line 354
  pxBottomLeft.X = (int )(0.5 + bottomLeft.X);
#line 355
  pxBottomLeft.Y = (int )(0.5 + bottomLeft.Y);
#line 356
  pxTopRight.X = (int )(0.5 + topRight.X);
#line 357
  pxTopRight.Y = (int )(0.5 + topRight.Y);
#line 358
  pxBottomRight.X = (int )(0.5 + bottomRight.X);
#line 359
  pxBottomRight.Y = (int )(0.5 + bottomRight.Y);
#line 361
  CacheFillQuad(dec, pxTopLeft, pxTopRight, pxBottomRight, pxBottomLeft);
#line 363
  DecodeDataStream(msg, reg->sizeIdx, (unsigned char *)((void *)0));
  }
#line 365
  return (msg);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern DmtxMessage *dmtxDecodeMosaicRegion(DmtxDecode *dec , DmtxRegion *reg , int fix ) 
{ 
  int offset ;
  int colorPlane ;
  DmtxMessage *oMsg ;
  DmtxMessage *rMsg ;
  DmtxMessage *gMsg ;
  DmtxMessage *bMsg ;

  {
  {
#line 382
  colorPlane = reg->flowBegin.plane;
#line 397
  reg->flowBegin.plane = 0;
#line 398
  rMsg = dmtxDecodeMatrixRegion(dec, reg, fix);
#line 400
  reg->flowBegin.plane = 1;
#line 401
  gMsg = dmtxDecodeMatrixRegion(dec, reg, fix);
#line 403
  reg->flowBegin.plane = 2;
#line 404
  bMsg = dmtxDecodeMatrixRegion(dec, reg, fix);
#line 406
  reg->flowBegin.plane = colorPlane;
#line 408
  oMsg = dmtxMessageCreate(reg->sizeIdx, 1);
  }
#line 410
  if ((unsigned long )oMsg == (unsigned long )((void *)0)) {
    {
#line 411
    dmtxMessageDestroy(& oMsg);
#line 412
    dmtxMessageDestroy(& rMsg);
#line 413
    dmtxMessageDestroy(& gMsg);
#line 414
    dmtxMessageDestroy(& bMsg);
    }
#line 415
    return ((DmtxMessage *)((void *)0));
  } else
#line 410
  if ((unsigned long )rMsg == (unsigned long )((void *)0)) {
    {
#line 411
    dmtxMessageDestroy(& oMsg);
#line 412
    dmtxMessageDestroy(& rMsg);
#line 413
    dmtxMessageDestroy(& gMsg);
#line 414
    dmtxMessageDestroy(& bMsg);
    }
#line 415
    return ((DmtxMessage *)((void *)0));
  } else
#line 410
  if ((unsigned long )gMsg == (unsigned long )((void *)0)) {
    {
#line 411
    dmtxMessageDestroy(& oMsg);
#line 412
    dmtxMessageDestroy(& rMsg);
#line 413
    dmtxMessageDestroy(& gMsg);
#line 414
    dmtxMessageDestroy(& bMsg);
    }
#line 415
    return ((DmtxMessage *)((void *)0));
  } else
#line 410
  if ((unsigned long )bMsg == (unsigned long )((void *)0)) {
    {
#line 411
    dmtxMessageDestroy(& oMsg);
#line 412
    dmtxMessageDestroy(& rMsg);
#line 413
    dmtxMessageDestroy(& gMsg);
#line 414
    dmtxMessageDestroy(& bMsg);
    }
#line 415
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 418
  offset = 0;
#line 419
  memcpy((void */* __restrict  */)(oMsg->output + offset), (void const   */* __restrict  */)rMsg->output,
         (size_t )rMsg->outputIdx);
#line 420
  offset += rMsg->outputIdx;
#line 421
  memcpy((void */* __restrict  */)(oMsg->output + offset), (void const   */* __restrict  */)gMsg->output,
         (size_t )gMsg->outputIdx);
#line 422
  offset += gMsg->outputIdx;
#line 423
  memcpy((void */* __restrict  */)(oMsg->output + offset), (void const   */* __restrict  */)bMsg->output,
         (size_t )bMsg->outputIdx);
#line 424
  offset += bMsg->outputIdx;
#line 426
  oMsg->outputIdx = offset;
#line 428
  dmtxMessageDestroy(& rMsg);
#line 429
  dmtxMessageDestroy(& gMsg);
#line 430
  dmtxMessageDestroy(& bMsg);
  }
#line 432
  return (oMsg);
}
}
#line 474
extern int ( /* missing proto */  snprintf)() ;
#line 439 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
extern unsigned char *dmtxDecodeCreateDiagnostic(DmtxDecode *dec , int *totalBytes ,
                                                 int *headerBytes , int style ) 
{ 
  int i ;
  int row ;
  int col ;
  int width ;
  int height ;
  int widthDigits ;
  int heightDigits ;
  int count ;
  int channelCount ;
  int rgb[3] ;
  double shade ;
  unsigned char *pnm ;
  unsigned char *output ;
  unsigned char *cache ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  {
#line 450
  width = dmtxDecodeGetProp(dec, 300);
#line 451
  height = dmtxDecodeGetProp(dec, 301);
#line 452
  channelCount = dmtxImageGetProp(dec->image, 308);
#line 454
  style = 1;
#line 457
  widthDigits = 0;
#line 457
  i = width;
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (i > 0)) {
#line 457
      goto while_break;
    }
#line 458
    widthDigits ++;
#line 457
    i /= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  heightDigits = 0;
#line 461
  i = height;
  {
#line 461
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 461
    if (! (i > 0)) {
#line 461
      goto while_break___0;
    }
#line 462
    heightDigits ++;
#line 461
    i /= 10;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 464
  *headerBytes = (widthDigits + heightDigits) + 9;
#line 465
  *totalBytes = *headerBytes + (width * height) * 3;
#line 467
  tmp = malloc((size_t )*totalBytes);
#line 467
  pnm = (unsigned char *)tmp;
  }
#line 468
  if ((unsigned long )pnm == (unsigned long )((void *)0)) {
#line 469
    return ((unsigned char *)((void *)0));
  }
  {
#line 474
  count = snprintf((char *)pnm, *headerBytes + 1, "P6\n%d %d\n255\n", width, height);
  }
#line 477
  if (count != *headerBytes) {
    {
#line 478
    free((void *)pnm);
    }
#line 479
    return ((unsigned char *)((void *)0));
  }
#line 482
  output = pnm + *headerBytes;
#line 483
  row = height - 1;
  {
#line 483
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 483
    if (! (row >= 0)) {
#line 483
      goto while_break___1;
    }
#line 484
    col = 0;
    {
#line 484
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 484
      if (! (col < width)) {
#line 484
        goto while_break___2;
      }
      {
#line 485
      cache = dmtxDecodeGetCache(dec, col, row);
      }
#line 486
      if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 487
        rgb[0] = 0;
#line 488
        rgb[1] = 0;
#line 489
        rgb[2] = 128;
      } else
#line 491
      if ((int )*cache & 64) {
#line 492
        rgb[0] = 255;
#line 493
        rgb[1] = 0;
#line 494
        rgb[2] = 0;
      } else {
#line 497
        if ((int )*cache & 128) {
#line 497
          shade = 0.0;
        } else {
#line 497
          shade = 0.7;
        }
#line 498
        i = 0;
        {
#line 498
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 498
          if (! (i < 3)) {
#line 498
            goto while_break___3;
          }
#line 499
          if (i < channelCount) {
            {
#line 500
            dmtxDecodeGetPixelValue(dec, col, row, i, & rgb[i]);
            }
          } else {
            {
#line 502
            dmtxDecodeGetPixelValue(dec, col, row, 0, & rgb[i]);
            }
          }
#line 504
          rgb[i] += (int )(shade * (double )(255 - rgb[i]) + 0.5);
#line 505
          if (rgb[i] > 255) {
#line 506
            rgb[i] = 255;
          }
#line 498
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 509
      tmp___0 = output;
#line 509
      output ++;
#line 509
      *tmp___0 = (unsigned char )rgb[0];
#line 510
      tmp___1 = output;
#line 510
      output ++;
#line 510
      *tmp___1 = (unsigned char )rgb[1];
#line 511
      tmp___2 = output;
#line 511
      output ++;
#line 511
      *tmp___2 = (unsigned char )rgb[2];
#line 484
      col ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 483
    row --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  if (! ((unsigned long )output == (unsigned long )(pnm + *totalBytes))) {
    {
#line 514
    __assert_fail("output == pnm + *totalBytes", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                  514U, "dmtxDecodeCreateDiagnostic");
    }
  }
#line 516
  return (pnm);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
static void TallyModuleJumps(DmtxDecode *dec , DmtxRegion *reg , int (*tally)[24] ,
                             int xOrigin , int yOrigin , int mapWidth , int mapHeight ,
                             DmtxDirection dir ) 
{ 
  int extent ;
  int weight ;
  int travelStep ;
  int symbolRow ;
  int symbolCol ;
  int mapRow ;
  int mapCol ;
  int lineStart ;
  int lineStop ;
  int travelStart ;
  int travelStop ;
  int *line ;
  int *travel ;
  int jumpThreshold ;
  int darkOnLight ;
  int color ;
  int statusPrev ;
  int statusModule ;
  int tPrev ;
  int tModule ;
  int tmp ;

  {
#line 547
  if (! ((unsigned int )dir == 1U)) {
#line 547
    if (! ((unsigned int )dir == 2U)) {
#line 547
      if (! ((unsigned int )dir == 4U)) {
#line 547
        if (! ((unsigned int )dir == 8U)) {
          {
#line 547
          __assert_fail("dir == DmtxDirUp || dir == DmtxDirLeft || dir == DmtxDirDown || dir == DmtxDirRight",
                        "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                        547U, "TallyModuleJumps");
          }
        }
      }
    }
  }
#line 549
  if ((unsigned int )dir == 1U) {
#line 549
    travelStep = 1;
  } else
#line 549
  if ((unsigned int )dir == 8U) {
#line 549
    travelStep = 1;
  } else {
#line 549
    travelStep = -1;
  }
#line 554
  if (((unsigned int )dir & 10U) != 0U) {
#line 555
    line = & symbolRow;
#line 556
    travel = & symbolCol;
#line 557
    extent = mapWidth;
#line 558
    lineStart = yOrigin;
#line 559
    lineStop = yOrigin + mapHeight;
#line 560
    if (travelStep == 1) {
#line 560
      travelStart = xOrigin - 1;
    } else {
#line 560
      travelStart = xOrigin + mapWidth;
    }
#line 561
    if (travelStep == 1) {
#line 561
      travelStop = xOrigin + mapWidth;
    } else {
#line 561
      travelStop = xOrigin - 1;
    }
  } else {
#line 564
    if (! ((unsigned int )dir & 5U)) {
      {
#line 564
      __assert_fail("dir & DmtxDirVertical", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                    564U, "TallyModuleJumps");
      }
    }
#line 565
    line = & symbolCol;
#line 566
    travel = & symbolRow;
#line 567
    extent = mapHeight;
#line 568
    lineStart = xOrigin;
#line 569
    lineStop = xOrigin + mapWidth;
#line 570
    if (travelStep == 1) {
#line 570
      travelStart = yOrigin - 1;
    } else {
#line 570
      travelStart = yOrigin + mapHeight;
    }
#line 571
    if (travelStep == 1) {
#line 571
      travelStop = yOrigin + mapHeight;
    } else {
#line 571
      travelStop = yOrigin - 1;
    }
  }
  {
#line 575
  darkOnLight = reg->offColor > reg->onColor;
#line 576
  jumpThreshold = abs((int )(0.4 * (double )(reg->offColor - reg->onColor) + 0.5));
  }
#line 578
  if (! (jumpThreshold >= 0)) {
    {
#line 578
    __assert_fail("jumpThreshold >= 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                  578U, "TallyModuleJumps");
    }
  }
#line 580
  *line = lineStart;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (*line < lineStop)) {
#line 580
      goto while_break;
    }
    {
#line 585
    *travel = travelStart;
#line 586
    color = ReadModuleColor(dec, reg, symbolRow, symbolCol, reg->sizeIdx, reg->flowBegin.plane);
    }
#line 587
    if (darkOnLight) {
#line 587
      tModule = reg->offColor - color;
    } else {
#line 587
      tModule = color - reg->offColor;
    }
#line 589
    if (travelStep == 1) {
#line 589
      statusModule = 7;
    } else
#line 589
    if ((*line & 1) == 0) {
#line 589
      statusModule = 7;
    } else {
#line 589
      statusModule = 0;
    }
#line 591
    weight = extent;
    {
#line 593
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 593
      tmp = *travel + travelStep;
#line 593
      *travel = tmp;
#line 593
      if (! (tmp != travelStop)) {
#line 593
        goto while_break___0;
      }
      {
#line 595
      tPrev = tModule;
#line 596
      statusPrev = statusModule;
#line 601
      color = ReadModuleColor(dec, reg, symbolRow, symbolCol, reg->sizeIdx, reg->flowBegin.plane);
      }
#line 602
      if (darkOnLight) {
#line 602
        tModule = reg->offColor - color;
      } else {
#line 602
        tModule = color - reg->offColor;
      }
#line 604
      if (statusPrev == 7) {
#line 605
        if (tModule < tPrev - jumpThreshold) {
#line 606
          statusModule = 0;
        } else {
#line 608
          statusModule = 7;
        }
      } else
#line 610
      if (statusPrev == 0) {
#line 611
        if (tModule > tPrev + jumpThreshold) {
#line 612
          statusModule = 7;
        } else {
#line 614
          statusModule = 0;
        }
      }
#line 617
      mapRow = symbolRow - yOrigin;
#line 618
      mapCol = symbolCol - xOrigin;
#line 619
      if (mapRow < 24) {
#line 619
        if (! (mapCol < 24)) {
          {
#line 619
          __assert_fail("mapRow < 24 && mapCol < 24", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                        619U, "TallyModuleJumps");
          }
        }
      } else {
        {
#line 619
        __assert_fail("mapRow < 24 && mapCol < 24", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                      619U, "TallyModuleJumps");
        }
      }
#line 621
      if (statusModule == 7) {
#line 622
        (*(tally + mapRow))[mapCol] += 2 * weight;
      }
#line 624
      weight --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    if (! (weight == 0)) {
      {
#line 627
      __assert_fail("weight == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                    627U, "TallyModuleJumps");
      }
    }
#line 580
    (*line) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c"
static unsigned int PopulateArrayFromMatrix(DmtxDecode *dec , DmtxRegion *reg , DmtxMessage *msg ) 
{ 
  int weightFactor ;
  int mapWidth ;
  int mapHeight ;
  int xRegionTotal ;
  int yRegionTotal ;
  int xRegionCount ;
  int yRegionCount ;
  int xOrigin ;
  int yOrigin ;
  int mapCol ;
  int mapRow ;
  int colTmp ;
  int rowTmp ;
  int idx ;
  int tally[24][24] ;

  {
  {
#line 653
  xRegionTotal = dmtxGetSymbolAttribute(4, reg->sizeIdx);
#line 654
  yRegionTotal = dmtxGetSymbolAttribute(5, reg->sizeIdx);
#line 657
  mapWidth = dmtxGetSymbolAttribute(3, reg->sizeIdx);
#line 658
  mapHeight = dmtxGetSymbolAttribute(2, reg->sizeIdx);
#line 660
  weightFactor = 2 * ((mapHeight + mapWidth) + 2);
  }
#line 661
  if (! (weightFactor > 0)) {
    {
#line 661
    __assert_fail("weightFactor > 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecode.c",
                  661U, "PopulateArrayFromMatrix");
    }
  }
#line 664
  yRegionCount = 0;
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (yRegionCount < yRegionTotal)) {
#line 664
      goto while_break;
    }
#line 667
    yOrigin = yRegionCount * (mapHeight + 2) + 1;
#line 669
    xRegionCount = 0;
    {
#line 669
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 669
      if (! (xRegionCount < xRegionTotal)) {
#line 669
        goto while_break___0;
      }
      {
#line 672
      xOrigin = xRegionCount * (mapWidth + 2) + 1;
#line 674
      memset((void *)(tally), 0, 576UL * sizeof(int ));
#line 675
      TallyModuleJumps(dec, reg, tally, xOrigin, yOrigin, mapWidth, mapHeight, (DmtxDirection )1);
#line 676
      TallyModuleJumps(dec, reg, tally, xOrigin, yOrigin, mapWidth, mapHeight, (DmtxDirection )2);
#line 677
      TallyModuleJumps(dec, reg, tally, xOrigin, yOrigin, mapWidth, mapHeight, (DmtxDirection )4);
#line 678
      TallyModuleJumps(dec, reg, tally, xOrigin, yOrigin, mapWidth, mapHeight, (DmtxDirection )8);
#line 681
      mapRow = 0;
      }
      {
#line 681
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 681
        if (! (mapRow < mapHeight)) {
#line 681
          goto while_break___1;
        }
#line 682
        mapCol = 0;
        {
#line 682
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 682
          if (! (mapCol < mapWidth)) {
#line 682
            goto while_break___2;
          }
#line 684
          rowTmp = yRegionCount * mapHeight + mapRow;
#line 685
          rowTmp = (yRegionTotal * mapHeight - rowTmp) - 1;
#line 686
          colTmp = xRegionCount * mapWidth + mapCol;
#line 687
          idx = (rowTmp * xRegionTotal) * mapWidth + colTmp;
#line 689
          if ((double )tally[mapRow][mapCol] / (double )weightFactor >= 0.5) {
#line 690
            *(msg->array + idx) = (unsigned char)7;
          } else {
#line 692
            *(msg->array + idx) = (unsigned char)0;
          }
#line 694
          *(msg->array + idx) = (unsigned char )((int )*(msg->array + idx) | 16);
#line 682
          mapCol ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 681
        mapRow ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 669
      xRegionCount ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 664
    yRegionCount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  return (1U);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static void DecodeDataStream(DmtxMessage *msg , int sizeIdx , unsigned char *outputStart ) 
{ 
  unsigned int macro ;
  DmtxScheme encScheme ;
  unsigned char *ptr ;
  unsigned char *dataEnd ;
  int tmp ;
  int tmp___0 ;

  {
#line 23
  macro = 0U;
#line 27
  if ((unsigned long )outputStart == (unsigned long )((void *)0)) {
#line 27
    msg->output = msg->output;
  } else {
#line 27
    msg->output = outputStart;
  }
  {
#line 28
  msg->outputIdx = 0;
#line 30
  ptr = msg->code;
#line 31
  tmp = dmtxGetSymbolAttribute(11, sizeIdx);
#line 31
  dataEnd = ptr + tmp;
  }
#line 34
  if ((int )*ptr == 236) {
    {
#line 35
    PushOutputMacroHeader(msg, (int )*ptr);
#line 36
    macro = 1U;
    }
  } else
#line 34
  if ((int )*ptr == 237) {
    {
#line 35
    PushOutputMacroHeader(msg, (int )*ptr);
#line 36
    macro = 1U;
    }
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! ((unsigned long )ptr < (unsigned long )dataEnd)) {
#line 39
      goto while_break;
    }
    {
#line 41
    tmp___0 = GetEncodationScheme(*ptr);
#line 41
    encScheme = (DmtxScheme )tmp___0;
    }
#line 42
    if ((int )encScheme != 0) {
#line 43
      ptr ++;
    }
    {
#line 46
    if ((int )encScheme == 0) {
#line 46
      goto case_0;
    }
#line 50
    if ((int )encScheme == 2) {
#line 50
      goto case_2;
    }
#line 50
    if ((int )encScheme == 1) {
#line 50
      goto case_2;
    }
#line 53
    if ((int )encScheme == 3) {
#line 53
      goto case_3;
    }
#line 56
    if ((int )encScheme == 4) {
#line 56
      goto case_4;
    }
#line 59
    if ((int )encScheme == 5) {
#line 59
      goto case_5;
    }
#line 62
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 47
    ptr = DecodeSchemeAscii(msg, ptr, dataEnd);
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 51
    ptr = DecodeSchemeC40Text(msg, ptr, dataEnd, encScheme);
    }
#line 52
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 54
    ptr = DecodeSchemeX12(msg, ptr, dataEnd);
    }
#line 55
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 57
    ptr = DecodeSchemeEdifact(msg, ptr, dataEnd);
    }
#line 58
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 60
    ptr = DecodeSchemeBase256(msg, ptr, dataEnd);
    }
#line 61
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 64
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (macro == 1U) {
    {
#line 70
    PushOutputMacroTrailer(msg);
    }
  }
#line 71
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static int GetEncodationScheme(unsigned char cw ) 
{ 
  DmtxScheme encScheme ;

  {
  {
#line 85
  if ((int )cw == 230) {
#line 85
    goto case_230;
  }
#line 88
  if ((int )cw == 239) {
#line 88
    goto case_239;
  }
#line 91
  if ((int )cw == 238) {
#line 91
    goto case_238;
  }
#line 94
  if ((int )cw == 240) {
#line 94
    goto case_240;
  }
#line 97
  if ((int )cw == 231) {
#line 97
    goto case_231;
  }
#line 100
  goto switch_default;
  case_230: /* CIL Label */ 
#line 86
  encScheme = (DmtxScheme )1;
#line 87
  goto switch_break;
  case_239: /* CIL Label */ 
#line 89
  encScheme = (DmtxScheme )2;
#line 90
  goto switch_break;
  case_238: /* CIL Label */ 
#line 92
  encScheme = (DmtxScheme )3;
#line 93
  goto switch_break;
  case_240: /* CIL Label */ 
#line 95
  encScheme = (DmtxScheme )4;
#line 96
  goto switch_break;
  case_231: /* CIL Label */ 
#line 98
  encScheme = (DmtxScheme )5;
#line 99
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 101
  encScheme = (DmtxScheme )0;
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 105
  return ((int )encScheme);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static void PushOutputWord(DmtxMessage *msg , int value ) 
{ 
  int tmp ;

  {
#line 115
  if (value >= 0) {
#line 115
    if (! (value < 256)) {
      {
#line 115
      __assert_fail("value >= 0 && value < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                    115U, "PushOutputWord");
      }
    }
  } else {
    {
#line 115
    __assert_fail("value >= 0 && value < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                  115U, "PushOutputWord");
    }
  }
#line 117
  tmp = msg->outputIdx;
#line 117
  (msg->outputIdx) ++;
#line 117
  *(msg->output + tmp) = (unsigned char )value;
#line 118
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static void PushOutputC40TextWord(DmtxMessage *msg , C40TextState *state , int value ) 
{ 


  {
#line 127
  if (value >= 0) {
#line 127
    if (! (value < 256)) {
      {
#line 127
      __assert_fail("value >= 0 && value < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                    127U, "PushOutputC40TextWord");
      }
    }
  } else {
    {
#line 127
    __assert_fail("value >= 0 && value < 256", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                  127U, "PushOutputC40TextWord");
    }
  }
#line 129
  *(msg->output + msg->outputIdx) = (unsigned char )value;
#line 131
  if (state->upperShift == 1U) {
#line 132
    if (! (value < 128)) {
      {
#line 132
      __assert_fail("value < 128", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                    132U, "PushOutputC40TextWord");
      }
    }
#line 133
    *(msg->output + msg->outputIdx) = (unsigned char )((int )*(msg->output + msg->outputIdx) + 128);
  }
#line 136
  (msg->outputIdx) ++;
#line 138
  state->shift = 0;
#line 139
  state->upperShift = 0U;
#line 140
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static void PushOutputMacroHeader(DmtxMessage *msg , int macroType ) 
{ 


  {
  {
#line 149
  PushOutputWord(msg, '[');
#line 150
  PushOutputWord(msg, ')');
#line 151
  PushOutputWord(msg, '>');
#line 152
  PushOutputWord(msg, 30);
#line 153
  PushOutputWord(msg, '0');
  }
#line 155
  if (! (macroType == 236)) {
#line 155
    if (! (macroType == 237)) {
      {
#line 155
      __assert_fail("macroType == 236 || macroType == 237", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                    155U, "PushOutputMacroHeader");
      }
    }
  }
#line 156
  if (macroType == 236) {
    {
#line 157
    PushOutputWord(msg, '5');
    }
  } else {
    {
#line 159
    PushOutputWord(msg, '6');
    }
  }
  {
#line 161
  PushOutputWord(msg, 29);
  }
#line 162
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static void PushOutputMacroTrailer(DmtxMessage *msg ) 
{ 


  {
  {
#line 171
  PushOutputWord(msg, 30);
#line 172
  PushOutputWord(msg, 4);
  }
#line 173
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static unsigned char *DecodeSchemeAscii(DmtxMessage *msg , unsigned char *ptr , unsigned char *dataEnd ) 
{ 
  int upperShift ;
  int codeword ;
  int digits ;
  int tmp ;

  {
#line 188
  upperShift = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((unsigned long )ptr < (unsigned long )dataEnd)) {
#line 190
      goto while_break;
    }
    {
#line 192
    codeword = (int )*ptr;
#line 194
    tmp = GetEncodationScheme(*ptr);
    }
#line 194
    if (tmp != 0) {
#line 195
      return (ptr);
    } else {
#line 197
      ptr ++;
    }
#line 199
    if (upperShift == 1) {
      {
#line 200
      PushOutputWord(msg, codeword + 127);
#line 201
      upperShift = 0;
      }
    } else
#line 203
    if (codeword == 235) {
#line 204
      upperShift = 1;
    } else
#line 206
    if (codeword == 129) {
#line 207
      if (! ((unsigned long )dataEnd >= (unsigned long )ptr)) {
        {
#line 207
        __assert_fail("dataEnd >= ptr", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                      207U, "DecodeSchemeAscii");
        }
      }
#line 208
      if (! (dataEnd - ptr <= 2147483647L)) {
        {
#line 208
        __assert_fail("dataEnd - ptr <= 2147483647", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                      208U, "DecodeSchemeAscii");
        }
      }
#line 209
      msg->padCount = (int )(dataEnd - ptr);
#line 210
      return (dataEnd);
    } else
#line 212
    if (codeword <= 128) {
      {
#line 213
      PushOutputWord(msg, codeword - 1);
      }
    } else
#line 215
    if (codeword <= 229) {
      {
#line 216
      digits = codeword - 130;
#line 217
      PushOutputWord(msg, digits / 10 + 48);
#line 218
      PushOutputWord(msg, (digits - (digits / 10) * 10) + 48);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (ptr);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static unsigned char *DecodeSchemeC40Text(DmtxMessage *msg , unsigned char *ptr ,
                                          unsigned char *dataEnd , DmtxScheme encScheme ) 
{ 
  int i ;
  int packed ;
  int c40Values[3] ;
  C40TextState state ;

  {
#line 241
  state.shift = 0;
#line 242
  state.upperShift = 0U;
#line 244
  if (! ((int )encScheme == 1)) {
#line 244
    if (! ((int )encScheme == 2)) {
      {
#line 244
      __assert_fail("encScheme == DmtxSchemeC40 || encScheme == DmtxSchemeText", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                    244U, "DecodeSchemeC40Text");
      }
    }
  }
#line 247
  if (dataEnd - ptr < 2L) {
#line 248
    return (ptr);
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((unsigned long )ptr < (unsigned long )dataEnd)) {
#line 250
      goto while_break;
    }
#line 253
    packed = ((int )*ptr << 8) | (int )*(ptr + 1);
#line 254
    c40Values[0] = (packed - 1) / 1600;
#line 255
    c40Values[1] = ((packed - 1) / 40) % 40;
#line 256
    c40Values[2] = (packed - 1) % 40;
#line 257
    ptr += 2;
#line 259
    i = 0;
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 259
      if (! (i < 3)) {
#line 259
        goto while_break___0;
      }
#line 260
      if (state.shift == 0) {
#line 261
        if (c40Values[i] <= 2) {
#line 262
          state.shift = c40Values[i] + 1;
        } else
#line 264
        if (c40Values[i] == 3) {
          {
#line 265
          PushOutputC40TextWord(msg, & state, ' ');
          }
        } else
#line 267
        if (c40Values[i] <= 13) {
          {
#line 268
          PushOutputC40TextWord(msg, & state, (c40Values[i] - 13) + 57);
          }
        } else
#line 270
        if (c40Values[i] <= 39) {
#line 271
          if ((int )encScheme == 1) {
            {
#line 272
            PushOutputC40TextWord(msg, & state, (c40Values[i] - 39) + 90);
            }
          } else
#line 274
          if ((int )encScheme == 2) {
            {
#line 275
            PushOutputC40TextWord(msg, & state, (c40Values[i] - 39) + 122);
            }
          }
        }
      } else
#line 279
      if (state.shift == 1) {
        {
#line 280
        PushOutputC40TextWord(msg, & state, c40Values[i]);
        }
      } else
#line 282
      if (state.shift == 2) {
#line 283
        if (c40Values[i] <= 14) {
          {
#line 284
          PushOutputC40TextWord(msg, & state, c40Values[i] + 33);
          }
        } else
#line 286
        if (c40Values[i] <= 21) {
          {
#line 287
          PushOutputC40TextWord(msg, & state, c40Values[i] + 43);
          }
        } else
#line 289
        if (c40Values[i] <= 26) {
          {
#line 290
          PushOutputC40TextWord(msg, & state, c40Values[i] + 69);
          }
        } else
#line 292
        if (c40Values[i] == 27) {
          {
#line 293
          PushOutputC40TextWord(msg, & state, 29);
          }
        } else
#line 295
        if (c40Values[i] == 30) {
#line 296
          state.upperShift = 1U;
#line 297
          state.shift = 0;
        }
      } else
#line 300
      if (state.shift == 3) {
#line 301
        if ((int )encScheme == 1) {
          {
#line 302
          PushOutputC40TextWord(msg, & state, c40Values[i] + 96);
          }
        } else
#line 304
        if ((int )encScheme == 2) {
#line 305
          if (c40Values[i] == 0) {
            {
#line 306
            PushOutputC40TextWord(msg, & state, c40Values[i] + 96);
            }
          } else
#line 307
          if (c40Values[i] <= 26) {
            {
#line 308
            PushOutputC40TextWord(msg, & state, (c40Values[i] - 26) + 90);
            }
          } else {
            {
#line 310
            PushOutputC40TextWord(msg, & state, (c40Values[i] - 31) + 127);
            }
          }
        }
      }
#line 259
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    if ((int )*ptr == 254) {
#line 317
      return (ptr + 1);
    }
#line 320
    if (dataEnd - ptr < 2L) {
#line 321
      return (ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return (ptr);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static unsigned char *DecodeSchemeX12(DmtxMessage *msg , unsigned char *ptr , unsigned char *dataEnd ) 
{ 
  int i ;
  int packed ;
  int x12Values[3] ;

  {
#line 342
  if (dataEnd - ptr < 2L) {
#line 343
    return (ptr);
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! ((unsigned long )ptr < (unsigned long )dataEnd)) {
#line 345
      goto while_break;
    }
#line 348
    packed = ((int )*ptr << 8) | (int )*(ptr + 1);
#line 349
    x12Values[0] = (packed - 1) / 1600;
#line 350
    x12Values[1] = ((packed - 1) / 40) % 40;
#line 351
    x12Values[2] = (packed - 1) % 40;
#line 352
    ptr += 2;
#line 354
    i = 0;
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (! (i < 3)) {
#line 354
        goto while_break___0;
      }
#line 355
      if (x12Values[i] == 0) {
        {
#line 356
        PushOutputWord(msg, 13);
        }
      } else
#line 357
      if (x12Values[i] == 1) {
        {
#line 358
        PushOutputWord(msg, 42);
        }
      } else
#line 359
      if (x12Values[i] == 2) {
        {
#line 360
        PushOutputWord(msg, 62);
        }
      } else
#line 361
      if (x12Values[i] == 3) {
        {
#line 362
        PushOutputWord(msg, 32);
        }
      } else
#line 363
      if (x12Values[i] <= 13) {
        {
#line 364
        PushOutputWord(msg, x12Values[i] + 44);
        }
      } else
#line 365
      if (x12Values[i] <= 90) {
        {
#line 366
        PushOutputWord(msg, x12Values[i] + 51);
        }
      }
#line 354
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 370
    if ((int )*ptr == 254) {
#line 371
      return (ptr + 1);
    }
#line 374
    if (dataEnd - ptr < 2L) {
#line 375
      return (ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return (ptr);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static unsigned char *DecodeSchemeEdifact(DmtxMessage *msg , unsigned char *ptr ,
                                          unsigned char *dataEnd ) 
{ 
  int i ;
  unsigned char unpacked[4] ;

  {
#line 395
  if (dataEnd - ptr < 3L) {
#line 396
    return (ptr);
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! ((unsigned long )ptr < (unsigned long )dataEnd)) {
#line 398
      goto while_break;
    }
#line 403
    unpacked[0] = (unsigned char )(((int )*ptr & 252) >> 2);
#line 404
    unpacked[1] = (unsigned char )((((int )*ptr & 3) << 4) | (((int )*(ptr + 1) & 240) >> 4));
#line 405
    unpacked[2] = (unsigned char )((((int )*(ptr + 1) & 15) << 2) | (((int )*(ptr + 2) & 192) >> 6));
#line 406
    unpacked[3] = (unsigned char )((int )*(ptr + 2) & 63);
#line 408
    i = 0;
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 408
      if (! (i < 4)) {
#line 408
        goto while_break___0;
      }
#line 411
      if (i < 3) {
#line 412
        ptr ++;
      }
#line 415
      if ((int )unpacked[i] == 31) {
#line 416
        if (! ((int )*(msg->output + msg->outputIdx) == 0)) {
          {
#line 416
          __assert_fail("msg->output[msg->outputIdx] == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                        416U, "DecodeSchemeEdifact");
          }
        }
#line 417
        return (ptr);
      }
      {
#line 420
      PushOutputWord(msg, (int )unpacked[i] ^ ((((int )unpacked[i] & 32) ^ 32) << 1));
#line 408
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 424
    if (dataEnd - ptr < 3L) {
#line 425
      return (ptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return (ptr);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c"
static unsigned char *DecodeSchemeBase256(DmtxMessage *msg , unsigned char *ptr ,
                                          unsigned char *dataEnd ) 
{ 
  int d0 ;
  int d1 ;
  int idx ;
  unsigned char *ptrEnd ;
  int tmp ;
  unsigned char *tmp___0 ;
  unsigned char tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char tmp___7 ;

  {
#line 478
  if (! ((unsigned long )(ptr + 1) >= (unsigned long )msg->code)) {
    {
#line 478
    __assert_fail("ptr + 1 >= msg->code", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                  478U, "DecodeSchemeBase256");
    }
  }
#line 479
  if (! ((ptr + 1) - msg->code <= 2147483647L)) {
    {
#line 479
    __assert_fail("ptr + 1 - msg->code <= 2147483647", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxdecodescheme.c",
                  479U, "DecodeSchemeBase256");
    }
  }
  {
#line 480
  idx = (int )((ptr + 1) - msg->code);
#line 482
  tmp = idx;
#line 482
  idx ++;
#line 482
  tmp___0 = ptr;
#line 482
  ptr ++;
#line 482
  tmp___1 = UnRandomize255State(*tmp___0, tmp);
#line 482
  d0 = (int )tmp___1;
  }
#line 483
  if (d0 == 0) {
#line 484
    ptrEnd = dataEnd;
  } else
#line 486
  if (d0 <= 249) {
#line 487
    ptrEnd = ptr + d0;
  } else {
    {
#line 490
    tmp___2 = idx;
#line 490
    idx ++;
#line 490
    tmp___3 = ptr;
#line 490
    ptr ++;
#line 490
    tmp___4 = UnRandomize255State(*tmp___3, tmp___2);
#line 490
    d1 = (int )tmp___4;
#line 491
    ptrEnd = (ptr + (d0 - 249) * 250) + d1;
    }
  }
#line 494
  if ((unsigned long )ptrEnd > (unsigned long )dataEnd) {
    {
#line 495
    exit(40);
    }
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! ((unsigned long )ptr < (unsigned long )ptrEnd)) {
#line 497
      goto while_break;
    }
    {
#line 498
    tmp___5 = idx;
#line 498
    idx ++;
#line 498
    tmp___6 = ptr;
#line 498
    ptr ++;
#line 498
    tmp___7 = UnRandomize255State(*tmp___6, tmp___5);
#line 498
    PushOutputWord(msg, (int )tmp___7);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  return (ptr);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmessage.c"
extern DmtxMessage *dmtxMessageCreate(int sizeIdx , int symbolFormat ) 
{ 
  DmtxMessage *message ;
  int mappingRows ;
  int mappingCols ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 26
  if (! (symbolFormat == 0)) {
#line 26
    if (! (symbolFormat == 1)) {
      {
#line 26
      __assert_fail("symbolFormat == 0 || symbolFormat == 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmessage.c",
                    26U, "dmtxMessageCreate");
      }
    }
  }
  {
#line 28
  mappingRows = dmtxGetSymbolAttribute(6, sizeIdx);
#line 29
  mappingCols = dmtxGetSymbolAttribute(7, sizeIdx);
#line 31
  tmp = calloc((size_t )1, sizeof(DmtxMessage ));
#line 31
  message = (DmtxMessage *)tmp;
  }
#line 32
  if ((unsigned long )message == (unsigned long )((void *)0)) {
#line 33
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 35
  message->arraySize = (sizeof(unsigned char ) * (unsigned long )mappingRows) * (unsigned long )mappingCols;
#line 37
  tmp___0 = calloc((size_t )1, message->arraySize);
#line 37
  message->array = (unsigned char *)tmp___0;
  }
#line 38
  if ((unsigned long )message->array == (unsigned long )((void *)0)) {
    {
#line 39
    perror("Calloc failed");
#line 40
    dmtxMessageDestroy(& message);
    }
#line 41
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 44
  tmp___1 = dmtxGetSymbolAttribute(11, sizeIdx);
#line 44
  tmp___2 = dmtxGetSymbolAttribute(12, sizeIdx);
#line 44
  message->codeSize = sizeof(unsigned char ) * (unsigned long )tmp___1 + (unsigned long )tmp___2;
  }
#line 48
  if (symbolFormat == 1) {
#line 49
    message->codeSize *= 3UL;
  }
  {
#line 51
  tmp___3 = calloc(message->codeSize, sizeof(unsigned char ));
#line 51
  message->code = (unsigned char *)tmp___3;
  }
#line 52
  if ((unsigned long )message->code == (unsigned long )((void *)0)) {
    {
#line 53
    perror("Calloc failed");
#line 54
    dmtxMessageDestroy(& message);
    }
#line 55
    return ((DmtxMessage *)((void *)0));
  }
  {
#line 61
  message->outputSize = (sizeof(unsigned char ) * message->codeSize) * 10UL;
#line 62
  tmp___4 = calloc(message->outputSize, sizeof(unsigned char ));
#line 62
  message->output = (unsigned char *)tmp___4;
  }
#line 63
  if ((unsigned long )message->output == (unsigned long )((void *)0)) {
    {
#line 64
    perror("Calloc failed");
#line 65
    dmtxMessageDestroy(& message);
    }
#line 66
    return ((DmtxMessage *)((void *)0));
  }
#line 69
  return (message);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmessage.c"
extern unsigned int dmtxMessageDestroy(DmtxMessage **msg ) 
{ 


  {
#line 80
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 81
    return (0U);
  } else
#line 80
  if ((unsigned long )*msg == (unsigned long )((void *)0)) {
#line 81
    return (0U);
  }
#line 83
  if ((unsigned long )(*msg)->array != (unsigned long )((void *)0)) {
    {
#line 84
    free((void *)(*msg)->array);
    }
  }
#line 86
  if ((unsigned long )(*msg)->code != (unsigned long )((void *)0)) {
    {
#line 87
    free((void *)(*msg)->code);
    }
  }
#line 89
  if ((unsigned long )(*msg)->output != (unsigned long )((void *)0)) {
    {
#line 90
    free((void *)(*msg)->output);
    }
  }
  {
#line 92
  free((void *)*msg);
#line 94
  *msg = (DmtxMessage *)((void *)0);
  }
#line 96
  return (1U);
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
extern DmtxRegion *dmtxRegionCreate(DmtxRegion *reg ) 
{ 
  DmtxRegion *regCopy ;
  void *tmp ;

  {
  {
#line 26
  tmp = malloc(sizeof(DmtxRegion ));
#line 26
  regCopy = (DmtxRegion *)tmp;
  }
#line 27
  if ((unsigned long )regCopy == (unsigned long )((void *)0)) {
#line 28
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 30
  memcpy((void */* __restrict  */)regCopy, (void const   */* __restrict  */)reg, sizeof(DmtxRegion ));
  }
#line 32
  return (regCopy);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
extern unsigned int dmtxRegionDestroy(DmtxRegion **reg ) 
{ 


  {
#line 43
  if ((unsigned long )reg == (unsigned long )((void *)0)) {
#line 44
    return (0U);
  } else
#line 43
  if ((unsigned long )*reg == (unsigned long )((void *)0)) {
#line 44
    return (0U);
  }
  {
#line 46
  free((void *)*reg);
#line 48
  *reg = (DmtxRegion *)((void *)0);
  }
#line 50
  return (1U);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
extern DmtxRegion *dmtxRegionFindNext(DmtxDecode *dec , DmtxTime *timeout ) 
{ 
  int locStatus ;
  DmtxPixelLoc loc ;
  DmtxRegion *reg ;
  int tmp ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    locStatus = PopGridLocation(& dec->grid, & loc);
    }
#line 69
    if (locStatus == 2) {
#line 70
      goto while_break;
    }
    {
#line 73
    reg = dmtxRegionScanPixel(dec, loc.X, loc.Y);
    }
#line 74
    if ((unsigned long )reg != (unsigned long )((void *)0)) {
#line 75
      return (reg);
    }
#line 78
    if ((unsigned long )timeout != (unsigned long )((void *)0)) {
      {
#line 78
      tmp = dmtxTimeExceeded(*timeout);
      }
#line 78
      if (tmp) {
#line 79
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return ((DmtxRegion *)((void *)0));
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
extern DmtxRegion *dmtxRegionScanPixel(DmtxDecode *dec , int x , int y ) 
{ 
  unsigned char *cache ;
  DmtxRegion reg ;
  DmtxPointFlow flowBegin ;
  DmtxPixelLoc loc ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  DmtxRegion *tmp___6 ;

  {
  {
#line 99
  loc.X = x;
#line 100
  loc.Y = y;
#line 102
  cache = dmtxDecodeGetCache(dec, loc.X, loc.Y);
  }
#line 103
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 104
    return ((DmtxRegion *)((void *)0));
  }
#line 106
  if (((int )*cache & 128) != 0) {
#line 107
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 110
  flowBegin = MatrixRegionSeekEdge(dec, loc);
  }
#line 111
  if (flowBegin.mag < (int )((double )dec->edgeThresh * 7.65 + 0.5)) {
#line 112
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 114
  memset((void *)(& reg), 0, sizeof(DmtxRegion ));
#line 117
  tmp = MatrixRegionOrientation(dec, & reg, flowBegin);
  }
#line 117
  if (tmp == 0U) {
#line 118
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 119
  tmp___0 = dmtxRegionUpdateXfrms(dec, & reg);
  }
#line 119
  if (tmp___0 == 0U) {
#line 120
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 123
  tmp___1 = MatrixRegionAlignCalibEdge(dec, & reg, 1);
  }
#line 123
  if (tmp___1 == 0U) {
#line 124
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 125
  tmp___2 = dmtxRegionUpdateXfrms(dec, & reg);
  }
#line 125
  if (tmp___2 == 0U) {
#line 126
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 129
  tmp___3 = MatrixRegionAlignCalibEdge(dec, & reg, 8);
  }
#line 129
  if (tmp___3 == 0U) {
#line 130
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 131
  tmp___4 = dmtxRegionUpdateXfrms(dec, & reg);
  }
#line 131
  if (tmp___4 == 0U) {
#line 132
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 137
  tmp___5 = MatrixRegionFindSize(dec, & reg);
  }
#line 137
  if (tmp___5 == 0U) {
#line 138
    return ((DmtxRegion *)((void *)0));
  }
  {
#line 141
  tmp___6 = dmtxRegionCreate(& reg);
  }
#line 141
  return (tmp___6);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxPointFlow MatrixRegionSeekEdge(DmtxDecode *dec , DmtxPixelLoc loc ) 
{ 
  int i ;
  int strongIdx ;
  int channelCount ;
  DmtxPointFlow flow ;
  DmtxPointFlow flowPlane[3] ;
  DmtxPointFlow flowPos ;
  DmtxPointFlow flowPosBack ;
  DmtxPointFlow flowNeg ;
  DmtxPointFlow flowNegBack ;

  {
#line 158
  channelCount = (dec->image)->channelCount;
#line 161
  strongIdx = 0;
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < channelCount)) {
#line 162
      goto while_break;
    }
    {
#line 163
    flowPlane[i] = GetPointFlow(dec, i, loc, (int )dmtxNeighborNone);
    }
#line 164
    if (i > 0) {
#line 164
      if (flowPlane[i].mag > flowPlane[strongIdx].mag) {
#line 165
        strongIdx = i;
      }
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (flowPlane[strongIdx].mag < 10) {
#line 169
    return ((DmtxPointFlow )dmtxBlankEdge);
  }
  {
#line 171
  flow = flowPlane[strongIdx];
#line 173
  flowPos = FindStrongestNeighbor(dec, flow, 1);
#line 174
  flowNeg = FindStrongestNeighbor(dec, flow, -1);
  }
#line 175
  if (flowPos.mag != 0) {
#line 175
    if (flowNeg.mag != 0) {
      {
#line 176
      flowPosBack = FindStrongestNeighbor(dec, flowPos, -1);
#line 177
      flowNegBack = FindStrongestNeighbor(dec, flowNeg, 1);
      }
#line 178
      if (flowPos.arrive == (flowPosBack.arrive + 4) % 8) {
#line 178
        if (flowNeg.arrive == (flowNegBack.arrive + 4) % 8) {
#line 180
          flow.arrive = (int )dmtxNeighborNone;
#line 182
          return (flow);
        }
      }
    }
  }
#line 186
  return ((DmtxPointFlow )dmtxBlankEdge);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int MatrixRegionOrientation(DmtxDecode *dec , DmtxRegion *reg , DmtxPointFlow begin ) 
{ 
  int cross ;
  int minArea ;
  int scale ;
  int symbolShape ;
  int maxDiagonal ;
  unsigned int err ;
  DmtxBestLine line1x ;
  DmtxBestLine line2x ;
  DmtxBestLine line2n ;
  DmtxBestLine line2p ;
  DmtxFollow fTmp ;
  double tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;

  {
#line 206
  if (dec->sizeIdxExpected == -2) {
#line 209
    symbolShape = -2;
  } else
#line 206
  if (dec->sizeIdxExpected >= 0) {
#line 206
    if (dec->sizeIdxExpected <= 23) {
#line 209
      symbolShape = -2;
    } else {
#line 206
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 210
  if (dec->sizeIdxExpected == -3) {
#line 213
    symbolShape = -3;
  } else
#line 210
  if (dec->sizeIdxExpected >= 24) {
#line 210
    if (dec->sizeIdxExpected <= 29) {
#line 213
      symbolShape = -3;
    } else {
#line 215
      symbolShape = -1;
    }
  } else {
#line 215
    symbolShape = -1;
  }
#line 217
  if (dec->edgeMax != -1) {
#line 218
    if (symbolShape == -3) {
#line 219
      maxDiagonal = (int )(1.23 * (double )dec->edgeMax + 0.5);
    } else {
#line 221
      maxDiagonal = (int )(1.56 * (double )dec->edgeMax + 0.5);
    }
  } else {
#line 224
    maxDiagonal = -1;
  }
  {
#line 228
  err = TrailBlazeContinuous(dec, reg, begin, maxDiagonal);
  }
#line 229
  if (err == 0U) {
    {
#line 230
    TrailClear(dec, reg, 64);
    }
#line 231
    return (0U);
  } else
#line 229
  if (reg->stepsTotal < 40) {
    {
#line 230
    TrailClear(dec, reg, 64);
    }
#line 231
    return (0U);
  }
#line 235
  if (dec->edgeMin != -1) {
    {
#line 236
    scale = dmtxDecodeGetProp(dec, 404);
    }
#line 238
    if (symbolShape == -2) {
#line 239
      minArea = (dec->edgeMin * dec->edgeMin) / (scale * scale);
    } else {
#line 241
      minArea = ((2 * dec->edgeMin) * dec->edgeMin) / (scale * scale);
    }
#line 243
    if ((reg->boundMax.X - reg->boundMin.X) * (reg->boundMax.Y - reg->boundMin.Y) < minArea) {
      {
#line 244
      TrailClear(dec, reg, 64);
      }
#line 245
      return (0U);
    }
  }
  {
#line 249
  line1x = FindBestSolidLine(dec, reg, 0, 0, 1, -1);
  }
#line 250
  if (line1x.mag < 5) {
    {
#line 251
    TrailClear(dec, reg, 64);
    }
#line 252
    return (0U);
  }
  {
#line 255
  err = FindTravelLimits(dec, reg, & line1x);
  }
#line 256
  if (line1x.distSq < 100) {
    {
#line 257
    TrailClear(dec, reg, 64);
    }
#line 258
    return (0U);
  } else {
    {
#line 256
    tmp = sqrt((double )line1x.distSq);
    }
#line 256
    if (line1x.devn * (double )10 >= tmp) {
      {
#line 257
      TrailClear(dec, reg, 64);
      }
#line 258
      return (0U);
    }
  }
#line 260
  if (! (line1x.stepPos >= line1x.stepNeg)) {
    {
#line 260
    __assert_fail("line1x.stepPos >= line1x.stepNeg", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  260U, "MatrixRegionOrientation");
    }
  }
  {
#line 262
  fTmp = FollowSeek(dec, reg, line1x.stepPos + 5);
#line 263
  line2p = FindBestSolidLine(dec, reg, fTmp.step, line1x.stepNeg, 1, line1x.angle);
#line 265
  fTmp = FollowSeek(dec, reg, line1x.stepNeg - 5);
#line 266
  line2n = FindBestSolidLine(dec, reg, fTmp.step, line1x.stepPos, -1, line1x.angle);
  }
#line 267
  if (line2p.mag > line2n.mag) {
#line 267
    tmp___0 = line2p.mag;
  } else {
#line 267
    tmp___0 = line2n.mag;
  }
#line 267
  if (tmp___0 < 5) {
#line 268
    return (0U);
  }
#line 270
  if (line2p.mag > line2n.mag) {
    {
#line 271
    line2x = line2p;
#line 272
    err = FindTravelLimits(dec, reg, & line2x);
    }
#line 273
    if (line2x.distSq < 100) {
#line 274
      return (0U);
    } else {
      {
#line 273
      tmp___1 = sqrt((double )line2x.distSq);
      }
#line 273
      if (line2x.devn * (double )10 >= tmp___1) {
#line 274
        return (0U);
      }
    }
#line 276
    cross = (line1x.locPos.X - line1x.locNeg.X) * (line2x.locPos.Y - line2x.locNeg.Y) - (line1x.locPos.Y - line1x.locNeg.Y) * (line2x.locPos.X - line2x.locNeg.X);
#line 278
    if (cross > 0) {
#line 280
      reg->polarity = 1;
#line 281
      reg->locR = line2x.locPos;
#line 282
      reg->stepR = line2x.stepPos;
#line 283
      reg->locT = line1x.locNeg;
#line 284
      reg->stepT = line1x.stepNeg;
#line 285
      reg->leftLoc = line1x.locBeg;
#line 286
      reg->leftAngle = line1x.angle;
#line 287
      reg->bottomLoc = line2x.locBeg;
#line 288
      reg->bottomAngle = line2x.angle;
#line 289
      reg->leftLine = line1x;
#line 290
      reg->bottomLine = line2x;
    } else {
#line 294
      reg->polarity = -1;
#line 295
      reg->locR = line1x.locNeg;
#line 296
      reg->stepR = line1x.stepNeg;
#line 297
      reg->locT = line2x.locPos;
#line 298
      reg->stepT = line2x.stepPos;
#line 299
      reg->leftLoc = line2x.locBeg;
#line 300
      reg->leftAngle = line2x.angle;
#line 301
      reg->bottomLoc = line1x.locBeg;
#line 302
      reg->bottomAngle = line1x.angle;
#line 303
      reg->leftLine = line2x;
#line 304
      reg->bottomLine = line1x;
    }
  } else {
    {
#line 308
    line2x = line2n;
#line 309
    err = FindTravelLimits(dec, reg, & line2x);
    }
#line 310
    if (line2x.distSq < 100) {
#line 311
      return (0U);
    } else {
      {
#line 310
      tmp___2 = sqrt((double )line2x.distSq);
      }
#line 310
      if (line2x.devn / tmp___2 >= 0.1) {
#line 311
        return (0U);
      }
    }
#line 313
    cross = (line1x.locNeg.X - line1x.locPos.X) * (line2x.locNeg.Y - line2x.locPos.Y) - (line1x.locNeg.Y - line1x.locPos.Y) * (line2x.locNeg.X - line2x.locPos.X);
#line 315
    if (cross > 0) {
#line 317
      reg->polarity = -1;
#line 318
      reg->locR = line2x.locNeg;
#line 319
      reg->stepR = line2x.stepNeg;
#line 320
      reg->locT = line1x.locPos;
#line 321
      reg->stepT = line1x.stepPos;
#line 322
      reg->leftLoc = line1x.locBeg;
#line 323
      reg->leftAngle = line1x.angle;
#line 324
      reg->bottomLoc = line2x.locBeg;
#line 325
      reg->bottomAngle = line2x.angle;
#line 326
      reg->leftLine = line1x;
#line 327
      reg->bottomLine = line2x;
    } else {
#line 331
      reg->polarity = 1;
#line 332
      reg->locR = line1x.locPos;
#line 333
      reg->stepR = line1x.stepPos;
#line 334
      reg->locT = line2x.locNeg;
#line 335
      reg->stepT = line2x.stepNeg;
#line 336
      reg->leftLoc = line2x.locBeg;
#line 337
      reg->leftAngle = line2x.angle;
#line 338
      reg->bottomLoc = line1x.locBeg;
#line 339
      reg->bottomAngle = line1x.angle;
#line 340
      reg->leftLine = line2x;
#line 341
      reg->bottomLine = line1x;
    }
  }
#line 347
  tmp___3 = 1;
#line 347
  reg->bottomKnown = tmp___3;
#line 347
  reg->leftKnown = tmp___3;
#line 349
  return (1U);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static long DistanceSquared(DmtxPixelLoc a , DmtxPixelLoc b ) 
{ 
  long xDelta ;
  long yDelta ;

  {
#line 361
  xDelta = (long )(a.X - b.X);
#line 362
  yDelta = (long )(a.Y - b.Y);
#line 364
  return (xDelta * xDelta + yDelta * yDelta);
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
extern unsigned int dmtxRegionUpdateCorners(DmtxDecode *dec , DmtxRegion *reg , DmtxVector2 p00 ,
                                            DmtxVector2 p10 , DmtxVector2 p11 , DmtxVector2 p01 ) 
{ 
  double xMax ;
  double yMax ;
  double tx ;
  double ty ;
  double phi ;
  double shx ;
  double scx ;
  double scy ;
  double skx ;
  double sky ;
  double dimOT ;
  double dimOR ;
  double dimTX ;
  double dimRX ;
  double ratio ;
  DmtxVector2 vOT ;
  DmtxVector2 vOR ;
  DmtxVector2 vTX ;
  DmtxVector2 vRX ;
  DmtxVector2 vTmp ;
  DmtxMatrix3 m ;
  DmtxMatrix3 mtxy ;
  DmtxMatrix3 mphi ;
  DmtxMatrix3 mshx ;
  DmtxMatrix3 mscx ;
  DmtxMatrix3 mscy ;
  DmtxMatrix3 mscxy ;
  DmtxMatrix3 msky ;
  DmtxMatrix3 mskx ;
  int tmp ;
  int tmp___0 ;
  DmtxVector2 *tmp___1 ;
  DmtxVector2 *tmp___2 ;
  DmtxVector2 *tmp___3 ;
  DmtxVector2 *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;

  {
  {
#line 381
  tmp = dmtxDecodeGetProp(dec, 300);
#line 381
  xMax = (double )(tmp - 1);
#line 382
  tmp___0 = dmtxDecodeGetProp(dec, 301);
#line 382
  yMax = (double )(tmp___0 - 1);
  }
#line 384
  if (p00.X < 0.0) {
#line 387
    return (0U);
  } else
#line 384
  if (p00.Y < 0.0) {
#line 387
    return (0U);
  } else
#line 384
  if (p00.X > xMax) {
#line 387
    return (0U);
  } else
#line 384
  if (p00.Y > yMax) {
#line 387
    return (0U);
  } else
#line 384
  if (p01.X < 0.0) {
#line 387
    return (0U);
  } else
#line 384
  if (p01.Y < 0.0) {
#line 387
    return (0U);
  } else
#line 384
  if (p01.X > xMax) {
#line 387
    return (0U);
  } else
#line 384
  if (p01.Y > yMax) {
#line 387
    return (0U);
  } else
#line 384
  if (p10.X < 0.0) {
#line 387
    return (0U);
  } else
#line 384
  if (p10.Y < 0.0) {
#line 387
    return (0U);
  } else
#line 384
  if (p10.X > xMax) {
#line 387
    return (0U);
  } else
#line 384
  if (p10.Y > yMax) {
#line 387
    return (0U);
  }
  {
#line 389
  tmp___1 = dmtxVector2Sub(& vOT, (DmtxVector2 const   *)(& p01), (DmtxVector2 const   *)(& p00));
#line 389
  dimOT = dmtxVector2Mag((DmtxVector2 const   *)tmp___1);
#line 390
  tmp___2 = dmtxVector2Sub(& vOR, (DmtxVector2 const   *)(& p10), (DmtxVector2 const   *)(& p00));
#line 390
  dimOR = dmtxVector2Mag((DmtxVector2 const   *)tmp___2);
#line 391
  tmp___3 = dmtxVector2Sub(& vTX, (DmtxVector2 const   *)(& p11), (DmtxVector2 const   *)(& p01));
#line 391
  dimTX = dmtxVector2Mag((DmtxVector2 const   *)tmp___3);
#line 392
  tmp___4 = dmtxVector2Sub(& vRX, (DmtxVector2 const   *)(& p11), (DmtxVector2 const   *)(& p10));
#line 392
  dimRX = dmtxVector2Mag((DmtxVector2 const   *)tmp___4);
  }
#line 395
  if (dimOT <= 8.0) {
#line 396
    return (0U);
  } else
#line 395
  if (dimOR <= 8.0) {
#line 396
    return (0U);
  } else
#line 395
  if (dimTX <= 8.0) {
#line 396
    return (0U);
  } else
#line 395
  if (dimRX <= 8.0) {
#line 396
    return (0U);
  }
#line 399
  ratio = dimOT / dimRX;
#line 400
  if (ratio <= 0.5) {
#line 401
    return (0U);
  } else
#line 400
  if (ratio >= 2.0) {
#line 401
    return (0U);
  }
#line 403
  ratio = dimOR / dimTX;
#line 404
  if (ratio <= 0.5) {
#line 405
    return (0U);
  } else
#line 404
  if (ratio >= 2.0) {
#line 405
    return (0U);
  }
  {
#line 408
  tmp___5 = dmtxVector2Cross((DmtxVector2 const   *)(& vOR), (DmtxVector2 const   *)(& vRX));
  }
#line 408
  if (tmp___5 <= 0.0) {
#line 410
    return (0U);
  } else {
    {
#line 408
    tmp___6 = dmtxVector2Cross((DmtxVector2 const   *)(& vOT), (DmtxVector2 const   *)(& vTX));
    }
#line 408
    if (tmp___6 >= 0.0) {
#line 410
      return (0U);
    }
  }
  {
#line 412
  tmp___7 = RightAngleTrueness(p00, p10, p11, 1.57079632679489661923);
  }
#line 412
  if (tmp___7 <= dec->squareDevn) {
#line 413
    return (0U);
  }
  {
#line 414
  tmp___8 = RightAngleTrueness(p10, p11, p01, 1.57079632679489661923);
  }
#line 414
  if (tmp___8 <= dec->squareDevn) {
#line 415
    return (0U);
  }
  {
#line 418
  tx = (double )-1 * p00.X;
#line 419
  ty = (double )-1 * p00.Y;
#line 420
  dmtxMatrix3Translate((double (*)[3])(mtxy), tx, ty);
#line 422
  phi = atan2(vOT.X, vOT.Y);
#line 423
  dmtxMatrix3Rotate((double (*)[3])(mphi), phi);
#line 424
  dmtxMatrix3Multiply((double (*)[3])(m), (double (*)[3])(mtxy), (double (*)[3])(mphi));
#line 426
  dmtxMatrix3VMultiply(& vTmp, & p10, (double (*)[3])(m));
#line 427
  shx = - vTmp.Y / vTmp.X;
#line 428
  dmtxMatrix3Shear((double (*)[3])(mshx), 0.0, shx);
#line 429
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mshx));
#line 431
  scx = 1.0 / vTmp.X;
#line 432
  dmtxMatrix3Scale((double (*)[3])(mscx), scx, 1.0);
#line 433
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mscx));
#line 435
  dmtxMatrix3VMultiply(& vTmp, & p11, (double (*)[3])(m));
#line 436
  scy = 1.0 / vTmp.Y;
#line 437
  dmtxMatrix3Scale((double (*)[3])(mscy), 1.0, scy);
#line 438
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mscy));
#line 440
  dmtxMatrix3VMultiply(& vTmp, & p11, (double (*)[3])(m));
#line 441
  skx = vTmp.X;
#line 442
  dmtxMatrix3LineSkewSide((double (*)[3])(mskx), 1.0, skx, 1.0);
#line 443
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mskx));
#line 445
  dmtxMatrix3VMultiply(& vTmp, & p01, (double (*)[3])(m));
#line 446
  sky = vTmp.Y;
#line 447
  dmtxMatrix3LineSkewTop((double (*)[3])(msky), sky, 1.0, 1.0);
#line 448
  dmtxMatrix3Multiply((double (*)[3])(reg->raw2fit), (double (*)[3])(m), (double (*)[3])(msky));
#line 451
  dmtxMatrix3LineSkewTopInv((double (*)[3])(msky), sky, 1.0, 1.0);
#line 452
  dmtxMatrix3LineSkewSideInv((double (*)[3])(mskx), 1.0, skx, 1.0);
#line 453
  dmtxMatrix3Multiply((double (*)[3])(m), (double (*)[3])(msky), (double (*)[3])(mskx));
#line 455
  dmtxMatrix3Scale((double (*)[3])(mscxy), 1.0 / scx, 1.0 / scy);
#line 456
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mscxy));
#line 458
  dmtxMatrix3Shear((double (*)[3])(mshx), 0.0, - shx);
#line 459
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mshx));
#line 461
  dmtxMatrix3Rotate((double (*)[3])(mphi), - phi);
#line 462
  dmtxMatrix3MultiplyBy((double (*)[3])(m), (double (*)[3])(mphi));
#line 464
  dmtxMatrix3Translate((double (*)[3])(mtxy), - tx, - ty);
#line 465
  dmtxMatrix3Multiply((double (*)[3])(reg->fit2raw), (double (*)[3])(m), (double (*)[3])(mtxy));
  }
#line 467
  return (1U);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
extern unsigned int dmtxRegionUpdateXfrms(DmtxDecode *dec , DmtxRegion *reg ) 
{ 
  double radians ;
  DmtxRay2 rLeft ;
  DmtxRay2 rBottom ;
  DmtxRay2 rTop ;
  DmtxRay2 rRight ;
  DmtxVector2 p00 ;
  DmtxVector2 p10 ;
  DmtxVector2 p11 ;
  DmtxVector2 p01 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 481
  if (reg->leftKnown != 0) {
#line 481
    if (! (reg->bottomKnown != 0)) {
      {
#line 481
      __assert_fail("reg->leftKnown != 0 && reg->bottomKnown != 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    481U, "dmtxRegionUpdateXfrms");
      }
    }
  } else {
    {
#line 481
    __assert_fail("reg->leftKnown != 0 && reg->bottomKnown != 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  481U, "dmtxRegionUpdateXfrms");
    }
  }
  {
#line 484
  rLeft.p.X = (double )reg->leftLoc.X;
#line 485
  rLeft.p.Y = (double )reg->leftLoc.Y;
#line 486
  radians = (double )reg->leftAngle * (3.14159265358979323846 / (double )180);
#line 487
  rLeft.v.X = cos(radians);
#line 488
  rLeft.v.Y = sin(radians);
#line 489
  rLeft.tMin = 0.0;
#line 490
  rLeft.tMax = dmtxVector2Norm(& rLeft.v);
#line 493
  rBottom.p.X = (double )reg->bottomLoc.X;
#line 494
  rBottom.p.Y = (double )reg->bottomLoc.Y;
#line 495
  radians = (double )reg->bottomAngle * (3.14159265358979323846 / (double )180);
#line 496
  rBottom.v.X = cos(radians);
#line 497
  rBottom.v.Y = sin(radians);
#line 498
  rBottom.tMin = 0.0;
#line 499
  rBottom.tMax = dmtxVector2Norm(& rBottom.v);
  }
#line 502
  if (reg->topKnown != 0) {
    {
#line 503
    rTop.p.X = (double )reg->topLoc.X;
#line 504
    rTop.p.Y = (double )reg->topLoc.Y;
#line 505
    radians = (double )reg->topAngle * (3.14159265358979323846 / (double )180);
#line 506
    rTop.v.X = cos(radians);
#line 507
    rTop.v.Y = sin(radians);
#line 508
    rTop.tMin = 0.0;
#line 509
    rTop.tMax = dmtxVector2Norm(& rTop.v);
    }
  } else {
    {
#line 512
    rTop.p.X = (double )reg->locT.X;
#line 513
    rTop.p.Y = (double )reg->locT.Y;
#line 514
    radians = (double )reg->bottomAngle * (3.14159265358979323846 / (double )180);
#line 515
    rTop.v.X = cos(radians);
#line 516
    rTop.v.Y = sin(radians);
#line 517
    rTop.tMin = 0.0;
#line 518
    rTop.tMax = rBottom.tMax;
    }
  }
#line 522
  if (reg->rightKnown != 0) {
    {
#line 523
    rRight.p.X = (double )reg->rightLoc.X;
#line 524
    rRight.p.Y = (double )reg->rightLoc.Y;
#line 525
    radians = (double )reg->rightAngle * (3.14159265358979323846 / (double )180);
#line 526
    rRight.v.X = cos(radians);
#line 527
    rRight.v.Y = sin(radians);
#line 528
    rRight.tMin = 0.0;
#line 529
    rRight.tMax = dmtxVector2Norm(& rRight.v);
    }
  } else {
    {
#line 532
    rRight.p.X = (double )reg->locR.X;
#line 533
    rRight.p.Y = (double )reg->locR.Y;
#line 534
    radians = (double )reg->leftAngle * (3.14159265358979323846 / (double )180);
#line 535
    rRight.v.X = cos(radians);
#line 536
    rRight.v.Y = sin(radians);
#line 537
    rRight.tMin = 0.0;
#line 538
    rRight.tMax = rLeft.tMax;
    }
  }
  {
#line 542
  tmp = dmtxRay2Intersect(& p00, (DmtxRay2 const   *)(& rLeft), (DmtxRay2 const   *)(& rBottom));
  }
#line 542
  if (tmp == 0U) {
#line 543
    return (0U);
  }
  {
#line 545
  tmp___0 = dmtxRay2Intersect(& p10, (DmtxRay2 const   *)(& rBottom), (DmtxRay2 const   *)(& rRight));
  }
#line 545
  if (tmp___0 == 0U) {
#line 546
    return (0U);
  }
  {
#line 548
  tmp___1 = dmtxRay2Intersect(& p11, (DmtxRay2 const   *)(& rRight), (DmtxRay2 const   *)(& rTop));
  }
#line 548
  if (tmp___1 == 0U) {
#line 549
    return (0U);
  }
  {
#line 551
  tmp___2 = dmtxRay2Intersect(& p01, (DmtxRay2 const   *)(& rTop), (DmtxRay2 const   *)(& rLeft));
  }
#line 551
  if (tmp___2 == 0U) {
#line 552
    return (0U);
  }
  {
#line 554
  tmp___3 = dmtxRegionUpdateCorners(dec, reg, p00, p10, p11, p01);
  }
#line 554
  if (tmp___3 != 1U) {
#line 555
    return (0U);
  }
#line 557
  return (1U);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static double RightAngleTrueness(DmtxVector2 c0 , DmtxVector2 c1 , DmtxVector2 c2 ,
                                 double angle ) 
{ 
  DmtxVector2 vA ;
  DmtxVector2 vB ;
  DmtxMatrix3 m ;
  DmtxVector2 *tmp ;
  DmtxVector2 *tmp___0 ;
  double tmp___1 ;

  {
  {
#line 570
  tmp = dmtxVector2Sub(& vA, (DmtxVector2 const   *)(& c0), (DmtxVector2 const   *)(& c1));
#line 570
  dmtxVector2Norm(tmp);
#line 571
  tmp___0 = dmtxVector2Sub(& vB, (DmtxVector2 const   *)(& c2), (DmtxVector2 const   *)(& c1));
#line 571
  dmtxVector2Norm(tmp___0);
#line 573
  dmtxMatrix3Rotate((double (*)[3])(m), angle);
#line 574
  dmtxMatrix3VMultiplyBy(& vB, (double (*)[3])(m));
#line 576
  tmp___1 = dmtxVector2Dot((DmtxVector2 const   *)(& vA), (DmtxVector2 const   *)(& vB));
  }
#line 576
  return (tmp___1);
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static int ReadModuleColor(DmtxDecode *dec , DmtxRegion *reg , int symbolRow , int symbolCol ,
                           int sizeIdx , int colorPlane ) 
{ 
  int err ;
  int i ;
  int symbolRows ;
  int symbolCols ;
  int color ;
  int colorTmp ;
  double sampleX[5] ;
  double sampleY[5] ;
  DmtxVector2 p ;
  unsigned int tmp ;

  {
  {
#line 596
  sampleX[0] = 0.5;
#line 596
  sampleX[1] = 0.4;
#line 596
  sampleX[2] = 0.5;
#line 596
  sampleX[3] = 0.6;
#line 596
  sampleX[4] = 0.5;
#line 597
  sampleY[0] = 0.5;
#line 597
  sampleY[1] = 0.5;
#line 597
  sampleY[2] = 0.4;
#line 597
  sampleY[3] = 0.5;
#line 597
  sampleY[4] = 0.6;
#line 600
  symbolRows = dmtxGetSymbolAttribute(0, sizeIdx);
#line 601
  symbolCols = dmtxGetSymbolAttribute(1, sizeIdx);
#line 603
  color = 0;
#line 604
  i = 0;
  }
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! (i < 5)) {
#line 604
      goto while_break;
    }
    {
#line 606
    p.X = (1.0 / (double )symbolCols) * ((double )symbolCol + sampleX[i]);
#line 607
    p.Y = (1.0 / (double )symbolRows) * ((double )symbolRow + sampleY[i]);
#line 609
    dmtxMatrix3VMultiplyBy(& p, (double (*)[3])(reg->fit2raw));
#line 611
    tmp = dmtxDecodeGetPixelValue(dec, (int )(p.X + 0.5), (int )(p.Y + 0.5), colorPlane,
                                  & colorTmp);
#line 611
    err = (int )tmp;
#line 613
    color += colorTmp;
#line 604
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return (color / 5);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int MatrixRegionFindSize(DmtxDecode *dec , DmtxRegion *reg ) 
{ 
  int row ;
  int col ;
  int sizeIdxBeg ;
  int sizeIdxEnd ;
  int sizeIdx ;
  int bestSizeIdx ;
  int symbolRows ;
  int symbolCols ;
  int jumpCount ;
  int errors ;
  int color ;
  int colorOnAvg ;
  int bestColorOnAvg ;
  int colorOffAvg ;
  int bestColorOffAvg ;
  int contrast ;
  int bestContrast ;
  DmtxImage *img ;

  {
#line 639
  img = dec->image;
#line 640
  bestSizeIdx = -1;
#line 641
  bestContrast = 0;
#line 642
  bestColorOffAvg = 0;
#line 642
  bestColorOnAvg = bestColorOffAvg;
#line 644
  if (dec->sizeIdxExpected == -1) {
#line 645
    sizeIdxBeg = 0;
#line 646
    sizeIdxEnd = 30;
  } else
#line 648
  if (dec->sizeIdxExpected == -2) {
#line 649
    sizeIdxBeg = 0;
#line 650
    sizeIdxEnd = 24;
  } else
#line 652
  if (dec->sizeIdxExpected == -3) {
#line 653
    sizeIdxBeg = 24;
#line 654
    sizeIdxEnd = 30;
  } else {
#line 657
    sizeIdxBeg = dec->sizeIdxExpected;
#line 658
    sizeIdxEnd = dec->sizeIdxExpected + 1;
  }
#line 662
  sizeIdx = sizeIdxBeg;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! (sizeIdx < sizeIdxEnd)) {
#line 662
      goto while_break;
    }
    {
#line 664
    symbolRows = dmtxGetSymbolAttribute(0, sizeIdx);
#line 665
    symbolCols = dmtxGetSymbolAttribute(1, sizeIdx);
#line 666
    colorOffAvg = 0;
#line 666
    colorOnAvg = colorOffAvg;
#line 669
    row = symbolRows - 1;
#line 670
    col = 0;
    }
    {
#line 670
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 670
      if (! (col < symbolCols)) {
#line 670
        goto while_break___0;
      }
      {
#line 671
      color = ReadModuleColor(dec, reg, row, col, sizeIdx, reg->flowBegin.plane);
      }
#line 672
      if ((col & 1) != 0) {
#line 673
        colorOffAvg += color;
      } else {
#line 675
        colorOnAvg += color;
      }
#line 670
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 679
    col = symbolCols - 1;
#line 680
    row = 0;
    {
#line 680
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 680
      if (! (row < symbolRows)) {
#line 680
        goto while_break___1;
      }
      {
#line 681
      color = ReadModuleColor(dec, reg, row, col, sizeIdx, reg->flowBegin.plane);
      }
#line 682
      if ((row & 1) != 0) {
#line 683
        colorOffAvg += color;
      } else {
#line 685
        colorOnAvg += color;
      }
#line 680
      row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 688
    colorOnAvg = (colorOnAvg * 2) / (symbolRows + symbolCols);
#line 689
    colorOffAvg = (colorOffAvg * 2) / (symbolRows + symbolCols);
#line 691
    contrast = abs(colorOnAvg - colorOffAvg);
    }
#line 692
    if (contrast < 20) {
#line 693
      goto __Cont;
    }
#line 695
    if (contrast > bestContrast) {
#line 696
      bestContrast = contrast;
#line 697
      bestSizeIdx = sizeIdx;
#line 698
      bestColorOnAvg = colorOnAvg;
#line 699
      bestColorOffAvg = colorOffAvg;
    }
    __Cont: /* CIL Label */ 
#line 662
    sizeIdx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if (bestSizeIdx == -1) {
#line 705
    return (0U);
  } else
#line 704
  if (bestContrast < 20) {
#line 705
    return (0U);
  }
  {
#line 707
  reg->sizeIdx = bestSizeIdx;
#line 708
  reg->onColor = bestColorOnAvg;
#line 709
  reg->offColor = bestColorOffAvg;
#line 711
  reg->symbolRows = dmtxGetSymbolAttribute(0, reg->sizeIdx);
#line 712
  reg->symbolCols = dmtxGetSymbolAttribute(1, reg->sizeIdx);
#line 713
  reg->mappingRows = dmtxGetSymbolAttribute(6, reg->sizeIdx);
#line 714
  reg->mappingCols = dmtxGetSymbolAttribute(7, reg->sizeIdx);
#line 717
  jumpCount = CountJumpTally(dec, reg, 0, reg->symbolRows - 1, (DmtxDirection )8);
#line 718
  errors = abs((1 + jumpCount) - reg->symbolCols);
  }
#line 719
  if (jumpCount < 0) {
#line 720
    return (0U);
  } else
#line 719
  if (errors > 2) {
#line 720
    return (0U);
  }
  {
#line 723
  jumpCount = CountJumpTally(dec, reg, reg->symbolCols - 1, 0, (DmtxDirection )1);
#line 724
  errors = abs((1 + jumpCount) - reg->symbolRows);
  }
#line 725
  if (jumpCount < 0) {
#line 726
    return (0U);
  } else
#line 725
  if (errors > 2) {
#line 726
    return (0U);
  }
  {
#line 729
  errors = CountJumpTally(dec, reg, 0, 0, (DmtxDirection )8);
  }
#line 730
  if (jumpCount < 0) {
#line 731
    return (0U);
  } else
#line 730
  if (errors > 2) {
#line 731
    return (0U);
  }
  {
#line 734
  errors = CountJumpTally(dec, reg, 0, 0, (DmtxDirection )1);
  }
#line 735
  if (errors < 0) {
#line 736
    return (0U);
  } else
#line 735
  if (errors > 2) {
#line 736
    return (0U);
  }
  {
#line 739
  errors = CountJumpTally(dec, reg, 0, -1, (DmtxDirection )8);
  }
#line 740
  if (errors < 0) {
#line 741
    return (0U);
  } else
#line 740
  if (errors > 2) {
#line 741
    return (0U);
  }
  {
#line 743
  errors = CountJumpTally(dec, reg, -1, 0, (DmtxDirection )1);
  }
#line 744
  if (errors < 0) {
#line 745
    return (0U);
  } else
#line 744
  if (errors > 2) {
#line 745
    return (0U);
  }
  {
#line 747
  errors = CountJumpTally(dec, reg, 0, reg->symbolRows, (DmtxDirection )8);
  }
#line 748
  if (errors < 0) {
#line 749
    return (0U);
  } else
#line 748
  if (errors > 2) {
#line 749
    return (0U);
  }
  {
#line 751
  errors = CountJumpTally(dec, reg, reg->symbolCols, 0, (DmtxDirection )1);
  }
#line 752
  if (errors < 0) {
#line 753
    return (0U);
  } else
#line 752
  if (errors > 2) {
#line 753
    return (0U);
  }
#line 755
  return (1U);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static int CountJumpTally(DmtxDecode *dec , DmtxRegion *reg , int xStart , int yStart ,
                          DmtxDirection dir ) 
{ 
  int x ;
  int xInc ;
  int y ;
  int yInc ;
  int state ;
  int jumpCount ;
  int jumpThreshold ;
  int tModule ;
  int tPrev ;
  int darkOnLight ;
  int color ;

  {
#line 770
  xInc = 0;
#line 771
  yInc = 0;
#line 772
  state = 7;
#line 773
  jumpCount = 0;
#line 779
  if (! (xStart == 0)) {
#line 779
    if (! (yStart == 0)) {
      {
#line 779
      __assert_fail("xStart == 0 || yStart == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    779U, "CountJumpTally");
      }
    }
  }
#line 780
  if (! ((unsigned int )dir == 8U)) {
#line 780
    if (! ((unsigned int )dir == 1U)) {
      {
#line 780
      __assert_fail("dir == DmtxDirRight || dir == DmtxDirUp", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    780U, "CountJumpTally");
      }
    }
  }
#line 782
  if ((unsigned int )dir == 8U) {
#line 783
    xInc = 1;
  } else {
#line 785
    yInc = 1;
  }
#line 787
  if (xStart == -1) {
#line 789
    state = 0;
  } else
#line 787
  if (xStart == reg->symbolCols) {
#line 789
    state = 0;
  } else
#line 787
  if (yStart == -1) {
#line 789
    state = 0;
  } else
#line 787
  if (yStart == reg->symbolRows) {
#line 789
    state = 0;
  }
  {
#line 791
  darkOnLight = reg->offColor > reg->onColor;
#line 792
  jumpThreshold = abs((int )(0.4 * (double )(reg->onColor - reg->offColor) + 0.5));
#line 793
  color = ReadModuleColor(dec, reg, yStart, xStart, reg->sizeIdx, reg->flowBegin.plane);
  }
#line 794
  if (darkOnLight) {
#line 794
    tModule = reg->offColor - color;
  } else {
#line 794
    tModule = color - reg->offColor;
  }
#line 796
  x = xStart + xInc;
#line 796
  y = yStart + yInc;
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if ((unsigned int )dir == 8U) {
#line 796
      if (! (x < reg->symbolCols)) {
#line 796
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 796
    if ((unsigned int )dir == 1U) {
#line 796
      if (! (y < reg->symbolRows)) {
#line 796
        goto while_break;
      }
    } else {
#line 796
      goto while_break;
    }
    {
#line 801
    tPrev = tModule;
#line 802
    color = ReadModuleColor(dec, reg, y, x, reg->sizeIdx, reg->flowBegin.plane);
    }
#line 803
    if (darkOnLight) {
#line 803
      tModule = reg->offColor - color;
    } else {
#line 803
      tModule = color - reg->offColor;
    }
#line 805
    if (state == 0) {
#line 806
      if (tModule > tPrev + jumpThreshold) {
#line 807
        jumpCount ++;
#line 808
        state = 7;
      }
    } else
#line 812
    if (tModule < tPrev - jumpThreshold) {
#line 813
      jumpCount ++;
#line 814
      state = 0;
    }
#line 796
    x += xInc;
#line 796
    y += yInc;
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  return (jumpCount);
}
}
#line 829
static DmtxPointFlow GetPointFlow(DmtxDecode *dec , int colorPlane , DmtxPixelLoc loc ,
                                  int arrive ) ;
#line 829 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static int const   coefficient[8]  = 
#line 829
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )1, 
        (int const   )0,      (int const   )-1,      (int const   )-2,      (int const   )-1};
#line 826 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxPointFlow GetPointFlow(DmtxDecode *dec , int colorPlane , DmtxPixelLoc loc ,
                                  int arrive ) 
{ 
  int err ;
  int patternIdx ;
  int coefficientIdx ;
  int compass ;
  int compassMax ;
  int mag[4] ;
  unsigned int tmp ;
  int xAdjust ;
  int yAdjust ;
  int color ;
  int colorPattern[8] ;
  DmtxPointFlow flow ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 833
  mag[0] = 0;
#line 833
  tmp = 1U;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (tmp >= 4U) {
#line 833
      goto while_break;
    }
#line 833
    mag[tmp] = 0;
#line 833
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  patternIdx = 0;
  {
#line 838
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 838
    if (! (patternIdx < 8)) {
#line 838
      goto while_break___0;
    }
    {
#line 839
    xAdjust = loc.X + (int )dmtxPatternX[patternIdx];
#line 840
    yAdjust = loc.Y + (int )dmtxPatternY[patternIdx];
#line 841
    tmp___0 = dmtxDecodeGetPixelValue(dec, xAdjust, yAdjust, colorPlane, & colorPattern[patternIdx]);
#line 841
    err = (int )tmp___0;
    }
#line 843
    if (err == 0) {
#line 844
      return ((DmtxPointFlow )dmtxBlankEdge);
    }
#line 838
    patternIdx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 848
  compassMax = 0;
#line 849
  compass = 0;
  {
#line 849
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 849
    if (! (compass < 4)) {
#line 849
      goto while_break___1;
    }
#line 852
    patternIdx = 0;
    {
#line 852
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 852
      if (! (patternIdx < 8)) {
#line 852
        goto while_break___2;
      }
#line 854
      coefficientIdx = ((patternIdx - compass) + 8) % 8;
#line 855
      if (coefficient[coefficientIdx] == 0) {
#line 856
        goto __Cont;
      }
#line 858
      color = colorPattern[patternIdx];
      {
#line 861
      if (coefficient[coefficientIdx] == 2) {
#line 861
        goto case_2;
      }
#line 864
      if (coefficient[coefficientIdx] == 1) {
#line 864
        goto case_1;
      }
#line 867
      if (coefficient[coefficientIdx] == -2) {
#line 867
        goto case_neg_2;
      }
#line 870
      if (coefficient[coefficientIdx] == -1) {
#line 870
        goto case_neg_1;
      }
#line 860
      goto switch_break;
      case_2: /* CIL Label */ 
#line 862
      mag[compass] += color;
      case_1: /* CIL Label */ 
#line 865
      mag[compass] += color;
#line 866
      goto switch_break;
      case_neg_2: /* CIL Label */ 
#line 868
      mag[compass] -= color;
      case_neg_1: /* CIL Label */ 
#line 871
      mag[compass] -= color;
#line 872
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 852
      patternIdx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 877
    if (compass != 0) {
      {
#line 877
      tmp___1 = abs(mag[compass]);
#line 877
      tmp___2 = abs(mag[compassMax]);
      }
#line 877
      if (tmp___1 > tmp___2) {
#line 878
        compassMax = compass;
      }
    }
#line 849
    compass ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 882
  flow.plane = colorPlane;
#line 883
  flow.arrive = arrive;
#line 884
  if (mag[compassMax] > 0) {
#line 884
    flow.depart = compassMax + 4;
  } else {
#line 884
    flow.depart = compassMax;
  }
  {
#line 885
  flow.mag = abs(mag[compassMax]);
#line 886
  flow.loc = loc;
  }
#line 888
  return (flow);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxPointFlow FindStrongestNeighbor(DmtxDecode *dec , DmtxPointFlow center ,
                                           int sign ) 
{ 
  int i ;
  int strongIdx ;
  int attempt ;
  int attemptDiff ;
  int occupied ;
  unsigned char *cache ;
  DmtxPixelLoc loc ;
  DmtxPointFlow flow[8] ;
  struct DmtxPointFlow_struct tmp ;

  {
#line 906
  if (sign < 0) {
#line 906
    attempt = center.depart;
  } else {
#line 906
    attempt = (center.depart + 4) % 8;
  }
#line 908
  occupied = 0;
#line 909
  strongIdx = -1;
#line 910
  i = 0;
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    if (! (i < 8)) {
#line 910
      goto while_break;
    }
    {
#line 912
    loc.X = center.loc.X + (int )dmtxPatternX[i];
#line 913
    loc.Y = center.loc.Y + (int )dmtxPatternY[i];
#line 915
    cache = dmtxDecodeGetCache(dec, loc.X, loc.Y);
    }
#line 916
    if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 917
      goto __Cont;
    }
#line 919
    if (((int )*cache & 128) != 0) {
#line 920
      occupied ++;
#line 920
      if (occupied > 2) {
#line 921
        return ((DmtxPointFlow )dmtxBlankEdge);
      } else {
#line 923
        goto __Cont;
      }
    }
    {
#line 926
    attemptDiff = abs(attempt - i);
    }
#line 927
    if (attemptDiff > 4) {
#line 928
      attemptDiff = 8 - attemptDiff;
    }
#line 929
    if (attemptDiff > 1) {
#line 930
      goto __Cont;
    }
    {
#line 932
    flow[i] = GetPointFlow(dec, center.plane, loc, i);
    }
#line 934
    if (strongIdx == -1) {
#line 936
      strongIdx = i;
    } else
#line 934
    if (flow[i].mag > flow[strongIdx].mag) {
#line 936
      strongIdx = i;
    } else
#line 934
    if (flow[i].mag == flow[strongIdx].mag) {
#line 934
      if ((i & 1) != 0) {
#line 936
        strongIdx = i;
      }
    }
    __Cont: /* CIL Label */ 
#line 910
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 940
  if (strongIdx == -1) {
#line 940
    tmp = dmtxBlankEdge;
  } else {
#line 940
    tmp = (struct DmtxPointFlow_struct  const  )flow[strongIdx];
  }
#line 940
  return ((DmtxPointFlow )tmp);
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxFollow FollowSeek(DmtxDecode *dec , DmtxRegion *reg , int seek ) 
{ 
  int i ;
  int sign ;
  DmtxFollow follow ;
  int tmp ;

  {
  {
#line 954
  follow.loc = reg->flowBegin.loc;
#line 955
  follow.step = 0;
#line 956
  follow.ptr = dmtxDecodeGetCache(dec, follow.loc.X, follow.loc.Y);
  }
#line 957
  if (! ((unsigned long )follow.ptr != (unsigned long )((void *)0))) {
    {
#line 957
    __assert_fail("follow.ptr != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  957U, "FollowSeek");
    }
  }
#line 958
  follow.neighbor = *(follow.ptr);
#line 960
  if (seek > 0) {
#line 960
    sign = 1;
  } else {
#line 960
    sign = -1;
  }
#line 961
  i = 0;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (i != seek)) {
#line 961
      goto while_break;
    }
    {
#line 962
    follow = FollowStep(dec, reg, follow, sign);
    }
#line 963
    if (! ((unsigned long )follow.ptr != (unsigned long )((void *)0))) {
      {
#line 963
      __assert_fail("follow.ptr != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    963U, "FollowSeek");
      }
    }
    {
#line 964
    tmp = abs(follow.step);
    }
#line 964
    if (! (tmp <= reg->stepsTotal)) {
      {
#line 964
      __assert_fail("abs(follow.step) <= reg->stepsTotal", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    964U, "FollowSeek");
      }
    }
#line 961
    i += sign;
  }
  while_break: /* CIL Label */ ;
  }
#line 967
  return (follow);
}
}
#line 974 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxFollow FollowSeekLoc(DmtxDecode *dec , DmtxPixelLoc loc ) 
{ 
  DmtxFollow follow ;

  {
  {
#line 979
  follow.loc = loc;
#line 980
  follow.step = 0;
#line 981
  follow.ptr = dmtxDecodeGetCache(dec, follow.loc.X, follow.loc.Y);
  }
#line 982
  if (! ((unsigned long )follow.ptr != (unsigned long )((void *)0))) {
    {
#line 982
    __assert_fail("follow.ptr != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  982U, "FollowSeekLoc");
    }
  }
#line 983
  follow.neighbor = *(follow.ptr);
#line 985
  return (follow);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxFollow FollowStep(DmtxDecode *dec , DmtxRegion *reg , DmtxFollow followBeg ,
                             int sign ) 
{ 
  int patternIdx ;
  int stepMod ;
  int factor ;
  DmtxFollow follow ;
  int tmp ;

  {
  {
#line 1001
  tmp = abs(sign);
  }
#line 1001
  if (! (tmp == 1)) {
    {
#line 1001
    __assert_fail("abs(sign) == 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1001U, "FollowStep");
    }
  }
#line 1002
  if (! (((int )followBeg.neighbor & 64) != 0)) {
    {
#line 1002
    __assert_fail("(int)(followBeg.neighbor & 0x40) != 0x00", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1002U, "FollowStep");
    }
  }
#line 1004
  factor = reg->stepsTotal + 1;
#line 1005
  if (sign > 0) {
#line 1006
    stepMod = (factor + followBeg.step % factor) % factor;
  } else {
#line 1008
    stepMod = (factor - followBeg.step % factor) % factor;
  }
#line 1011
  if (sign > 0) {
#line 1011
    if (stepMod == reg->jumpToNeg) {
#line 1012
      follow.loc = reg->finalNeg;
    } else {
#line 1011
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1015
  if (sign < 0) {
#line 1015
    if (stepMod == reg->jumpToPos) {
#line 1016
      follow.loc = reg->finalPos;
    } else {
#line 1015
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1020
    if (sign < 0) {
#line 1020
      patternIdx = (int )followBeg.neighbor & 7;
    } else {
#line 1020
      patternIdx = ((int )followBeg.neighbor & 56) >> 3;
    }
#line 1021
    follow.loc.X = followBeg.loc.X + (int )dmtxPatternX[patternIdx];
#line 1022
    follow.loc.Y = followBeg.loc.Y + (int )dmtxPatternY[patternIdx];
  }
  {
#line 1025
  follow.step = followBeg.step + sign;
#line 1026
  follow.ptr = dmtxDecodeGetCache(dec, follow.loc.X, follow.loc.Y);
  }
#line 1027
  if (! ((unsigned long )follow.ptr != (unsigned long )((void *)0))) {
    {
#line 1027
    __assert_fail("follow.ptr != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1027U, "FollowStep");
    }
  }
#line 1028
  follow.neighbor = *(follow.ptr);
#line 1030
  return (follow);
}
}
#line 1037 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxFollow FollowStep2(DmtxDecode *dec , DmtxFollow followBeg , int sign ) 
{ 
  int patternIdx ;
  DmtxFollow follow ;
  int tmp ;

  {
  {
#line 1043
  tmp = abs(sign);
  }
#line 1043
  if (! (tmp == 1)) {
    {
#line 1043
    __assert_fail("abs(sign) == 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1043U, "FollowStep2");
    }
  }
#line 1044
  if (! (((int )followBeg.neighbor & 64) != 0)) {
    {
#line 1044
    __assert_fail("(int)(followBeg.neighbor & 0x40) != 0x00", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1044U, "FollowStep2");
    }
  }
#line 1046
  if (sign < 0) {
#line 1046
    patternIdx = (int )followBeg.neighbor & 7;
  } else {
#line 1046
    patternIdx = ((int )followBeg.neighbor & 56) >> 3;
  }
  {
#line 1047
  follow.loc.X = followBeg.loc.X + (int )dmtxPatternX[patternIdx];
#line 1048
  follow.loc.Y = followBeg.loc.Y + (int )dmtxPatternY[patternIdx];
#line 1050
  follow.step = followBeg.step + sign;
#line 1051
  follow.ptr = dmtxDecodeGetCache(dec, follow.loc.X, follow.loc.Y);
  }
#line 1052
  if (! ((unsigned long )follow.ptr != (unsigned long )((void *)0))) {
    {
#line 1052
    __assert_fail("follow.ptr != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1052U, "FollowStep2");
    }
  }
#line 1053
  follow.neighbor = *(follow.ptr);
#line 1055
  return (follow);
}
}
#line 1066 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int TrailBlazeContinuous(DmtxDecode *dec , DmtxRegion *reg , DmtxPointFlow flowBegin ,
                                         int maxDiagonal ) 
{ 
  int posAssigns ;
  int negAssigns ;
  int clears ;
  int sign ;
  int steps ;
  unsigned char *cache ;
  unsigned char *cacheNext ;
  unsigned char *cacheBeg ;
  DmtxPointFlow flow ;
  DmtxPointFlow flowNext ;
  DmtxPixelLoc boundMin ;
  DmtxPixelLoc boundMax ;
  int tmp ;

  {
  {
#line 1076
  boundMax = flowBegin.loc;
#line 1076
  boundMin = boundMax;
#line 1077
  cacheBeg = dmtxDecodeGetCache(dec, flowBegin.loc.X, flowBegin.loc.Y);
  }
#line 1078
  if ((unsigned long )cacheBeg == (unsigned long )((void *)0)) {
#line 1079
    return (0U);
  }
#line 1080
  *cacheBeg = (unsigned char)192;
#line 1082
  reg->flowBegin = flowBegin;
#line 1084
  negAssigns = 0;
#line 1084
  posAssigns = negAssigns;
#line 1085
  sign = 1;
  {
#line 1085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1085
    if (! (sign >= -1)) {
#line 1085
      goto while_break;
    }
#line 1087
    flow = flowBegin;
#line 1088
    cache = cacheBeg;
#line 1090
    steps = 0;
    {
#line 1090
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1092
      if (maxDiagonal != -1) {
#line 1092
        if (boundMax.X - boundMin.X > maxDiagonal) {
#line 1094
          goto while_break___0;
        } else
#line 1092
        if (boundMax.Y - boundMin.Y > maxDiagonal) {
#line 1094
          goto while_break___0;
        }
      }
      {
#line 1097
      flowNext = FindStrongestNeighbor(dec, flow, sign);
      }
#line 1098
      if (flowNext.mag < 50) {
#line 1099
        goto while_break___0;
      }
      {
#line 1102
      cacheNext = dmtxDecodeGetCache(dec, flowNext.loc.X, flowNext.loc.Y);
      }
#line 1103
      if ((unsigned long )cacheNext == (unsigned long )((void *)0)) {
#line 1104
        goto while_break___0;
      }
#line 1105
      if (! (! ((int )*cacheNext & 128))) {
        {
#line 1105
        __assert_fail("!(*cacheNext & 0x80)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                      1105U, "TrailBlazeContinuous");
        }
      }
#line 1110
      if (sign < 0) {
#line 1110
        tmp = flowNext.arrive;
      } else {
#line 1110
        tmp = flowNext.arrive << 3;
      }
#line 1110
      *cache = (unsigned char )((int )*cache | tmp);
#line 1115
      if (sign < 0) {
#line 1115
        *cacheNext = (unsigned char )((flowNext.arrive + 4) % 8 << 3);
      } else {
#line 1115
        *cacheNext = (unsigned char )((flowNext.arrive + 4) % 8);
      }
#line 1116
      *cacheNext = (unsigned char )((int )*cacheNext | 192);
#line 1117
      if (sign > 0) {
#line 1118
        posAssigns ++;
      } else {
#line 1120
        negAssigns ++;
      }
#line 1121
      cache = cacheNext;
#line 1122
      flow = flowNext;
#line 1124
      if (flow.loc.X > boundMax.X) {
#line 1125
        boundMax.X = flow.loc.X;
      } else
#line 1126
      if (flow.loc.X < boundMin.X) {
#line 1127
        boundMin.X = flow.loc.X;
      }
#line 1128
      if (flow.loc.Y > boundMax.Y) {
#line 1129
        boundMax.Y = flow.loc.Y;
      } else
#line 1130
      if (flow.loc.Y < boundMin.Y) {
#line 1131
        boundMin.Y = flow.loc.Y;
      }
#line 1090
      steps ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1136
    if (sign > 0) {
#line 1137
      reg->finalPos = flow.loc;
#line 1138
      reg->jumpToNeg = steps;
    } else {
#line 1141
      reg->finalNeg = flow.loc;
#line 1142
      reg->jumpToPos = steps;
    }
#line 1085
    sign -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1145
  reg->stepsTotal = reg->jumpToPos + reg->jumpToNeg;
#line 1146
  reg->boundMin = boundMin;
#line 1147
  reg->boundMax = boundMax;
#line 1150
  clears = TrailClear(dec, reg, 128);
  }
#line 1151
  if (! (posAssigns + negAssigns == clears - 1)) {
    {
#line 1151
    __assert_fail("posAssigns + negAssigns == clears - 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1151U, "TrailBlazeContinuous");
    }
  }
#line 1154
  if (maxDiagonal != -1) {
#line 1154
    if (boundMax.X - boundMin.X > maxDiagonal) {
#line 1156
      return (0U);
    } else
#line 1154
    if (boundMax.Y - boundMin.Y > maxDiagonal) {
#line 1156
      return (0U);
    }
  }
#line 1158
  return (1U);
}
}
#line 1166 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static int TrailBlazeGapped(DmtxDecode *dec , DmtxRegion *reg , DmtxBresLine line ,
                            int streamDir ) 
{ 
  unsigned char *beforeCache ;
  unsigned char *afterCache ;
  unsigned int onEdge ;
  int distSq ;
  int distSqMax ;
  int travel ;
  int outward ;
  int xDiff ;
  int yDiff ;
  int steps ;
  int stepDir ;
  int dirMap[9] ;
  unsigned int err ;
  DmtxPixelLoc beforeStep ;
  DmtxPixelLoc afterStep ;
  DmtxPointFlow flow ;
  DmtxPointFlow flowNext ;
  DmtxPixelLoc loc0 ;
  int xStep ;
  int yStep ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1175
  dirMap[0] = 0;
#line 1175
  dirMap[1] = 1;
#line 1175
  dirMap[2] = 2;
#line 1175
  dirMap[3] = 7;
#line 1175
  dirMap[4] = 8;
#line 1175
  dirMap[5] = 3;
#line 1175
  dirMap[6] = 6;
#line 1175
  dirMap[7] = 5;
#line 1175
  dirMap[8] = 4;
#line 1182
  loc0 = line.loc;
#line 1183
  flow = GetPointFlow(dec, reg->flowBegin.plane, loc0, (int )dmtxNeighborNone);
#line 1184
  distSqMax = line.xDelta * line.xDelta + line.yDelta * line.yDelta;
#line 1185
  steps = 0;
#line 1186
  onEdge = 1U;
#line 1188
  beforeStep = loc0;
#line 1189
  beforeCache = dmtxDecodeGetCache(dec, loc0.X, loc0.Y);
  }
#line 1190
  if ((unsigned long )beforeCache == (unsigned long )((void *)0)) {
#line 1191
    return (0);
  } else {
#line 1193
    *beforeCache = (unsigned char)0;
  }
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (onEdge == 1U) {
      {
#line 1197
      flowNext = FindStrongestNeighbor(dec, flow, streamDir);
      }
#line 1198
      if (flowNext.mag == -1) {
#line 1199
        goto while_break;
      }
      {
#line 1201
      err = BresLineGetStep(line, flowNext.loc, & travel, & outward);
      }
#line 1202
      if (flowNext.mag < 50) {
#line 1203
        onEdge = 0U;
      } else
#line 1202
      if (outward < 0) {
#line 1203
        onEdge = 0U;
      } else
#line 1202
      if (outward == 0) {
#line 1202
        if (travel < 0) {
#line 1203
          onEdge = 0U;
        } else {
          {
#line 1206
          BresLineStep(& line, travel, outward);
#line 1207
          flow = flowNext;
          }
        }
      } else {
        {
#line 1206
        BresLineStep(& line, travel, outward);
#line 1207
        flow = flowNext;
        }
      }
    }
#line 1211
    if (onEdge == 0U) {
      {
#line 1212
      BresLineStep(& line, 1, 0);
#line 1213
      flow = GetPointFlow(dec, reg->flowBegin.plane, line.loc, (int )dmtxNeighborNone);
      }
#line 1214
      if (flow.mag > 50) {
#line 1215
        onEdge = 1U;
      }
    }
    {
#line 1218
    afterStep = line.loc;
#line 1219
    afterCache = dmtxDecodeGetCache(dec, afterStep.X, afterStep.Y);
    }
#line 1220
    if ((unsigned long )afterCache == (unsigned long )((void *)0)) {
#line 1221
      goto while_break;
    }
    {
#line 1224
    xStep = afterStep.X - beforeStep.X;
#line 1225
    yStep = afterStep.Y - beforeStep.Y;
#line 1226
    tmp = abs(xStep);
    }
#line 1226
    if (tmp <= 1) {
      {
#line 1226
      tmp___0 = abs(yStep);
      }
#line 1226
      if (! (tmp___0 <= 1)) {
        {
#line 1226
        __assert_fail("abs(xStep) <= 1 && abs(yStep) <= 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                      1226U, "TrailBlazeGapped");
        }
      }
    } else {
      {
#line 1226
      __assert_fail("abs(xStep) <= 1 && abs(yStep) <= 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    1226U, "TrailBlazeGapped");
      }
    }
#line 1227
    stepDir = dirMap[(3 * yStep + xStep) + 4];
#line 1228
    if (! (stepDir != 8)) {
      {
#line 1228
      __assert_fail("stepDir != 8", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    1228U, "TrailBlazeGapped");
      }
    }
#line 1230
    if (streamDir < 0) {
#line 1231
      *beforeCache = (unsigned char )((int )*beforeCache | (64 | stepDir));
#line 1232
      *afterCache = (unsigned char )((stepDir + 4) % 8 << 3);
    } else {
#line 1235
      *beforeCache = (unsigned char )((int )*beforeCache | (64 | (stepDir << 3)));
#line 1236
      *afterCache = (unsigned char )((stepDir + 4) % 8);
    }
#line 1240
    xDiff = line.loc.X - loc0.X;
#line 1241
    yDiff = line.loc.Y - loc0.Y;
#line 1242
    distSq = xDiff * xDiff + yDiff * yDiff;
#line 1244
    beforeStep = line.loc;
#line 1245
    beforeCache = afterCache;
#line 1246
    steps ++;
#line 1195
    if (! (distSq < distSqMax)) {
#line 1195
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1250
  return (steps);
}
}
#line 1257 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static int TrailClear(DmtxDecode *dec , DmtxRegion *reg , int clearMask ) 
{ 
  int clears ;
  DmtxFollow follow ;
  int tmp ;

  {
#line 1263
  if (! ((clearMask | 255) == 255)) {
    {
#line 1263
    __assert_fail("(clearMask | 0xff) == 0xff", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1263U, "TrailClear");
    }
  }
  {
#line 1266
  clears = 0;
#line 1267
  follow = FollowSeek(dec, reg, 0);
  }
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1268
    tmp = abs(follow.step);
    }
#line 1268
    if (! (tmp <= reg->stepsTotal)) {
#line 1268
      goto while_break;
    }
#line 1269
    if (! (((int )*(follow.ptr) & clearMask) != 0)) {
      {
#line 1269
      __assert_fail("(int)(*follow.ptr & clearMask) != 0x00", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    1269U, "TrailClear");
      }
    }
    {
#line 1270
    *(follow.ptr) = (unsigned char )((int )*(follow.ptr) & (clearMask ^ 255));
#line 1271
    follow = FollowStep(dec, reg, follow, 1);
#line 1272
    clears ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1275
  return (clears);
}
}
#line 1282 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxBestLine FindBestSolidLine(DmtxDecode *dec , DmtxRegion *reg , int step0 ,
                                      int step1 , int streamDir , int houghAvoid ) 
{ 
  int hough[3][180] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int houghMin ;
  int houghMax ;
  char houghTest[180] ;
  int i ;
  int step ;
  int sign ;
  int tripSteps ;
  int angleBest ;
  int hOffset ;
  int hOffsetBest ;
  int xDiff ;
  int yDiff ;
  int dH ;
  DmtxRay2 rH ;
  DmtxFollow follow ;
  DmtxBestLine line ;
  DmtxPixelLoc rHp ;

  {
#line 1285
  hough[0][0] = 0;
#line 1285
  tmp = 1U;
  {
#line 1285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    if (tmp >= 180U) {
#line 1285
      goto while_break;
    }
#line 1285
    hough[0][tmp] = 0;
#line 1285
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1285
  tmp___0 = 1U;
  {
#line 1285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1285
    if (tmp___0 >= 3U) {
#line 1285
      goto while_break___0;
    }
#line 1285
    hough[tmp___0][0] = 0;
#line 1285
    hough[tmp___0][1] = 0;
#line 1285
    hough[tmp___0][2] = 0;
#line 1285
    hough[tmp___0][3] = 0;
#line 1285
    hough[tmp___0][4] = 0;
#line 1285
    hough[tmp___0][5] = 0;
#line 1285
    hough[tmp___0][6] = 0;
#line 1285
    hough[tmp___0][7] = 0;
#line 1285
    hough[tmp___0][8] = 0;
#line 1285
    hough[tmp___0][9] = 0;
#line 1285
    hough[tmp___0][10] = 0;
#line 1285
    hough[tmp___0][11] = 0;
#line 1285
    hough[tmp___0][12] = 0;
#line 1285
    hough[tmp___0][13] = 0;
#line 1285
    hough[tmp___0][14] = 0;
#line 1285
    hough[tmp___0][15] = 0;
#line 1285
    hough[tmp___0][16] = 0;
#line 1285
    hough[tmp___0][17] = 0;
#line 1285
    hough[tmp___0][18] = 0;
#line 1285
    hough[tmp___0][19] = 0;
#line 1285
    hough[tmp___0][20] = 0;
#line 1285
    hough[tmp___0][21] = 0;
#line 1285
    hough[tmp___0][22] = 0;
#line 1285
    hough[tmp___0][23] = 0;
#line 1285
    hough[tmp___0][24] = 0;
#line 1285
    hough[tmp___0][25] = 0;
#line 1285
    hough[tmp___0][26] = 0;
#line 1285
    hough[tmp___0][27] = 0;
#line 1285
    hough[tmp___0][28] = 0;
#line 1285
    hough[tmp___0][29] = 0;
#line 1285
    hough[tmp___0][30] = 0;
#line 1285
    hough[tmp___0][31] = 0;
#line 1285
    hough[tmp___0][32] = 0;
#line 1285
    hough[tmp___0][33] = 0;
#line 1285
    hough[tmp___0][34] = 0;
#line 1285
    hough[tmp___0][35] = 0;
#line 1285
    hough[tmp___0][36] = 0;
#line 1285
    hough[tmp___0][37] = 0;
#line 1285
    hough[tmp___0][38] = 0;
#line 1285
    hough[tmp___0][39] = 0;
#line 1285
    hough[tmp___0][40] = 0;
#line 1285
    hough[tmp___0][41] = 0;
#line 1285
    hough[tmp___0][42] = 0;
#line 1285
    hough[tmp___0][43] = 0;
#line 1285
    hough[tmp___0][44] = 0;
#line 1285
    hough[tmp___0][45] = 0;
#line 1285
    hough[tmp___0][46] = 0;
#line 1285
    hough[tmp___0][47] = 0;
#line 1285
    hough[tmp___0][48] = 0;
#line 1285
    hough[tmp___0][49] = 0;
#line 1285
    hough[tmp___0][50] = 0;
#line 1285
    hough[tmp___0][51] = 0;
#line 1285
    hough[tmp___0][52] = 0;
#line 1285
    hough[tmp___0][53] = 0;
#line 1285
    hough[tmp___0][54] = 0;
#line 1285
    hough[tmp___0][55] = 0;
#line 1285
    hough[tmp___0][56] = 0;
#line 1285
    hough[tmp___0][57] = 0;
#line 1285
    hough[tmp___0][58] = 0;
#line 1285
    hough[tmp___0][59] = 0;
#line 1285
    hough[tmp___0][60] = 0;
#line 1285
    hough[tmp___0][61] = 0;
#line 1285
    hough[tmp___0][62] = 0;
#line 1285
    hough[tmp___0][63] = 0;
#line 1285
    hough[tmp___0][64] = 0;
#line 1285
    hough[tmp___0][65] = 0;
#line 1285
    hough[tmp___0][66] = 0;
#line 1285
    hough[tmp___0][67] = 0;
#line 1285
    hough[tmp___0][68] = 0;
#line 1285
    hough[tmp___0][69] = 0;
#line 1285
    hough[tmp___0][70] = 0;
#line 1285
    hough[tmp___0][71] = 0;
#line 1285
    hough[tmp___0][72] = 0;
#line 1285
    hough[tmp___0][73] = 0;
#line 1285
    hough[tmp___0][74] = 0;
#line 1285
    hough[tmp___0][75] = 0;
#line 1285
    hough[tmp___0][76] = 0;
#line 1285
    hough[tmp___0][77] = 0;
#line 1285
    hough[tmp___0][78] = 0;
#line 1285
    hough[tmp___0][79] = 0;
#line 1285
    hough[tmp___0][80] = 0;
#line 1285
    hough[tmp___0][81] = 0;
#line 1285
    hough[tmp___0][82] = 0;
#line 1285
    hough[tmp___0][83] = 0;
#line 1285
    hough[tmp___0][84] = 0;
#line 1285
    hough[tmp___0][85] = 0;
#line 1285
    hough[tmp___0][86] = 0;
#line 1285
    hough[tmp___0][87] = 0;
#line 1285
    hough[tmp___0][88] = 0;
#line 1285
    hough[tmp___0][89] = 0;
#line 1285
    hough[tmp___0][90] = 0;
#line 1285
    hough[tmp___0][91] = 0;
#line 1285
    hough[tmp___0][92] = 0;
#line 1285
    hough[tmp___0][93] = 0;
#line 1285
    hough[tmp___0][94] = 0;
#line 1285
    hough[tmp___0][95] = 0;
#line 1285
    hough[tmp___0][96] = 0;
#line 1285
    hough[tmp___0][97] = 0;
#line 1285
    hough[tmp___0][98] = 0;
#line 1285
    hough[tmp___0][99] = 0;
#line 1285
    hough[tmp___0][100] = 0;
#line 1285
    hough[tmp___0][101] = 0;
#line 1285
    hough[tmp___0][102] = 0;
#line 1285
    hough[tmp___0][103] = 0;
#line 1285
    hough[tmp___0][104] = 0;
#line 1285
    hough[tmp___0][105] = 0;
#line 1285
    hough[tmp___0][106] = 0;
#line 1285
    hough[tmp___0][107] = 0;
#line 1285
    hough[tmp___0][108] = 0;
#line 1285
    hough[tmp___0][109] = 0;
#line 1285
    hough[tmp___0][110] = 0;
#line 1285
    hough[tmp___0][111] = 0;
#line 1285
    hough[tmp___0][112] = 0;
#line 1285
    hough[tmp___0][113] = 0;
#line 1285
    hough[tmp___0][114] = 0;
#line 1285
    hough[tmp___0][115] = 0;
#line 1285
    hough[tmp___0][116] = 0;
#line 1285
    hough[tmp___0][117] = 0;
#line 1285
    hough[tmp___0][118] = 0;
#line 1285
    hough[tmp___0][119] = 0;
#line 1285
    hough[tmp___0][120] = 0;
#line 1285
    hough[tmp___0][121] = 0;
#line 1285
    hough[tmp___0][122] = 0;
#line 1285
    hough[tmp___0][123] = 0;
#line 1285
    hough[tmp___0][124] = 0;
#line 1285
    hough[tmp___0][125] = 0;
#line 1285
    hough[tmp___0][126] = 0;
#line 1285
    hough[tmp___0][127] = 0;
#line 1285
    hough[tmp___0][128] = 0;
#line 1285
    hough[tmp___0][129] = 0;
#line 1285
    hough[tmp___0][130] = 0;
#line 1285
    hough[tmp___0][131] = 0;
#line 1285
    hough[tmp___0][132] = 0;
#line 1285
    hough[tmp___0][133] = 0;
#line 1285
    hough[tmp___0][134] = 0;
#line 1285
    hough[tmp___0][135] = 0;
#line 1285
    hough[tmp___0][136] = 0;
#line 1285
    hough[tmp___0][137] = 0;
#line 1285
    hough[tmp___0][138] = 0;
#line 1285
    hough[tmp___0][139] = 0;
#line 1285
    hough[tmp___0][140] = 0;
#line 1285
    hough[tmp___0][141] = 0;
#line 1285
    hough[tmp___0][142] = 0;
#line 1285
    hough[tmp___0][143] = 0;
#line 1285
    hough[tmp___0][144] = 0;
#line 1285
    hough[tmp___0][145] = 0;
#line 1285
    hough[tmp___0][146] = 0;
#line 1285
    hough[tmp___0][147] = 0;
#line 1285
    hough[tmp___0][148] = 0;
#line 1285
    hough[tmp___0][149] = 0;
#line 1285
    hough[tmp___0][150] = 0;
#line 1285
    hough[tmp___0][151] = 0;
#line 1285
    hough[tmp___0][152] = 0;
#line 1285
    hough[tmp___0][153] = 0;
#line 1285
    hough[tmp___0][154] = 0;
#line 1285
    hough[tmp___0][155] = 0;
#line 1285
    hough[tmp___0][156] = 0;
#line 1285
    hough[tmp___0][157] = 0;
#line 1285
    hough[tmp___0][158] = 0;
#line 1285
    hough[tmp___0][159] = 0;
#line 1285
    hough[tmp___0][160] = 0;
#line 1285
    hough[tmp___0][161] = 0;
#line 1285
    hough[tmp___0][162] = 0;
#line 1285
    hough[tmp___0][163] = 0;
#line 1285
    hough[tmp___0][164] = 0;
#line 1285
    hough[tmp___0][165] = 0;
#line 1285
    hough[tmp___0][166] = 0;
#line 1285
    hough[tmp___0][167] = 0;
#line 1285
    hough[tmp___0][168] = 0;
#line 1285
    hough[tmp___0][169] = 0;
#line 1285
    hough[tmp___0][170] = 0;
#line 1285
    hough[tmp___0][171] = 0;
#line 1285
    hough[tmp___0][172] = 0;
#line 1285
    hough[tmp___0][173] = 0;
#line 1285
    hough[tmp___0][174] = 0;
#line 1285
    hough[tmp___0][175] = 0;
#line 1285
    hough[tmp___0][176] = 0;
#line 1285
    hough[tmp___0][177] = 0;
#line 1285
    hough[tmp___0][178] = 0;
#line 1285
    hough[tmp___0][179] = 0;
#line 1285
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1301
  memset((void *)(& line), 0, sizeof(DmtxBestLine ));
#line 1302
  memset((void *)(& rH), 0, sizeof(DmtxRay2 ));
#line 1303
  angleBest = 0;
#line 1304
  hOffsetBest = 0;
#line 1304
  hOffset = hOffsetBest;
  }
#line 1307
  if (step0 != 0) {
#line 1308
    if (step0 > 0) {
#line 1309
      sign = 1;
#line 1310
      tripSteps = ((step1 - step0) + reg->stepsTotal) % reg->stepsTotal;
    } else {
#line 1313
      sign = -1;
#line 1314
      tripSteps = ((step0 - step1) + reg->stepsTotal) % reg->stepsTotal;
    }
#line 1316
    if (tripSteps == 0) {
#line 1317
      tripSteps = reg->stepsTotal;
    }
  } else
#line 1319
  if (step1 != 0) {
#line 1320
    if (step1 > 0) {
#line 1320
      sign = 1;
    } else {
#line 1320
      sign = -1;
    }
    {
#line 1321
    tripSteps = abs(step1);
    }
  } else
#line 1323
  if (step1 == 0) {
#line 1324
    sign = 1;
#line 1325
    tripSteps = reg->stepsTotal;
  }
#line 1327
  if (! (sign == streamDir)) {
    {
#line 1327
    __assert_fail("sign == streamDir", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1327U, "FindBestSolidLine");
    }
  }
  {
#line 1329
  follow = FollowSeek(dec, reg, step0);
#line 1330
  rHp = follow.loc;
#line 1332
  line.stepNeg = step0;
#line 1332
  line.stepPos = line.stepNeg;
#line 1332
  line.stepBeg = line.stepPos;
#line 1333
  line.locBeg = follow.loc;
#line 1334
  line.locPos = follow.loc;
#line 1335
  line.locNeg = follow.loc;
#line 1338
  i = 0;
  }
  {
#line 1338
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1338
    if (! (i < 180)) {
#line 1338
      goto while_break___1;
    }
#line 1339
    if (houghAvoid == -1) {
#line 1340
      houghTest[i] = (char)1;
    } else {
#line 1343
      houghMin = (houghAvoid + 30) % 180;
#line 1344
      houghMax = ((houghAvoid - 30) + 180) % 180;
#line 1345
      if (houghMin > houghMax) {
#line 1346
        if (i > houghMin) {
#line 1346
          houghTest[i] = (char)1;
        } else
#line 1346
        if (i < houghMax) {
#line 1346
          houghTest[i] = (char)1;
        } else {
#line 1346
          houghTest[i] = (char)0;
        }
      } else
#line 1348
      if (i > houghMin) {
#line 1348
        if (i < houghMax) {
#line 1348
          houghTest[i] = (char)1;
        } else {
#line 1348
          houghTest[i] = (char)0;
        }
      } else {
#line 1348
        houghTest[i] = (char)0;
      }
    }
#line 1338
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1353
  step = 0;
  {
#line 1353
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1353
    if (! (step < tripSteps)) {
#line 1353
      goto while_break___2;
    }
#line 1355
    xDiff = follow.loc.X - rHp.X;
#line 1356
    yDiff = follow.loc.Y - rHp.Y;
#line 1359
    i = 0;
    {
#line 1359
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1359
      if (! (i < 180)) {
#line 1359
        goto while_break___3;
      }
#line 1361
      if ((int )houghTest[i] == 0) {
#line 1362
        goto __Cont;
      }
#line 1364
      dH = rHvX[i] * yDiff - rHvY[i] * xDiff;
#line 1365
      if (dH >= -384) {
#line 1365
        if (dH <= 384) {
#line 1367
          if (dH > 128) {
#line 1368
            hOffset = 2;
          } else
#line 1369
          if (dH >= -128) {
#line 1370
            hOffset = 1;
          } else {
#line 1372
            hOffset = 0;
          }
#line 1374
          (hough[hOffset][i]) ++;
#line 1377
          if (hough[hOffset][i] > hough[hOffsetBest][angleBest]) {
#line 1378
            angleBest = i;
#line 1379
            hOffsetBest = hOffset;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1359
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1386
    follow = FollowStep(dec, reg, follow, sign);
#line 1353
    step ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1389
  line.angle = angleBest;
#line 1390
  line.hOffset = hOffsetBest;
#line 1391
  line.mag = hough[hOffsetBest][angleBest];
#line 1393
  return (line);
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxBestLine FindBestSolidLine2(DmtxDecode *dec , DmtxPixelLoc loc0 , int tripSteps ,
                                       int sign , int houghAvoid ) 
{ 
  int hough[3][180] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int houghMin ;
  int houghMax ;
  char houghTest[180] ;
  int i ;
  int step ;
  int angleBest ;
  int hOffset ;
  int hOffsetBest ;
  int xDiff ;
  int yDiff ;
  int dH ;
  DmtxRay2 rH ;
  DmtxBestLine line ;
  DmtxPixelLoc rHp ;
  DmtxFollow follow ;

  {
#line 1403
  hough[0][0] = 0;
#line 1403
  tmp = 1U;
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    if (tmp >= 180U) {
#line 1403
      goto while_break;
    }
#line 1403
    hough[0][tmp] = 0;
#line 1403
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1403
  tmp___0 = 1U;
  {
#line 1403
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1403
    if (tmp___0 >= 3U) {
#line 1403
      goto while_break___0;
    }
#line 1403
    hough[tmp___0][0] = 0;
#line 1403
    hough[tmp___0][1] = 0;
#line 1403
    hough[tmp___0][2] = 0;
#line 1403
    hough[tmp___0][3] = 0;
#line 1403
    hough[tmp___0][4] = 0;
#line 1403
    hough[tmp___0][5] = 0;
#line 1403
    hough[tmp___0][6] = 0;
#line 1403
    hough[tmp___0][7] = 0;
#line 1403
    hough[tmp___0][8] = 0;
#line 1403
    hough[tmp___0][9] = 0;
#line 1403
    hough[tmp___0][10] = 0;
#line 1403
    hough[tmp___0][11] = 0;
#line 1403
    hough[tmp___0][12] = 0;
#line 1403
    hough[tmp___0][13] = 0;
#line 1403
    hough[tmp___0][14] = 0;
#line 1403
    hough[tmp___0][15] = 0;
#line 1403
    hough[tmp___0][16] = 0;
#line 1403
    hough[tmp___0][17] = 0;
#line 1403
    hough[tmp___0][18] = 0;
#line 1403
    hough[tmp___0][19] = 0;
#line 1403
    hough[tmp___0][20] = 0;
#line 1403
    hough[tmp___0][21] = 0;
#line 1403
    hough[tmp___0][22] = 0;
#line 1403
    hough[tmp___0][23] = 0;
#line 1403
    hough[tmp___0][24] = 0;
#line 1403
    hough[tmp___0][25] = 0;
#line 1403
    hough[tmp___0][26] = 0;
#line 1403
    hough[tmp___0][27] = 0;
#line 1403
    hough[tmp___0][28] = 0;
#line 1403
    hough[tmp___0][29] = 0;
#line 1403
    hough[tmp___0][30] = 0;
#line 1403
    hough[tmp___0][31] = 0;
#line 1403
    hough[tmp___0][32] = 0;
#line 1403
    hough[tmp___0][33] = 0;
#line 1403
    hough[tmp___0][34] = 0;
#line 1403
    hough[tmp___0][35] = 0;
#line 1403
    hough[tmp___0][36] = 0;
#line 1403
    hough[tmp___0][37] = 0;
#line 1403
    hough[tmp___0][38] = 0;
#line 1403
    hough[tmp___0][39] = 0;
#line 1403
    hough[tmp___0][40] = 0;
#line 1403
    hough[tmp___0][41] = 0;
#line 1403
    hough[tmp___0][42] = 0;
#line 1403
    hough[tmp___0][43] = 0;
#line 1403
    hough[tmp___0][44] = 0;
#line 1403
    hough[tmp___0][45] = 0;
#line 1403
    hough[tmp___0][46] = 0;
#line 1403
    hough[tmp___0][47] = 0;
#line 1403
    hough[tmp___0][48] = 0;
#line 1403
    hough[tmp___0][49] = 0;
#line 1403
    hough[tmp___0][50] = 0;
#line 1403
    hough[tmp___0][51] = 0;
#line 1403
    hough[tmp___0][52] = 0;
#line 1403
    hough[tmp___0][53] = 0;
#line 1403
    hough[tmp___0][54] = 0;
#line 1403
    hough[tmp___0][55] = 0;
#line 1403
    hough[tmp___0][56] = 0;
#line 1403
    hough[tmp___0][57] = 0;
#line 1403
    hough[tmp___0][58] = 0;
#line 1403
    hough[tmp___0][59] = 0;
#line 1403
    hough[tmp___0][60] = 0;
#line 1403
    hough[tmp___0][61] = 0;
#line 1403
    hough[tmp___0][62] = 0;
#line 1403
    hough[tmp___0][63] = 0;
#line 1403
    hough[tmp___0][64] = 0;
#line 1403
    hough[tmp___0][65] = 0;
#line 1403
    hough[tmp___0][66] = 0;
#line 1403
    hough[tmp___0][67] = 0;
#line 1403
    hough[tmp___0][68] = 0;
#line 1403
    hough[tmp___0][69] = 0;
#line 1403
    hough[tmp___0][70] = 0;
#line 1403
    hough[tmp___0][71] = 0;
#line 1403
    hough[tmp___0][72] = 0;
#line 1403
    hough[tmp___0][73] = 0;
#line 1403
    hough[tmp___0][74] = 0;
#line 1403
    hough[tmp___0][75] = 0;
#line 1403
    hough[tmp___0][76] = 0;
#line 1403
    hough[tmp___0][77] = 0;
#line 1403
    hough[tmp___0][78] = 0;
#line 1403
    hough[tmp___0][79] = 0;
#line 1403
    hough[tmp___0][80] = 0;
#line 1403
    hough[tmp___0][81] = 0;
#line 1403
    hough[tmp___0][82] = 0;
#line 1403
    hough[tmp___0][83] = 0;
#line 1403
    hough[tmp___0][84] = 0;
#line 1403
    hough[tmp___0][85] = 0;
#line 1403
    hough[tmp___0][86] = 0;
#line 1403
    hough[tmp___0][87] = 0;
#line 1403
    hough[tmp___0][88] = 0;
#line 1403
    hough[tmp___0][89] = 0;
#line 1403
    hough[tmp___0][90] = 0;
#line 1403
    hough[tmp___0][91] = 0;
#line 1403
    hough[tmp___0][92] = 0;
#line 1403
    hough[tmp___0][93] = 0;
#line 1403
    hough[tmp___0][94] = 0;
#line 1403
    hough[tmp___0][95] = 0;
#line 1403
    hough[tmp___0][96] = 0;
#line 1403
    hough[tmp___0][97] = 0;
#line 1403
    hough[tmp___0][98] = 0;
#line 1403
    hough[tmp___0][99] = 0;
#line 1403
    hough[tmp___0][100] = 0;
#line 1403
    hough[tmp___0][101] = 0;
#line 1403
    hough[tmp___0][102] = 0;
#line 1403
    hough[tmp___0][103] = 0;
#line 1403
    hough[tmp___0][104] = 0;
#line 1403
    hough[tmp___0][105] = 0;
#line 1403
    hough[tmp___0][106] = 0;
#line 1403
    hough[tmp___0][107] = 0;
#line 1403
    hough[tmp___0][108] = 0;
#line 1403
    hough[tmp___0][109] = 0;
#line 1403
    hough[tmp___0][110] = 0;
#line 1403
    hough[tmp___0][111] = 0;
#line 1403
    hough[tmp___0][112] = 0;
#line 1403
    hough[tmp___0][113] = 0;
#line 1403
    hough[tmp___0][114] = 0;
#line 1403
    hough[tmp___0][115] = 0;
#line 1403
    hough[tmp___0][116] = 0;
#line 1403
    hough[tmp___0][117] = 0;
#line 1403
    hough[tmp___0][118] = 0;
#line 1403
    hough[tmp___0][119] = 0;
#line 1403
    hough[tmp___0][120] = 0;
#line 1403
    hough[tmp___0][121] = 0;
#line 1403
    hough[tmp___0][122] = 0;
#line 1403
    hough[tmp___0][123] = 0;
#line 1403
    hough[tmp___0][124] = 0;
#line 1403
    hough[tmp___0][125] = 0;
#line 1403
    hough[tmp___0][126] = 0;
#line 1403
    hough[tmp___0][127] = 0;
#line 1403
    hough[tmp___0][128] = 0;
#line 1403
    hough[tmp___0][129] = 0;
#line 1403
    hough[tmp___0][130] = 0;
#line 1403
    hough[tmp___0][131] = 0;
#line 1403
    hough[tmp___0][132] = 0;
#line 1403
    hough[tmp___0][133] = 0;
#line 1403
    hough[tmp___0][134] = 0;
#line 1403
    hough[tmp___0][135] = 0;
#line 1403
    hough[tmp___0][136] = 0;
#line 1403
    hough[tmp___0][137] = 0;
#line 1403
    hough[tmp___0][138] = 0;
#line 1403
    hough[tmp___0][139] = 0;
#line 1403
    hough[tmp___0][140] = 0;
#line 1403
    hough[tmp___0][141] = 0;
#line 1403
    hough[tmp___0][142] = 0;
#line 1403
    hough[tmp___0][143] = 0;
#line 1403
    hough[tmp___0][144] = 0;
#line 1403
    hough[tmp___0][145] = 0;
#line 1403
    hough[tmp___0][146] = 0;
#line 1403
    hough[tmp___0][147] = 0;
#line 1403
    hough[tmp___0][148] = 0;
#line 1403
    hough[tmp___0][149] = 0;
#line 1403
    hough[tmp___0][150] = 0;
#line 1403
    hough[tmp___0][151] = 0;
#line 1403
    hough[tmp___0][152] = 0;
#line 1403
    hough[tmp___0][153] = 0;
#line 1403
    hough[tmp___0][154] = 0;
#line 1403
    hough[tmp___0][155] = 0;
#line 1403
    hough[tmp___0][156] = 0;
#line 1403
    hough[tmp___0][157] = 0;
#line 1403
    hough[tmp___0][158] = 0;
#line 1403
    hough[tmp___0][159] = 0;
#line 1403
    hough[tmp___0][160] = 0;
#line 1403
    hough[tmp___0][161] = 0;
#line 1403
    hough[tmp___0][162] = 0;
#line 1403
    hough[tmp___0][163] = 0;
#line 1403
    hough[tmp___0][164] = 0;
#line 1403
    hough[tmp___0][165] = 0;
#line 1403
    hough[tmp___0][166] = 0;
#line 1403
    hough[tmp___0][167] = 0;
#line 1403
    hough[tmp___0][168] = 0;
#line 1403
    hough[tmp___0][169] = 0;
#line 1403
    hough[tmp___0][170] = 0;
#line 1403
    hough[tmp___0][171] = 0;
#line 1403
    hough[tmp___0][172] = 0;
#line 1403
    hough[tmp___0][173] = 0;
#line 1403
    hough[tmp___0][174] = 0;
#line 1403
    hough[tmp___0][175] = 0;
#line 1403
    hough[tmp___0][176] = 0;
#line 1403
    hough[tmp___0][177] = 0;
#line 1403
    hough[tmp___0][178] = 0;
#line 1403
    hough[tmp___0][179] = 0;
#line 1403
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1417
  memset((void *)(& line), 0, sizeof(DmtxBestLine ));
#line 1418
  memset((void *)(& rH), 0, sizeof(DmtxRay2 ));
#line 1419
  angleBest = 0;
#line 1420
  hOffsetBest = 0;
#line 1420
  hOffset = hOffsetBest;
#line 1422
  follow = FollowSeekLoc(dec, loc0);
#line 1423
  line.locNeg = follow.loc;
#line 1423
  line.locPos = line.locNeg;
#line 1423
  line.locBeg = line.locPos;
#line 1423
  rHp = line.locBeg;
#line 1424
  line.stepNeg = 0;
#line 1424
  line.stepPos = line.stepNeg;
#line 1424
  line.stepBeg = line.stepPos;
#line 1427
  i = 0;
  }
  {
#line 1427
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1427
    if (! (i < 180)) {
#line 1427
      goto while_break___1;
    }
#line 1428
    if (houghAvoid == -1) {
#line 1429
      houghTest[i] = (char)1;
    } else {
#line 1432
      houghMin = (houghAvoid + 30) % 180;
#line 1433
      houghMax = ((houghAvoid - 30) + 180) % 180;
#line 1434
      if (houghMin > houghMax) {
#line 1435
        if (i > houghMin) {
#line 1435
          houghTest[i] = (char)1;
        } else
#line 1435
        if (i < houghMax) {
#line 1435
          houghTest[i] = (char)1;
        } else {
#line 1435
          houghTest[i] = (char)0;
        }
      } else
#line 1437
      if (i > houghMin) {
#line 1437
        if (i < houghMax) {
#line 1437
          houghTest[i] = (char)1;
        } else {
#line 1437
          houghTest[i] = (char)0;
        }
      } else {
#line 1437
        houghTest[i] = (char)0;
      }
    }
#line 1427
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1442
  step = 0;
  {
#line 1442
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1442
    if (! (step < tripSteps)) {
#line 1442
      goto while_break___2;
    }
#line 1444
    xDiff = follow.loc.X - rHp.X;
#line 1445
    yDiff = follow.loc.Y - rHp.Y;
#line 1448
    i = 0;
    {
#line 1448
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1448
      if (! (i < 180)) {
#line 1448
        goto while_break___3;
      }
#line 1450
      if ((int )houghTest[i] == 0) {
#line 1451
        goto __Cont;
      }
#line 1453
      dH = rHvX[i] * yDiff - rHvY[i] * xDiff;
#line 1454
      if (dH >= -384) {
#line 1454
        if (dH <= 384) {
#line 1455
          if (dH > 128) {
#line 1456
            hOffset = 2;
          } else
#line 1457
          if (dH >= -128) {
#line 1458
            hOffset = 1;
          } else {
#line 1460
            hOffset = 0;
          }
#line 1462
          (hough[hOffset][i]) ++;
#line 1465
          if (hough[hOffset][i] > hough[hOffsetBest][angleBest]) {
#line 1466
            angleBest = i;
#line 1467
            hOffsetBest = hOffset;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1448
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1474
    follow = FollowStep2(dec, follow, sign);
#line 1442
    step ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1477
  line.angle = angleBest;
#line 1478
  line.hOffset = hOffsetBest;
#line 1479
  line.mag = hough[hOffsetBest][angleBest];
#line 1481
  return (line);
}
}
#line 1488 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int FindTravelLimits(DmtxDecode *dec , DmtxRegion *reg , DmtxBestLine *line ) 
{ 
  int i ;
  int distSq ;
  int distSqMax ;
  int xDiff ;
  int yDiff ;
  int posRunning ;
  int negRunning ;
  int posTravel ;
  int negTravel ;
  int posWander ;
  int posWanderMin ;
  int posWanderMax ;
  int posWanderMinLock ;
  int posWanderMaxLock ;
  int negWander ;
  int negWanderMin ;
  int negWanderMax ;
  int negWanderMinLock ;
  int negWanderMaxLock ;
  int cosAngle ;
  int sinAngle ;
  DmtxFollow followPos ;
  DmtxFollow followNeg ;
  DmtxPixelLoc loc0 ;
  DmtxPixelLoc posMax ;
  DmtxPixelLoc negMax ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1503
  followNeg = FollowSeek(dec, reg, line->stepBeg);
#line 1503
  followPos = followNeg;
#line 1504
  loc0 = followPos.loc;
#line 1506
  cosAngle = rHvX[line->angle];
#line 1507
  sinAngle = rHvY[line->angle];
#line 1509
  distSqMax = 0;
#line 1510
  negMax = followPos.loc;
#line 1510
  posMax = negMax;
#line 1512
  negTravel = 0;
#line 1512
  posTravel = negTravel;
#line 1513
  posWanderMaxLock = 0;
#line 1513
  posWanderMinLock = posWanderMaxLock;
#line 1513
  posWanderMax = posWanderMinLock;
#line 1513
  posWanderMin = posWanderMax;
#line 1513
  posWander = posWanderMin;
#line 1514
  negWanderMaxLock = 0;
#line 1514
  negWanderMinLock = negWanderMaxLock;
#line 1514
  negWanderMax = negWanderMinLock;
#line 1514
  negWanderMin = negWanderMax;
#line 1514
  negWander = negWanderMin;
#line 1516
  i = 0;
  }
  {
#line 1516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1516
    if (! (i < reg->stepsTotal / 2)) {
#line 1516
      goto while_break;
    }
#line 1518
    if (i < 10) {
#line 1518
      tmp___1 = 1;
    } else {
      {
#line 1518
      tmp = abs(posWander);
#line 1518
      tmp___0 = abs(posTravel);
      }
#line 1518
      if (tmp < tmp___0) {
#line 1518
        tmp___1 = 1;
      } else {
#line 1518
        tmp___1 = 0;
      }
    }
#line 1518
    posRunning = tmp___1;
#line 1519
    if (i < 10) {
#line 1519
      tmp___4 = 1;
    } else {
      {
#line 1519
      tmp___2 = abs(negWander);
#line 1519
      tmp___3 = abs(negTravel);
      }
#line 1519
      if (tmp___2 < tmp___3) {
#line 1519
        tmp___4 = 1;
      } else {
#line 1519
        tmp___4 = 0;
      }
    }
#line 1519
    negRunning = tmp___4;
#line 1521
    if (posRunning != 0) {
#line 1522
      xDiff = followPos.loc.X - loc0.X;
#line 1523
      yDiff = followPos.loc.Y - loc0.Y;
#line 1524
      posTravel = cosAngle * xDiff + sinAngle * yDiff;
#line 1525
      posWander = cosAngle * yDiff - sinAngle * xDiff;
#line 1527
      if (posWander >= -768) {
#line 1527
        if (posWander <= 768) {
          {
#line 1528
          tmp___5 = DistanceSquared(followPos.loc, negMax);
#line 1528
          distSq = (int )tmp___5;
          }
#line 1529
          if (distSq > distSqMax) {
#line 1530
            posMax = followPos.loc;
#line 1531
            distSqMax = distSq;
#line 1532
            line->stepPos = followPos.step;
#line 1533
            line->locPos = followPos.loc;
#line 1534
            posWanderMinLock = posWanderMin;
#line 1535
            posWanderMaxLock = posWanderMax;
          }
        } else {
#line 1527
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1539
        if (posWanderMin < posWander) {
#line 1539
          posWanderMin = posWanderMin;
        } else {
#line 1539
          posWanderMin = posWander;
        }
#line 1540
        if (posWanderMax > posWander) {
#line 1540
          posWanderMax = posWanderMax;
        } else {
#line 1540
          posWanderMax = posWander;
        }
      }
    } else
#line 1543
    if (! negRunning) {
#line 1544
      goto while_break;
    }
#line 1547
    if (negRunning != 0) {
#line 1548
      xDiff = followNeg.loc.X - loc0.X;
#line 1549
      yDiff = followNeg.loc.Y - loc0.Y;
#line 1550
      negTravel = cosAngle * xDiff + sinAngle * yDiff;
#line 1551
      negWander = cosAngle * yDiff - sinAngle * xDiff;
#line 1553
      if (negWander >= -768) {
#line 1553
        if (negWander < 768) {
          {
#line 1554
          tmp___6 = DistanceSquared(followNeg.loc, posMax);
#line 1554
          distSq = (int )tmp___6;
          }
#line 1555
          if (distSq > distSqMax) {
#line 1556
            negMax = followNeg.loc;
#line 1557
            distSqMax = distSq;
#line 1558
            line->stepNeg = followNeg.step;
#line 1559
            line->locNeg = followNeg.loc;
#line 1560
            negWanderMinLock = negWanderMin;
#line 1561
            negWanderMaxLock = negWanderMax;
          }
        } else {
#line 1553
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1565
        if (negWanderMin < negWander) {
#line 1565
          negWanderMin = negWanderMin;
        } else {
#line 1565
          negWanderMin = negWander;
        }
#line 1566
        if (negWanderMax > negWander) {
#line 1566
          negWanderMax = negWanderMax;
        } else {
#line 1566
          negWanderMax = negWander;
        }
      }
    } else
#line 1569
    if (! posRunning) {
#line 1570
      goto while_break;
    }
    {
#line 1576
    followPos = FollowStep(dec, reg, followPos, 1);
#line 1577
    followNeg = FollowStep(dec, reg, followNeg, -1);
#line 1516
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1579
  if (posWanderMaxLock - posWanderMinLock > negWanderMaxLock - negWanderMinLock) {
#line 1579
    tmp___7 = posWanderMaxLock - posWanderMinLock;
  } else {
#line 1579
    tmp___7 = negWanderMaxLock - negWanderMinLock;
  }
#line 1579
  line->devn = (double )(tmp___7 / 256);
#line 1580
  line->distSq = distSqMax;
#line 1585
  return (1U);
}
}
#line 1592 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int MatrixRegionAlignCalibEdge(DmtxDecode *dec , DmtxRegion *reg ,
                                               int edgeLoc ) 
{ 
  int streamDir ;
  int steps ;
  int avoidAngle ;
  int symbolShape ;
  DmtxVector2 pTmp ;
  DmtxPixelLoc loc0 ;
  DmtxPixelLoc loc1 ;
  DmtxPixelLoc locOrigin ;
  DmtxBresLine line ;
  DmtxFollow follow ;
  DmtxBestLine bestLine ;

  {
  {
#line 1606
  pTmp.X = 0.0;
#line 1607
  pTmp.Y = 0.0;
#line 1608
  dmtxMatrix3VMultiplyBy(& pTmp, (double (*)[3])(reg->fit2raw));
#line 1609
  locOrigin.X = (int )(pTmp.X + 0.5);
#line 1610
  locOrigin.Y = (int )(pTmp.Y + 0.5);
  }
#line 1612
  if (dec->sizeIdxExpected == -2) {
#line 1615
    symbolShape = -2;
  } else
#line 1612
  if (dec->sizeIdxExpected >= 0) {
#line 1612
    if (dec->sizeIdxExpected <= 23) {
#line 1615
      symbolShape = -2;
    } else {
#line 1612
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1616
  if (dec->sizeIdxExpected == -3) {
#line 1619
    symbolShape = -3;
  } else
#line 1616
  if (dec->sizeIdxExpected >= 24) {
#line 1616
    if (dec->sizeIdxExpected <= 29) {
#line 1619
      symbolShape = -3;
    } else {
#line 1621
      symbolShape = -1;
    }
  } else {
#line 1621
    symbolShape = -1;
  }
#line 1624
  if (edgeLoc == 1) {
    {
#line 1625
    streamDir = reg->polarity * -1;
#line 1626
    avoidAngle = reg->leftLine.angle;
#line 1627
    follow = FollowSeekLoc(dec, reg->locT);
#line 1628
    pTmp.X = 0.8;
    }
#line 1629
    if (symbolShape == -3) {
#line 1629
      pTmp.Y = 0.2;
    } else {
#line 1629
      pTmp.Y = 0.6;
    }
  } else {
#line 1632
    if (! (edgeLoc == 8)) {
      {
#line 1632
      __assert_fail("edgeLoc == DmtxEdgeRight", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    1632U, "MatrixRegionAlignCalibEdge");
      }
    }
    {
#line 1633
    streamDir = reg->polarity;
#line 1634
    avoidAngle = reg->bottomLine.angle;
#line 1635
    follow = FollowSeekLoc(dec, reg->locR);
    }
#line 1636
    if (symbolShape == -2) {
#line 1636
      pTmp.X = 0.7;
    } else {
#line 1636
      pTmp.X = 0.9;
    }
#line 1637
    pTmp.Y = 0.8;
  }
  {
#line 1640
  dmtxMatrix3VMultiplyBy(& pTmp, (double (*)[3])(reg->fit2raw));
#line 1641
  loc1.X = (int )(pTmp.X + 0.5);
#line 1642
  loc1.Y = (int )(pTmp.Y + 0.5);
#line 1644
  loc0 = follow.loc;
#line 1645
  line = BresLineInit(loc0, loc1, locOrigin);
#line 1646
  steps = TrailBlazeGapped(dec, reg, line, streamDir);
#line 1648
  bestLine = FindBestSolidLine2(dec, loc0, steps, streamDir, avoidAngle);
  }
#line 1653
  if (edgeLoc == 1) {
#line 1654
    reg->topKnown = 1;
#line 1655
    reg->topAngle = bestLine.angle;
#line 1656
    reg->topLoc = bestLine.locBeg;
  } else {
#line 1659
    reg->rightKnown = 1;
#line 1660
    reg->rightAngle = bestLine.angle;
#line 1661
    reg->rightLoc = bestLine.locBeg;
  }
#line 1664
  return (1U);
}
}
#line 1671 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static DmtxBresLine BresLineInit(DmtxPixelLoc loc0 , DmtxPixelLoc loc1 , DmtxPixelLoc locInside ) 
{ 
  int cp ;
  DmtxBresLine line ;
  DmtxPixelLoc *locBeg ;
  DmtxPixelLoc *locEnd ;

  {
#line 1681
  line.loc0 = loc0;
#line 1682
  line.loc1 = loc1;
#line 1683
  if (loc0.X < loc1.X) {
#line 1683
    line.xStep = 1;
  } else {
#line 1683
    line.xStep = -1;
  }
#line 1684
  if (loc0.Y < loc1.Y) {
#line 1684
    line.yStep = 1;
  } else {
#line 1684
    line.yStep = -1;
  }
  {
#line 1685
  line.xDelta = abs(loc1.X - loc0.X);
#line 1686
  line.yDelta = abs(loc1.Y - loc0.Y);
#line 1687
  line.steep = line.yDelta > line.xDelta;
  }
#line 1690
  if (line.steep != 0) {
#line 1692
    if (loc0.Y < loc1.Y) {
#line 1693
      locBeg = & loc0;
#line 1694
      locEnd = & loc1;
    } else {
#line 1697
      locBeg = & loc1;
#line 1698
      locEnd = & loc0;
    }
#line 1700
    cp = (locEnd->X - locBeg->X) * (locInside.Y - locEnd->Y) - (locEnd->Y - locBeg->Y) * (locInside.X - locEnd->X);
#line 1703
    if (cp > 0) {
#line 1703
      line.xOut = 1;
    } else {
#line 1703
      line.xOut = -1;
    }
#line 1704
    line.yOut = 0;
  } else {
#line 1708
    if (loc0.X > loc1.X) {
#line 1709
      locBeg = & loc0;
#line 1710
      locEnd = & loc1;
    } else {
#line 1713
      locBeg = & loc1;
#line 1714
      locEnd = & loc0;
    }
#line 1716
    cp = (locEnd->X - locBeg->X) * (locInside.Y - locEnd->Y) - (locEnd->Y - locBeg->Y) * (locInside.X - locEnd->X);
#line 1719
    line.xOut = 0;
#line 1720
    if (cp > 0) {
#line 1720
      line.yOut = 1;
    } else {
#line 1720
      line.yOut = -1;
    }
  }
#line 1724
  line.loc = loc0;
#line 1725
  line.travel = 0;
#line 1726
  line.outward = 0;
#line 1727
  if (line.steep) {
#line 1727
    line.error = line.yDelta / 2;
  } else {
#line 1727
    line.error = line.xDelta / 2;
  }
#line 1732
  return (line);
}
}
#line 1739 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int BresLineGetStep(DmtxBresLine line , DmtxPixelLoc target , int *travel ,
                                    int *outward ) 
{ 


  {
#line 1743
  if (line.steep != 0) {
#line 1744
    if (line.yStep > 0) {
#line 1744
      *travel = target.Y - line.loc.Y;
    } else {
#line 1744
      *travel = line.loc.Y - target.Y;
    }
    {
#line 1745
    BresLineStep(& line, *travel, 0);
    }
#line 1746
    if (line.xOut > 0) {
#line 1746
      *outward = target.X - line.loc.X;
    } else {
#line 1746
      *outward = line.loc.X - target.X;
    }
#line 1747
    if (! (line.yOut == 0)) {
      {
#line 1747
      __assert_fail("line.yOut == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    1747U, "BresLineGetStep");
      }
    }
  } else {
#line 1750
    if (line.xStep > 0) {
#line 1750
      *travel = target.X - line.loc.X;
    } else {
#line 1750
      *travel = line.loc.X - target.X;
    }
    {
#line 1751
    BresLineStep(& line, *travel, 0);
    }
#line 1752
    if (line.yOut > 0) {
#line 1752
      *outward = target.Y - line.loc.Y;
    } else {
#line 1752
      *outward = line.loc.Y - target.Y;
    }
#line 1753
    if (! (line.xOut == 0)) {
      {
#line 1753
      __assert_fail("line.xOut == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                    1753U, "BresLineGetStep");
      }
    }
  }
#line 1756
  return (1U);
}
}
#line 1763 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c"
static unsigned int BresLineStep(DmtxBresLine *line , int travel , int outward ) 
{ 
  int i ;
  DmtxBresLine lineNew ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1769
  lineNew = *line;
#line 1771
  tmp = abs(travel);
  }
#line 1771
  if (! (tmp < 2)) {
    {
#line 1771
    __assert_fail("abs(travel) < 2", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1771U, "BresLineStep");
    }
  }
  {
#line 1772
  tmp___0 = abs(outward);
  }
#line 1772
  if (! (tmp___0 >= 0)) {
    {
#line 1772
    __assert_fail("abs(outward) >= 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxregion.c",
                  1772U, "BresLineStep");
    }
  }
#line 1775
  if (travel > 0) {
#line 1776
    (lineNew.travel) ++;
#line 1777
    if (lineNew.steep != 0) {
#line 1778
      lineNew.loc.Y += lineNew.yStep;
#line 1779
      lineNew.error -= lineNew.xDelta;
#line 1780
      if (lineNew.error < 0) {
#line 1781
        lineNew.loc.X += lineNew.xStep;
#line 1782
        lineNew.error += lineNew.yDelta;
      }
    } else {
#line 1786
      lineNew.loc.X += lineNew.xStep;
#line 1787
      lineNew.error -= lineNew.yDelta;
#line 1788
      if (lineNew.error < 0) {
#line 1789
        lineNew.loc.Y += lineNew.yStep;
#line 1790
        lineNew.error += lineNew.xDelta;
      }
    }
  } else
#line 1794
  if (travel < 0) {
#line 1795
    (lineNew.travel) --;
#line 1796
    if (lineNew.steep != 0) {
#line 1797
      lineNew.loc.Y -= lineNew.yStep;
#line 1798
      lineNew.error += lineNew.xDelta;
#line 1799
      if (lineNew.error >= lineNew.yDelta) {
#line 1800
        lineNew.loc.X -= lineNew.xStep;
#line 1801
        lineNew.error -= lineNew.yDelta;
      }
    } else {
#line 1805
      lineNew.loc.X -= lineNew.xStep;
#line 1806
      lineNew.error += lineNew.yDelta;
#line 1807
      if (lineNew.error >= lineNew.xDelta) {
#line 1808
        lineNew.loc.Y -= lineNew.yStep;
#line 1809
        lineNew.error -= lineNew.xDelta;
      }
    }
  }
#line 1814
  i = 0;
  {
#line 1814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1814
    if (! (i < outward)) {
#line 1814
      goto while_break;
    }
#line 1816
    (lineNew.outward) ++;
#line 1817
    lineNew.loc.X += lineNew.xOut;
#line 1818
    lineNew.loc.Y += lineNew.yOut;
#line 1814
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1821
  *line = lineNew;
#line 1823
  return (1U);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   symbolRows[30]  = 
#line 23
  {      (int const   )10,      (int const   )12,      (int const   )14,      (int const   )16, 
        (int const   )18,      (int const   )20,      (int const   )22,      (int const   )24, 
        (int const   )26,      (int const   )32,      (int const   )36,      (int const   )40, 
        (int const   )44,      (int const   )48,      (int const   )52,      (int const   )64, 
        (int const   )72,      (int const   )80,      (int const   )88,      (int const   )96, 
        (int const   )104,      (int const   )120,      (int const   )132,      (int const   )144, 
        (int const   )8,      (int const   )8,      (int const   )12,      (int const   )12, 
        (int const   )16,      (int const   )16};
#line 29
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   symbolCols[30]  = 
#line 29
  {      (int const   )10,      (int const   )12,      (int const   )14,      (int const   )16, 
        (int const   )18,      (int const   )20,      (int const   )22,      (int const   )24, 
        (int const   )26,      (int const   )32,      (int const   )36,      (int const   )40, 
        (int const   )44,      (int const   )48,      (int const   )52,      (int const   )64, 
        (int const   )72,      (int const   )80,      (int const   )88,      (int const   )96, 
        (int const   )104,      (int const   )120,      (int const   )132,      (int const   )144, 
        (int const   )18,      (int const   )32,      (int const   )26,      (int const   )36, 
        (int const   )36,      (int const   )48};
#line 35
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   dataRegionRows[30]  = 
#line 35
  {      (int const   )8,      (int const   )10,      (int const   )12,      (int const   )14, 
        (int const   )16,      (int const   )18,      (int const   )20,      (int const   )22, 
        (int const   )24,      (int const   )14,      (int const   )16,      (int const   )18, 
        (int const   )20,      (int const   )22,      (int const   )24,      (int const   )14, 
        (int const   )16,      (int const   )18,      (int const   )20,      (int const   )22, 
        (int const   )24,      (int const   )18,      (int const   )20,      (int const   )22, 
        (int const   )6,      (int const   )6,      (int const   )10,      (int const   )10, 
        (int const   )14,      (int const   )14};
#line 41
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   dataRegionCols[30]  = 
#line 41
  {      (int const   )8,      (int const   )10,      (int const   )12,      (int const   )14, 
        (int const   )16,      (int const   )18,      (int const   )20,      (int const   )22, 
        (int const   )24,      (int const   )14,      (int const   )16,      (int const   )18, 
        (int const   )20,      (int const   )22,      (int const   )24,      (int const   )14, 
        (int const   )16,      (int const   )18,      (int const   )20,      (int const   )22, 
        (int const   )24,      (int const   )18,      (int const   )20,      (int const   )22, 
        (int const   )16,      (int const   )14,      (int const   )24,      (int const   )16, 
        (int const   )16,      (int const   )22};
#line 47
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   horizDataRegions[30]  = 
#line 47
  {      (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )1,      (int const   )2,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )2};
#line 53
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   interleavedBlocks[30]  = 
#line 53
  {      (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )6,      (int const   )6,      (int const   )8,      (int const   )10, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1};
#line 59
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   symbolDataWords[30]  = 
#line 59
  {      (int const   )3,      (int const   )5,      (int const   )8,      (int const   )12, 
        (int const   )18,      (int const   )22,      (int const   )30,      (int const   )36, 
        (int const   )44,      (int const   )62,      (int const   )86,      (int const   )114, 
        (int const   )144,      (int const   )174,      (int const   )204,      (int const   )280, 
        (int const   )368,      (int const   )456,      (int const   )576,      (int const   )696, 
        (int const   )816,      (int const   )1050,      (int const   )1304,      (int const   )1558, 
        (int const   )5,      (int const   )10,      (int const   )16,      (int const   )22, 
        (int const   )32,      (int const   )49};
#line 65
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   blockErrorWords[30]  = 
#line 65
  {      (int const   )5,      (int const   )7,      (int const   )10,      (int const   )12, 
        (int const   )14,      (int const   )18,      (int const   )20,      (int const   )24, 
        (int const   )28,      (int const   )36,      (int const   )42,      (int const   )48, 
        (int const   )56,      (int const   )68,      (int const   )42,      (int const   )56, 
        (int const   )36,      (int const   )48,      (int const   )56,      (int const   )68, 
        (int const   )56,      (int const   )68,      (int const   )62,      (int const   )62, 
        (int const   )7,      (int const   )11,      (int const   )14,      (int const   )18, 
        (int const   )24,      (int const   )28};
#line 71
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int const   blockMaxCorrectable[30]  = 
#line 71
  {      (int const   )2,      (int const   )3,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )9,      (int const   )10,      (int const   )12, 
        (int const   )14,      (int const   )18,      (int const   )21,      (int const   )24, 
        (int const   )28,      (int const   )34,      (int const   )21,      (int const   )28, 
        (int const   )18,      (int const   )24,      (int const   )28,      (int const   )34, 
        (int const   )28,      (int const   )34,      (int const   )31,      (int const   )31, 
        (int const   )3,      (int const   )5,      (int const   )7,      (int const   )9, 
        (int const   )12,      (int const   )14};
#line 20 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
extern int dmtxGetSymbolAttribute(int attribute , int sizeIdx ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 77
  if (sizeIdx < 0) {
#line 78
    return (-1);
  } else
#line 77
  if (sizeIdx >= 30) {
#line 78
    return (-1);
  }
  {
#line 81
  if (attribute == 0) {
#line 81
    goto case_0;
  }
#line 83
  if (attribute == 1) {
#line 83
    goto case_1;
  }
#line 85
  if (attribute == 2) {
#line 85
    goto case_2;
  }
#line 87
  if (attribute == 3) {
#line 87
    goto case_3;
  }
#line 89
  if (attribute == 4) {
#line 89
    goto case_4;
  }
#line 91
  if (attribute == 5) {
#line 91
    goto case_5;
  }
#line 93
  if (attribute == 6) {
#line 93
    goto case_6;
  }
#line 96
  if (attribute == 7) {
#line 96
    goto case_7;
  }
#line 98
  if (attribute == 8) {
#line 98
    goto case_8;
  }
#line 100
  if (attribute == 9) {
#line 100
    goto case_9;
  }
#line 102
  if (attribute == 10) {
#line 102
    goto case_10;
  }
#line 104
  if (attribute == 11) {
#line 104
    goto case_11;
  }
#line 106
  if (attribute == 12) {
#line 106
    goto case_12;
  }
#line 108
  if (attribute == 13) {
#line 108
    goto case_13;
  }
#line 80
  goto switch_break;
  case_0: /* CIL Label */ 
#line 82
  return ((int )symbolRows[sizeIdx]);
  case_1: /* CIL Label */ 
#line 84
  return ((int )symbolCols[sizeIdx]);
  case_2: /* CIL Label */ 
#line 86
  return ((int )dataRegionRows[sizeIdx]);
  case_3: /* CIL Label */ 
#line 88
  return ((int )dataRegionCols[sizeIdx]);
  case_4: /* CIL Label */ 
#line 90
  return ((int )horizDataRegions[sizeIdx]);
  case_5: /* CIL Label */ 
#line 92
  if (sizeIdx < 24) {
#line 92
    tmp = horizDataRegions[sizeIdx];
  } else {
#line 92
    tmp = (int const   )1;
  }
#line 92
  return ((int )tmp);
  case_6: /* CIL Label */ 
  {
#line 94
  tmp___0 = dmtxGetSymbolAttribute(5, sizeIdx);
  }
#line 94
  return ((int )(dataRegionRows[sizeIdx] * (int const   )tmp___0));
  case_7: /* CIL Label */ 
#line 97
  return ((int )(dataRegionCols[sizeIdx] * horizDataRegions[sizeIdx]));
  case_8: /* CIL Label */ 
#line 99
  return ((int )interleavedBlocks[sizeIdx]);
  case_9: /* CIL Label */ 
#line 101
  return ((int )blockErrorWords[sizeIdx]);
  case_10: /* CIL Label */ 
#line 103
  return ((int )blockMaxCorrectable[sizeIdx]);
  case_11: /* CIL Label */ 
#line 105
  return ((int )symbolDataWords[sizeIdx]);
  case_12: /* CIL Label */ 
#line 107
  return ((int )(blockErrorWords[sizeIdx] * interleavedBlocks[sizeIdx]));
  case_13: /* CIL Label */ 
#line 109
  return ((int )(blockMaxCorrectable[sizeIdx] * interleavedBlocks[sizeIdx]));
  switch_break: /* CIL Label */ ;
  }
#line 112
  return (-1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
extern int dmtxGetBlockDataSize(int sizeIdx , int blockIdx ) 
{ 
  int symbolDataWords___0 ;
  int interleavedBlocks___0 ;
  int count ;
  int tmp ;

  {
  {
#line 128
  symbolDataWords___0 = dmtxGetSymbolAttribute(11, sizeIdx);
#line 129
  interleavedBlocks___0 = dmtxGetSymbolAttribute(8, sizeIdx);
  }
#line 131
  if (symbolDataWords___0 < 1) {
#line 132
    return (-1);
  } else
#line 131
  if (interleavedBlocks___0 < 1) {
#line 132
    return (-1);
  }
#line 134
  count = symbolDataWords___0 / interleavedBlocks___0;
#line 136
  if (sizeIdx == 23) {
#line 136
    if (blockIdx < 8) {
#line 136
      tmp = count + 1;
    } else {
#line 136
      tmp = count;
    }
  } else {
#line 136
    tmp = count;
  }
#line 136
  return (tmp);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxsymbol.c"
static int FindSymbolSize(int dataWords , int sizeIdxRequest ) 
{ 
  int sizeIdx ;
  int idxBeg ;
  int idxEnd ;
  int tmp ;
  int tmp___0 ;

  {
#line 151
  if (dataWords <= 0) {
#line 152
    return (-1);
  }
#line 154
  if (sizeIdxRequest == -2) {
#line 154
    goto _L;
  } else
#line 154
  if (sizeIdxRequest == -3) {
    _L: /* CIL Label */ 
#line 156
    if (sizeIdxRequest == -2) {
#line 157
      idxBeg = 0;
#line 158
      idxEnd = 24;
    } else {
#line 161
      idxBeg = 24;
#line 162
      idxEnd = 30;
    }
#line 165
    sizeIdx = idxBeg;
    {
#line 165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 165
      if (! (sizeIdx < idxEnd)) {
#line 165
        goto while_break;
      }
      {
#line 166
      tmp = dmtxGetSymbolAttribute(11, sizeIdx);
      }
#line 166
      if (tmp >= dataWords) {
#line 167
        goto while_break;
      }
#line 165
      sizeIdx ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 170
    if (sizeIdx == idxEnd) {
#line 171
      return (-1);
    }
  } else {
#line 174
    sizeIdx = sizeIdxRequest;
  }
  {
#line 177
  tmp___0 = dmtxGetSymbolAttribute(11, sizeIdx);
  }
#line 177
  if (dataWords > tmp___0) {
#line 178
    return (-1);
  }
#line 180
  return (sizeIdx);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
int dmtxSymbolModuleStatus(DmtxMessage *message , int sizeIdx , int symbolRow , int symbolCol ) 
{ 
  int symbolRowReverse ;
  int mappingRow ;
  int mappingCol ;
  int dataRegionRows___0 ;
  int dataRegionCols___0 ;
  int symbolRows___0 ;
  int mappingCols ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 30
  dataRegionRows___0 = dmtxGetSymbolAttribute(2, sizeIdx);
#line 31
  dataRegionCols___0 = dmtxGetSymbolAttribute(3, sizeIdx);
#line 32
  symbolRows___0 = dmtxGetSymbolAttribute(0, sizeIdx);
#line 33
  mappingCols = dmtxGetSymbolAttribute(7, sizeIdx);
#line 35
  symbolRowReverse = (symbolRows___0 - symbolRow) - 1;
#line 36
  mappingRow = (symbolRowReverse - 1) - 2 * (symbolRowReverse / (dataRegionRows___0 + 2));
#line 37
  mappingCol = (symbolCol - 1) - 2 * (symbolCol / (dataRegionCols___0 + 2));
  }
#line 40
  if (symbolRow % (dataRegionRows___0 + 2) == 0) {
#line 42
    return (7);
  } else
#line 40
  if (symbolCol % (dataRegionCols___0 + 2) == 0) {
#line 42
    return (7);
  }
#line 45
  if ((symbolRow + 1) % (dataRegionRows___0 + 2) == 0) {
#line 46
    if (symbolCol & 1) {
#line 46
      tmp = 0;
    } else {
#line 46
      tmp = 7;
    }
#line 46
    return (tmp);
  }
#line 49
  if ((symbolCol + 1) % (dataRegionCols___0 + 2) == 0) {
#line 50
    if (symbolRow & 1) {
#line 50
      tmp___0 = 0;
    } else {
#line 50
      tmp___0 = 7;
    }
#line 50
    return (tmp___0);
  }
#line 53
  return ((int )*(message->array + (mappingRow * mappingCols + mappingCol)) | 64);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static int ModulePlacementEcc200(unsigned char *modules , unsigned char *codewords ,
                                 int sizeIdx , int moduleOnColor ) 
{ 
  int row ;
  int col ;
  int chr ;
  int mappingRows ;
  int mappingCols ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 70
  if (! (moduleOnColor & 7)) {
    {
#line 70
    __assert_fail("moduleOnColor & (0x01 | 0x02 | 0x04)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c",
                  70U, "ModulePlacementEcc200");
    }
  }
  {
#line 72
  mappingRows = dmtxGetSymbolAttribute(6, sizeIdx);
#line 73
  mappingCols = dmtxGetSymbolAttribute(7, sizeIdx);
#line 76
  chr = 0;
#line 77
  row = 4;
#line 78
  col = 0;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (row == mappingRows) {
#line 82
      if (col == 0) {
        {
#line 83
        tmp = chr;
#line 83
        chr ++;
#line 83
        PatternShapeSpecial1(modules, mappingRows, mappingCols, codewords + tmp, moduleOnColor);
        }
      } else {
#line 82
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 84
    if (row == mappingRows - 2) {
#line 84
      if (col == 0) {
#line 84
        if (mappingCols % 4 != 0) {
          {
#line 85
          tmp___0 = chr;
#line 85
          chr ++;
#line 85
          PatternShapeSpecial2(modules, mappingRows, mappingCols, codewords + tmp___0,
                               moduleOnColor);
          }
        } else {
#line 84
          goto _L___2;
        }
      } else {
#line 84
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 86
    if (row == mappingRows - 2) {
#line 86
      if (col == 0) {
#line 86
        if (mappingCols % 8 == 4) {
          {
#line 87
          tmp___1 = chr;
#line 87
          chr ++;
#line 87
          PatternShapeSpecial3(modules, mappingRows, mappingCols, codewords + tmp___1,
                               moduleOnColor);
          }
        } else {
#line 86
          goto _L___0;
        }
      } else {
#line 86
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 88
    if (row == mappingRows + 4) {
#line 88
      if (col == 2) {
#line 88
        if (mappingCols % 8 == 0) {
          {
#line 89
          tmp___2 = chr;
#line 89
          chr ++;
#line 89
          PatternShapeSpecial4(modules, mappingRows, mappingCols, codewords + tmp___2,
                               moduleOnColor);
          }
        }
      }
    }
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      if (row < mappingRows) {
#line 93
        if (col >= 0) {
#line 93
          if (! ((int )*(modules + (row * mappingCols + col)) & 32)) {
            {
#line 95
            tmp___3 = chr;
#line 95
            chr ++;
#line 95
            PatternShapeStandard(modules, mappingRows, mappingCols, row, col, codewords + tmp___3,
                                 moduleOnColor);
            }
          }
        }
      }
#line 96
      row -= 2;
#line 97
      col += 2;
#line 92
      if (row >= 0) {
#line 92
        if (! (col < mappingCols)) {
#line 92
          goto while_break___0;
        }
      } else {
#line 92
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    row ++;
#line 100
    col += 3;
    {
#line 103
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 104
      if (row >= 0) {
#line 104
        if (col < mappingCols) {
#line 104
          if (! ((int )*(modules + (row * mappingCols + col)) & 32)) {
            {
#line 106
            tmp___4 = chr;
#line 106
            chr ++;
#line 106
            PatternShapeStandard(modules, mappingRows, mappingCols, row, col, codewords + tmp___4,
                                 moduleOnColor);
            }
          }
        }
      }
#line 107
      row += 2;
#line 108
      col -= 2;
#line 103
      if (row < mappingRows) {
#line 103
        if (! (col >= 0)) {
#line 103
          goto while_break___1;
        }
      } else {
#line 103
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    row += 3;
#line 111
    col ++;
#line 80
    if (! (row < mappingRows)) {
#line 80
      if (! (col < mappingCols)) {
#line 80
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (! ((int )*(modules + (mappingRows * mappingCols - 1)) & 32)) {
#line 119
    *(modules + (mappingRows * mappingCols - 1)) = (unsigned char )((int )*(modules + (mappingRows * mappingCols - 1)) | moduleOnColor);
#line 120
    *(modules + ((mappingRows * mappingCols - mappingCols) - 2)) = (unsigned char )((int )*(modules + ((mappingRows * mappingCols - mappingCols) - 2)) | moduleOnColor);
  }
#line 124
  return (chr);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static void PatternShapeStandard(unsigned char *modules , int mappingRows , int mappingCols ,
                                 int row , int col , unsigned char *codeword , int moduleOnColor ) 
{ 


  {
  {
#line 141
  PlaceModule(modules, mappingRows, mappingCols, row - 2, col - 2, codeword, 128,
              moduleOnColor);
#line 142
  PlaceModule(modules, mappingRows, mappingCols, row - 2, col - 1, codeword, 64, moduleOnColor);
#line 143
  PlaceModule(modules, mappingRows, mappingCols, row - 1, col - 2, codeword, 32, moduleOnColor);
#line 144
  PlaceModule(modules, mappingRows, mappingCols, row - 1, col - 1, codeword, 16, moduleOnColor);
#line 145
  PlaceModule(modules, mappingRows, mappingCols, row - 1, col, codeword, 8, moduleOnColor);
#line 146
  PlaceModule(modules, mappingRows, mappingCols, row, col - 2, codeword, 4, moduleOnColor);
#line 147
  PlaceModule(modules, mappingRows, mappingCols, row, col - 1, codeword, 2, moduleOnColor);
#line 148
  PlaceModule(modules, mappingRows, mappingCols, row, col, codeword, 1, moduleOnColor);
  }
#line 149
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static void PatternShapeSpecial1(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) 
{ 


  {
  {
#line 163
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, 0, codeword, 128,
              moduleOnColor);
#line 164
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, 1, codeword, 64,
              moduleOnColor);
#line 165
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, 2, codeword, 32,
              moduleOnColor);
#line 166
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 2, codeword, 16,
              moduleOnColor);
#line 167
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 1, codeword, 8,
              moduleOnColor);
#line 168
  PlaceModule(modules, mappingRows, mappingCols, 1, mappingCols - 1, codeword, 4,
              moduleOnColor);
#line 169
  PlaceModule(modules, mappingRows, mappingCols, 2, mappingCols - 1, codeword, 2,
              moduleOnColor);
#line 170
  PlaceModule(modules, mappingRows, mappingCols, 3, mappingCols - 1, codeword, 1,
              moduleOnColor);
  }
#line 171
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static void PatternShapeSpecial2(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) 
{ 


  {
  {
#line 185
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 3, 0, codeword, 128,
              moduleOnColor);
#line 186
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 2, 0, codeword, 64,
              moduleOnColor);
#line 187
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, 0, codeword, 32,
              moduleOnColor);
#line 188
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 4, codeword, 16,
              moduleOnColor);
#line 189
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 3, codeword, 8,
              moduleOnColor);
#line 190
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 2, codeword, 4,
              moduleOnColor);
#line 191
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 1, codeword, 2,
              moduleOnColor);
#line 192
  PlaceModule(modules, mappingRows, mappingCols, 1, mappingCols - 1, codeword, 1,
              moduleOnColor);
  }
#line 193
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static void PatternShapeSpecial3(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) 
{ 


  {
  {
#line 207
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 3, 0, codeword, 128,
              moduleOnColor);
#line 208
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 2, 0, codeword, 64,
              moduleOnColor);
#line 209
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, 0, codeword, 32,
              moduleOnColor);
#line 210
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 2, codeword, 16,
              moduleOnColor);
#line 211
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 1, codeword, 8,
              moduleOnColor);
#line 212
  PlaceModule(modules, mappingRows, mappingCols, 1, mappingCols - 1, codeword, 4,
              moduleOnColor);
#line 213
  PlaceModule(modules, mappingRows, mappingCols, 2, mappingCols - 1, codeword, 2,
              moduleOnColor);
#line 214
  PlaceModule(modules, mappingRows, mappingCols, 3, mappingCols - 1, codeword, 1,
              moduleOnColor);
  }
#line 215
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static void PatternShapeSpecial4(unsigned char *modules , int mappingRows , int mappingCols ,
                                 unsigned char *codeword , int moduleOnColor ) 
{ 


  {
  {
#line 229
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, 0, codeword, 128,
              moduleOnColor);
#line 230
  PlaceModule(modules, mappingRows, mappingCols, mappingRows - 1, mappingCols - 1,
              codeword, 64, moduleOnColor);
#line 231
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 3, codeword, 32,
              moduleOnColor);
#line 232
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 2, codeword, 16,
              moduleOnColor);
#line 233
  PlaceModule(modules, mappingRows, mappingCols, 0, mappingCols - 1, codeword, 8,
              moduleOnColor);
#line 234
  PlaceModule(modules, mappingRows, mappingCols, 1, mappingCols - 3, codeword, 4,
              moduleOnColor);
#line 235
  PlaceModule(modules, mappingRows, mappingCols, 1, mappingCols - 2, codeword, 2,
              moduleOnColor);
#line 236
  PlaceModule(modules, mappingRows, mappingCols, 1, mappingCols - 1, codeword, 1,
              moduleOnColor);
  }
#line 237
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxplacemod.c"
static void PlaceModule(unsigned char *modules , int mappingRows , int mappingCols ,
                        int row , int col , unsigned char *codeword , int mask , int moduleOnColor ) 
{ 


  {
#line 254
  if (row < 0) {
#line 255
    row += mappingRows;
#line 256
    col += 4 - (mappingRows + 4) % 8;
  }
#line 258
  if (col < 0) {
#line 259
    col += mappingCols;
#line 260
    row += 4 - (mappingCols + 4) % 8;
  }
#line 264
  if (((int )*(modules + (row * mappingCols + col)) & 16) != 0) {
#line 265
    if (((int )*(modules + (row * mappingCols + col)) & moduleOnColor) != 0) {
#line 266
      *codeword = (unsigned char )((int )*codeword | mask);
    } else {
#line 268
      *codeword = (unsigned char )((int )*codeword & (255 ^ mask));
    }
  } else {
#line 272
    if (((int )*codeword & mask) != 0) {
#line 273
      *(modules + (row * mappingCols + col)) = (unsigned char )((int )*(modules + (row * mappingCols + col)) | moduleOnColor);
    }
#line 275
    *(modules + (row * mappingCols + col)) = (unsigned char )((int )*(modules + (row * mappingCols + col)) | 16);
  }
#line 278
  *(modules + (row * mappingCols + col)) = (unsigned char )((int )*(modules + (row * mappingCols + col)) | 32);
#line 279
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static DmtxByte log301[256]  = 
#line 40 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
  {      (DmtxByte )255,      (DmtxByte )0,      (DmtxByte )1,      (DmtxByte )240, 
        (DmtxByte )2,      (DmtxByte )225,      (DmtxByte )241,      (DmtxByte )53, 
        (DmtxByte )3,      (DmtxByte )38,      (DmtxByte )226,      (DmtxByte )133, 
        (DmtxByte )242,      (DmtxByte )43,      (DmtxByte )54,      (DmtxByte )210, 
        (DmtxByte )4,      (DmtxByte )195,      (DmtxByte )39,      (DmtxByte )114, 
        (DmtxByte )227,      (DmtxByte )106,      (DmtxByte )134,      (DmtxByte )28, 
        (DmtxByte )243,      (DmtxByte )140,      (DmtxByte )44,      (DmtxByte )23, 
        (DmtxByte )55,      (DmtxByte )118,      (DmtxByte )211,      (DmtxByte )234, 
        (DmtxByte )5,      (DmtxByte )219,      (DmtxByte )196,      (DmtxByte )96, 
        (DmtxByte )40,      (DmtxByte )222,      (DmtxByte )115,      (DmtxByte )103, 
        (DmtxByte )228,      (DmtxByte )78,      (DmtxByte )107,      (DmtxByte )125, 
        (DmtxByte )135,      (DmtxByte )8,      (DmtxByte )29,      (DmtxByte )162, 
        (DmtxByte )244,      (DmtxByte )186,      (DmtxByte )141,      (DmtxByte )180, 
        (DmtxByte )45,      (DmtxByte )99,      (DmtxByte )24,      (DmtxByte )49, 
        (DmtxByte )56,      (DmtxByte )13,      (DmtxByte )119,      (DmtxByte )153, 
        (DmtxByte )212,      (DmtxByte )199,      (DmtxByte )235,      (DmtxByte )91, 
        (DmtxByte )6,      (DmtxByte )76,      (DmtxByte )220,      (DmtxByte )217, 
        (DmtxByte )197,      (DmtxByte )11,      (DmtxByte )97,      (DmtxByte )184, 
        (DmtxByte )41,      (DmtxByte )36,      (DmtxByte )223,      (DmtxByte )253, 
        (DmtxByte )116,      (DmtxByte )138,      (DmtxByte )104,      (DmtxByte )193, 
        (DmtxByte )229,      (DmtxByte )86,      (DmtxByte )79,      (DmtxByte )171, 
        (DmtxByte )108,      (DmtxByte )165,      (DmtxByte )126,      (DmtxByte )145, 
        (DmtxByte )136,      (DmtxByte )34,      (DmtxByte )9,      (DmtxByte )74, 
        (DmtxByte )30,      (DmtxByte )32,      (DmtxByte )163,      (DmtxByte )84, 
        (DmtxByte )245,      (DmtxByte )173,      (DmtxByte )187,      (DmtxByte )204, 
        (DmtxByte )142,      (DmtxByte )81,      (DmtxByte )181,      (DmtxByte )190, 
        (DmtxByte )46,      (DmtxByte )88,      (DmtxByte )100,      (DmtxByte )159, 
        (DmtxByte )25,      (DmtxByte )231,      (DmtxByte )50,      (DmtxByte )207, 
        (DmtxByte )57,      (DmtxByte )147,      (DmtxByte )14,      (DmtxByte )67, 
        (DmtxByte )120,      (DmtxByte )128,      (DmtxByte )154,      (DmtxByte )248, 
        (DmtxByte )213,      (DmtxByte )167,      (DmtxByte )200,      (DmtxByte )63, 
        (DmtxByte )236,      (DmtxByte )110,      (DmtxByte )92,      (DmtxByte )176, 
        (DmtxByte )7,      (DmtxByte )161,      (DmtxByte )77,      (DmtxByte )124, 
        (DmtxByte )221,      (DmtxByte )102,      (DmtxByte )218,      (DmtxByte )95, 
        (DmtxByte )198,      (DmtxByte )90,      (DmtxByte )12,      (DmtxByte )152, 
        (DmtxByte )98,      (DmtxByte )48,      (DmtxByte )185,      (DmtxByte )179, 
        (DmtxByte )42,      (DmtxByte )209,      (DmtxByte )37,      (DmtxByte )132, 
        (DmtxByte )224,      (DmtxByte )52,      (DmtxByte )254,      (DmtxByte )239, 
        (DmtxByte )117,      (DmtxByte )233,      (DmtxByte )139,      (DmtxByte )22, 
        (DmtxByte )105,      (DmtxByte )27,      (DmtxByte )194,      (DmtxByte )113, 
        (DmtxByte )230,      (DmtxByte )206,      (DmtxByte )87,      (DmtxByte )158, 
        (DmtxByte )80,      (DmtxByte )189,      (DmtxByte )172,      (DmtxByte )203, 
        (DmtxByte )109,      (DmtxByte )175,      (DmtxByte )166,      (DmtxByte )62, 
        (DmtxByte )127,      (DmtxByte )247,      (DmtxByte )146,      (DmtxByte )66, 
        (DmtxByte )137,      (DmtxByte )192,      (DmtxByte )35,      (DmtxByte )252, 
        (DmtxByte )10,      (DmtxByte )183,      (DmtxByte )75,      (DmtxByte )216, 
        (DmtxByte )31,      (DmtxByte )83,      (DmtxByte )33,      (DmtxByte )73, 
        (DmtxByte )164,      (DmtxByte )144,      (DmtxByte )85,      (DmtxByte )170, 
        (DmtxByte )246,      (DmtxByte )65,      (DmtxByte )174,      (DmtxByte )61, 
        (DmtxByte )188,      (DmtxByte )202,      (DmtxByte )205,      (DmtxByte )157, 
        (DmtxByte )143,      (DmtxByte )169,      (DmtxByte )82,      (DmtxByte )72, 
        (DmtxByte )182,      (DmtxByte )215,      (DmtxByte )191,      (DmtxByte )251, 
        (DmtxByte )47,      (DmtxByte )178,      (DmtxByte )89,      (DmtxByte )151, 
        (DmtxByte )101,      (DmtxByte )94,      (DmtxByte )160,      (DmtxByte )123, 
        (DmtxByte )26,      (DmtxByte )112,      (DmtxByte )232,      (DmtxByte )21, 
        (DmtxByte )51,      (DmtxByte )238,      (DmtxByte )208,      (DmtxByte )131, 
        (DmtxByte )58,      (DmtxByte )69,      (DmtxByte )148,      (DmtxByte )18, 
        (DmtxByte )15,      (DmtxByte )16,      (DmtxByte )68,      (DmtxByte )17, 
        (DmtxByte )121,      (DmtxByte )149,      (DmtxByte )129,      (DmtxByte )19, 
        (DmtxByte )155,      (DmtxByte )59,      (DmtxByte )249,      (DmtxByte )70, 
        (DmtxByte )214,      (DmtxByte )250,      (DmtxByte )168,      (DmtxByte )71, 
        (DmtxByte )201,      (DmtxByte )156,      (DmtxByte )64,      (DmtxByte )60, 
        (DmtxByte )237,      (DmtxByte )130,      (DmtxByte )111,      (DmtxByte )20, 
        (DmtxByte )93,      (DmtxByte )122,      (DmtxByte )177,      (DmtxByte )150};
#line 59 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static DmtxByte antilog301[256]  = 
#line 59
  {      (DmtxByte )1,      (DmtxByte )2,      (DmtxByte )4,      (DmtxByte )8, 
        (DmtxByte )16,      (DmtxByte )32,      (DmtxByte )64,      (DmtxByte )128, 
        (DmtxByte )45,      (DmtxByte )90,      (DmtxByte )180,      (DmtxByte )69, 
        (DmtxByte )138,      (DmtxByte )57,      (DmtxByte )114,      (DmtxByte )228, 
        (DmtxByte )229,      (DmtxByte )231,      (DmtxByte )227,      (DmtxByte )235, 
        (DmtxByte )251,      (DmtxByte )219,      (DmtxByte )155,      (DmtxByte )27, 
        (DmtxByte )54,      (DmtxByte )108,      (DmtxByte )216,      (DmtxByte )157, 
        (DmtxByte )23,      (DmtxByte )46,      (DmtxByte )92,      (DmtxByte )184, 
        (DmtxByte )93,      (DmtxByte )186,      (DmtxByte )89,      (DmtxByte )178, 
        (DmtxByte )73,      (DmtxByte )146,      (DmtxByte )9,      (DmtxByte )18, 
        (DmtxByte )36,      (DmtxByte )72,      (DmtxByte )144,      (DmtxByte )13, 
        (DmtxByte )26,      (DmtxByte )52,      (DmtxByte )104,      (DmtxByte )208, 
        (DmtxByte )141,      (DmtxByte )55,      (DmtxByte )110,      (DmtxByte )220, 
        (DmtxByte )149,      (DmtxByte )7,      (DmtxByte )14,      (DmtxByte )28, 
        (DmtxByte )56,      (DmtxByte )112,      (DmtxByte )224,      (DmtxByte )237, 
        (DmtxByte )247,      (DmtxByte )195,      (DmtxByte )171,      (DmtxByte )123, 
        (DmtxByte )246,      (DmtxByte )193,      (DmtxByte )175,      (DmtxByte )115, 
        (DmtxByte )230,      (DmtxByte )225,      (DmtxByte )239,      (DmtxByte )243, 
        (DmtxByte )203,      (DmtxByte )187,      (DmtxByte )91,      (DmtxByte )182, 
        (DmtxByte )65,      (DmtxByte )130,      (DmtxByte )41,      (DmtxByte )82, 
        (DmtxByte )164,      (DmtxByte )101,      (DmtxByte )202,      (DmtxByte )185, 
        (DmtxByte )95,      (DmtxByte )190,      (DmtxByte )81,      (DmtxByte )162, 
        (DmtxByte )105,      (DmtxByte )210,      (DmtxByte )137,      (DmtxByte )63, 
        (DmtxByte )126,      (DmtxByte )252,      (DmtxByte )213,      (DmtxByte )135, 
        (DmtxByte )35,      (DmtxByte )70,      (DmtxByte )140,      (DmtxByte )53, 
        (DmtxByte )106,      (DmtxByte )212,      (DmtxByte )133,      (DmtxByte )39, 
        (DmtxByte )78,      (DmtxByte )156,      (DmtxByte )21,      (DmtxByte )42, 
        (DmtxByte )84,      (DmtxByte )168,      (DmtxByte )125,      (DmtxByte )250, 
        (DmtxByte )217,      (DmtxByte )159,      (DmtxByte )19,      (DmtxByte )38, 
        (DmtxByte )76,      (DmtxByte )152,      (DmtxByte )29,      (DmtxByte )58, 
        (DmtxByte )116,      (DmtxByte )232,      (DmtxByte )253,      (DmtxByte )215, 
        (DmtxByte )131,      (DmtxByte )43,      (DmtxByte )86,      (DmtxByte )172, 
        (DmtxByte )117,      (DmtxByte )234,      (DmtxByte )249,      (DmtxByte )223, 
        (DmtxByte )147,      (DmtxByte )11,      (DmtxByte )22,      (DmtxByte )44, 
        (DmtxByte )88,      (DmtxByte )176,      (DmtxByte )77,      (DmtxByte )154, 
        (DmtxByte )25,      (DmtxByte )50,      (DmtxByte )100,      (DmtxByte )200, 
        (DmtxByte )189,      (DmtxByte )87,      (DmtxByte )174,      (DmtxByte )113, 
        (DmtxByte )226,      (DmtxByte )233,      (DmtxByte )255,      (DmtxByte )211, 
        (DmtxByte )139,      (DmtxByte )59,      (DmtxByte )118,      (DmtxByte )236, 
        (DmtxByte )245,      (DmtxByte )199,      (DmtxByte )163,      (DmtxByte )107, 
        (DmtxByte )214,      (DmtxByte )129,      (DmtxByte )47,      (DmtxByte )94, 
        (DmtxByte )188,      (DmtxByte )85,      (DmtxByte )170,      (DmtxByte )121, 
        (DmtxByte )242,      (DmtxByte )201,      (DmtxByte )191,      (DmtxByte )83, 
        (DmtxByte )166,      (DmtxByte )97,      (DmtxByte )194,      (DmtxByte )169, 
        (DmtxByte )127,      (DmtxByte )254,      (DmtxByte )209,      (DmtxByte )143, 
        (DmtxByte )51,      (DmtxByte )102,      (DmtxByte )204,      (DmtxByte )181, 
        (DmtxByte )71,      (DmtxByte )142,      (DmtxByte )49,      (DmtxByte )98, 
        (DmtxByte )196,      (DmtxByte )165,      (DmtxByte )103,      (DmtxByte )206, 
        (DmtxByte )177,      (DmtxByte )79,      (DmtxByte )158,      (DmtxByte )17, 
        (DmtxByte )34,      (DmtxByte )68,      (DmtxByte )136,      (DmtxByte )61, 
        (DmtxByte )122,      (DmtxByte )244,      (DmtxByte )197,      (DmtxByte )167, 
        (DmtxByte )99,      (DmtxByte )198,      (DmtxByte )161,      (DmtxByte )111, 
        (DmtxByte )222,      (DmtxByte )145,      (DmtxByte )15,      (DmtxByte )30, 
        (DmtxByte )60,      (DmtxByte )120,      (DmtxByte )240,      (DmtxByte )205, 
        (DmtxByte )183,      (DmtxByte )67,      (DmtxByte )134,      (DmtxByte )33, 
        (DmtxByte )66,      (DmtxByte )132,      (DmtxByte )37,      (DmtxByte )74, 
        (DmtxByte )148,      (DmtxByte )5,      (DmtxByte )10,      (DmtxByte )20, 
        (DmtxByte )40,      (DmtxByte )80,      (DmtxByte )160,      (DmtxByte )109, 
        (DmtxByte )218,      (DmtxByte )153,      (DmtxByte )31,      (DmtxByte )62, 
        (DmtxByte )124,      (DmtxByte )248,      (DmtxByte )221,      (DmtxByte )151, 
        (DmtxByte )3,      (DmtxByte )6,      (DmtxByte )12,      (DmtxByte )24, 
        (DmtxByte )48,      (DmtxByte )96,      (DmtxByte )192,      (DmtxByte )173, 
        (DmtxByte )119,      (DmtxByte )238,      (DmtxByte )241,      (DmtxByte )207, 
        (DmtxByte )179,      (DmtxByte )75,      (DmtxByte )150,      (DmtxByte )0};
#line 86 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsEncode(DmtxMessage *message , int sizeIdx ) 
{ 
  int i ;
  int j ;
  int blockStride ;
  int blockIdx ;
  int blockErrorWords___0 ;
  int symbolDataWords___0 ;
  int symbolErrorWords ;
  int symbolTotalWords ;
  unsigned int passFail ;
  DmtxByte val ;
  DmtxByte *eccPtr ;
  DmtxByte genStorage[68] ;
  DmtxByte eccStorage[68] ;
  DmtxByteList gen ;
  DmtxByteList tmp ;
  DmtxByteList ecc ;
  DmtxByteList tmp___0 ;
  int tmp___1 ;

  {
  {
#line 96
  tmp = dmtxByteListBuild(genStorage, (int )sizeof(genStorage));
#line 96
  gen = tmp;
#line 97
  tmp___0 = dmtxByteListBuild(eccStorage, (int )sizeof(eccStorage));
#line 97
  ecc = tmp___0;
#line 99
  blockStride = dmtxGetSymbolAttribute(8, sizeIdx);
#line 100
  blockErrorWords___0 = dmtxGetSymbolAttribute(9, sizeIdx);
#line 101
  symbolDataWords___0 = dmtxGetSymbolAttribute(11, sizeIdx);
#line 102
  symbolErrorWords = dmtxGetSymbolAttribute(12, sizeIdx);
#line 103
  symbolTotalWords = symbolDataWords___0 + symbolErrorWords;
#line 106
  RsGenPoly(& gen, blockErrorWords___0);
#line 109
  blockIdx = 0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (blockIdx < blockStride)) {
#line 109
      goto while_break;
    }
    {
#line 112
    dmtxByteListInit(& ecc, blockErrorWords___0, (DmtxByte )0, & passFail);
    }
#line 112
    if (passFail == 0U) {
#line 112
      return (0U);
    }
#line 113
    i = blockIdx;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! (i < symbolDataWords___0)) {
#line 113
        goto while_break___0;
      }
#line 115
      val = (DmtxByte )((int )*(ecc.b + (blockErrorWords___0 - 1)) ^ (int )*(message->code + i));
#line 117
      j = blockErrorWords___0 - 1;
      {
#line 117
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 117
        if (! (j > 0)) {
#line 117
          goto while_break___1;
        }
#line 119
        if (j >= 0) {
#line 119
          if (j < ecc.length) {
#line 119
            if (! (ecc.length <= ecc.capacity)) {
              {
#line 119
              __assert_fail("(j) >= 0 && (j) < (&ecc)->length && (&ecc)->length <= (&ecc)->capacity",
                            "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                            119U, "RsEncode");
              }
            }
          } else {
            {
#line 119
            __assert_fail("(j) >= 0 && (j) < (&ecc)->length && (&ecc)->length <= (&ecc)->capacity",
                          "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                          119U, "RsEncode");
            }
          }
        } else {
          {
#line 119
          __assert_fail("(j) >= 0 && (j) < (&ecc)->length && (&ecc)->length <= (&ecc)->capacity",
                        "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                        119U, "RsEncode");
          }
        }
#line 119
        if (j - 1 >= 0) {
#line 119
          if (j - 1 < ecc.length) {
#line 119
            if (! (ecc.length <= ecc.capacity)) {
              {
#line 119
              __assert_fail("(j-1) >= 0 && (j-1) < (&ecc)->length && (&ecc)->length <= (&ecc)->capacity",
                            "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                            119U, "RsEncode");
              }
            }
          } else {
            {
#line 119
            __assert_fail("(j-1) >= 0 && (j-1) < (&ecc)->length && (&ecc)->length <= (&ecc)->capacity",
                          "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                          119U, "RsEncode");
            }
          }
        } else {
          {
#line 119
          __assert_fail("(j-1) >= 0 && (j-1) < (&ecc)->length && (&ecc)->length <= (&ecc)->capacity",
                        "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                        119U, "RsEncode");
          }
        }
#line 119
        if (j >= 0) {
#line 119
          if (j < gen.length) {
#line 119
            if (! (gen.length <= gen.capacity)) {
              {
#line 119
              __assert_fail("(j) >= 0 && (j) < (&gen)->length && (&gen)->length <= (&gen)->capacity",
                            "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                            119U, "RsEncode");
              }
            }
          } else {
            {
#line 119
            __assert_fail("(j) >= 0 && (j) < (&gen)->length && (&gen)->length <= (&gen)->capacity",
                          "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                          119U, "RsEncode");
            }
          }
        } else {
          {
#line 119
          __assert_fail("(j) >= 0 && (j) < (&gen)->length && (&gen)->length <= (&gen)->capacity",
                        "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                        119U, "RsEncode");
          }
        }
#line 120
        if ((int )*(gen.b + j) == 0) {
#line 120
          tmp___1 = 0;
        } else
#line 120
        if ((int )val == 0) {
#line 120
          tmp___1 = 0;
        } else {
#line 120
          tmp___1 = (int )antilog301[((int )log301[*(gen.b + j)] + (int )log301[val]) % 255];
        }
#line 120
        *(ecc.b + j) = (DmtxByte )((int )*(ecc.b + (j - 1)) ^ tmp___1);
#line 117
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 123
      if ((int )*(gen.b + 0) == 0) {
#line 123
        *(ecc.b + 0) = (DmtxByte )0;
      } else
#line 123
      if ((int )val == 0) {
#line 123
        *(ecc.b + 0) = (DmtxByte )0;
      } else {
#line 123
        *(ecc.b + 0) = antilog301[((int )log301[*(gen.b + 0)] + (int )log301[val]) % 255];
      }
#line 113
      i += blockStride;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    eccPtr = ecc.b + blockErrorWords___0;
#line 128
    i = symbolDataWords___0 + blockIdx;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (i < symbolTotalWords)) {
#line 128
        goto while_break___2;
      }
#line 129
      eccPtr --;
#line 129
      *(message->code + i) = *eccPtr;
#line 128
      i += blockStride;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 131
    if (! ((unsigned long )ecc.b == (unsigned long )eccPtr)) {
      {
#line 131
      __assert_fail("ecc.b == eccPtr", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                    131U, "RsEncode");
      }
    }
#line 109
    blockIdx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (1U);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsDecode(unsigned char *code , int sizeIdx , int fix ) 
{ 
  int i ;
  int blockStride ;
  int blockIdx ;
  int blockDataWords ;
  int blockErrorWords___0 ;
  int blockTotalWords ;
  int blockMaxCorrectable___0 ;
  int symbolDataWords___0 ;
  int symbolErrorWords ;
  int symbolTotalWords ;
  unsigned int error ;
  unsigned int repairable ;
  unsigned int passFail ;
  unsigned char *word ;
  DmtxByte elpStorage[68] ;
  DmtxByte synStorage[69] ;
  DmtxByte recStorage[255] ;
  DmtxByte locStorage[255] ;
  DmtxByteList elp ;
  DmtxByteList tmp ;
  DmtxByteList syn ;
  DmtxByteList tmp___0 ;
  DmtxByteList rec ;
  DmtxByteList tmp___1 ;
  DmtxByteList loc ;
  DmtxByteList tmp___2 ;

  {
  {
#line 161
  tmp = dmtxByteListBuild(elpStorage, (int )sizeof(elpStorage));
#line 161
  elp = tmp;
#line 162
  tmp___0 = dmtxByteListBuild(synStorage, (int )sizeof(synStorage));
#line 162
  syn = tmp___0;
#line 163
  tmp___1 = dmtxByteListBuild(recStorage, (int )sizeof(recStorage));
#line 163
  rec = tmp___1;
#line 164
  tmp___2 = dmtxByteListBuild(locStorage, (int )sizeof(locStorage));
#line 164
  loc = tmp___2;
#line 166
  blockStride = dmtxGetSymbolAttribute(8, sizeIdx);
#line 167
  blockErrorWords___0 = dmtxGetSymbolAttribute(9, sizeIdx);
#line 168
  blockMaxCorrectable___0 = dmtxGetSymbolAttribute(10, sizeIdx);
#line 169
  symbolDataWords___0 = dmtxGetSymbolAttribute(11, sizeIdx);
#line 170
  symbolErrorWords = dmtxGetSymbolAttribute(12, sizeIdx);
#line 171
  symbolTotalWords = symbolDataWords___0 + symbolErrorWords;
#line 174
  blockIdx = 0;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (blockIdx < blockStride)) {
#line 174
      goto while_break;
    }
    {
#line 177
    blockDataWords = dmtxGetBlockDataSize(sizeIdx, blockIdx);
#line 178
    blockTotalWords = blockErrorWords___0 + blockDataWords;
#line 181
    dmtxByteListInit(& rec, 0, (DmtxByte )0, & passFail);
    }
#line 181
    if (passFail == 0U) {
#line 181
      return (0U);
    }
#line 184
    word = ((code + symbolTotalWords) + blockIdx) - blockStride;
#line 185
    i = 0;
    {
#line 185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 185
      if (! (i < blockErrorWords___0)) {
#line 185
        goto while_break___0;
      }
      {
#line 187
      dmtxByteListPush(& rec, *word, & passFail);
      }
#line 187
      if (passFail == 0U) {
#line 187
        return (0U);
      }
#line 188
      word -= blockStride;
#line 185
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    word = (code + blockIdx) + blockStride * (blockDataWords - 1);
#line 193
    i = 0;
    {
#line 193
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 193
      if (! (i < blockDataWords)) {
#line 193
        goto while_break___1;
      }
      {
#line 195
      dmtxByteListPush(& rec, *word, & passFail);
      }
#line 195
      if (passFail == 0U) {
#line 195
        return (0U);
      }
#line 196
      word -= blockStride;
#line 193
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 200
    error = RsComputeSyndromes(& syn, (DmtxByteList const   *)(& rec), blockErrorWords___0);
    }
#line 203
    if (error) {
      {
#line 206
      repairable = RsFindErrorLocatorPoly(& elp, (DmtxByteList const   *)(& syn),
                                          blockErrorWords___0, blockMaxCorrectable___0);
      }
#line 207
      if (! repairable) {
#line 208
        return (0U);
      }
      {
#line 211
      repairable = RsFindErrorLocations(& loc, (DmtxByteList const   *)(& elp));
      }
#line 212
      if (! repairable) {
#line 213
        return (0U);
      }
      {
#line 216
      RsRepairErrors(& rec, (DmtxByteList const   *)(& loc), (DmtxByteList const   *)(& elp),
                     (DmtxByteList const   *)(& syn));
      }
    }
#line 224
    word = code + blockIdx;
#line 225
    i = 0;
    {
#line 225
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 225
      if (! (i < blockDataWords)) {
#line 225
        goto while_break___2;
      }
      {
#line 227
      *word = dmtxByteListPop(& rec, & passFail);
      }
#line 227
      if (passFail == 0U) {
#line 227
        return (0U);
      }
#line 228
      word += blockStride;
#line 225
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 232
    word = (code + symbolDataWords___0) + blockIdx;
#line 233
    i = 0;
    {
#line 233
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 233
      if (! (i < blockErrorWords___0)) {
#line 233
        goto while_break___3;
      }
      {
#line 235
      *word = dmtxByteListPop(& rec, & passFail);
      }
#line 235
      if (passFail == 0U) {
#line 235
        return (0U);
      }
#line 236
      word += blockStride;
#line 233
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 174
    blockIdx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (1U);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsGenPoly(DmtxByteList *gen , int errorWordCount ) 
{ 
  int i ;
  int j ;
  unsigned int passFail ;

  {
  {
#line 259
  dmtxByteListInit(gen, errorWordCount, (DmtxByte )1, & passFail);
  }
#line 259
  if (passFail == 0U) {
#line 259
    return (0U);
  }
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < gen->length)) {
#line 262
      goto while_break;
    }
#line 264
    j = i;
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 264
      if (! (j >= 0)) {
#line 264
        goto while_break___0;
      }
#line 266
      if ((int )*(gen->b + j) == 0) {
#line 266
        *(gen->b + j) = (DmtxByte )0;
      } else {
#line 266
        *(gen->b + j) = antilog301[((int )log301[*(gen->b + j)] + (i + 1)) % 255];
      }
#line 267
      if (j > 0) {
#line 268
        *(gen->b + j) = (DmtxByte )((int )*(gen->b + j) ^ (int )*(gen->b + (j - 1)));
      }
#line 264
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return (1U);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsComputeSyndromes(DmtxByteList *syn , DmtxByteList const   *rec ,
                                       int blockErrorWords___0 ) 
{ 
  int i ;
  int j ;
  unsigned int passFail ;
  unsigned int error ;
  int tmp ;

  {
  {
#line 294
  error = 0U;
#line 297
  dmtxByteListInit(syn, blockErrorWords___0 + 1, (DmtxByte )0, & passFail);
  }
#line 297
  if (passFail == 0U) {
#line 297
    return (1U);
  }
#line 299
  i = 1;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < syn->length)) {
#line 299
      goto while_break;
    }
#line 302
    j = 0;
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! (j < (int )rec->length)) {
#line 302
        goto while_break___0;
      }
#line 303
      if ((int )*(rec->b + j) == 0) {
#line 303
        tmp = 0;
      } else {
#line 303
        tmp = (int )antilog301[((int )log301[*(rec->b + j)] + i * j) % 255];
      }
#line 303
      *(syn->b + i) = (DmtxByte )((int )*(syn->b + i) ^ tmp);
#line 302
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 306
    if ((int )*(syn->b + i) != 0) {
#line 307
      error = 1U;
    }
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (error);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsFindErrorLocatorPoly(DmtxByteList *elpOut , DmtxByteList const   *syn ,
                                           int errorWordCount , int maxCorrectable ) 
{ 
  int i ;
  int iNext ;
  int j ;
  int m ;
  int mCmp ;
  int lambda ;
  DmtxByte disTmp ;
  DmtxByte disStorage[69] ;
  DmtxByte elpStorage[70][68] ;
  DmtxByteList dis ;
  DmtxByteList elp[70] ;
  unsigned int passFail ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 335
  dis = dmtxByteListBuild(disStorage, (int )sizeof(disStorage));
#line 336
  dmtxByteListInit(& dis, 0, (DmtxByte )0, & passFail);
  }
#line 336
  if (passFail == 0U) {
#line 336
    return (0U);
  }
#line 338
  i = 0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (i < 70)) {
#line 338
      goto while_break;
    }
    {
#line 340
    elp[i] = dmtxByteListBuild(elpStorage[i], (int )sizeof(elpStorage[i]));
#line 341
    dmtxByteListInit(& elp[i], 0, (DmtxByte )0, & passFail);
    }
#line 341
    if (passFail == 0U) {
#line 341
      return (0U);
    }
#line 338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  dmtxByteListPush(& elp[0], (DmtxByte )1, & passFail);
  }
#line 345
  if (passFail == 0U) {
#line 345
    return (0U);
  }
  {
#line 346
  dmtxByteListPush(& dis, (DmtxByte )1, & passFail);
  }
#line 346
  if (passFail == 0U) {
#line 346
    return (0U);
  }
  {
#line 349
  dmtxByteListPush(& elp[1], (DmtxByte )1, & passFail);
  }
#line 349
  if (passFail == 0U) {
#line 349
    return (0U);
  }
  {
#line 350
  dmtxByteListPush(& dis, *(syn->b + 1), & passFail);
  }
#line 350
  if (passFail == 0U) {
#line 350
    return (0U);
  }
#line 352
  iNext = 2;
#line 352
  i = 1;
  {
#line 352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 354
    if ((int )*(dis.b + i) == 0) {
      {
#line 357
      dmtxByteListCopy(& elp[iNext], (DmtxByteList const   *)(& elp[i]), & passFail);
      }
#line 357
      if (passFail == 0U) {
#line 357
        return (0U);
      }
    } else {
#line 362
      m = 0;
#line 362
      mCmp = 1;
      {
#line 362
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 362
        if (! (mCmp < i)) {
#line 362
          goto while_break___1;
        }
#line 363
        if ((int )*(dis.b + mCmp) != 0) {
#line 363
          if (mCmp - elp[mCmp].length >= m - elp[m].length) {
#line 364
            m = mCmp;
          }
        }
#line 362
        mCmp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 367
      lambda = elp[m].length - 1;
#line 367
      j = 0;
      {
#line 367
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 367
        if (! (j <= lambda)) {
#line 367
          goto while_break___2;
        }
#line 368
        *(elp[iNext].b + ((j + i) - m)) = antilog301[(((255 - (int )log301[*(dis.b + m)]) + (int )log301[*(dis.b + i)]) + (int )log301[*(elp[m].b + j)]) % 255];
#line 367
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 372
      lambda = elp[i].length - 1;
#line 372
      j = 0;
      {
#line 372
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 372
        if (! (j <= lambda)) {
#line 372
          goto while_break___3;
        }
#line 373
        *(elp[iNext].b + j) = (DmtxByte )((int )*(elp[iNext].b + j) ^ (int )*(elp[i].b + j));
#line 372
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 375
      if (elp[i].length > (elp[m].length + i) - m) {
#line 375
        elp[iNext].length = elp[i].length;
      } else {
#line 375
        elp[iNext].length = (elp[m].length + i) - m;
      }
    }
#line 378
    lambda = elp[iNext].length - 1;
#line 379
    if (i == errorWordCount) {
#line 380
      goto while_break___0;
    } else
#line 379
    if (i >= lambda + maxCorrectable) {
#line 380
      goto while_break___0;
    }
#line 383
    disTmp = *(syn->b + iNext);
#line 383
    j = 1;
    {
#line 383
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 383
      if (! (j <= lambda)) {
#line 383
        goto while_break___4;
      }
#line 384
      if ((int )*(syn->b + (iNext - j)) == 0) {
#line 384
        tmp___0 = 0;
      } else
#line 384
      if ((int )*(elp[iNext].b + j) == 0) {
#line 384
        tmp___0 = 0;
      } else {
#line 384
        tmp___0 = (int )antilog301[((int )log301[*(syn->b + (iNext - j))] + (int )log301[*(elp[iNext].b + j)]) % 255];
      }
#line 384
      disTmp = (DmtxByte )((int )disTmp ^ tmp___0);
#line 383
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 386
    if (! (dis.length == iNext)) {
      {
#line 386
      __assert_fail("dis.length == iNext", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c",
                    386U, "RsFindErrorLocatorPoly");
      }
    }
    {
#line 387
    dmtxByteListPush(& dis, disTmp, & passFail);
    }
#line 387
    if (passFail == 0U) {
#line 387
      return (0U);
    }
#line 352
    tmp = iNext;
#line 352
    iNext ++;
#line 352
    i = tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 390
  dmtxByteListCopy(elpOut, (DmtxByteList const   *)(& elp[iNext]), & passFail);
  }
#line 390
  if (passFail == 0U) {
#line 390
    return (0U);
  }
#line 392
  if (lambda <= maxCorrectable) {
#line 392
    tmp___1 = 1;
  } else {
#line 392
    tmp___1 = 0;
  }
#line 392
  return ((unsigned int )tmp___1);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsFindErrorLocations(DmtxByteList *loc , DmtxByteList const   *elp ) 
{ 
  int i ;
  int j ;
  int lambda ;
  unsigned int passFail ;
  DmtxByte q ;
  DmtxByte regStorage[68] ;
  DmtxByteList reg ;
  DmtxByteList tmp ;
  int tmp___0 ;

  {
  {
#line 411
  lambda = (int )(elp->length - 1);
#line 414
  tmp = dmtxByteListBuild(regStorage, (int )sizeof(regStorage));
#line 414
  reg = tmp;
#line 416
  dmtxByteListCopy(& reg, elp, & passFail);
  }
#line 416
  if (passFail == 0U) {
#line 416
    return (0U);
  }
  {
#line 417
  dmtxByteListInit(loc, 0, (DmtxByte )0, & passFail);
  }
#line 417
  if (passFail == 0U) {
#line 417
    return (0U);
  }
#line 419
  i = 1;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i <= 255)) {
#line 419
      goto while_break;
    }
#line 421
    q = (DmtxByte )1;
#line 421
    j = 1;
    {
#line 421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 421
      if (! (j <= lambda)) {
#line 421
        goto while_break___0;
      }
#line 423
      if ((int )*(reg.b + j) == 0) {
#line 423
        *(reg.b + j) = (DmtxByte )0;
      } else {
#line 423
        *(reg.b + j) = antilog301[((int )log301[*(reg.b + j)] + j) % 255];
      }
#line 424
      q = (DmtxByte )((int )q ^ (int )*(reg.b + j));
#line 421
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 427
    if ((int )q == 0) {
      {
#line 429
      dmtxByteListPush(loc, (DmtxByte )(255 - i), & passFail);
      }
#line 429
      if (passFail == 0U) {
#line 429
        return (0U);
      }
    }
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  if (loc->length == lambda) {
#line 433
    tmp___0 = 1;
  } else {
#line 433
    tmp___0 = 0;
  }
#line 433
  return ((unsigned int )tmp___0);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxreedsol.c"
static unsigned int RsRepairErrors(DmtxByteList *rec , DmtxByteList const   *loc ,
                                   DmtxByteList const   *elp , DmtxByteList const   *syn ) 
{ 
  int i ;
  int j ;
  int q ;
  int lambda ;
  unsigned int passFail ;
  DmtxByte zVal ;
  DmtxByte root ;
  DmtxByte err ;
  DmtxByte zStorage[69] ;
  DmtxByteList z ;
  DmtxByteList tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 456
  lambda = (int )(elp->length - 1);
#line 460
  tmp = dmtxByteListBuild(zStorage, (int )sizeof(zStorage));
#line 460
  z = tmp;
#line 463
  dmtxByteListPush(& z, (DmtxByte )1, & passFail);
  }
#line 463
  if (passFail == 0U) {
#line 463
    return (0U);
  }
#line 464
  i = 1;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (i <= lambda)) {
#line 464
      goto while_break;
    }
#line 466
    zVal = (DmtxByte )((int )*(syn->b + i) ^ (int )*(elp->b + i));
#line 466
    j = 1;
    {
#line 466
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 466
      if (! (j < i)) {
#line 466
        goto while_break___0;
      }
#line 467
      if ((int )*(elp->b + (i - j)) == 0) {
#line 467
        tmp___0 = 0;
      } else
#line 467
      if ((int )*(syn->b + j) == 0) {
#line 467
        tmp___0 = 0;
      } else {
#line 467
        tmp___0 = (int )antilog301[((int )log301[*(elp->b + (i - j))] + (int )log301[*(syn->b + j)]) % 255];
      }
#line 467
      zVal = (DmtxByte )((int )zVal ^ tmp___0);
#line 466
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 468
    dmtxByteListPush(& z, zVal, & passFail);
    }
#line 468
    if (passFail == 0U) {
#line 468
      return (0U);
    }
#line 464
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 471
    if (! (i < lambda)) {
#line 471
      goto while_break___1;
    }
#line 474
    root = (DmtxByte )(255 - (int )*(loc->b + i));
#line 476
    err = (DmtxByte )1;
#line 476
    j = 1;
    {
#line 476
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 476
      if (! (j <= lambda)) {
#line 476
        goto while_break___2;
      }
#line 477
      if ((int )*(z.b + j) == 0) {
#line 477
        tmp___1 = 0;
      } else {
#line 477
        tmp___1 = (int )antilog301[((int )log301[*(z.b + j)] + j * (int )root) % 255];
      }
#line 477
      err = (DmtxByte )((int )err ^ tmp___1);
#line 476
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 479
    if ((int )err == 0) {
#line 480
      goto __Cont;
    }
#line 483
    q = 0;
#line 483
    j = 0;
    {
#line 483
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 483
      if (! (j < lambda)) {
#line 483
        goto while_break___3;
      }
#line 485
      if (j != i) {
#line 486
        q += (int )log301[1 ^ (int )antilog301[((int )*(loc->b + j) + (int )root) % 255]];
      }
#line 483
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 488
    q %= 255;
#line 490
    if ((int )err == 0) {
#line 490
      err = (DmtxByte )0;
    } else {
#line 490
      err = antilog301[((int )log301[err] + (255 - q)) % 255];
    }
#line 491
    *(rec->b + *(loc->b + i)) = (DmtxByte )((int )*(rec->b + *(loc->b + i)) ^ (int )err);
    __Cont: /* CIL Label */ 
#line 471
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 494
  return (1U);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxscangrid.c"
static DmtxScanGrid InitScanGrid(DmtxDecode *dec ) 
{ 
  int scale ;
  int smallestFeature ;
  int xExtent ;
  int yExtent ;
  int maxExtent ;
  int extent ;
  DmtxScanGrid grid ;
  int tmp ;

  {
  {
#line 27
  memset((void *)(& grid), 0, sizeof(DmtxScanGrid ));
#line 29
  scale = dmtxDecodeGetProp(dec, 404);
#line 30
  tmp = dmtxDecodeGetProp(dec, 202);
#line 30
  smallestFeature = tmp / scale;
#line 32
  grid.xMin = dmtxDecodeGetProp(dec, 400);
#line 33
  grid.xMax = dmtxDecodeGetProp(dec, 401);
#line 34
  grid.yMin = dmtxDecodeGetProp(dec, 402);
#line 35
  grid.yMax = dmtxDecodeGetProp(dec, 403);
#line 38
  xExtent = grid.xMax - grid.xMin;
#line 39
  yExtent = grid.yMax - grid.yMin;
  }
#line 40
  if (xExtent > yExtent) {
#line 40
    maxExtent = xExtent;
  } else {
#line 40
    maxExtent = yExtent;
  }
#line 42
  if (! (maxExtent > 1)) {
    {
#line 42
    __assert_fail("maxExtent > 1", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxscangrid.c",
                  42U, "InitScanGrid");
    }
  }
#line 44
  extent = 1;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (extent < maxExtent)) {
#line 44
      goto while_break;
    }
#line 45
    if (extent <= smallestFeature) {
#line 46
      grid.minExtent = extent;
    }
#line 44
    extent = (extent + 1) * 2 - 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  grid.maxExtent = extent;
#line 50
  grid.xOffset = ((grid.xMin + grid.xMax) - grid.maxExtent) / 2;
#line 51
  grid.yOffset = ((grid.yMin + grid.yMax) - grid.maxExtent) / 2;
#line 54
  grid.total = 1;
#line 55
  grid.extent = grid.maxExtent;
#line 57
  SetDerivedFields(& grid);
  }
#line 59
  return (grid);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxscangrid.c"
static int PopGridLocation(DmtxScanGrid *grid , DmtxPixelLoc *locPtr ) 
{ 
  int locStatus ;

  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    locStatus = GetGridCoordinates(grid, locPtr);
#line 78
    (grid->pixelCount) ++;
    }
#line 74
    if (! (locStatus == 1)) {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (locStatus);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxscangrid.c"
static int GetGridCoordinates(DmtxScanGrid *grid , DmtxPixelLoc *locPtr ) 
{ 
  int count ;
  int half ;
  int quarter ;
  DmtxPixelLoc loc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 101
  if (grid->pixelCount >= grid->pixelTotal) {
#line 102
    grid->pixelCount = 0;
#line 103
    grid->xCenter += grid->jumpSize;
  }
#line 107
  if (grid->xCenter > grid->maxExtent) {
#line 108
    grid->xCenter = grid->startPos;
#line 109
    grid->yCenter += grid->jumpSize;
  }
#line 113
  if (grid->yCenter > grid->maxExtent) {
    {
#line 114
    grid->total *= 4;
#line 115
    grid->extent /= 2;
#line 116
    SetDerivedFields(grid);
    }
  }
#line 119
  if (grid->extent == 0) {
#line 120
    tmp = -1;
#line 120
    locPtr->Y = tmp;
#line 120
    locPtr->X = tmp;
#line 121
    return (2);
  } else
#line 119
  if (grid->extent < grid->minExtent) {
#line 120
    tmp = -1;
#line 120
    locPtr->Y = tmp;
#line 120
    locPtr->X = tmp;
#line 121
    return (2);
  }
#line 124
  count = grid->pixelCount;
#line 126
  if (! (count < grid->pixelTotal)) {
    {
#line 126
    __assert_fail("count < grid->pixelTotal", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxscangrid.c",
                  126U, "GetGridCoordinates");
    }
  }
#line 128
  if (count == grid->pixelTotal - 1) {
#line 130
    loc.X = grid->xCenter;
#line 131
    loc.Y = grid->yCenter;
  } else {
#line 134
    half = grid->pixelTotal / 2;
#line 135
    quarter = half / 2;
#line 138
    if (count < half) {
#line 139
      if (count < quarter) {
#line 139
        tmp___0 = count - quarter;
      } else {
#line 139
        tmp___0 = half - count;
      }
#line 139
      loc.X = grid->xCenter + tmp___0;
#line 140
      loc.Y = grid->yCenter;
    } else {
#line 144
      count -= half;
#line 145
      loc.X = grid->xCenter;
#line 146
      if (count < quarter) {
#line 146
        tmp___1 = count - quarter;
      } else {
#line 146
        tmp___1 = half - count;
      }
#line 146
      loc.Y = grid->yCenter + tmp___1;
    }
  }
#line 150
  loc.X += grid->xOffset;
#line 151
  loc.Y += grid->yOffset;
#line 153
  *locPtr = loc;
#line 155
  if (loc.X < grid->xMin) {
#line 157
    return (1);
  } else
#line 155
  if (loc.X > grid->xMax) {
#line 157
    return (1);
  } else
#line 155
  if (loc.Y < grid->yMin) {
#line 157
    return (1);
  } else
#line 155
  if (loc.Y > grid->yMax) {
#line 157
    return (1);
  }
#line 159
  return (0);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxscangrid.c"
static void SetDerivedFields(DmtxScanGrid *grid ) 
{ 
  int tmp ;

  {
#line 170
  grid->jumpSize = grid->extent + 1;
#line 171
  grid->pixelTotal = 2 * grid->extent - 1;
#line 172
  grid->startPos = grid->extent / 2;
#line 173
  grid->pixelCount = 0;
#line 174
  tmp = grid->startPos;
#line 174
  grid->yCenter = tmp;
#line 174
  grid->xCenter = tmp;
#line 175
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern DmtxImage *dmtxImageCreate(unsigned char *pxl , int width , int height , int pack ) 
{ 
  unsigned int err ;
  DmtxImage *img ;
  void *tmp ;

  {
#line 65
  if ((unsigned long )pxl == (unsigned long )((void *)0)) {
#line 66
    return ((DmtxImage *)((void *)0));
  } else
#line 65
  if (width < 1) {
#line 66
    return ((DmtxImage *)((void *)0));
  } else
#line 65
  if (height < 1) {
#line 66
    return ((DmtxImage *)((void *)0));
  }
  {
#line 68
  tmp = calloc((size_t )1, sizeof(DmtxImage ));
#line 68
  img = (DmtxImage *)tmp;
  }
#line 69
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 70
    return ((DmtxImage *)((void *)0));
  }
  {
#line 72
  img->pxl = pxl;
#line 73
  img->width = width;
#line 74
  img->height = height;
#line 75
  img->pixelPacking = pack;
#line 76
  img->bitsPerPixel = GetBitsPerPixel(pack);
#line 77
  img->bytesPerPixel = img->bitsPerPixel / 8;
#line 78
  img->rowPadBytes = 0;
#line 79
  img->rowSizeBytes = img->width * img->bytesPerPixel + img->rowPadBytes;
#line 80
  img->imageFlip = 0;
#line 83
  img->channelCount = 0;
  }
  {
#line 86
  if (pack == 100) {
#line 86
    goto case_100;
  }
#line 88
  if (pack == 200) {
#line 88
    goto case_200;
  }
#line 92
  if (pack == 300) {
#line 92
    goto case_300;
  }
#line 97
  if (pack == 406) {
#line 97
    goto case_406;
  }
#line 97
  if (pack == 403) {
#line 97
    goto case_406;
  }
#line 97
  if (pack == 400) {
#line 97
    goto case_406;
  }
#line 106
  if (pack == 602) {
#line 106
    goto case_602;
  }
#line 106
  if (pack == 600) {
#line 106
    goto case_602;
  }
#line 106
  if (pack == 502) {
#line 106
    goto case_602;
  }
#line 106
  if (pack == 501) {
#line 106
    goto case_602;
  }
#line 106
  if (pack == 500) {
#line 106
    goto case_602;
  }
#line 112
  if (pack == 404) {
#line 112
    goto case_404;
  }
#line 112
  if (pack == 401) {
#line 112
    goto case_404;
  }
#line 118
  if (pack == 405) {
#line 118
    goto case_405;
  }
#line 118
  if (pack == 402) {
#line 118
    goto case_405;
  }
#line 124
  if (pack == 603) {
#line 124
    goto case_603;
  }
#line 124
  if (pack == 601) {
#line 124
    goto case_603;
  }
#line 129
  if (pack == 604) {
#line 129
    goto case_604;
  }
#line 135
  goto switch_default;
  case_100: /* CIL Label */ 
#line 87
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 89
  err = dmtxImageSetChannel(img, 0, 1);
  }
#line 90
  return ((DmtxImage *)((void *)0));
  case_300: /* CIL Label */ 
  {
#line 93
  err = dmtxImageSetChannel(img, 0, 8);
  }
#line 94
  goto switch_break;
  case_406: /* CIL Label */ 
  case_403: /* CIL Label */ 
  case_400: /* CIL Label */ 
  {
#line 98
  err = dmtxImageSetChannel(img, 0, 5);
#line 99
  err = dmtxImageSetChannel(img, 5, 5);
#line 100
  err = dmtxImageSetChannel(img, 10, 5);
  }
#line 101
  goto switch_break;
  case_602: /* CIL Label */ 
  case_600: /* CIL Label */ 
  case_502: /* CIL Label */ 
  case_501: /* CIL Label */ 
  case_500: /* CIL Label */ 
  {
#line 107
  err = dmtxImageSetChannel(img, 0, 8);
#line 108
  err = dmtxImageSetChannel(img, 8, 8);
#line 109
  err = dmtxImageSetChannel(img, 16, 8);
  }
#line 110
  goto switch_break;
  case_404: /* CIL Label */ 
  case_401: /* CIL Label */ 
  {
#line 113
  err = dmtxImageSetChannel(img, 0, 5);
#line 114
  err = dmtxImageSetChannel(img, 5, 5);
#line 115
  err = dmtxImageSetChannel(img, 10, 5);
  }
#line 116
  goto switch_break;
  case_405: /* CIL Label */ 
  case_402: /* CIL Label */ 
  {
#line 119
  err = dmtxImageSetChannel(img, 1, 5);
#line 120
  err = dmtxImageSetChannel(img, 6, 5);
#line 121
  err = dmtxImageSetChannel(img, 11, 5);
  }
#line 122
  goto switch_break;
  case_603: /* CIL Label */ 
  case_601: /* CIL Label */ 
  {
#line 125
  err = dmtxImageSetChannel(img, 8, 8);
#line 126
  err = dmtxImageSetChannel(img, 16, 8);
#line 127
  err = dmtxImageSetChannel(img, 24, 8);
  }
#line 128
  goto switch_break;
  case_604: /* CIL Label */ 
  {
#line 130
  err = dmtxImageSetChannel(img, 0, 8);
#line 131
  err = dmtxImageSetChannel(img, 8, 8);
#line 132
  err = dmtxImageSetChannel(img, 16, 8);
#line 133
  err = dmtxImageSetChannel(img, 24, 8);
  }
#line 134
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 136
  return ((DmtxImage *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 139
  return (img);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageDestroy(DmtxImage **img ) 
{ 


  {
#line 150
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 151
    return (0U);
  } else
#line 150
  if ((unsigned long )*img == (unsigned long )((void *)0)) {
#line 151
    return (0U);
  }
  {
#line 153
  free((void *)*img);
#line 155
  *img = (DmtxImage *)((void *)0);
  }
#line 157
  return (1U);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageSetChannel(DmtxImage *img , int channelStart , int bitsPerChannel ) 
{ 


  {
#line 167
  if (img->channelCount >= 4) {
#line 168
    return (0U);
  }
#line 174
  img->bitsPerChannel[img->channelCount] = bitsPerChannel;
#line 175
  img->channelStart[img->channelCount] = channelStart;
#line 176
  (img->channelCount) ++;
#line 178
  return (1U);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageSetProp(DmtxImage *img , int prop , int value ) 
{ 


  {
#line 189
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 190
    return (0U);
  }
  {
#line 193
  if (prop == 305) {
#line 193
    goto case_305;
  }
#line 197
  if (prop == 307) {
#line 197
    goto case_307;
  }
#line 200
  goto switch_default;
  case_305: /* CIL Label */ 
#line 194
  img->rowPadBytes = value;
#line 195
  img->rowSizeBytes = img->width * (img->bitsPerPixel / 8) + img->rowPadBytes;
#line 196
  goto switch_break;
  case_307: /* CIL Label */ 
#line 198
  img->imageFlip = value;
#line 199
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 201
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 204
  return (1U);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern int dmtxImageGetProp(DmtxImage *img , int prop ) 
{ 


  {
#line 215
  if ((unsigned long )img == (unsigned long )((void *)0)) {
#line 216
    return (-1);
  }
  {
#line 219
  if (prop == 300) {
#line 219
    goto case_300;
  }
#line 221
  if (prop == 301) {
#line 221
    goto case_301;
  }
#line 223
  if (prop == 302) {
#line 223
    goto case_302;
  }
#line 225
  if (prop == 303) {
#line 225
    goto case_303;
  }
#line 227
  if (prop == 304) {
#line 227
    goto case_304;
  }
#line 229
  if (prop == 305) {
#line 229
    goto case_305;
  }
#line 231
  if (prop == 306) {
#line 231
    goto case_306;
  }
#line 233
  if (prop == 307) {
#line 233
    goto case_307;
  }
#line 235
  if (prop == 308) {
#line 235
    goto case_308;
  }
#line 237
  goto switch_default;
  case_300: /* CIL Label */ 
#line 220
  return (img->width);
  case_301: /* CIL Label */ 
#line 222
  return (img->height);
  case_302: /* CIL Label */ 
#line 224
  return (img->pixelPacking);
  case_303: /* CIL Label */ 
#line 226
  return (img->bitsPerPixel);
  case_304: /* CIL Label */ 
#line 228
  return (img->bytesPerPixel);
  case_305: /* CIL Label */ 
#line 230
  return (img->rowPadBytes);
  case_306: /* CIL Label */ 
#line 232
  return (img->rowSizeBytes);
  case_307: /* CIL Label */ 
#line 234
  return (img->imageFlip);
  case_308: /* CIL Label */ 
#line 236
  return (img->channelCount);
  switch_default: /* CIL Label */ 
#line 238
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 241
  return (-1);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern int dmtxImageGetByteOffset(DmtxImage *img , int x , int y ) 
{ 
  unsigned int tmp ;

  {
#line 254
  if (! ((unsigned long )img != (unsigned long )((void *)0))) {
    {
#line 254
    __assert_fail("img != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  254U, "dmtxImageGetByteOffset");
    }
  }
#line 255
  if (! (! (img->imageFlip & 1))) {
    {
#line 255
    __assert_fail("!(img->imageFlip & DmtxFlipX)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  255U, "dmtxImageGetByteOffset");
    }
  }
  {
#line 257
  tmp = dmtxImageContainsInt(img, 0, x, y);
  }
#line 257
  if (tmp == 0U) {
#line 258
    return (-1);
  }
#line 260
  if (img->imageFlip & 2) {
#line 261
    return (y * img->rowSizeBytes + x * img->bytesPerPixel);
  }
#line 263
  return (((img->height - y) - 1) * img->rowSizeBytes + x * img->bytesPerPixel);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageGetPixelValue(DmtxImage *img , int x , int y , int channel ,
                                           int *value ) 
{ 
  int offset ;

  {
#line 279
  if (! ((unsigned long )img != (unsigned long )((void *)0))) {
    {
#line 279
    __assert_fail("img != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  279U, "dmtxImageGetPixelValue");
    }
  }
#line 280
  if (! (channel < img->channelCount)) {
    {
#line 280
    __assert_fail("channel < img->channelCount", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  280U, "dmtxImageGetPixelValue");
    }
  }
  {
#line 282
  offset = dmtxImageGetByteOffset(img, x, y);
  }
#line 283
  if (offset == -1) {
#line 284
    return (0U);
  }
  {
#line 287
  if (img->bitsPerChannel[channel] == 1) {
#line 287
    goto case_1;
  }
#line 292
  if (img->bitsPerChannel[channel] == 5) {
#line 292
    goto case_5;
  }
#line 301
  if (img->bitsPerChannel[channel] == 8) {
#line 301
    goto case_8;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 291
  goto switch_break;
  case_5: /* CIL Label */ 
#line 300
  goto switch_break;
  case_8: /* CIL Label */ 
#line 302
  if (! (img->channelStart[channel] % 8 == 0)) {
    {
#line 302
    __assert_fail("img->channelStart[channel] % 8 == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  302U, "dmtxImageGetPixelValue");
    }
  }
#line 303
  if (! (img->bitsPerPixel % 8 == 0)) {
    {
#line 303
    __assert_fail("img->bitsPerPixel % 8 == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  303U, "dmtxImageGetPixelValue");
    }
  }
#line 304
  *value = (int )*(img->pxl + (offset + channel));
#line 305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 308
  return (1U);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageSetPixelValue(DmtxImage *img , int x , int y , int channel ,
                                           int value ) 
{ 
  int offset ;

  {
#line 324
  if (! ((unsigned long )img != (unsigned long )((void *)0))) {
    {
#line 324
    __assert_fail("img != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  324U, "dmtxImageSetPixelValue");
    }
  }
#line 325
  if (! (channel < img->channelCount)) {
    {
#line 325
    __assert_fail("channel < img->channelCount", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  325U, "dmtxImageSetPixelValue");
    }
  }
  {
#line 327
  offset = dmtxImageGetByteOffset(img, x, y);
  }
#line 328
  if (offset == -1) {
#line 329
    return (0U);
  }
  {
#line 332
  if (img->bitsPerChannel[channel] == 1) {
#line 332
    goto case_1;
  }
#line 337
  if (img->bitsPerChannel[channel] == 5) {
#line 337
    goto case_5;
  }
#line 346
  if (img->bitsPerChannel[channel] == 8) {
#line 346
    goto case_8;
  }
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 336
  goto switch_break;
  case_5: /* CIL Label */ 
#line 345
  goto switch_break;
  case_8: /* CIL Label */ 
#line 347
  if (! (img->channelStart[channel] % 8 == 0)) {
    {
#line 347
    __assert_fail("img->channelStart[channel] % 8 == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  347U, "dmtxImageSetPixelValue");
    }
  }
#line 348
  if (! (img->bitsPerPixel % 8 == 0)) {
    {
#line 348
    __assert_fail("img->bitsPerPixel % 8 == 0", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  348U, "dmtxImageSetPixelValue");
    }
  }
#line 349
  *(img->pxl + (offset + channel)) = (unsigned char )value;
#line 350
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 353
  return (1U);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageContainsInt(DmtxImage *img , int margin , int x , int y ) 
{ 


  {
#line 367
  if (! ((unsigned long )img != (unsigned long )((void *)0))) {
    {
#line 367
    __assert_fail("img != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  367U, "dmtxImageContainsInt");
    }
  }
#line 369
  if (x - margin >= 0) {
#line 369
    if (x + margin < img->width) {
#line 369
      if (y - margin >= 0) {
#line 369
        if (y + margin < img->height) {
#line 371
          return (1U);
        }
      }
    }
  }
#line 373
  return (0U);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
extern unsigned int dmtxImageContainsFloat(DmtxImage *img , double x , double y ) 
{ 


  {
#line 386
  if (! ((unsigned long )img != (unsigned long )((void *)0))) {
    {
#line 386
    __assert_fail("img != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c",
                  386U, "dmtxImageContainsFloat");
    }
  }
#line 388
  if (x >= 0.0) {
#line 388
    if (x < (double )img->width) {
#line 388
      if (y >= 0.0) {
#line 388
        if (y < (double )img->height) {
#line 389
          return (1U);
        }
      }
    }
  }
#line 391
  return (0U);
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtximage.c"
static int GetBitsPerPixel(int pack ) 
{ 


  {
  {
#line 402
  if (pack == 200) {
#line 402
    goto case_200;
  }
#line 404
  if (pack == 300) {
#line 404
    goto case_300;
  }
#line 412
  if (pack == 406) {
#line 412
    goto case_406;
  }
#line 412
  if (pack == 405) {
#line 412
    goto case_406;
  }
#line 412
  if (pack == 404) {
#line 412
    goto case_406;
  }
#line 412
  if (pack == 403) {
#line 412
    goto case_406;
  }
#line 412
  if (pack == 402) {
#line 412
    goto case_406;
  }
#line 412
  if (pack == 401) {
#line 412
    goto case_406;
  }
#line 412
  if (pack == 400) {
#line 412
    goto case_406;
  }
#line 416
  if (pack == 502) {
#line 416
    goto case_502;
  }
#line 416
  if (pack == 501) {
#line 416
    goto case_502;
  }
#line 416
  if (pack == 500) {
#line 416
    goto case_502;
  }
#line 422
  if (pack == 604) {
#line 422
    goto case_604;
  }
#line 422
  if (pack == 603) {
#line 422
    goto case_604;
  }
#line 422
  if (pack == 602) {
#line 422
    goto case_604;
  }
#line 422
  if (pack == 601) {
#line 422
    goto case_604;
  }
#line 422
  if (pack == 600) {
#line 422
    goto case_604;
  }
#line 424
  goto switch_default;
  case_200: /* CIL Label */ 
#line 403
  return (1);
  case_300: /* CIL Label */ 
#line 405
  return (8);
  case_406: /* CIL Label */ 
  case_405: /* CIL Label */ 
  case_404: /* CIL Label */ 
  case_403: /* CIL Label */ 
  case_402: /* CIL Label */ 
  case_401: /* CIL Label */ 
  case_400: /* CIL Label */ 
#line 413
  return (16);
  case_502: /* CIL Label */ 
  case_501: /* CIL Label */ 
  case_500: /* CIL Label */ 
#line 417
  return (24);
  case_604: /* CIL Label */ 
  case_603: /* CIL Label */ 
  case_602: /* CIL Label */ 
  case_601: /* CIL Label */ 
  case_600: /* CIL Label */ 
#line 423
  return (32);
  switch_default: /* CIL Label */ 
#line 425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 428
  return (-1);
}
}
#line 17 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern DmtxByteList dmtxByteListBuild(DmtxByte *storage , int capacity ) 
{ 
  DmtxByteList list ;

  {
#line 22
  list.b = storage;
#line 23
  list.capacity = capacity;
#line 24
  list.length = 0;
#line 26
  return (list);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern void dmtxByteListInit(DmtxByteList *list , int length , DmtxByte value , unsigned int *passFail ) 
{ 


  {
#line 36
  if (length > list->capacity) {
#line 38
    *passFail = 0U;
  } else {
    {
#line 42
    list->length = length;
#line 43
    memset((void *)list->b, (int )value, sizeof(DmtxByte ) * (unsigned long )list->capacity);
#line 44
    *passFail = 1U;
    }
  }
#line 46
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern void dmtxByteListClear(DmtxByteList *list ) 
{ 


  {
  {
#line 55
  memset((void *)list->b, 0, sizeof(DmtxByte ) * (unsigned long )list->capacity);
#line 56
  list->length = 0;
  }
#line 57
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern unsigned int dmtxByteListHasCapacity(DmtxByteList *list ) 
{ 
  int tmp ;

  {
#line 66
  if (list->length < list->capacity) {
#line 66
    tmp = 1;
  } else {
#line 66
    tmp = 0;
  }
#line 66
  return ((unsigned int )tmp);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern void dmtxByteListCopy(DmtxByteList *dst , DmtxByteList const   *src , unsigned int *passFail ) 
{ 
  int length ;

  {
#line 78
  if (dst->capacity < (int )src->length) {
#line 80
    *passFail = 0U;
  } else {
#line 85
    if (dst->capacity < (int )src->capacity) {
#line 85
      length = dst->capacity;
    } else {
#line 85
      length = (int )src->capacity;
    }
    {
#line 87
    dst->length = (int )src->length;
#line 88
    memcpy((void */* __restrict  */)dst->b, (void const   */* __restrict  */)src->b,
           sizeof(unsigned char ) * (unsigned long )length);
#line 89
    *passFail = 1U;
    }
  }
#line 91
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern void dmtxByteListPush(DmtxByteList *list , DmtxByte value , unsigned int *passFail ) 
{ 
  int tmp ;

  {
#line 100
  if (list->length >= list->capacity) {
#line 102
    *passFail = 0U;
  } else {
#line 106
    tmp = list->length;
#line 106
    (list->length) ++;
#line 106
    *(list->b + tmp) = value;
#line 107
    *passFail = 1U;
  }
#line 109
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern DmtxByte dmtxByteListPop(DmtxByteList *list , unsigned int *passFail ) 
{ 


  {
#line 118
  if (list->length > 0) {
#line 118
    *passFail = 1U;
  } else {
#line 118
    *passFail = 0U;
  }
#line 120
  (list->length) --;
#line 120
  return (*(list->b + list->length));
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxbytelist.c"
extern void dmtxByteListPrint(DmtxByteList *list , char *prefix ) 
{ 
  int i ;

  {
#line 132
  if ((unsigned long )prefix != (unsigned long )((void *)0)) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
            prefix);
    }
  }
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < list->length)) {
#line 135
      goto while_break;
    }
    {
#line 136
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" %d",
            (int )*(list->b + i));
#line 135
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  fputc('\n', stdout);
  }
#line 139
  return;
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxtime.c"
extern DmtxTime dmtxTimeNow(void) 
{ 
  unsigned int err ;
  struct timeval tv ;
  DmtxTime tNow ;
  int tmp ;

  {
  {
#line 33
  tmp = gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 33
  err = (unsigned int )tmp;
#line 37
  tNow.sec = tv.tv_sec;
#line 38
  tNow.usec = (unsigned long )tv.tv_usec;
  }
#line 40
  return (tNow);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxtime.c"
extern DmtxTime dmtxTimeAdd(DmtxTime t , long msec ) 
{ 
  int usec ;

  {
#line 110
  usec = (int )(msec * 1000L);
#line 113
  if (usec > 0) {
#line 113
    if (usec < 1) {
#line 114
      usec = 1;
    }
  }
#line 117
  t.sec += (time_t )(usec / 1000000);
#line 118
  t.usec += (unsigned long )(usec % 1000000);
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (t.usec >= 1000000UL)) {
#line 121
      goto while_break;
    }
#line 122
    (t.sec) ++;
#line 123
    t.usec -= 1000000UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (t);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxtime.c"
extern int dmtxTimeExceeded(DmtxTime timeout ) 
{ 
  DmtxTime now ;
  int tmp ;

  {
  {
#line 139
  now = dmtxTimeNow();
  }
#line 141
  if (now.sec > timeout.sec) {
#line 141
    tmp = 1;
  } else
#line 141
  if (now.sec == timeout.sec) {
#line 141
    if (now.usec > timeout.usec) {
#line 141
      tmp = 1;
    } else {
#line 141
      tmp = 0;
    }
  } else {
#line 141
    tmp = 0;
  }
#line 141
  return (tmp);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern DmtxVector2 *dmtxVector2AddTo(DmtxVector2 *v1 , DmtxVector2 const   *v2 ) 
{ 


  {
#line 21
  v1->X += (double )v2->X;
#line 22
  v1->Y += (double )v2->Y;
#line 24
  return (v1);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern DmtxVector2 *dmtxVector2Add(DmtxVector2 *vOut , DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) 
{ 
  DmtxVector2 *tmp ;

  {
  {
#line 34
  *vOut = (DmtxVector2 )*v1;
#line 36
  tmp = dmtxVector2AddTo(vOut, v2);
  }
#line 36
  return (tmp);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern DmtxVector2 *dmtxVector2SubFrom(DmtxVector2 *v1 , DmtxVector2 const   *v2 ) 
{ 


  {
#line 46
  v1->X -= (double )v2->X;
#line 47
  v1->Y -= (double )v2->Y;
#line 49
  return (v1);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern DmtxVector2 *dmtxVector2Sub(DmtxVector2 *vOut , DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) 
{ 
  DmtxVector2 *tmp ;

  {
  {
#line 59
  *vOut = (DmtxVector2 )*v1;
#line 61
  tmp = dmtxVector2SubFrom(vOut, v2);
  }
#line 61
  return (tmp);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern DmtxVector2 *dmtxVector2ScaleBy(DmtxVector2 *v , double s ) 
{ 


  {
#line 71
  v->X *= s;
#line 72
  v->Y *= s;
#line 74
  return (v);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern DmtxVector2 *dmtxVector2Scale(DmtxVector2 *vOut , DmtxVector2 const   *v ,
                                     double s ) 
{ 
  DmtxVector2 *tmp ;

  {
  {
#line 84
  *vOut = (DmtxVector2 )*v;
#line 86
  tmp = dmtxVector2ScaleBy(vOut, s);
  }
#line 86
  return (tmp);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern double dmtxVector2Cross(DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) 
{ 


  {
#line 96
  return ((double )(v1->X * v2->Y - v1->Y * v2->X));
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern double dmtxVector2Norm(DmtxVector2 *v ) 
{ 
  double mag ;

  {
  {
#line 108
  mag = dmtxVector2Mag((DmtxVector2 const   *)v);
  }
#line 110
  if (mag <= 0.000001) {
#line 111
    return (- 1.0);
  }
  {
#line 113
  dmtxVector2ScaleBy(v, (double )1 / mag);
  }
#line 115
  return (mag);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern double dmtxVector2Dot(DmtxVector2 const   *v1 , DmtxVector2 const   *v2 ) 
{ 


  {
#line 125
  return ((double )(v1->X * v2->X + v1->Y * v2->Y));
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern double dmtxVector2Mag(DmtxVector2 const   *v ) 
{ 
  double tmp ;

  {
  {
#line 135
  tmp = sqrt((double )(v->X * v->X + v->Y * v->Y));
  }
#line 135
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern double dmtxDistanceFromRay2(DmtxRay2 const   *r , DmtxVector2 const   *q ) 
{ 
  DmtxVector2 vSubTmp ;
  double tmp ;
  double tmp___0 ;
  DmtxVector2 *tmp___1 ;
  double tmp___2 ;

  {
  {
#line 148
  tmp = dmtxVector2Mag(& r->v);
#line 148
  tmp___0 = fabs(1.0 - tmp);
  }
#line 148
  if (! (tmp___0 <= 0.000001)) {
    {
#line 148
    __assert_fail("fabs(1.0 - dmtxVector2Mag(&(r->v))) <= 0.000001", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c",
                  148U, "dmtxDistanceFromRay2");
    }
  }
  {
#line 150
  tmp___1 = dmtxVector2Sub(& vSubTmp, q, & r->p);
#line 150
  tmp___2 = dmtxVector2Cross(& r->v, (DmtxVector2 const   *)tmp___1);
  }
#line 150
  return (tmp___2);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern double dmtxDistanceAlongRay2(DmtxRay2 const   *r , DmtxVector2 const   *q ) 
{ 
  DmtxVector2 vSubTmp ;
  DmtxVector2 *tmp ;
  double tmp___0 ;

  {
  {
#line 169
  tmp = dmtxVector2Sub(& vSubTmp, q, & r->p);
#line 169
  tmp___0 = dmtxVector2Dot((DmtxVector2 const   *)tmp, & r->v);
  }
#line 169
  return (tmp___0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern unsigned int dmtxRay2Intersect(DmtxVector2 *point , DmtxRay2 const   *p0 ,
                                      DmtxRay2 const   *p1 ) 
{ 
  double numer ;
  double denom ;
  DmtxVector2 w ;
  double tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 182
  denom = dmtxVector2Cross(& p1->v, & p0->v);
#line 183
  tmp = fabs(denom);
  }
#line 183
  if (tmp <= 0.000001) {
#line 184
    return (0U);
  }
  {
#line 186
  dmtxVector2Sub(& w, & p1->p, & p0->p);
#line 187
  numer = dmtxVector2Cross(& p1->v, (DmtxVector2 const   *)(& w));
#line 189
  tmp___0 = dmtxPointAlongRay2(point, p0, numer / denom);
  }
#line 189
  return (tmp___0);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c"
extern unsigned int dmtxPointAlongRay2(DmtxVector2 *point , DmtxRay2 const   *r ,
                                       double t ) 
{ 
  DmtxVector2 vTmp ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 202
  tmp = dmtxVector2Mag(& r->v);
#line 202
  tmp___0 = fabs(1.0 - tmp);
  }
#line 202
  if (! (tmp___0 <= 0.000001)) {
    {
#line 202
    __assert_fail("fabs(1.0 - dmtxVector2Mag(&(r->v))) <= 0.000001", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxvector2.c",
                  202U, "dmtxPointAlongRay2");
    }
  }
  {
#line 204
  dmtxVector2Scale(& vTmp, & r->v, t);
#line 205
  dmtxVector2Add(point, & r->p, (DmtxVector2 const   *)(& vTmp));
  }
#line 207
  return (1U);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Copy(double (*m0)[3] , double (*m1)[3] ) 
{ 


  {
  {
#line 23
  memcpy((void */* __restrict  */)m0, (void const   */* __restrict  */)m1, sizeof(DmtxMatrix3 ));
  }
#line 24
  return;
}
}
#line 48
extern void dmtxMatrix3Identity(double (*m)[3] ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
static double tmp[3][3]  = { {        (double )1,        (double )0,        (double )0}, 
   {        (double )0,        (double )1,        (double )0}, 
   {        (double )0,        (double )0,        (double )1}};
#line 45 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Identity(double (*m)[3] ) 
{ 


  {
  {
#line 51
  dmtxMatrix3Copy(m, (double (*)[3])(tmp));
  }
#line 52
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
void dmtxMatrix3Translate(double (*m)[3] , double tx , double ty ) 
{ 


  {
  {
#line 77
  dmtxMatrix3Identity(m);
#line 78
  (*(m + 2))[0] = tx;
#line 79
  (*(m + 2))[1] = ty;
  }
#line 80
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Rotate(double (*m)[3] , double angle ) 
{ 
  double sinAngle ;
  double cosAngle ;

  {
  {
#line 106
  sinAngle = sin(angle);
#line 107
  cosAngle = cos(angle);
#line 109
  dmtxMatrix3Identity(m);
#line 110
  (*(m + 0))[0] = cosAngle;
#line 111
  (*(m + 0))[1] = sinAngle;
#line 112
  (*(m + 1))[0] = - sinAngle;
#line 113
  (*(m + 1))[1] = cosAngle;
  }
#line 114
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Scale(double (*m)[3] , double sx , double sy ) 
{ 


  {
  {
#line 140
  dmtxMatrix3Identity(m);
#line 141
  (*(m + 0))[0] = sx;
#line 142
  (*(m + 1))[1] = sy;
  }
#line 143
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Shear(double (*m)[3] , double shx , double shy ) 
{ 


  {
  {
#line 159
  dmtxMatrix3Identity(m);
#line 160
  (*(m + 1))[0] = shx;
#line 161
  (*(m + 0))[1] = shy;
  }
#line 162
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3LineSkewTop(double (*m)[3] , double b0 , double b1 , double sz ) 
{ 


  {
#line 193
  if (! (b0 >= 0.000001)) {
    {
#line 193
    __assert_fail("b0 >= 0.000001", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c",
                  193U, "dmtxMatrix3LineSkewTop");
    }
  }
  {
#line 195
  dmtxMatrix3Identity(m);
#line 196
  (*(m + 0))[0] = b1 / b0;
#line 197
  (*(m + 1))[1] = sz / b0;
#line 198
  (*(m + 0))[2] = (b1 - b0) / (sz * b0);
  }
#line 199
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3LineSkewTopInv(double (*m)[3] , double b0 , double b1 , double sz ) 
{ 


  {
#line 212
  if (! (b1 >= 0.000001)) {
    {
#line 212
    __assert_fail("b1 >= 0.000001", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c",
                  212U, "dmtxMatrix3LineSkewTopInv");
    }
  }
  {
#line 214
  dmtxMatrix3Identity(m);
#line 215
  (*(m + 0))[0] = b0 / b1;
#line 216
  (*(m + 1))[1] = b0 / sz;
#line 217
  (*(m + 0))[2] = (b0 - b1) / (sz * b1);
  }
#line 218
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3LineSkewSide(double (*m)[3] , double b0 , double b1 , double sz ) 
{ 


  {
#line 231
  if (! (b0 >= 0.000001)) {
    {
#line 231
    __assert_fail("b0 >= 0.000001", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c",
                  231U, "dmtxMatrix3LineSkewSide");
    }
  }
  {
#line 233
  dmtxMatrix3Identity(m);
#line 234
  (*(m + 0))[0] = sz / b0;
#line 235
  (*(m + 1))[1] = b1 / b0;
#line 236
  (*(m + 1))[2] = (b1 - b0) / (sz * b0);
  }
#line 237
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3LineSkewSideInv(double (*m)[3] , double b0 , double b1 , double sz ) 
{ 


  {
#line 250
  if (! (b1 >= 0.000001)) {
    {
#line 250
    __assert_fail("b1 >= 0.000001", "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c",
                  250U, "dmtxMatrix3LineSkewSideInv");
    }
  }
  {
#line 252
  dmtxMatrix3Identity(m);
#line 253
  (*(m + 0))[0] = b0 / sz;
#line 254
  (*(m + 1))[1] = b0 / b1;
#line 255
  (*(m + 1))[2] = (b0 - b1) / (sz * b1);
  }
#line 256
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Multiply(double (*mOut)[3] , double (*m0)[3] , double (*m1)[3] ) 
{ 
  int i ;
  int j ;
  int k ;
  double val ;

  {
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < 3)) {
#line 271
      goto while_break;
    }
#line 272
    j = 0;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      if (! (j < 3)) {
#line 272
        goto while_break___0;
      }
#line 273
      val = 0.0;
#line 274
      k = 0;
      {
#line 274
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 274
        if (! (k < 3)) {
#line 274
          goto while_break___1;
        }
#line 275
        val += (*(m0 + i))[k] * (*(m1 + k))[j];
#line 274
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 277
      (*(mOut + i))[j] = val;
#line 272
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 271
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3MultiplyBy(double (*m0)[3] , double (*m1)[3] ) 
{ 
  DmtxMatrix3 mTmp ;

  {
  {
#line 293
  dmtxMatrix3Copy((double (*)[3])(mTmp), m0);
#line 294
  dmtxMatrix3Multiply(m0, (double (*)[3])(mTmp), m1);
  }
#line 295
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern int dmtxMatrix3VMultiply(DmtxVector2 *vOut , DmtxVector2 *vIn , double (*m)[3] ) 
{ 
  double w ;
  double tmp___0 ;

  {
  {
#line 309
  w = (vIn->X * (*(m + 0))[2] + vIn->Y * (*(m + 1))[2]) + (*(m + 2))[2];
#line 310
  tmp___0 = fabs(w);
  }
#line 310
  if (tmp___0 <= 0.000001) {
#line 311
    vOut->X = (double )3.40282346638528859812e+38F;
#line 312
    vOut->Y = (double )3.40282346638528859812e+38F;
#line 313
    return (0);
  }
#line 316
  vOut->X = ((vIn->X * (*(m + 0))[0] + vIn->Y * (*(m + 1))[0]) + (*(m + 2))[0]) / w;
#line 317
  vOut->Y = ((vIn->X * (*(m + 0))[1] + vIn->Y * (*(m + 1))[1]) + (*(m + 2))[1]) / w;
#line 319
  return (1);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern int dmtxMatrix3VMultiplyBy(DmtxVector2 *v , double (*m)[3] ) 
{ 
  int success ;
  DmtxVector2 vOut ;

  {
  {
#line 334
  success = dmtxMatrix3VMultiply(& vOut, v, m);
#line 335
  *v = vOut;
  }
#line 337
  return (success);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtxmatrix3.c"
extern void dmtxMatrix3Print(double (*m)[3] ) 
{ 


  {
  {
#line 348
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%8.8f\t%8.8f\t%8.8f\n",
          (*(m + 0))[0], (*(m + 0))[1], (*(m + 0))[2]);
#line 349
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%8.8f\t%8.8f\t%8.8f\n",
          (*(m + 1))[0], (*(m + 1))[1], (*(m + 1))[2]);
#line 350
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%8.8f\t%8.8f\t%8.8f\n",
          (*(m + 2))[0], (*(m + 2))[1], (*(m + 2))[2]);
#line 351
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
  }
#line 352
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libdmtx-0.7.4/dmtx.c"
extern char *dmtxVersion(void) 
{ 


  {
#line 87
  return ((char *)"0.7.4");
}
}
