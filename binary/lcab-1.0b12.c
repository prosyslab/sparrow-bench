/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 33 "/home/wheatley/newnew/temp/lcab-1.0b12/mytypes.h"
typedef unsigned short word;
#line 34 "/home/wheatley/newnew/temp/lcab-1.0b12/mytypes.h"
typedef unsigned long dword;
#line 59 "/home/wheatley/newnew/temp/lcab-1.0b12/cstruct.h"
struct cdata {
   dword checksum ;
   word ncbytes ;
   word nubytes ;
};
#line 32 "/home/wheatley/newnew/temp/lcab-1.0b12/mytypes.h"
typedef unsigned char byte;
#line 35 "/home/wheatley/newnew/temp/lcab-1.0b12/mytypes.h"
typedef unsigned long CHECKSUM;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 24 "/home/wheatley/newnew/temp/lcab-1.0b12/cstruct.h"
struct cheader {
   byte sig[4] ;
   dword res1 ;
   dword size ;
   dword res2 ;
   dword offsetfiles ;
   dword res3 ;
   byte versionMIN ;
   byte versionMAJ ;
   word nfolders ;
   word nfiles ;
   word flags ;
   word setID ;
   word cabID ;
};
#line 41 "/home/wheatley/newnew/temp/lcab-1.0b12/cstruct.h"
struct cfolder {
   dword offsetdata ;
   word ndatab ;
   word typecomp ;
};
#line 48 "/home/wheatley/newnew/temp/lcab-1.0b12/cstruct.h"
struct cfile {
   dword usize ;
   dword uoffset ;
   word index ;
   word date ;
   word time ;
   word fattr ;
   byte name[4096] ;
};
#line 26 "/home/wheatley/newnew/temp/lcab-1.0b12/cdata.h"
struct mydatablock {
   struct cdata cd ;
   struct mydatablock *next ;
};
#line 27 "/home/wheatley/newnew/temp/lcab-1.0b12/cfile.h"
struct mycfile {
   struct cfile cf ;
   struct mycfile *next ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 32 "/home/wheatley/newnew/temp/lcab-1.0b12/cdata.h"
void cdata_init(struct cdata *cd , int checksum ) ;
#line 34
void cdata_ncbytes(struct cdata *cd , int ncb ) ;
#line 36
void cdata_nubytes(struct cdata *cd , int nub ) ;
#line 22 "/home/wheatley/newnew/temp/lcab-1.0b12/cdata.c"
void cdata_init(struct cdata *cd , int checksum ) 
{ 


  {
#line 24
  cd->checksum = (dword )checksum;
#line 25
  return;
}
}
#line 28 "/home/wheatley/newnew/temp/lcab-1.0b12/cdata.c"
void cdata_ncbytes(struct cdata *cd , int ncb ) 
{ 


  {
#line 30
  cd->ncbytes = (word )ncb;
#line 31
  return;
}
}
#line 34 "/home/wheatley/newnew/temp/lcab-1.0b12/cdata.c"
void cdata_nubytes(struct cdata *cd , int nub ) 
{ 


  {
#line 36
  cd->nubytes = (word )nub;
#line 37
  return;
}
}
#line 24 "/home/wheatley/newnew/temp/lcab-1.0b12/checksum.h"
CHECKSUM compute_checksum(byte *in , word ncbytes , CHECKSUM seed ) ;
#line 20 "/home/wheatley/newnew/temp/lcab-1.0b12/checksum.c"
CHECKSUM compute_checksum(byte *in , word ncbytes , CHECKSUM seed ) 
{ 
  int no_ulongs ;
  CHECKSUM csum ;
  byte *stroom ;
  CHECKSUM temp ;
  byte *tmp ;
  byte *tmp___0 ;
  byte *tmp___1 ;
  byte *tmp___2 ;
  int tmp___3 ;
  byte *tmp___4 ;
  byte *tmp___5 ;
  byte *tmp___6 ;

  {
#line 23
  csum = (CHECKSUM )0;
#line 27
  no_ulongs = (int )ncbytes / 4;
#line 28
  csum = seed;
#line 29
  stroom = in;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    tmp___3 = no_ulongs;
#line 31
    no_ulongs --;
#line 31
    if (! (tmp___3 > 0)) {
#line 31
      goto while_break;
    }
#line 33
    tmp = stroom;
#line 33
    stroom ++;
#line 33
    temp = (CHECKSUM )*tmp;
#line 34
    tmp___0 = stroom;
#line 34
    stroom ++;
#line 34
    temp |= (CHECKSUM )*tmp___0 << 8;
#line 35
    tmp___1 = stroom;
#line 35
    stroom ++;
#line 35
    temp |= (CHECKSUM )*tmp___1 << 16;
#line 36
    tmp___2 = stroom;
#line 36
    stroom ++;
#line 36
    temp |= (CHECKSUM )*tmp___2 << 24;
#line 38
    csum ^= temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  temp = (CHECKSUM )0;
  {
#line 44
  if ((int )ncbytes % 4 == 3) {
#line 44
    goto case_3;
  }
#line 45
  if ((int )ncbytes % 4 == 2) {
#line 45
    goto case_2;
  }
#line 46
  if ((int )ncbytes % 4 == 1) {
#line 46
    goto case_1;
  }
#line 47
  goto switch_default;
  case_3: /* CIL Label */ 
#line 44
  tmp___4 = stroom;
#line 44
  stroom ++;
#line 44
  temp |= (CHECKSUM )*tmp___4 << 16;
  case_2: /* CIL Label */ 
#line 45
  tmp___5 = stroom;
#line 45
  stroom ++;
#line 45
  temp |= (CHECKSUM )*tmp___5 << 8;
  case_1: /* CIL Label */ 
#line 46
  tmp___6 = stroom;
#line 46
  stroom ++;
#line 46
  temp |= (CHECKSUM )*tmp___6;
  switch_default: /* CIL Label */ 
#line 47
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 50
  csum ^= temp;
#line 52
  return (csum);
}
}
#line 178 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 2 "/home/wheatley/newnew/temp/lcab-1.0b12/warn.h"
extern void warn(char const   *fmt  , ...) ;
#line 27 "/home/wheatley/newnew/temp/lcab-1.0b12/cheader.h"
void cheader_init(struct cheader *ch , char *sign , int nfolders , int nfiles , int flags ,
                  int setID , int cabID ) ;
#line 32
void cheader_size(struct cheader *ch , int size ) ;
#line 34
void cheader_offsetfiles(struct cheader *ch , int offset ) ;
#line 27 "/home/wheatley/newnew/temp/lcab-1.0b12/cfolder.h"
void cfolder_init(struct cfolder *cf , int nod , int type ) ;
#line 29
void cfolder_offsetdata(struct cfolder *cf , int offset ) ;
#line 33 "/home/wheatley/newnew/temp/lcab-1.0b12/cfile.h"
void cfile_init(struct cfile *cf , int usize , int index___0 , char *filename , char *origFilename ) ;
#line 35
void cfile_uoffset(struct cfile *cf , int offset ) ;
#line 28 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.h"
int cheaderwrite(struct cheader *ch , FILE *fpout ) ;
#line 29
int cfolderwrite(struct cfolder *cf , FILE *fpout ) ;
#line 32
int cfilewrite(struct cfile *cf , FILE *fpout ) ;
#line 36
long cdatawrite(struct cdata *cd , FILE *fpout , long pos , FILE *fptemp ) ;
#line 36 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
long sizefile(char *filename ) ;
#line 37
int number_of_datablocks(int nof ) ;
#line 38
char *strippath(char *filename ) ;
#line 39
char *changepath(char *filename ) ;
#line 40
int maketempfile(int nof , FILE *fp ) ;
#line 41
int recurse_directory(char const   *file , int *n ) ;
#line 43 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
char *inputfiles[1024]  ;
#line 44 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
char *outputfile  ;
#line 52 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
long sizefile(char *filename ) 
{ 
  long size ;
  FILE *fp ;
  FILE *tmp ;
  int tmp___0 ;

  {
  {
#line 54
  size = 0L;
#line 55
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
#line 55
  fp = tmp;
  }
#line 56
  if (! fp) {
    {
#line 58
    printf((char const   */* __restrict  */)"Error: could not open %s\n", filename);
#line 59
    exit(1);
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    tmp___0 = fgetc(fp);
    }
#line 61
    if (! (tmp___0 != -1)) {
#line 61
      goto while_break;
    }
#line 63
    size ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  fclose(fp);
  }
#line 66
  return (size);
}
}
#line 71 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
int number_of_datablocks(int nof ) 
{ 
  int i ;
  int size ;
  long tmp ;

  {
#line 73
  size = 0;
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < nof)) {
#line 74
      goto while_break;
    }
    {
#line 76
    tmp = sizefile(inputfiles[i]);
#line 76
    size = (int )((long )size + tmp);
#line 74
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (size / 32768 + 1);
}
}
#line 82 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
char *strippath(char *filename ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 85
  tmp = strrchr((char const   *)filename, '/');
  }
#line 85
  if (tmp) {
#line 86
    tmp___0 = tmp;
#line 86
    tmp ++;
  } else {
#line 85
    tmp = filename;
  }
#line 87
  return (tmp);
}
}
#line 91 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
char *changepath(char *filename ) 
{ 
  char *tmp ;
  int i ;
  int j ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 94
  i = 0;
#line 95
  j = 0;
#line 97
  tmp___0 = strlen((char const   *)filename);
#line 97
  tmp___1 = calloc(tmp___0 + 1UL, sizeof(char ));
#line 97
  tmp = (char *)tmp___1;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp___2 = strlen((char const   *)filename);
    }
#line 98
    if (! ((size_t )i < tmp___2)) {
#line 98
      goto while_break;
    }
#line 100
    if ((int )*(filename + i) != 47) {
#line 100
      *(tmp + j) = *(filename + i);
    } else {
#line 101
      *(tmp + j) = (char )'\\';
    }
#line 102
    j ++;
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  *(tmp + j) = (char )'\000';
#line 105
  return (tmp);
}
}
#line 109 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
int maketempfile(int nof , FILE *fp ) 
{ 
  int i ;
  FILE *fp2 ;
  char *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 115
  i = 0;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < nof)) {
#line 115
      goto while_break;
    }
    {
#line 117
    fp2 = fopen((char const   */* __restrict  */)inputfiles[i], (char const   */* __restrict  */)"rb");
    }
#line 118
    if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
      {
#line 118
      printf((char const   */* __restrict  */)"error: could not open %s\n", inputfiles[i]);
      }
#line 118
      return (0);
    } else {
      {
#line 121
      tmp___0 = sizefile(inputfiles[i]);
#line 121
      tmp___1 = calloc((size_t )tmp___0, sizeof(byte ));
#line 121
      tmp = (char *)((byte *)tmp___1);
#line 122
      tmp___2 = sizefile(inputfiles[i]);
#line 122
      fread((void */* __restrict  */)tmp, (size_t )tmp___2, (size_t )1, (FILE */* __restrict  */)fp2);
#line 123
      tmp___3 = sizefile(inputfiles[i]);
#line 123
      fwrite((void const   */* __restrict  */)((byte *)tmp), (size_t )tmp___3, (size_t )1,
             (FILE */* __restrict  */)fp);
#line 124
      free((void *)tmp);
#line 125
      fclose(fp2);
      }
    }
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return (1);
}
}
#line 133 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
void usage(char **argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 135
  tmp = strippath(*(argv + 0));
#line 135
  printf((char const   */* __restrict  */)"usage: %s [options] inputfiles outputfile.cab\n",
         tmp);
#line 136
  printf((char const   */* __restrict  */)"\nlcab will create a Cabinet File from inputfiles.\n");
#line 137
  printf((char const   */* __restrict  */)"Inputfiles can also be directories together with option -r.\n");
#line 138
  printf((char const   */* __restrict  */)"\nOptions:\n");
#line 139
  printf((char const   */* __restrict  */)"     -r        loop recursive through directories\n");
#line 140
  printf((char const   */* __restrict  */)"     -n        create files without pathnames\n");
#line 141
  printf((char const   */* __restrict  */)"     -q        be quiet!\n");
#line 142
  tmp___0 = strippath(*(argv + 0));
#line 142
  printf((char const   */* __restrict  */)"\n%s v%s (2003) by Rien (rien@geekshop.be)\n",
         tmp___0, "1.0b12");
#line 143
  exit(0);
  }
}
}
#line 147 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
int recurse_directory(char const   *file , int *n ) 
{ 
  DIR *d ;
  struct dirent *dp ;
  int i ;
  struct stat st ;
  char buf[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 151
  i = *n;
#line 153
  d = opendir(file);
  }
#line 153
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 154
    return (1);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    dp = readdir(d);
    }
#line 156
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 156
      goto while_break;
    }
    {
#line 160
    tmp = strcmp((char const   *)(dp->d_name), ".");
    }
#line 160
    if (tmp == 0) {
#line 161
      goto while_continue;
    } else {
      {
#line 160
      tmp___0 = strcmp((char const   *)(dp->d_name), "..");
      }
#line 160
      if (tmp___0 == 0) {
#line 161
        goto while_continue;
      }
    }
    {
#line 163
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s",
             file, dp->d_name);
#line 165
    tmp___1 = stat((char const   */* __restrict  */)(buf), (struct stat */* __restrict  */)(& st));
    }
#line 165
    if (tmp___1 == -1) {
#line 166
      goto while_continue;
    }
#line 168
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 169
      recurse_directory((char const   *)(buf), & i);
      }
#line 170
      goto while_continue;
    }
    {
#line 174
    tmp___2 = realloc((void *)inputfiles[i], (unsigned long )(i + 2) * sizeof(char *));
#line 174
    inputfiles[i] = (char *)tmp___2;
#line 175
    tmp___3 = i;
#line 175
    i ++;
#line 175
    inputfiles[tmp___3] = strdup((char const   *)(buf));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  closedir(d);
#line 179
  *n = i;
  }
#line 180
  return (0);
}
}
#line 188 "/home/wheatley/newnew/temp/lcab-1.0b12/main.c"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  FILE *fptmp ;
  int i ;
  int mysize2 ;
  long mysize ;
  int nof ;
  int nod ;
  int offsetdata ;
  long pos ;
  int opt ;
  int quiet ;
  int makenopath ;
  int recursive ;
  struct cheader mycheader ;
  struct cfolder mycfolder ;
  struct mydatablock *ptrdbs ;
  struct mydatablock *mydatablocks ;
  struct mycfile *ptrcfs ;
  struct mycfile *prevcfile ;
  struct mycfile *mycfiles ;
  char *tmp ;
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  long tmp___14 ;
  void *tmp___15 ;
  long tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
#line 192
  mysize = 0L;
#line 193
  nof = 0;
#line 194
  nod = 0;
#line 195
  offsetdata = 0;
#line 196
  pos = 0L;
#line 198
  quiet = 0;
#line 200
  makenopath = 0;
#line 201
  recursive = 0;
#line 205
  ptrdbs = (struct mydatablock *)((void *)0);
#line 206
  mydatablocks = (struct mydatablock *)((void *)0);
#line 207
  ptrcfs = (struct mycfile *)((void *)0);
#line 208
  prevcfile = (struct mycfile *)((void *)0);
#line 209
  mycfiles = (struct mycfile *)((void *)0);
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    opt = getopt(argc, (char * const  *)argv, "nrhq");
    }
#line 214
    if (! (opt != -1)) {
#line 214
      goto while_break;
    }
    {
#line 216
    if (opt == 113) {
#line 216
      goto case_113;
    }
#line 219
    if (opt == 114) {
#line 219
      goto case_114;
    }
#line 222
    if (opt == 110) {
#line 222
      goto case_110;
    }
#line 226
    goto switch_default;
    case_113: /* CIL Label */ 
#line 217
    quiet = 1;
#line 218
    goto switch_break;
    case_114: /* CIL Label */ 
#line 220
    recursive = 1;
#line 221
    goto switch_break;
    case_110: /* CIL Label */ 
#line 223
    makenopath = 1;
#line 224
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 227
    usage(argv);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (argc - optind < 2) {
    {
#line 232
    usage(argv);
    }
  }
  {
#line 234
  tmp = strippath(*(argv + 0));
#line 234
  printf((char const   */* __restrict  */)"%s v%s (2003) by Rien (rien@geekshop.be)\n",
         tmp, "1.0b12");
#line 237
  nof = ((argc - 2) - makenopath) - recursive;
#line 238
  i = 0;
  }
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if (! (optind < argc - 1)) {
#line 238
      goto while_break___0;
    }
    {
#line 242
    tmp___0 = stat((char const   */* __restrict  */)*(argv + optind), (struct stat */* __restrict  */)(& st));
    }
#line 242
    if (tmp___0 == -1) {
      {
#line 244
      warn("%s", *(argv + optind));
      }
#line 245
      goto __Cont;
    }
    {
#line 249
    tmp___1 = strncmp((char const   *)*(argv + optind), "..", (size_t )2);
    }
#line 249
    if (! tmp___1) {
      {
#line 249
      printf((char const   */* __restrict  */)"##### WARNING : %s has a .. in front of it! #####\n",
             *(argv + optind));
      }
    }
#line 252
    if ((st.st_mode & 61440U) == 16384U) {
#line 252
      if (recursive) {
        {
#line 254
        recurse_directory((char const   *)*(argv + optind), & i);
        }
#line 255
        goto __Cont;
      }
    }
    {
#line 258
    tmp___2 = realloc((void *)inputfiles[i], (unsigned long )(i + 2) * sizeof(char *));
#line 258
    inputfiles[i] = (char *)tmp___2;
#line 259
    tmp___3 = i;
#line 259
    i ++;
#line 259
    inputfiles[tmp___3] = strdup((char const   *)*(argv + optind));
    }
    __Cont: /* CIL Label */ 
#line 238
    optind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 262
  inputfiles[i] = (char *)((void *)0);
#line 265
  nof = i;
#line 269
  nod = number_of_datablocks(nof);
#line 270
  tmp___4 = calloc((size_t )4096, sizeof(char ));
#line 270
  outputfile = (char *)tmp___4;
#line 271
  strcpy((char */* __restrict  */)outputfile, (char const   */* __restrict  */)*(argv + (argc - 1)));
#line 274
  printf((char const   */* __restrict  */)"nopath          : ");
  }
#line 274
  if (makenopath) {
    {
#line 274
    printf((char const   */* __restrict  */)"yes\n");
    }
  } else {
    {
#line 274
    printf((char const   */* __restrict  */)"no\n");
    }
  }
  {
#line 275
  printf((char const   */* __restrict  */)"recursive       : ");
  }
#line 275
  if (recursive) {
    {
#line 275
    printf((char const   */* __restrict  */)"yes\n");
    }
  } else {
    {
#line 275
    printf((char const   */* __restrict  */)"no\n");
    }
  }
  {
#line 276
  printf((char const   */* __restrict  */)"quiet           : ");
  }
#line 276
  if (quiet) {
    {
#line 276
    printf((char const   */* __restrict  */)"yes\n");
    }
  } else {
    {
#line 276
    printf((char const   */* __restrict  */)"no\n");
    }
  }
#line 278
  if (! quiet) {
    {
#line 280
    printf((char const   */* __restrict  */)"inputfiles      : ");
#line 281
    i = 0;
    }
    {
#line 281
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 281
      if (! (i < nof)) {
#line 281
        goto while_break___1;
      }
      {
#line 281
      printf((char const   */* __restrict  */)"%s ", inputfiles[i]);
#line 281
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 282
    printf((char const   */* __restrict  */)"\noutputfile      : %s\n", outputfile);
    }
  }
  {
#line 286
  cheader_init(& mycheader, (char *)"MSCF", 1, nof, 0, 1234, 0);
#line 287
  cheader_offsetfiles(& mycheader, 44);
#line 289
  mysize2 = 44 + nof * 16;
#line 290
  i = 0;
  }
  {
#line 290
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 290
    if (! (i < nof)) {
#line 290
      goto while_break___2;
    }
#line 291
    if (makenopath) {
      {
#line 291
      tmp___5 = strippath(inputfiles[i]);
#line 291
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 291
      tmp___6 = changepath(inputfiles[i]);
#line 291
      tmp___7 = tmp___6;
      }
    }
    {
#line 291
    tmp___8 = strlen((char const   *)tmp___7);
#line 291
    mysize2 = (int )((size_t )mysize2 + (tmp___8 + 1UL));
#line 290
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 292
  mysize2 += nod * 8;
#line 295
  cfolder_init(& mycfolder, nod, 0);
#line 297
  i = 0;
  }
  {
#line 297
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 297
    if (! (i < nof)) {
#line 297
      goto while_break___3;
    }
#line 298
    if (makenopath) {
      {
#line 298
      tmp___9 = strippath(inputfiles[i]);
#line 298
      tmp___11 = tmp___9;
      }
    } else {
      {
#line 298
      tmp___10 = changepath(inputfiles[i]);
#line 298
      tmp___11 = tmp___10;
      }
    }
    {
#line 298
    tmp___12 = strlen((char const   *)tmp___11);
#line 298
    offsetdata = (int )((size_t )offsetdata + ((16UL + tmp___12) + 1UL));
#line 297
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 299
  cfolder_offsetdata(& mycfolder, 44 + offsetdata);
#line 303
  tmp___13 = calloc((size_t )1, sizeof(struct mydatablock ));
#line 303
  mydatablocks = (struct mydatablock *)tmp___13;
#line 304
  mydatablocks->next = (struct mydatablock *)((void *)0);
#line 305
  ptrdbs = mydatablocks;
#line 307
  i = 0;
  }
  {
#line 307
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 307
    if (! (i < nof)) {
#line 307
      goto while_break___4;
    }
    {
#line 308
    tmp___14 = sizefile(inputfiles[i]);
#line 308
    mysize += tmp___14;
#line 307
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 310
  cdata_init(& ptrdbs->cd, 0);
  }
#line 311
  if (mysize < 32768L) {
    {
#line 313
    cdata_ncbytes(& ptrdbs->cd, (int )mysize);
#line 314
    cdata_nubytes(& ptrdbs->cd, (int )mysize);
#line 315
    mysize2 = (int )((long )mysize2 + mysize);
    }
  } else {
#line 319
    i = 0;
    {
#line 319
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 319
      if (! (i < nod)) {
#line 319
        goto while_break___5;
      }
#line 321
      if (i != nod - 1) {
        {
#line 323
        cdata_ncbytes(& ptrdbs->cd, 32768);
#line 324
        cdata_nubytes(& ptrdbs->cd, 32768);
#line 325
        mysize2 += 32768;
#line 327
        tmp___15 = calloc((size_t )1, sizeof(struct mydatablock ));
#line 327
        ptrdbs->next = (struct mydatablock *)tmp___15;
#line 328
        ptrdbs = ptrdbs->next;
#line 329
        ptrdbs->next = (struct mydatablock *)((void *)0);
#line 330
        cdata_init(& ptrdbs->cd, 0);
        }
      } else {
        {
#line 334
        mysize -= (long )(32768 * (nod - 1));
#line 335
        cdata_ncbytes(& ptrdbs->cd, (int )mysize);
#line 336
        cdata_nubytes(& ptrdbs->cd, (int )mysize);
#line 337
        mysize2 = (int )((long )mysize2 + mysize);
        }
      }
#line 319
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 345
  cheader_size(& mycheader, mysize2);
#line 347
  i = 0;
  }
  {
#line 347
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 347
    if (! (i < nof)) {
#line 347
      goto while_break___6;
    }
    {
#line 348
    tmp___16 = sizefile(inputfiles[i]);
#line 348
    mysize += tmp___16;
#line 347
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 349
  if (! quiet) {
    {
#line 349
    printf((char const   */* __restrict  */)"cabfile         : %d bytes (approx. %.2f Kbytes)\n",
           (int )mysize, (double )((float )mysize / (float )1024));
    }
  }
  {
#line 352
  tmp___17 = calloc((size_t )1, sizeof(struct mycfile ));
#line 352
  mycfiles = (struct mycfile *)tmp___17;
#line 353
  mycfiles->next = (struct mycfile *)((void *)0);
#line 354
  ptrcfs = mycfiles;
#line 356
  i = 0;
  }
  {
#line 356
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 356
    if (! (i < nof)) {
#line 356
      goto while_break___7;
    }
#line 358
    if (makenopath) {
      {
#line 358
      tmp___18 = strippath(inputfiles[i]);
#line 358
      tmp___20 = tmp___18;
      }
    } else {
      {
#line 358
      tmp___19 = changepath(inputfiles[i]);
#line 358
      tmp___20 = tmp___19;
      }
    }
    {
#line 358
    tmp___21 = sizefile(inputfiles[i]);
#line 358
    cfile_init(& ptrcfs->cf, (int )tmp___21, 0, tmp___20, inputfiles[i]);
    }
#line 361
    if (i == 0) {
      {
#line 361
      cfile_uoffset(& ptrcfs->cf, 0);
      }
    } else {
      {
#line 364
      tmp___22 = sizefile(inputfiles[i - 1]);
#line 364
      cfile_uoffset(& ptrcfs->cf, (int )(prevcfile->cf.uoffset + (dword )tmp___22));
      }
    }
#line 367
    if (i < nof - 1) {
      {
#line 369
      prevcfile = ptrcfs;
#line 370
      tmp___23 = calloc((size_t )1, sizeof(struct mycfile ));
#line 370
      ptrcfs->next = (struct mycfile *)tmp___23;
#line 371
      prevcfile = ptrcfs;
#line 372
      ptrcfs = ptrcfs->next;
#line 373
      ptrcfs->next = (struct mycfile *)((void *)0);
      }
    }
#line 356
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 378
  fptmp = fopen((char const   */* __restrict  */)"lcab.tmp", (char const   */* __restrict  */)"wb");
  }
#line 379
  if ((unsigned long )fptmp == (unsigned long )((void *)0)) {
    {
#line 379
    printf((char const   */* __restrict  */)"error: could not open lcab.tmp for writing\n");
    }
#line 379
    return (0);
  } else {
    {
#line 382
    tmp___24 = maketempfile(nof, fptmp);
    }
#line 382
    if (tmp___24) {
#line 383
      if (! quiet) {
        {
#line 383
        printf((char const   */* __restrict  */)"tmp,");
        }
      }
    } else {
      {
#line 382
      printf((char const   */* __restrict  */)"error: could not make tempfile");
      }
#line 382
      return (0);
    }
    {
#line 384
    fclose(fptmp);
    }
  }
  {
#line 386
  fp = fopen((char const   */* __restrict  */)outputfile, (char const   */* __restrict  */)"wb");
  }
#line 387
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 387
    printf((char const   */* __restrict  */)"error: could not open %s for writing\n",
           outputfile);
    }
#line 387
    return (0);
  } else {
    {
#line 390
    tmp___25 = cheaderwrite(& mycheader, fp);
    }
#line 390
    if (! tmp___25) {
      {
#line 390
      printf((char const   */* __restrict  */)"error: could not write header\n");
#line 390
      fclose(fp);
      }
#line 390
      return (0);
    }
#line 391
    if (! quiet) {
      {
#line 391
      printf((char const   */* __restrict  */)"header,");
      }
    }
    {
#line 392
    tmp___26 = cfolderwrite(& mycfolder, fp);
    }
#line 392
    if (! tmp___26) {
      {
#line 392
      printf((char const   */* __restrict  */)"error: could not write folder\n");
#line 392
      fclose(fp);
      }
#line 392
      return (0);
    }
#line 393
    if (! quiet) {
      {
#line 393
      printf((char const   */* __restrict  */)"folder,");
      }
    }
    {
#line 395
    ptrcfs = mycfiles;
#line 396
    tmp___27 = cfilewrite(& ptrcfs->cf, fp);
    }
#line 396
    if (! tmp___27) {
      {
#line 396
      printf((char const   */* __restrict  */)"error: could not write header\n");
#line 396
      fclose(fp);
      }
#line 396
      return (0);
    }
#line 397
    if (! quiet) {
      {
#line 397
      printf((char const   */* __restrict  */)".");
      }
    }
    {
#line 398
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 398
      if (! ((unsigned long )ptrcfs->next != (unsigned long )((void *)0))) {
#line 398
        goto while_break___8;
      }
      {
#line 400
      ptrcfs = ptrcfs->next;
#line 401
      tmp___28 = cfilewrite(& ptrcfs->cf, fp);
      }
#line 401
      if (! tmp___28) {
        {
#line 401
        printf((char const   */* __restrict  */)"error: could not write header\n");
#line 401
        fclose(fp);
        }
#line 401
        return (0);
      }
#line 402
      if (! quiet) {
        {
#line 402
        printf((char const   */* __restrict  */)".");
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 406
    fptmp = fopen((char const   */* __restrict  */)"lcab.tmp", (char const   */* __restrict  */)"rb");
    }
#line 407
    if ((unsigned long )fptmp == (unsigned long )((void *)0)) {
      {
#line 407
      printf((char const   */* __restrict  */)"error: could not open lcab.tmp for writing\n");
      }
#line 407
      return (0);
    } else {
      {
#line 410
      ptrdbs = mydatablocks;
#line 411
      pos = cdatawrite(& ptrdbs->cd, fp, pos, fptmp);
      }
#line 412
      if (pos == -1L) {
        {
#line 414
        printf((char const   */* __restrict  */)"error: could not write datablock at pos: %ld\n",
               pos);
#line 415
        fclose(fptmp);
#line 416
        fclose(fp);
#line 417
        tmp___29 = remove("lcab.tmp");
        }
#line 417
        if (tmp___29) {
          {
#line 417
          printf((char const   */* __restrict  */)"could not remove lcab.tmp\n");
          }
        }
      }
      {
#line 419
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 419
        if (! ((unsigned long )ptrdbs->next != (unsigned long )((void *)0))) {
#line 419
          goto while_break___9;
        }
        {
#line 421
        ptrdbs = ptrdbs->next;
#line 422
        pos = cdatawrite(& ptrdbs->cd, fp, pos, fptmp);
        }
#line 423
        if (pos == -1L) {
          {
#line 425
          printf((char const   */* __restrict  */)"error: could not write datablock at pos: %ld\n",
                 pos);
#line 426
          fclose(fptmp);
#line 427
          fclose(fp);
#line 428
          tmp___30 = remove("lcab.tmp");
          }
#line 428
          if (tmp___30) {
            {
#line 428
            printf((char const   */* __restrict  */)"could not remove lcab.tmp\n");
            }
          }
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 432
      fclose(fptmp);
      }
    }
    {
#line 435
    fclose(fp);
    }
  }
#line 438
  if (! quiet) {
    {
#line 438
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 441
  tmp___31 = remove("lcab.tmp");
  }
#line 441
  if (tmp___31) {
    {
#line 441
    printf((char const   */* __restrict  */)"could not remove lcab.tmp\n");
    }
  }
#line 444
  i = 0;
  {
#line 444
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 444
    if (! (i < nof)) {
#line 444
      goto while_break___10;
    }
    {
#line 445
    free((void *)inputfiles[i]);
#line 444
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 446
  free((void *)outputfile);
#line 448
  printf((char const   */* __restrict  */)"done\n");
  }
#line 450
  return (0);
}
}
#line 22 "/home/wheatley/newnew/temp/lcab-1.0b12/cfolder.c"
void cfolder_init(struct cfolder *cf , int nod , int type ) 
{ 


  {
#line 24
  cf->ndatab = (word )nod;
#line 25
  cf->typecomp = (word )type;
#line 26
  return;
}
}
#line 29 "/home/wheatley/newnew/temp/lcab-1.0b12/cfolder.c"
void cfolder_offsetdata(struct cfolder *cf , int offset ) 
{ 


  {
#line 31
  cf->offsetdata = (dword )offset;
#line 32
  return;
}
}
#line 26 "/home/wheatley/newnew/temp/lcab-1.0b12/cheader.c"
void cheader_init(struct cheader *ch , char *sign , int nfolders , int nfiles , int flags ,
                  int setID , int cabID ) 
{ 
  int i ;

  {
#line 33
  i = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (i < 4)) {
#line 33
      goto while_break;
    }
#line 33
    ch->sig[i] = (byte )*(sign + i);
#line 33
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  ch->res1 = (dword )0;
#line 35
  ch->res2 = (dword )0;
#line 36
  ch->res3 = (dword )0;
#line 37
  ch->versionMAJ = (byte )1;
#line 38
  ch->versionMIN = (byte )3;
#line 39
  ch->nfolders = (word )nfolders;
#line 40
  ch->nfiles = (word )nfiles;
#line 41
  ch->flags = (word )flags;
#line 42
  ch->setID = (word )setID;
#line 43
  ch->cabID = (word )cabID;
#line 44
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/lcab-1.0b12/cheader.c"
void cheader_size(struct cheader *ch , int size ) 
{ 


  {
#line 49
  ch->size = (dword )size;
#line 50
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/lcab-1.0b12/cheader.c"
void cheader_offsetfiles(struct cheader *ch , int offset ) 
{ 


  {
#line 55
  ch->offsetfiles = (dword )offset;
#line 56
  return;
}
}
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 35 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.h"
long writedata(struct cdata *cd , long pos , FILE *fpout , FILE *fptemp ) ;
#line 24 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.c"
int cheaderwrite(struct cheader *ch , FILE *fpout ) 
{ 
  int error ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 26
  error = 0;
#line 27
  tmp = fwrite((void const   */* __restrict  */)((char *)(& ch->sig)), (size_t )4,
               (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 27
  if (! tmp) {
#line 27
    error = 1;
  }
  {
#line 28
  tmp___0 = fwrite((void const   */* __restrict  */)((char *)(& ch->res1)), (size_t )4,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 28
  if (! tmp___0) {
#line 28
    error = 1;
  }
  {
#line 29
  tmp___1 = fwrite((void const   */* __restrict  */)((char *)(& ch->size)), (size_t )4,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 29
  if (! tmp___1) {
#line 29
    error = 1;
  }
  {
#line 30
  tmp___2 = fwrite((void const   */* __restrict  */)((char *)(& ch->res2)), (size_t )4,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 30
  if (! tmp___2) {
#line 30
    error = 1;
  }
  {
#line 31
  tmp___3 = fwrite((void const   */* __restrict  */)((char *)(& ch->offsetfiles)),
                   (size_t )4, (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 31
  if (! tmp___3) {
#line 31
    error = 1;
  }
  {
#line 32
  tmp___4 = fwrite((void const   */* __restrict  */)((char *)(& ch->res3)), (size_t )4,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 32
  if (! tmp___4) {
#line 32
    error = 1;
  }
  {
#line 33
  tmp___5 = fwrite((void const   */* __restrict  */)((char *)(& ch->versionMIN)),
                   (size_t )1, (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 33
  if (! tmp___5) {
#line 33
    error = 1;
  }
  {
#line 34
  tmp___6 = fwrite((void const   */* __restrict  */)((char *)(& ch->versionMAJ)),
                   (size_t )1, (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 34
  if (! tmp___6) {
#line 34
    error = 1;
  }
  {
#line 35
  tmp___7 = fwrite((void const   */* __restrict  */)((char *)(& ch->nfolders)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 35
  if (! tmp___7) {
#line 35
    error = 1;
  }
  {
#line 36
  tmp___8 = fwrite((void const   */* __restrict  */)((char *)(& ch->nfiles)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 36
  if (! tmp___8) {
#line 36
    error = 1;
  }
  {
#line 37
  tmp___9 = fwrite((void const   */* __restrict  */)((char *)(& ch->flags)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 37
  if (! tmp___9) {
#line 37
    error = 1;
  }
  {
#line 38
  tmp___10 = fwrite((void const   */* __restrict  */)((char *)(& ch->setID)), (size_t )2,
                    (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 38
  if (! tmp___10) {
#line 38
    error = 1;
  }
  {
#line 39
  tmp___11 = fwrite((void const   */* __restrict  */)((char *)(& ch->cabID)), (size_t )2,
                    (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 39
  if (! tmp___11) {
#line 39
    error = 1;
  }
#line 41
  return (! error);
}
}
#line 45 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.c"
int cfolderwrite(struct cfolder *cf , FILE *fpout ) 
{ 
  int error ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 47
  error = 0;
#line 49
  tmp = fwrite((void const   */* __restrict  */)((char *)(& cf->offsetdata)), (size_t )4,
               (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 49
  if (! tmp) {
#line 49
    error = 1;
  }
  {
#line 50
  tmp___0 = fwrite((void const   */* __restrict  */)((char *)(& cf->ndatab)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 50
  if (! tmp___0) {
#line 50
    error = 1;
  }
  {
#line 51
  tmp___1 = fwrite((void const   */* __restrict  */)((char *)(& cf->typecomp)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 51
  if (! tmp___1) {
#line 51
    error = 1;
  }
#line 53
  return (! error);
}
}
#line 58 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.c"
int cfilewrite(struct cfile *cf , FILE *fpout ) 
{ 
  int error ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 60
  error = 0;
#line 64
  tmp = fwrite((void const   */* __restrict  */)((char *)(& cf->usize)), (size_t )4,
               (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 64
  if (! tmp) {
#line 64
    error = 1;
  }
  {
#line 65
  tmp___0 = fwrite((void const   */* __restrict  */)((char *)(& cf->uoffset)), (size_t )4,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 65
  if (! tmp___0) {
#line 65
    error = 1;
  }
  {
#line 66
  tmp___1 = fwrite((void const   */* __restrict  */)((char *)(& cf->index)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 66
  if (! tmp___1) {
#line 66
    error = 1;
  }
  {
#line 67
  tmp___2 = fwrite((void const   */* __restrict  */)((char *)(& cf->date)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 67
  if (! tmp___2) {
#line 67
    error = 1;
  }
  {
#line 68
  tmp___3 = fwrite((void const   */* __restrict  */)((char *)(& cf->time)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 68
  if (! tmp___3) {
#line 68
    error = 1;
  }
  {
#line 69
  tmp___4 = fwrite((void const   */* __restrict  */)((char *)(& cf->fattr)), (size_t )2,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 69
  if (! tmp___4) {
#line 69
    error = 1;
  }
  {
#line 70
  tmp___5 = strlen((char const   *)(cf->name));
#line 70
  tmp___6 = fwrite((void const   */* __restrict  */)((char *)(& cf->name)), tmp___5 + 1UL,
                   (size_t )1, (FILE */* __restrict  */)fpout);
  }
#line 70
  if (! tmp___6) {
#line 70
    error = 1;
  }
#line 72
  return (! error);
}
}
#line 78 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.c"
long writedata(struct cdata *cd , long pos , FILE *fpout , FILE *fptemp ) 
{ 
  char *tmp ;
  CHECKSUM csum ;
  void *tmp___0 ;
  CHECKSUM tmp___1 ;

  {
  {
#line 81
  csum = (CHECKSUM )0;
#line 83
  fseek(fptemp, pos, 0);
#line 84
  tmp___0 = calloc((size_t )cd->ncbytes, sizeof(byte ));
#line 84
  tmp = (char *)((byte *)tmp___0);
#line 85
  fread((void */* __restrict  */)tmp, (size_t )cd->ncbytes, (size_t )1, (FILE */* __restrict  */)fptemp);
#line 88
  tmp___1 = compute_checksum((byte *)tmp, cd->ncbytes, (CHECKSUM )0);
#line 88
  csum = compute_checksum((byte *)(& cd->ncbytes), (word )(sizeof(cd->ncbytes) + sizeof(cd->nubytes)),
                          tmp___1);
#line 91
  cd->checksum = csum;
#line 93
  fwrite((void const   */* __restrict  */)((char *)(& cd->checksum)), (size_t )4,
         (size_t )1, (FILE */* __restrict  */)fpout);
#line 94
  fwrite((void const   */* __restrict  */)((char *)(& cd->ncbytes)), (size_t )2, (size_t )1,
         (FILE */* __restrict  */)fpout);
#line 95
  fwrite((void const   */* __restrict  */)((char *)(& cd->nubytes)), (size_t )2, (size_t )1,
         (FILE */* __restrict  */)fpout);
#line 97
  fwrite((void const   */* __restrict  */)((byte *)tmp), (size_t )cd->ncbytes, (size_t )1,
         (FILE */* __restrict  */)fpout);
#line 99
  free((void *)tmp);
#line 100
  pos = ftell(fptemp);
  }
#line 101
  return (pos);
}
}
#line 104 "/home/wheatley/newnew/temp/lcab-1.0b12/cwrite.c"
long cdatawrite(struct cdata *cd , FILE *fpout , long pos , FILE *fptemp ) 
{ 


  {
  {
#line 106
  pos = writedata(cd, pos, fpout, fptemp);
  }
#line 107
  if (pos != -1L) {
#line 109
    return (pos);
  } else {
#line 113
    return (pos);
  }
}
}
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 23 "/home/wheatley/newnew/temp/lcab-1.0b12/cfile.c"
void cfile_init(struct cfile *cf , int usize , int index___0 , char *filename , char *origFilename ) 
{ 
  struct stat attributes ;
  struct tm *fts ;
  size_t tmp ;

  {
  {
#line 28
  cf->usize = (dword )usize;
#line 29
  cf->index = (word )index___0;
#line 30
  stat((char const   */* __restrict  */)origFilename, (struct stat */* __restrict  */)(& attributes));
#line 31
  fts = localtime((time_t const   *)(& attributes.st_mtim.tv_sec));
#line 32
  printf((char const   */* __restrict  */)"cfileInit: %s localtime:\n", filename);
#line 35
  cf->date = (word )(((((fts->tm_year + 1900) - 1980) << 9) + ((fts->tm_mon + 1) << 5)) + fts->tm_mday);
#line 37
  cf->time = (word )(((fts->tm_hour << 11) + (fts->tm_min << 5)) + fts->tm_sec / 2);
#line 40
  cf->fattr = (word )32;
#line 42
  strcpy((char */* __restrict  */)(cf->name), (char const   */* __restrict  */)filename);
#line 43
  tmp = strlen((char const   *)filename);
#line 43
  cf->name[tmp] = (byte )'\000';
  }
#line 44
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/lcab-1.0b12/cfile.c"
void cfile_uoffset(struct cfile *cf , int offset ) 
{ 


  {
#line 49
  cf->uoffset = (dword )offset;
#line 50
  return;
}
}
