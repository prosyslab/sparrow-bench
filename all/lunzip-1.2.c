/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 41 "/usr/include/fcntl.h"
typedef __mode_t mode_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 57 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.h"
enum ap_Has_arg {
    ap_no = 0,
    ap_yes = 1,
    ap_maybe = 2
} ;
#line 59 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.h"
struct ap_Option {
   int code ;
   char const   *name ;
   enum ap_Has_arg has_arg ;
};
#line 67 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.h"
struct ap_Record {
   int code ;
   char *argument ;
};
#line 74 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.h"
struct Arg_parser {
   struct ap_Record *data ;
   char *error ;
   int data_size ;
   int error_size ;
};
#line 89 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
typedef int Bit_model;
#line 98 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
struct Pretty_print {
   char const   *name ;
   char const   *stdin_name ;
   int longest_name ;
   int verbosity ;
   _Bool first_post ;
};
#line 124 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
typedef uint32_t CRC32[256];
#line 163 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
typedef uint8_t File_header[6];
#line 20 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
struct Range_decoder {
   unsigned long long partial_member_pos ;
   uint8_t *buffer ;
   int pos ;
   int stream_pos ;
   uint32_t code ;
   uint32_t range ;
   int infd ;
   _Bool at_stream_end ;
};
#line 217 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
struct Len_decoder {
   Bit_model choice1 ;
   Bit_model choice2 ;
   Bit_model bm_low[4][8] ;
   Bit_model bm_mid[4][8] ;
   Bit_model bm_high[256] ;
};
#line 249 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
struct LZ_decoder {
   unsigned long long partial_data_pos ;
   int dictionary_size ;
   int buffer_size ;
   uint8_t *buffer ;
   int pos ;
   int stream_pos ;
   uint32_t crc ;
   int outfd ;
   int member_version ;
   Bit_model bm_literal[1 << 3][768] ;
   Bit_model bm_match[12][4] ;
   Bit_model bm_rep[12] ;
   Bit_model bm_rep0[12] ;
   Bit_model bm_rep1[12] ;
   Bit_model bm_rep2[12] ;
   Bit_model bm_len[12][4] ;
   Bit_model bm_dis_slot[4][1 << 6] ;
   Bit_model bm_dis[114] ;
   Bit_model bm_align[16] ;
   struct Range_decoder *range_decoder ;
   struct Len_decoder len_decoder ;
   struct Len_decoder rep_match_len_decoder ;
};
#line 73 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
struct __anonstruct_known_extensions_58 {
   char const   *from ;
   char const   *to ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 25 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
typedef int State;
#line 208 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
typedef uint8_t File_trailer[20];
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 478
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 83 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.h"
char ap_init(struct Arg_parser * const  ap , int const   argc , char const   * const  *argv ,
             struct ap_Option  const  *options , char const   in_order ) ;
#line 87
void ap_free(struct Arg_parser * const  ap ) ;
#line 89
char const   *ap_error(struct Arg_parser  const  * const  ap ) ;
#line 92
int ap_arguments(struct Arg_parser  const  * const  ap ) ;
#line 96
int ap_code(struct Arg_parser  const  * const  ap , int const   i ) ;
#line 98
char const   *ap_argument(struct Arg_parser  const  * const  ap , int const   i ) ;
#line 91 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void Bm_init(Bit_model * const  probability ) 
{ 


  {
#line 92
  *probability = 1024;
#line 92
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void Bm_array_init(Bit_model * const  p , int const   size ) 
{ 
  int i ;
  int tmp ;

  {
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < (int )size)) {
#line 95
      goto while_break;
    }
#line 95
    tmp = i;
#line 95
    i ++;
#line 95
    *(p + tmp) = 1024;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 107
void Pp_init(struct Pretty_print * const  pp , char const   * const  *filenames ,
             int const   num_filenames , int const   v ) ;
#line 110 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void Pp_set_name(struct Pretty_print * const  pp , char const   * const  filename ) 
{ 
  int tmp ;

  {
#line 113
  if (filename) {
#line 113
    if (*(filename + 0)) {
      {
#line 113
      tmp = strcmp((char const   *)filename, "-");
      }
#line 113
      if (tmp != 0) {
#line 114
        pp->name = (char const   *)filename;
      } else {
#line 115
        pp->name = pp->stdin_name;
      }
    } else {
#line 115
      pp->name = pp->stdin_name;
    }
  } else {
#line 115
    pp->name = pp->stdin_name;
  }
#line 116
  pp->first_post = (_Bool)1;
#line 117
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void Pp_reset(struct Pretty_print * const  pp ) 
{ 


  {
#line 120
  if (pp->name) {
#line 120
    if (*(pp->name + 0)) {
#line 120
      pp->first_post = (_Bool)1;
    }
  }
#line 120
  return;
}
}
#line 121
void Pp_show_msg(struct Pretty_print * const  pp , char const   * const  msg ) ;
#line 126
CRC32 crc32 ;
#line 128 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void CRC32_init(void) 
{ 
  unsigned int n ;
  unsigned int c ;
  int k ;

  {
#line 131
  n = 0U;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (n < 256U)) {
#line 131
      goto while_break;
    }
#line 133
    c = n;
#line 135
    k = 0;
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! (k < 8)) {
#line 135
        goto while_break___0;
      }
#line 136
      if (c & 1U) {
#line 136
        c = 3988292384U ^ (c >> 1);
      } else {
#line 136
        c >>= 1;
      }
#line 135
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 137
    crc32[n] = c;
#line 131
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 161 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
static uint8_t const   magic_string[4]  = {      (uint8_t const   )76,      (uint8_t const   )90,      (uint8_t const   )73,      (uint8_t const   )80};
#line 171 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static _Bool Fh_verify_magic(uint8_t * const  data ) 
{ 
  int tmp ;

  {
  {
#line 172
  tmp = memcmp((void const   *)data, (void const   *)(magic_string), (size_t )4);
  }
#line 172
  return ((_Bool )(tmp == 0));
}
}
#line 174 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static uint8_t Fh_version(uint8_t * const  data ) 
{ 


  {
#line 175
  return (*(data + 4));
}
}
#line 177 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static _Bool Fh_verify_version(uint8_t * const  data ) 
{ 


  {
#line 178
  return ((_Bool )((int )*(data + 4) <= 1));
}
}
#line 180 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static int Fh_get_dictionary_size(uint8_t * const  data ) 
{ 
  int sz ;

  {
#line 182
  sz = 1 << ((int )*(data + 5) & 31);
#line 183
  if (sz > 4096) {
#line 183
    if (sz <= 536870912) {
#line 184
      sz -= (sz / 16) * (((int )*(data + 5) >> 5) & 7);
    }
  }
#line 185
  return (sz);
}
}
#line 262
void cleanup_and_fail(int const   retval ) ;
#line 263
void show_error(char const   * const  msg , int const   errcode , _Bool const   help ) ;
#line 32 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
_Bool Rd_read_block(struct Range_decoder * const  rdec ) ;
#line 34 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static _Bool Rd_init(struct Range_decoder * const  rdec , int const   ifd ) 
{ 
  void *tmp ;

  {
  {
#line 36
  rdec->partial_member_pos = 0ULL;
#line 37
  tmp = malloc((size_t )16384);
#line 37
  rdec->buffer = (uint8_t *)tmp;
  }
#line 38
  if (! rdec->buffer) {
#line 38
    return ((_Bool)0);
  }
#line 39
  rdec->pos = 0;
#line 40
  rdec->stream_pos = 0;
#line 41
  rdec->code = (uint32_t )0;
#line 42
  rdec->range = 4294967295U;
#line 43
  rdec->infd = (int )ifd;
#line 44
  rdec->at_stream_end = (_Bool)0;
#line 45
  return ((_Bool)1);
}
}
#line 48 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void Rd_free(struct Range_decoder * const  rdec ) 
{ 


  {
  {
#line 49
  free((void *)rdec->buffer);
  }
#line 49
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static _Bool Rd_finished(struct Range_decoder * const  rdec ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 52
  if (rdec->pos >= rdec->stream_pos) {
    {
#line 52
    tmp = Rd_read_block(rdec);
    }
#line 52
    if (tmp) {
#line 52
      tmp___0 = 0;
    } else {
#line 52
      tmp___0 = 1;
    }
  } else {
#line 52
    tmp___0 = 0;
  }
#line 52
  return ((_Bool )tmp___0);
}
}
#line 54 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static unsigned long long Rd_member_position(struct Range_decoder  const  * const  rdec ) 
{ 


  {
#line 56
  return ((unsigned long long )(rdec->partial_member_pos + (unsigned long long const   )rdec->pos));
}
}
#line 58 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void Rd_reset_member_position(struct Range_decoder * const  rdec ) 
{ 


  {
#line 59
  rdec->partial_member_pos = (unsigned long long )(- rdec->pos);
#line 59
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_read_data(struct Range_decoder * const  rdec , uint8_t * const  outbuf ,
                                 int const   size ) 
{ 
  int rest ;
  int rd ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 70
  rest = (int )size;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (rest > 0) {
      {
#line 71
      tmp___0 = Rd_finished(rdec);
      }
#line 71
      if (tmp___0) {
#line 71
        goto while_break;
      }
    } else {
#line 71
      goto while_break;
    }
#line 73
    if (rest <= rdec->stream_pos - rdec->pos) {
#line 73
      tmp = rest;
    } else {
#line 73
      tmp = rdec->stream_pos - rdec->pos;
    }
    {
#line 73
    rd = tmp;
#line 74
    memcpy((void */* __restrict  */)((outbuf + size) - rest), (void const   */* __restrict  */)(rdec->buffer + rdec->pos),
           (size_t )rd);
#line 75
    rdec->pos += rd;
#line 76
    rest -= rd;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((int )(size - (int const   )rest));
}
}
#line 226 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void Led_init(struct Len_decoder * const  len_decoder ) 
{ 


  {
  {
#line 228
  Bm_init((Bit_model */* const  */)(& len_decoder->choice1));
#line 229
  Bm_init((Bit_model */* const  */)(& len_decoder->choice2));
#line 230
  Bm_array_init((Bit_model */* const  */)(len_decoder->bm_low[0]), (int const   )32);
#line 231
  Bm_array_init((Bit_model */* const  */)(len_decoder->bm_mid[0]), (int const   )32);
#line 232
  Bm_array_init((Bit_model */* const  */)(len_decoder->bm_high), (int const   )256);
  }
#line 233
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static _Bool LZd_init(struct LZ_decoder * const  decoder , uint8_t * const  header ,
                               struct Range_decoder * const  rdec , int const   ofd ) 
{ 
  void *tmp ;
  uint8_t tmp___0 ;

  {
  {
#line 327
  decoder->partial_data_pos = 0ULL;
#line 328
  decoder->dictionary_size = Fh_get_dictionary_size(header);
  }
#line 329
  if (65536 >= decoder->dictionary_size) {
#line 329
    decoder->buffer_size = 65536;
  } else {
#line 329
    decoder->buffer_size = decoder->dictionary_size;
  }
  {
#line 330
  tmp = malloc((size_t )decoder->buffer_size);
#line 330
  decoder->buffer = (uint8_t *)tmp;
  }
#line 331
  if (! decoder->buffer) {
#line 331
    return ((_Bool)0);
  }
  {
#line 332
  decoder->pos = 0;
#line 333
  decoder->stream_pos = 0;
#line 334
  decoder->crc = 4294967295U;
#line 335
  decoder->outfd = (int )ofd;
#line 336
  tmp___0 = Fh_version(header);
#line 336
  decoder->member_version = (int )tmp___0;
#line 338
  Bm_array_init((Bit_model */* const  */)(decoder->bm_literal[0]), (int const   )((1 << 3) * 768));
#line 339
  Bm_array_init((Bit_model */* const  */)(decoder->bm_match[0]), (int const   )48);
#line 340
  Bm_array_init((Bit_model */* const  */)(decoder->bm_rep), (int const   )12);
#line 341
  Bm_array_init((Bit_model */* const  */)(decoder->bm_rep0), (int const   )12);
#line 342
  Bm_array_init((Bit_model */* const  */)(decoder->bm_rep1), (int const   )12);
#line 343
  Bm_array_init((Bit_model */* const  */)(decoder->bm_rep2), (int const   )12);
#line 344
  Bm_array_init((Bit_model */* const  */)(decoder->bm_len[0]), (int const   )48);
#line 345
  Bm_array_init((Bit_model */* const  */)(decoder->bm_dis_slot[0]), (int const   )(4 * (1 << 6)));
#line 346
  Bm_array_init((Bit_model */* const  */)(decoder->bm_dis), (int const   )114);
#line 347
  Bm_array_init((Bit_model */* const  */)(decoder->bm_align), (int const   )16);
#line 349
  decoder->range_decoder = (struct Range_decoder *)rdec;
#line 350
  Led_init((struct Len_decoder */* const  */)(& decoder->len_decoder));
#line 351
  Led_init((struct Len_decoder */* const  */)(& decoder->rep_match_len_decoder));
#line 352
  *(decoder->buffer + (decoder->buffer_size - 1)) = (uint8_t )0;
  }
#line 353
  return ((_Bool)1);
}
}
#line 356 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void LZd_free(struct LZ_decoder * const  decoder ) 
{ 


  {
  {
#line 357
  free((void *)decoder->buffer);
  }
#line 357
  return;
}
}
#line 366
int LZd_decode_member(struct LZ_decoder * const  decoder , struct Pretty_print * const  pp ) ;
#line 62 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
char const   * const  Program_name  =    (char const   */* const  */)"Lunzip";
#line 63 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
char const   * const  program_name  =    (char const   */* const  */)"lunzip";
#line 64 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
char const   * const  program_year  =    (char const   */* const  */)"2013";
#line 65 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
char const   *invocation_name  =    (char const   *)0;
#line 70 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
int const   o_binary  =    (int const   )0;
#line 73 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
struct __anonstruct_known_extensions_58  const  known_extensions[3]  = {      {".lz", ""}, 
        {".tlz", ".tar"}, 
        {(char const   *)0, (char const   *)0}};
#line 78 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
char *output_filename  =    (char *)0;
#line 79 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
int outfd  =    -1;
#line 80 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
int verbosity  =    0;
#line 81 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
unsigned int const   usr_rw  =    (mode_t const   )384;
#line 82 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
unsigned int const   all_rw  =    (mode_t const   )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 83 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
mode_t outfd_mode  =    (mode_t )384;
#line 84 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
_Bool delete_output_on_interrupt  =    (_Bool)0;
#line 87 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static void show_help(void) 
{ 


  {
  {
#line 89
  printf((char const   */* __restrict  */)"%s - Decompressor for lzip files.\n", Program_name);
#line 90
  printf((char const   */* __restrict  */)"\nUsage: %s [options] [files]\n", invocation_name);
#line 91
  printf((char const   */* __restrict  */)"\nOptions:\n  -h, --help                 display this help and exit\n  -V, --version              output version information and exit\n  -c, --stdout               send output to standard output\n  -d, --decompress           decompress (this is the default)\n  -f, --force                overwrite existing output files\n  -k, --keep                 keep (don\'t delete) input files\n  -o, --output=<file>        if reading stdin, place the output into <file>\n  -q, --quiet                suppress all messages\n  -t, --test                 test compressed file integrity\n  -v, --verbose              be verbose (a 2nd -v gives more)\nIf no file names are given, lunzip decompresses from standard input to\nstandard output.\n\nReport bugs to lzip-bug@nongnu.org\nLunzip home page: http://www.nongnu.org/lzip/lunzip.html\n");
  }
#line 106
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static void show_version(void) 
{ 


  {
  {
#line 111
  printf((char const   */* __restrict  */)"%s %s\n", Program_name, "1.2");
#line 112
  printf((char const   */* __restrict  */)"Copyright (C) %s Antonio Diaz Diaz.\n",
         program_year);
#line 113
  printf((char const   */* __restrict  */)"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n");
  }
#line 116
  return;
}
}
#line 119 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
void show_header(uint8_t * const  header ) 
{ 
  char const   *prefix[8] ;
  char const   *p ;
  char const   *np ;
  unsigned int num ;
  int tmp ;
  unsigned int i ;
  _Bool exact ;
  uint8_t tmp___0 ;

  {
  {
#line 121
  prefix[0] = "Ki";
#line 121
  prefix[1] = "Mi";
#line 121
  prefix[2] = "Gi";
#line 121
  prefix[3] = "Ti";
#line 121
  prefix[4] = "Pi";
#line 121
  prefix[5] = "Ei";
#line 121
  prefix[6] = "Zi";
#line 121
  prefix[7] = "Yi";
#line 124
  p = "";
#line 125
  np = "  ";
#line 126
  tmp = Fh_get_dictionary_size(header);
#line 126
  num = (unsigned int )tmp;
#line 127
  exact = (_Bool )(num % 1024U == 0U);
#line 129
  i = 0U;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (i < 8U) {
#line 129
      if (! (num > 9999U)) {
#line 129
        if (exact) {
#line 129
          if (! (num >= 1024U)) {
#line 129
            goto while_break;
          }
        } else {
#line 129
          goto while_break;
        }
      }
    } else {
#line 129
      goto while_break;
    }
#line 130
    num /= 1024U;
#line 130
    if (num % 1024U != 0U) {
#line 130
      exact = (_Bool)0;
    }
#line 131
    p = prefix[i];
#line 131
    np = "";
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  tmp___0 = Fh_version(header);
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"version %d, dictionary size %s%4u %sB.  ",
          (int )tmp___0, np, num, p);
  }
#line 134
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static int extension_index(char const   * const  name ) 
{ 
  int i ;
  char const   *ext ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! known_extensions[i].from) {
#line 140
      goto while_break;
    }
    {
#line 142
    ext = (char const   *)known_extensions[i].from;
#line 143
    tmp = strlen((char const   *)name);
#line 143
    tmp___0 = strlen(ext);
    }
#line 143
    if (tmp > tmp___0) {
      {
#line 143
      tmp___1 = strlen(ext);
#line 143
      tmp___2 = strlen((char const   *)name);
#line 143
      tmp___3 = strlen(ext);
#line 143
      tmp___4 = strncmp((char const   *)((name + tmp___2) - tmp___3), ext, tmp___1);
      }
#line 143
      if (tmp___4 == 0) {
#line 145
        return (i);
      }
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (-1);
}
}
#line 151 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static int open_instream(char const   * const  name , struct stat * const  in_statsp ,
                         _Bool const   to_stdout ) 
{ 
  int infd ;
  int *tmp ;
  char *tmp___0 ;
  int i ;
  int tmp___1 ;
  mode_t mode ;
  _Bool can_read ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 154
  infd = -1;
#line 155
  infd = open((char const   *)name, (int )o_binary);
  }
#line 156
  if (infd < 0) {
#line 158
    if (verbosity >= 0) {
      {
#line 159
      tmp = __errno_location();
#line 159
      tmp___0 = strerror(*tmp);
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t open input file \'%s\': %s.\n",
              program_name, name, tmp___0);
      }
    }
  } else {
    {
#line 164
    tmp___1 = fstat(infd, (struct stat *)in_statsp);
#line 164
    i = tmp___1;
#line 165
    mode = in_statsp->st_mode;
    }
#line 166
    if (i == 0) {
#line 166
      if ((mode & 61440U) == 24576U) {
#line 166
        tmp___2 = 1;
      } else
#line 166
      if ((mode & 61440U) == 8192U) {
#line 166
        tmp___2 = 1;
      } else
#line 166
      if ((mode & 61440U) == 4096U) {
#line 166
        tmp___2 = 1;
      } else
#line 166
      if ((mode & 61440U) == 49152U) {
#line 166
        tmp___2 = 1;
      } else {
#line 166
        tmp___2 = 0;
      }
    } else {
#line 166
      tmp___2 = 0;
    }
#line 166
    can_read = (_Bool )tmp___2;
#line 169
    if (i != 0) {
#line 169
      goto _L___0;
    } else
#line 169
    if (! ((mode & 61440U) == 32768U)) {
#line 169
      if (! to_stdout) {
#line 169
        goto _L___0;
      } else
#line 169
      if (! can_read) {
        _L___0: /* CIL Label */ 
#line 171
        if (verbosity >= 0) {
#line 172
          if (can_read) {
#line 172
            if (! to_stdout) {
#line 172
              tmp___3 = " and \'--stdout\' was not specified";
            } else {
#line 172
              tmp___3 = "";
            }
          } else {
#line 172
            tmp___3 = "";
          }
          {
#line 172
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input file \'%s\' is not a regular file%s.\n",
                  program_name, name, tmp___3);
          }
        }
        {
#line 176
        close(infd);
#line 177
        infd = -1;
        }
      }
    }
  }
#line 180
  return (infd);
}
}
#line 185 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static void *resize_buffer(void *buf , int const   min_size ) 
{ 


  {
#line 187
  if (buf) {
    {
#line 187
    buf = realloc(buf, (size_t )min_size);
    }
  } else {
    {
#line 188
    buf = malloc((size_t )min_size);
    }
  }
#line 189
  if (! buf) {
    {
#line 191
    show_error((char const   */* const  */)"Not enough memory.", (int const   )0,
               (_Bool const   )0);
#line 192
    cleanup_and_fail((int const   )1);
    }
  }
#line 194
  return (buf);
}
}
#line 198 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static void set_d_outname(char const   * const  name , int const   i ) 
{ 
  char const   *from ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
#line 200
  if (i >= 0) {
    {
#line 202
    from = (char const   *)known_extensions[i].from;
#line 203
    tmp___4 = strlen((char const   *)name);
#line 203
    tmp___5 = strlen(from);
    }
#line 203
    if (tmp___4 > tmp___5) {
      {
#line 205
      tmp = strlen((char const   *)name);
#line 205
      tmp___0 = strlen((char const   *)known_extensions[0].to);
#line 205
      tmp___1 = resize_buffer((void *)output_filename, (int const   )((tmp + tmp___0) + 1UL));
#line 205
      output_filename = (char *)tmp___1;
#line 207
      strcpy((char */* __restrict  */)output_filename, (char const   */* __restrict  */)name);
#line 208
      tmp___2 = strlen((char const   *)name);
#line 208
      tmp___3 = strlen(from);
#line 208
      strcpy((char */* __restrict  */)((output_filename + tmp___2) - tmp___3), (char const   */* __restrict  */)known_extensions[i].to);
      }
#line 210
      return;
    }
  }
  {
#line 213
  tmp___6 = strlen((char const   *)name);
#line 213
  tmp___7 = resize_buffer((void *)output_filename, (int const   )((tmp___6 + 4UL) + 1UL));
#line 213
  output_filename = (char *)tmp___7;
#line 214
  strcpy((char */* __restrict  */)output_filename, (char const   */* __restrict  */)name);
#line 215
  strcat((char */* __restrict  */)output_filename, (char const   */* __restrict  */)".out");
  }
#line 216
  if (verbosity >= 1) {
    {
#line 217
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t guess original name for \'%s\' -- using \'%s\'.\n",
            program_name, name, output_filename);
    }
  }
#line 219
  return;
}
}
#line 222 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static _Bool open_outstream(_Bool const   force ) 
{ 
  int flags ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 224
  flags = 65 | (int )o_binary;
#line 225
  if (force) {
#line 225
    flags |= 512;
  } else {
#line 225
    flags |= 128;
  }
  {
#line 227
  outfd = open((char const   *)output_filename, flags, outfd_mode);
  }
#line 228
  if (outfd < 0) {
#line 228
    if (verbosity >= 0) {
      {
#line 230
      tmp___1 = __errno_location();
      }
#line 230
      if (*tmp___1 == 17) {
        {
#line 231
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Output file \'%s\' already exists, skipping.\n",
                program_name, output_filename);
        }
      } else {
        {
#line 234
        tmp = __errno_location();
#line 234
        tmp___0 = strerror(*tmp);
#line 234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Can\'t create output file \'%s\': %s.\n",
                program_name, output_filename, tmp___0);
        }
      }
    }
  }
#line 237
  return ((_Bool )(outfd >= 0));
}
}
#line 241 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
void cleanup_and_fail(int const   retval ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
#line 243
  if (delete_output_on_interrupt) {
#line 245
    delete_output_on_interrupt = (_Bool)0;
#line 246
    if (verbosity >= 0) {
      {
#line 247
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Deleting output file \'%s\', if it exists.\n",
              program_name, output_filename);
      }
    }
#line 249
    if (outfd >= 0) {
      {
#line 249
      close(outfd);
#line 249
      outfd = -1;
      }
    }
    {
#line 250
    tmp = remove((char const   *)output_filename);
    }
#line 250
    if (tmp != 0) {
      {
#line 250
      tmp___0 = __errno_location();
      }
#line 250
      if (*tmp___0 != 2) {
        {
#line 251
        show_error((char const   */* const  */)"WARNING: deletion of output file (apparently) failed.",
                   (int const   )0, (_Bool const   )0);
        }
      }
    }
  }
  {
#line 253
  exit((int )retval);
  }
}
}
#line 258 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static void close_and_set_permissions(struct stat  const  * const  in_statsp ) 
{ 
  _Bool warning ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct utimbuf t ;
  int tmp___3 ;

  {
#line 260
  warning = (_Bool)0;
#line 261
  if (in_statsp) {
    {
#line 264
    tmp = fchown(outfd, (__uid_t )in_statsp->st_uid, (__gid_t )in_statsp->st_gid);
    }
#line 264
    if (tmp != 0) {
      {
#line 264
      tmp___0 = __errno_location();
      }
#line 264
      if (*tmp___0 != 1) {
#line 266
        warning = (_Bool)1;
      } else {
#line 264
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 264
      tmp___1 = fchmod(outfd, (__mode_t )in_statsp->st_mode);
      }
#line 264
      if (tmp___1 != 0) {
#line 266
        warning = (_Bool)1;
      }
    }
  }
  {
#line 268
  tmp___2 = close(outfd);
  }
#line 268
  if (tmp___2 != 0) {
    {
#line 268
    cleanup_and_fail((int const   )1);
    }
  }
#line 269
  outfd = -1;
#line 270
  delete_output_on_interrupt = (_Bool)0;
#line 271
  if (in_statsp) {
    {
#line 274
    t.actime = (__time_t )in_statsp->st_atim.tv_sec;
#line 275
    t.modtime = (__time_t )in_statsp->st_mtim.tv_sec;
#line 276
    tmp___3 = utime((char const   *)output_filename, (struct utimbuf  const  *)(& t));
    }
#line 276
    if (tmp___3 != 0) {
#line 276
      warning = (_Bool)1;
    }
  }
#line 278
  if (warning) {
#line 278
    if (verbosity >= 1) {
      {
#line 279
      show_error((char const   */* const  */)"Can\'t change output file attributes.",
                 (int const   )0, (_Bool const   )0);
      }
    }
  }
#line 280
  return;
}
}
#line 283 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static int decompress(int const   infd , struct Pretty_print * const  pp , _Bool const   testing ) 
{ 
  unsigned long long partial_file_pos ;
  struct Range_decoder rdec ;
  int retval ;
  _Bool first_member ;
  _Bool tmp ;
  int result ;
  File_header header ;
  struct LZ_decoder decoder ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  uint8_t tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  unsigned long long tmp___7 ;

  {
  {
#line 286
  partial_file_pos = 0ULL;
#line 288
  retval = 0;
#line 290
  tmp = Rd_init((struct Range_decoder */* const  */)(& rdec), infd);
  }
#line 290
  if (! tmp) {
    {
#line 292
    show_error((char const   */* const  */)"Not enough memory. Find a machine with more memory.",
               (int const   )0, (_Bool const   )0);
#line 293
    cleanup_and_fail((int const   )1);
    }
  }
#line 296
  first_member = (_Bool)1;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 301
    Rd_reset_member_position((struct Range_decoder */* const  */)(& rdec));
#line 302
    Rd_read_data((struct Range_decoder */* const  */)(& rdec), (uint8_t */* const  */)(header),
                 (int const   )6);
#line 303
    tmp___0 = Rd_finished((struct Range_decoder */* const  */)(& rdec));
    }
#line 303
    if (tmp___0) {
#line 305
      if (first_member) {
        {
#line 306
        Pp_show_msg(pp, (char const   */* const  */)"Error reading member header");
#line 306
        retval = 1;
        }
      }
#line 307
      goto while_break;
    }
    {
#line 309
    tmp___1 = Fh_verify_magic((uint8_t */* const  */)(header));
    }
#line 309
    if (! tmp___1) {
#line 311
      if (! first_member) {
#line 311
        goto while_break;
      }
      {
#line 312
      Pp_show_msg(pp, (char const   */* const  */)"Bad magic number (file not in lzip format)");
#line 313
      retval = 2;
      }
#line 313
      goto while_break;
    }
    {
#line 315
    tmp___3 = Fh_verify_version((uint8_t */* const  */)(header));
    }
#line 315
    if (! tmp___3) {
#line 317
      if (verbosity >= 0) {
        {
#line 318
        Pp_show_msg(pp, (char const   */* const  */)0);
#line 319
        tmp___2 = Fh_version((uint8_t */* const  */)(header));
#line 319
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version %d member format not supported.\n",
                (int )tmp___2);
        }
      }
#line 321
      retval = 2;
#line 321
      goto while_break;
    }
    {
#line 323
    tmp___4 = Fh_get_dictionary_size((uint8_t */* const  */)(header));
    }
#line 323
    if (tmp___4 < 4096) {
      {
#line 325
      Pp_show_msg(pp, (char const   */* const  */)"Invalid dictionary size in member header");
#line 326
      retval = 2;
      }
#line 326
      goto while_break;
    } else {
      {
#line 323
      tmp___5 = Fh_get_dictionary_size((uint8_t */* const  */)(header));
      }
#line 323
      if (tmp___5 > 536870912) {
        {
#line 325
        Pp_show_msg(pp, (char const   */* const  */)"Invalid dictionary size in member header");
#line 326
        retval = 2;
        }
#line 326
        goto while_break;
      }
    }
#line 328
    if (verbosity >= 2) {
#line 328
      goto _L;
    } else
#line 328
    if (verbosity == 1) {
#line 328
      if (first_member) {
        _L: /* CIL Label */ 
        {
#line 329
        Pp_show_msg(pp, (char const   */* const  */)0);
        }
#line 329
        if (verbosity >= 2) {
          {
#line 329
          show_header((uint8_t */* const  */)(header));
          }
        }
      }
    }
    {
#line 331
    tmp___6 = LZd_init((struct LZ_decoder */* const  */)(& decoder), (uint8_t */* const  */)(header),
                       (struct Range_decoder */* const  */)(& rdec), (int const   )outfd);
    }
#line 331
    if (! tmp___6) {
      {
#line 333
      show_error((char const   */* const  */)"Not enough memory. Find a machine with more memory.",
                 (int const   )0, (_Bool const   )0);
#line 334
      cleanup_and_fail((int const   )1);
      }
    }
    {
#line 336
    result = LZd_decode_member((struct LZ_decoder */* const  */)(& decoder), pp);
#line 337
    tmp___7 = Rd_member_position((struct Range_decoder  const  */* const  */)(& rdec));
#line 337
    partial_file_pos += tmp___7;
#line 338
    LZd_free((struct LZ_decoder */* const  */)(& decoder));
    }
#line 339
    if (result != 0) {
#line 341
      if (verbosity >= 0) {
#line 341
        if (result <= 2) {
          {
#line 343
          Pp_show_msg(pp, (char const   */* const  */)0);
          }
#line 344
          if (result == 2) {
            {
#line 345
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File ends unexpectedly at pos %llu\n",
                    partial_file_pos);
            }
          } else {
            {
#line 348
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decoder error at pos %llu\n",
                    partial_file_pos);
            }
          }
        }
      }
#line 350
      retval = 2;
#line 350
      goto while_break;
    }
#line 352
    if (verbosity >= 2) {
#line 353
      if (testing) {
        {
#line 353
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ok\n");
        }
      } else {
        {
#line 354
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done\n");
        }
      }
      {
#line 354
      Pp_reset(pp);
      }
    }
#line 296
    first_member = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  Rd_free((struct Range_decoder */* const  */)(& rdec));
  }
#line 357
  if (verbosity == 1) {
#line 357
    if (retval == 0) {
#line 358
      if (testing) {
        {
#line 358
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ok\n");
        }
      } else {
        {
#line 359
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done\n");
        }
      }
    }
  }
#line 360
  return (retval);
}
}
#line 364 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
void signal_handler(int sig ) 
{ 


  {
  {
#line 367
  show_error((char const   */* const  */)"Control-C or similar caught, quitting.",
             (int const   )0, (_Bool const   )0);
#line 368
  cleanup_and_fail((int const   )1);
  }
#line 369
  return;
}
}
#line 372 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
static void set_signals(void) 
{ 


  {
  {
#line 374
  signal(1, & signal_handler);
#line 375
  signal(2, & signal_handler);
#line 376
  signal(15, & signal_handler);
  }
#line 377
  return;
}
}
#line 380 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
void Pp_init(struct Pretty_print * const  pp , char const   * const  *filenames ,
             int const   num_filenames , int const   v ) 
{ 
  unsigned int stdin_name_len ;
  int i ;
  size_t tmp ;
  char const   *s ;
  int len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 385
  pp->name = (char const   *)0;
#line 386
  pp->stdin_name = "(stdin)";
#line 387
  pp->longest_name = 0;
#line 388
  pp->verbosity = (int )v;
#line 389
  pp->first_post = (_Bool)0;
#line 390
  tmp = strlen(pp->stdin_name);
#line 390
  stdin_name_len = (unsigned int )tmp;
#line 392
  i = 0;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i < (int )num_filenames)) {
#line 392
      goto while_break;
    }
    {
#line 394
    s = (char const   *)*(filenames + i);
#line 395
    tmp___3 = strcmp(s, "-");
    }
#line 395
    if (tmp___3 == 0) {
#line 395
      tmp___2 = (size_t )stdin_name_len;
    } else {
      {
#line 395
      tmp___1 = strlen(s);
#line 395
      tmp___2 = tmp___1;
      }
    }
#line 395
    len = (int )tmp___2;
#line 396
    if (len > pp->longest_name) {
#line 396
      pp->longest_name = len;
    }
#line 392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  if (pp->longest_name == 0) {
#line 398
    pp->longest_name = (int )stdin_name_len;
  }
#line 399
  return;
}
}
#line 402 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
void show_error(char const   * const  msg , int const   errcode , _Bool const   help ) 
{ 
  char *tmp ;

  {
#line 404
  if (verbosity >= 0) {
#line 406
    if (msg) {
#line 406
      if (*(msg + 0)) {
        {
#line 408
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s",
                program_name, msg);
        }
#line 409
        if (errcode > 0) {
          {
#line 409
          tmp = strerror((int )errcode);
#line 409
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
                  tmp);
          }
        }
        {
#line 410
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
    }
#line 412
    if (help) {
      {
#line 413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
              invocation_name);
      }
    }
  }
#line 416
  return;
}
}
#line 419 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
void internal_error(char const   * const  msg ) 
{ 


  {
#line 421
  if (verbosity >= 0) {
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: internal error: %s.\n",
            program_name, msg);
    }
  }
  {
#line 423
  exit(3);
  }
}
}
#line 427 "/home/wheatley/newnew/temp/lunzip-1.2/main.c"
int main(int const   argc , char const   * const  *argv ) 
{ 
  char const   *input_filename ;
  char const   *default_output_filename ;
  char const   **filenames ;
  int num_filenames ;
  int infd ;
  int argind ;
  int retval ;
  int i ;
  _Bool filenames_given ;
  _Bool force ;
  _Bool keep_input_files ;
  _Bool testing ;
  _Bool to_stdout ;
  struct Pretty_print pp ;
  struct ap_Option options[11] ;
  struct Arg_parser parser ;
  char tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int code ;
  int tmp___2 ;
  char const   *arg ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  struct stat in_stats ;
  struct stat  const  *in_statsp ;
  size_t tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;

  {
  {
#line 429
  input_filename = "";
#line 430
  default_output_filename = "";
#line 431
  filenames = (char const   **)0;
#line 432
  num_filenames = 0;
#line 433
  infd = -1;
#line 434
  argind = 0;
#line 435
  retval = 0;
#line 437
  filenames_given = (_Bool)0;
#line 438
  force = (_Bool)0;
#line 439
  keep_input_files = (_Bool)0;
#line 440
  testing = (_Bool)0;
#line 441
  to_stdout = (_Bool)0;
#line 444
  options[0].code = 'c';
#line 444
  options[0].name = "stdout";
#line 444
  options[0].has_arg = (enum ap_Has_arg )0;
#line 444
  options[1].code = 'd';
#line 444
  options[1].name = "decompress";
#line 444
  options[1].has_arg = (enum ap_Has_arg )0;
#line 444
  options[2].code = 'f';
#line 444
  options[2].name = "force";
#line 444
  options[2].has_arg = (enum ap_Has_arg )0;
#line 444
  options[3].code = 'h';
#line 444
  options[3].name = "help";
#line 444
  options[3].has_arg = (enum ap_Has_arg )0;
#line 444
  options[4].code = 'k';
#line 444
  options[4].name = "keep";
#line 444
  options[4].has_arg = (enum ap_Has_arg )0;
#line 444
  options[5].code = 'o';
#line 444
  options[5].name = "output";
#line 444
  options[5].has_arg = (enum ap_Has_arg )1;
#line 444
  options[6].code = 'q';
#line 444
  options[6].name = "quiet";
#line 444
  options[6].has_arg = (enum ap_Has_arg )0;
#line 444
  options[7].code = 't';
#line 444
  options[7].name = "test";
#line 444
  options[7].has_arg = (enum ap_Has_arg )0;
#line 444
  options[8].code = 'v';
#line 444
  options[8].name = "verbose";
#line 444
  options[8].has_arg = (enum ap_Has_arg )0;
#line 444
  options[9].code = 'V';
#line 444
  options[9].name = "version";
#line 444
  options[9].has_arg = (enum ap_Has_arg )0;
#line 444
  options[10].code = 0;
#line 444
  options[10].name = (char const   *)0;
#line 444
  options[10].has_arg = (enum ap_Has_arg )0;
#line 460
  invocation_name = (char const   *)*(argv + 0);
#line 461
  CRC32_init();
#line 463
  tmp = ap_init((struct Arg_parser */* const  */)(& parser), argc, argv, (struct ap_Option  const  *)(options),
                (char const   )0);
  }
#line 463
  if (! tmp) {
    {
#line 464
    show_error((char const   */* const  */)"Memory exhausted.", (int const   )0, (_Bool const   )0);
    }
#line 464
    return (1);
  }
  {
#line 465
  tmp___1 = ap_error((struct Arg_parser  const  */* const  */)(& parser));
  }
#line 465
  if (tmp___1) {
    {
#line 466
    tmp___0 = ap_error((struct Arg_parser  const  */* const  */)(& parser));
#line 466
    show_error((char const   */* const  */)tmp___0, (int const   )0, (_Bool const   )1);
    }
#line 466
    return (1);
  }
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 468
    tmp___4 = ap_arguments((struct Arg_parser  const  */* const  */)(& parser));
    }
#line 468
    if (! (argind < tmp___4)) {
#line 468
      goto while_break;
    }
    {
#line 470
    tmp___2 = ap_code((struct Arg_parser  const  */* const  */)(& parser), (int const   )argind);
#line 470
    code = tmp___2;
#line 471
    tmp___3 = ap_argument((struct Arg_parser  const  */* const  */)(& parser), (int const   )argind);
#line 471
    arg = tmp___3;
    }
#line 472
    if (! code) {
#line 472
      goto while_break;
    }
    {
#line 475
    if (code == 99) {
#line 475
      goto case_99;
    }
#line 476
    if (code == 100) {
#line 476
      goto case_100;
    }
#line 477
    if (code == 102) {
#line 477
      goto case_102;
    }
#line 478
    if (code == 104) {
#line 478
      goto case_104;
    }
#line 479
    if (code == 107) {
#line 479
      goto case_107;
    }
#line 480
    if (code == 111) {
#line 480
      goto case_111;
    }
#line 481
    if (code == 113) {
#line 481
      goto case_113;
    }
#line 482
    if (code == 116) {
#line 482
      goto case_116;
    }
#line 483
    if (code == 118) {
#line 483
      goto case_118;
    }
#line 484
    if (code == 86) {
#line 484
      goto case_86;
    }
#line 485
    goto switch_default;
    case_99: /* CIL Label */ 
#line 475
    to_stdout = (_Bool)1;
#line 475
    goto switch_break;
    case_100: /* CIL Label */ 
#line 476
    testing = (_Bool)0;
#line 476
    goto switch_break;
    case_102: /* CIL Label */ 
#line 477
    force = (_Bool)1;
#line 477
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 478
    show_help();
    }
#line 478
    return (0);
    case_107: /* CIL Label */ 
#line 479
    keep_input_files = (_Bool)1;
#line 479
    goto switch_break;
    case_111: /* CIL Label */ 
#line 480
    default_output_filename = arg;
#line 480
    goto switch_break;
    case_113: /* CIL Label */ 
#line 481
    verbosity = -1;
#line 481
    goto switch_break;
    case_116: /* CIL Label */ 
#line 482
    testing = (_Bool)1;
#line 482
    goto switch_break;
    case_118: /* CIL Label */ 
#line 483
    if (verbosity < 4) {
#line 483
      verbosity ++;
    }
#line 483
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 484
    show_version();
    }
#line 484
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 485
    internal_error((char const   */* const  */)"uncaught option");
    }
    switch_break: /* CIL Label */ ;
    }
#line 468
    argind ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  if (testing) {
#line 495
    outfd = -1;
  }
  {
#line 497
  tmp___7 = ap_arguments((struct Arg_parser  const  */* const  */)(& parser));
  }
#line 497
  if (1 >= tmp___7 - argind) {
#line 497
    num_filenames = 1;
  } else {
    {
#line 497
    tmp___6 = ap_arguments((struct Arg_parser  const  */* const  */)(& parser));
#line 497
    num_filenames = tmp___6 - argind;
    }
  }
  {
#line 498
  tmp___8 = resize_buffer((void *)filenames, (int const   )((unsigned long )num_filenames * sizeof(*(filenames + 0))));
#line 498
  filenames = (char const   **)tmp___8;
#line 499
  *(filenames + 0) = "-";
#line 501
  i = 0;
  }
  {
#line 501
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 501
    tmp___10 = ap_arguments((struct Arg_parser  const  */* const  */)(& parser));
    }
#line 501
    if (! (argind + i < tmp___10)) {
#line 501
      goto while_break___0;
    }
    {
#line 503
    *(filenames + i) = ap_argument((struct Arg_parser  const  */* const  */)(& parser),
                                   (int const   )(argind + i));
#line 504
    tmp___9 = strcmp(*(filenames + i), "-");
    }
#line 504
    if (tmp___9 != 0) {
#line 504
      filenames_given = (_Bool)1;
    }
#line 501
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 507
  if (! to_stdout) {
#line 507
    if (! testing) {
#line 507
      if (filenames_given) {
        {
#line 509
        set_signals();
        }
      } else
#line 507
      if (*(default_output_filename + 0)) {
        {
#line 509
        set_signals();
        }
      }
    }
  }
  {
#line 511
  Pp_init((struct Pretty_print */* const  */)(& pp), (char const   * const  *)filenames,
          (int const   )num_filenames, (int const   )verbosity);
#line 513
  tmp___11 = resize_buffer((void *)output_filename, (int const   )1);
#line 513
  output_filename = (char *)tmp___11;
#line 514
  i = 0;
  }
  {
#line 514
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 514
    if (! (i < num_filenames)) {
#line 514
      goto while_break___1;
    }
#line 519
    *(output_filename + 0) = (char)0;
#line 521
    if (! *(*(filenames + i) + 0)) {
#line 521
      goto _L;
    } else {
      {
#line 521
      tmp___18 = strcmp(*(filenames + i), "-");
      }
#line 521
      if (tmp___18 == 0) {
        _L: /* CIL Label */ 
#line 523
        input_filename = "";
#line 524
        infd = 0;
#line 525
        if (! testing) {
#line 527
          if (to_stdout) {
#line 528
            outfd = 1;
          } else
#line 527
          if (! *(default_output_filename + 0)) {
#line 528
            outfd = 1;
          } else {
            {
#line 531
            tmp___13 = strlen(default_output_filename);
#line 531
            tmp___14 = resize_buffer((void *)output_filename, (int const   )(tmp___13 + 1UL));
#line 531
            output_filename = (char *)tmp___14;
#line 533
            strcpy((char */* __restrict  */)output_filename, (char const   */* __restrict  */)default_output_filename);
#line 534
            outfd_mode = (mode_t )all_rw;
#line 535
            tmp___15 = open_outstream((_Bool const   )force);
            }
#line 535
            if (! tmp___15) {
#line 537
              if (retval < 1) {
#line 537
                retval = 1;
              }
              {
#line 538
              close(infd);
#line 538
              infd = -1;
              }
#line 539
              goto __Cont;
            }
          }
        }
      } else {
        {
#line 546
        input_filename = *(filenames + i);
#line 547
        infd = open_instream((char const   */* const  */)input_filename, (struct stat */* const  */)(& in_stats),
                             (_Bool const   )to_stdout);
        }
#line 548
        if (infd < 0) {
#line 548
          if (retval < 1) {
#line 548
            retval = 1;
          }
#line 548
          goto __Cont;
        }
#line 549
        if (! testing) {
#line 551
          if (to_stdout) {
#line 551
            outfd = 1;
          } else {
            {
#line 554
            tmp___16 = extension_index((char const   */* const  */)input_filename);
#line 554
            set_d_outname((char const   */* const  */)input_filename, (int const   )tmp___16);
#line 555
            outfd_mode = (mode_t )usr_rw;
#line 556
            tmp___17 = open_outstream((_Bool const   )force);
            }
#line 556
            if (! tmp___17) {
#line 558
              if (retval < 1) {
#line 558
                retval = 1;
              }
              {
#line 559
              close(infd);
#line 559
              infd = -1;
              }
#line 560
              goto __Cont;
            }
          }
        }
      }
    }
    {
#line 566
    tmp___19 = isatty(infd);
    }
#line 566
    if (tmp___19) {
      {
#line 568
      show_error((char const   */* const  */)"I won\'t read compressed data from a terminal.",
                 (int const   )0, (_Bool const   )1);
      }
#line 569
      return (1);
    }
#line 572
    if (*(output_filename + 0)) {
#line 572
      if (! to_stdout) {
#line 572
        if (! testing) {
#line 573
          delete_output_on_interrupt = (_Bool)1;
        }
      }
    }
#line 574
    if (*(input_filename + 0)) {
#line 574
      in_statsp = (struct stat  const  *)(& in_stats);
    } else {
#line 574
      in_statsp = (struct stat  const  *)0;
    }
    {
#line 575
    Pp_set_name((struct Pretty_print */* const  */)(& pp), (char const   */* const  */)input_filename);
#line 576
    tmp___12 = decompress((int const   )infd, (struct Pretty_print */* const  */)(& pp),
                          (_Bool const   )testing);
    }
#line 577
    if (tmp___12 > retval) {
#line 577
      retval = tmp___12;
    }
#line 578
    if (tmp___12) {
#line 578
      if (! testing) {
        {
#line 578
        cleanup_and_fail((int const   )retval);
        }
      }
    }
#line 580
    if (delete_output_on_interrupt) {
      {
#line 581
      close_and_set_permissions((struct stat  const  */* const  */)in_statsp);
      }
    }
#line 582
    if (*(input_filename + 0)) {
      {
#line 584
      close(infd);
#line 584
      infd = -1;
      }
#line 585
      if (! keep_input_files) {
#line 585
        if (! to_stdout) {
#line 585
          if (! testing) {
            {
#line 586
            remove(input_filename);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 514
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 589
  if (outfd >= 0) {
    {
#line 589
    tmp___21 = close(outfd);
    }
#line 589
    if (tmp___21 != 0) {
      {
#line 591
      tmp___20 = __errno_location();
#line 591
      show_error((char const   */* const  */)"Can\'t close stdout", (int const   )*tmp___20,
                 (_Bool const   )0);
      }
#line 592
      if (retval < 1) {
#line 592
        retval = 1;
      }
    }
  }
  {
#line 594
  free((void *)output_filename);
#line 595
  free((void *)filenames);
#line 596
  ap_free((struct Arg_parser */* const  */)(& parser));
  }
#line 597
  return (retval);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 36 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
static void *ap_resize_buffer(void *buf , int const   min_size ) 
{ 


  {
#line 38
  if (buf) {
    {
#line 38
    buf = realloc(buf, (size_t )min_size);
    }
  } else {
    {
#line 39
    buf = malloc((size_t )min_size);
    }
  }
#line 40
  return (buf);
}
}
#line 44 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
static char push_back_record(struct Arg_parser * const  ap , int const   code , char const   * const  argument ) 
{ 
  int len ;
  size_t tmp ;
  struct ap_Record *p ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 47
  tmp = strlen((char const   *)argument);
#line 47
  len = (int )tmp;
#line 49
  tmp___1 = ap_resize_buffer((void *)ap->data, (int const   )((unsigned long )(ap->data_size + 1) * sizeof(struct ap_Record )));
#line 49
  tmp___0 = tmp___1;
  }
#line 51
  if (! tmp___0) {
#line 51
    return ((char)0);
  }
  {
#line 52
  ap->data = (struct ap_Record *)tmp___0;
#line 53
  p = ap->data + ap->data_size;
#line 54
  p->code = (int )code;
#line 55
  p->argument = (char *)0;
#line 56
  tmp___0 = ap_resize_buffer((void *)p->argument, (int const   )(len + 1));
  }
#line 57
  if (! tmp___0) {
#line 57
    return ((char)0);
  }
  {
#line 58
  p->argument = (char *)tmp___0;
#line 59
  strncpy((char */* __restrict  */)p->argument, (char const   */* __restrict  */)argument,
          (size_t )(len + 1));
#line 60
  (ap->data_size) ++;
  }
#line 61
  return ((char)1);
}
}
#line 65 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
static char add_error(struct Arg_parser * const  ap , char const   * const  msg ) 
{ 
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 67
  tmp = strlen((char const   *)msg);
#line 67
  len = (int )tmp;
#line 68
  tmp___1 = ap_resize_buffer((void *)ap->error, (int const   )((ap->error_size + len) + 1));
#line 68
  tmp___0 = tmp___1;
  }
#line 69
  if (! tmp___0) {
#line 69
    return ((char)0);
  }
  {
#line 70
  ap->error = (char *)tmp___0;
#line 71
  strncpy((char */* __restrict  */)(ap->error + ap->error_size), (char const   */* __restrict  */)msg,
          (size_t )(len + 1));
#line 72
  ap->error_size += len;
  }
#line 73
  return ((char)1);
}
}
#line 77 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
static void free_data(struct Arg_parser * const  ap ) 
{ 
  int i ;

  {
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < ap->data_size)) {
#line 80
      goto while_break;
    }
    {
#line 80
    free((void *)(ap->data + i)->argument);
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (ap->data) {
    {
#line 81
    free((void *)ap->data);
#line 81
    ap->data = (struct ap_Record *)0;
    }
  }
#line 82
  ap->data_size = 0;
#line 83
  return;
}
}
#line 86 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
static char parse_long_option(struct Arg_parser * const  ap , char const   * const  opt ,
                              char const   * const  arg , struct ap_Option  const  *options ,
                              int * const  argindp ) 
{ 
  unsigned int len ;
  int index___0 ;
  int i ;
  char exact ;
  char ambig ;
  size_t tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;

  {
#line 92
  index___0 = -1;
#line 94
  exact = (char)0;
#line 94
  ambig = (char)0;
#line 96
  len = 0U;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (*(opt + (len + 2U))) {
#line 96
      if (! ((int const   )*(opt + (len + 2U)) != 61)) {
#line 96
        goto while_break;
      }
    } else {
#line 96
      goto while_break;
    }
#line 96
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! ((options + i)->code != 0)) {
#line 99
      goto while_break___0;
    }
#line 100
    if ((options + i)->name) {
      {
#line 100
      tmp___0 = strncmp((char const   *)(options + i)->name, opt + 2, (size_t )len);
      }
#line 100
      if (! tmp___0) {
        {
#line 102
        tmp = strlen((char const   *)(options + i)->name);
        }
#line 102
        if (tmp == (size_t )len) {
#line 103
          index___0 = i;
#line 103
          exact = (char)1;
#line 103
          goto while_break___0;
        } else
#line 104
        if (index___0 < 0) {
#line 104
          index___0 = i;
        } else
#line 105
        if ((options + index___0)->code != (options + i)->code) {
#line 107
          ambig = (char)1;
        } else
#line 105
        if ((unsigned int const   )(options + index___0)->has_arg != (unsigned int const   )(options + i)->has_arg) {
#line 107
          ambig = (char)1;
        }
      }
    }
#line 99
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  if (ambig) {
#line 110
    if (! exact) {
      {
#line 112
      add_error(ap, (char const   */* const  */)"option \'");
#line 112
      add_error(ap, opt);
#line 113
      add_error(ap, (char const   */* const  */)"\' is ambiguous");
      }
#line 114
      return ((char)1);
    }
  }
#line 117
  if (index___0 < 0) {
    {
#line 119
    add_error(ap, (char const   */* const  */)"unrecognized option \'");
#line 119
    add_error(ap, opt);
#line 120
    add_error(ap, (char const   */* const  */)"\'");
    }
#line 121
    return ((char)1);
  }
#line 124
  (*argindp) ++;
#line 126
  if (*(opt + (len + 2U))) {
#line 128
    if ((unsigned int const   )(options + index___0)->has_arg == 0U) {
      {
#line 130
      add_error(ap, (char const   */* const  */)"option \'--");
#line 130
      add_error(ap, (options + index___0)->name);
#line 131
      add_error(ap, (char const   */* const  */)"\' doesn\'t allow an argument");
      }
#line 132
      return ((char)1);
    }
#line 134
    if ((unsigned int const   )(options + index___0)->has_arg == 1U) {
#line 134
      if (! *(opt + (len + 3U))) {
        {
#line 136
        add_error(ap, (char const   */* const  */)"option \'--");
#line 136
        add_error(ap, (options + index___0)->name);
#line 137
        add_error(ap, (char const   */* const  */)"\' requires an argument");
        }
#line 138
        return ((char)1);
      }
    }
    {
#line 140
    tmp___1 = push_back_record(ap, (options + index___0)->code, (char const   */* const  */)(opt + (len + 3U)));
    }
#line 140
    return (tmp___1);
  }
#line 143
  if ((unsigned int const   )(options + index___0)->has_arg == 1U) {
#line 145
    if (! arg) {
      {
#line 147
      add_error(ap, (char const   */* const  */)"option \'--");
#line 147
      add_error(ap, (options + index___0)->name);
#line 148
      add_error(ap, (char const   */* const  */)"\' requires an argument");
      }
#line 149
      return ((char)1);
    } else
#line 145
    if (! *(arg + 0)) {
      {
#line 147
      add_error(ap, (char const   */* const  */)"option \'--");
#line 147
      add_error(ap, (options + index___0)->name);
#line 148
      add_error(ap, (char const   */* const  */)"\' requires an argument");
      }
#line 149
      return ((char)1);
    }
    {
#line 151
    (*argindp) ++;
#line 152
    tmp___2 = push_back_record(ap, (options + index___0)->code, arg);
    }
#line 152
    return (tmp___2);
  }
  {
#line 155
  tmp___3 = push_back_record(ap, (options + index___0)->code, (char const   */* const  */)"");
  }
#line 155
  return (tmp___3);
}
}
#line 159 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
static char parse_short_option(struct Arg_parser * const  ap , char const   * const  opt ,
                               char const   * const  arg , struct ap_Option  const  *options ,
                               int * const  argindp ) 
{ 
  int cind ;
  int index___0 ;
  int i ;
  unsigned char code ;
  char code_str[2] ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 164
  cind = 1;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (cind > 0)) {
#line 166
      goto while_break;
    }
#line 168
    index___0 = -1;
#line 170
    code = (unsigned char )*(opt + cind);
#line 172
    code_str[0] = (char )code;
#line 172
    code_str[1] = (char)0;
#line 174
    if ((int )code != 0) {
#line 175
      i = 0;
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (options + i)->code) {
#line 175
          goto while_break___0;
        }
#line 176
        if ((int )code == (int )(options + i)->code) {
#line 177
          index___0 = i;
#line 177
          goto while_break___0;
        }
#line 175
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 179
    if (index___0 < 0) {
      {
#line 181
      add_error(ap, (char const   */* const  */)"invalid option -- ");
#line 181
      add_error(ap, (char const   */* const  */)(code_str));
      }
#line 182
      return ((char)1);
    }
#line 185
    cind ++;
#line 185
    if ((int const   )*(opt + cind) == 0) {
#line 185
      (*argindp) ++;
#line 185
      cind = 0;
    }
#line 187
    if ((unsigned int const   )(options + index___0)->has_arg != 0U) {
#line 187
      if (cind > 0) {
#line 187
        if (*(opt + cind)) {
          {
#line 189
          tmp = push_back_record(ap, (int const   )code, (char const   */* const  */)(opt + cind));
          }
#line 189
          if (! tmp) {
#line 189
            return ((char)0);
          }
#line 190
          (*argindp) ++;
#line 190
          cind = 0;
        } else {
#line 187
          goto _L___0;
        }
      } else {
#line 187
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 192
    if ((unsigned int const   )(options + index___0)->has_arg == 1U) {
#line 194
      if (! arg) {
        {
#line 196
        add_error(ap, (char const   */* const  */)"option requires an argument -- ");
#line 197
        add_error(ap, (char const   */* const  */)(code_str));
        }
#line 198
        return ((char)1);
      } else
#line 194
      if (! *(arg + 0)) {
        {
#line 196
        add_error(ap, (char const   */* const  */)"option requires an argument -- ");
#line 197
        add_error(ap, (char const   */* const  */)(code_str));
        }
#line 198
        return ((char)1);
      }
      {
#line 200
      (*argindp) ++;
#line 200
      cind = 0;
#line 201
      tmp___0 = push_back_record(ap, (int const   )code, arg);
      }
#line 201
      if (! tmp___0) {
#line 201
        return ((char)0);
      }
    } else {
      {
#line 203
      tmp___1 = push_back_record(ap, (int const   )code, (char const   */* const  */)"");
      }
#line 203
      if (! tmp___1) {
#line 203
        return ((char)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char)1);
}
}
#line 209 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
char ap_init(struct Arg_parser * const  ap , int const   argc , char const   * const  *argv ,
             struct ap_Option  const  *options , char const   in_order ) 
{ 
  char const   **non_options ;
  int non_options_size ;
  int argind ;
  int i ;
  unsigned char ch1 ;
  unsigned char ch2 ;
  int tmp ;
  char const   *opt ;
  char const   *arg ;
  char const   *tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  char tmp___11 ;

  {
#line 213
  non_options = (char const   **)0;
#line 214
  non_options_size = 0;
#line 215
  argind = 1;
#line 218
  ap->data = (struct ap_Record *)0;
#line 219
  ap->error = (char *)0;
#line 220
  ap->data_size = 0;
#line 221
  ap->error_size = 0;
#line 222
  if (argc < 2) {
#line 222
    return ((char)1);
  } else
#line 222
  if (! argv) {
#line 222
    return ((char)1);
  } else
#line 222
  if (! options) {
#line 222
    return ((char)1);
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (argind < (int )argc)) {
#line 224
      goto while_break;
    }
#line 226
    ch1 = (unsigned char )*(*(argv + argind) + 0);
#line 227
    if (ch1) {
#line 227
      tmp = (int const   )*(*(argv + argind) + 1);
    } else {
#line 227
      tmp = (int const   )0;
    }
#line 227
    ch2 = (unsigned char )tmp;
#line 229
    if ((int )ch1 == 45) {
#line 229
      if (ch2) {
#line 231
        opt = (char const   *)*(argv + argind);
#line 232
        if (argind + 1 < (int )argc) {
#line 232
          tmp___0 = *(argv + (argind + 1));
        } else {
#line 232
          tmp___0 = (char const   */* const  */)0;
        }
#line 232
        arg = (char const   *)tmp___0;
#line 233
        if ((int )ch2 == 45) {
#line 235
          if (! *(*(argv + argind) + 2)) {
#line 235
            argind ++;
#line 235
            goto while_break;
          } else {
            {
#line 236
            tmp___1 = parse_long_option(ap, (char const   */* const  */)opt, (char const   */* const  */)arg,
                                        options, (int */* const  */)(& argind));
            }
#line 236
            if (! tmp___1) {
#line 236
              return ((char)0);
            }
          }
        } else {
          {
#line 238
          tmp___2 = parse_short_option(ap, (char const   */* const  */)opt, (char const   */* const  */)arg,
                                       options, (int */* const  */)(& argind));
          }
#line 238
          if (! tmp___2) {
#line 238
            return ((char)0);
          }
        }
#line 239
        if (ap->error) {
#line 239
          goto while_break;
        }
      } else {
#line 229
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 243
    if (! in_order) {
      {
#line 245
      tmp___4 = ap_resize_buffer((void *)non_options, (int const   )((unsigned long )(non_options_size + 1) * sizeof(*non_options)));
#line 245
      tmp___3 = tmp___4;
      }
#line 247
      if (! tmp___3) {
#line 247
        return ((char)0);
      }
#line 248
      non_options = (char const   **)tmp___3;
#line 249
      tmp___5 = non_options_size;
#line 249
      non_options_size ++;
#line 249
      tmp___6 = argind;
#line 249
      argind ++;
#line 249
      *(non_options + tmp___5) = (char const   *)*(argv + tmp___6);
    } else {
      {
#line 251
      tmp___7 = argind;
#line 251
      argind ++;
#line 251
      tmp___8 = push_back_record(ap, (int const   )0, *(argv + tmp___7));
      }
#line 251
      if (! tmp___8) {
#line 251
        return ((char)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (ap->error) {
    {
#line 254
    free_data(ap);
    }
  } else {
#line 257
    i = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (i < non_options_size)) {
#line 257
        goto while_break___0;
      }
      {
#line 258
      tmp___9 = push_back_record(ap, (int const   )0, (char const   */* const  */)*(non_options + i));
      }
#line 258
      if (! tmp___9) {
#line 258
        return ((char)0);
      }
#line 257
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 259
      if (! (argind < (int )argc)) {
#line 259
        goto while_break___1;
      }
      {
#line 260
      tmp___10 = argind;
#line 260
      argind ++;
#line 260
      tmp___11 = push_back_record(ap, (int const   )0, *(argv + tmp___10));
      }
#line 260
      if (! tmp___11) {
#line 260
        return ((char)0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 262
  if (non_options) {
    {
#line 262
    free((void *)non_options);
    }
  }
#line 263
  return ((char)1);
}
}
#line 267 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
void ap_free(struct Arg_parser * const  ap ) 
{ 


  {
  {
#line 269
  free_data(ap);
  }
#line 270
  if (ap->error) {
    {
#line 270
    free((void *)ap->error);
#line 270
    ap->error = (char *)0;
    }
  }
#line 271
  ap->error_size = 0;
#line 272
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
char const   *ap_error(struct Arg_parser  const  * const  ap ) 
{ 


  {
#line 276
  return ((char const   *)ap->error);
}
}
#line 279 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
int ap_arguments(struct Arg_parser  const  * const  ap ) 
{ 


  {
#line 280
  return ((int )ap->data_size);
}
}
#line 283 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
int ap_code(struct Arg_parser  const  * const  ap , int const   i ) 
{ 
  int tmp ;

  {
#line 285
  if (i >= 0) {
    {
#line 285
    tmp = ap_arguments(ap);
    }
#line 285
    if (i < (int const   )tmp) {
#line 285
      return ((ap->data + i)->code);
    } else {
#line 286
      return (0);
    }
  } else {
#line 286
    return (0);
  }
}
}
#line 290 "/home/wheatley/newnew/temp/lunzip-1.2/carg_parser.c"
char const   *ap_argument(struct Arg_parser  const  * const  ap , int const   i ) 
{ 
  int tmp ;

  {
#line 292
  if (i >= 0) {
    {
#line 292
    tmp = ap_arguments(ap);
    }
#line 292
    if (i < (int const   )tmp) {
#line 292
      return ((char const   *)(ap->data + i)->argument);
    } else {
#line 293
      return ("");
    }
  } else {
#line 293
    return ("");
  }
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 29 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static _Bool St_is_char(State const   st ) 
{ 


  {
#line 29
  return ((_Bool )(st < 7));
}
}
#line 37 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static State St_set_match(State const   st ) 
{ 
  int tmp ;

  {
#line 38
  if (st < 7) {
#line 38
    tmp = 7;
  } else {
#line 38
    tmp = 10;
  }
#line 38
  return (tmp);
}
}
#line 40 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static State St_set_rep(State const   st ) 
{ 
  int tmp ;

  {
#line 41
  if (st < 7) {
#line 41
    tmp = 8;
  } else {
#line 41
    tmp = 11;
  }
#line 41
  return (tmp);
}
}
#line 43 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static State St_set_short_rep(State const   st ) 
{ 
  int tmp ;

  {
#line 44
  if (st < 7) {
#line 44
    tmp = 9;
  } else {
#line 44
    tmp = 11;
  }
#line 44
  return (tmp);
}
}
#line 78 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static int get_dis_state(int const   len ) 
{ 
  int tmp ;

  {
#line 79
  if (len - 2 <= 3) {
#line 79
    tmp = len - 2;
  } else {
#line 79
    tmp = (int const   )3;
  }
#line 79
  return ((int )tmp);
}
}
#line 81 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static int get_lit_state(uint8_t const   prev_byte ) 
{ 


  {
#line 82
  return ((int )((int const   )prev_byte >> 5));
}
}
#line 126 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
CRC32 crc32  ;
#line 144 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void CRC32_update_buf(uint32_t *crc , uint8_t const   * const  buffer ,
                                      int const   size ) 
{ 
  int i ;

  {
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < (int )size)) {
#line 148
      goto while_break;
    }
#line 149
    *crc = crc32[(*crc ^ (unsigned int )*(buffer + i)) & 255U] ^ (*crc >> 8);
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 215 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static int Ft_versioned_size(int const   version ) 
{ 
  int tmp ;

  {
#line 216
  if (version >= 1) {
#line 216
    tmp = 20;
  } else {
#line 216
    tmp = 12;
  }
#line 216
  return (tmp);
}
}
#line 218 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static unsigned int Ft_get_data_crc(uint8_t * const  data ) 
{ 
  unsigned int tmp ;
  int i ;

  {
#line 220
  tmp = 0U;
#line 222
  i = 3;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (i >= 0)) {
#line 222
      goto while_break;
    }
#line 222
    tmp <<= 8;
#line 222
    tmp += (unsigned int )*(data + i);
#line 222
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return (tmp);
}
}
#line 232 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static unsigned long long Ft_get_data_size(uint8_t * const  data ) 
{ 
  unsigned long long tmp ;
  int i ;

  {
#line 234
  tmp = 0ULL;
#line 236
  i = 11;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i >= 4)) {
#line 236
      goto while_break;
    }
#line 236
    tmp <<= 8;
#line 236
    tmp += (unsigned long long )*(data + i);
#line 236
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (tmp);
}
}
#line 246 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static unsigned long long Ft_get_member_size(uint8_t * const  data ) 
{ 
  unsigned long long tmp ;
  int i ;

  {
#line 248
  tmp = 0ULL;
#line 250
  i = 19;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i >= 12)) {
#line 250
      goto while_break;
    }
#line 250
    tmp <<= 8;
#line 250
    tmp += (unsigned long long )*(data + i);
#line 250
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return (tmp);
}
}
#line 254 "/home/wheatley/newnew/temp/lunzip-1.2/lunzip.h"
__inline static void Ft_set_member_size(uint8_t *data , unsigned long long sz ) 
{ 
  int i ;

  {
#line 257
  i = 12;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i <= 19)) {
#line 257
      goto while_break;
    }
#line 257
    *(data + i) = (uint8_t )sz;
#line 257
    sz >>= 8;
#line 257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static uint8_t Rd_get_byte(struct Range_decoder * const  rdec ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 63
  tmp = Rd_finished(rdec);
  }
#line 63
  if (tmp) {
#line 63
    return ((uint8_t )170);
  }
#line 64
  tmp___0 = rdec->pos;
#line 64
  (rdec->pos) ++;
#line 64
  return (*(rdec->buffer + tmp___0));
}
}
#line 81 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void Rd_load(struct Range_decoder * const  rdec ) 
{ 
  int i ;
  uint8_t tmp ;

  {
#line 84
  rdec->code = (uint32_t )0;
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < 5)) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = Rd_get_byte(rdec);
#line 86
    rdec->code = (rdec->code << 8) | (unsigned int )tmp;
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  rdec->range = 4294967295U;
#line 88
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void Rd_normalize(struct Range_decoder * const  rdec ) 
{ 
  uint8_t tmp ;

  {
#line 92
  if (rdec->range <= 16777215U) {
    {
#line 94
    rdec->range <<= 8;
#line 95
    tmp = Rd_get_byte(rdec);
#line 95
    rdec->code = (rdec->code << 8) | (unsigned int )tmp;
    }
  }
#line 97
  return;
}
}
#line 99 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode(struct Range_decoder * const  rdec , int const   num_bits ) 
{ 
  int symbol ;
  int i ;
  uint32_t mask ;

  {
#line 102
  symbol = 0;
#line 104
  i = (int )num_bits;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i > 0)) {
#line 104
      goto while_break;
    }
    {
#line 107
    Rd_normalize(rdec);
#line 108
    rdec->range >>= 1;
#line 111
    mask = 0U - (unsigned int )(rdec->code < rdec->range);
#line 112
    rdec->code -= rdec->range;
#line 113
    rdec->code += rdec->range & mask;
#line 114
    symbol = (int )((uint32_t )(symbol << 1) + (mask + 1U));
#line 104
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (symbol);
}
}
#line 119 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode_bit(struct Range_decoder * const  rdec , Bit_model * const  probability ) 
{ 
  uint32_t bound ;

  {
  {
#line 123
  Rd_normalize(rdec);
#line 124
  bound = (rdec->range >> 11) * (uint32_t )*probability;
  }
#line 125
  if (rdec->code < bound) {
#line 127
    rdec->range = bound;
#line 128
    *probability += (2048 - *probability) >> 5;
#line 129
    return (0);
  } else {
#line 133
    rdec->range -= bound;
#line 134
    rdec->code -= bound;
#line 135
    *probability -= *probability >> 5;
#line 136
    return (1);
  }
}
}
#line 140 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode_tree(struct Range_decoder * const  rdec , Bit_model *bm ,
                                   int const   num_bits ) 
{ 
  int model ;
  int i ;
  int tmp ;

  {
#line 143
  model = 1;
#line 145
  i = (int )num_bits;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i > 0)) {
#line 145
      goto while_break;
    }
    {
#line 146
    tmp = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 146
    model = (model << 1) | tmp;
#line 145
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (model - (1 << num_bits));
}
}
#line 150 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode_tree6(struct Range_decoder * const  rdec , Bit_model *bm ) 
{ 
  int model ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 153
  model = 1;
#line 154
  tmp = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 154
  model = (model << 1) | tmp;
#line 155
  tmp___0 = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 155
  model = (model << 1) | tmp___0;
#line 156
  tmp___1 = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 156
  model = (model << 1) | tmp___1;
#line 157
  tmp___2 = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 157
  model = (model << 1) | tmp___2;
#line 158
  tmp___3 = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 158
  model = (model << 1) | tmp___3;
#line 159
  tmp___4 = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 159
  model = (model << 1) | tmp___4;
  }
#line 160
  return (model - (1 << 6));
}
}
#line 163 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode_tree_reversed(struct Range_decoder * const  rdec , Bit_model *bm ,
                                            int const   num_bits ) 
{ 
  int model ;
  int symbol ;
  int i ;
  _Bool bit ;
  int tmp ;

  {
#line 166
  model = 1;
#line 167
  symbol = 0;
#line 169
  i = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i < (int )num_bits)) {
#line 169
      goto while_break;
    }
    {
#line 171
    tmp = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 171
    bit = (_Bool )tmp;
#line 172
    model <<= 1;
    }
#line 173
    if (bit) {
#line 173
      model ++;
#line 173
      symbol |= 1 << i;
    }
#line 169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (symbol);
}
}
#line 178 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode_tree_reversed4(struct Range_decoder * const  rdec ,
                                             Bit_model *bm ) 
{ 
  int model ;
  int symbol ;
  int bit ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 181
  model = 1;
#line 182
  symbol = 0;
#line 183
  tmp = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 183
  bit = tmp;
#line 184
  model = (model << 1) + bit;
#line 184
  symbol |= bit;
#line 185
  bit = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 186
  model = (model << 1) + bit;
#line 186
  symbol |= bit << 1;
#line 187
  bit = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
#line 188
  model = (model << 1) + bit;
#line 188
  symbol |= bit << 2;
#line 189
  tmp___0 = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + model));
  }
#line 189
  if (tmp___0) {
#line 189
    symbol |= 8;
  }
#line 190
  return (symbol);
}
}
#line 193 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Rd_decode_matched(struct Range_decoder * const  rdec , Bit_model *bm ,
                                      int match_byte ) 
{ 
  Bit_model *bm1 ;
  int symbol ;
  int i ;
  int match_bit ;
  int bit ;
  int tmp ;

  {
#line 196
  bm1 = bm + 256;
#line 197
  symbol = 1;
#line 199
  i = 7;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i >= 0)) {
#line 199
      goto while_break;
    }
    {
#line 202
    match_byte <<= 1;
#line 203
    match_bit = match_byte & 256;
#line 204
    bit = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm1 + (match_bit + symbol)));
#line 205
    symbol = (symbol << 1) | bit;
    }
#line 206
    if (match_bit != bit << 8) {
      {
#line 208
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 208
        if (! (symbol < 256)) {
#line 208
          goto while_break___0;
        }
        {
#line 209
        tmp = Rd_decode_bit(rdec, (Bit_model */* const  */)(bm + symbol));
#line 209
        symbol = (symbol << 1) | tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 210
      goto while_break;
    }
#line 199
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (symbol - 256);
}
}
#line 235 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static int Led_decode(struct Len_decoder * const  len_decoder , struct Range_decoder * const  rdec ,
                               int const   pos_state ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 239
  tmp___0 = Rd_decode_bit(rdec, (Bit_model */* const  */)(& len_decoder->choice1));
  }
#line 239
  if (tmp___0 == 0) {
    {
#line 240
    tmp = Rd_decode_tree(rdec, len_decoder->bm_low[pos_state], (int const   )3);
    }
#line 240
    return (tmp);
  }
  {
#line 241
  tmp___2 = Rd_decode_bit(rdec, (Bit_model */* const  */)(& len_decoder->choice2));
  }
#line 241
  if (tmp___2 == 0) {
    {
#line 242
    tmp___1 = Rd_decode_tree(rdec, len_decoder->bm_mid[pos_state], (int const   )3);
    }
#line 242
    return (8 + tmp___1);
  }
  {
#line 244
  tmp___3 = Rd_decode_tree(rdec, len_decoder->bm_high, (int const   )8);
  }
#line 244
  return (16 + tmp___3);
}
}
#line 277
void LZd_flush_data(struct LZ_decoder * const  decoder ) ;
#line 279
_Bool LZd_verify_trailer(struct LZ_decoder * const  decoder , struct Pretty_print * const  pp ) ;
#line 282 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static uint8_t LZd_get_prev_byte(struct LZ_decoder  const  * const  decoder ) 
{ 
  int i ;
  int tmp ;

  {
#line 284
  if (decoder->pos > 0) {
#line 284
    tmp = decoder->pos;
  } else {
#line 284
    tmp = decoder->buffer_size;
  }
#line 284
  i = (int )(tmp - 1);
#line 286
  return (*(decoder->buffer + i));
}
}
#line 289 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static uint8_t LZd_get_byte(struct LZ_decoder  const  * const  decoder ,
                                     int const   distance ) 
{ 
  int i ;

  {
#line 292
  i = (int )((decoder->pos - distance) - 1);
#line 293
  if (i < 0) {
#line 293
    i += (int )decoder->buffer_size;
  }
#line 294
  return (*(decoder->buffer + i));
}
}
#line 297 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void LZd_put_byte(struct LZ_decoder * const  decoder , uint8_t const   b ) 
{ 


  {
#line 300
  *(decoder->buffer + decoder->pos) = (uint8_t )b;
#line 301
  (decoder->pos) ++;
#line 301
  if (decoder->pos >= decoder->buffer_size) {
    {
#line 301
    LZd_flush_data(decoder);
    }
  }
#line 302
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static void LZd_copy_block(struct LZ_decoder * const  decoder , int const   distance ,
                                    int len ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 307
  i = (decoder->pos - (int )distance) - 1;
#line 308
  if (i < 0) {
#line 308
    i += decoder->buffer_size;
  }
#line 309
  if (decoder->pos >= i) {
#line 309
    tmp = decoder->pos;
  } else {
#line 309
    tmp = i;
  }
#line 309
  if (len < decoder->buffer_size - tmp) {
    {
#line 309
    tmp___0 = abs(decoder->pos - i);
    }
#line 309
    if (len <= tmp___0) {
      {
#line 312
      memcpy((void */* __restrict  */)(decoder->buffer + decoder->pos), (void const   */* __restrict  */)(decoder->buffer + i),
             (size_t )len);
#line 313
      decoder->pos += len;
      }
    } else {
#line 309
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 315
    while (1) {
      while_continue: /* CIL Label */ ;
#line 315
      if (! (len > 0)) {
#line 315
        goto while_break;
      }
#line 317
      *(decoder->buffer + decoder->pos) = *(decoder->buffer + i);
#line 318
      (decoder->pos) ++;
#line 318
      if (decoder->pos >= decoder->buffer_size) {
        {
#line 318
        LZd_flush_data(decoder);
        }
      }
#line 319
      i ++;
#line 319
      if (i >= decoder->buffer_size) {
#line 319
        i = 0;
      }
#line 315
      len --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 321
  return;
}
}
#line 359 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static unsigned int LZd_crc(struct LZ_decoder  const  * const  decoder ) 
{ 


  {
#line 360
  return ((unsigned int )(decoder->crc ^ 4294967295U));
}
}
#line 362 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.h"
__inline static unsigned long long LZd_data_position(struct LZ_decoder  const  * const  decoder ) 
{ 


  {
#line 364
  return ((unsigned long long )(decoder->partial_data_pos + (unsigned long long const   )decoder->pos));
}
}
#line 35 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
void Pp_show_msg(struct Pretty_print * const  pp , char const   * const  msg ) 
{ 
  int i ;
  int len ;
  size_t tmp ;

  {
#line 37
  if (pp->verbosity >= 0) {
#line 39
    if (pp->first_post) {
      {
#line 42
      pp->first_post = (_Bool)0;
#line 43
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: ",
              pp->name);
#line 44
      tmp = strlen(pp->name);
#line 44
      len = (int )((size_t )pp->longest_name - tmp);
#line 45
      i = 0;
      }
      {
#line 45
      while (1) {
        while_continue: /* CIL Label */ ;
#line 45
        if (! (i < len)) {
#line 45
          goto while_break;
        }
        {
#line 45
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 45
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 46
      if (! msg) {
        {
#line 46
        fflush(stderr);
        }
      }
    }
#line 48
    if (msg) {
      {
#line 48
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.\n",
              msg);
      }
    }
  }
#line 50
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
static int readblock(int const   fd , uint8_t * const  buf , int const   size ) 
{ 
  int rest ;
  int *tmp ;
  int n ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  rest = (int )size;
#line 59
  tmp = __errno_location();
#line 59
  *tmp = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (rest > 0)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = read((int )fd, (void *)((buf + size) - rest), (size_t )rest);
#line 62
    n = (int )tmp___0;
    }
#line 63
    if (n > 0) {
#line 63
      rest -= n;
    } else
#line 64
    if (n == 0) {
#line 64
      goto while_break;
    } else {
      {
#line 65
      tmp___1 = __errno_location();
      }
#line 65
      if (*tmp___1 != 4) {
        {
#line 65
        tmp___2 = __errno_location();
        }
#line 65
        if (*tmp___2 != 11) {
#line 65
          goto while_break;
        }
      }
    }
    {
#line 66
    tmp___3 = __errno_location();
#line 66
    *tmp___3 = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return ((int )(size - (int const   )rest));
}
}
#line 75 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
static int writeblock(int const   fd , uint8_t const   * const  buf , int const   size ) 
{ 
  int rest ;
  int *tmp ;
  int n ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 77
  rest = (int )size;
#line 78
  tmp = __errno_location();
#line 78
  *tmp = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (rest > 0)) {
#line 79
      goto while_break;
    }
    {
#line 81
    tmp___0 = write((int )fd, (void const   *)((buf + size) - rest), (size_t )rest);
#line 81
    n = (int )tmp___0;
    }
#line 82
    if (n > 0) {
#line 82
      rest -= n;
    } else
#line 83
    if (n < 0) {
      {
#line 83
      tmp___1 = __errno_location();
      }
#line 83
      if (*tmp___1 != 4) {
        {
#line 83
        tmp___2 = __errno_location();
        }
#line 83
        if (*tmp___2 != 11) {
#line 83
          goto while_break;
        }
      }
    }
    {
#line 84
    tmp___3 = __errno_location();
#line 84
    *tmp___3 = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return ((int )(size - (int const   )rest));
}
}
#line 90 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
_Bool Rd_read_block(struct Range_decoder * const  rdec ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 92
  if (! rdec->at_stream_end) {
    {
#line 94
    rdec->stream_pos = readblock((int const   )rdec->infd, (uint8_t */* const  */)rdec->buffer,
                                 (int const   )16384);
    }
#line 95
    if (rdec->stream_pos != 16384) {
      {
#line 95
      tmp___0 = __errno_location();
      }
#line 95
      if (*tmp___0) {
        {
#line 96
        tmp = __errno_location();
#line 96
        show_error((char const   */* const  */)"Read error", (int const   )*tmp, (_Bool const   )0);
#line 96
        cleanup_and_fail((int const   )1);
        }
      }
    }
#line 97
    rdec->at_stream_end = (_Bool )(rdec->stream_pos < 16384);
#line 98
    rdec->partial_member_pos += (unsigned long long )rdec->pos;
#line 99
    rdec->pos = 0;
  }
#line 101
  return ((_Bool )(rdec->pos < rdec->stream_pos));
}
}
#line 105 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
void LZd_flush_data(struct LZ_decoder * const  decoder ) 
{ 
  int size ;
  int *tmp ;
  int tmp___0 ;

  {
#line 107
  size = decoder->pos - decoder->stream_pos;
#line 108
  if (size > 0) {
    {
#line 110
    CRC32_update_buf(& decoder->crc, (uint8_t const   */* const  */)(decoder->buffer + decoder->stream_pos),
                     (int const   )size);
    }
#line 111
    if (decoder->outfd >= 0) {
      {
#line 111
      tmp___0 = writeblock((int const   )decoder->outfd, (uint8_t const   */* const  */)(decoder->buffer + decoder->stream_pos),
                           (int const   )size);
      }
#line 111
      if (tmp___0 != size) {
        {
#line 113
        tmp = __errno_location();
#line 113
        show_error((char const   */* const  */)"Write error", (int const   )*tmp,
                   (_Bool const   )0);
#line 113
        cleanup_and_fail((int const   )1);
        }
      }
    }
#line 114
    if (decoder->pos >= decoder->buffer_size) {
#line 115
      decoder->partial_data_pos += (unsigned long long )decoder->pos;
#line 115
      decoder->pos = 0;
    }
#line 116
    decoder->stream_pos = decoder->pos;
  }
#line 118
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
_Bool LZd_verify_trailer(struct LZ_decoder * const  decoder , struct Pretty_print * const  pp ) 
{ 
  File_trailer trailer ;
  int trailer_size ;
  int tmp ;
  unsigned long long member_size ;
  unsigned long long tmp___0 ;
  _Bool error ;
  int size ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned long long tmp___7 ;
  unsigned long long tmp___8 ;
  unsigned long long tmp___9 ;
  unsigned long long tmp___10 ;
  unsigned long long tmp___11 ;
  unsigned long long tmp___12 ;
  unsigned long long tmp___13 ;
  unsigned long long tmp___14 ;
  unsigned long long tmp___15 ;
  unsigned long long tmp___16 ;
  unsigned long long tmp___17 ;
  unsigned long long tmp___18 ;
  unsigned long long tmp___19 ;
  unsigned int tmp___20 ;

  {
  {
#line 125
  tmp = Ft_versioned_size((int const   )decoder->member_version);
#line 125
  trailer_size = tmp;
#line 126
  tmp___0 = Rd_member_position((struct Range_decoder  const  */* const  */)decoder->range_decoder);
#line 126
  member_size = tmp___0 + (unsigned long long )trailer_size;
#line 128
  error = (_Bool)0;
#line 130
  tmp___1 = Rd_read_data((struct Range_decoder */* const  */)decoder->range_decoder,
                         (uint8_t */* const  */)(trailer), (int const   )trailer_size);
#line 130
  size = tmp___1;
  }
#line 131
  if (size < trailer_size) {
#line 133
    error = (_Bool)1;
#line 134
    if (pp->verbosity >= 0) {
      {
#line 136
      Pp_show_msg(pp, (char const   */* const  */)0);
#line 137
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trailer truncated at trailer position %d; some checks may fail.\n",
              size);
      }
    }
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! (size < trailer_size)) {
#line 140
        goto while_break;
      }
#line 140
      tmp___2 = size;
#line 140
      size ++;
#line 140
      trailer[tmp___2] = (uint8_t )0;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 142
  if (decoder->member_version == 0) {
    {
#line 142
    Ft_set_member_size((uint8_t *)(trailer), member_size);
    }
  }
#line 143
  if ((decoder->range_decoder)->code != 0U) {
    {
#line 145
    error = (_Bool)1;
#line 146
    Pp_show_msg(pp, (char const   */* const  */)"Range decoder final code is not zero");
    }
  }
  {
#line 148
  tmp___5 = Ft_get_data_crc((uint8_t */* const  */)(trailer));
#line 148
  tmp___6 = LZd_crc((struct LZ_decoder  const  */* const  */)decoder);
  }
#line 148
  if (tmp___5 != tmp___6) {
#line 150
    error = (_Bool)1;
#line 151
    if (pp->verbosity >= 0) {
      {
#line 153
      Pp_show_msg(pp, (char const   */* const  */)0);
#line 154
      tmp___3 = LZd_crc((struct LZ_decoder  const  */* const  */)decoder);
#line 154
      tmp___4 = Ft_get_data_crc((uint8_t */* const  */)(trailer));
#line 154
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC mismatch; trailer says %08X, data CRC is %08X.\n",
              tmp___4, tmp___3);
      }
    }
  }
  {
#line 158
  tmp___10 = Ft_get_data_size((uint8_t */* const  */)(trailer));
#line 158
  tmp___11 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
  }
#line 158
  if (tmp___10 != tmp___11) {
#line 160
    error = (_Bool)1;
#line 161
    if (pp->verbosity >= 0) {
      {
#line 163
      Pp_show_msg(pp, (char const   */* const  */)0);
#line 164
      tmp___7 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
#line 164
      tmp___8 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
#line 164
      tmp___9 = Ft_get_data_size((uint8_t */* const  */)(trailer));
#line 164
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Data size mismatch; trailer says %llu, data size is %llu (0x%llX).\n",
              tmp___9, tmp___8, tmp___7);
      }
    }
  }
  {
#line 168
  tmp___13 = Ft_get_member_size((uint8_t */* const  */)(trailer));
  }
#line 168
  if (tmp___13 != member_size) {
#line 170
    error = (_Bool)1;
#line 171
    if (pp->verbosity >= 0) {
      {
#line 173
      Pp_show_msg(pp, (char const   */* const  */)0);
#line 174
      tmp___12 = Ft_get_member_size((uint8_t */* const  */)(trailer));
#line 174
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Member size mismatch; trailer says %llu, member size is %llu (0x%llX).\n",
              tmp___12, member_size, member_size);
      }
    }
  }
#line 178
  if (! error) {
#line 178
    if (pp->verbosity >= 3) {
      {
#line 178
      tmp___17 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
      }
#line 178
      if (tmp___17 > 0ULL) {
#line 178
        if (member_size > 0ULL) {
          {
#line 179
          tmp___14 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
#line 179
          tmp___15 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
#line 179
          tmp___16 = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
#line 179
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%6.3f:1, %6.3f bits/byte, %5.2f%% saved.  ",
                  (double )tmp___16 / (double )member_size, (8.0 * (double )member_size) / (double )tmp___15,
                  100.0 * (1.0 - (double )member_size / (double )tmp___14));
          }
        }
      }
    }
  }
#line 183
  if (! error) {
#line 183
    if (pp->verbosity >= 4) {
      {
#line 184
      tmp___18 = Ft_get_member_size((uint8_t */* const  */)(trailer));
#line 184
      tmp___19 = Ft_get_data_size((uint8_t */* const  */)(trailer));
#line 184
      tmp___20 = Ft_get_data_crc((uint8_t */* const  */)(trailer));
#line 184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"data CRC %08X, data size %9llu, member size %8llu.  ",
              tmp___20, tmp___19, tmp___18);
      }
    }
  }
#line 187
  return ((_Bool )(! error));
}
}
#line 193 "/home/wheatley/newnew/temp/lunzip-1.2/decoder.c"
int LZd_decode_member(struct LZ_decoder * const  decoder , struct Pretty_print * const  pp ) 
{ 
  unsigned int rep0 ;
  unsigned int rep1 ;
  unsigned int rep2 ;
  unsigned int rep3 ;
  State state ;
  int pos_state ;
  unsigned long long tmp ;
  uint8_t prev_byte ;
  uint8_t tmp___0 ;
  State tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint8_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  int len ;
  unsigned int distance ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int dis_slot ;
  unsigned int rep0_saved ;
  int tmp___14 ;
  int tmp___15 ;
  int direct_bits ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  _Bool tmp___22 ;

  {
  {
#line 196
  rep0 = 0U;
#line 197
  rep1 = 0U;
#line 198
  rep2 = 0U;
#line 199
  rep3 = 0U;
#line 201
  state = 0;
#line 202
  Rd_load((struct Range_decoder */* const  */)decoder->range_decoder);
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 204
    tmp___22 = Rd_finished((struct Range_decoder */* const  */)decoder->range_decoder);
    }
#line 204
    if (tmp___22) {
#line 204
      goto while_break;
    }
    {
#line 206
    tmp = LZd_data_position((struct LZ_decoder  const  */* const  */)decoder);
#line 206
    pos_state = (int )(tmp & 3ULL);
#line 207
    tmp___21 = Rd_decode_bit((struct Range_decoder */* const  */)decoder->range_decoder,
                             (Bit_model */* const  */)(& decoder->bm_match[state][pos_state]));
    }
#line 207
    if (tmp___21 == 0) {
      {
#line 209
      tmp___0 = LZd_get_prev_byte((struct LZ_decoder  const  */* const  */)decoder);
#line 209
      prev_byte = tmp___0;
#line 210
      tmp___8 = St_is_char((State const   )state);
      }
#line 210
      if (tmp___8) {
#line 212
        if (state < 4) {
#line 212
          tmp___1 = state;
        } else {
#line 212
          tmp___1 = 3;
        }
        {
#line 212
        state -= tmp___1;
#line 213
        tmp___2 = get_lit_state((uint8_t const   )prev_byte);
#line 213
        tmp___3 = Rd_decode_tree((struct Range_decoder */* const  */)decoder->range_decoder,
                                 decoder->bm_literal[tmp___2], (int const   )8);
#line 213
        LZd_put_byte(decoder, (uint8_t const   )tmp___3);
        }
      } else {
#line 218
        if (state < 10) {
#line 218
          tmp___4 = 3;
        } else {
#line 218
          tmp___4 = 6;
        }
        {
#line 218
        state -= tmp___4;
#line 219
        tmp___5 = LZd_get_byte((struct LZ_decoder  const  */* const  */)decoder, (int const   )rep0);
#line 219
        tmp___6 = get_lit_state((uint8_t const   )prev_byte);
#line 219
        tmp___7 = Rd_decode_matched((struct Range_decoder */* const  */)decoder->range_decoder,
                                    decoder->bm_literal[tmp___6], (int )tmp___5);
#line 219
        LZd_put_byte(decoder, (uint8_t const   )tmp___7);
        }
      }
    } else {
      {
#line 226
      tmp___20 = Rd_decode_bit((struct Range_decoder */* const  */)decoder->range_decoder,
                               (Bit_model */* const  */)(& decoder->bm_rep[state]));
      }
#line 226
      if (tmp___20 == 1) {
        {
#line 228
        len = 0;
#line 229
        tmp___12 = Rd_decode_bit((struct Range_decoder */* const  */)decoder->range_decoder,
                                 (Bit_model */* const  */)(& decoder->bm_rep0[state]));
        }
#line 229
        if (tmp___12 == 1) {
          {
#line 232
          tmp___10 = Rd_decode_bit((struct Range_decoder */* const  */)decoder->range_decoder,
                                   (Bit_model */* const  */)(& decoder->bm_rep1[state]));
          }
#line 232
          if (tmp___10 == 0) {
#line 233
            distance = rep1;
          } else {
            {
#line 236
            tmp___9 = Rd_decode_bit((struct Range_decoder */* const  */)decoder->range_decoder,
                                    (Bit_model */* const  */)(& decoder->bm_rep2[state]));
            }
#line 236
            if (tmp___9 == 0) {
#line 237
              distance = rep2;
            } else {
#line 238
              distance = rep3;
#line 238
              rep3 = rep2;
            }
#line 239
            rep2 = rep1;
          }
#line 241
          rep1 = rep0;
#line 242
          rep0 = distance;
        } else {
          {
#line 246
          tmp___11 = Rd_decode_bit((struct Range_decoder */* const  */)decoder->range_decoder,
                                   (Bit_model */* const  */)(& decoder->bm_len[state][pos_state]));
          }
#line 246
          if (tmp___11 == 0) {
            {
#line 247
            state = St_set_short_rep((State const   )state);
#line 247
            len = 1;
            }
          }
        }
#line 249
        if (len == 0) {
          {
#line 251
          state = St_set_rep((State const   )state);
#line 252
          tmp___13 = Led_decode((struct Len_decoder */* const  */)(& decoder->rep_match_len_decoder),
                                (struct Range_decoder */* const  */)decoder->range_decoder,
                                (int const   )pos_state);
#line 252
          len = 2 + tmp___13;
          }
        }
      } else {
        {
#line 258
        rep0_saved = rep0;
#line 259
        tmp___14 = Led_decode((struct Len_decoder */* const  */)(& decoder->len_decoder),
                              (struct Range_decoder */* const  */)decoder->range_decoder,
                              (int const   )pos_state);
#line 259
        len = 2 + tmp___14;
#line 260
        tmp___15 = get_dis_state((int const   )len);
#line 260
        dis_slot = Rd_decode_tree6((struct Range_decoder */* const  */)decoder->range_decoder,
                                   decoder->bm_dis_slot[tmp___15]);
        }
#line 261
        if (dis_slot < 4) {
#line 261
          rep0 = (unsigned int )dis_slot;
        } else {
#line 264
          direct_bits = (dis_slot >> 1) - 1;
#line 265
          rep0 = (unsigned int )((2 | (dis_slot & 1)) << direct_bits);
#line 266
          if (dis_slot < 14) {
            {
#line 267
            tmp___16 = Rd_decode_tree_reversed((struct Range_decoder */* const  */)decoder->range_decoder,
                                               ((decoder->bm_dis + rep0) - dis_slot) - 1,
                                               (int const   )direct_bits);
#line 267
            rep0 += (unsigned int )tmp___16;
            }
          } else {
            {
#line 272
            tmp___17 = Rd_decode((struct Range_decoder */* const  */)decoder->range_decoder,
                                 (int const   )(direct_bits - 4));
#line 272
            rep0 += (unsigned int )(tmp___17 << 4);
#line 273
            tmp___18 = Rd_decode_tree_reversed4((struct Range_decoder */* const  */)decoder->range_decoder,
                                                decoder->bm_align);
#line 273
            rep0 += (unsigned int )tmp___18;
            }
#line 274
            if (rep0 == 4294967295U) {
              {
#line 276
              rep0 = rep0_saved;
#line 277
              Rd_normalize((struct Range_decoder */* const  */)decoder->range_decoder);
#line 278
              LZd_flush_data(decoder);
              }
#line 279
              if (len == 2) {
                {
#line 281
                tmp___19 = LZd_verify_trailer(decoder, pp);
                }
#line 281
                if (tmp___19) {
#line 281
                  return (0);
                } else {
#line 281
                  return (3);
                }
              }
#line 283
              if (len == 3) {
                {
#line 285
                Rd_load((struct Range_decoder */* const  */)decoder->range_decoder);
                }
#line 285
                goto while_continue;
              }
#line 287
              if (pp->verbosity >= 0) {
                {
#line 289
                Pp_show_msg(pp, (char const   */* const  */)0);
#line 290
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unsupported marker code \'%d\'.\n",
                        len);
                }
              }
#line 292
              return (4);
            }
          }
        }
        {
#line 296
        rep3 = rep2;
#line 296
        rep2 = rep1;
#line 296
        rep1 = rep0_saved;
#line 297
        state = St_set_match((State const   )state);
        }
#line 298
        if (rep0 >= (unsigned int )decoder->dictionary_size) {
          {
#line 300
          LZd_flush_data(decoder);
          }
#line 300
          return (1);
        } else
#line 298
        if (rep0 >= (unsigned int )decoder->pos) {
#line 298
          if (! decoder->partial_data_pos) {
            {
#line 300
            LZd_flush_data(decoder);
            }
#line 300
            return (1);
          }
        }
      }
      {
#line 302
      LZd_copy_block(decoder, (int const   )rep0, len);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  LZd_flush_data(decoder);
  }
#line 306
  return (2);
}
}
