/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 50 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct trans {
   char action ;
   void *arg ;
};
#line 50 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct state {
   int number ;
   char *seen ;
   struct trans trans[123] ;
   struct state *next ;
};
#line 66 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct user_action {
   char *action ;
   struct user_action *next ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 86 "/home/june/collector/temp/a56-1.3+dfsg/a56.h"
FILE *open_read(char *file ) ;
#line 86
FILE *open_write(char *file ) ;
#line 86
FILE *open_append(char *file ) ;
#line 98
char *alloc(int size ) ;
#line 33 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
FILE *open_read(char *file ) 
{ 
  FILE *fp ;
  int tmp ;

  {
  {
#line 38
  tmp = strcmp((char const   *)file, "-");
  }
#line 38
  if (tmp == 0) {
#line 39
    fp = stdin;
  } else {
    {
#line 40
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
    }
#line 40
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 41
      perror((char const   *)file);
#line 42
      exit(1);
      }
    }
  }
#line 44
  return (fp);
}
}
#line 47 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
FILE *open_write(char *file ) 
{ 
  FILE *fp ;

  {
  {
#line 51
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 51
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 52
    perror((char const   *)file);
#line 53
    exit(1);
    }
  }
#line 55
  return (fp);
}
}
#line 58 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
FILE *open_append(char *file ) 
{ 
  FILE *fp ;

  {
  {
#line 62
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"a");
  }
#line 62
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 63
    perror((char const   *)file);
#line 64
    exit(1);
    }
  }
#line 66
  return (fp);
}
}
#line 69 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
int fatal(char *c , char *a1 , char *a2 , char *a3 , char *a4 , char *a5 , char *a6 ,
          char *a7 , char *a8 ) 
{ 


  {
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)c, a1,
          a2, a3, a4, a5, a6, a7, a8);
#line 73
  exit(1);
  }
}
}
#line 79 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
char tabbuf[256]  ;
#line 79
char *untabn(char *s , int stops ) ;
#line 80 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
char *untab(char *s ) 
{ 
  char *tmp ;

  {
  {
#line 83
  tmp = untabn(s, 8);
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
char *untabn(char *s , int stops ) 
{ 
  char *o ;
  register char *b ;

  {
  {
#line 90
  o = s;
#line 94
  b = tabbuf;
#line 96
  strncpy((char */* __restrict  */)b, (char const   */* __restrict  */)s, (size_t )256);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! *b) {
#line 100
      goto while_break;
    }
#line 101
    if ((int )*b == 9) {
      {
#line 102
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 103
        *s = (char )' ';
#line 102
        s ++;
#line 102
        if (! ((s - o) % (long )stops)) {
#line 102
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 106
      *s = *b;
#line 106
      s ++;
    }
#line 108
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  *s = (char )'\000';
#line 115
  return (o);
}
}
#line 118 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
char *alloc(int size ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 121
  tmp = malloc((size_t )size);
#line 121
  p = (char *)tmp;
  }
#line 122
  if (! p) {
    {
#line 123
    fatal((char *)"alloc:  insufficient virtual memory to allocate %d bytes\n", (char *)size);
    }
  }
#line 125
  return (p);
}
}
#line 135 "/home/june/collector/temp/a56-1.3+dfsg/subs.c"
int a56_strtol(char *s , char **p , int base ) 
{ 
  register long result ;
  register int sign ;
  register int dig ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 139
  result = 0L;
#line 140
  sign = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! ((int )*s == 32)) {
#line 142
      if (! ((int )*s == 9)) {
#line 142
        goto while_break;
      }
    }
#line 143
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if ((int )*s == 45) {
#line 146
    s ++;
#line 147
    sign ++;
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if ((int )*s >= 48) {
#line 150
      if (! ((int )*s <= 57)) {
#line 150
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 150
    if ((int )*s >= 65) {
#line 150
      if (! ((int )*s <= 90)) {
#line 150
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 150
    if ((int )*s >= 97) {
#line 150
      if (! ((int )*s <= 122)) {
#line 150
        goto while_break___0;
      }
    } else {
#line 150
      goto while_break___0;
    }
#line 151
    if ((int )*s >= 97) {
#line 151
      tmp___0 = ((int )*s - 97) + 10;
    } else {
#line 151
      if ((int )*s >= 65) {
#line 151
        tmp = ((int )*s - 65) + 10;
      } else {
#line 151
        tmp = (int )*s - 48;
      }
#line 151
      tmp___0 = tmp;
    }
#line 151
    dig = tmp___0;
#line 152
    if (dig >= base) {
#line 153
      goto while_break___0;
    }
#line 154
    result *= (long )base;
#line 155
    result += (long )dig;
#line 156
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  if (p) {
#line 160
    *p = s;
  }
#line 162
  if (sign) {
#line 162
    tmp___1 = - result;
  } else {
#line 162
    tmp___1 = result;
  }
#line 162
  return ((int )tmp___1);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 638
extern char *gets(char *__s )  __attribute__((__deprecated__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 23 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
char buf[1024]  ;
#line 37
int add_tok(char *tok , char *actions ) ;
#line 42
int dump_machine(void) ;
#line 25 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
int main(void) 
{ 
  int line ;
  char *bp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 27
  line = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 29
    tmp___2 = gets(buf);
    }
#line 29
    if (! tmp___2) {
#line 29
      goto while_break;
    }
#line 30
    bp = buf;
#line 31
    line ++;
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 32
      if ((int )*bp != 9) {
#line 32
        if (! ((int )*bp != 32)) {
#line 32
          goto while_break___0;
        }
      } else {
#line 32
        goto while_break___0;
      }
#line 32
      bp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 33
    tmp = bp;
#line 33
    bp ++;
#line 33
    *tmp = (char )'\000';
    {
#line 34
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 34
      if (! ((int )*bp == 9)) {
#line 34
        if (! ((int )*bp == 32)) {
#line 34
          goto while_break___1;
        }
      }
#line 34
      bp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 35
    tmp___1 = strcmp((char const   *)(buf), ".code");
    }
#line 35
    if (tmp___1 == 0) {
      {
#line 36
      printf((char const   */* __restrict  */)"%s\n", bp);
      }
    } else {
      {
#line 37
      tmp___0 = add_tok(buf, bp);
      }
#line 37
      if (tmp___0 == -1) {
        {
#line 38
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input line %d: ambiguous\n",
                line);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  dump_machine();
  }
#line 43
  return (0);
}
}
#line 50 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct state empty_state  ;
#line 50 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct state *stop  =    (struct state *)((void *)0);
#line 50 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct state *scur  =    (struct state *)((void *)0);
#line 50
struct state *new_state(char *tp ) ;
#line 59 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
int n_states  =    0;
#line 66 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct user_action *utop  =    (struct user_action *)((void *)0);
#line 66 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct user_action *ucur  =    (struct user_action *)((void *)0);
#line 70 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
int n_user_actions  =    0;
#line 88
int follow(char c , char *tp , struct state *sp ) ;
#line 72 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
int add_tok(char *tok , char *actions ) 
{ 
  struct user_action *unew ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 76
  tmp = alloc((int )sizeof(*unew));
#line 76
  unew = (struct user_action *)tmp;
  }
#line 77
  if ((unsigned long )actions != (unsigned long )((void *)0)) {
    {
#line 77
    tmp___0 = strlen((char const   *)actions);
#line 77
    tmp___1 = malloc(tmp___0 + 1UL);
#line 77
    tmp___2 = strcpy((char */* __restrict  */)((char *)tmp___1), (char const   */* __restrict  */)actions);
#line 77
    unew->action = tmp___2;
    }
  } else {
#line 77
    unew->action = (char *)((void *)0);
  }
#line 78
  unew->next = (struct user_action *)((void *)0);
#line 79
  if (ucur) {
#line 80
    ucur->next = unew;
  }
#line 81
  ucur = unew;
#line 82
  if ((unsigned long )utop == (unsigned long )((void *)0)) {
#line 83
    utop = unew;
  }
#line 85
  if ((unsigned long )stop == (unsigned long )((void *)0)) {
    {
#line 86
    new_state((void *)0);
    }
  }
  {
#line 88
  tmp___3 = follow((int )*tok, tok + 1, stop);
  }
#line 88
  if (tmp___3 == -1) {
#line 89
    return (-1);
  }
#line 91
  n_user_actions ++;
#line 92
  return (0);
}
}
#line 95 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
int follow(char c , char *tp , struct state *sp ) 
{ 
  struct trans *arcp ;
  struct trans *arcup ;
  char tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct state *new ;
  struct state *tmp___2 ;
  char tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 102
  if ((int )c >= 97) {
#line 102
    if ((int )c <= 122) {
#line 103
      c = (char )((int )c - 32);
    }
  }
#line 105
  arcp = sp->trans + (int )c;
#line 107
  if ((int )c >= 65) {
#line 107
    if ((int )c <= 90) {
#line 108
      arcup = ((sp->trans + (int )c) + 97) - 65;
    } else {
#line 110
      arcup = arcp;
    }
  } else {
#line 110
    arcup = arcp;
  }
#line 113
  if ((int )c == 0) {
#line 114
    if ((int )arcp->action == 2) {
#line 115
      return (-1);
    } else {
#line 117
      tmp = (char)2;
#line 117
      arcup->action = tmp;
#line 117
      arcp->action = tmp;
#line 118
      tmp___0 = (void *)n_user_actions;
#line 118
      arcup->arg = tmp___0;
#line 118
      arcp->arg = tmp___0;
#line 119
      return (0);
    }
  } else
#line 122
  if ((int )arcp->action == 1) {
    {
#line 123
    tmp___1 = follow(*tp, tp + 1, (struct state *)arcp->arg);
    }
#line 123
    return (tmp___1);
  } else {
    {
#line 125
    tmp___2 = new_state(tp);
#line 125
    new = tmp___2;
#line 126
    tmp___3 = (char)1;
#line 126
    arcup->action = tmp___3;
#line 126
    arcp->action = tmp___3;
#line 127
    tmp___4 = (void *)new;
#line 127
    arcup->arg = tmp___4;
#line 127
    arcp->arg = tmp___4;
#line 128
    tmp___5 = follow(*tp, tp + 1, new);
    }
#line 128
    return (tmp___5);
  }
}
}
#line 133 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
struct state *new_state(char *tp ) 
{ 
  struct state *snew ;
  char *tmp ;
  char tmp___0[1024] ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 136
  tmp = alloc((int )sizeof(*snew));
#line 136
  snew = (struct state *)tmp;
#line 139
  *snew = empty_state;
#line 141
  tmp___1 = n_states;
#line 141
  n_states ++;
#line 141
  snew->number = tmp___1;
#line 143
  snew->next = (struct state *)((void *)0);
  }
#line 145
  if (scur) {
#line 146
    scur->next = snew;
  }
#line 147
  scur = snew;
#line 149
  if ((unsigned long )stop == (unsigned long )((void *)0)) {
#line 150
    stop = snew;
  }
#line 152
  if (tp) {
    {
#line 153
    strncpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)(buf),
            (size_t )(tp - buf));
#line 154
    tmp___0[tp - buf] = (char )'\000';
    }
  } else {
    {
#line 156
    strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"<nothing>");
    }
  }
#line 158
  if ((unsigned long )(tmp___0) != (unsigned long )((void *)0)) {
    {
#line 158
    tmp___2 = strlen((char const   *)(tmp___0));
#line 158
    tmp___3 = malloc(tmp___2 + 1UL);
#line 158
    tmp___4 = strcpy((char */* __restrict  */)((char *)tmp___3), (char const   */* __restrict  */)(tmp___0));
#line 158
    snew->seen = tmp___4;
    }
  } else {
#line 158
    snew->seen = (char *)((void *)0);
  }
#line 160
  return (snew);
}
}
#line 163 "/home/june/collector/temp/a56-1.3+dfsg/keybld.c"
int dump_machine(void) 
{ 
  struct state *sp ;
  struct user_action *up ;
  int n ;
  int a ;
  struct trans *tp ;
  char const   *tmp ;

  {
  {
#line 169
  printf((char const   */* __restrict  */)"/* state machine generated by keybld */\n");
#line 170
  printf((char const   */* __restrict  */)"/* states=%d actions=%d */\n", n_states,
         n_user_actions);
#line 171
  printf((char const   */* __restrict  */)"/* %d bytes required for transition table storage */\n",
         (sizeof(short ) * 123UL) * (unsigned long )n_states);
#line 174
  printf((char const   */* __restrict  */)"short transitions[%d][%d] = {\n", n_states,
         123);
#line 175
  n = 0;
#line 175
  sp = stop;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! sp) {
#line 175
      goto while_break;
    }
    {
#line 176
    printf((char const   */* __restrict  */)"\t/* state %d: \"%s\" */\n", n, sp->seen);
#line 177
    printf((char const   */* __restrict  */)"\t{");
#line 178
    a = 0;
    }
    {
#line 178
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 178
      if (! (a < 123)) {
#line 178
        goto while_break___0;
      }
#line 179
      tp = sp->trans + a;
      {
#line 181
      if ((int )tp->action == 1) {
#line 181
        goto case_1;
      }
#line 184
      if ((int )tp->action == 2) {
#line 184
        goto case_2;
      }
#line 187
      if ((int )tp->action == 0) {
#line 187
        goto case_0;
      }
#line 180
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 182
      printf((char const   */* __restrict  */)"%d", ((struct state *)tp->arg)->number);
      }
#line 183
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 185
      printf((char const   */* __restrict  */)"%d", - ((int )tp->arg) - 1);
      }
#line 186
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 188
      printf((char const   */* __restrict  */)"0");
      }
#line 189
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 191
      if (a % 20 == 19) {
#line 191
        tmp = "\n\t\t";
      } else {
#line 191
        tmp = "";
      }
      {
#line 191
      printf((char const   */* __restrict  */)",%s", tmp);
#line 178
      a ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 193
    printf((char const   */* __restrict  */)"},\n");
#line 175
    sp = sp->next;
#line 175
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  printf((char const   */* __restrict  */)"};\n");
#line 198
  printf((char const   */* __restrict  */)"\nkparse(kp)\nchar *kp;\n{\n\tint state = 0;\n\n\tfor(;;) {\n\t\tshort transition = transitions[state][*kp];\n");
#line 208
  printf((char const   */* __restrict  */)"\t\tif(transition == 0) {\n\t\t\treturn 0;\n\t\t} else if(transition > 0) {\n\t\t\tkp++;\n\t\t\tstate = transition;\n\t\t} else {\n\t\t\tswitch(-transition) {\n");
#line 217
  n = 1;
#line 217
  up = utop;
  }
  {
#line 217
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 217
    if (! up) {
#line 217
      goto while_break___1;
    }
    {
#line 218
    printf((char const   */* __restrict  */)"\t\t\tcase %d:\n\t\t\t\t%s;\n\t\t\t\tbreak;\n",
           n, up->action);
#line 217
    up = up->next;
#line 217
    n ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 224
  printf((char const   */* __restrict  */)"\t\t\t}\n\t\t\treturn transition;\n\t\t}\n\t}\n}\n");
  }
#line 231
  return (0);
}
}
