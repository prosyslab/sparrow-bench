/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 31 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
struct addrmask {
   u_int32_t neta ;
   u_int32_t mask ;
   struct addrmask *next ;
   struct addrmask *prev ;
};
#line 55
enum __anonenum_output_t_32 {
    OUT_STD = 0,
    OUT_CIDR = 1,
    OUT_CISCO = 2,
    OUT_RANGE = 3,
    OUT_HEX = 4,
    OUT_OCTAL = 5,
    OUT_BINARY = 6
} ;
#line 55 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
typedef enum __anonenum_output_t_32 output_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 35 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.h"
int initerrors(char *pn , int type , int stat ) ;
#line 37
int status(char const   *fmt  , ...) ;
#line 40
int warn(char const   *fmt  , ...) ;
#line 43
int panic(char const   *fmt  , ...) ;
#line 47 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static char *progname___0  =    (char *)((void *)0);
#line 49 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static int show_status  =    0;
#line 50 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static int use_syslog  =    0;
#line 52
static int message(int priority , char const   *msg ) ;
#line 54 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
int initerrors(char *pn , int type , int stat ) 
{ 


  {
#line 56
  if (type == 0) {
#line 56
    use_syslog = type;
  } else
#line 56
  if (type == 1) {
#line 56
    use_syslog = type;
  }
#line 58
  if ((unsigned long )pn != (unsigned long )((void *)0)) {
#line 58
    progname___0 = pn;
  }
#line 59
  if (stat == 0) {
#line 59
    show_status = stat;
  } else
#line 59
  if (stat == 1) {
#line 59
    show_status = stat;
  }
#line 60
  return (0);
}
}
#line 64 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static char buf[1024]  ;
#line 63 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
int status(char const   *fmt  , ...) 
{ 
  va_list args ;
  int tmp ;

  {
#line 67
  if (! show_status) {
#line 67
    return (0);
  }
  {
#line 68
  __builtin_va_start(args, fmt);
#line 69
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt, args);
#line 70
  __builtin_va_end(args);
#line 71
  tmp = message(7, (char const   *)(buf));
  }
#line 71
  return (tmp);
}
}
#line 75 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static char buf___0[1024]  ;
#line 74 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
int warn(char const   *fmt  , ...) 
{ 
  va_list args ;
  int tmp ;

  {
  {
#line 78
  __builtin_va_start(args, fmt);
#line 79
  vsprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)fmt,
           args);
#line 80
  __builtin_va_end(args);
#line 81
  tmp = message(4, (char const   *)(buf___0));
  }
#line 81
  return (tmp);
}
}
#line 85 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static char buf___1[1024]  ;
#line 84 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
int panic(char const   *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 88
  __builtin_va_start(args, fmt);
#line 89
  vsprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)fmt,
           args);
#line 90
  __builtin_va_end(args);
#line 91
  message(3, (char const   *)(buf___1));
#line 92
  exit(1);
  }
}
}
#line 95 "/home/wheatley/newnew/temp/netmask-2.3.12/errors.c"
static int message(int priority , char const   *msg ) 
{ 
  char buf___2[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 99
  tmp___2 = __errno_location();
  }
#line 99
  if (*tmp___2) {
#line 99
    if (priority < 5) {
      {
#line 100
      tmp = __errno_location();
#line 100
      tmp___0 = strerror(*tmp);
#line 100
      sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s: %s",
              msg, tmp___0);
#line 101
      tmp___1 = __errno_location();
#line 101
      *tmp___1 = 0;
      }
    } else {
      {
#line 102
      strcpy((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)msg);
      }
    }
  } else {
    {
#line 102
    strcpy((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)msg);
    }
  }
#line 103
  if (use_syslog) {
    {
#line 103
    syslog(priority, "%s", buf___2);
    }
  } else {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            progname___0, buf___2);
    }
  }
#line 105
  return (0);
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 38 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
struct option longopts[14]  = 
#line 38 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
  {      {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"debug", 0, (int *)0, 'd'}, 
        {"standard", 0, (int *)0, 's'}, 
        {"cidr", 0, (int *)0, 'c'}, 
        {"cisco", 0, (int *)0, 'i'}, 
        {"range", 0, (int *)0, 'r'}, 
        {"hex", 0, (int *)0, 'x'}, 
        {"octal", 0, (int *)0, 'o'}, 
        {"binary", 0, (int *)0, 'b'}, 
        {"nodns", 0, (int *)0, 'n'}, 
        {"max", 1, (int *)0, 'M'}, 
        {"min", 1, (int *)0, 'm'}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 59
int spectoaml(char *addrspec , int dns ) ;
#line 60
int display(output_t style ) ;
#line 61
int addtoaml(u_int32_t addr , u_int32_t mask ) ;
#line 62
static u_int32_t mspectou32(char *mstr ) ;
#line 64 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
char version[23]  = 
#line 64
  {      (char )'n',      (char )'e',      (char )'t',      (char )'m', 
        (char )'a',      (char )'s',      (char )'k',      (char )',', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'2',      (char )'.',      (char )'3', 
        (char )'.',      (char )'7',      (char )'\000'};
#line 65 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
char vversion[21]  = 
#line 65
  {      (char )'M',      (char )'a',      (char )'r',      (char )' ', 
        (char )' ',      (char )'4',      (char )' ',      (char )'2', 
        (char )'0',      (char )'1',      (char )'6',      (char )' ', 
        (char )'1',      (char )'5',      (char )':',      (char )'0', 
        (char )'8',      (char )':',      (char )'3',      (char )'7', 
        (char )'\000'};
#line 66 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
char usage[39]  = 
#line 66
  {      (char )'T',      (char )'r',      (char )'y',      (char )' ', 
        (char )'`',      (char )'%',      (char )'s',      (char )' ', 
        (char )'-',      (char )'-',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )'\'',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'m',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 67 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
char *progname  =    (char *)((void *)0);
#line 68 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static struct addrmask *aml  ;
#line 70 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
int main(int argc , char **argv ) 
{ 
  int optc ;
  int h ;
  int v ;
  int debug ;
  int dns ;
  int lose ;
  output_t output ;
  int tmp ;

  {
  {
#line 71
  h = 0;
#line 71
  v = 0;
#line 71
  debug = 0;
#line 71
  dns = 1;
#line 71
  lose = 0;
#line 73
  output = (output_t )1;
#line 75
  progname = *(argv + 0);
#line 76
  initerrors(progname, 0, 0);
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    optc = getopt_long(argc, (char * const  *)argv, "shoxdrvbincM:m:", (struct option  const  *)(longopts),
                       (int *)((void *)0));
    }
#line 77
    if (! (optc != -1)) {
#line 77
      goto while_break;
    }
    {
#line 79
    if (optc == 104) {
#line 79
      goto case_104;
    }
#line 80
    if (optc == 118) {
#line 80
      goto case_118;
    }
#line 81
    if (optc == 110) {
#line 81
      goto case_110;
    }
#line 84
    if (optc == 100) {
#line 84
      goto case_100;
    }
#line 88
    if (optc == 115) {
#line 88
      goto case_115;
    }
#line 89
    if (optc == 99) {
#line 89
      goto case_99;
    }
#line 90
    if (optc == 105) {
#line 90
      goto case_105;
    }
#line 91
    if (optc == 114) {
#line 91
      goto case_114;
    }
#line 92
    if (optc == 120) {
#line 92
      goto case_120;
    }
#line 93
    if (optc == 111) {
#line 93
      goto case_111;
    }
#line 94
    if (optc == 98) {
#line 94
      goto case_98;
    }
#line 95
    goto switch_default;
    case_104: /* CIL Label */ 
#line 79
    h = 1;
#line 79
    goto switch_break;
    case_118: /* CIL Label */ 
#line 80
    v ++;
#line 80
    goto switch_break;
    case_110: /* CIL Label */ 
#line 81
    dns = 0;
#line 81
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 85
    initerrors((char *)((void *)0), -1, 1);
#line 86
    debug = 1;
    }
#line 87
    goto switch_break;
    case_115: /* CIL Label */ 
#line 88
    output = (output_t )0;
#line 88
    goto switch_break;
    case_99: /* CIL Label */ 
#line 89
    output = (output_t )1;
#line 89
    goto switch_break;
    case_105: /* CIL Label */ 
#line 90
    output = (output_t )2;
#line 90
    goto switch_break;
    case_114: /* CIL Label */ 
#line 91
    output = (output_t )3;
#line 91
    goto switch_break;
    case_120: /* CIL Label */ 
#line 92
    output = (output_t )4;
#line 92
    goto switch_break;
    case_111: /* CIL Label */ 
#line 93
    output = (output_t )5;
#line 93
    goto switch_break;
    case_98: /* CIL Label */ 
#line 94
    output = (output_t )6;
#line 94
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 95
    lose = 1;
#line 95
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (v) {
#line 98
    if (v == 1) {
      {
#line 98
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              version);
      }
    } else {
      {
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s, %s\n",
              version, vversion);
      }
    }
#line 100
    if (! h) {
      {
#line 100
      exit(0);
      }
    }
  }
#line 102
  if (h) {
    {
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This is netmask, an address netmask generation utility\nUsage: %s spec [spec ...]\n  -h, --help\t\t\tPrint a summary of the options\n  -v, --version\t\t\tPrint the version number\n  -d, --debug\t\t\tPrint status/progress information\n  -s, --standard\t\tOutput address/netmask pairs\n  -c, --cidr\t\t\tOutput CIDR format address lists\n  -i, --cisco\t\t\tOutput Cisco style address lists\n  -r, --range\t\t\tOutput ip address ranges\n  -x, --hex\t\t\tOutput address/netmask pairs in hex\n  -o, --octal\t\t\tOutput address/netmask pairs in octal\n  -b, --binary\t\t\tOutput address/netmask pairs in binary\n  -n, --nodns\t\t\tDisable DNS lookups for addresses\nDefinitions:\n  a spec can be any of:\n    address\n    address:address\n    address:+address\n    address/mask\n  an address can be any of:\n    N\t\tdecimal number\n    0N\t\toctal number\n    0xN\t\thex number\n    N.N.N.N\tdotted quad\n    hostname\tdns domain name\n  a mask is the number of bits set to one from the left\n",
            progname);
#line 132
    exit(0);
    }
  }
#line 134
  if (lose) {
    {
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage),
            progname);
#line 136
    exit(1);
    }
  } else
#line 134
  if (optind == argc) {
    {
#line 135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(usage),
            progname);
#line 136
    exit(1);
    }
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (! (optind < argc)) {
#line 138
      goto while_break___0;
    }
    {
#line 138
    tmp = optind;
#line 138
    optind ++;
#line 138
    spectoaml(*(argv + tmp), dns);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  display(output);
  }
#line 140
  return (0);
}
}
#line 147
static u_int32_t aspectou32(char *astr , int dns ) ;
#line 148
static int rangetoaml(u_int32_t low , u_int32_t high ) ;
#line 149
static int strtou32(u_int32_t *num , char *istr ) ;
#line 160 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
int spectoaml(char *addrspec , int dns ) 
{ 
  char *sep ;
  u_int32_t addr ;
  u_int32_t addr2 ;
  char *tmp ;
  u_int32_t tmp___0 ;
  u_int32_t mask ;
  char *tmp___1 ;

  {
  {
#line 164
  sep = strchr((char const   *)addrspec, ':');
  }
#line 164
  if ((unsigned long )sep != (unsigned long )((void *)0)) {
    {
#line 167
    tmp = sep;
#line 167
    sep ++;
#line 167
    *tmp = (char )'\000';
#line 168
    addr = aspectou32(addrspec, dns);
    }
#line 169
    if ((int )*sep == 43) {
#line 170
      sep ++;
#line 171
      addr2 = addr;
    } else {
#line 172
      addr2 = (u_int32_t )0;
    }
    {
#line 173
    tmp___0 = aspectou32(sep, dns);
#line 173
    addr2 += tmp___0;
#line 174
    rangetoaml(addr, addr2);
    }
  } else {
    {
#line 175
    sep = strchr((char const   *)addrspec, '/');
    }
#line 175
    if ((unsigned long )sep != (unsigned long )((void *)0)) {
      {
#line 178
      tmp___1 = sep;
#line 178
      sep ++;
#line 178
      *tmp___1 = (char )'\000';
#line 179
      addr = aspectou32(addrspec, dns);
#line 180
      mask = mspectou32(sep);
#line 181
      addtoaml(addr, mask);
      }
    } else {
      {
#line 183
      addr = aspectou32(addrspec, dns);
#line 184
      addtoaml(addr, (u_int32_t )(~ 0));
      }
    }
  }
#line 186
  return (0);
}
}
#line 194 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static u_int32_t aspectou32(char *astr , int dns ) 
{ 
  u_int32_t addr ;
  struct hostent *h ;
  struct in_addr s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 199
  tmp___0 = strtou32(& addr, astr);
  }
#line 199
  if (! tmp___0) {
#line 200
    if (dns) {
      {
#line 200
      h = gethostbyname((char const   *)astr);
      }
#line 200
      if ((unsigned long )h != (unsigned long )((void *)0)) {
        {
#line 201
        addr = ntohl(*((u_int32_t *)*(h->h_addr_list + 0)));
        }
      } else {
#line 200
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 202
      tmp = inet_aton((char const   *)astr, & s);
      }
#line 202
      if (tmp) {
        {
#line 203
        addr = ntohl(s.s_addr);
        }
      } else {
        {
#line 204
        panic("unable to parse \"%s\"", astr);
        }
      }
    }
  }
#line 205
  return (addr);
}
}
#line 212 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static u_int32_t mspectou32(char *mstr ) 
{ 
  u_int32_t mask ;
  u_int32_t num ;
  struct in_addr s ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 213
  mask = (u_int32_t )0;
#line 216
  tmp___0 = strtou32(& num, mstr);
  }
#line 216
  if (tmp___0) {
#line 216
    if (num) {
#line 216
      mask = (u_int32_t )(-1 << (32U - num));
    } else {
#line 216
      mask = num;
    }
  } else {
    {
#line 217
    tmp = inet_aton((char const   *)mstr, & s);
    }
#line 217
    if (tmp) {
      {
#line 218
      mask = ntohl(s.s_addr);
#line 219
      num = ~ mask;
      }
      {
#line 219
      while (1) {
        while_continue: /* CIL Label */ ;
#line 219
        if (! (num & 1U)) {
#line 219
          goto while_break;
        }
#line 219
        num >>= 1;
      }
      while_break: /* CIL Label */ ;
      }
#line 220
      if (num) {
#line 221
        num = mask;
        {
#line 221
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 221
          if (! (num & 1U)) {
#line 221
            goto while_break___0;
          }
#line 221
          num >>= 1;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 222
        if (num) {
          {
#line 222
          panic("invalid mask 0x%08x from \"%s\"", mask, mstr);
          }
        }
#line 223
        mask = ~ mask;
      }
    } else {
      {
#line 225
      panic("unable to parse \"%s\"", mstr);
      }
    }
  }
#line 226
  return (mask);
}
}
#line 234 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int strtou32(u_int32_t *num , char *istr ) 
{ 
  u_int32_t value ;
  u_int32_t base ;
  char *str ;
  char *endp ;
  unsigned long tmp ;

  {
#line 238
  if ((unsigned long )istr == (unsigned long )((void *)0)) {
#line 238
    return (0);
  } else
#line 238
  if ((int )*istr == 0) {
#line 238
    return (0);
  }
#line 239
  if ((int )*(istr + 0) == 48) {
#line 239
    if (*(istr + 1)) {
#line 240
      if ((int )*(istr + 1) == 120) {
#line 240
        if (*(istr + 2)) {
#line 241
          base = (u_int32_t )16;
#line 242
          str = istr + 2;
        } else {
#line 244
          base = (u_int32_t )8;
#line 245
          str = istr + 1;
        }
      } else {
#line 244
        base = (u_int32_t )8;
#line 245
        str = istr + 1;
      }
    } else {
#line 248
      base = (u_int32_t )10;
#line 249
      str = istr;
    }
  } else {
#line 248
    base = (u_int32_t )10;
#line 249
    str = istr;
  }
  {
#line 251
  tmp = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& endp),
                (int )base);
#line 251
  value = (u_int32_t )tmp;
  }
#line 252
  if ((int )*endp != 0) {
#line 252
    return (0);
  }
#line 253
  *num = value;
#line 254
  return (1);
}
}
#line 258 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int rangetoaml(u_int32_t low , u_int32_t high ) 
{ 
  u_int32_t i ;
  u_int32_t j ;
  u_int32_t lxh ;

  {
#line 261
  if (low > high) {
#line 262
    i = low;
#line 263
    low = high;
#line 264
    high = i;
  }
#line 266
  i = low ^ high;
#line 266
  lxh = i;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i & 1U)) {
#line 266
      goto while_break;
    }
#line 266
    i >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (i == 0U) {
#line 267
    if ((low | lxh) == high) {
      {
#line 267
      addtoaml(low, ~ (high - low));
      }
    } else {
#line 267
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 269
    i = lxh;
#line 269
    j = (u_int32_t )0;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! (i >> 1)) {
#line 269
        goto while_break___0;
      }
#line 269
      i >>= 1;
#line 269
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 270
    i <<= j;
#line 271
    i = ~ (i - 1U) & high;
#line 272
    rangetoaml(low, i - 1U);
#line 273
    rangetoaml(i, high);
    }
  }
#line 275
  return (0);
}
}
#line 298
static int optimize(void) ;
#line 305 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
int addtoaml(u_int32_t addr , u_int32_t mask ) 
{ 
  int neta ;
  char first ;
  struct addrmask *cur ;
  struct addrmask *lst ;
  struct addrmask *src ;
  struct addrmask *dst ;
  struct addrmask *old ;
  void *tmp ;
  u_int32_t tmp___0 ;
  u_int32_t tmp___1 ;
  u_int32_t tmp___2 ;
  u_int32_t tmp___3 ;
  int tmp___4 ;

  {
#line 306
  neta = (int )(addr & mask);
#line 307
  first = (char)0;
#line 308
  cur = aml;
#line 308
  lst = (struct addrmask *)((void *)0);
#line 308
  src = (struct addrmask *)((void *)0);
#line 308
  dst = (struct addrmask *)((void *)0);
#line 308
  old = (struct addrmask *)((void *)0);
#line 311
  if ((unsigned long )aml == (unsigned long )((void *)0)) {
#line 312
    first = (char)1;
  } else
#line 311
  if (aml->mask > mask) {
#line 312
    first = (char)1;
  } else
#line 311
  if (aml->mask == mask) {
#line 311
    if (aml->neta > (u_int32_t )neta) {
#line 312
      first = (char)1;
    } else {
#line 311
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 314
    cur = aml;
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      if (cur) {
#line 314
        if (! (cur->mask < mask)) {
#line 314
          if (cur->mask == mask) {
#line 314
            if (! (cur->neta <= (u_int32_t )neta)) {
#line 314
              goto while_break;
            }
          } else {
#line 314
            goto while_break;
          }
        }
      } else {
#line 314
        goto while_break;
      }
#line 316
      if (cur->neta == ((unsigned int )neta & cur->mask)) {
        {
#line 317
        status("skip %08x/%08x (%08x/%08x exists)", neta, mask, cur->neta, cur->mask);
        }
#line 319
        return (0);
      }
#line 314
      lst = cur;
#line 314
      cur = cur->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 321
    dst = lst;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! cur) {
#line 323
      goto while_break___0;
    }
#line 324
    if ((unsigned int )neta == (cur->neta & mask)) {
      {
#line 325
      status("pull %08x/%08x (%08x/%08x added)", cur->neta, cur->mask, neta, mask);
#line 327
      old = cur;
#line 328
      cur = cur->next;
      }
#line 329
      if (old->prev) {
#line 329
        (old->prev)->next = old->next;
      }
#line 330
      if (old->next) {
#line 330
        (old->next)->prev = old->prev;
      }
#line 331
      if ((unsigned long )aml == (unsigned long )old) {
#line 331
        aml = cur;
      }
#line 332
      if (! old->prev) {
#line 332
        if (! old->next) {
#line 333
          cur = (struct addrmask *)((void *)0);
#line 333
          aml = cur;
#line 334
          first = (char)1;
        }
      }
#line 336
      if (! src) {
#line 336
        src = old;
      } else {
        {
#line 337
        free((void *)old);
        }
      }
    } else {
#line 338
      cur = cur->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 340
  if (! src) {
    {
#line 340
    tmp = malloc(sizeof(struct addrmask ));
#line 340
    src = (struct addrmask *)tmp;
    }
#line 340
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      {
#line 341
      panic("malloc failure");
      }
    }
  }
#line 342
  src->neta = (u_int32_t )neta;
#line 343
  src->mask = mask;
#line 344
  if (first) {
#line 345
    if (aml) {
#line 345
      tmp___0 = aml->mask;
    } else {
#line 345
      tmp___0 = (u_int32_t )0;
    }
#line 345
    if (aml) {
#line 345
      tmp___1 = aml->neta;
    } else {
#line 345
      tmp___1 = (u_int32_t )0;
    }
    {
#line 345
    status("add first                   {%08x/%08x}%08x/%08x", neta, mask, tmp___1,
           tmp___0);
#line 347
    src->prev = (struct addrmask *)((void *)0);
#line 348
    src->next = aml;
    }
#line 349
    if (aml) {
#line 349
      aml->prev = src;
    }
#line 350
    aml = src;
  } else
#line 351
  if (dst) {
#line 352
    if (dst->next) {
#line 352
      tmp___2 = (dst->next)->mask;
    } else {
#line 352
      tmp___2 = (u_int32_t )0;
    }
#line 352
    if (dst->next) {
#line 352
      tmp___3 = (dst->next)->neta;
    } else {
#line 352
      tmp___3 = (u_int32_t )0;
    }
    {
#line 352
    status("add middle %08x/%08x{%08x/%08x}%08x/%08x", dst->neta, dst->mask, neta,
           mask, tmp___3, tmp___2);
#line 356
    src->prev = dst;
#line 357
    src->next = dst->next;
#line 358
    dst->next = src;
    }
#line 359
    if (src->next) {
#line 359
      (src->next)->prev = src;
    }
  } else {
    {
#line 361
    status("add last   %08x/%08x{%08x/%08x}", lst->neta, lst->mask, neta, mask);
#line 363
    src->prev = lst;
#line 364
    src->next = (struct addrmask *)((void *)0);
#line 365
    lst->next = src;
    }
  }
  {
#line 367
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 367
    tmp___4 = optimize();
    }
#line 367
    if (! tmp___4) {
#line 367
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 368
  return (0);
}
}
#line 372 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int optimize(void) 
{ 
  struct addrmask *cur ;

  {
#line 375
  cur = aml;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! cur->next) {
#line 375
      goto while_break;
    }
#line 376
    if (cur->mask == (cur->next)->mask) {
#line 376
      if (cur->neta == ((cur->next)->neta & (cur->mask << 1))) {
        {
#line 378
        addtoaml(cur->neta, cur->mask << 1);
        }
#line 379
        return (1);
      }
    }
#line 375
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return (0);
}
}
#line 388
static int dispcidr(struct addrmask *am ) ;
#line 389
static int dispstd(struct addrmask *am ) ;
#line 390
static int dispcisco(struct addrmask *am ) ;
#line 391
static int disprange(struct addrmask *am ) ;
#line 392
static int disphex(struct addrmask *am ) ;
#line 393
static int dispoctal(struct addrmask *am ) ;
#line 394
static int dispbinary(struct addrmask *am ) ;
#line 398 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
int display(output_t style ) 
{ 
  struct addrmask *am ;
  struct addrmask *list ;
  int (*disp)(struct addrmask * ) ;

  {
#line 400
  disp = (int (*)(struct addrmask * ))((void *)0);
  {
#line 403
  if ((unsigned int )style == 0U) {
#line 403
    goto case_0;
  }
#line 404
  if ((unsigned int )style == 1U) {
#line 404
    goto case_1;
  }
#line 405
  if ((unsigned int )style == 2U) {
#line 405
    goto case_2;
  }
#line 406
  if ((unsigned int )style == 3U) {
#line 406
    goto case_3;
  }
#line 407
  if ((unsigned int )style == 4U) {
#line 407
    goto case_4;
  }
#line 408
  if ((unsigned int )style == 5U) {
#line 408
    goto case_5;
  }
#line 409
  if ((unsigned int )style == 6U) {
#line 409
    goto case_6;
  }
#line 410
  goto switch_default;
  case_0: /* CIL Label */ 
#line 403
  disp = & dispstd;
#line 403
  goto switch_break;
  case_1: /* CIL Label */ 
#line 404
  disp = & dispcidr;
#line 404
  goto switch_break;
  case_2: /* CIL Label */ 
#line 405
  disp = & dispcisco;
#line 405
  goto switch_break;
  case_3: /* CIL Label */ 
#line 406
  disp = & disprange;
#line 406
  goto switch_break;
  case_4: /* CIL Label */ 
#line 407
  disp = & disphex;
#line 407
  goto switch_break;
  case_5: /* CIL Label */ 
#line 408
  disp = & dispoctal;
#line 408
  goto switch_break;
  case_6: /* CIL Label */ 
#line 409
  disp = & dispbinary;
#line 409
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 410
  panic("memfrob() apparently called on code segment");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! aml) {
#line 412
      goto while_break;
    }
#line 413
    am = (struct addrmask *)((void *)0);
#line 414
    list = aml;
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (! list) {
#line 414
        goto while_break___0;
      }
#line 415
      if (! am) {
#line 415
        am = list;
      } else
#line 415
      if (am->neta > list->neta) {
#line 415
        am = list;
      }
#line 414
      list = list->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 416
    if (am->next) {
#line 416
      (am->next)->prev = am->prev;
    }
#line 417
    if (am->prev) {
#line 417
      (am->prev)->next = am->next;
    } else {
#line 418
      aml = am->next;
    }
    {
#line 419
    (*disp)(am);
#line 420
    free((void *)am);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return (0);
}
}
#line 425 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int dispcidr(struct addrmask *am ) 
{ 
  u_int32_t mask ;
  int ctr ;
  struct in_addr __constr_expr_0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
#line 427
  ctr = 0;
#line 429
  mask = am->mask;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! mask) {
#line 429
      goto while_break;
    }
#line 429
    ctr ++;
#line 429
    mask <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  tmp = htonl(am->neta);
#line 430
  __constr_expr_0.s_addr = tmp;
#line 430
  tmp___0 = inet_ntoa(__constr_expr_0);
#line 430
  printf((char const   */* __restrict  */)"%15s/%d\n", tmp___0, ctr);
  }
#line 431
  return (0);
}
}
#line 433 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int dispstd(struct addrmask *am ) 
{ 
  char buf___2[32] ;
  struct in_addr __constr_expr_1 ;
  uint32_t tmp ;
  char *tmp___0 ;
  struct in_addr __constr_expr_2 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 436
  tmp = htonl(am->neta);
#line 436
  __constr_expr_1.s_addr = tmp;
#line 436
  tmp___0 = inet_ntoa(__constr_expr_1);
#line 436
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%15s/",
          tmp___0);
#line 437
  tmp___1 = htonl(am->mask);
#line 437
  __constr_expr_2.s_addr = tmp___1;
#line 437
  tmp___2 = inet_ntoa(__constr_expr_2);
#line 437
  sprintf((char */* __restrict  */)(buf___2 + 16), (char const   */* __restrict  */)"%-15s",
          tmp___2);
#line 438
  puts((char const   *)(buf___2));
  }
#line 439
  return (0);
}
}
#line 441 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int dispcisco(struct addrmask *am ) 
{ 
  char buf___2[32] ;
  struct in_addr __constr_expr_3 ;
  uint32_t tmp ;
  char *tmp___0 ;
  struct in_addr __constr_expr_4 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 444
  tmp = htonl(am->neta);
#line 444
  __constr_expr_3.s_addr = tmp;
#line 444
  tmp___0 = inet_ntoa(__constr_expr_3);
#line 444
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%15s ",
          tmp___0);
#line 445
  tmp___1 = htonl(~ am->mask);
#line 445
  __constr_expr_4.s_addr = tmp___1;
#line 445
  tmp___2 = inet_ntoa(__constr_expr_4);
#line 445
  sprintf((char */* __restrict  */)(buf___2 + 16), (char const   */* __restrict  */)"%-15s",
          tmp___2);
#line 446
  puts((char const   *)(buf___2));
  }
#line 447
  return (0);
}
}
#line 449 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int disprange(struct addrmask *am ) 
{ 
  char buf___2[80] ;
  u_int32_t range ;
  struct in_addr __constr_expr_5 ;
  uint32_t tmp ;
  char *tmp___0 ;
  struct in_addr __constr_expr_6 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 451
  range = ~ am->mask + 1U;
#line 453
  tmp = htonl(am->neta);
#line 453
  __constr_expr_5.s_addr = tmp;
#line 453
  tmp___0 = inet_ntoa(__constr_expr_5);
#line 453
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%15s-",
          tmp___0);
#line 454
  tmp___1 = htonl((am->neta + range) - 1U);
#line 454
  __constr_expr_6.s_addr = tmp___1;
#line 454
  tmp___2 = inet_ntoa(__constr_expr_6);
#line 454
  sprintf((char */* __restrict  */)(buf___2 + 16), (char const   */* __restrict  */)"%-15s (%u)",
          tmp___2, range);
#line 456
  puts((char const   *)(buf___2));
  }
#line 457
  return (0);
}
}
#line 459 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int disphex(struct addrmask *am ) 
{ 


  {
  {
#line 460
  printf((char const   */* __restrict  */)"0x%08x/0x%08x\n", am->neta, am->mask);
  }
#line 461
  return (0);
}
}
#line 463 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int dispoctal(struct addrmask *am ) 
{ 


  {
  {
#line 464
  printf((char const   */* __restrict  */)"0%10o/0%10o\n", am->neta, am->mask);
  }
#line 465
  return (0);
}
}
#line 467 "/home/wheatley/newnew/temp/netmask-2.3.12/netmask.c"
static int dispbinary(struct addrmask *am ) 
{ 
  char abuf[36] ;
  char mbuf[36] ;
  int i ;
  int j ;

  {
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (i < 32)) {
#line 471
      goto while_break;
    }
#line 472
    j = 34 - (i * 9) / 8;
#line 473
    if (am->neta & 1U) {
#line 473
      abuf[j] = (char )'1';
    } else {
#line 473
      abuf[j] = (char )'0';
    }
#line 474
    if (am->mask & 1U) {
#line 474
      mbuf[j] = (char )'1';
    } else {
#line 474
      mbuf[j] = (char )'0';
    }
#line 475
    am->neta >>= 1;
#line 476
    am->mask >>= 1;
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 478
  mbuf[26] = (char )' ';
#line 478
  mbuf[17] = mbuf[26];
#line 478
  mbuf[8] = mbuf[17];
#line 478
  abuf[26] = mbuf[8];
#line 478
  abuf[17] = abuf[26];
#line 478
  abuf[8] = abuf[17];
#line 479
  mbuf[35] = (char )'\000';
#line 479
  abuf[35] = mbuf[35];
#line 480
  printf((char const   */* __restrict  */)"%s / %s\n", abuf, mbuf);
  }
#line 481
  return (0);
}
}
