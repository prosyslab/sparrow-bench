/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 22 "/usr/include/linux/input.h"
struct input_event {
   struct timeval time ;
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 82 "/usr/include/glob.h"
struct dirent;
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_32 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , struct stat * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , struct stat * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_32 glob_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.h"
struct connection {
   int fd ;
   void (*process)(int fd ) ;
   char *pathname ;
   int kybd ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
struct evtab_entry {
   struct input_event event ;
   char const   *str ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_18 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_18 fd_set;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 237 "/usr/include/unistd.h"
typedef __uid_t uid_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 311 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_57 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_57 regmatch_t;
#line 47 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
enum __anonenum_type_63 {
    RULE_NONE = 0,
    RULE_CMD = 1,
    RULE_CLIENT = 2
} ;
#line 47 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
union __anonunion_action_64 {
   char *cmd ;
   int fd ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
struct rule {
   enum __anonenum_type_63 type ;
   char *origin ;
   regex_t *event ;
   union __anonunion_action_64 action ;
   struct rule *next ;
   struct rule *prev ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
struct rule_list {
   struct rule *head ;
   struct rule *tail ;
};
#line 702 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 705 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 704 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 701 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 99 "/usr/include/linux/netlink.h"
struct nlmsgerr {
   int error ;
   struct nlmsghdr msg ;
};
#line 149 "/usr/include/linux/rtnetlink.h"
struct rtattr {
   unsigned short rta_len ;
   unsigned short rta_type ;
};
#line 432 "/usr/include/linux/rtnetlink.h"
struct rtgenmsg {
   unsigned char rtgen_family ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.h"
struct rtnl_handle {
   int fd ;
   struct sockaddr_nl local ;
   struct sockaddr_nl peer ;
   __u32 seq ;
   __u32 dump ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
struct __anonstruct_req_75 {
   struct nlmsghdr nlh ;
   struct rtgenmsg g ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
struct inotify_event {
   int wd ;
   uint32_t mask ;
   uint32_t cookie ;
   uint32_t len ;
   char name[] ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/inotify_handler.c"
union __anonunion_eventbuf_13 {
   char buffer[256] ;
   struct inotify_event event ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 11 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/genetlink.h"
struct genlmsghdr {
   __u8 cmd ;
   __u8 version ;
   __u16 reserved ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_genetlink.h"
struct acpi_genl_event {
   char device_class[20] ;
   char bus_id[15] ;
   __u32 type ;
   __u32 data ;
};
#line 168 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
struct __anonstruct_req_69 {
   struct nlmsghdr n ;
   char buf[4096] ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/connection_list.h"
struct connection___0 {
   int fd ;
   void (*process)(int fd ) ;
};
#line 165 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
struct __anonstruct_req_69___0 {
   struct nlmsghdr n ;
   char buf[4096] ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/libnetlink.c"
struct __anonstruct_req_75___0 {
   struct nlmsghdr nlh ;
   struct rtgenmsg g ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 406
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) glob)(char const   * __restrict  __pattern ,
                                                                           int __flags ,
                                                                           int (*__errfunc)(char const   * ,
                                                                                            int  ) ,
                                                                           glob_t * __restrict  __pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.h"
int logevents ;
#line 49
int locked(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/log.h"
int ( /* format attribute */  acpid_log)(int level , char const   *fmt  , ...) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.h"
int add_connection(struct connection *p ) ;
#line 54
void delete_connection(int fd ) ;
#line 60
struct connection *find_connection(int fd ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.h"
int acpid_handle_event(char const   *event ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.h"
void open_input(void) ;
#line 33
int open_inputfile(char const   *filename ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
static struct evtab_entry evtab[48]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
  {      {{{(__time_t )0, (__suseconds_t )0}, (__u16 )1, (__u16 )116, 1}, "button/power PBTN 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )205, 1}, "button/suspend SUSP 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )142, 1}, "button/sleep SBTN 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )0, 1}, "button/lid LID close"}, 
        {{{(__time_t )0, (__suseconds_t )0}, (__u16 )5, (__u16 )0, 0}, "button/lid LID open"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )1, 0}, "video/tabletmode TBLT 0000008A 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )1, 1}, "video/tabletmode TBLT 0000008A 00000001"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )372, 1}, "button/zoom ZOOM 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )224, 1}, "video/brightnessdown BRTDN 00000087 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )225, 1}, "video/brightnessup BRTUP 00000086 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )241, 1}, "video/next NEXT 00000083 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )242, 1}, "video/prev PREV 00000084 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )243, 1}, "video/brightnesscycle BCYC 00000085 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )244, 1}, "video/brightnesszero BZRO 00000088 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )245, 1}, "video/displayoff DOFF 00000089 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )227, 1}, "video/switchmode VMOD 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )114, 1}, "button/volumedown VOLDN 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )115, 1}, "button/volumeup VOLUP 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )113, 1}, "button/mute MUTE 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )248, 1}, "button/micmute MICMUTE 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )163, 1}, "cd/next CDNEXT 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )165, 1}, "cd/prev CDPREV 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )164, 1}, "cd/play CDPLAY 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )166, 1}, "cd/stop CDSTOP 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )2, 0}, "jack/headphone HEADPHONE unplug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )2, 1}, "jack/headphone HEADPHONE plug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )4, 0}, "jack/microphone MICROPHONE unplug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )4, 1}, "jack/microphone MICROPHONE plug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )6, 0}, "jack/lineout LINEOUT unplug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )6, 1}, "jack/lineout LINEOUT plug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )8, 0}, "jack/videoout VIDEOOUT unplug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )8, 1}, "jack/videoout VIDEOOUT plug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )13, 0}, "jack/linein LINEIN unplug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )5, (__u16 )13, 1}, "jack/linein LINEIN plug"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )148, 1}, "button/prog1 PROG1 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )360, 1}, "button/vendor VNDR 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )236, 1}, "button/battery BAT 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )152, 1}, "button/screenlock SCRNLCK 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )152, 1}, "button/coffee CFEE 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )238, 1}, "button/wlan WLAN 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )466, 1}, "button/fnf1 FNF1 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )467, 1}, "button/fnf2 FNF2 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )471, 1}, "button/fnf6 FNF6 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )474, 1}, "button/fnf9 FNF9 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )475, 1}, "button/fnf10 FF10 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )476, 1}, "button/fnf11 FF11 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )194, 1}, "button/f24 F24 00000080 00000000"}, 
        {{{(__time_t )0,
        (__suseconds_t )0}, (__u16 )1, (__u16 )228, 1}, "button/kbdillumtoggle KBILLUM 00000080 00000000"}};
#line 207 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
static char const   *event_string(struct input_event event ) 
{ 
  unsigned int i ;

  {
#line 216
  i = 0U;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! ((unsigned long )i < sizeof(evtab) / sizeof(evtab[0]))) {
#line 216
      goto while_break;
    }
#line 219
    if ((int )event.type == (int )evtab[i].event.type) {
#line 219
      if ((int )event.code == (int )evtab[i].event.code) {
#line 219
        if (event.value == evtab[i].event.value) {
#line 222
          return (evtab[i].str);
        }
      }
    }
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return ((char const   *)((void *)0));
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
static int need_event(int type , int code ) 
{ 
  unsigned int i ;

  {
#line 237
  i = 0U;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! ((unsigned long )i < sizeof(evtab) / sizeof(evtab[0]))) {
#line 237
      goto while_break;
    }
#line 239
    if (type == (int )evtab[i].event.type) {
#line 239
      if (code == (int )evtab[i].event.code) {
#line 241
        return (1);
      }
    }
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (0);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
static int nerrs  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
static void process_input(int fd ) 
{ 
  struct input_event event ;
  ssize_t nbytes ;
  char const   *str ;
  struct connection *c ;
  char str2[100] ;
  long __result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    tmp = read(fd, (void *)(& event), sizeof(event));
#line 259
    __result = tmp;
    }
#line 259
    if (__result == -1L) {
      {
#line 259
      tmp___0 = __errno_location();
      }
#line 259
      if (! (*tmp___0 == 4)) {
#line 259
        goto while_break;
      }
    } else {
#line 259
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  nbytes = __result;
#line 261
  if (nbytes == 0L) {
    {
#line 262
    acpid_log(4, "input layer connection closed");
#line 263
    exit(1);
    }
  }
#line 266
  if (nbytes < 0L) {
    {
#line 267
    tmp___1 = __errno_location();
    }
#line 267
    if (*tmp___1 == 19) {
      {
#line 268
      acpid_log(4, "input device has been disconnected, fd %d", fd);
#line 270
      delete_connection(fd);
      }
#line 271
      return;
    }
    {
#line 273
    tmp___2 = __errno_location();
#line 273
    tmp___3 = __errno_location();
#line 273
    tmp___4 = strerror(*tmp___3);
#line 273
    acpid_log(3, "input layer read error: %s (%d)", tmp___4, *tmp___2);
#line 275
    nerrs ++;
    }
#line 275
    if (nerrs >= 5) {
      {
#line 276
      acpid_log(3, "too many errors reading input layer - aborting");
#line 279
      exit(1);
      }
    }
#line 281
    return;
  }
#line 287
  if ((unsigned long )nbytes != sizeof(event)) {
    {
#line 288
    acpid_log(4, "input layer unexpected length: %zd   expected: %zd", nbytes, sizeof(event));
    }
#line 290
    return;
  }
  {
#line 293
  c = find_connection(fd);
  }
#line 296
  if ((int )event.type == 4) {
#line 296
    if ((int )event.code == 4) {
#line 297
      if (c) {
#line 298
        c->kybd = 1;
      }
    }
  }
  {
#line 302
  str = event_string(event);
  }
#line 304
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 305
    return;
  }
#line 309
  if (c) {
#line 309
    if (c->kybd) {
      {
#line 309
      tmp___5 = strnlen(str, sizeof(str2));
      }
#line 309
      if (tmp___5 <= sizeof(str2) - 3UL) {
        {
#line 310
        strcpy((char */* __restrict  */)(str2), (char const   */* __restrict  */)str);
#line 311
        strcat((char */* __restrict  */)(str2), (char const   */* __restrict  */)" K");
#line 312
        str = (char const   *)(str2);
        }
      }
    }
  }
  {
#line 316
  tmp___6 = locked();
  }
#line 316
  if (tmp___6) {
#line 317
    if (logevents) {
      {
#line 318
      acpid_log(6, "lockfile present, not processing input layer event \"%s\"", str);
      }
    }
#line 322
    return;
  }
#line 325
  if (logevents) {
    {
#line 326
    acpid_log(6, "received input layer event \"%s\"", str);
    }
  }
  {
#line 330
  acpid_handle_event(str);
  }
#line 332
  if (logevents) {
    {
#line 333
    acpid_log(6, "completed input layer event \"%s\"", str);
    }
  }
#line 335
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
static int has_event(int fd ) 
{ 
  int type ;
  int code ;
  unsigned long bit[31][766UL / (sizeof(long ) * 8UL) + 1UL] ;
  int tmp ;

  {
  {
#line 352
  memset((void *)(bit), 0, sizeof(bit));
#line 354
  ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 32U) | (sizeof(bit[0]) << 16),
        bit[0]);
#line 357
  type = 0;
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (type < 31)) {
#line 357
      goto while_break;
    }
#line 359
    if ((bit[0][(unsigned long )type / (sizeof(long ) * 8UL)] >> (unsigned long )type % (sizeof(long ) * 8UL)) & 1UL) {
#line 361
      if (type == 0) {
#line 361
        goto __Cont;
      }
      {
#line 363
      ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | (unsigned int )(32 + type)) | (sizeof(bit[type]) << 16),
            bit[type]);
#line 365
      code = 0;
      }
      {
#line 365
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 365
        if (! (code < 767)) {
#line 365
          goto while_break___0;
        }
#line 367
        if ((bit[type][(unsigned long )code / (sizeof(long ) * 8UL)] >> (unsigned long )code % (sizeof(long ) * 8UL)) & 1UL) {
          {
#line 369
          tmp = need_event(type, code);
          }
#line 369
          if (tmp != 0) {
#line 370
            return (1);
          }
        }
#line 365
        code ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 357
    type ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  return (0);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
int open_inputfile(char const   *filename ) 
{ 
  int fd ;
  struct connection c ;
  char evname[256] ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 387
  fd = open(filename, 526336);
  }
#line 389
  if (fd >= 0) {
    {
#line 393
    tmp = has_event(fd);
    }
#line 393
    if (! tmp) {
      {
#line 394
      close(fd);
      }
#line 395
      return (-1);
    }
    {
#line 399
    strcpy((char */* __restrict  */)(evname), (char const   */* __restrict  */)"Unknown");
#line 400
    ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U) | (sizeof(evname) << 16),
          evname);
#line 402
    acpid_log(7, "input layer %s (%s) opened successfully, fd %d", filename, evname,
              fd);
#line 406
    c.fd = fd;
#line 407
    c.process = & process_input;
#line 409
    tmp___0 = strlen(filename);
#line 409
    tmp___1 = malloc(tmp___0 + 1UL);
#line 409
    c.pathname = (char *)tmp___1;
    }
#line 410
    if (c.pathname) {
      {
#line 411
      strcpy((char */* __restrict  */)c.pathname, (char const   */* __restrict  */)filename);
      }
    }
    {
#line 413
    c.kybd = 0;
#line 415
    tmp___2 = add_connection(& c);
    }
#line 415
    if (tmp___2 < 0) {
      {
#line 416
      close(fd);
#line 417
      acpid_log(3, "can\'t add connection for input layer %s (%s)", filename, evname);
      }
#line 420
      return (-1);
    }
#line 423
    return (0);
  }
#line 427
  return (-1);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/input_layer.c"
void open_input(void) 
{ 
  char *filename ;
  glob_t globbuf ;
  unsigned int i ;
  int success ;
  int tmp ;

  {
  {
#line 434
  filename = (char *)((void *)0);
#line 437
  success = 0;
#line 440
  glob((char const   */* __restrict  */)"/dev/input/event*", 0, (int (*)(char const   * ,
                                                                         int  ))((void *)0),
       (glob_t */* __restrict  */)(& globbuf));
#line 443
  i = 0U;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! ((size_t )i < globbuf.gl_pathc)) {
#line 443
      goto while_break;
    }
    {
#line 444
    filename = *(globbuf.gl_pathv + i);
#line 447
    tmp = open_inputfile((char const   *)filename);
    }
#line 447
    if (tmp == 0) {
#line 448
      success = 1;
    }
#line 443
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (! success) {
    {
#line 452
    acpid_log(3, "cannot open input layer");
    }
  }
  {
#line 454
  globfree(& globbuf);
  }
#line 455
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.h"
struct connection *find_connection_name(char *pathname ) ;
#line 67
int get_number_of_connections(void) ;
#line 70
struct connection *get_connection(int i ) ;
#line 73
fd_set const   *get_fdset(void) ;
#line 76
int get_highestfd(void) ;
#line 79
void delete_all_connections(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
static int capacity  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
static struct connection *connection_list  =    (struct connection *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
static int nconnections  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
static fd_set allfds  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
static int highestfd  =    -2;
#line 54 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
int add_connection(struct connection *p ) 
{ 
  void *tmp ;
  int __d0 ;
  int __d1 ;

  {
#line 57
  if (nconnections < 0) {
#line 58
    return (-1);
  }
#line 61
  if (nconnections >= capacity) {
#line 63
    if (capacity > 1024) {
      {
#line 64
      acpid_log(3, "Too many connections.");
      }
#line 65
      return (-1);
    }
    {
#line 69
    capacity += 20;
#line 70
    tmp = realloc((void *)connection_list, sizeof(struct connection ) * (unsigned long )capacity);
#line 70
    connection_list = (struct connection *)tmp;
    }
  }
#line 74
  if (nconnections == 0) {
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
#line 75
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& allfds.fds_bits[0]): "memory");
#line 75
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 78
  *(connection_list + nconnections) = *p;
#line 79
  nconnections ++;
#line 82
  allfds.fds_bits[p->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << p->fd % (8 * (int )sizeof(__fd_mask ));
#line 83
  if (highestfd > p->fd) {
#line 83
    highestfd = highestfd;
  } else {
#line 83
    highestfd = p->fd;
  }
#line 85
  return (0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
void delete_connection(int fd ) 
{ 
  int i ;

  {
#line 96
  if (fd > 2) {
    {
#line 97
    close(fd);
    }
  }
#line 100
  allfds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < nconnections)) {
#line 102
      goto while_break;
    }
#line 104
    if ((connection_list + i)->fd == fd) {
      {
#line 105
      free((void *)(connection_list + i)->pathname);
#line 107
      nconnections --;
#line 108
      *(connection_list + i) = *(connection_list + nconnections);
      }
#line 110
      goto while_break;
    }
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  highestfd = -2;
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (i < nconnections)) {
#line 118
      goto while_break___0;
    }
#line 119
    if (highestfd > (connection_list + i)->fd) {
#line 119
      highestfd = highestfd;
    } else {
#line 119
      highestfd = (connection_list + i)->fd;
    }
#line 118
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
void delete_all_connections(void) 
{ 


  {
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! nconnections) {
#line 129
      goto while_break;
    }
    {
#line 131
    delete_connection((connection_list + (nconnections - 1))->fd);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  free((void *)connection_list);
#line 135
  connection_list = (struct connection *)((void *)0);
  }
#line 136
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
struct connection *find_connection(int fd ) 
{ 
  int i ;

  {
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < nconnections)) {
#line 146
      goto while_break;
    }
#line 148
    if ((connection_list + i)->fd == fd) {
#line 149
      return (connection_list + i);
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return ((struct connection *)((void *)0));
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
struct connection *find_connection_name(char *pathname ) 
{ 
  int i ;
  int tmp ;

  {
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < nconnections)) {
#line 163
      goto while_break;
    }
#line 165
    if ((unsigned long )(connection_list + i)->pathname == (unsigned long )((void *)0)) {
#line 166
      goto __Cont;
    }
    {
#line 169
    tmp = strcmp((char const   *)(connection_list + i)->pathname, (char const   *)pathname);
    }
#line 169
    if (tmp == 0) {
#line 170
      return (connection_list + i);
    }
    __Cont: /* CIL Label */ 
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return ((struct connection *)((void *)0));
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
int get_number_of_connections(void) 
{ 


  {
#line 181
  return (nconnections);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
struct connection *get_connection(int i ) 
{ 


  {
#line 189
  if (i < 0) {
#line 190
    return ((struct connection *)((void *)0));
  } else
#line 189
  if (i >= nconnections) {
#line 190
    return ((struct connection *)((void *)0));
  }
#line 192
  return (connection_list + i);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
fd_set const   *get_fdset(void) 
{ 


  {
#line 200
  return ((fd_set const   *)(& allfds));
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/connection_list.c"
int get_highestfd(void) 
{ 


  {
#line 208
  return (highestfd);
}
}
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.h"
void clean_exit_with_status(int status ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.h"
int acpid_add_client(int clifd , char const   *origin ) ;
#line 274 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isfdtype)(int __fd ,
                                                                               int __fdtype ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/ud_socket.h"
int ud_create_socket(char const   *name , mode_t socketmode___0 ) ;
#line 12
int ud_accept(int listenfd , struct ucred *cred ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.h"
char const   *socketfile ;
#line 27 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.h"
char const   *socketgroup  ;
#line 28
mode_t socketmode ;
#line 29
int clientmax ;
#line 30 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.h"
int non_root_clients  ;
#line 32
int is_socket(int fd ) ;
#line 33
void open_sock(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
char const   *socketfile  =    "/var/run/acpid.socket";
#line 46 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
mode_t socketmode  =    (mode_t )438;
#line 47 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
int clientmax  =    256;
#line 53 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
int is_socket(int fd ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = isfdtype(fd, 49152);
  }
#line 56
  return (tmp == 1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
static int accept_errors  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
static void process_sock(int fd ) 
{ 
  int cli_fd ;
  struct ucred creds ;
  char *buf___2 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 69
  cli_fd = ud_accept(fd, & creds);
  }
#line 70
  if (cli_fd < 0) {
    {
#line 71
    tmp = __errno_location();
#line 71
    tmp___0 = strerror(*tmp);
#line 71
    acpid_log(3, "can\'t accept client: %s", tmp___0);
#line 73
    accept_errors ++;
    }
#line 74
    if (accept_errors >= 5) {
      {
#line 75
      acpid_log(3, "giving up");
#line 76
      clean_exit_with_status(1);
      }
    }
#line 78
    return;
  }
#line 80
  accept_errors = 0;
#line 83
  if (creds.uid != 0U) {
#line 83
    if (non_root_clients >= clientmax) {
      {
#line 84
      close(cli_fd);
#line 85
      acpid_log(3, "too many non-root clients");
      }
#line 86
      return;
    }
  }
#line 88
  if (creds.uid != 0U) {
#line 89
    non_root_clients ++;
  }
  {
#line 92
  tmp___3 = asprintf((char **/* __restrict  */)(& buf___2), (char const   */* __restrict  */)"%d[%d:%d]",
                     creds.pid, creds.uid, creds.gid);
  }
#line 92
  if (tmp___3 < 0) {
    {
#line 93
    close(cli_fd);
#line 94
    tmp___1 = __errno_location();
#line 94
    tmp___2 = strerror(*tmp___1);
#line 94
    acpid_log(3, "asprintf: %s", tmp___2);
    }
#line 95
    return;
  }
  {
#line 97
  acpid_add_client(cli_fd, (char const   *)buf___2);
#line 98
  free((void *)buf___2);
  }
#line 99
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/sock.c"
void open_sock(void) 
{ 
  int fd ;
  struct connection c ;
  int *tmp ;
  char *tmp___0 ;
  struct group *gr ;
  struct stat buf___2 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 109
  tmp___7 = is_socket(0);
  }
#line 109
  if (tmp___7) {
#line 110
    fd = 0;
  } else {
    {
#line 114
    fd = ud_create_socket(socketfile, socketmode);
    }
#line 115
    if (fd < 0) {
      {
#line 116
      tmp = __errno_location();
#line 116
      tmp___0 = strerror(*tmp);
#line 116
      acpid_log(3, "can\'t open socket %s: %s", socketfile, tmp___0);
#line 118
      exit(1);
      }
    }
#line 122
    if (socketgroup) {
      {
#line 126
      gr = getgrnam(socketgroup);
      }
#line 127
      if (! gr) {
        {
#line 128
        acpid_log(3, "group %s does not exist", socketgroup);
#line 129
        exit(1);
        }
      }
      {
#line 131
      tmp___3 = fstat(fd, & buf___2);
      }
#line 131
      if (tmp___3 < 0) {
        {
#line 132
        tmp___1 = __errno_location();
#line 132
        tmp___2 = strerror(*tmp___1);
#line 132
        acpid_log(3, "can\'t stat %s: %s", socketfile, tmp___2);
#line 134
        exit(1);
        }
      }
      {
#line 140
      tmp___6 = chown(socketfile, buf___2.st_uid, gr->gr_gid);
      }
#line 140
      if (tmp___6 < 0) {
        {
#line 141
        tmp___4 = __errno_location();
#line 141
        tmp___5 = strerror(*tmp___4);
#line 141
        acpid_log(3, "can\'t chown %s: %s", socketfile, tmp___5);
#line 143
        exit(1);
        }
      }
    }
  }
  {
#line 151
  tmp___10 = fcntl(fd, 2, 1);
  }
#line 151
  if (tmp___10 < 0) {
    {
#line 152
    close(fd);
#line 153
    tmp___8 = __errno_location();
#line 153
    tmp___9 = strerror(*tmp___8);
#line 153
    acpid_log(3, "fcntl() on socket %s for FD_CLOEXEC: %s", socketfile, tmp___9);
    }
#line 155
    return;
  }
  {
#line 161
  tmp___13 = fcntl(fd, 4, 2048);
  }
#line 161
  if (tmp___13 < 0) {
    {
#line 162
    close(fd);
#line 163
    tmp___11 = __errno_location();
#line 163
    tmp___12 = strerror(*tmp___11);
#line 163
    acpid_log(3, "fcntl() on socket %s for O_NONBLOCK: %s", socketfile, tmp___12);
    }
#line 165
    return;
  }
  {
#line 169
  c.fd = fd;
#line 170
  c.process = & process_sock;
#line 171
  c.pathname = (char *)((void *)0);
#line 172
  c.kybd = 0;
#line 174
  tmp___14 = add_connection(& c);
  }
#line 174
  if (tmp___14 < 0) {
    {
#line 175
    close(fd);
#line 176
    acpid_log(3, "can\'t add connection for socket %s", socketfile);
    }
#line 178
    return;
  }
#line 180
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 251
extern int accept4(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ,
                   int __flags ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/ud_socket.h"
int ud_connect(char const   *name ) ;
#line 14
int ud_get_peercred(int fd , struct ucred *cred ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/ud_socket.c"
int ud_create_socket(char const   *name , mode_t socketmode___0 ) 
{ 
  int fd ;
  int r ;
  struct sockaddr_un uds_addr ;
  int *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 32
  tmp___0 = strnlen(name, sizeof(uds_addr.sun_path));
  }
#line 32
  if (tmp___0 > sizeof(uds_addr.sun_path) - 1UL) {
    {
#line 34
    acpid_log(3, "ud_create_socket(): socket filename longer than %zu characters: %s",
              sizeof(uds_addr.sun_path) - 1UL, name);
#line 37
    tmp = __errno_location();
#line 37
    *tmp = 22;
    }
#line 38
    return (-1);
  }
  {
#line 42
  unlink(name);
#line 44
  fd = socket(1, 526337, 0);
  }
#line 45
  if (fd < 0) {
#line 46
    return (fd);
  }
  {
#line 50
  umask((__mode_t )0);
#line 52
  tmp___3 = fchmod(fd, socketmode___0);
  }
#line 52
  if (tmp___3 < 0) {
    {
#line 53
    close(fd);
#line 54
    tmp___1 = __errno_location();
#line 54
    tmp___2 = strerror(*tmp___1);
#line 54
    acpid_log(3, "fchmod() on socket %s: %s", name, tmp___2);
    }
#line 56
    return (-1);
  }
  {
#line 60
  memset((void *)(& uds_addr), 0, sizeof(uds_addr));
#line 61
  uds_addr.sun_family = (sa_family_t )1;
#line 62
  strncpy((char */* __restrict  */)(uds_addr.sun_path), (char const   */* __restrict  */)name,
          sizeof(uds_addr.sun_path) - 1UL);
#line 65
  r = bind(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& uds_addr)),
           (socklen_t )sizeof(uds_addr));
  }
#line 66
  if (r < 0) {
    {
#line 67
    close(fd);
    }
#line 68
    return (r);
  }
  {
#line 72
  r = listen(fd, 10);
  }
#line 73
  if (r < 0) {
    {
#line 74
    close(fd);
    }
#line 75
    return (r);
  }
#line 78
  return (fd);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/ud_socket.c"
int ud_accept(int listenfd , struct ucred *cred ) 
{ 
  int newsock ;
  struct sockaddr_un cliaddr ;
  socklen_t len ;
  long __result ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    newsock = 0;
#line 87
    len = (socklen_t )sizeof(struct sockaddr_un );
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 89
      tmp = accept4(listenfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cliaddr)),
                    (socklen_t */* __restrict  */)(& len), 526336);
#line 89
      __result = (long )tmp;
      }
#line 89
      if (__result == -1L) {
        {
#line 89
        tmp___0 = __errno_location();
        }
#line 89
        if (! (*tmp___0 == 4)) {
#line 89
          goto while_break___0;
        }
      } else {
#line 89
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 89
    newsock = (int )__result;
#line 90
    if (newsock < 0) {
#line 91
      return (newsock);
    }
#line 93
    if (cred) {
      {
#line 94
      len = (socklen_t )sizeof(struct ucred );
#line 95
      getsockopt(newsock, 1, 17, (void */* __restrict  */)cred, (socklen_t */* __restrict  */)(& len));
      }
    }
#line 98
    return (newsock);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/ud_socket.c"
int ud_connect(char const   *name ) 
{ 
  int fd ;
  int r ;
  struct sockaddr_un addr ;
  int *tmp ;
  size_t tmp___0 ;

  {
  {
#line 109
  tmp___0 = strnlen(name, sizeof(addr.sun_path));
  }
#line 109
  if (tmp___0 > sizeof(addr.sun_path) - 1UL) {
    {
#line 110
    acpid_log(3, "ud_connect(): socket filename longer than %zu characters: %s", sizeof(addr.sun_path) - 1UL,
              name);
#line 113
    tmp = __errno_location();
#line 113
    *tmp = 22;
    }
#line 114
    return (-1);
  }
  {
#line 117
  fd = socket(1, 524289, 0);
  }
#line 118
  if (fd < 0) {
#line 119
    return (fd);
  }
  {
#line 122
  memset((void *)(& addr), 0, sizeof(addr));
#line 123
  addr.sun_family = (sa_family_t )1;
#line 124
  sprintf((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)"%s",
          name);
#line 128
  r = connect(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& addr)),
              (socklen_t )sizeof(addr));
  }
#line 129
  if (r < 0) {
    {
#line 130
    close(fd);
    }
#line 131
    return (r);
  }
#line 134
  return (fd);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/ud_socket.c"
int ud_get_peercred(int fd , struct ucred *cred ) 
{ 
  socklen_t len ;

  {
  {
#line 140
  len = (socklen_t )sizeof(struct ucred );
#line 141
  getsockopt(fd, 1, 17, (void */* __restrict  */)cred, (socklen_t */* __restrict  */)(& len));
  }
#line 142
  return (0);
}
}
#line 238 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 170 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 223
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.h"
int acpid_debug ;
#line 29 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.h"
int acpid_read_conf(char const   *confdir___0 ) ;
#line 31
int acpid_cleanup_rules(int do_detach ) ;
#line 33
void acpid_close_dead_clients(void) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static struct rule_list drop_list  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static struct rule_list client_list  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static struct rule_list cmd_list  ;
#line 72
static void enlist_rule(struct rule_list *list , struct rule *r ) ;
#line 73
static void delist_rule(struct rule_list *list , struct rule *r ) ;
#line 74
static struct rule *new_rule(void) ;
#line 75
static void free_rule(struct rule *r ) ;
#line 78
static void lock_rules(void) ;
#line 79
static void unlock_rules(void) ;
#line 80
static sigset_t *signals_handled(void) ;
#line 81
static struct rule *parse_file(int fd_rule , char const   *file ) ;
#line 82
static struct rule *parse_client(int client ) ;
#line 83
static int do_cmd_rule(struct rule *rule , char const   *event ) ;
#line 84
static int do_client_rule(struct rule *rule , char const   *event ) ;
#line 85
static int safe_write(int fd , char const   *buf___2 , int len ) ;
#line 86
static char *parse_cmd(char const   *cmd , char const   *event ) ;
#line 87
static int check_escapes(char const   *str ) ;
#line 89
char const   *dropaction ;
#line 94 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
int acpid_read_conf(char const   *confdir___0 ) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  int nrules ;
  regex_t preg ;
  int rc ;
  int *tmp ;
  char *tmp___0 ;
  struct rule *r ;
  struct stat stat_buf ;
  char *file ;
  int fd_rule ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;

  {
  {
#line 99
  nrules = 0;
#line 101
  rc = 0;
#line 103
  lock_rules();
#line 105
  dir = opendir(confdir___0);
  }
#line 106
  if (! dir) {
    {
#line 107
    tmp = __errno_location();
#line 107
    tmp___0 = strerror(*tmp);
#line 107
    acpid_log(3, "opendir(%s): %s", confdir___0, tmp___0);
#line 109
    unlock_rules();
    }
#line 110
    return (-1);
  }
  {
#line 114
  rc = regcomp((regex_t */* __restrict  */)(& preg), (char const   */* __restrict  */)"^[a-zA-Z0-9_-]+$",
               ((1 | (1 << 1)) | (((1 << 1) << 1) << 1)) | ((1 << 1) << 1));
  }
#line 115
  if (rc) {
    {
#line 116
    closedir(dir);
#line 117
    acpid_log(3, "regcomp(): %d", rc);
#line 118
    unlock_rules();
    }
#line 119
    return (-1);
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    dirent = readdir(dir);
    }
#line 123
    if (! dirent) {
#line 123
      goto while_break;
    }
    {
#line 126
    file = (char *)((void *)0);
#line 130
    tmp___1 = strncmp((char const   *)(dirent->d_name), ".", sizeof(dirent->d_name));
    }
#line 130
    if (tmp___1 == 0) {
#line 131
      goto while_continue;
    }
    {
#line 132
    tmp___2 = strncmp((char const   *)(dirent->d_name), "..", sizeof(dirent->d_name));
    }
#line 132
    if (tmp___2 == 0) {
#line 133
      goto while_continue;
    }
    {
#line 135
    tmp___5 = asprintf((char **/* __restrict  */)(& file), (char const   */* __restrict  */)"%s/%s",
                       confdir___0, dirent->d_name);
    }
#line 135
    if (tmp___5 < 0) {
      {
#line 136
      tmp___3 = __errno_location();
#line 136
      tmp___4 = strerror(*tmp___3);
#line 136
      acpid_log(3, "asprintf: %s", tmp___4);
#line 137
      regfree(& preg);
#line 138
      closedir(dir);
#line 139
      unlock_rules();
      }
#line 140
      return (-1);
    }
    {
#line 144
    tmp___6 = regexec((regex_t const   */* __restrict  */)(& preg), (char const   */* __restrict  */)(dirent->d_name),
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 144
    if (tmp___6 != 0) {
      {
#line 145
      acpid_log(6, "skipping conf file %s", file);
#line 146
      free((void *)file);
      }
#line 147
      goto while_continue;
    }
#line 152
    if ((int )dirent->d_type != 8) {
      {
#line 154
      tmp___9 = dirfd(dir);
#line 154
      tmp___10 = fstatat(tmp___9, (char const   */* __restrict  */)(dirent->d_name),
                         (struct stat */* __restrict  */)(& stat_buf), 0);
      }
#line 154
      if (tmp___10 != 0) {
        {
#line 155
        tmp___7 = __errno_location();
#line 155
        tmp___8 = strerror(*tmp___7);
#line 155
        acpid_log(3, "fstatat(%s): %s", file, tmp___8);
#line 156
        free((void *)file);
        }
#line 157
        goto while_continue;
      }
#line 159
      if (! ((stat_buf.st_mode & 61440U) == 32768U)) {
        {
#line 160
        acpid_log(6, "skipping non-file %s", file);
#line 161
        free((void *)file);
        }
#line 162
        goto while_continue;
      }
    }
    {
#line 167
    tmp___13 = dirfd(dir);
#line 167
    fd_rule = openat(tmp___13, (char const   *)(dirent->d_name), 526336);
    }
#line 167
    if (fd_rule == -1) {
      {
#line 170
      tmp___11 = __errno_location();
#line 170
      tmp___12 = strerror(*tmp___11);
#line 170
      acpid_log(3, "openat(%s): %s", file, tmp___12);
#line 171
      free((void *)file);
#line 173
      closedir(dir);
#line 174
      regfree(& preg);
#line 175
      unlock_rules();
      }
#line 176
      return (-1);
    }
    {
#line 179
    r = parse_file(fd_rule, (char const   *)file);
    }
#line 180
    if (r) {
      {
#line 182
      tmp___14 = strcmp((char const   *)r->action.cmd, dropaction);
      }
#line 182
      if (tmp___14) {
        {
#line 185
        enlist_rule(& cmd_list, r);
        }
      } else {
        {
#line 183
        enlist_rule(& drop_list, r);
        }
      }
#line 186
      nrules ++;
    }
    {
#line 188
    free((void *)file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  regfree(& preg);
#line 192
  closedir(dir);
#line 193
  unlock_rules();
  }
#line 195
  if (nrules == 1) {
#line 195
    tmp___15 = "";
  } else {
#line 195
    tmp___15 = "s";
  }
  {
#line 195
  acpid_log(6, "%d rule%s loaded", nrules, tmp___15);
  }
#line 197
  return (0);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
int acpid_cleanup_rules(int do_detach ) 
{ 
  struct rule *p ;
  struct rule *next ;

  {
  {
#line 209
  lock_rules();
  }
#line 211
  if (acpid_debug >= 3) {
    {
#line 212
    acpid_log(7, "cleaning up rules");
    }
  }
#line 215
  if (do_detach) {
#line 217
    p = client_list.head;
    {
#line 218
    while (1) {
      while_continue: /* CIL Label */ ;
#line 218
      if (! p) {
#line 218
        goto while_break;
      }
      {
#line 219
      next = p->next;
#line 220
      delist_rule(& client_list, p);
#line 221
      close(p->action.fd);
#line 222
      free_rule(p);
#line 223
      p = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 228
  p = cmd_list.head;
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! p) {
#line 229
      goto while_break___0;
    }
    {
#line 230
    next = p->next;
#line 231
    delist_rule(& cmd_list, p);
#line 232
    free_rule(p);
#line 233
    p = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 237
  p = drop_list.head;
  {
#line 238
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 238
    if (! p) {
#line 238
      goto while_break___1;
    }
    {
#line 239
    next = p->next;
#line 240
    delist_rule(& drop_list, p);
#line 241
    free_rule(p);
#line 242
    p = next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 245
  unlock_rules();
  }
#line 247
  return (0);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static struct rule *parse_file(int fd_rule , char const   *file ) 
{ 
  FILE *fp ;
  char buf___2[512] ;
  int line ;
  struct rule *r ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *p ;
  char key[64] ;
  char val[512] ;
  int n ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int rv ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char rbuf[128] ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 255
  line = 0;
#line 258
  acpid_log(7, "parsing conf file %s", file);
#line 261
  fp = fdopen(fd_rule, "re");
  }
#line 262
  if (! fp) {
    {
#line 263
    tmp = __errno_location();
#line 263
    tmp___0 = strerror(*tmp);
#line 263
    acpid_log(3, "fopen(%s): %s", file, tmp___0);
    }
#line 264
    return ((struct rule *)((void *)0));
  }
  {
#line 268
  r = new_rule();
  }
#line 269
  if (! r) {
    {
#line 270
    fclose(fp);
    }
#line 271
    return ((struct rule *)((void *)0));
  }
  {
#line 273
  r->type = (enum __anonenum_type_63 )1;
#line 274
  r->origin = strdup(file);
  }
#line 275
  if (! r->origin) {
    {
#line 276
    tmp___1 = __errno_location();
#line 276
    tmp___2 = strerror(*tmp___1);
#line 276
    acpid_log(3, "strdup(): %s", tmp___2);
#line 277
    free_rule(r);
#line 278
    fclose(fp);
    }
#line 279
    return ((struct rule *)((void *)0));
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    tmp___13 = feof(fp);
    }
#line 283
    if (tmp___13) {
#line 283
      goto while_break;
    } else {
      {
#line 283
      tmp___14 = ferror(fp);
      }
#line 283
      if (tmp___14) {
#line 283
        goto while_break;
      }
    }
    {
#line 284
    p = buf___2;
#line 289
    line ++;
#line 290
    memset((void *)(key), 0, sizeof(key));
#line 291
    memset((void *)(val), 0, sizeof(val));
#line 293
    tmp___3 = fgets((char */* __restrict  */)(buf___2), (int )(sizeof(buf___2) - 1UL),
                    (FILE */* __restrict  */)fp);
    }
#line 293
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 294
      goto while_continue;
    }
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      if (*p) {
        {
#line 298
        tmp___4 = __ctype_b_loc();
        }
#line 298
        if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 298
          goto while_break___0;
        }
      } else {
#line 298
        goto while_break___0;
      }
#line 299
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 302
    if (! *p) {
#line 303
      goto while_continue;
    } else
#line 302
    if ((int )*p == 35) {
#line 303
      goto while_continue;
    }
    {
#line 307
    n = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"%63[^=\n]=%255[^\n]",
               key, val);
    }
#line 308
    if (n != 2) {
      {
#line 309
      acpid_log(4, "can\'t parse %s at line %d", file, line);
      }
#line 311
      goto while_continue;
    }
#line 313
    if (acpid_debug >= 3) {
      {
#line 314
      acpid_log(7, "    key=\"%s\" val=\"%s\"", key, val);
      }
    }
    {
#line 318
    tmp___12 = strcasecmp((char const   *)(key), "event");
    }
#line 318
    if (tmp___12) {
      {
#line 337
      tmp___11 = strcasecmp((char const   *)(key), "action");
      }
#line 337
      if (tmp___11) {
        {
#line 354
        acpid_log(4, "unknown option \'%s\' in %s at line %d", key, file, line);
        }
#line 357
        goto while_continue;
      } else {
        {
#line 338
        tmp___8 = check_escapes((char const   *)(val));
        }
#line 338
        if (tmp___8 < 0) {
          {
#line 339
          acpid_log(3, "can\'t load file %s", file);
#line 341
          free_rule(r);
#line 342
          fclose(fp);
          }
#line 343
          return ((struct rule *)((void *)0));
        }
        {
#line 345
        r->action.cmd = strdup((char const   *)(val));
        }
#line 346
        if (! r->action.cmd) {
          {
#line 347
          tmp___9 = __errno_location();
#line 347
          tmp___10 = strerror(*tmp___9);
#line 347
          acpid_log(3, "strdup(): %s", tmp___10);
#line 349
          free_rule(r);
#line 350
          fclose(fp);
          }
#line 351
          return ((struct rule *)((void *)0));
        }
      }
    } else {
      {
#line 320
      tmp___5 = malloc(sizeof(regex_t ));
#line 320
      r->event = (regex_t *)tmp___5;
      }
#line 321
      if (! r->event) {
        {
#line 322
        tmp___6 = __errno_location();
#line 322
        tmp___7 = strerror(*tmp___6);
#line 322
        acpid_log(3, "malloc(): %s", tmp___7);
#line 324
        free_rule(r);
#line 325
        fclose(fp);
        }
#line 326
        return ((struct rule *)((void *)0));
      }
      {
#line 328
      rv = regcomp((regex_t */* __restrict  */)r->event, (char const   */* __restrict  */)(val),
                   ((1 | (1 << 1)) | (((1 << 1) << 1) << 1)) | ((1 << 1) << 1));
      }
#line 329
      if (rv) {
        {
#line 331
        regerror(rv, (regex_t const   */* __restrict  */)r->event, (char */* __restrict  */)(rbuf),
                 sizeof(rbuf));
#line 332
        acpid_log(3, "regcomp(): %s", rbuf);
#line 333
        free_rule(r);
#line 334
        fclose(fp);
        }
#line 335
        return ((struct rule *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  if (! r->event) {
    {
#line 361
    acpid_log(6, "skipping incomplete file %s", file);
#line 362
    free_rule(r);
#line 363
    fclose(fp);
    }
#line 364
    return ((struct rule *)((void *)0));
  } else
#line 360
  if (! r->action.cmd) {
    {
#line 361
    acpid_log(6, "skipping incomplete file %s", file);
#line 362
    free_rule(r);
#line 363
    fclose(fp);
    }
#line 364
    return ((struct rule *)((void *)0));
  }
  {
#line 366
  fclose(fp);
  }
#line 368
  return (r);
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
int acpid_add_client(int clifd , char const   *origin ) 
{ 
  struct rule *r ;
  int nrules ;
  char const   *tmp ;

  {
  {
#line 375
  nrules = 0;
#line 377
  acpid_log(5, "client connected from %s", origin);
#line 379
  r = parse_client(clifd);
  }
#line 380
  if (r) {
    {
#line 381
    r->origin = strdup(origin);
#line 382
    enlist_rule(& client_list, r);
#line 383
    nrules ++;
    }
  }
#line 386
  if (nrules == 1) {
#line 386
    tmp = "";
  } else {
#line 386
    tmp = "s";
  }
  {
#line 386
  acpid_log(6, "%d client rule%s loaded", nrules, tmp);
  }
#line 389
  return (0);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static struct rule *parse_client(int client ) 
{ 
  struct rule *r ;
  int rv ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char buf___2[128] ;

  {
  {
#line 399
  r = new_rule();
  }
#line 400
  if (! r) {
#line 401
    return ((struct rule *)((void *)0));
  }
  {
#line 403
  r->type = (enum __anonenum_type_63 )2;
#line 404
  r->action.fd = client;
#line 405
  tmp = malloc(sizeof(regex_t ));
#line 405
  r->event = (regex_t *)tmp;
  }
#line 406
  if (! r->event) {
    {
#line 407
    tmp___0 = __errno_location();
#line 407
    tmp___1 = strerror(*tmp___0);
#line 407
    acpid_log(3, "malloc(): %s", tmp___1);
#line 408
    free_rule(r);
    }
#line 409
    return ((struct rule *)((void *)0));
  }
  {
#line 411
  rv = regcomp((regex_t */* __restrict  */)r->event, (char const   */* __restrict  */)".*",
               ((1 | (1 << 1)) | (((1 << 1) << 1) << 1)) | ((1 << 1) << 1));
  }
#line 412
  if (rv) {
    {
#line 414
    regerror(rv, (regex_t const   */* __restrict  */)r->event, (char */* __restrict  */)(buf___2),
             sizeof(buf___2));
#line 415
    acpid_log(3, "regcomp(): %s", buf___2);
#line 416
    free_rule(r);
    }
#line 417
    return ((struct rule *)((void *)0));
  }
#line 420
  return (r);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static void enlist_rule(struct rule_list *list , struct rule *r ) 
{ 
  struct rule *tmp ;
  struct rule *tmp___0 ;

  {
#line 430
  tmp = (struct rule *)((void *)0);
#line 430
  r->prev = tmp;
#line 430
  r->next = tmp;
#line 431
  if (! list->head) {
#line 432
    tmp___0 = r;
#line 432
    list->tail = tmp___0;
#line 432
    list->head = tmp___0;
  } else {
#line 434
    (list->tail)->next = r;
#line 435
    r->prev = list->tail;
#line 436
    list->tail = r;
  }
#line 438
  return;
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static void delist_rule(struct rule_list *list , struct rule *r ) 
{ 
  struct rule *tmp ;

  {
#line 443
  if (r->next) {
#line 444
    (r->next)->prev = r->prev;
  } else {
#line 446
    list->tail = r->prev;
  }
#line 449
  if (r->prev) {
#line 450
    (r->prev)->next = r->next;
  } else {
#line 452
    list->head = r->next;
  }
#line 455
  tmp = (struct rule *)((void *)0);
#line 455
  r->prev = tmp;
#line 455
  r->next = tmp;
#line 456
  return;
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static struct rule *new_rule(void) 
{ 
  struct rule *r ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct rule *tmp___2 ;

  {
  {
#line 463
  tmp = malloc(sizeof(*r));
#line 463
  r = (struct rule *)tmp;
  }
#line 464
  if (! r) {
    {
#line 465
    tmp___0 = __errno_location();
#line 465
    tmp___1 = strerror(*tmp___0);
#line 465
    acpid_log(3, "malloc(): %s", tmp___1);
    }
#line 466
    return ((struct rule *)((void *)0));
  }
#line 469
  r->type = (enum __anonenum_type_63 )0;
#line 470
  r->origin = (char *)((void *)0);
#line 471
  r->event = (regex_t *)((void *)0);
#line 472
  r->action.cmd = (char *)((void *)0);
#line 473
  tmp___2 = (struct rule *)((void *)0);
#line 473
  r->next = tmp___2;
#line 473
  r->prev = tmp___2;
#line 475
  return (r);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static void free_rule(struct rule *r ) 
{ 


  {
#line 482
  if ((unsigned int )r->type == 1U) {
#line 483
    if (r->action.cmd) {
      {
#line 484
      free((void *)r->action.cmd);
      }
    }
  }
#line 488
  if (r->origin) {
    {
#line 489
    free((void *)r->origin);
    }
  }
#line 491
  if (r->event) {
    {
#line 492
    regfree(r->event);
#line 493
    free((void *)r->event);
    }
  }
  {
#line 496
  free((void *)r);
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static int client_is_dead(int fd ) 
{ 
  struct pollfd pfd ;
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 506
  pfd.fd = fd;
#line 507
  pfd.events = (short)24;
#line 508
  r = poll(& pfd, (nfds_t )1, 0);
  }
#line 510
  if (r < 0) {
    {
#line 511
    tmp = __errno_location();
#line 511
    tmp___0 = strerror(*tmp);
#line 511
    acpid_log(3, "poll(): %s", tmp___0);
    }
#line 512
    return (0);
  }
#line 515
  return ((int )pfd.revents);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
void acpid_close_dead_clients(void) 
{ 
  struct rule *p ;
  struct rule *next ;
  struct ucred cred ;
  int tmp ;

  {
  {
#line 523
  lock_rules();
#line 526
  p = client_list.head;
  }
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! p) {
#line 527
      goto while_break;
    }
    {
#line 528
    next = p->next;
#line 529
    tmp = client_is_dead(p->action.fd);
    }
#line 529
    if (tmp) {
      {
#line 532
      acpid_log(5, "client %s has disconnected", p->origin);
#line 534
      delist_rule(& client_list, p);
#line 535
      ud_get_peercred(p->action.fd, & cred);
      }
#line 536
      if (cred.uid != 0U) {
#line 537
        non_root_clients --;
      }
      {
#line 539
      close(p->action.fd);
#line 540
      free_rule(p);
      }
    }
#line 542
    p = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  unlock_rules();
  }
#line 546
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
int acpid_handle_event(char const   *event ) 
{ 
  struct rule *p ;
  int nrules ;
  struct rule_list *ar[4] ;
  struct rule_list **lp ;
  struct rule_list *l ;
  struct rule *pnext ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 555
  nrules = 0;
#line 556
  ar[0] = & drop_list;
#line 556
  ar[1] = & client_list;
#line 556
  ar[2] = & cmd_list;
#line 556
  ar[3] = (struct rule_list *)((void *)0);
#line 560
  lock_rules();
#line 563
  lp = ar;
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! *lp) {
#line 563
      goto while_break;
    }
#line 564
    l = *lp;
#line 565
    p = l->head;
    {
#line 566
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 566
      if (! p) {
#line 566
        goto while_break___0;
      }
      {
#line 568
      pnext = p->next;
#line 569
      tmp___0 = regexec((regex_t const   */* __restrict  */)p->event, (char const   */* __restrict  */)event,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 569
      if (tmp___0) {
#line 596
        if (acpid_debug >= 3) {
#line 596
          if (logevents) {
            {
#line 597
            acpid_log(6, "rule from %s did not match", p->origin);
            }
          }
        }
      } else {
#line 571
        if (logevents) {
          {
#line 572
          acpid_log(6, "rule from %s matched", p->origin);
          }
        }
#line 576
        nrules ++;
#line 577
        if ((unsigned int )p->type == 1U) {
          {
#line 578
          tmp = do_cmd_rule(p, event);
          }
#line 578
          if (tmp == 1) {
#line 580
            if (logevents) {
              {
#line 581
              acpid_log(6, "event dropped");
              }
            }
            {
#line 583
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 583
              lp ++;
#line 583
              if (! *lp) {
#line 583
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 585
            lp --;
#line 586
            goto while_break___0;
          }
        } else
#line 588
        if ((unsigned int )p->type == 2U) {
          {
#line 589
          do_client_rule(p, event);
          }
        } else {
          {
#line 591
          acpid_log(4, "unknown rule type: %d", (unsigned int )p->type);
          }
        }
      }
#line 602
      p = pnext;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 563
    lp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  unlock_rules();
  }
#line 608
  if (logevents) {
#line 609
    if (nrules == 1) {
#line 609
      tmp___1 = "";
    } else {
#line 609
      tmp___1 = "s";
    }
    {
#line 609
    acpid_log(6, "%d total rule%s matched", nrules, tmp___1);
    }
  }
#line 613
  return (0);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static sigset_t set  ;
#line 617 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static sigset_t *signals_handled(void) 
{ 


  {
  {
#line 622
  sigemptyset(& set);
#line 623
  sigaddset(& set, 1);
#line 624
  sigaddset(& set, 15);
#line 625
  sigaddset(& set, 3);
#line 626
  sigaddset(& set, 2);
  }
#line 628
  return (& set);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static void lock_rules(void) 
{ 
  sigset_t *tmp ;

  {
#line 634
  if (acpid_debug >= 4) {
    {
#line 635
    acpid_log(7, "blocking signals for rule lock");
    }
  }
  {
#line 637
  tmp = signals_handled();
#line 637
  sigprocmask(0, (sigset_t const   */* __restrict  */)tmp, (sigset_t */* __restrict  */)((void *)0));
  }
#line 638
  return;
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static void unlock_rules(void) 
{ 
  sigset_t *tmp ;

  {
#line 643
  if (acpid_debug >= 4) {
    {
#line 644
    acpid_log(7, "unblocking signals for rule lock");
    }
  }
  {
#line 646
  tmp = signals_handled();
#line 646
  sigprocmask(1, (sigset_t const   */* __restrict  */)tmp, (sigset_t */* __restrict  */)((void *)0));
  }
#line 647
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static int do_cmd_rule(struct rule *rule , char const   *event ) 
{ 
  pid_t pid ;
  int status ;
  char const   *action ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  sigset_t *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  union __anonunion_65 __constr_expr_0 ;
  union __anonunion_66 __constr_expr_1 ;
  union __anonunion_67 __constr_expr_2 ;
  union __anonunion_68 __constr_expr_3 ;

  {
  {
#line 660
  tmp = strcmp((char const   *)rule->action.cmd, dropaction);
  }
#line 660
  if (! tmp) {
#line 661
    return (1);
  }
  {
#line 663
  pid = fork();
  }
  {
#line 665
  if (pid == -1) {
#line 665
    goto case_neg_1;
  }
#line 668
  if (pid == 0) {
#line 668
    goto case_0;
  }
#line 664
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 666
  tmp___0 = __errno_location();
#line 666
  tmp___1 = strerror(*tmp___0);
#line 666
  acpid_log(3, "fork(): %s", tmp___1);
  }
#line 667
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 670
  tmp___2 = parse_cmd((char const   *)rule->action.cmd, event);
#line 670
  action = (char const   *)tmp___2;
  }
#line 671
  if (logevents) {
    {
#line 672
    acpid_log(6, "executing action \"%s\"", action);
    }
  }
  {
#line 677
  signal(1, (void (*)(int  ))0);
#line 678
  signal(15, (void (*)(int  ))0);
#line 679
  signal(2, (void (*)(int  ))0);
#line 680
  signal(3, (void (*)(int  ))0);
#line 681
  signal(13, (void (*)(int  ))0);
#line 682
  tmp___3 = signals_handled();
#line 682
  sigprocmask(1, (sigset_t const   */* __restrict  */)tmp___3, (sigset_t */* __restrict  */)((void *)0));
  }
#line 684
  if (acpid_debug) {
#line 684
    if (logevents) {
      {
#line 685
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"BEGIN HANDLER MESSAGES\n");
      }
    }
  }
  {
#line 687
  umask((__mode_t )63);
#line 688
  execl("/bin/sh", "/bin/sh", "-c", action, (void *)0);
#line 690
  tmp___4 = __errno_location();
#line 690
  tmp___5 = strerror(*tmp___4);
#line 690
  acpid_log(3, "execl(): %s", tmp___5);
#line 691
  _exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 695
  waitpid(pid, & status, 0);
  }
#line 696
  if (acpid_debug) {
#line 696
    if (logevents) {
      {
#line 697
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"END HANDLER MESSAGES\n");
      }
    }
  }
#line 700
  if (logevents) {
#line 701
    __constr_expr_3.__in = status;
#line 701
    if ((__constr_expr_3.__i & 127) == 0) {
      {
#line 702
      __constr_expr_0.__in = status;
#line 702
      acpid_log(6, "action exited with status %d", (__constr_expr_0.__i & 65280) >> 8);
      }
    } else {
#line 704
      __constr_expr_2.__in = status;
#line 704
      if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
        {
#line 705
        __constr_expr_1.__in = status;
#line 705
        acpid_log(6, "action exited on signal %d", __constr_expr_1.__i & 127);
        }
      } else {
        {
#line 708
        acpid_log(6, "action exited with status %d", status);
        }
      }
    }
  }
#line 713
  return (0);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static int do_client_rule(struct rule *rule , char const   *event ) 
{ 
  int r ;
  int client ;
  size_t tmp ;
  struct ucred cred ;
  int *tmp___0 ;

  {
#line 720
  client = rule->action.fd;
#line 722
  if (logevents) {
    {
#line 723
    acpid_log(6, "notifying client %s", rule->origin);
    }
  }
  {
#line 726
  tmp = strlen(event);
#line 726
  r = safe_write(client, event, (int )tmp);
  }
#line 727
  if (r < 0) {
    {
#line 727
    tmp___0 = __errno_location();
    }
#line 727
    if (*tmp___0 == 32) {
      {
#line 730
      acpid_log(5, "client %s has disconnected", rule->origin);
#line 732
      delist_rule(& client_list, rule);
#line 733
      ud_get_peercred(rule->action.fd, & cred);
      }
#line 734
      if (cred.uid != 0U) {
#line 735
        non_root_clients --;
      }
      {
#line 737
      close(rule->action.fd);
#line 738
      free_rule(rule);
      }
#line 739
      return (-1);
    }
  }
  {
#line 741
  safe_write(client, "\n", 1);
  }
#line 743
  return (0);
}
}
#line 747 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static int safe_write(int fd , char const   *buf___2 , int len ) 
{ 
  int r ;
  int ttl ;
  int ntries ;
  long __result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 751
  ttl = 0;
#line 752
  ntries = 100;
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 755
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 755
      tmp = write(fd, (void const   *)(buf___2 + ttl), (size_t )(len - ttl));
#line 755
      __result = tmp;
      }
#line 755
      if (__result == -1L) {
        {
#line 755
        tmp___0 = __errno_location();
        }
#line 755
        if (! (*tmp___0 == 4)) {
#line 755
          goto while_break___0;
        }
      } else {
#line 755
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 755
    r = (int )__result;
#line 756
    if (r < 0) {
      {
#line 757
      tmp___1 = __errno_location();
      }
#line 757
      if (*tmp___1 != 11) {
#line 759
        return (r);
      }
#line 761
      ntries --;
    } else
#line 762
    if (r > 0) {
#line 764
      ntries = 100;
#line 765
      ttl += r;
    }
#line 754
    if (ttl < len) {
#line 754
      if (! ntries) {
#line 754
        goto while_break;
      }
    } else {
#line 754
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  if (! ntries) {
#line 770
    if (acpid_debug >= 2) {
      {
#line 771
      acpid_log(3, "safe_write() timed out");
      }
    }
#line 773
    return (r);
  }
#line 776
  return (ttl);
}
}
#line 782 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static char buf[4096]  ;
#line 779 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static char *parse_cmd(char const   *cmd , char const   *event ) 
{ 
  size_t i ;
  char const   *p ;
  size_t size ;
  int tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 786
  p = cmd;
#line 787
  i = (size_t )0;
#line 789
  memset((void *)(buf), 0, sizeof(buf));
  }
  {
#line 790
  while (1) {
    while_continue: /* CIL Label */ ;
#line 790
    if (! (i < sizeof(buf) - 1UL)) {
#line 790
      goto while_break;
    }
#line 791
    if ((int const   )*p == 37) {
#line 792
      p ++;
#line 793
      if ((int const   )*p == 101) {
        {
#line 795
        size = sizeof(buf) - i;
#line 796
        tmp = snprintf((char */* __restrict  */)(buf + i), size, (char const   */* __restrict  */)"%s",
                       event);
#line 796
        size = (size_t )tmp;
#line 797
        i += size;
#line 798
        p ++;
        }
#line 799
        goto while_continue;
      }
    }
#line 802
    if (! *p) {
#line 803
      goto while_break;
    }
#line 805
    tmp___0 = i;
#line 805
    i ++;
#line 805
    tmp___1 = p;
#line 805
    p ++;
#line 805
    buf[tmp___0] = (char )*tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 807
  if (acpid_debug >= 2) {
    {
#line 808
    acpid_log(7, "expanded \"%s\" -> \"%s\"", cmd, buf);
    }
  }
#line 811
  return (buf);
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/event.c"
static int check_escapes(char const   *str ) 
{ 
  char const   *p ;
  int r ;

  {
#line 818
  r = 0;
#line 820
  p = str;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! *p) {
#line 821
      goto while_break;
    }
#line 823
    if ((int const   )*p == 37) {
#line 824
      p ++;
#line 825
      if (! *p) {
        {
#line 826
        acpid_log(4, "invalid escape at EOL");
        }
#line 828
        return (-1);
      } else
#line 829
      if ((int const   )*p != 37) {
#line 829
        if ((int const   )*p != 101) {
          {
#line 830
          acpid_log(4, "invalid escape \"%%%c\"", (int const   )*p);
#line 832
          r = -1;
          }
        }
      }
    }
#line 835
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 837
  return (r);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.h"
int rtnl_open(struct rtnl_handle *rth , unsigned int subscriptions ) ;
#line 20
int rtnl_open_byproto(struct rtnl_handle *rth , unsigned int subscriptions , int protocol ) ;
#line 21
void rtnl_close(struct rtnl_handle *rth ) ;
#line 22
int rtnl_wilddump_request(struct rtnl_handle *rth , int family , int type ) ;
#line 23
int rtnl_dump_request(struct rtnl_handle *rth , int type , void *req , int len ) ;
#line 27
int rtnl_dump_filter(struct rtnl_handle *rth , int (*filter)(struct sockaddr_nl  const  * ,
                                                             struct nlmsghdr *n ,
                                                             void * ) , void *arg1 ,
                     int (*junk)(struct sockaddr_nl  const  * , struct nlmsghdr *n ,
                                 void * ) , void *arg2 ) ;
#line 31
int rtnl_talk(struct rtnl_handle *rtnl , struct nlmsghdr *n , pid_t peer , unsigned int groups ,
              struct nlmsghdr *answer , int (*junk)(struct sockaddr_nl  const  * ,
                                                    struct nlmsghdr *n , void * ) ,
              void *jarg ) ;
#line 35
int rtnl_send(struct rtnl_handle *rth , char const   *buf___2 , int len ) ;
#line 38
int addattr32(struct nlmsghdr *n , int maxlen , int type , __u32 data ) ;
#line 39
int addattr_l(struct nlmsghdr *n , int maxlen , int type , void const   *data , int alen ) ;
#line 40
int addraw_l(struct nlmsghdr *n , int maxlen , void const   *data , int len ) ;
#line 41
int rta_addattr32(struct rtattr *rta , int maxlen , int type , __u32 data ) ;
#line 42
int rta_addattr_l(struct rtattr *rta , int maxlen , int type , void const   *data ,
                  int alen ) ;
#line 44
int parse_rtattr(struct rtattr **tb , int max , struct rtattr *rta , int len ) ;
#line 45
int parse_rtattr_byindex(struct rtattr **tb , int max , struct rtattr *rta , int len ) ;
#line 50
int rtnl_listen(struct rtnl_handle *rtnl , int (*handler)(struct sockaddr_nl  const  * ,
                                                          struct nlmsghdr *n , void * ) ,
                void *jarg ) ;
#line 52
int rtnl_from_file(FILE *rtnl , int (*handler)(struct sockaddr_nl  const  * , struct nlmsghdr *n ,
                                               void * ) , void *jarg ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
void rtnl_close(struct rtnl_handle *rth ) 
{ 


  {
#line 31
  if (rth->fd >= 0) {
    {
#line 32
    close(rth->fd);
#line 33
    rth->fd = -1;
    }
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_open_byproto(struct rtnl_handle *rth , unsigned int subscriptions , int protocol ) 
{ 
  socklen_t addr_len ;
  int sndbuf ;
  int rcvbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  time_t tmp___3 ;

  {
  {
#line 41
  sndbuf = 32768;
#line 42
  rcvbuf = 32768;
#line 44
  memset((void *)rth, 0, sizeof(struct rtnl_handle ));
#line 46
  rth->fd = socket(16, 524291, protocol);
  }
#line 47
  if (rth->fd < 0) {
    {
#line 48
    perror("Cannot open netlink socket");
    }
#line 49
    return (-1);
  }
  {
#line 52
  tmp = setsockopt(rth->fd, 1, 7, (void const   *)(& sndbuf), (socklen_t )sizeof(sndbuf));
  }
#line 52
  if (tmp < 0) {
    {
#line 53
    perror("SO_SNDBUF");
    }
#line 54
    return (-1);
  }
  {
#line 57
  tmp___0 = setsockopt(rth->fd, 1, 8, (void const   *)(& rcvbuf), (socklen_t )sizeof(rcvbuf));
  }
#line 57
  if (tmp___0 < 0) {
    {
#line 58
    perror("SO_RCVBUF");
    }
#line 59
    return (-1);
  }
  {
#line 62
  memset((void *)(& rth->local), 0, sizeof(rth->local));
#line 63
  rth->local.nl_family = (__kernel_sa_family_t )16;
#line 64
  rth->local.nl_groups = subscriptions;
#line 66
  tmp___1 = bind(rth->fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& rth->local)),
                 (socklen_t )sizeof(rth->local));
  }
#line 66
  if (tmp___1 < 0) {
    {
#line 67
    perror("Cannot bind netlink socket");
    }
#line 68
    return (-1);
  }
  {
#line 70
  addr_len = (socklen_t )sizeof(rth->local);
#line 71
  tmp___2 = getsockname(rth->fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& rth->local)),
                        (socklen_t */* __restrict  */)(& addr_len));
  }
#line 71
  if (tmp___2 < 0) {
    {
#line 72
    perror("Cannot getsockname");
    }
#line 73
    return (-1);
  }
#line 75
  if ((unsigned long )addr_len != sizeof(rth->local)) {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong address length %d\n",
            addr_len);
    }
#line 77
    return (-1);
  }
#line 79
  if ((int )rth->local.nl_family != 16) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong address family %d\n",
            (int )rth->local.nl_family);
    }
#line 81
    return (-1);
  }
  {
#line 83
  tmp___3 = time((time_t *)((void *)0));
#line 83
  rth->seq = (__u32 )tmp___3;
  }
#line 84
  return (0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_open(struct rtnl_handle *rth , unsigned int subscriptions ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = rtnl_open_byproto(rth, subscriptions, 0);
  }
#line 89
  return (tmp);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_wilddump_request(struct rtnl_handle *rth , int family , int type ) 
{ 
  struct __anonstruct_req_75 req ;
  struct sockaddr_nl nladdr ;
  __u32 tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 100
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 101
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 103
  memset((void *)(& req), 0, sizeof(req));
#line 104
  req.nlh.nlmsg_len = (__u32 )sizeof(req);
#line 105
  req.nlh.nlmsg_type = (__u16 )type;
#line 106
  req.nlh.nlmsg_flags = (__u16 )769;
#line 107
  req.nlh.nlmsg_pid = (__u32 )0;
#line 108
  (rth->seq) ++;
#line 108
  tmp = rth->seq;
#line 108
  rth->dump = tmp;
#line 108
  req.nlh.nlmsg_seq = tmp;
#line 109
  req.g.rtgen_family = (unsigned char )family;
#line 111
  tmp___0 = sendto(rth->fd, (void const   *)((void *)(& req)), sizeof(req), 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& nladdr)),
                   (socklen_t )sizeof(nladdr));
  }
#line 111
  return ((int )tmp___0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_send(struct rtnl_handle *rth , char const   *buf___2 , int len ) 
{ 
  struct sockaddr_nl nladdr ;
  ssize_t tmp ;

  {
  {
#line 119
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 120
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 122
  tmp = sendto(rth->fd, (void const   *)buf___2, (size_t )len, 0, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& nladdr)),
               (socklen_t )sizeof(nladdr));
  }
#line 122
  return ((int )tmp);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_dump_request(struct rtnl_handle *rth , int type , void *req , int len ) 
{ 
  struct nlmsghdr nlh ;
  struct sockaddr_nl nladdr ;
  struct iovec iov[2] ;
  struct msghdr msg ;
  __u32 tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 129
  iov[0].iov_base = (void *)(& nlh);
#line 129
  iov[0].iov_len = sizeof(nlh);
#line 129
  iov[1].iov_base = req;
#line 129
  iov[1].iov_len = (size_t )len;
#line 133
  msg.msg_name = (void *)(& nladdr);
#line 133
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 133
  msg.msg_iov = iov;
#line 133
  msg.msg_iovlen = (size_t )2;
#line 133
  msg.msg_control = (void *)0;
#line 133
  msg.msg_controllen = 0UL;
#line 133
  msg.msg_flags = 0;
#line 140
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 141
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 143
  nlh.nlmsg_len = (__u32 )(len + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
#line 144
  nlh.nlmsg_type = (__u16 )type;
#line 145
  nlh.nlmsg_flags = (__u16 )769;
#line 146
  nlh.nlmsg_pid = (__u32 )0;
#line 147
  (rth->seq) ++;
#line 147
  tmp = rth->seq;
#line 147
  rth->dump = tmp;
#line 147
  nlh.nlmsg_seq = tmp;
#line 149
  tmp___0 = sendmsg(rth->fd, (struct msghdr  const  *)(& msg), 0);
  }
#line 149
  return ((int )tmp___0);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_dump_filter(struct rtnl_handle *rth , int (*filter)(struct sockaddr_nl  const  * ,
                                                             struct nlmsghdr *n ,
                                                             void * ) , void *arg1 ,
                     int (*junk)(struct sockaddr_nl  const  * , struct nlmsghdr *n ,
                                 void * ) , void *arg2 ) 
{ 
  struct sockaddr_nl nladdr ;
  struct iovec iov ;
  struct msghdr msg ;
  char buf___2[16384] ;
  int status ;
  struct nlmsghdr *h ;
  long __result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int err ;
  struct nlmsgerr *msgerr ;
  int *tmp___1 ;

  {
#line 160
  msg.msg_name = (void *)(& nladdr);
#line 160
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 160
  msg.msg_iov = & iov;
#line 160
  msg.msg_iovlen = (size_t )1;
#line 160
  msg.msg_control = (void *)0;
#line 160
  msg.msg_controllen = 0UL;
#line 160
  msg.msg_flags = 0;
#line 168
  iov.iov_base = (void *)(buf___2);
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    iov.iov_len = sizeof(buf___2);
    {
#line 174
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 174
      tmp = recvmsg(rth->fd, & msg, 1073741824);
#line 174
      __result = tmp;
      }
#line 174
      if (__result == -1L) {
        {
#line 174
        tmp___0 = __errno_location();
        }
#line 174
        if (! (*tmp___0 == 4)) {
#line 174
          goto while_break___0;
        }
      } else {
#line 174
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 174
    status = (int )__result;
#line 176
    if (status < 0) {
      {
#line 177
      perror("OVERRUN");
      }
#line 178
      goto while_continue;
    }
#line 181
    if (status == 0) {
      {
#line 182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF on netlink\n");
      }
#line 183
      return (-1);
    }
#line 186
    h = (struct nlmsghdr *)(buf___2);
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      if ((unsigned int )status >= (unsigned int )((int )sizeof(struct nlmsghdr ))) {
#line 187
        if ((unsigned long )h->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 187
          if (! (h->nlmsg_len <= (unsigned int )status)) {
#line 187
            goto while_break___1;
          }
        } else {
#line 187
          goto while_break___1;
        }
      } else {
#line 187
        goto while_break___1;
      }
#line 190
      if (nladdr.nl_pid != 0U) {
#line 190
        goto _L;
      } else
#line 190
      if (h->nlmsg_pid != rth->local.nl_pid) {
#line 190
        goto _L;
      } else
#line 190
      if (h->nlmsg_seq != rth->dump) {
        _L: /* CIL Label */ 
#line 193
        if (junk) {
          {
#line 194
          err = (*junk)((struct sockaddr_nl  const  *)(& nladdr), h, arg2);
          }
#line 195
          if (err < 0) {
#line 196
            return (err);
          }
        }
#line 198
        goto skip_it;
      }
#line 201
      if ((int )h->nlmsg_type == 3) {
#line 202
        return (0);
      }
#line 203
      if ((int )h->nlmsg_type == 2) {
#line 204
        msgerr = (struct nlmsgerr *)((void *)((char *)h + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 205
        if ((unsigned long )h->nlmsg_len < sizeof(struct nlmsgerr ) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))) {
          {
#line 206
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR truncated\n");
          }
        } else {
          {
#line 208
          tmp___1 = __errno_location();
#line 208
          *tmp___1 = - msgerr->error;
#line 209
          perror("RTNETLINK answers");
          }
        }
#line 211
        return (-1);
      }
      {
#line 213
      err = (*filter)((struct sockaddr_nl  const  *)(& nladdr), h, arg1);
      }
#line 214
      if (err < 0) {
#line 215
        return (err);
      }
      skip_it: 
#line 218
      status = (int )((unsigned int )status - (((h->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 218
      h = (struct nlmsghdr *)((char *)h + (((h->nlmsg_len + 4U) - 1U) & 4294967292U));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 220
    if (msg.msg_flags & 32) {
      {
#line 221
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Message truncated\n");
      }
#line 222
      goto while_continue;
    }
#line 224
    if (status) {
      {
#line 225
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!Remnant of size %d\n",
              status);
#line 226
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_talk(struct rtnl_handle *rtnl , struct nlmsghdr *n , pid_t peer , unsigned int groups ,
              struct nlmsghdr *answer , int (*junk)(struct sockaddr_nl  const  * ,
                                                    struct nlmsghdr *n , void * ) ,
              void *jarg ) 
{ 
  int status ;
  unsigned int seq ;
  struct nlmsghdr *h ;
  struct sockaddr_nl nladdr ;
  struct iovec iov ;
  struct msghdr msg ;
  char buf___2[16384] ;
  ssize_t tmp ;
  long __result ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int err ;
  int len ;
  int l ;
  struct nlmsgerr *msgerr ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 240
  iov.iov_base = (void *)n;
#line 240
  iov.iov_len = (size_t )n->nlmsg_len;
#line 244
  msg.msg_name = (void *)(& nladdr);
#line 244
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 244
  msg.msg_iov = & iov;
#line 244
  msg.msg_iovlen = (size_t )1;
#line 244
  msg.msg_control = (void *)0;
#line 244
  msg.msg_controllen = 0UL;
#line 244
  msg.msg_flags = 0;
#line 252
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 253
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 254
  nladdr.nl_pid = (__u32 )peer;
#line 255
  nladdr.nl_groups = groups;
#line 257
  (rtnl->seq) ++;
#line 257
  seq = rtnl->seq;
#line 257
  n->nlmsg_seq = seq;
  }
#line 259
  if ((unsigned long )answer == (unsigned long )((void *)0)) {
#line 260
    n->nlmsg_flags = (__u16 )((int )n->nlmsg_flags | 4);
  }
  {
#line 262
  tmp = sendmsg(rtnl->fd, (struct msghdr  const  *)(& msg), 0);
#line 262
  status = (int )tmp;
  }
#line 264
  if (status < 0) {
    {
#line 265
    perror("Cannot talk to rtnetlink");
    }
#line 266
    return (-1);
  }
  {
#line 269
  memset((void *)(buf___2), 0, sizeof(buf___2));
#line 271
  iov.iov_base = (void *)(buf___2);
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    iov.iov_len = sizeof(buf___2);
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 275
      tmp___0 = recvmsg(rtnl->fd, & msg, 1073741824);
#line 275
      __result = tmp___0;
      }
#line 275
      if (__result == -1L) {
        {
#line 275
        tmp___1 = __errno_location();
        }
#line 275
        if (! (*tmp___1 == 4)) {
#line 275
          goto while_break___0;
        }
      } else {
#line 275
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    status = (int )__result;
#line 277
    if (status < 0) {
      {
#line 278
      perror("OVERRUN");
      }
#line 279
      goto while_continue;
    }
#line 281
    if (status == 0) {
      {
#line 282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF on netlink\n");
      }
#line 283
      return (-1);
    }
#line 285
    if ((unsigned long )msg.msg_namelen != sizeof(nladdr)) {
      {
#line 286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sender address length == %d\n",
              msg.msg_namelen);
#line 287
      exit(1);
      }
    }
#line 289
    h = (struct nlmsghdr *)(buf___2);
    {
#line 289
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 289
      if (! ((unsigned long )((unsigned int )status) >= sizeof(*h))) {
#line 289
        goto while_break___1;
      }
#line 291
      len = (int )h->nlmsg_len;
#line 292
      l = (int )((unsigned long )len - sizeof(*h));
#line 294
      if (l < 0) {
#line 294
        goto _L;
      } else
#line 294
      if (len > status) {
        _L: /* CIL Label */ 
#line 295
        if (msg.msg_flags & 32) {
          {
#line 296
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncated message\n");
          }
#line 297
          return (-1);
        }
        {
#line 299
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!malformed message: len=%d\n",
                len);
#line 300
        exit(1);
        }
      }
#line 303
      if (nladdr.nl_pid != (unsigned int )peer) {
#line 303
        goto _L___0;
      } else
#line 303
      if (h->nlmsg_pid != rtnl->local.nl_pid) {
#line 303
        goto _L___0;
      } else
#line 303
      if (h->nlmsg_seq != seq) {
        _L___0: /* CIL Label */ 
#line 306
        if (junk) {
          {
#line 307
          err = (*junk)((struct sockaddr_nl  const  *)(& nladdr), h, jarg);
          }
#line 308
          if (err < 0) {
#line 309
            return (err);
          }
        }
#line 312
        status = (int )((unsigned int )status - ((((unsigned int )len + 4U) - 1U) & 4294967292U));
#line 313
        h = (struct nlmsghdr *)((char *)h + ((((unsigned int )len + 4U) - 1U) & 4294967292U));
#line 314
        goto __Cont;
      }
#line 317
      if ((int )h->nlmsg_type == 2) {
#line 318
        msgerr = (struct nlmsgerr *)((void *)((char *)h + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 319
        if ((unsigned long )((unsigned int )l) < sizeof(struct nlmsgerr )) {
          {
#line 320
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR truncated\n");
          }
        } else {
          {
#line 322
          tmp___2 = __errno_location();
#line 322
          *tmp___2 = - msgerr->error;
#line 323
          tmp___3 = __errno_location();
          }
#line 323
          if (*tmp___3 == 0) {
#line 324
            if (answer) {
              {
#line 325
              memcpy((void */* __restrict  */)answer, (void const   */* __restrict  */)h,
                     (size_t )h->nlmsg_len);
              }
            }
#line 326
            return (0);
          }
          {
#line 328
          perror("RTNETLINK1 answers");
          }
        }
#line 330
        return (-1);
      }
#line 332
      if (answer) {
        {
#line 333
        memcpy((void */* __restrict  */)answer, (void const   */* __restrict  */)h,
               (size_t )h->nlmsg_len);
        }
#line 334
        return (0);
      }
      {
#line 337
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected reply!!!\n");
#line 339
      status = (int )((unsigned int )status - ((((unsigned int )len + 4U) - 1U) & 4294967292U));
#line 340
      h = (struct nlmsghdr *)((char *)h + ((((unsigned int )len + 4U) - 1U) & 4294967292U));
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 342
    if (msg.msg_flags & 32) {
      {
#line 343
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Message truncated\n");
      }
#line 344
      goto while_continue;
    }
#line 346
    if (status) {
      {
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!Remnant of size %d\n",
              status);
#line 348
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_listen(struct rtnl_handle *rtnl , int (*handler)(struct sockaddr_nl  const  * ,
                                                          struct nlmsghdr *n , void * ) ,
                void *jarg ) 
{ 
  int status ;
  struct nlmsghdr *h ;
  struct sockaddr_nl nladdr ;
  struct iovec iov ;
  struct msghdr msg ;
  char buf___2[8192] ;
  long __result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int err ;
  int len ;
  int l ;

  {
  {
#line 361
  msg.msg_name = (void *)(& nladdr);
#line 361
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 361
  msg.msg_iov = & iov;
#line 361
  msg.msg_iovlen = (size_t )1;
#line 361
  msg.msg_control = (void *)0;
#line 361
  msg.msg_controllen = 0UL;
#line 361
  msg.msg_flags = 0;
#line 369
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 370
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 371
  nladdr.nl_pid = (__u32 )0;
#line 372
  nladdr.nl_groups = (__u32 )0;
#line 374
  iov.iov_base = (void *)(buf___2);
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    iov.iov_len = sizeof(buf___2);
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 377
      tmp = recvmsg(rtnl->fd, & msg, 1073741824);
#line 377
      __result = tmp;
      }
#line 377
      if (__result == -1L) {
        {
#line 377
        tmp___0 = __errno_location();
        }
#line 377
        if (! (*tmp___0 == 4)) {
#line 377
          goto while_break___0;
        }
      } else {
#line 377
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 377
    status = (int )__result;
#line 379
    if (status < 0) {
      {
#line 380
      perror("OVERRUN");
      }
#line 381
      goto while_continue;
    }
#line 383
    if (status == 0) {
      {
#line 384
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF on netlink\n");
      }
#line 385
      return (-1);
    }
#line 387
    if ((unsigned long )msg.msg_namelen != sizeof(nladdr)) {
      {
#line 388
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sender address length == %d\n",
              msg.msg_namelen);
#line 389
      exit(1);
      }
    }
#line 391
    h = (struct nlmsghdr *)(buf___2);
    {
#line 391
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 391
      if (! ((unsigned long )((unsigned int )status) >= sizeof(*h))) {
#line 391
        goto while_break___1;
      }
#line 393
      len = (int )h->nlmsg_len;
#line 394
      l = (int )((unsigned long )len - sizeof(*h));
#line 396
      if (l < 0) {
#line 396
        goto _L;
      } else
#line 396
      if (len > status) {
        _L: /* CIL Label */ 
#line 397
        if (msg.msg_flags & 32) {
          {
#line 398
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncated message\n");
          }
#line 399
          return (-1);
        }
        {
#line 401
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!malformed message: len=%d\n",
                len);
#line 402
        exit(1);
        }
      }
      {
#line 405
      err = (*handler)((struct sockaddr_nl  const  *)(& nladdr), h, jarg);
      }
#line 406
      if (err < 0) {
#line 407
        return (err);
      }
#line 409
      status = (int )((unsigned int )status - ((((unsigned int )len + 4U) - 1U) & 4294967292U));
#line 410
      h = (struct nlmsghdr *)((char *)h + ((((unsigned int )len + 4U) - 1U) & 4294967292U));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 412
    if (msg.msg_flags & 32) {
      {
#line 413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Message truncated\n");
      }
#line 414
      goto while_continue;
    }
#line 416
    if (status) {
      {
#line 417
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!Remnant of size %d\n",
              status);
#line 418
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rtnl_from_file(FILE *rtnl , int (*handler)(struct sockaddr_nl  const  * , struct nlmsghdr *n ,
                                               void * ) , void *jarg ) 
{ 
  int status ;
  struct sockaddr_nl nladdr ;
  char buf___2[8192] ;
  struct nlmsghdr *h ;
  int err ;
  int len ;
  int l ;
  long __result ;
  size_t tmp ;
  int *tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 429
  h = (struct nlmsghdr *)((void *)(buf___2));
#line 431
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 432
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 433
  nladdr.nl_pid = (__u32 )0;
#line 434
  nladdr.nl_groups = (__u32 )0;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 440
      tmp = fread((void */* __restrict  */)(& buf___2), (size_t )1, sizeof(*h), (FILE */* __restrict  */)rtnl);
#line 440
      __result = (long )tmp;
      }
#line 440
      if (__result == -1L) {
        {
#line 440
        tmp___0 = __errno_location();
        }
#line 440
        if (! (*tmp___0 == 4)) {
#line 440
          goto while_break___0;
        }
      } else {
#line 440
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 440
    status = (int )__result;
#line 442
    if (status < 0) {
      {
#line 443
      perror("rtnl_from_file: fread");
      }
#line 444
      return (-1);
    }
#line 446
    if (status == 0) {
#line 447
      return (0);
    }
#line 449
    len = (int )h->nlmsg_len;
#line 450
    l = (int )((unsigned long )len - sizeof(*h));
#line 452
    if (l < 0) {
      {
#line 453
      tmp___1 = ftell(rtnl);
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!malformed message: len=%d @%lu\n",
              len, tmp___1);
      }
#line 455
      return (-1);
    } else
#line 452
    if ((unsigned long )((unsigned int )len) > sizeof(buf___2)) {
      {
#line 453
      tmp___1 = ftell(rtnl);
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!malformed message: len=%d @%lu\n",
              len, tmp___1);
      }
#line 455
      return (-1);
    }
    {
#line 458
    tmp___2 = fread((void */* __restrict  */)((void *)((char *)h + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
                    (size_t )1, (size_t )((((unsigned int )l + 4U) - 1U) & 4294967292U),
                    (FILE */* __restrict  */)rtnl);
#line 458
    status = (int )tmp___2;
    }
#line 460
    if (status < 0) {
      {
#line 461
      perror("rtnl_from_file: fread");
      }
#line 462
      return (-1);
    }
#line 464
    if (status < l) {
      {
#line 465
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rtnl-from_file: truncated message\n");
      }
#line 466
      return (-1);
    }
    {
#line 469
    err = (*handler)((struct sockaddr_nl  const  *)(& nladdr), h, jarg);
    }
#line 470
    if (err < 0) {
#line 471
      return (err);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int addattr32(struct nlmsghdr *n , int maxlen , int type , __u32 data ) 
{ 
  int len ;
  struct rtattr *rta ;

  {
#line 477
  len = (int )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + 4UL);
#line 479
  if ((int )(((n->nlmsg_len + 4U) - 1U) & 4294967292U) + len > maxlen) {
    {
#line 480
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"addattr32: Error! max allowed bound %d exceeded\n",
            maxlen);
    }
#line 481
    return (-1);
  }
  {
#line 483
  rta = (struct rtattr *)((void *)n + (((n->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 484
  rta->rta_type = (unsigned short )type;
#line 485
  rta->rta_len = (unsigned short )len;
#line 486
  memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
         (void const   */* __restrict  */)(& data), (size_t )4);
#line 487
  n->nlmsg_len = (((n->nlmsg_len + 4U) - 1U) & 4294967292U) + (unsigned int )len;
  }
#line 488
  return (0);
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int addattr_l(struct nlmsghdr *n , int maxlen , int type , void const   *data , int alen ) 
{ 
  int len ;
  struct rtattr *rta ;

  {
#line 494
  len = (int )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + (unsigned long )alen);
#line 497
  if ((int )(((n->nlmsg_len + 4U) - 1U) & 4294967292U) + (((len + 4) - 1) & -4) > maxlen) {
    {
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"addattr_l ERROR: message exceeded bound of %d\n",
            maxlen);
    }
#line 499
    return (-1);
  }
  {
#line 501
  rta = (struct rtattr *)((void *)n + (((n->nlmsg_len + 4U) - 1U) & 4294967292U));
#line 502
  rta->rta_type = (unsigned short )type;
#line 503
  rta->rta_len = (unsigned short )len;
#line 504
  memcpy((void */* __restrict  */)((void *)((char *)rta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
         (void const   */* __restrict  */)data, (size_t )alen);
#line 505
  n->nlmsg_len = (((n->nlmsg_len + 4U) - 1U) & 4294967292U) + (unsigned int )(((len + 4) - 1) & -4);
  }
#line 506
  return (0);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int addraw_l(struct nlmsghdr *n , int maxlen , void const   *data , int len ) 
{ 


  {
#line 511
  if ((int )(((n->nlmsg_len + 4U) - 1U) & 4294967292U) + (int )((((unsigned int )len + 4U) - 1U) & 4294967292U) > maxlen) {
    {
#line 512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"addraw_l ERROR: message exceeded bound of %d\n",
            maxlen);
    }
#line 513
    return (-1);
  }
  {
#line 516
  memcpy((void */* __restrict  */)((struct rtattr *)((void *)n + (((n->nlmsg_len + 4U) - 1U) & 4294967292U))),
         (void const   */* __restrict  */)data, (size_t )len);
#line 517
  memset((void *)((struct rtattr *)((void *)n + (((n->nlmsg_len + 4U) - 1U) & 4294967292U))) + len,
         0, (size_t )(((((unsigned int )len + 4U) - 1U) & 4294967292U) - (unsigned int )len));
#line 518
  n->nlmsg_len = (((n->nlmsg_len + 4U) - 1U) & 4294967292U) + ((((unsigned int )len + 4U) - 1U) & 4294967292U);
  }
#line 519
  return (0);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rta_addattr32(struct rtattr *rta , int maxlen , int type , __u32 data ) 
{ 
  int len ;
  struct rtattr *subrta ;

  {
#line 524
  len = (int )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + 4UL);
#line 527
  if (((((int )rta->rta_len + 4) - 1) & -4) + len > maxlen) {
    {
#line 528
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rta_addattr32: Error! max allowed bound %d exceeded\n",
            maxlen);
    }
#line 529
    return (-1);
  }
  {
#line 531
  subrta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 532
  subrta->rta_type = (unsigned short )type;
#line 533
  subrta->rta_len = (unsigned short )len;
#line 534
  memcpy((void */* __restrict  */)((void *)((char *)subrta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
         (void const   */* __restrict  */)(& data), (size_t )4);
#line 535
  rta->rta_len = (unsigned short )(((((unsigned int )rta->rta_len + 4U) - 1U) & 4294967292U) + (unsigned int )len);
  }
#line 536
  return (0);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int rta_addattr_l(struct rtattr *rta , int maxlen , int type , void const   *data ,
                  int alen ) 
{ 
  struct rtattr *subrta ;
  int len ;

  {
#line 543
  len = (int )((((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL) + (unsigned long )alen);
#line 545
  if (((((int )rta->rta_len + 4) - 1) & -4) + (((len + 4) - 1) & -4) > maxlen) {
    {
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rta_addattr_l: Error! max allowed bound %d exceeded\n",
            maxlen);
    }
#line 547
    return (-1);
  }
  {
#line 549
  subrta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
#line 550
  subrta->rta_type = (unsigned short )type;
#line 551
  subrta->rta_len = (unsigned short )len;
#line 552
  memcpy((void */* __restrict  */)((void *)((char *)subrta + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
         (void const   */* __restrict  */)data, (size_t )alen);
#line 553
  rta->rta_len = (unsigned short )(((((unsigned int )rta->rta_len + 4U) - 1U) & 4294967292U) + (unsigned int )(((len + 4) - 1) & -4));
  }
#line 554
  return (0);
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int parse_rtattr(struct rtattr **tb , int max , struct rtattr *rta , int len ) 
{ 


  {
  {
#line 559
  memset((void *)tb, 0, sizeof(struct rtattr *) * (unsigned long )(max + 1));
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (len >= (int )sizeof(struct rtattr )) {
#line 560
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 560
        if (! ((int )rta->rta_len <= len)) {
#line 560
          goto while_break;
        }
      } else {
#line 560
        goto while_break;
      }
    } else {
#line 560
      goto while_break;
    }
#line 561
    if ((int )rta->rta_type <= max) {
#line 562
      *(tb + rta->rta_type) = rta;
    }
#line 563
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 563
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  if (len) {
    {
#line 566
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!Deficit %d, rta_len=%d\n",
            len, (int )rta->rta_len);
    }
  }
#line 567
  return (0);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/libnetlink.c"
int parse_rtattr_byindex(struct rtattr **tb , int max , struct rtattr *rta , int len ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 572
  i = 0;
#line 574
  memset((void *)tb, 0, sizeof(struct rtattr *) * (unsigned long )max);
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (len >= (int )sizeof(struct rtattr )) {
#line 575
      if ((unsigned long )rta->rta_len >= sizeof(struct rtattr )) {
#line 575
        if (! ((int )rta->rta_len <= len)) {
#line 575
          goto while_break;
        }
      } else {
#line 575
        goto while_break;
      }
    } else {
#line 575
      goto while_break;
    }
#line 576
    if ((int )rta->rta_type <= max) {
#line 576
      if (i < max) {
#line 577
        tmp = i;
#line 577
        i ++;
#line 577
        *(tb + tmp) = rta;
      }
    }
#line 578
    len -= (((int )rta->rta_len + 4) - 1) & -4;
#line 578
    rta = (struct rtattr *)((char *)rta + ((((int )rta->rta_len + 4) - 1) & -4));
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if (len) {
    {
#line 581
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"!!!Deficit %d, rta_len=%d\n",
            len, (int )rta->rta_len);
    }
  }
#line 582
  return (i);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 200 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/log.h"
int log_debug_to_stderr ;
#line 29 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/log.c"
int log_debug_to_stderr  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/log.c"
int ( /* format attribute */  acpid_log)(int level , char const   *fmt  , ...) 
{ 
  va_list args ;

  {
#line 39
  if (level == 7) {
#line 41
    if (log_debug_to_stderr) {
      {
#line 43
      __builtin_va_start(args, fmt);
#line 44
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
               args);
#line 45
      __builtin_va_end(args);
#line 47
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  } else {
    {
#line 50
    __builtin_va_start(args, fmt);
#line 51
    vsyslog(level, fmt, args);
#line 52
    __builtin_va_end(args);
    }
  }
#line 55
  return (0);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.h"
int acpid_debug  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.h"
int logevents  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.h"
char const   *progname  ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.h"
char const   *eventfile ;
#line 28
int open_proc(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/inotify_handler.h"
void open_inotify(void) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/netlink.h"
void open_netlink(void) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int handle_cmdline(int *argc , char ***argv ) ;
#line 46
static void close_fds(void) ;
#line 47
static int daemonize(void) ;
#line 48
static void open_log(void) ;
#line 49
static int std2null(void) ;
#line 50
static int create_pidfile(void) ;
#line 51
static void clean_exit(int sig  __attribute__((__unused__)) ) ;
#line 52
static void reload_conf(int sig  __attribute__((__unused__)) ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static char const   *confdir  =    "/etc/acpi/events";
#line 62 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static char const   *lockfile  =    "/var/lock/acpid";
#line 63 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int nosocket  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int foreground  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static char const   *pidfile  =    "/var/run/acpid.pid";
#line 66 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int netlink  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
char const   *dropaction  =    "<drop>";
#line 69 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
int main(int argc , char **argv ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  fd_set readfds ;
  int nready ;
  int i ;
  struct connection *p ;
  fd_set const   *tmp___8 ;
  long __result ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int fd ;
  int tmp___14 ;

  {
  {
#line 73
  tmp = strrchr((char const   *)*(argv + 0), '/');
#line 73
  progname = (char const   *)tmp;
  }
#line 74
  if (progname) {
#line 74
    progname ++;
  } else {
#line 74
    progname = (char const   *)*(argv + 0);
  }
  {
#line 77
  handle_cmdline(& argc, & argv);
#line 80
  close_fds();
#line 83
  open_log();
  }
#line 85
  if (! netlink) {
    {
#line 88
    tmp___0 = open_proc();
    }
#line 88
    if (tmp___0) {
#line 89
      netlink = 1;
    }
  }
#line 92
  if (netlink) {
    {
#line 94
    open_input();
#line 97
    open_inotify();
#line 100
    open_netlink();
    }
  }
#line 104
  if (! nosocket) {
    {
#line 105
    open_sock();
    }
  }
#line 110
  if (! foreground) {
    {
#line 110
    tmp___2 = is_socket(0);
    }
#line 110
    if (! tmp___2) {
      {
#line 111
      tmp___1 = daemonize();
      }
#line 111
      if (tmp___1 < 0) {
        {
#line 112
        exit(1);
        }
      }
    }
  }
  {
#line 116
  tmp___3 = std2null();
  }
#line 116
  if (tmp___3 < 0) {
    {
#line 117
    exit(1);
    }
  }
#line 120
  if (netlink) {
#line 120
    tmp___4 = "netlink and the input layer";
  } else {
#line 120
    tmp___4 = "proc fs";
  }
  {
#line 120
  acpid_log(6, "starting up with %s", tmp___4);
#line 124
  signal(1, & reload_conf);
#line 125
  signal(2, & clean_exit);
#line 126
  signal(3, & clean_exit);
#line 127
  signal(15, & clean_exit);
#line 128
  signal(13, (void (*)(int  ))1);
#line 131
  tmp___5 = acpid_read_conf(confdir);
  }
#line 131
  if (tmp___5) {
    {
#line 132
    exit(1);
    }
  }
#line 136
  if (! foreground) {
    {
#line 136
    tmp___6 = create_pidfile();
    }
#line 136
    if (tmp___6 < 0) {
      {
#line 137
      exit(1);
      }
    }
  }
#line 140
  if (logevents) {
#line 140
    tmp___7 = "on";
  } else {
#line 140
    tmp___7 = "off";
  }
  {
#line 140
  acpid_log(6, "waiting for events: event logging is %s", tmp___7);
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    tmp___8 = get_fdset();
#line 151
    readfds = (fd_set )*tmp___8;
    }
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 154
      tmp___9 = get_highestfd();
#line 154
      tmp___10 = select(tmp___9 + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
#line 154
      __result = (long )tmp___10;
      }
#line 154
      if (__result == -1L) {
        {
#line 154
        tmp___11 = __errno_location();
        }
#line 154
        if (! (*tmp___11 == 4)) {
#line 154
          goto while_break___0;
        }
      } else {
#line 154
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 154
    nready = (int )__result;
#line 156
    if (nready < 0) {
      {
#line 157
      tmp___12 = __errno_location();
#line 157
      tmp___13 = strerror(*tmp___12);
#line 157
      acpid_log(3, "select(): %s", tmp___13);
      }
#line 158
      goto while_continue;
    }
    {
#line 162
    acpid_close_dead_clients();
#line 165
    i = 0;
    }
    {
#line 165
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 165
      tmp___14 = get_number_of_connections();
      }
#line 165
      if (! (i <= tmp___14)) {
#line 165
        goto while_break___1;
      }
      {
#line 168
      p = get_connection(i);
      }
#line 171
      if (! p) {
#line 172
        goto while_break___1;
      }
#line 175
      fd = p->fd;
#line 178
      if ((readfds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 180
        (*(p->process))(fd);
        }
      }
#line 165
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  clean_exit_with_status(0);
  }
#line 187
  return (0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int handle_cmdline(int *argc , char ***argv ) 
{ 
  struct option opts___0[17] ;
  char const   *opts_help___0[16] ;
  struct option *opt ;
  char const   **hlp ;
  int max ;
  int size ;
  int i ;
  long tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 196
  opts___0[0].name = "confdir";
#line 196
  opts___0[0].has_arg = 1;
#line 196
  opts___0[0].flag = (int *)0;
#line 196
  opts___0[0].val = 'c';
#line 196
  opts___0[1].name = "clientmax";
#line 196
  opts___0[1].has_arg = 1;
#line 196
  opts___0[1].flag = (int *)0;
#line 196
  opts___0[1].val = 'C';
#line 196
  opts___0[2].name = "debug";
#line 196
  opts___0[2].has_arg = 0;
#line 196
  opts___0[2].flag = (int *)0;
#line 196
  opts___0[2].val = 'd';
#line 196
  opts___0[3].name = "eventfile";
#line 196
  opts___0[3].has_arg = 1;
#line 196
  opts___0[3].flag = (int *)0;
#line 196
  opts___0[3].val = 'e';
#line 196
  opts___0[4].name = "foreground";
#line 196
  opts___0[4].has_arg = 0;
#line 196
  opts___0[4].flag = (int *)0;
#line 196
  opts___0[4].val = 'f';
#line 196
  opts___0[5].name = "logevents";
#line 196
  opts___0[5].has_arg = 0;
#line 196
  opts___0[5].flag = (int *)0;
#line 196
  opts___0[5].val = 'l';
#line 196
  opts___0[6].name = "socketgroup";
#line 196
  opts___0[6].has_arg = 1;
#line 196
  opts___0[6].flag = (int *)0;
#line 196
  opts___0[6].val = 'g';
#line 196
  opts___0[7].name = "socketmode";
#line 196
  opts___0[7].has_arg = 1;
#line 196
  opts___0[7].flag = (int *)0;
#line 196
  opts___0[7].val = 'm';
#line 196
  opts___0[8].name = "socketfile";
#line 196
  opts___0[8].has_arg = 1;
#line 196
  opts___0[8].flag = (int *)0;
#line 196
  opts___0[8].val = 's';
#line 196
  opts___0[9].name = "nosocket";
#line 196
  opts___0[9].has_arg = 1;
#line 196
  opts___0[9].flag = (int *)0;
#line 196
  opts___0[9].val = 'S';
#line 196
  opts___0[10].name = "pidfile";
#line 196
  opts___0[10].has_arg = 1;
#line 196
  opts___0[10].flag = (int *)0;
#line 196
  opts___0[10].val = 'p';
#line 196
  opts___0[11].name = "lockfile";
#line 196
  opts___0[11].has_arg = 1;
#line 196
  opts___0[11].flag = (int *)0;
#line 196
  opts___0[11].val = 'L';
#line 196
  opts___0[12].name = "netlink";
#line 196
  opts___0[12].has_arg = 0;
#line 196
  opts___0[12].flag = (int *)0;
#line 196
  opts___0[12].val = 'n';
#line 196
  opts___0[13].name = "dropaction";
#line 196
  opts___0[13].has_arg = 1;
#line 196
  opts___0[13].flag = (int *)0;
#line 196
  opts___0[13].val = 'r';
#line 196
  opts___0[14].name = "version";
#line 196
  opts___0[14].has_arg = 0;
#line 196
  opts___0[14].flag = (int *)0;
#line 196
  opts___0[14].val = 'v';
#line 196
  opts___0[15].name = "help";
#line 196
  opts___0[15].has_arg = 0;
#line 196
  opts___0[15].flag = (int *)0;
#line 196
  opts___0[15].val = 'h';
#line 196
  opts___0[16].name = (char const   *)((void *)0);
#line 196
  opts___0[16].has_arg = 0;
#line 196
  opts___0[16].flag = (int *)0;
#line 196
  opts___0[16].val = 0;
#line 215
  opts_help___0[0] = "Set the configuration directory.";
#line 215
  opts_help___0[1] = "Set the limit on non-root socket connections.";
#line 215
  opts_help___0[2] = "Increase debugging level (implies -f).";
#line 215
  opts_help___0[3] = "Use the specified file for events.";
#line 215
  opts_help___0[4] = "Run in the foreground.";
#line 215
  opts_help___0[5] = "Log all event activity.";
#line 215
  opts_help___0[6] = "Set the group on the socket file.";
#line 215
  opts_help___0[7] = "Set the permissions on the socket file.";
#line 215
  opts_help___0[8] = "Use the specified socket file.";
#line 215
  opts_help___0[9] = "Do not listen on a UNIX socket (overrides -s).";
#line 215
  opts_help___0[10] = "Use the specified PID file.";
#line 215
  opts_help___0[11] = "Use the specified lockfile to stop processing.";
#line 215
  opts_help___0[12] = "Force netlink/input layer mode. (overrides -e)";
#line 215
  opts_help___0[13] = "Define the pseudo-action to drop an event.";
#line 215
  opts_help___0[14] = "Print version information.";
#line 215
  opts_help___0[15] = "Print this message.";
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 239
    i = getopt_long(*argc, (char * const  *)*argv, "c:C:de:flg:m:s:Sp:L:nr:vh", (struct option  const  *)(opts___0),
                    (int *)((void *)0));
    }
#line 241
    if (i == -1) {
#line 242
      goto while_break;
    }
    {
#line 245
    if (i == 99) {
#line 245
      goto case_99;
    }
#line 248
    if (i == 67) {
#line 248
      goto case_67;
    }
#line 251
    if (i == 100) {
#line 251
      goto case_100;
    }
#line 256
    if (i == 101) {
#line 256
      goto case_101;
    }
#line 259
    if (i == 102) {
#line 259
      goto case_102;
    }
#line 262
    if (i == 108) {
#line 262
      goto case_108;
    }
#line 265
    if (i == 103) {
#line 265
      goto case_103;
    }
#line 268
    if (i == 109) {
#line 268
      goto case_109;
    }
#line 271
    if (i == 115) {
#line 271
      goto case_115;
    }
#line 274
    if (i == 83) {
#line 274
      goto case_83;
    }
#line 277
    if (i == 112) {
#line 277
      goto case_112;
    }
#line 280
    if (i == 76) {
#line 280
      goto case_76;
    }
#line 283
    if (i == 110) {
#line 283
      goto case_110;
    }
#line 286
    if (i == 114) {
#line 286
      goto case_114;
    }
#line 289
    if (i == 118) {
#line 289
      goto case_118;
    }
#line 293
    goto switch_default;
    case_99: /* CIL Label */ 
#line 246
    confdir = (char const   *)optarg;
#line 247
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 249
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                 0);
#line 249
    clientmax = (int )tmp;
    }
#line 250
    goto switch_break;
    case_100: /* CIL Label */ 
#line 252
    foreground = 1;
#line 253
    acpid_debug ++;
#line 254
    log_debug_to_stderr = 1;
#line 255
    goto switch_break;
    case_101: /* CIL Label */ 
#line 257
    eventfile = (char const   *)optarg;
#line 258
    goto switch_break;
    case_102: /* CIL Label */ 
#line 260
    foreground = 1;
#line 261
    goto switch_break;
    case_108: /* CIL Label */ 
#line 263
    logevents = 1;
#line 264
    goto switch_break;
    case_103: /* CIL Label */ 
#line 266
    socketgroup = (char const   *)optarg;
#line 267
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 269
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     8);
#line 269
    socketmode = (mode_t )tmp___0;
    }
#line 270
    goto switch_break;
    case_115: /* CIL Label */ 
#line 272
    socketfile = (char const   *)optarg;
#line 273
    goto switch_break;
    case_83: /* CIL Label */ 
#line 275
    nosocket = 1;
#line 276
    goto switch_break;
    case_112: /* CIL Label */ 
#line 278
    pidfile = (char const   *)optarg;
#line 279
    goto switch_break;
    case_76: /* CIL Label */ 
#line 281
    lockfile = (char const   *)optarg;
#line 282
    goto switch_break;
    case_110: /* CIL Label */ 
#line 284
    netlink = 1;
#line 285
    goto switch_break;
    case_114: /* CIL Label */ 
#line 287
    dropaction = (char const   *)optarg;
#line 288
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 290
    printf((char const   */* __restrict  */)"acpid-2.0.21\n");
#line 291
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 294
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [OPTIONS]\n",
            progname);
#line 295
    max = 0;
#line 296
    opt = opts___0;
    }
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 296
      if (! opt->name) {
#line 296
        goto while_break___0;
      }
      {
#line 297
      tmp___1 = strlen(opt->name);
#line 297
      size = (int )tmp___1;
      }
#line 298
      if (size > max) {
#line 299
        max = size;
      }
#line 296
      opt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    opt = opts___0;
#line 301
    hlp = opts_help___0;
    {
#line 301
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 301
      if (! opt->name) {
#line 301
        goto while_break___1;
      }
      {
#line 304
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -%c, --%s",
              opt->val, opt->name);
#line 306
      tmp___2 = strlen(opt->name);
#line 306
      size = (int )tmp___2;
      }
      {
#line 307
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 307
        if (! (size < max)) {
#line 307
          goto while_break___2;
        }
        {
#line 308
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ");
#line 307
        size ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s\n",
              *hlp);
#line 301
      opt ++;
#line 301
      hlp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 311
    exit(1);
    }
#line 312
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  *argc -= optind;
#line 317
  *argv += optind;
#line 319
  return (0);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static void close_fds(void) 
{ 
  struct dirent *dent ;
  DIR *dirp ;
  char *endp ;
  long fd ;
  int tmp ;

  {
  {
#line 330
  dirp = opendir("/proc/self/fd");
  }
#line 330
  if ((unsigned long )dirp != (unsigned long )((void *)0)) {
    {
#line 331
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 331
      dent = readdir(dirp);
      }
#line 331
      if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 331
        goto while_break;
      }
      {
#line 332
      fd = strtol((char const   */* __restrict  */)(dent->d_name), (char **/* __restrict  */)(& endp),
                  10);
      }
#line 333
      if ((unsigned long )(dent->d_name) != (unsigned long )endp) {
#line 333
        if ((int )*endp == 0) {
#line 333
          if (fd >= 3L) {
            {
#line 333
            tmp = dirfd(dirp);
            }
#line 333
            if (fd != (long )tmp) {
              {
#line 335
              close((int )fd);
              }
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 338
    closedir(dirp);
    }
  }
#line 340
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int daemonize(void) 
{ 
  pid_t pid ;
  pid_t sid ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 347
  pid = fork();
  }
#line 348
  if (pid < 0) {
    {
#line 349
    tmp = __errno_location();
#line 349
    tmp___0 = strerror(*tmp);
#line 349
    acpid_log(3, "fork: %s", tmp___0);
    }
#line 350
    return (-1);
  }
#line 353
  if (pid > 0) {
    {
#line 354
    exit(0);
    }
  }
  {
#line 361
  umask((__mode_t )0);
#line 365
  sid = setsid();
  }
#line 366
  if (sid < 0) {
    {
#line 367
    tmp___1 = __errno_location();
#line 367
    tmp___2 = strerror(*tmp___1);
#line 367
    acpid_log(3, "setsid: %s", tmp___2);
    }
#line 368
    return (-1);
  }
  {
#line 373
  tmp___5 = chdir("/");
  }
#line 373
  if (tmp___5 < 0) {
    {
#line 374
    tmp___3 = __errno_location();
#line 374
    tmp___4 = strerror(*tmp___3);
#line 374
    acpid_log(3, "chdir(\"/\"): %s", tmp___4);
    }
#line 375
    return (-1);
  }
#line 378
  return (0);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static void open_log(void) 
{ 
  int log_opts ;

  {
#line 387
  log_opts = 10;
#line 388
  if (acpid_debug) {
#line 389
    log_opts |= 32;
  }
  {
#line 391
  openlog("acpid", log_opts, 3 << 3);
  }
#line 392
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int std2null(void) 
{ 
  int nullfd ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 400
  nullfd = open("/dev/null", 2);
  }
#line 401
  if (nullfd < 0) {
    {
#line 402
    tmp = __errno_location();
#line 402
    tmp___0 = strerror(*tmp);
#line 402
    acpid_log(3, "can\'t open /dev/null: %s", tmp___0);
    }
#line 403
    return (-1);
  }
  {
#line 409
  tmp___3 = is_socket(0);
  }
#line 409
  if (! tmp___3) {
    {
#line 409
    tmp___4 = dup2(nullfd, 0);
    }
#line 409
    if (tmp___4 != 0) {
      {
#line 411
      tmp___1 = __errno_location();
#line 411
      tmp___2 = strerror(*tmp___1);
#line 411
      acpid_log(3, "dup2() stdin: %s", tmp___2);
#line 412
      close(nullfd);
      }
#line 413
      return (-1);
    }
  }
#line 415
  if (! acpid_debug) {
    {
#line 415
    tmp___7 = dup2(nullfd, 1);
    }
#line 415
    if (tmp___7 != 1) {
      {
#line 416
      tmp___5 = __errno_location();
#line 416
      tmp___6 = strerror(*tmp___5);
#line 416
      acpid_log(3, "dup2() stdout: %s", tmp___6);
#line 417
      close(nullfd);
      }
#line 418
      return (-1);
    }
  }
#line 420
  if (! acpid_debug) {
    {
#line 420
    tmp___10 = dup2(nullfd, 2);
    }
#line 420
    if (tmp___10 != 2) {
      {
#line 421
      tmp___8 = __errno_location();
#line 421
      tmp___9 = strerror(*tmp___8);
#line 421
      acpid_log(3, "dup2() stderr: %s", tmp___9);
#line 422
      close(nullfd);
      }
#line 423
      return (-1);
    }
  }
  {
#line 426
  close(nullfd);
  }
#line 428
  return (0);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static int create_pidfile(void) 
{ 
  int fd ;
  FILE *f ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 437
  unlink(pidfile);
#line 440
  fd = open(pidfile, 193, 420);
  }
#line 441
  if (fd >= 0) {
    {
#line 445
    f = fdopen(fd, "w");
    }
#line 446
    if ((unsigned long )f != (unsigned long )((void *)0)) {
      {
#line 447
      tmp = getpid();
#line 447
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d\n",
              tmp);
#line 448
      fclose(f);
      }
#line 450
      return (0);
    }
    {
#line 452
    close(fd);
    }
  }
  {
#line 456
  tmp___0 = __errno_location();
#line 456
  tmp___1 = strerror(*tmp___0);
#line 456
  acpid_log(3, "can\'t create pidfile %s: %s", pidfile, tmp___1);
  }
#line 458
  return (-1);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
void clean_exit_with_status(int status ) 
{ 


  {
  {
#line 464
  acpid_cleanup_rules(1);
#line 465
  delete_all_connections();
#line 466
  acpid_log(7, "exiting");
#line 467
  unlink(pidfile);
#line 468
  exit(status);
  }
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static void clean_exit(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 474
  clean_exit_with_status(0);
  }
#line 475
  return;
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
static void reload_conf(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 480
  acpid_log(5, "reloading configuration");
#line 481
  acpid_cleanup_rules(0);
#line 482
  acpid_read_conf(confdir);
  }
#line 483
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpid.c"
int locked(void) 
{ 
  struct stat trash ;
  int tmp ;

  {
  {
#line 491
  tmp = stat((char const   */* __restrict  */)lockfile, (struct stat */* __restrict  */)(& trash));
  }
#line 491
  return (tmp == 0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 87 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_init1)(int __flags ) ;
#line 91
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_add_watch)(int __fd ,
                                                                                        char const   *__name ,
                                                                                        uint32_t __mask ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/inotify_handler.c"
static void process_inotify(int fd ) 
{ 
  int bytes ;
  union __anonunion_eventbuf_13 eventbuf ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int dnsize ;
  char *devname ;
  unsigned long __lengthofdevname ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 53
  tmp = read(fd, (void *)(& eventbuf.buffer), sizeof(eventbuf.buffer));
#line 53
  bytes = (int )tmp;
#line 55
  acpid_log(7, "inotify read bytes: %d", bytes);
  }
#line 58
  if (bytes == 0) {
    {
#line 59
    acpid_log(4, "inotify fd eof encountered");
    }
#line 60
    return;
  } else
#line 62
  if (bytes < 0) {
    {
#line 64
    tmp___0 = __errno_location();
#line 64
    tmp___1 = __errno_location();
#line 64
    tmp___2 = strerror(*tmp___1);
#line 64
    acpid_log(3, "inotify read error: %s (%d)", tmp___2, *tmp___0);
#line 66
    acpid_log(3, "disconnecting from inotify");
#line 67
    delete_connection(fd);
    }
#line 68
    return;
  }
  {
#line 71
  acpid_log(7, "inotify name len: %d", eventbuf.event.len);
#line 73
  dnsize = 256;
#line 74
  __lengthofdevname = (unsigned long )dnsize;
#line 74
  tmp___3 = __builtin_alloca(sizeof(*devname) * __lengthofdevname);
#line 74
  devname = (char *)tmp___3;
  }
#line 77
  if (eventbuf.event.len > 0U) {
    {
#line 79
    strcpy((char */* __restrict  */)devname, (char const   */* __restrict  */)"/dev/input");
#line 80
    strcat((char */* __restrict  */)devname, (char const   */* __restrict  */)"/");
#line 81
    tmp___4 = strlen((char const   *)devname);
#line 81
    strncat((char */* __restrict  */)devname, (char const   */* __restrict  */)(eventbuf.event.name),
            ((size_t )dnsize - tmp___4) - 1UL);
    }
  }
#line 85
  if (eventbuf.event.mask & 256U) {
    {
#line 86
    acpid_log(7, "inotify about to open: %s", devname);
#line 88
    open_inputfile((char const   *)devname);
    }
  }
#line 92
  if (eventbuf.event.mask & 512U) {
    {
#line 95
    acpid_log(7, "inotify received a delete for: %s", devname);
    }
  }
#line 110
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/inotify_handler.c"
void open_inotify(void) 
{ 
  int fd ;
  int wd ;
  struct connection c ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 116
  fd = -1;
#line 117
  wd = -1;
#line 121
  fd = inotify_init1(524288);
  }
#line 123
  if (fd < 0) {
    {
#line 124
    tmp = __errno_location();
#line 124
    tmp___0 = __errno_location();
#line 124
    tmp___1 = strerror(*tmp___0);
#line 124
    acpid_log(3, "inotify_init() failed: %s (%d)", tmp___1, *tmp);
    }
#line 126
    return;
  }
  {
#line 129
  acpid_log(7, "inotify fd: %d", fd);
#line 132
  wd = inotify_add_watch(fd, "/dev/input", (uint32_t )768);
  }
#line 134
  if (wd < 0) {
    {
#line 135
    tmp___2 = __errno_location();
#line 135
    tmp___3 = __errno_location();
#line 135
    tmp___4 = strerror(*tmp___3);
#line 135
    acpid_log(3, "inotify_add_watch() failed: %s (%d)", tmp___4, *tmp___2);
#line 137
    close(fd);
    }
#line 138
    return;
  }
  {
#line 141
  acpid_log(7, "inotify wd: %d", wd);
#line 144
  c.fd = fd;
#line 145
  c.process = & process_inotify;
#line 146
  c.pathname = (char *)((void *)0);
#line 147
  c.kybd = 0;
#line 149
  tmp___5 = add_connection(& c);
  }
#line 149
  if (tmp___5 < 0) {
    {
#line 150
    close(fd);
#line 151
    acpid_log(3, "can\'t add connection for inotify");
    }
#line 152
    return;
  }
#line 154
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.h"
__u16 acpi_ids_getfamily(void) ;
#line 28
__u32 acpi_ids_getgroup(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/netlink.c"
static void format_netlink(struct nlmsghdr *msg ) 
{ 
  struct rtattr *tb[2] ;
  struct genlmsghdr *ghdr ;
  int len ;
  struct rtattr *attrs ;
  __u16 tmp ;
  struct acpi_genl_event *event ;
  char buf___2[64] ;
  int tmp___0 ;

  {
  {
#line 54
  ghdr = (struct genlmsghdr *)((void *)((char *)msg + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 58
  len = (int )msg->nlmsg_len;
#line 61
  tmp = acpi_ids_getfamily();
  }
#line 61
  if ((int )msg->nlmsg_type != (int )tmp) {
#line 62
    if (logevents) {
      {
#line 63
      acpid_log(6, "wrong netlink family ID.");
      }
    }
#line 65
    return;
  }
#line 68
  len = (int )((unsigned long )len - ((((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))));
#line 70
  if (len < 0) {
    {
#line 71
    acpid_log(4, "wrong netlink controller message len: %d", len);
    }
#line 73
    return;
  }
  {
#line 76
  attrs = (struct rtattr *)((char *)ghdr + (((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
#line 78
  parse_rtattr(tb, 1, attrs, len);
  }
#line 81
  if (tb[1]) {
    {
#line 83
    event = (struct acpi_genl_event *)((void *)((char *)tb[1] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 88
    snprintf((char */* __restrict  */)(buf___2), sizeof(buf___2), (char const   */* __restrict  */)"%s %s %08x %08x",
             event->device_class, event->bus_id, event->type, event->data);
#line 92
    tmp___0 = locked();
    }
#line 92
    if (tmp___0) {
#line 93
      if (logevents) {
        {
#line 94
        acpid_log(6, "lockfile present, not processing netlink event \"%s\"", buf___2);
        }
      }
#line 98
      return;
    }
#line 101
    if (logevents) {
      {
#line 102
      acpid_log(6, "received netlink event \"%s\"", buf___2);
      }
    }
    {
#line 106
    acpid_handle_event((char const   *)(buf___2));
    }
#line 108
    if (logevents) {
      {
#line 109
      acpid_log(6, "completed netlink event \"%s\"", buf___2);
      }
    }
  }
#line 112
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/netlink.c"
static int nerrs___0  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/netlink.c"
static void process_netlink(int fd ) 
{ 
  int status ;
  struct nlmsghdr *h ;
  struct sockaddr_nl nladdr ;
  struct iovec iov ;
  struct msghdr msg ;
  char buf___2[8192] ;
  long __result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int len ;
  int l ;

  {
  {
#line 125
  msg.msg_name = (void *)(& nladdr);
#line 125
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 125
  msg.msg_iov = & iov;
#line 125
  msg.msg_iovlen = (size_t )1;
#line 125
  msg.msg_control = (void *)0;
#line 125
  msg.msg_controllen = 0UL;
#line 125
  msg.msg_flags = 0;
#line 136
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 137
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 138
  nladdr.nl_pid = (__u32 )0;
#line 139
  nladdr.nl_groups = (__u32 )0;
#line 142
  iov.iov_base = (void *)(buf___2);
#line 143
  iov.iov_len = sizeof(buf___2);
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 146
    tmp = recvmsg(fd, & msg, 1073741824);
#line 146
    __result = tmp;
    }
#line 146
    if (__result == -1L) {
      {
#line 146
      tmp___0 = __errno_location();
      }
#line 146
      if (! (*tmp___0 == 4)) {
#line 146
        goto while_break;
      }
    } else {
#line 146
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  status = (int )__result;
#line 149
  if (status < 0) {
    {
#line 150
    tmp___1 = __errno_location();
#line 150
    tmp___2 = __errno_location();
#line 150
    tmp___3 = strerror(*tmp___2);
#line 150
    acpid_log(3, "netlink read error: %s (%d)", tmp___3, *tmp___1);
#line 152
    nerrs___0 ++;
    }
#line 152
    if (nerrs___0 >= 5) {
      {
#line 153
      acpid_log(3, "too many errors reading via netlink - aborting");
#line 156
      exit(1);
      }
    }
#line 158
    return;
  }
#line 161
  if (status == 0) {
    {
#line 162
    acpid_log(4, "netlink connection closed");
#line 163
    exit(1);
    }
  }
#line 166
  if ((unsigned long )msg.msg_namelen != sizeof(nladdr)) {
    {
#line 167
    acpid_log(4, "netlink unexpected length: %d   expected: %zd", msg.msg_namelen,
              sizeof(nladdr));
    }
#line 169
    return;
  }
#line 173
  h = (struct nlmsghdr *)(buf___2);
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 173
    if (! ((unsigned long )((unsigned int )status) >= sizeof(*h))) {
#line 173
      goto while_break___0;
    }
#line 174
    len = (int )h->nlmsg_len;
#line 175
    l = (int )((unsigned long )len - sizeof(*h));
#line 177
    if (l < 0) {
#line 177
      goto _L;
    } else
#line 177
    if (len > status) {
      _L: /* CIL Label */ 
#line 178
      if (msg.msg_flags & 32) {
        {
#line 179
        acpid_log(4, "netlink msg truncated (1)");
        }
#line 180
        return;
      }
      {
#line 182
      acpid_log(4, "malformed netlink msg, length %d", len);
      }
#line 184
      return;
    }
    {
#line 188
    format_netlink(h);
#line 190
    status = (int )((unsigned int )status - ((((unsigned int )len + 4U) - 1U) & 4294967292U));
#line 191
    h = (struct nlmsghdr *)((char *)h + ((((unsigned int )len + 4U) - 1U) & 4294967292U));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  if (msg.msg_flags & 32) {
    {
#line 194
    acpid_log(4, "netlink msg truncated (2)");
    }
#line 195
    return;
  }
#line 197
  if (status) {
    {
#line 198
    acpid_log(4, "netlink remnant of size %d", status);
    }
#line 199
    return;
  }
#line 202
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/netlink.c"
static __u32 nl_mgrp(__u32 group ) 
{ 
  int tmp ;

  {
#line 210
  if (group > 31U) {
    {
#line 211
    acpid_log(3, "Unexpected group number %d", group);
    }
#line 212
    return ((__u32 )0);
  }
#line 214
  if (group) {
#line 214
    tmp = 1 << (group - 1U);
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((__u32 )tmp);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/netlink.c"
void open_netlink(void) 
{ 
  struct rtnl_handle rth ;
  struct connection c ;
  __u32 tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 223
  tmp = acpi_ids_getgroup();
#line 223
  tmp___0 = nl_mgrp(tmp);
#line 223
  tmp___1 = rtnl_open_byproto(& rth, tmp___0, 16);
  }
#line 223
  if (tmp___1 < 0) {
    {
#line 225
    acpid_log(3, "cannot open generic netlink socket");
    }
#line 226
    return;
  }
  {
#line 229
  acpid_log(7, "netlink opened successfully");
#line 232
  c.fd = rth.fd;
#line 233
  c.process = & process_netlink;
#line 234
  c.pathname = (char *)((void *)0);
#line 235
  c.kybd = 0;
#line 237
  tmp___2 = add_connection(& c);
  }
#line 237
  if (tmp___2 < 0) {
    {
#line 238
    rtnl_close(& rth);
#line 239
    acpid_log(3, "can\'t add connection for generic netlink socket");
    }
#line 241
    return;
  }
#line 243
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.c"
char const   *eventfile  =    "/proc/acpi/event";
#line 39
static char *read_line(int fd ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.c"
static int nerrs___1  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.c"
static void process_proc(int fd ) 
{ 
  char *event ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 47
  event = read_line(fd);
#line 50
  tmp = locked();
  }
#line 50
  if (tmp) {
#line 51
    if (logevents) {
#line 51
      if ((unsigned long )event != (unsigned long )((void *)0)) {
        {
#line 52
        acpid_log(6, "lockfile present, not processing event \"%s\"", event);
        }
      }
    }
#line 56
    return;
  }
#line 60
  if (event) {
#line 61
    if (logevents) {
      {
#line 62
      acpid_log(6, "procfs received event \"%s\"", event);
      }
    }
    {
#line 65
    acpid_handle_event((char const   *)event);
    }
#line 66
    if (logevents) {
      {
#line 67
      acpid_log(6, "procfs completed event \"%s\"", event);
      }
    }
  } else {
    {
#line 70
    tmp___0 = __errno_location();
    }
#line 70
    if (*tmp___0 == 32) {
      {
#line 71
      acpid_log(4, "events file connection closed");
#line 73
      exit(1);
      }
    } else {
#line 76
      nerrs___1 ++;
#line 76
      if (nerrs___1 >= 5) {
        {
#line 77
        acpid_log(3, "too many errors reading events file - aborting");
#line 80
        exit(1);
        }
      }
    }
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.c"
int open_proc(void) 
{ 
  int fd ;
  struct connection c ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 93
  fd = open(eventfile, 524288);
  }
#line 94
  if (fd < 0) {
    {
#line 95
    tmp___2 = __errno_location();
    }
#line 95
    if (*tmp___2 == 2) {
      {
#line 96
      acpid_log(7, "Deprecated %s was not found.  Trying netlink and the input layer...",
                eventfile);
      }
    } else {
      {
#line 99
      tmp = __errno_location();
#line 99
      tmp___0 = __errno_location();
#line 99
      tmp___1 = strerror(*tmp___0);
#line 99
      acpid_log(3, "can\'t open %s: %s (%d)", eventfile, tmp___1, *tmp);
      }
    }
#line 102
    return (-1);
  }
  {
#line 105
  acpid_log(7, "proc fs opened successfully");
#line 108
  c.fd = fd;
#line 109
  c.process = & process_proc;
#line 110
  c.pathname = (char *)((void *)0);
#line 111
  c.kybd = 0;
#line 113
  tmp___3 = add_connection(& c);
  }
#line 113
  if (tmp___3 < 0) {
    {
#line 114
    close(fd);
#line 115
    acpid_log(3, "can\'t add connection for %s", eventfile);
    }
#line 116
    return (-1);
  }
#line 119
  return (0);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.c"
static char buf___0[1024]  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/proc.c"
static char *read_line(int fd ) 
{ 
  int i ;
  int r ;
  int searching ;
  long __result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
#line 130
  i = 0;
#line 132
  searching = 1;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! searching) {
#line 134
      goto while_break;
    }
    {
#line 135
    memset((void *)(buf___0 + i), 0, (size_t )(1024 - i));
    }
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 138
      if (! (i < 1023)) {
#line 138
        goto while_break___0;
      }
      {
#line 139
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 139
        tmp = read(fd, (void *)(buf___0 + i), (size_t )1);
#line 139
        __result = tmp;
        }
#line 139
        if (__result == -1L) {
          {
#line 139
          tmp___0 = __errno_location();
          }
#line 139
          if (! (*tmp___0 == 4)) {
#line 139
            goto while_break___1;
          }
        } else {
#line 139
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 139
      r = (int )__result;
#line 140
      if (r < 0) {
        {
#line 142
        tmp___1 = __errno_location();
#line 142
        tmp___2 = strerror(*tmp___1);
#line 142
        acpid_log(3, "read(): %s", tmp___2);
        }
#line 144
        return ((char *)((void *)0));
      } else
#line 145
      if (r == 0) {
        {
#line 147
        tmp___3 = __errno_location();
#line 147
        *tmp___3 = 32;
        }
#line 148
        return ((char *)((void *)0));
      } else
#line 149
      if (r == 1) {
#line 151
        if ((int )buf___0[i] == 10) {
#line 152
          searching = 0;
#line 153
          buf___0[i] = (char )'\000';
#line 154
          goto while_break___0;
        }
#line 156
        i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 159
    if (i >= 1023) {
#line 160
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return (buf___0);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static int initialized  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static __u16 acpi_event_family_id  =    (__u16 )0;
#line 40 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static __u32 acpi_event_mcast_group_id  =    (__u32 )0;
#line 53 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static int get_ctrl_grp_id(struct rtattr *arg ) 
{ 
  struct rtattr *tb[3] ;
  char *name ;
  int tmp ;

  {
#line 59
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 60
    return (-1);
  }
  {
#line 64
  parse_rtattr(tb, 2, (struct rtattr *)((void *)((char *)arg + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
               (int )((unsigned long )((int )arg->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
  }
#line 67
  if (! tb[1]) {
#line 68
    return (-1);
  } else
#line 67
  if (! tb[2]) {
#line 68
    return (-1);
  }
  {
#line 71
  name = (char *)((void *)((char *)tb[1] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 74
  tmp = strcmp((char const   *)name, "acpi_mc_group");
  }
#line 74
  if (tmp) {
#line 75
    return (-1);
  }
#line 79
  acpi_event_mcast_group_id = *((__u32 *)((void *)((char *)tb[2] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 82
  return (0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static int genl_get_mcast_group_id(struct nlmsghdr *n ) 
{ 
  struct rtattr *tb[8] ;
  struct genlmsghdr ghdr ;
  int len ;
  struct rtattr *attrs ;
  struct rtattr *tb2[257] ;
  int i ;
  int tmp ;

  {
#line 98
  len = (int )((unsigned long )n->nlmsg_len - ((((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))));
#line 102
  if (len < 0) {
    {
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: netlink CTRL_CMD_GETFAMILY response, wrong controller message len: %d\n",
            progname, len);
    }
#line 105
    return (-1);
  }
#line 108
  if ((int )n->nlmsg_type != 16) {
    {
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not a netlink controller message, nlmsg_len=%d nlmsg_type=0x%x\n",
            progname, n->nlmsg_len, (int )n->nlmsg_type);
    }
#line 112
    return (0);
  }
  {
#line 116
  memcpy((void */* __restrict  */)(& ghdr), (void const   */* __restrict  */)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
         ((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
  }
#line 118
  if ((int )ghdr.cmd != 3) {
#line 118
    if ((int )ghdr.cmd != 2) {
#line 118
      if ((int )ghdr.cmd != 1) {
#line 118
        if ((int )ghdr.cmd != 7) {
#line 118
          if ((int )ghdr.cmd != 8) {
            {
#line 123
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown netlink controller command %d\n",
                    progname, (int )ghdr.cmd);
            }
#line 125
            return (0);
          }
        }
      }
    }
  }
  {
#line 129
  attrs = (struct rtattr *)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)) + (((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
#line 132
  parse_rtattr(tb, 7, attrs, len);
  }
#line 135
  if (tb[1]) {
#line 137
    acpi_event_family_id = (__u16 )*((__u32 *)((void *)((char *)tb[1] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
  }
#line 142
  if (tb[7]) {
    {
#line 147
    parse_rtattr(tb2, 256, (struct rtattr *)((void *)((char *)tb[7] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
                 (int )((unsigned long )((int )(tb[7])->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 151
    i = 0;
    }
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! (i < 256)) {
#line 151
        goto while_break;
      }
#line 153
      if (tb2[i]) {
        {
#line 155
        tmp = get_ctrl_grp_id(tb2[i]);
        }
#line 155
        if (! tmp) {
#line 156
          return (0);
        }
      }
#line 151
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 159
  return (-1);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static int genl_get_ids(char *family_name ) 
{ 
  struct rtnl_handle rth ;
  struct __anonstruct_req_69 req ;
  struct nlmsghdr *nlh ;
  struct genlmsghdr ghdr ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 177
  ret = -1;
#line 180
  memset((void *)(& req), 0, sizeof(req));
#line 183
  nlh = & req.n;
#line 185
  nlh->nlmsg_len = (__u32 )((((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 186
  nlh->nlmsg_flags = (__u16 )5;
#line 187
  nlh->nlmsg_type = (__u16 )16;
#line 190
  memset((void *)(& ghdr), 0, sizeof(struct genlmsghdr ));
#line 192
  ghdr.cmd = (__u8 )3;
#line 194
  memcpy((void */* __restrict  */)((void *)((char *)(& req.n) + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
         (void const   */* __restrict  */)(& ghdr), ((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
#line 197
  tmp = strlen((char const   *)family_name);
#line 197
  addattr_l(nlh, 128, 2, (void const   *)family_name, (int )(tmp + 1UL));
#line 201
  tmp___0 = rtnl_open_byproto(& rth, 0U, 16);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open generic netlink socket\n",
            progname);
    }
#line 204
    return (-1);
  }
  {
#line 211
  tmp___1 = rtnl_talk(& rth, nlh, 0, 0U, nlh, (int (*)(struct sockaddr_nl  const  * ,
                                                       struct nlmsghdr *n , void * ))((void *)0),
                      (void *)0);
  }
#line 211
  if (tmp___1 < 0) {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error talking to the kernel via netlink\n",
            progname);
    }
#line 214
    goto ctrl_done;
  }
  {
#line 218
  tmp___2 = genl_get_mcast_group_id(nlh);
  }
#line 218
  if (tmp___2 < 0) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to get acpi_event netlink multicast group\n",
            progname);
    }
#line 221
    goto ctrl_done;
  }
#line 224
  ret = 0;
  ctrl_done: 
  {
#line 227
  rtnl_close(& rth);
  }
#line 228
  return (ret);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
static void acpi_ids_init(void) 
{ 


  {
  {
#line 235
  genl_get_ids((char *)"acpi_event");
#line 237
  initialized = 1;
  }
#line 238
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
__u16 acpi_ids_getfamily(void) 
{ 


  {
#line 245
  if (initialized == 0) {
    {
#line 246
    acpi_ids_init();
    }
  }
#line 248
  return (acpi_event_family_id);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_ids.c"
__u32 acpi_ids_getgroup(void) 
{ 


  {
#line 256
  if (initialized == 0) {
    {
#line 257
    acpi_ids_init();
    }
  }
#line 259
  return (acpi_event_mcast_group_id);
}
}
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 336 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static int handle_cmdline___0(int *argc , char ***argv ) ;
#line 43
static char *read_line___0(int fd ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static int max_events  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static void time_expired(int signum  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 52
  exit(0);
  }
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static int nerrs___2  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static struct option opts[6]  = {      {"count", 0, (int *)0, 'c'}, 
        {"socketfile", 1, (int *)0, 's'}, 
        {"time", 0, (int *)0, 't'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 118 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static char const   *opts_help[5]  = {      "Set the maximum number of events.",      "Use the specified socket file.",      "Listen for the specified time (in seconds).",      "Print version information.", 
        "Print this message."};
#line 126 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static void usage(FILE *fp ) 
{ 
  struct option *opt ;
  char const   **hlp ;
  int max ;
  int size ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 133
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Usage: %s [OPTIONS]\n",
          progname);
#line 134
  max = 0;
#line 135
  opt = opts;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! opt->name) {
#line 135
      goto while_break;
    }
    {
#line 136
    tmp = strlen(opt->name);
#line 136
    size = (int )tmp;
    }
#line 137
    if (size > max) {
#line 138
      max = size;
    }
#line 135
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  opt = opts;
#line 140
  hlp = opts_help;
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! opt->name) {
#line 140
      goto while_break___0;
    }
    {
#line 141
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  -%c, --%s",
            opt->val, opt->name);
#line 142
    tmp___0 = strlen(opt->name);
#line 142
    size = (int )tmp___0;
    }
    {
#line 143
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 143
      if (! (size < max)) {
#line 143
        goto while_break___1;
      }
      {
#line 144
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 143
      size ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 145
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %s\n",
            *hlp);
#line 140
    opt ++;
#line 140
    hlp ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static int handle_cmdline___0(int *argc , char ***argv ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    i = getopt_long(*argc, (char * const  *)*argv, "c:s:t:vh", (struct option  const  *)(opts),
                    (int *)((void *)0));
    }
#line 158
    if (i == -1) {
#line 159
      goto while_break;
    }
    {
#line 162
    if (i == 99) {
#line 162
      goto case_99;
    }
#line 169
    if (i == 115) {
#line 169
      goto case_115;
    }
#line 172
    if (i == 116) {
#line 172
      goto case_116;
    }
#line 179
    if (i == 118) {
#line 179
      goto case_118;
    }
#line 182
    if (i == 104) {
#line 182
      goto case_104;
    }
#line 185
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 163
    tmp = __ctype_b_loc();
    }
#line 163
    if (! ((int const   )*(*tmp + (int )*(optarg + 0)) & 2048)) {
      {
#line 164
      usage(stderr);
#line 165
      exit(1);
      }
    }
    {
#line 167
    max_events = atoi((char const   *)optarg);
    }
#line 168
    goto switch_break;
    case_115: /* CIL Label */ 
#line 170
    socketfile = (char const   *)optarg;
#line 171
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 173
    tmp___0 = __ctype_b_loc();
    }
#line 173
    if (! ((int const   )*(*tmp___0 + (int )*(optarg + 0)) & 2048)) {
      {
#line 174
      usage(stderr);
#line 175
      exit(1);
      }
    }
    {
#line 177
    tmp___1 = atoi((char const   *)optarg);
#line 177
    alarm((unsigned int )tmp___1);
    }
#line 178
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 180
    printf((char const   */* __restrict  */)"acpid-2.0.21\n");
#line 181
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 183
    usage(stdout);
#line 184
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 186
    usage(stderr);
#line 187
    exit(1);
    }
#line 188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  *argc -= optind;
#line 193
  *argv += optind;
#line 195
  return (0);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static char *buf___1  ;
#line 199 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/acpi_listen.c"
static char *read_line___0(int fd ) 
{ 
  int buflen ;
  int i ;
  int r ;
  int searching ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  long __result ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;

  {
#line 203
  buflen = 64;
#line 204
  i = 0;
#line 206
  searching = 1;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! searching) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp = realloc((void *)buf___1, (size_t )buflen);
#line 209
    buf___1 = (char *)tmp;
    }
#line 210
    if (! buf___1) {
      {
#line 211
      tmp___0 = __errno_location();
#line 211
      tmp___1 = strerror(*tmp___0);
#line 211
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERR: malloc(%d): %s\n",
              buflen, tmp___1);
      }
#line 213
      return ((char *)((void *)0));
    }
    {
#line 215
    memset((void *)(buf___1 + i), 0, (size_t )(buflen - i));
    }
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (i < buflen)) {
#line 217
        goto while_break___0;
      }
      {
#line 218
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 218
        tmp___2 = read(fd, (void *)(buf___1 + i), (size_t )1);
#line 218
        __result = tmp___2;
        }
#line 218
        if (__result == -1L) {
          {
#line 218
          tmp___3 = __errno_location();
          }
#line 218
          if (! (*tmp___3 == 4)) {
#line 218
            goto while_break___1;
          }
        } else {
#line 218
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 218
      r = (int )__result;
#line 219
      if (r < 0) {
        {
#line 221
        tmp___4 = __errno_location();
#line 221
        tmp___5 = strerror(*tmp___4);
#line 221
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERR: read(): %s\n",
                tmp___5);
        }
#line 223
        return ((char *)((void *)0));
      } else
#line 224
      if (r == 0) {
        {
#line 226
        tmp___6 = __errno_location();
#line 226
        *tmp___6 = 32;
        }
#line 227
        return ((char *)((void *)0));
      } else
#line 228
      if (r == 1) {
#line 230
        if ((int )*(buf___1 + i) == 10) {
#line 231
          searching = 0;
#line 232
          *(buf___1 + i) = (char )'\000';
#line 233
          goto while_break___0;
        }
#line 235
        i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 238
    if (buflen >= 1024) {
#line 239
      goto while_break;
    }
#line 241
    buflen *= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  return (buf___1);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/connection_list.c"
static struct connection___0 connection_list___0[20]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/connection_list.c"
static int nconnections___0  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/connection_list.c"
static fd_set allfds___0  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/connection_list.c"
static int highestfd___0  =    -2;
#line 37 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static int initialized___0  =    0;
#line 38 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static __u16 acpi_event_family_id___0  =    (__u16 )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static __u32 acpi_event_mcast_group_id___0  =    (__u32 )0;
#line 52 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static int get_ctrl_grp_id___0(struct rtattr *arg ) 
{ 
  struct rtattr *tb[3] ;
  char *name ;
  int tmp ;

  {
#line 58
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 59
    return (-1);
  }
  {
#line 63
  parse_rtattr(tb, 2, (struct rtattr *)((void *)((char *)arg + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
               (int )((unsigned long )((int )arg->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
  }
#line 66
  if (! tb[1]) {
#line 67
    return (-1);
  } else
#line 66
  if (! tb[2]) {
#line 67
    return (-1);
  }
  {
#line 70
  name = (char *)((void *)((char *)tb[1] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 73
  tmp = strcmp((char const   *)name, "acpi_mc_group");
  }
#line 73
  if (tmp) {
#line 74
    return (-1);
  }
#line 78
  acpi_event_mcast_group_id___0 = *((__u32 *)((void *)((char *)tb[2] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
#line 81
  return (0);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static int genl_get_mcast_group_id___0(struct nlmsghdr *n ) 
{ 
  struct rtattr *tb[8] ;
  struct genlmsghdr ghdr ;
  int len ;
  struct rtattr *attrs ;
  struct rtattr *tb2[257] ;
  int i ;
  int tmp ;

  {
#line 97
  len = (int )((unsigned long )n->nlmsg_len - ((((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))));
#line 101
  if (len < 0) {
    {
#line 102
    printf((char const   */* __restrict  */)"Netlink: CTRL_CMD_GETFAMILY response, wrong controller message len: %d\n",
           len);
    }
#line 104
    return (-1);
  }
#line 107
  if ((int )n->nlmsg_type != 16) {
    {
#line 108
    printf((char const   */* __restrict  */)"Netlink: Not a controller message, nlmsg_len=%d nlmsg_type=0x%x\n",
           n->nlmsg_len, (int )n->nlmsg_type);
    }
#line 110
    return (0);
  }
  {
#line 114
  memcpy((void */* __restrict  */)(& ghdr), (void const   */* __restrict  */)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
         ((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
  }
#line 116
  if ((int )ghdr.cmd != 3) {
#line 116
    if ((int )ghdr.cmd != 2) {
#line 116
      if ((int )ghdr.cmd != 1) {
#line 116
        if ((int )ghdr.cmd != 7) {
#line 116
          if ((int )ghdr.cmd != 8) {
            {
#line 121
            printf((char const   */* __restrict  */)"Netlink: Unknown controller command %d\n",
                   (int )ghdr.cmd);
            }
#line 122
            return (0);
          }
        }
      }
    }
  }
  {
#line 126
  attrs = (struct rtattr *)((void *)((char *)n + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)) + (((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
#line 129
  parse_rtattr(tb, 7, attrs, len);
  }
#line 132
  if (tb[1]) {
#line 134
    acpi_event_family_id___0 = (__u16 )*((__u32 *)((void *)((char *)tb[1] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))));
  }
#line 139
  if (tb[7]) {
    {
#line 144
    parse_rtattr(tb2, 256, (struct rtattr *)((void *)((char *)tb[7] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL))),
                 (int )((unsigned long )((int )(tb[7])->rta_len) - (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 148
    i = 0;
    }
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! (i < 256)) {
#line 148
        goto while_break;
      }
#line 150
      if (tb2[i]) {
        {
#line 152
        tmp = get_ctrl_grp_id___0(tb2[i]);
        }
#line 152
        if (! tmp) {
#line 153
          return (0);
        }
      }
#line 148
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 156
  return (-1);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static int genl_get_ids___0(char *family_name ) 
{ 
  struct rtnl_handle rth ;
  struct __anonstruct_req_69___0 req ;
  struct nlmsghdr *nlh ;
  struct genlmsghdr ghdr ;
  int ret ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 174
  ret = -1;
#line 177
  memset((void *)(& req), 0, sizeof(req));
#line 180
  nlh = & req.n;
#line 182
  nlh->nlmsg_len = (__u32 )((((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 183
  nlh->nlmsg_flags = (__u16 )5;
#line 184
  nlh->nlmsg_type = (__u16 )16;
#line 187
  memset((void *)(& ghdr), 0, sizeof(struct genlmsghdr ));
#line 189
  ghdr.cmd = (__u8 )3;
#line 191
  memcpy((void */* __restrict  */)((void *)((char *)(& req.n) + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))),
         (void const   */* __restrict  */)(& ghdr), ((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL);
#line 194
  tmp = strlen((char const   *)family_name);
#line 194
  addattr_l(nlh, 128, 2, (void const   *)family_name, (int )(tmp + 1UL));
#line 198
  tmp___0 = rtnl_open_byproto(& rth, 0U, 16);
  }
#line 198
  if (tmp___0 < 0) {
    {
#line 199
    printf((char const   */* __restrict  */)"Netlink: Cannot open generic netlink socket\n");
    }
#line 200
    return (-1);
  }
  {
#line 207
  tmp___1 = rtnl_talk(& rth, nlh, 0, 0U, nlh, (int (*)(struct sockaddr_nl  const  * ,
                                                       struct nlmsghdr *n , void * ))((void *)0),
                      (void *)0);
  }
#line 207
  if (tmp___1 < 0) {
    {
#line 208
    printf((char const   */* __restrict  */)"Netlink: Error talking to the kernel\n");
    }
#line 209
    goto ctrl_done;
  }
  {
#line 213
  tmp___2 = genl_get_mcast_group_id___0(nlh);
  }
#line 213
  if (tmp___2 < 0) {
    {
#line 214
    printf((char const   */* __restrict  */)"Netlink: Failed to get acpi_event multicast group\n");
    }
#line 215
    goto ctrl_done;
  }
#line 218
  ret = 0;
  ctrl_done: 
  {
#line 221
  rtnl_close(& rth);
  }
#line 222
  return (ret);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/acpi_ids.c"
static void acpi_ids_init___0(void) 
{ 


  {
  {
#line 229
  genl_get_ids___0((char *)"acpi_event");
#line 231
  initialized___0 = 1;
  }
#line 232
  return;
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/kacpimon.h"
int exitflag ;
#line 57 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/kacpimon.c"
int exitflag  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/kacpimon.c"
static void process_proc___0(int fd ) 
{ 
  int buffsize ;
  char *buffer ;
  unsigned long __lengthofbuffer ;
  void *tmp ;
  ssize_t nbytes ;

  {
  {
#line 65
  buffsize = 1024;
#line 66
  __lengthofbuffer = (unsigned long )buffsize;
#line 66
  tmp = __builtin_alloca(sizeof(*buffer) * __lengthofbuffer);
#line 66
  buffer = (char *)tmp;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 71
    nbytes = read(fd, (void *)buffer, (size_t )(buffsize - 1));
    }
#line 76
    if (nbytes <= 0L) {
#line 77
      goto while_break;
    }
    {
#line 80
    *(buffer + nbytes) = (char)0;
#line 82
    printf((char const   */* __restrict  */)"/proc/acpi/event: %s", buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/kacpimon.c"
static void open_proc___0(void) 
{ 
  char *filename ;
  int fd ;
  struct connection___0 c ;
  int errno2 ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 90
  filename = (char *)"/proc/acpi/event";
#line 94
  fd = open((char const   *)filename, 2048);
  }
#line 95
  if (fd >= 0) {
    {
#line 97
    printf((char const   */* __restrict  */)"%s opened successfully\n", filename);
#line 100
    c.fd = fd;
#line 101
    c.process = & process_proc___0;
#line 102
    add_connection(& c);
    }
  } else {
    {
#line 106
    tmp = __errno_location();
#line 106
    errno2 = *tmp;
#line 107
    tmp___0 = strerror(errno2);
#line 107
    printf((char const   */* __restrict  */)"open for %s: %s (%d)\n", filename, tmp___0,
           errno2);
    }
#line 109
    if (errno2 == 13) {
      {
#line 110
      printf((char const   */* __restrict  */)"  (try running as root)\n");
      }
    }
#line 111
    if (errno2 == 2) {
      {
#line 112
      printf((char const   */* __restrict  */)"  (ACPI proc filesystem may not be present)\n");
      }
    }
#line 113
    if (errno2 == 16) {
      {
#line 114
      printf((char const   */* __restrict  */)"  (ACPI proc filesystem is in use.  You might need to kill acpid.)\n");
      }
    }
  }
#line 117
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/kacpimon.c"
static void monitor(void) 
{ 
  fd_set readfds ;
  int nready ;
  int i ;
  fd_set const   *tmp ;
  int tmp___0 ;
  int fd ;
  struct connection___0 *p ;
  int tmp___1 ;

  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (exitflag == 0)) {
#line 125
      goto while_break;
    }
    {
#line 132
    tmp = get_fdset();
#line 132
    readfds = (fd_set )*tmp;
#line 135
    tmp___0 = get_highestfd();
#line 135
    nready = select(tmp___0 + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 138
    if (nready <= 0) {
#line 139
      goto while_break;
    }
#line 142
    i = 0;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 142
      tmp___1 = get_number_of_connections();
      }
#line 142
      if (! (i <= tmp___1)) {
#line 142
        goto while_break___0;
      }
      {
#line 147
      p = get_connection(i);
      }
#line 150
      if (! p) {
#line 151
        goto while_break___0;
      }
#line 154
      fd = p->fd;
#line 157
      if ((readfds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 159
        (*(p->process))(fd);
        }
      }
#line 142
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/kacpimon.c"
static void close_all(void) 
{ 
  int i ;
  struct connection___0 *p ;
  int tmp ;

  {
#line 169
  i = 0;
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 172
    tmp = get_number_of_connections();
    }
#line 172
    if (! (i <= tmp)) {
#line 172
      goto while_break;
    }
    {
#line 176
    p = get_connection(i);
    }
#line 179
    if ((unsigned long )p == (unsigned long )((struct connection___0 *)0)) {
#line 180
      goto __Cont;
    }
    {
#line 182
    close(p->fd);
    }
    __Cont: /* CIL Label */ 
#line 172
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/input_layer.c"
static void process_input___0(int fd ) 
{ 
  struct input_event event ;
  ssize_t nbytes ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 56
  nbytes = read(fd, (void *)(& event), sizeof(event));
  }
#line 58
  if (nbytes == 0L) {
    {
#line 59
    printf((char const   */* __restrict  */)"Input layer connection closed.\n");
    }
#line 60
    return;
  }
#line 63
  if (nbytes < 0L) {
    {
#line 65
    tmp = __errno_location();
    }
#line 65
    if (*tmp == 4) {
#line 66
      return;
    }
    {
#line 68
    tmp___0 = __errno_location();
#line 68
    tmp___1 = __errno_location();
#line 68
    tmp___2 = strerror(*tmp___1);
#line 68
    printf((char const   */* __restrict  */)"Input layer read error: %s (%d)\n", tmp___2,
           *tmp___0);
    }
#line 70
    return;
  }
#line 76
  if ((unsigned long )nbytes != sizeof(event)) {
    {
#line 77
    printf((char const   */* __restrict  */)"Input Layer unexpected Length\n");
#line 78
    printf((char const   */* __restrict  */)"  Expected: %lu   Got: %zd\n", sizeof(event),
           nbytes);
    }
#line 80
    return;
  }
#line 84
  if ((int )event.type == 1) {
#line 84
    if ((int )event.code == 1) {
#line 84
      if (event.value == 1) {
        {
#line 87
        printf((char const   */* __restrict  */)"Escape key pressed\n");
#line 88
        exitflag = 1;
        }
      }
    }
  }
#line 91
  if ((int )event.type == 0) {
    {
#line 92
    printf((char const   */* __restrict  */)"Input Layer:  Sync\n");
    }
  } else {
    {
#line 95
    printf((char const   */* __restrict  */)"Input Layer:  Type: %hu  Code: %hu  Value: %d\n",
           (int )event.type, (int )event.code, event.value);
    }
  }
#line 98
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/netlink.c"
static void format_netlink___0(struct nlmsghdr *msg ) 
{ 
  struct rtattr *tb[2] ;
  struct genlmsghdr *ghdr ;
  int len ;
  struct rtattr *attrs ;
  __u16 tmp ;
  struct acpi_genl_event *event ;

  {
  {
#line 53
  ghdr = (struct genlmsghdr *)((void *)((char *)msg + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 57
  len = (int )msg->nlmsg_len;
#line 60
  tmp = acpi_ids_getfamily();
  }
#line 60
  if ((int )msg->nlmsg_type != (int )tmp) {
    {
#line 61
    printf((char const   */* __restrict  */)"Netlink: Message received with improper family ID.\n");
    }
#line 62
    return;
  }
#line 65
  len = (int )((unsigned long )len - ((((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))));
#line 67
  if (len < 0) {
    {
#line 68
    printf((char const   */* __restrict  */)"Netlink: Wrong controller message len: %d\n",
           len);
    }
#line 69
    return;
  }
  {
#line 72
  attrs = (struct rtattr *)((char *)ghdr + (((sizeof(struct genlmsghdr ) + 4UL) - 1UL) & 4294967292UL));
#line 74
  parse_rtattr(tb, 1, attrs, len);
  }
#line 77
  if (tb[1]) {
    {
#line 79
    event = (struct acpi_genl_event *)((void *)((char *)tb[1] + (((sizeof(struct rtattr ) + 4UL) - 1UL) & 0xfffffffffffffffcUL)));
#line 82
    printf((char const   */* __restrict  */)"netlink: %s %s %08x %08x\n", event->device_class,
           event->bus_id, event->type, event->data);
    }
  }
#line 86
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/netlink.c"
static void process_netlink___0(int fd ) 
{ 
  int status ;
  struct nlmsghdr *h ;
  struct sockaddr_nl nladdr ;
  struct iovec iov ;
  struct msghdr msg ;
  char buf___2[8192] ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int len ;
  int l ;

  {
  {
#line 99
  msg.msg_name = (void *)(& nladdr);
#line 99
  msg.msg_namelen = (socklen_t )sizeof(nladdr);
#line 99
  msg.msg_iov = & iov;
#line 99
  msg.msg_iovlen = (size_t )1;
#line 99
  msg.msg_control = (void *)0;
#line 99
  msg.msg_controllen = 0UL;
#line 99
  msg.msg_flags = 0;
#line 109
  memset((void *)(& nladdr), 0, sizeof(nladdr));
#line 110
  nladdr.nl_family = (__kernel_sa_family_t )16;
#line 111
  nladdr.nl_pid = (__u32 )0;
#line 112
  nladdr.nl_groups = (__u32 )0;
#line 115
  iov.iov_base = (void *)(buf___2);
#line 116
  iov.iov_len = sizeof(buf___2);
#line 119
  tmp = recvmsg(fd, & msg, 0);
#line 119
  status = (int )tmp;
  }
#line 122
  if (status < 0) {
    {
#line 124
    tmp___0 = __errno_location();
    }
#line 124
    if (*tmp___0 == 4) {
#line 125
      return;
    }
    {
#line 126
    tmp___1 = __errno_location();
#line 126
    tmp___2 = __errno_location();
#line 126
    tmp___3 = strerror(*tmp___2);
#line 126
    printf((char const   */* __restrict  */)"Netlink: recvmsg() error: %s (%d)\n",
           tmp___3, *tmp___1);
    }
#line 128
    return;
  }
#line 131
  if (status == 0) {
    {
#line 132
    printf((char const   */* __restrict  */)"Netlink: Connection closed\n");
    }
#line 133
    return;
  }
#line 136
  if ((unsigned long )msg.msg_namelen != sizeof(nladdr)) {
    {
#line 137
    printf((char const   */* __restrict  */)"Netlink: Unexpected address length: %d\n",
           msg.msg_namelen);
    }
#line 138
    return;
  }
#line 142
  h = (struct nlmsghdr *)(buf___2);
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! ((unsigned long )((unsigned int )status) >= sizeof(*h))) {
#line 142
      goto while_break;
    }
#line 143
    len = (int )h->nlmsg_len;
#line 144
    l = (int )((unsigned long )len - sizeof(*h));
#line 146
    if (l < 0) {
#line 146
      goto _L;
    } else
#line 146
    if (len > status) {
      _L: /* CIL Label */ 
#line 147
      if (msg.msg_flags & 32) {
        {
#line 148
        printf((char const   */* __restrict  */)"Netlink: Message truncated (1)\n");
        }
#line 149
        return;
      }
      {
#line 151
      printf((char const   */* __restrict  */)"Netlink: Malformed message.  Length: %d\n",
             len);
      }
#line 152
      return;
    }
    {
#line 156
    format_netlink___0(h);
#line 158
    status = (int )((unsigned int )status - ((((unsigned int )len + 4U) - 1U) & 4294967292U));
#line 159
    h = (struct nlmsghdr *)((char *)h + ((((unsigned int )len + 4U) - 1U) & 4294967292U));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (msg.msg_flags & 32) {
    {
#line 162
    printf((char const   */* __restrict  */)"Netlink: Message truncated (2)\n");
    }
#line 163
    return;
  }
#line 165
  if (status) {
    {
#line 166
    printf((char const   */* __restrict  */)"Netlink: Remnant of size %d\n", status);
    }
#line 167
    return;
  }
#line 170
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/acpid-2.0.21/kacpimon/netlink.c"
static __u32 nl_mgrp___0(__u32 group ) 
{ 
  int tmp ;

  {
#line 178
  if (group > 31U) {
    {
#line 179
    printf((char const   */* __restrict  */)"Netlink: Use setsockopt for this group: %d\n",
           group);
    }
#line 180
    return ((__u32 )0);
  }
#line 182
  if (group) {
#line 182
    tmp = 1 << (group - 1U);
  } else {
#line 182
    tmp = 0;
  }
#line 182
  return ((__u32 )tmp);
}
}
