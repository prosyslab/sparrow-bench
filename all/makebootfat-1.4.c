/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 29 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.h"
struct disk_geometry {
   unsigned int sectors ;
   unsigned int heads ;
   unsigned int cylinders ;
   unsigned int size ;
   unsigned int start ;
   unsigned char drive ;
};
#line 38 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.h"
struct disk_cache {
   unsigned char *data ;
   unsigned int pos ;
   unsigned int size ;
   struct disk_cache *next ;
};
#line 45 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.h"
struct disk_handle {
   int handle ;
   struct disk_geometry geometry ;
   char device[512] ;
   void *ope_context ;
   void (*ope_callback)(void *context , int operation , unsigned int pos , unsigned int size ) ;
   struct disk_cache *cache_list ;
   unsigned int cache_begin ;
   unsigned int cache_end ;
};
#line 35 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_info {
   unsigned int fat_bit ;
   unsigned int fat_num ;
   unsigned int fat_pos ;
   unsigned int fat_size ;
   unsigned int data_pos ;
   unsigned int data_size ;
   unsigned int cluster_num ;
   unsigned int cluster_size ;
   unsigned int root_pos ;
   unsigned int root_size ;
};
#line 51 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_context {
   struct disk_handle *h ;
   unsigned int h_pos ;
   unsigned int h_size ;
   unsigned char *table ;
   unsigned char tmp[65536] ;
   struct fat_info info ;
   struct disk_geometry geometry ;
   unsigned int first_free ;
};
#line 67 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct __anonstruct_fat16_48 {
   unsigned char BS_DrvNum ;
   unsigned char BS_Reserved1 ;
   unsigned char BS_BootSig ;
   unsigned char BS_VolID[4] ;
   char BS_VolLab[11] ;
   char BS_FilSysType[8] ;
   unsigned char BS_Code[448] ;
};
#line 67 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct __anonstruct_fat32_49 {
   unsigned char BPB_FATSz32[4] ;
   unsigned char BPB_ExtFlags[2] ;
   unsigned char BPB_FSVer[2] ;
   unsigned char BPB_RootClus[4] ;
   unsigned char BPB_FSInfo[2] ;
   unsigned char BPB_BkBootSec[2] ;
   unsigned char BPB_Reserved[12] ;
   unsigned char BS_DrvNum ;
   unsigned char BS_Reserved1 ;
   unsigned char BS_BootSig ;
   unsigned char BS_VolID[4] ;
   char BS_VolLab[11] ;
   char BS_FilSysType[8] ;
   unsigned char BS_Code[420] ;
};
#line 67 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
union __anonunion_bit_47 {
   struct __anonstruct_fat16_48 fat16 ;
   struct __anonstruct_fat32_49 fat32 ;
};
#line 67 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_boot_sector {
   unsigned char BS_JumpBoot[3] ;
   char BS_OemName[8] ;
   unsigned char BPB_BytesPerSec[2] ;
   unsigned char BPB_SecPerClus ;
   unsigned char BPB_RsvdSecCnt[2] ;
   unsigned char BPB_NumFATs ;
   unsigned char BPB_RootEntCnt[2] ;
   unsigned char BPB_TotSec16[2] ;
   unsigned char BPB_Media ;
   unsigned char BPB_FATSz16[2] ;
   unsigned char BPB_SecPerTrk[2] ;
   unsigned char BPB_NumHeads[2] ;
   unsigned char BPB_HiddSec[4] ;
   unsigned char BPB_TotSec32[4] ;
   union __anonunion_bit_47 bit ;
   unsigned char BS_Sign[2] ;
};
#line 112 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_fsinfo {
   unsigned char FSI_LeadSig[4] ;
   unsigned char FSI_Reserved1[480] ;
   unsigned char FSI_StrucSig[4] ;
   unsigned char FSI_Free_Count[4] ;
   unsigned char FSI_Nxt_Free[4] ;
   unsigned char FSI_Reserved2[12] ;
   unsigned char FSI_TrailSig[4] ;
};
#line 135 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_direntry {
   char DE_Name[11] ;
   unsigned char DE_Attributes ;
   unsigned char DE_Reserved ;
   unsigned char DE_CrtTimeTenth ;
   unsigned char DE_CrtTime[2] ;
   unsigned char DE_CrtDate[2] ;
   unsigned char DE_LstAccDate[2] ;
   unsigned char DE_ClusterH[2] ;
   unsigned char DE_WrtTime[2] ;
   unsigned char DE_WrtDate[2] ;
   unsigned char DE_ClusterL[2] ;
   unsigned char DE_FileSize[4] ;
};
#line 153 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_longentry {
   unsigned char DE_Ordinal ;
   unsigned char DE_Name0[2] ;
   unsigned char DE_Name1[2] ;
   unsigned char DE_Name2[2] ;
   unsigned char DE_Name3[2] ;
   unsigned char DE_Name4[2] ;
   unsigned char DE_Attributes ;
   unsigned char DE_Reserved ;
   unsigned char DE_CheckSum ;
   unsigned char DE_Name5[2] ;
   unsigned char DE_Name6[2] ;
   unsigned char DE_Name7[2] ;
   unsigned char DE_Name8[2] ;
   unsigned char DE_Name9[2] ;
   unsigned char DE_Name10[2] ;
   unsigned char DE_ClusterL[2] ;
   unsigned char DE_Name11[2] ;
   unsigned char DE_Name12[2] ;
};
#line 29 "/home/wheatley/newnew/temp/makebootfat-1.4/part.h"
struct partition_entry {
   unsigned char status ;
   unsigned char start_head ;
   unsigned char start_seccyl[2] ;
   unsigned char type ;
   unsigned char end_head ;
   unsigned char end_seccyl[2] ;
   unsigned char start[4] ;
   unsigned char size[4] ;
};
#line 43 "/home/wheatley/newnew/temp/makebootfat-1.4/part.h"
struct partition_table {
   unsigned char bootcode[446] ;
   struct partition_entry entries[4] ;
   unsigned char id[2] ;
};
#line 205 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
struct fat_format {
   unsigned char bootraw[16384] ;
   unsigned int bootraw_pos ;
   unsigned int bootraw_size ;
   unsigned char fatraw[512] ;
   unsigned int fatraw_pos ;
   unsigned int fatraw_size ;
   unsigned char rootraw[65536] ;
   unsigned int rootraw_pos ;
   unsigned int rootraw_size ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 200 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
struct string_list {
   char *path ;
   struct string_list *next ;
};
#line 438 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
struct verbose_context_struct {
   unsigned int total ;
   unsigned int counter ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 313 "/usr/include/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 13 "/usr/include/linux/fd.h"
struct floppy_struct {
   unsigned int size ;
   unsigned int sect ;
   unsigned int head ;
   unsigned int track ;
   unsigned int stretch ;
   unsigned char gap ;
   unsigned char rate ;
   unsigned char spec1 ;
   unsigned char fmt_gap ;
   char const   *name ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 61 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.h"
unsigned int le_uint16_read(void const   *ptr ) ;
#line 62
unsigned int le_uint32_read(void const   *ptr ) ;
#line 63
void le_uint16_write(void *ptr , unsigned int v ) ;
#line 64
void le_uint32_write(void *ptr , unsigned int v ) ;
#line 69
int disk_read(struct disk_handle *h , unsigned int pos , void *data , unsigned int size ) ;
#line 70
int disk_write(struct disk_handle *h , unsigned int pos , void const   *data , unsigned int size ) ;
#line 174 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.h"
struct fat_context *fat_open(struct disk_handle *h , unsigned int pos , unsigned int size ,
                             struct disk_geometry  const  *geometry ) ;
#line 175
int fat_close(struct fat_context *fat ) ;
#line 176
int fat_format(struct fat_context *fat , unsigned int size , unsigned int bit , unsigned int sector_per_cluster ,
               char const   *oem , char const   *label , unsigned int serial , struct disk_geometry  const  *geometry ) ;
#line 177
int fat_entry_add(struct fat_context *fat , unsigned int dir_cluster , char const   *file_name ,
                  unsigned int file_cluster , unsigned int file_size , unsigned int file_attrib ,
                  time_t file_time ) ;
#line 178
int fat_cluster_dir(struct fat_context *fat , unsigned int root_cluster , unsigned int *cluster ,
                    time_t time___0 ) ;
#line 179
int fat_cluster_file(struct fat_context *fat , char const   *file , unsigned int *cluster ,
                     unsigned int *size ) ;
#line 180
int fat_cluster_chain(struct fat_context *fat , unsigned int cluster , unsigned int *cluster_map ,
                      unsigned int cluster_max ) ;
#line 181
int fat_sector_chain(struct fat_context *fat , unsigned int cluster , unsigned int *sector_map ,
                     unsigned int sector_max ) ;
#line 182
int fat_boot_setup(unsigned char *boot , unsigned char const   *code , unsigned int bit ) ;
#line 25 "/home/wheatley/newnew/temp/makebootfat-1.4/error.h"
void error_set(char const   *text  , ...) ;
#line 27 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static void fat_table_set(struct fat_context *fat , unsigned int cluster , unsigned int val ) 
{ 
  unsigned char *off ;
  unsigned int tmp ;
  unsigned char *off___0 ;
  unsigned char *off___1 ;

  {
#line 29
  if (cluster != 0U) {
#line 29
    if (cluster != 1U) {
#line 29
      if (! (cluster < fat->info.cluster_num + 2U)) {
        {
#line 29
        __assert_fail("cluster != 0 && cluster != 1 && cluster < fat->info.cluster_num + 2",
                      "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 29U, "fat_table_set");
        }
      }
    } else {
      {
#line 29
      __assert_fail("cluster != 0 && cluster != 1 && cluster < fat->info.cluster_num + 2",
                    "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 29U, "fat_table_set");
      }
    }
  } else {
    {
#line 29
    __assert_fail("cluster != 0 && cluster != 1 && cluster < fat->info.cluster_num + 2",
                  "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 29U, "fat_table_set");
    }
  }
#line 31
  if (fat->info.fat_bit == 32U) {
    {
#line 32
    off = fat->table + cluster * 4U;
#line 33
    tmp = le_uint32_read((void const   *)off);
#line 33
    le_uint32_write((void *)off, (tmp & 4026531840U) | (val & 268435455U));
    }
  } else
#line 34
  if (fat->info.fat_bit == 16U) {
    {
#line 35
    off___0 = fat->table + cluster * 2U;
#line 36
    le_uint16_write((void *)off___0, val & 65535U);
    }
  } else
#line 37
  if (fat->info.fat_bit == 12U) {
#line 38
    off___1 = (fat->table + cluster) + cluster / 2U;
#line 39
    if ((cluster & 1U) == 0U) {
#line 40
      *(off___1 + 0) = (unsigned char )(val & 255U);
#line 41
      *(off___1 + 1) = (unsigned char )((unsigned int )((int )*(off___1 + 1) & 240) | ((val >> 8) & 15U));
    } else {
#line 43
      *(off___1 + 0) = (unsigned char )((unsigned int )((int )*(off___1 + 0) & 15) | ((val << 4) & 240U));
#line 44
      *(off___1 + 1) = (unsigned char )((val >> 4) & 255U);
    }
  }
#line 47
  return;
}
}
#line 49 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static unsigned int fat_table_get(struct fat_context *fat , unsigned int cluster ) 
{ 
  unsigned int r ;
  unsigned char *off ;
  unsigned int tmp ;
  unsigned char *off___0 ;
  unsigned char *off___1 ;

  {
#line 53
  if (cluster != 0U) {
#line 53
    if (cluster != 1U) {
#line 53
      if (! (cluster < fat->info.cluster_num + 2U)) {
        {
#line 53
        __assert_fail("cluster != 0 && cluster != 1 && cluster < fat->info.cluster_num + 2",
                      "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 53U, "fat_table_get");
        }
      }
    } else {
      {
#line 53
      __assert_fail("cluster != 0 && cluster != 1 && cluster < fat->info.cluster_num + 2",
                    "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 53U, "fat_table_get");
      }
    }
  } else {
    {
#line 53
    __assert_fail("cluster != 0 && cluster != 1 && cluster < fat->info.cluster_num + 2",
                  "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 53U, "fat_table_get");
    }
  }
#line 55
  if (fat->info.fat_bit == 32U) {
    {
#line 56
    off = fat->table + cluster * 4U;
#line 57
    tmp = le_uint32_read((void const   *)off);
#line 57
    r = tmp & 268435455U;
    }
#line 58
    if (r >= 268435448U) {
#line 59
      r = 4294967295U;
    }
#line 60
    if (r == 268435447U) {
#line 61
      r = 4294967287U;
    }
  } else
#line 62
  if (fat->info.fat_bit == 16U) {
    {
#line 63
    off___0 = fat->table + cluster * 2U;
#line 64
    r = le_uint16_read((void const   *)off___0);
    }
#line 65
    if (r >= 65528U) {
#line 66
      r = 4294967295U;
    }
#line 67
    if (r == 65527U) {
#line 68
      r = 4294967287U;
    }
  } else
#line 69
  if (fat->info.fat_bit == 12U) {
#line 70
    off___1 = (fat->table + cluster) + cluster / 2U;
#line 71
    if ((cluster & 1U) == 0U) {
#line 72
      r = (unsigned int )((int )*(off___1 + 0) | (((int )*(off___1 + 1) & 15) << 8));
    } else {
#line 74
      r = (unsigned int )(((int )*(off___1 + 0) >> 4) | ((int )*(off___1 + 1) << 4));
    }
#line 76
    if (r >= 4088U) {
#line 77
      r = 4294967295U;
    }
#line 78
    if (r == 4087U) {
#line 79
      r = 4294967287U;
    }
  } else {
    {
#line 81
    __assert_fail("0", "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c", 81U, "fat_table_get");
    }
  }
#line 84
  return (r);
}
}
#line 87 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
struct fat_context *fat_open(struct disk_handle *h , unsigned int pos , unsigned int size ,
                             struct disk_geometry  const  *geometry ) 
{ 
  struct fat_context *fat ;
  void *tmp ;

  {
#line 92
  if (sizeof(struct fat_direntry ) != 32UL) {
    {
#line 93
    error_set("Invalid structure size.");
    }
#line 94
    return ((struct fat_context *)0);
  }
#line 97
  if (sizeof(struct fat_longentry ) != 32UL) {
    {
#line 98
    error_set("Invalid structure size.");
    }
#line 99
    return ((struct fat_context *)0);
  }
#line 102
  if (sizeof(struct fat_boot_sector ) != 512UL) {
    {
#line 103
    error_set("Invalid structure size.");
    }
#line 104
    return ((struct fat_context *)0);
  }
#line 107
  if (sizeof(struct fat_fsinfo ) != 512UL) {
    {
#line 108
    error_set("Invalid structure size.");
    }
#line 109
    return ((struct fat_context *)0);
  }
#line 112
  if (sizeof(struct partition_table ) != 512UL) {
    {
#line 113
    error_set("Invalid structure size.");
    }
#line 114
    return ((struct fat_context *)0);
  }
  {
#line 117
  tmp = malloc(sizeof(struct fat_context ));
#line 117
  fat = (struct fat_context *)tmp;
  }
#line 118
  if (! fat) {
    {
#line 119
    error_set("Low memory.");
    }
#line 120
    return ((struct fat_context *)0);
  }
  {
#line 123
  fat->h = h;
#line 124
  fat->h_pos = pos;
#line 125
  fat->h_size = size;
#line 127
  fat->table = (unsigned char *)0;
#line 129
  memset((void *)(& fat->info), 0, sizeof(fat->info));
#line 131
  fat->geometry = (struct disk_geometry )*geometry;
#line 133
  fat->first_free = 2U;
  }
#line 135
  return (fat);
}
}
#line 138 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_close(struct fat_context *fat ) 
{ 
  struct fat_boot_sector boot ;
  int tmp ;
  unsigned int i ;
  int tmp___0 ;
  struct fat_fsinfo fsinfo ;
  unsigned int freecount ;
  unsigned int firstfree ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
#line 143
  tmp = disk_read(fat->h, fat->h_pos, (void *)(& boot), 1U);
  }
#line 143
  if (tmp != 0) {
#line 144
    return (-1);
  }
#line 147
  if (fat->table) {
#line 150
    i = 0U;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 150
      if (! (i < fat->info.fat_num)) {
#line 150
        goto while_break;
      }
      {
#line 151
      tmp___0 = disk_write(fat->h, (fat->h_pos + fat->info.fat_pos) + i * fat->info.fat_size,
                           (void const   *)fat->table, fat->info.fat_size);
      }
#line 151
      if (tmp___0 != 0) {
#line 152
        return (-1);
      }
#line 150
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 155
    if (fat->info.fat_bit == 32U) {
      {
#line 155
      tmp___6 = le_uint16_read((void const   *)(boot.bit.fat32.BPB_FSInfo));
      }
#line 155
      if (tmp___6 != 0U) {
#line 161
        freecount = 4294967295U;
#line 162
        firstfree = 4294967295U;
#line 163
        i = 2U;
        {
#line 163
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 163
          if (! (i < fat->info.cluster_num + 2U)) {
#line 163
            goto while_break___0;
          }
          {
#line 164
          tmp___1 = fat_table_get(fat, i);
          }
#line 164
          if (tmp___1 == 0U) {
#line 165
            if (freecount == 4294967295U) {
#line 166
              freecount = 1U;
            } else {
#line 168
              freecount ++;
            }
#line 169
            if (firstfree == 4294967295U) {
#line 170
              firstfree = i;
            }
          }
#line 163
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 174
        tmp___2 = le_uint16_read((void const   *)(boot.bit.fat32.BPB_FSInfo));
#line 174
        tmp___3 = disk_read(fat->h, fat->h_pos + tmp___2, (void *)(& fsinfo), 1U);
        }
#line 174
        if (tmp___3 != 0) {
#line 175
          return (-1);
        }
        {
#line 177
        le_uint32_write((void *)(fsinfo.FSI_Free_Count), freecount);
#line 178
        le_uint32_write((void *)(fsinfo.FSI_Nxt_Free), firstfree);
#line 181
        tmp___4 = le_uint16_read((void const   *)(boot.bit.fat32.BPB_FSInfo));
#line 181
        tmp___5 = disk_write(fat->h, fat->h_pos + tmp___4, (void const   *)(& fsinfo),
                             1U);
        }
#line 181
        if (tmp___5 != 0) {
#line 182
          return (-1);
        }
      }
    }
    {
#line 185
    free((void *)fat->table);
    }
  }
#line 188
  if (fat->info.fat_bit == 32U) {
    {
#line 188
    tmp___9 = le_uint16_read((void const   *)(boot.bit.fat32.BPB_BkBootSec));
    }
#line 188
    if (tmp___9 != 0U) {
      {
#line 191
      tmp___7 = le_uint16_read((void const   *)(boot.bit.fat32.BPB_BkBootSec));
#line 191
      tmp___8 = disk_write(fat->h, fat->h_pos + tmp___7, (void const   *)(& boot),
                           1U);
      }
#line 191
      if (tmp___8 != 0) {
#line 192
        return (-1);
      }
    }
  }
  {
#line 195
  free((void *)fat);
  }
#line 197
  return (0);
}
}
#line 227 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_format_check(unsigned int bit , unsigned int data_sec , unsigned int fat_sec ,
                            unsigned int sector_per_cluster ) 
{ 
  unsigned int tst_fat_ent ;
  unsigned int tst_fat_sec ;
  unsigned int tst_fat_ent___0 ;
  unsigned int tst_fat_sec___0 ;
  unsigned int tst_fat_ent___1 ;
  unsigned int tst_fat_sec___1 ;

  {
#line 230
  if (bit == 12U) {
#line 231
    tst_fat_ent = data_sec / sector_per_cluster + 2U;
#line 232
    tst_fat_sec = ((tst_fat_ent * 3U + 1024U) - 1U) / 1024U;
#line 233
    if (fat_sec < tst_fat_sec) {
#line 234
      return (-1);
    }
  } else
#line 235
  if (bit == 16U) {
#line 236
    tst_fat_ent___0 = data_sec / sector_per_cluster + 2U;
#line 237
    tst_fat_sec___0 = ((tst_fat_ent___0 * 2U + 512U) - 1U) / 512U;
#line 238
    if (fat_sec < tst_fat_sec___0) {
#line 239
      return (-1);
    }
  } else {
#line 241
    tst_fat_ent___1 = data_sec / sector_per_cluster + 2U;
#line 242
    tst_fat_sec___1 = ((tst_fat_ent___1 * 4U + 512U) - 1U) / 512U;
#line 243
    if (fat_sec < tst_fat_sec___1) {
#line 244
      return (-1);
    }
  }
#line 247
  return (0);
}
}
#line 250 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static void strfcpy(char *dst , char const   *s , char fill , unsigned int l ) 
{ 
  unsigned int i ;

  {
#line 254
  i = 0U;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (i < l) {
#line 254
      if (! *(s + i)) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
#line 255
    *(dst + i) = (char )*(s + i);
#line 254
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 257
    if (! (i < l)) {
#line 257
      goto while_break___0;
    }
#line 258
    *(dst + i) = fill;
#line 257
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  return;
}
}
#line 274 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_format_compute(struct fat_format *format , struct fat_info *info ,
                              unsigned int size_in_sector , unsigned int bit , unsigned int sector_per_cluster ,
                              char const   *oem , char const   *label , unsigned int serial ,
                              struct disk_geometry  const  *geometry , unsigned int hidden ) 
{ 
  struct fat_boot_sector *boot ;
  unsigned int root_sec ;
  unsigned int tot_sec ;
  unsigned int fat_ent ;
  unsigned int data_sec ;
  unsigned int fat_sec ;
  unsigned int data_clus ;
  unsigned char *fat ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tst_fat_ent ;
  unsigned int tst_fat_sec ;
  unsigned int tst_fat_ent___0 ;
  unsigned int tst_fat_sec___0 ;
  unsigned int tst_fat_ent___1 ;
  unsigned int tst_fat_sec___1 ;
  unsigned int tmp___5 ;
  struct fat_fsinfo *fsinfo ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  struct fat_direntry *root ;
  unsigned int tmp___8 ;
  struct fat_direntry *dir ;
  unsigned int dir_sec ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;

  {
#line 281
  if (sector_per_cluster * 512U > 32768U) {
#line 282
    return (-1);
  }
  {
#line 285
  boot = (struct fat_boot_sector *)(format->bootraw);
#line 287
  memset((void *)boot, 0, (size_t )512);
#line 290
  boot->BS_JumpBoot[0] = (unsigned char)235;
#line 291
  boot->BS_JumpBoot[1] = (unsigned char)88;
#line 292
  boot->BS_JumpBoot[2] = (unsigned char)144;
#line 294
  strfcpy(boot->BS_OemName, oem, (char )' ', 8U);
#line 296
  le_uint16_write((void *)(& boot->BPB_BytesPerSec), 512U);
#line 297
  boot->BPB_SecPerClus = (unsigned char )sector_per_cluster;
  }
#line 298
  if (bit == 32U) {
    {
#line 299
    le_uint16_write((void *)(& boot->BPB_RsvdSecCnt), 32U);
    }
  } else {
    {
#line 301
    le_uint16_write((void *)(& boot->BPB_RsvdSecCnt), 1U);
    }
  }
#line 302
  boot->BPB_NumFATs = (unsigned char)1;
#line 303
  if (bit == 32U) {
    {
#line 304
    le_uint16_write((void *)(& boot->BPB_RootEntCnt), 0U);
    }
  } else {
    {
#line 306
    le_uint16_write((void *)(& boot->BPB_RootEntCnt), 512U);
    }
  }
#line 308
  if (bit == 32U) {
    {
#line 309
    le_uint16_write((void *)(& boot->BPB_TotSec16), 0U);
#line 310
    le_uint32_write((void *)(& boot->BPB_TotSec32), size_in_sector);
    }
  } else
#line 308
  if (size_in_sector >= 65536U) {
    {
#line 309
    le_uint16_write((void *)(& boot->BPB_TotSec16), 0U);
#line 310
    le_uint32_write((void *)(& boot->BPB_TotSec32), size_in_sector);
    }
  } else {
    {
#line 312
    le_uint16_write((void *)(& boot->BPB_TotSec16), size_in_sector);
#line 313
    le_uint32_write((void *)(& boot->BPB_TotSec32), 0U);
    }
  }
  {
#line 315
  boot->BPB_Media = (unsigned char)248;
#line 317
  tmp = le_uint16_read((void const   *)(& boot->BPB_RootEntCnt));
#line 317
  root_sec = tmp / 16U;
#line 318
  tmp___0 = le_uint16_read((void const   *)(& boot->BPB_TotSec16));
  }
#line 318
  if (tmp___0) {
    {
#line 319
    tot_sec = le_uint16_read((void const   *)(& boot->BPB_TotSec16));
    }
  } else {
    {
#line 321
    tot_sec = le_uint32_read((void const   *)(& boot->BPB_TotSec32));
    }
  }
  {
#line 324
  tmp___1 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 324
  data_sec = (tot_sec - tmp___1) - root_sec;
#line 325
  fat_ent = data_sec / (unsigned int )boot->BPB_SecPerClus + 2U;
  }
#line 327
  if (bit == 12U) {
#line 328
    fat_sec = ((fat_ent * 3U + 1024U) - 1U) / 1024U;
  } else
#line 329
  if (bit == 16U) {
#line 330
    fat_sec = ((fat_ent * 2U + 512U) - 1U) / 512U;
  } else {
#line 332
    fat_sec = ((fat_ent * 4U + 512U) - 1U) / 512U;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (fat_sec > 0U) {
      {
#line 336
      tmp___2 = fat_format_check(bit, data_sec - (fat_sec - 1U) * (unsigned int )boot->BPB_NumFATs,
                                 fat_sec - 1U, (unsigned int )boot->BPB_SecPerClus);
      }
#line 336
      if (! (tmp___2 == 0)) {
#line 336
        goto while_break;
      }
    } else {
#line 336
      goto while_break;
    }
#line 337
    fat_sec --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 340
  tmp___3 = fat_format_check(bit, data_sec - fat_sec * (unsigned int )boot->BPB_NumFATs,
                             fat_sec, (unsigned int )boot->BPB_SecPerClus);
  }
#line 340
  if (tmp___3 != 0) {
#line 341
    return (-1);
  }
#line 344
  if (bit != 32U) {
    {
#line 345
    le_uint16_write((void *)(& boot->BPB_FATSz16), fat_sec);
    }
  } else {
    {
#line 347
    le_uint16_write((void *)(& boot->BPB_FATSz16), 0U);
#line 348
    le_uint32_write((void *)(& boot->bit.fat32.BPB_FATSz32), fat_sec);
    }
  }
  {
#line 352
  tmp___4 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 352
  data_sec = ((tot_sec - tmp___4) - fat_sec * (unsigned int )boot->BPB_NumFATs) - root_sec;
#line 355
  data_clus = data_sec / (unsigned int )boot->BPB_SecPerClus;
  }
#line 356
  if (data_clus < 4085U) {
#line 357
    if (bit != 12U) {
#line 358
      return (-1);
    }
  } else
#line 359
  if (data_clus < 65525U) {
#line 360
    if (bit != 16U) {
#line 361
      return (-1);
    }
  } else
#line 363
  if (bit != 32U) {
#line 364
    return (-1);
  }
#line 368
  if (bit == 12U) {
#line 369
    tst_fat_ent = data_sec / (unsigned int )boot->BPB_SecPerClus + 2U;
#line 370
    tst_fat_sec = ((tst_fat_ent * 3U + 1024U) - 1U) / 1024U;
#line 371
    if (fat_sec < tst_fat_sec) {
#line 372
      return (-1);
    }
  } else
#line 373
  if (bit == 16U) {
#line 374
    tst_fat_ent___0 = data_sec / (unsigned int )boot->BPB_SecPerClus + 2U;
#line 375
    tst_fat_sec___0 = ((tst_fat_ent___0 * 2U + 512U) - 1U) / 512U;
#line 376
    if (fat_sec < tst_fat_sec___0) {
#line 377
      return (-1);
    }
  } else {
#line 379
    tst_fat_ent___1 = data_sec / (unsigned int )boot->BPB_SecPerClus + 2U;
#line 380
    tst_fat_sec___1 = ((tst_fat_ent___1 * 4U + 512U) - 1U) / 512U;
#line 381
    if (fat_sec < tst_fat_sec___1) {
#line 382
      return (-1);
    }
  }
  {
#line 385
  le_uint16_write((void *)(& boot->BPB_SecPerTrk), (unsigned int )geometry->sectors);
#line 386
  le_uint16_write((void *)(& boot->BPB_NumHeads), (unsigned int )geometry->heads);
#line 387
  le_uint32_write((void *)(& boot->BPB_HiddSec), hidden);
  }
#line 389
  if (bit != 32U) {
    {
#line 390
    boot->bit.fat16.BS_DrvNum = (unsigned char )geometry->drive;
#line 391
    boot->bit.fat16.BS_Reserved1 = (unsigned char)0;
#line 392
    boot->bit.fat16.BS_BootSig = (unsigned char)41;
#line 393
    le_uint32_write((void *)(& boot->bit.fat16.BS_VolID), serial);
#line 394
    memset((void *)(boot->bit.fat16.BS_VolLab), ' ', (size_t )11);
    }
#line 395
    if (label) {
      {
#line 396
      strfcpy(boot->bit.fat16.BS_VolLab, label, (char )' ', 11U);
      }
    }
#line 397
    if (bit == 16U) {
      {
#line 398
      strfcpy(boot->bit.fat16.BS_FilSysType, "FAT16", (char )' ', 8U);
      }
    } else {
      {
#line 400
      strfcpy(boot->bit.fat16.BS_FilSysType, "FAT12", (char )' ', 8U);
      }
    }
  } else {
    {
#line 402
    le_uint16_write((void *)(& boot->bit.fat32.BPB_ExtFlags), 0U);
#line 403
    le_uint16_write((void *)(& boot->bit.fat32.BPB_FSVer), 0U);
#line 404
    le_uint32_write((void *)(& boot->bit.fat32.BPB_RootClus), 2U);
#line 405
    le_uint16_write((void *)(& boot->bit.fat32.BPB_FSInfo), 1U);
#line 406
    le_uint16_write((void *)(& boot->bit.fat32.BPB_BkBootSec), 6U);
#line 407
    memset((void *)(boot->bit.fat32.BPB_Reserved), 0, (size_t )12);
#line 408
    boot->bit.fat32.BS_DrvNum = (unsigned char )geometry->drive;
#line 409
    boot->bit.fat32.BS_Reserved1 = (unsigned char)0;
#line 410
    boot->bit.fat32.BS_BootSig = (unsigned char)41;
#line 411
    le_uint32_write((void *)(& boot->bit.fat32.BS_VolID), serial);
#line 412
    memset((void *)(boot->bit.fat32.BS_VolLab), ' ', (size_t )11);
    }
#line 413
    if (label) {
      {
#line 414
      strfcpy(boot->bit.fat32.BS_VolLab, label, (char )' ', 11U);
      }
    }
    {
#line 415
    strfcpy(boot->bit.fat32.BS_FilSysType, "FAT32", (char )' ', 8U);
    }
  }
  {
#line 418
  format->bootraw[510] = (unsigned char)85;
#line 419
  format->bootraw[511] = (unsigned char)170;
#line 422
  tmp___5 = le_uint16_read((void const   *)(boot->BPB_RsvdSecCnt));
#line 422
  memset((void *)(format->bootraw + 512), 0, (size_t )((tmp___5 - 1U) * 512U));
  }
#line 424
  if (bit == 32U) {
    {
#line 426
    tmp___6 = le_uint16_read((void const   *)(& boot->bit.fat32.BPB_FSInfo));
#line 426
    fsinfo = (struct fat_fsinfo *)(format->bootraw + tmp___6 * 512U);
#line 428
    memset((void *)fsinfo, 0, (size_t )512);
#line 430
    le_uint32_write((void *)(& fsinfo->FSI_LeadSig), 1096897106U);
#line 431
    memset((void *)(fsinfo->FSI_Reserved1), 0, (size_t )480);
#line 432
    le_uint32_write((void *)(& fsinfo->FSI_StrucSig), 1631679090U);
#line 433
    le_uint32_write((void *)(& fsinfo->FSI_Free_Count), 4294967295U);
#line 434
    le_uint32_write((void *)(& fsinfo->FSI_Nxt_Free), 4294967295U);
#line 435
    memset((void *)(fsinfo->FSI_Reserved2), 0, (size_t )12);
#line 436
    le_uint32_write((void *)(& fsinfo->FSI_TrailSig), 2857697280U);
#line 439
    tmp___7 = le_uint16_read((void const   *)(& boot->bit.fat32.BPB_BkBootSec));
#line 439
    memcpy((void */* __restrict  */)(format->bootraw + 512U * tmp___7), (void const   */* __restrict  */)(format->bootraw),
           (size_t )1024);
    }
  }
  {
#line 442
  format->bootraw_pos = 0U;
#line 443
  format->bootraw_size = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 446
  fat = format->fatraw;
#line 448
  format->fatraw_pos = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 449
  format->fatraw_size = 1U;
#line 451
  memset((void *)fat, 0, (size_t )512);
  }
#line 453
  if (bit == 12U) {
#line 454
    *(fat + 0) = boot->BPB_Media;
#line 455
    *(fat + 1) = (unsigned char)255;
#line 456
    *(fat + 2) = (unsigned char)255;
  } else
#line 457
  if (bit == 16U) {
#line 458
    *(fat + 0) = boot->BPB_Media;
#line 459
    *(fat + 1) = (unsigned char)255;
#line 460
    *(fat + 2) = (unsigned char)255;
#line 461
    *(fat + 3) = (unsigned char)255;
  } else {
#line 463
    *(fat + 0) = boot->BPB_Media;
#line 464
    *(fat + 1) = (unsigned char)255;
#line 465
    *(fat + 2) = (unsigned char)255;
#line 466
    *(fat + 3) = (unsigned char)255;
#line 467
    *(fat + 4) = (unsigned char)255;
#line 468
    *(fat + 5) = (unsigned char)255;
#line 469
    *(fat + 6) = (unsigned char)255;
#line 470
    *(fat + 7) = (unsigned char)255;
  }
#line 473
  if (bit != 32U) {
    {
#line 475
    root = (struct fat_direntry *)(format->rootraw);
#line 477
    tmp___8 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 477
    format->rootraw_pos = tmp___8 + fat_sec * (unsigned int )boot->BPB_NumFATs;
#line 478
    format->rootraw_size = root_sec;
#line 480
    memset((void *)root, 0, (size_t )(root_sec * 512U));
    }
#line 482
    if (label) {
      {
#line 483
      strfcpy(root->DE_Name, label, (char )' ', 11U);
#line 484
      root->DE_Attributes = (unsigned char)8;
      }
    }
  } else {
    {
#line 488
    dir = (struct fat_direntry *)(format->rootraw);
#line 489
    dir_sec = (unsigned int )boot->BPB_SecPerClus;
#line 491
    tmp___9 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 491
    format->rootraw_pos = tmp___9 + fat_sec * (unsigned int )boot->BPB_NumFATs;
#line 492
    format->rootraw_size = dir_sec;
#line 494
    memset((void *)dir, 0, (size_t )(dir_sec * 512U));
    }
#line 496
    if (label) {
      {
#line 497
      strfcpy(dir->DE_Name, label, (char )' ', 11U);
#line 498
      dir->DE_Attributes = (unsigned char)8;
      }
    }
#line 501
    *(fat + 8) = (unsigned char)255;
#line 502
    *(fat + 9) = (unsigned char)255;
#line 503
    *(fat + 10) = (unsigned char)255;
#line 504
    *(fat + 11) = (unsigned char)255;
  }
#line 507
  if (info) {
    {
#line 508
    info->fat_bit = bit;
#line 509
    info->fat_num = (unsigned int )boot->BPB_NumFATs;
#line 510
    info->fat_pos = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 511
    info->fat_size = fat_sec;
    }
#line 512
    if (bit != 32U) {
      {
#line 513
      tmp___10 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 513
      info->data_pos = (tmp___10 + fat_sec * (unsigned int )boot->BPB_NumFATs) + root_sec;
      }
    } else {
      {
#line 515
      tmp___11 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 515
      info->data_pos = tmp___11 + fat_sec * (unsigned int )boot->BPB_NumFATs;
      }
    }
    {
#line 516
    info->data_size = data_sec;
#line 517
    info->cluster_num = data_clus;
#line 518
    info->cluster_size = sector_per_cluster;
#line 519
    tmp___12 = le_uint16_read((void const   *)(& boot->BPB_RsvdSecCnt));
#line 519
    info->root_pos = tmp___12 + fat_sec * (unsigned int )boot->BPB_NumFATs;
    }
#line 520
    if (bit != 32U) {
#line 521
      info->root_size = root_sec;
    } else {
#line 523
      info->root_size = (unsigned int )boot->BPB_SecPerClus;
    }
  }
#line 527
  return (0);
}
}
#line 537 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_format(struct fat_context *fat , unsigned int size , unsigned int bit , unsigned int sector_per_cluster ,
               char const   *oem , char const   *label , unsigned int serial , struct disk_geometry  const  *geometry ) 
{ 
  struct fat_format format ;
  int r ;
  void *tmp ;

  {
  {
#line 542
  r = fat_format_compute(& format, & fat->info, size, bit, sector_per_cluster, oem,
                         label, serial, geometry, fat->h_pos + (unsigned int )geometry->start);
  }
#line 543
  if (r != 0) {
#line 544
    return (1);
  }
  {
#line 547
  free((void *)fat->table);
#line 548
  tmp = malloc((size_t )(fat->info.fat_size * 512U));
#line 548
  fat->table = (unsigned char *)tmp;
  }
#line 549
  if (! fat->table) {
    {
#line 550
    error_set("Low memory.");
    }
#line 551
    return (-1);
  }
  {
#line 555
  memset((void *)fat->table, 0, (size_t )(fat->info.fat_size * 512U));
#line 556
  memcpy((void */* __restrict  */)(fat->table + (format.fatraw_pos - fat->info.fat_pos) * 512U),
         (void const   */* __restrict  */)(format.fatraw), (size_t )(format.fatraw_size * 512U));
#line 559
  r = disk_write(fat->h, fat->h_pos + format.bootraw_pos, (void const   *)(format.bootraw),
                 format.bootraw_size);
  }
#line 560
  if (r != 0) {
#line 561
    return (-1);
  }
  {
#line 564
  r = disk_write(fat->h, fat->h_pos + format.rootraw_pos, (void const   *)(format.rootraw),
                 format.rootraw_size);
  }
#line 565
  if (r != 0) {
#line 566
    return (-1);
  }
#line 568
  return (0);
}
}
#line 571 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static unsigned int fat_table_allocate(struct fat_context *fat , unsigned int cluster ) 
{ 
  unsigned int i ;
  unsigned int tmp ;

  {
#line 576
  i = fat->first_free;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! (i < fat->info.cluster_num + 2U)) {
#line 576
      goto while_break;
    }
    {
#line 577
    tmp = fat_table_get(fat, i);
    }
#line 577
    if (tmp == 0U) {
#line 578
      goto while_break;
    }
#line 576
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  fat->first_free = i;
#line 582
  if (i == fat->info.cluster_num + 2U) {
    {
#line 583
    error_set("Disk full.");
    }
#line 584
    return (0U);
  }
#line 587
  if (cluster != 4294967295U) {
    {
#line 588
    fat_table_set(fat, cluster, i);
    }
  }
  {
#line 590
  fat_table_set(fat, i, 4294967295U);
  }
#line 592
  return (i);
}
}
#line 595 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static unsigned int fat_cluster_to_sector(struct fat_context *fat , unsigned int cluster ) 
{ 


  {
#line 597
  if (cluster >= 2U) {
#line 597
    if (! (cluster < fat->info.cluster_num + 2U)) {
      {
#line 597
      __assert_fail("cluster >= 2 && cluster < fat->info.cluster_num + 2", "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c",
                    597U, "fat_cluster_to_sector");
      }
    }
  } else {
    {
#line 597
    __assert_fail("cluster >= 2 && cluster < fat->info.cluster_num + 2", "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c",
                  597U, "fat_cluster_to_sector");
    }
  }
#line 599
  return (fat->info.data_pos + (cluster - 2U) * fat->info.cluster_size);
}
}
#line 602 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_cluster_read(struct fat_context *fat , unsigned int cluster , void *data ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 604
  tmp = fat_cluster_to_sector(fat, cluster);
#line 604
  tmp___0 = disk_read(fat->h, fat->h_pos + tmp, data, fat->info.cluster_size);
  }
#line 604
  return (tmp___0);
}
}
#line 607 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_cluster_write(struct fat_context *fat , unsigned int cluster , void const   *data ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 609
  tmp = fat_cluster_to_sector(fat, cluster);
#line 609
  tmp___0 = disk_write(fat->h, fat->h_pos + tmp, data, fat->info.cluster_size);
  }
#line 609
  return (tmp___0);
}
}
#line 620 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_name_set(struct fat_direntry *entry , char const   *file_name ) 
{ 
  char const   *dot ;
  unsigned int i ;
  int need_long ;
  char *tmp ;
  unsigned int l ;
  size_t tmp___0 ;
  unsigned int l___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
#line 624
  need_long = 0;
#line 626
  tmp = strchr(file_name, '.');
#line 626
  dot = (char const   *)tmp;
#line 628
  memset((void *)(entry->DE_Name), ' ', (size_t )11);
  }
#line 630
  if (dot) {
#line 631
    l = (unsigned int )(dot - file_name);
#line 632
    if (l > 8U) {
#line 633
      l = 8U;
#line 634
      need_long = 1;
    }
    {
#line 636
    memcpy((void */* __restrict  */)(entry->DE_Name), (void const   */* __restrict  */)file_name,
           (size_t )l);
#line 638
    dot ++;
#line 640
    tmp___0 = strlen(dot);
#line 640
    l = (unsigned int )tmp___0;
    }
#line 641
    if (l > 3U) {
#line 642
      l = 3U;
#line 643
      need_long = 1;
    } else
#line 644
    if (l == 0U) {
#line 646
      need_long = 1;
    }
    {
#line 649
    memcpy((void */* __restrict  */)(entry->DE_Name + 8), (void const   */* __restrict  */)dot,
           (size_t )l);
    }
  } else {
    {
#line 651
    tmp___1 = strlen(file_name);
#line 651
    l___0 = (unsigned int )tmp___1;
    }
#line 652
    if (l___0 > 8U) {
#line 653
      l___0 = 8U;
#line 654
      need_long = 1;
    }
    {
#line 657
    memcpy((void */* __restrict  */)(entry->DE_Name), (void const   */* __restrict  */)file_name,
           (size_t )l___0);
    }
  }
#line 660
  if (! need_long) {
#line 661
    i = 0U;
    {
#line 661
    while (1) {
      while_continue: /* CIL Label */ ;
#line 661
      if (! (i < 11U)) {
#line 661
        goto while_break;
      }
      {
#line 662
      tmp___2 = __ctype_b_loc();
      }
#line 662
      if ((int const   )*(*tmp___2 + (int )entry->DE_Name[i]) & 512) {
#line 663
        need_long = 1;
#line 664
        goto while_break;
      }
#line 661
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 669
  i = 0U;
  {
#line 669
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 669
    if (! (i < 11U)) {
#line 669
      goto while_break___0;
    }
    {
#line 670
    tmp___3 = toupper((int )entry->DE_Name[i]);
#line 670
    entry->DE_Name[i] = (char )tmp___3;
#line 669
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 672
  return (need_long);
}
}
#line 681 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static unsigned int fat_long_set(struct fat_direntry *entry , char const   *file_name ) 
{ 
  unsigned int l ;
  unsigned int n ;
  unsigned int i ;
  unsigned char checksum ;
  int tmp ;
  size_t tmp___0 ;
  unsigned short ws[13] ;
  unsigned int k ;
  struct fat_longentry *longentry ;
  unsigned int j ;

  {
  {
#line 688
  tmp = fat_name_set(entry, file_name);
  }
#line 688
  if (! tmp) {
#line 690
    return (1U);
  }
  {
#line 693
  tmp___0 = strlen(file_name);
#line 693
  l = (unsigned int )tmp___0;
  }
#line 696
  if (l > 255U) {
#line 697
    l = 255U;
  }
  {
#line 699
  n = (l + 12U) / 13U;
#line 701
  memcpy((void */* __restrict  */)(entry + n), (void const   */* __restrict  */)entry,
         (size_t )32);
#line 703
  checksum = (unsigned char)0;
#line 704
  i = 0U;
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (i < 11U)) {
#line 704
      goto while_break;
    }
#line 705
    checksum = (unsigned char )(((int )checksum >> 1) | ((int )checksum << 7));
#line 706
    checksum = (unsigned char )((int )checksum + (int )(entry + n)->DE_Name[i]);
#line 704
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  i = 0U;
  {
#line 709
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 709
    if (! (i < n)) {
#line 709
      goto while_break___0;
    }
#line 712
    longentry = (struct fat_longentry *)(entry + ((n - i) - 1U));
#line 714
    k = 0U;
    {
#line 714
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 714
      if (! (k < 13U)) {
#line 714
        goto while_break___1;
      }
#line 715
      j = k + i * 13U;
#line 716
      if (j == l) {
#line 717
        ws[k] = (unsigned short)0;
      } else
#line 718
      if (j > l) {
#line 719
        ws[k] = (unsigned short)65535;
      } else {
#line 721
        ws[k] = (unsigned short )((unsigned char )*(file_name + j));
      }
#line 714
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 724
    longentry->DE_Ordinal = (unsigned char )(i + 1U);
#line 725
    if (i + 1U == n) {
#line 726
      longentry->DE_Ordinal = (unsigned char )((int )longentry->DE_Ordinal | 64);
    }
    {
#line 727
    le_uint16_write((void *)(longentry->DE_Name0), (unsigned int )ws[0]);
#line 728
    le_uint16_write((void *)(longentry->DE_Name1), (unsigned int )ws[1]);
#line 729
    le_uint16_write((void *)(longentry->DE_Name2), (unsigned int )ws[2]);
#line 730
    le_uint16_write((void *)(longentry->DE_Name3), (unsigned int )ws[3]);
#line 731
    le_uint16_write((void *)(longentry->DE_Name4), (unsigned int )ws[4]);
#line 732
    longentry->DE_Attributes = (unsigned char)15;
#line 733
    longentry->DE_Reserved = (unsigned char)0;
#line 734
    longentry->DE_CheckSum = checksum;
#line 735
    le_uint16_write((void *)(longentry->DE_Name5), (unsigned int )ws[5]);
#line 736
    le_uint16_write((void *)(longentry->DE_Name6), (unsigned int )ws[6]);
#line 737
    le_uint16_write((void *)(longentry->DE_Name7), (unsigned int )ws[7]);
#line 738
    le_uint16_write((void *)(longentry->DE_Name8), (unsigned int )ws[8]);
#line 739
    le_uint16_write((void *)(longentry->DE_Name9), (unsigned int )ws[9]);
#line 740
    le_uint16_write((void *)(longentry->DE_Name10), (unsigned int )ws[10]);
#line 741
    le_uint16_write((void *)(longentry->DE_ClusterL), 0U);
#line 742
    le_uint16_write((void *)(longentry->DE_Name11), (unsigned int )ws[11]);
#line 743
    le_uint16_write((void *)(longentry->DE_Name12), (unsigned int )ws[12]);
#line 709
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 746
  return (n + 1U);
}
}
#line 757 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_cluster_file(struct fat_context *fat , char const   *file , unsigned int *cluster ,
                     unsigned int *size ) 
{ 
  FILE *f ;
  struct stat st ;
  unsigned int c ;
  unsigned int s ;
  int tmp ;
  int tmp___0 ;
  unsigned int run ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 764
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 765
  if (! f) {
    {
#line 766
    error_set("Error reading the file %s.", file);
    }
#line 767
    goto err;
  }
  {
#line 770
  tmp = fileno(f);
#line 770
  tmp___0 = fstat(tmp, & st);
  }
#line 770
  if (tmp___0 != 0) {
    {
#line 771
    error_set("Error reading the file %s.", file);
    }
#line 772
    goto err_close;
  }
#line 775
  s = (unsigned int )st.st_size;
#line 776
  *size = (unsigned int )st.st_size;
#line 778
  c = 4294967295U;
#line 779
  *cluster = 4294967295U;
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! s) {
#line 781
      goto while_break;
    }
#line 782
    run = fat->info.cluster_size * 512U;
#line 783
    if (run > s) {
#line 784
      run = s;
    }
#line 786
    if (c == 4294967295U) {
      {
#line 787
      c = fat_table_allocate(fat, c);
      }
#line 788
      if (! c) {
#line 789
        goto err_close;
      }
#line 790
      *cluster = c;
    } else {
      {
#line 792
      c = fat_table_allocate(fat, c);
      }
#line 793
      if (! c) {
#line 794
        goto err_close;
      }
    }
    {
#line 797
    tmp___1 = fread((void */* __restrict  */)(fat->tmp), (size_t )run, (size_t )1,
                    (FILE */* __restrict  */)f);
    }
#line 797
    if (tmp___1 != 1UL) {
      {
#line 798
      error_set("Error reading the file %s.", file);
      }
#line 799
      goto err_close;
    }
#line 802
    if (run < fat->info.cluster_size * 512U) {
      {
#line 803
      memset((void *)(fat->tmp + run), 0, (size_t )(fat->info.cluster_size * 512U - run));
      }
    }
    {
#line 805
    tmp___2 = fat_cluster_write(fat, c, (void const   *)(fat->tmp));
    }
#line 805
    if (tmp___2 != 0) {
#line 806
      goto err_close;
    }
#line 808
    s -= run;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 811
  fclose(f);
  }
#line 813
  return (0);
  err_close: 
  {
#line 816
  fclose(f);
  }
  err: 
#line 818
  return (-1);
}
}
#line 829 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_cluster_chain(struct fat_context *fat , unsigned int cluster , unsigned int *cluster_map ,
                      unsigned int cluster_max ) 
{ 
  unsigned int mac ;

  {
#line 833
  mac = 0U;
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! (cluster != 4294967295U)) {
#line 835
      goto while_break;
    }
#line 836
    if (cluster == 0U) {
#line 837
      return (-1);
    } else
#line 836
    if (cluster == 4294967287U) {
#line 837
      return (-1);
    }
#line 839
    if (mac >= cluster_max) {
#line 840
      return (-1);
    }
    {
#line 842
    *(cluster_map + mac) = cluster;
#line 843
    mac ++;
#line 845
    cluster = fat_table_get(fat, cluster);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 848
  return ((int )mac);
}
}
#line 859 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_sector_chain(struct fat_context *fat , unsigned int cluster , unsigned int *sector_map ,
                     unsigned int sector_max ) 
{ 
  unsigned int mac ;
  unsigned int i ;
  unsigned int tmp ;

  {
#line 863
  mac = 0U;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! (cluster != 4294967295U)) {
#line 865
      goto while_break;
    }
#line 868
    if (cluster == 0U) {
#line 869
      return (-1);
    } else
#line 868
    if (cluster == 4294967287U) {
#line 869
      return (-1);
    }
#line 871
    i = 0U;
    {
#line 871
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 871
      if (! (i < fat->info.cluster_size)) {
#line 871
        goto while_break___0;
      }
#line 872
      if (mac >= sector_max) {
#line 873
        return (-1);
      }
      {
#line 875
      tmp = fat_cluster_to_sector(fat, cluster);
#line 875
      *(sector_map + mac) = tmp + i;
#line 876
      mac ++;
#line 871
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 879
    cluster = fat_table_get(fat, cluster);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  return ((int )mac);
}
}
#line 885 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static void fat_date(unsigned char *w , time_t t ) 
{ 
  struct tm *tm ;
  int dos_year ;
  int dos_month ;
  int dos_day ;

  {
  {
#line 892
  tm = gmtime((time_t const   *)(& t));
  }
#line 894
  if (! tm) {
    {
#line 895
    le_uint16_write((void *)w, 0U);
    }
#line 896
    return;
  }
#line 899
  dos_day = tm->tm_mday;
#line 900
  dos_month = tm->tm_mon + 1;
#line 901
  dos_year = (tm->tm_year + 1900) - 1980;
#line 903
  if (dos_day < 0) {
    {
#line 906
    le_uint16_write((void *)w, 0U);
    }
#line 907
    return;
  } else
#line 903
  if (dos_day > 31) {
    {
#line 906
    le_uint16_write((void *)w, 0U);
    }
#line 907
    return;
  } else
#line 903
  if (dos_month < 1) {
    {
#line 906
    le_uint16_write((void *)w, 0U);
    }
#line 907
    return;
  } else
#line 903
  if (dos_month > 12) {
    {
#line 906
    le_uint16_write((void *)w, 0U);
    }
#line 907
    return;
  } else
#line 903
  if (dos_year < 0) {
    {
#line 906
    le_uint16_write((void *)w, 0U);
    }
#line 907
    return;
  } else
#line 903
  if (dos_year > 119) {
    {
#line 906
    le_uint16_write((void *)w, 0U);
    }
#line 907
    return;
  }
  {
#line 910
  le_uint16_write((void *)w, (unsigned int )((dos_day | (dos_month << 5)) | (dos_year << 9)));
  }
#line 911
  return;
}
}
#line 913 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static void fat_time(unsigned char *w , time_t t ) 
{ 
  struct tm *tm ;
  int dos_hour ;
  int dos_min ;
  int dos_sec ;

  {
  {
#line 920
  tm = gmtime((time_t const   *)(& t));
  }
#line 922
  if (! tm) {
    {
#line 923
    le_uint16_write((void *)w, 0U);
    }
#line 924
    return;
  }
#line 927
  dos_sec = tm->tm_sec / 2;
#line 928
  if (dos_sec == 30) {
#line 929
    dos_sec = 29;
  }
#line 930
  dos_min = tm->tm_min;
#line 931
  dos_hour = tm->tm_hour;
#line 933
  if (dos_sec < 0) {
    {
#line 936
    le_uint16_write((void *)w, 0U);
    }
#line 937
    return;
  } else
#line 933
  if (dos_sec > 29) {
    {
#line 936
    le_uint16_write((void *)w, 0U);
    }
#line 937
    return;
  } else
#line 933
  if (dos_min < 0) {
    {
#line 936
    le_uint16_write((void *)w, 0U);
    }
#line 937
    return;
  } else
#line 933
  if (dos_min > 59) {
    {
#line 936
    le_uint16_write((void *)w, 0U);
    }
#line 937
    return;
  } else
#line 933
  if (dos_hour < 0) {
    {
#line 936
    le_uint16_write((void *)w, 0U);
    }
#line 937
    return;
  } else
#line 933
  if (dos_hour > 23) {
    {
#line 936
    le_uint16_write((void *)w, 0U);
    }
#line 937
    return;
  }
  {
#line 940
  le_uint16_write((void *)w, (unsigned int )((dos_sec | (dos_min << 5)) | (dos_hour << 11)));
  }
#line 941
  return;
}
}
#line 949 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_cluster_dir(struct fat_context *fat , unsigned int root_cluster , unsigned int *cluster ,
                    time_t time___0 ) 
{ 
  unsigned int c ;
  struct fat_direntry *entry ;
  int tmp ;

  {
  {
#line 954
  c = fat_table_allocate(fat, 4294967295U);
  }
#line 955
  if (! c) {
#line 956
    return (-1);
  }
  {
#line 959
  memset((void *)(fat->tmp), 0, (size_t )(fat->info.cluster_size * 512U));
#line 961
  entry = (struct fat_direntry *)(fat->tmp);
#line 963
  strfcpy((entry + 0)->DE_Name, ".", (char )' ', 11U);
#line 964
  (entry + 0)->DE_Attributes = (unsigned char)16;
#line 965
  (entry + 0)->DE_Reserved = (unsigned char)0;
#line 966
  (entry + 0)->DE_CrtTimeTenth = (unsigned char)0;
#line 967
  le_uint16_write((void *)((entry + 0)->DE_CrtTime), 0U);
#line 968
  le_uint16_write((void *)((entry + 0)->DE_CrtDate), 0U);
#line 969
  le_uint16_write((void *)((entry + 0)->DE_LstAccDate), 0U);
#line 970
  le_uint16_write((void *)((entry + 0)->DE_ClusterH), c >> 16);
#line 971
  fat_time((entry + 0)->DE_WrtTime, time___0);
#line 972
  fat_date((entry + 0)->DE_WrtDate, time___0);
#line 973
  le_uint16_write((void *)((entry + 0)->DE_ClusterL), c & 65535U);
#line 974
  le_uint32_write((void *)((entry + 0)->DE_FileSize), 0U);
#line 975
  strfcpy((entry + 1)->DE_Name, "..", (char )' ', 11U);
#line 976
  (entry + 1)->DE_Attributes = (unsigned char)16;
#line 977
  (entry + 1)->DE_Reserved = (unsigned char)0;
#line 978
  (entry + 1)->DE_CrtTimeTenth = (unsigned char)0;
#line 979
  le_uint16_write((void *)((entry + 1)->DE_CrtTime), 0U);
#line 980
  le_uint16_write((void *)((entry + 1)->DE_CrtDate), 0U);
#line 981
  le_uint16_write((void *)((entry + 1)->DE_LstAccDate), 0U);
#line 982
  le_uint16_write((void *)((entry + 1)->DE_ClusterH), root_cluster >> 16);
#line 983
  fat_time((entry + 1)->DE_WrtTime, time___0);
#line 984
  fat_date((entry + 1)->DE_WrtDate, time___0);
#line 985
  le_uint16_write((void *)((entry + 1)->DE_ClusterL), root_cluster & 65535U);
#line 986
  le_uint32_write((void *)((entry + 1)->DE_FileSize), 0U);
#line 988
  tmp = fat_cluster_write(fat, c, (void const   *)(fat->tmp));
  }
#line 988
  if (tmp != 0) {
#line 989
    return (-1);
  }
#line 991
  *cluster = c;
#line 993
  return (0);
}
}
#line 996 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_chain_read(struct fat_context *fat , unsigned int cluster , unsigned char **data ,
                          unsigned int *data_size ) 
{ 
  void *tmp ;
  int tmp___0 ;
  unsigned int c ;
  unsigned int i ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 998
  if (cluster == 0U) {
#line 998
    if (fat->info.root_pos > fat->info.data_pos) {
#line 1000
      cluster = (fat->info.root_pos - fat->info.data_pos) / fat->info.cluster_size + 2U;
    }
  }
#line 1003
  if (cluster == 0U) {
    {
#line 1004
    *data_size = fat->info.root_size;
#line 1005
    tmp = malloc((size_t )(fat->info.root_size * 512U));
#line 1005
    *data = (unsigned char *)tmp;
    }
#line 1006
    if (! *data) {
      {
#line 1007
      error_set("Low memory.");
      }
#line 1008
      return (-1);
    }
    {
#line 1011
    tmp___0 = disk_read(fat->h, fat->h_pos + fat->info.root_pos, (void *)*data, fat->info.root_size);
    }
#line 1011
    if (tmp___0 != 0) {
#line 1012
      return (-1);
    }
  } else {
#line 1016
    i = 0U;
#line 1017
    c = cluster;
    {
#line 1018
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1018
      if (! (c != 4294967295U)) {
#line 1018
        goto while_break;
      }
      {
#line 1019
      c = fat_table_get(fat, c);
#line 1020
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1023
    *data_size = i * fat->info.cluster_size;
#line 1024
    tmp___1 = malloc((size_t )((i * fat->info.cluster_size) * 512U));
#line 1024
    *data = (unsigned char *)tmp___1;
    }
#line 1025
    if (! *data) {
      {
#line 1026
      error_set("Low memory.");
      }
#line 1027
      return (-1);
    }
#line 1030
    c = cluster;
#line 1031
    i = 0U;
    {
#line 1032
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1032
      if (! (c != 4294967295U)) {
#line 1032
        goto while_break___0;
      }
      {
#line 1033
      tmp___2 = fat_cluster_read(fat, c, (void *)(*data + (i * fat->info.cluster_size) * 512U));
      }
#line 1033
      if (tmp___2 != 0) {
#line 1034
        return (-1);
      }
      {
#line 1036
      c = fat_table_get(fat, c);
#line 1038
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1042
  return (0);
}
}
#line 1045 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
static int fat_chain_write(struct fat_context *fat , unsigned int cluster , unsigned char *data ,
                           unsigned int data_size ) 
{ 
  int tmp ;
  unsigned int c ;
  unsigned int i ;
  int tmp___0 ;
  unsigned int next ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 1047
  if (cluster == 0U) {
#line 1047
    if (fat->info.root_pos > fat->info.data_pos) {
#line 1049
      cluster = (fat->info.root_pos - fat->info.data_pos) / fat->info.cluster_size + 2U;
    }
  }
#line 1052
  if (cluster == 0U) {
#line 1053
    if (data_size != fat->info.root_size) {
      {
#line 1054
      error_set("Root directory full.");
      }
#line 1055
      return (-1);
    }
    {
#line 1058
    tmp = disk_write(fat->h, fat->h_pos + fat->info.root_pos, (void const   *)data,
                     fat->info.root_size);
    }
#line 1058
    if (tmp != 0) {
#line 1059
      return (-1);
    }
  } else {
    {
#line 1063
    i = 0U;
#line 1064
    c = cluster;
#line 1066
    tmp___0 = fat_cluster_write(fat, c, (void const   *)(data + (i * fat->info.cluster_size) * 512U));
    }
#line 1066
    if (tmp___0 != 0) {
#line 1067
      return (-1);
    }
#line 1069
    i ++;
    {
#line 1071
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1071
      if (! (i * fat->info.cluster_size < data_size)) {
#line 1071
        goto while_break;
      }
      {
#line 1072
      tmp___1 = fat_table_get(fat, c);
#line 1072
      next = tmp___1;
      }
#line 1074
      if (next == 4294967295U) {
        {
#line 1075
        next = fat_table_allocate(fat, c);
        }
      }
#line 1077
      c = next;
#line 1078
      if (! c) {
#line 1079
        return (-1);
      }
      {
#line 1081
      tmp___2 = fat_cluster_write(fat, c, (void const   *)(data + (i * fat->info.cluster_size) * 512U));
      }
#line 1081
      if (tmp___2 != 0) {
#line 1082
        return (-1);
      }
#line 1084
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1088
  return (0);
}
}
#line 1101 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_entry_add(struct fat_context *fat , unsigned int dir_cluster , char const   *file_name ,
                  unsigned int file_cluster , unsigned int file_size , unsigned int file_attrib ,
                  time_t file_time ) 
{ 
  struct fat_direntry longentry[21] ;
  struct fat_direntry *entry ;
  unsigned int n ;
  unsigned int i ;
  unsigned char *data ;
  unsigned int data_size ;
  unsigned int entry_count ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1110
  n = fat_long_set(longentry, file_name);
#line 1112
  entry = (longentry + n) - 1;
#line 1114
  entry->DE_Attributes = (unsigned char )file_attrib;
#line 1115
  entry->DE_Reserved = (unsigned char)0;
#line 1116
  entry->DE_CrtTimeTenth = (unsigned char)0;
#line 1117
  le_uint16_write((void *)(entry->DE_CrtTime), 0U);
#line 1118
  le_uint16_write((void *)(entry->DE_CrtDate), 0U);
#line 1119
  le_uint16_write((void *)(entry->DE_LstAccDate), 0U);
#line 1120
  le_uint16_write((void *)(entry->DE_ClusterH), file_cluster >> 16);
#line 1121
  fat_time(entry->DE_WrtTime, file_time);
#line 1122
  fat_date(entry->DE_WrtDate, file_time);
#line 1123
  le_uint16_write((void *)(entry->DE_ClusterL), file_cluster & 65535U);
#line 1124
  le_uint32_write((void *)(entry->DE_FileSize), file_size);
#line 1126
  tmp = fat_chain_read(fat, dir_cluster, & data, & data_size);
  }
#line 1126
  if (tmp != 0) {
#line 1127
    return (-1);
  }
#line 1129
  entry = (struct fat_direntry *)data;
#line 1131
  entry_count = data_size * 16U;
#line 1133
  i = 0U;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! (i < entry_count)) {
#line 1133
      goto while_break;
    }
#line 1134
    if ((int )(entry + i)->DE_Name[0] == 0) {
#line 1135
      goto while_break;
    }
#line 1133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1140
    if (! (i + n > entry_count)) {
#line 1140
      goto while_break___0;
    }
    {
#line 1141
    tmp___0 = realloc((void *)data, (size_t )((data_size + fat->info.cluster_size) * 512U));
#line 1141
    data = (unsigned char *)tmp___0;
    }
#line 1142
    if (! data) {
      {
#line 1143
      error_set("Low memory.");
      }
#line 1144
      return (-1);
    }
    {
#line 1147
    entry = (struct fat_direntry *)data;
#line 1150
    memset((void *)(data + data_size * 512U), 0, (size_t )(fat->info.cluster_size * 512U));
#line 1152
    data_size += fat->info.cluster_size;
#line 1154
    entry_count += fat->info.cluster_size * 16U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1157
  memcpy((void */* __restrict  */)(entry + i), (void const   */* __restrict  */)(longentry),
         (size_t )(n * 32U));
#line 1159
  tmp___1 = fat_chain_write(fat, dir_cluster, data, data_size);
  }
#line 1159
  if (tmp___1 != 0) {
#line 1160
    return (-1);
  }
  {
#line 1162
  free((void *)data);
  }
#line 1164
  return (0);
}
}
#line 1173 "/home/wheatley/newnew/temp/makebootfat-1.4/fat.c"
int fat_boot_setup(unsigned char *boot , unsigned char const   *code , unsigned int bit ) 
{ 
  unsigned int code_start ;

  {
#line 1178
  if ((int const   )*(code + 0) != 235) {
#line 1178
    goto _L;
  } else
#line 1178
  if ((int const   )*(code + 2) != 144) {
    _L: /* CIL Label */ 
#line 1178
    if ((int const   )*(code + 0) != 233) {
      {
#line 1179
      error_set("Invalid jump signature in the boot sector.");
      }
#line 1180
      return (-1);
    }
  }
#line 1183
  if ((int const   )*(code + 0) == 235) {
#line 1184
    code_start = (unsigned int )((int const   )*(code + 1) + 2);
  } else {
    {
#line 1186
    error_set("Unsupported jump in the boot sector.");
    }
#line 1187
    return (-1);
  }
#line 1190
  if (bit == 32U) {
#line 1190
    if (code_start < 90U) {
      {
#line 1191
      error_set("Invalid code start %X in the boot sector (for fat32 it must be at least 5A).",
                code_start);
      }
#line 1192
      return (-1);
    }
  }
#line 1195
  if (code_start < 62U) {
    {
#line 1196
    error_set("Invalid code start %X in the boot sector (it must be at least 3E).",
              code_start);
    }
#line 1197
    return (-1);
  }
  {
#line 1201
  memcpy((void */* __restrict  */)boot, (void const   */* __restrict  */)code, (size_t )3);
#line 1202
  memcpy((void */* __restrict  */)(boot + code_start), (void const   */* __restrict  */)(code + code_start),
         (size_t )(510U - code_start));
  }
#line 1204
  return (0);
}
}
#line 49 "/home/wheatley/newnew/temp/makebootfat-1.4/part.h"
void part_setup(unsigned char *mbr , unsigned int entry , unsigned int fat_bit , unsigned int fat_begin ,
                unsigned int fat_size , struct disk_geometry  const  *geometry ) ;
#line 50
int part_fat_setup(unsigned char *mbr , unsigned char const   *boot , unsigned int bit ,
                   unsigned int pos ) ;
#line 27 "/home/wheatley/newnew/temp/makebootfat-1.4/part.c"
static void part_entry_set(struct partition_entry *entry , unsigned int offset , unsigned int size ,
                           struct disk_geometry  const  *geometry ) 
{ 
  unsigned int h ;
  unsigned int s ;
  unsigned int c ;
  unsigned int start ;
  unsigned int end ;

  {
  {
#line 32
  le_uint32_write((void *)(entry->start), offset);
#line 33
  le_uint32_write((void *)(entry->size), size);
#line 35
  start = offset;
#line 36
  end = (offset + size) - 1U;
#line 38
  s = start % (unsigned int )geometry->sectors + 1U;
#line 39
  start /= (unsigned int )geometry->sectors;
#line 40
  h = start % (unsigned int )geometry->heads;
#line 41
  start /= (unsigned int )geometry->heads;
#line 42
  c = start;
#line 44
  entry->start_head = (unsigned char )h;
#line 45
  entry->start_seccyl[0] = (unsigned char )((s & 63U) | ((c >> 2) & 192U));
#line 46
  entry->start_seccyl[1] = (unsigned char )(c & 255U);
#line 48
  s = end % (unsigned int )geometry->sectors + 1U;
#line 49
  end /= (unsigned int )geometry->sectors;
#line 50
  h = end % (unsigned int )geometry->heads;
#line 51
  end /= (unsigned int )geometry->heads;
#line 52
  c = end;
#line 54
  entry->end_head = (unsigned char )h;
#line 55
  entry->end_seccyl[0] = (unsigned char )((s & 63U) | ((c >> 2) & 192U));
#line 56
  entry->end_seccyl[1] = (unsigned char )(c & 255U);
  }
#line 57
  return;
}
}
#line 64 "/home/wheatley/newnew/temp/makebootfat-1.4/part.c"
void part_setup(unsigned char *mbr , unsigned int entry , unsigned int fat_bit , unsigned int fat_begin ,
                unsigned int fat_size , struct disk_geometry  const  *geometry ) 
{ 
  struct partition_table *part ;

  {
  {
#line 66
  part = (struct partition_table *)mbr;
#line 69
  memset((void *)(part->entries), 0, sizeof(part->entries));
#line 71
  part->entries[entry].status = (unsigned char)128;
  }
#line 72
  if (fat_bit == 12U) {
#line 73
    part->entries[entry].type = (unsigned char)1;
  } else
#line 74
  if (fat_bit == 16U) {
#line 75
    part->entries[entry].type = (unsigned char)6;
  } else
#line 76
  if (fat_bit == 32U) {
#line 77
    part->entries[entry].type = (unsigned char)11;
  } else {
#line 79
    part->entries[entry].type = (unsigned char)0;
  }
#line 81
  if (! (fat_begin + fat_size <= (unsigned int )geometry->size)) {
    {
#line 81
    __assert_fail("fat_begin + fat_size <= geometry->size", "/home/wheatley/newnew/temp/makebootfat-1.4/part.c",
                  81U, "part_setup");
    }
  }
  {
#line 83
  part_entry_set(& part->entries[entry], fat_begin, fat_size, geometry);
#line 85
  part->id[0] = (unsigned char)85;
#line 86
  part->id[1] = (unsigned char)170;
  }
#line 87
  return;
}
}
#line 96 "/home/wheatley/newnew/temp/makebootfat-1.4/part.c"
int part_fat_setup(unsigned char *mbr , unsigned char const   *boot , unsigned int bit ,
                   unsigned int pos ) 
{ 
  struct fat_boot_sector *fat ;
  unsigned int size_in_sector ;
  unsigned int code_start ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 102
  if ((int )*(mbr + 0) != 235) {
#line 102
    goto _L;
  } else
#line 102
  if ((int )*(mbr + 2) != 144) {
    _L: /* CIL Label */ 
#line 102
    if ((int )*(mbr + 0) != 233) {
      {
#line 103
      error_set("Invalid jump signature in the mbr sector.");
      }
#line 104
      return (-1);
    }
  }
#line 107
  if ((int )*(mbr + 510) != 85) {
    {
#line 108
    error_set("Invalid end AA55 signature in the mbr sector.");
    }
#line 109
    return (-1);
  } else
#line 107
  if ((int )*(mbr + 511) != 170) {
    {
#line 108
    error_set("Invalid end AA55 signature in the mbr sector.");
    }
#line 109
    return (-1);
  }
#line 112
  if ((int )*(mbr + 0) == 235) {
#line 113
    code_start = (unsigned int )((int )*(mbr + 1) + 2);
  } else {
    {
#line 115
    error_set("Unsupported jump in the mbr sector.");
    }
#line 116
    return (-1);
  }
#line 119
  if (bit == 32U) {
#line 119
    if (code_start < 90U) {
      {
#line 120
      error_set("Invalid code start %X in the mbr sector (for fat32 it must be at least 5A).",
                code_start);
      }
#line 121
      return (-1);
    }
  }
#line 124
  if (code_start < 62U) {
    {
#line 125
    error_set("Invalid code start %X in the mbr sector (it must be at least 3E).",
              code_start);
    }
#line 126
    return (-1);
  }
#line 130
  if (bit == 32U) {
    {
#line 131
    memcpy((void */* __restrict  */)(mbr + 3), (void const   */* __restrict  */)(boot + 3),
           (size_t )87);
    }
  } else {
    {
#line 133
    memcpy((void */* __restrict  */)(mbr + 3), (void const   */* __restrict  */)(boot + 3),
           (size_t )59);
    }
  }
  {
#line 135
  fat = (struct fat_boot_sector *)mbr;
#line 138
  tmp = le_uint16_read((void const   *)(& fat->BPB_RsvdSecCnt));
#line 138
  le_uint16_write((void *)(& fat->BPB_RsvdSecCnt), tmp + pos);
#line 141
  tmp___0 = le_uint32_read((void const   *)(& fat->BPB_HiddSec));
  }
#line 141
  if (tmp___0 != pos) {
    {
#line 142
    error_set("Invalid number of hidden sector in the fat boot sector, it must be %d.",
              pos);
    }
#line 143
    return (-1);
  }
  {
#line 145
  le_uint32_write((void *)(& fat->BPB_HiddSec), 0U);
#line 148
  tmp___1 = le_uint32_read((void const   *)(fat->BPB_TotSec32));
  }
#line 148
  if (tmp___1 != 0U) {
    {
#line 149
    size_in_sector = le_uint32_read((void const   *)(fat->BPB_TotSec32));
    }
  } else {
    {
#line 151
    size_in_sector = le_uint16_read((void const   *)(fat->BPB_TotSec16));
    }
  }
#line 152
  size_in_sector += pos;
#line 153
  if (bit == 32U) {
    {
#line 154
    le_uint16_write((void *)(fat->BPB_TotSec16), 0U);
#line 155
    le_uint32_write((void *)(fat->BPB_TotSec32), size_in_sector);
    }
  } else
#line 153
  if (size_in_sector >= 65536U) {
    {
#line 154
    le_uint16_write((void *)(fat->BPB_TotSec16), 0U);
#line 155
    le_uint32_write((void *)(fat->BPB_TotSec32), size_in_sector);
    }
  } else {
    {
#line 157
    le_uint16_write((void *)(fat->BPB_TotSec16), size_in_sector);
#line 158
    le_uint32_write((void *)(fat->BPB_TotSec32), 0U);
    }
  }
#line 162
  if (bit == 32U) {
    {
#line 163
    tmp___2 = le_uint16_read((void const   *)(fat->bit.fat32.BPB_FSInfo));
#line 163
    le_uint16_write((void *)(fat->bit.fat32.BPB_FSInfo), tmp___2 + pos);
#line 166
    le_uint16_write((void *)(fat->bit.fat32.BPB_BkBootSec), 0U);
    }
  }
#line 169
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 24 "/home/wheatley/newnew/temp/makebootfat-1.4/error.h"
void error_interactive(int interactive ) ;
#line 26
char const   *error_get(void) ;
#line 25 "/home/wheatley/newnew/temp/makebootfat-1.4/error.c"
static char error_text[512]  ;
#line 26 "/home/wheatley/newnew/temp/makebootfat-1.4/error.c"
static int error_message_interactive  ;
#line 28 "/home/wheatley/newnew/temp/makebootfat-1.4/error.c"
void error_interactive(int interactive ) 
{ 


  {
#line 30
  error_message_interactive = interactive;
#line 31
  return;
}
}
#line 52 "/home/wheatley/newnew/temp/makebootfat-1.4/error.c"
void error_set(char const   *text  , ...) 
{ 
  va_list arg ;

  {
#line 56
  if (! error_text[0]) {
    {
#line 57
    __builtin_va_start(arg, text);
#line 58
    vsnprintf((char */* __restrict  */)(error_text), sizeof(error_text), (char const   */* __restrict  */)text,
              arg);
#line 59
    __builtin_va_end(arg);
    }
  }
#line 61
  return;
}
}
#line 65 "/home/wheatley/newnew/temp/makebootfat-1.4/error.c"
char const   *error_get(void) 
{ 


  {
#line 67
  return ((char const   *)(error_text));
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 66 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.h"
struct disk_handle *disk_open(char const   *dev ) ;
#line 67
int disk_close(struct disk_handle *h ) ;
#line 68
struct disk_handle *disk_find(void) ;
#line 27 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
int fatboot_format(struct fat_context *fat , unsigned char const   *boot12 , unsigned char const   *boot16 ,
                   unsigned char const   *boot32 , char const   *oem , char const   *label ,
                   unsigned int serial , struct disk_geometry  const  *geometry ,
                   int syslinux2 ) 
{ 
  unsigned int sector_per_cluster ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 33
  if (fat->h_size <= 32768U) {
#line 34
    sector_per_cluster = 1U;
  } else
#line 35
  if (fat->h_size <= 131072U) {
#line 36
    sector_per_cluster = 2U;
  } else
#line 37
  if (fat->h_size <= 524288U) {
#line 38
    sector_per_cluster = 4U;
  } else
#line 39
  if (fat->h_size <= 2097152U) {
#line 40
    sector_per_cluster = 8U;
  } else
#line 41
  if (fat->h_size <= 8388608U) {
#line 42
    sector_per_cluster = 16U;
  } else {
#line 44
    sector_per_cluster = 32U;
  }
#line 46
  r = -1;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (sector_per_cluster <= 32U)) {
#line 49
      if (! syslinux2) {
#line 49
        if (! (sector_per_cluster <= 128U)) {
#line 49
          goto while_break;
        }
      } else {
#line 49
        goto while_break;
      }
    }
#line 51
    if ((unsigned long )boot12 != (unsigned long )((unsigned char const   *)0)) {
      {
#line 52
      r = fat_format(fat, fat->h_size, 12U, sector_per_cluster, oem, label, serial,
                     geometry);
      }
#line 53
      if (r < 0) {
#line 54
        return (-1);
      }
#line 55
      if (r == 0) {
#line 56
        goto while_break;
      }
    }
#line 59
    if ((unsigned long )boot16 != (unsigned long )((unsigned char const   *)0)) {
      {
#line 60
      r = fat_format(fat, fat->h_size, 16U, sector_per_cluster, oem, label, serial,
                     geometry);
      }
#line 61
      if (r < 0) {
#line 62
        return (-1);
      }
#line 63
      if (r == 0) {
#line 64
        goto while_break;
      }
    }
#line 67
    if ((unsigned long )boot32 != (unsigned long )((unsigned char const   *)0)) {
#line 69
      if (! syslinux2) {
        {
#line 70
        r = fat_format(fat, fat->h_size, 32U, sector_per_cluster, oem, label, serial,
                       geometry);
        }
#line 71
        if (r < 0) {
#line 72
          return (-1);
        }
#line 73
        if (r == 0) {
#line 74
          goto while_break;
        }
      }
    }
#line 78
    sector_per_cluster *= 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (r != 0) {
    {
#line 82
    error_set("Unsupported disk size.");
    }
#line 83
    return (-1);
  }
  {
#line 87
  tmp = disk_read(fat->h, fat->h_pos, (void *)(fat->tmp), 1U);
  }
#line 87
  if (tmp != 0) {
#line 88
    return (-1);
  }
  {
#line 91
  if (fat->info.fat_bit == 12U) {
#line 91
    goto case_12;
  }
#line 95
  if (fat->info.fat_bit == 16U) {
#line 95
    goto case_16;
  }
#line 99
  if (fat->info.fat_bit == 32U) {
#line 99
    goto case_32;
  }
#line 90
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 92
  tmp___0 = fat_boot_setup(fat->tmp, boot12, fat->info.fat_bit);
  }
#line 92
  if (tmp___0 != 0) {
#line 93
    return (-1);
  }
#line 94
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 96
  tmp___1 = fat_boot_setup(fat->tmp, boot16, fat->info.fat_bit);
  }
#line 96
  if (tmp___1 != 0) {
#line 97
    return (-1);
  }
#line 98
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 100
  tmp___2 = fat_boot_setup(fat->tmp, boot32, fat->info.fat_bit);
  }
#line 100
  if (tmp___2 != 0) {
#line 101
    return (-1);
  }
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 105
  tmp___3 = disk_write(fat->h, fat->h_pos, (void const   *)(fat->tmp), 1U);
  }
#line 105
  if (tmp___3 != 0) {
#line 106
    return (-1);
  }
#line 108
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
int fatboot_syslinux3(struct fat_context *fat , unsigned int *sec_map , unsigned int sec_mac ,
                      unsigned int size ) 
{ 
  unsigned char tmp[512] ;
  unsigned char *data ;
  unsigned int i ;
  unsigned int p ;
  unsigned int csum ;
  unsigned int csum_mac ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
#line 125
  if (sec_mac > 65U) {
    {
#line 126
    error_set("Invalid ldlinux.sys. Too big.");
    }
#line 127
    return (-1);
  }
  {
#line 131
  tmp___0 = disk_read(fat->h, fat->h_pos, (void *)(tmp), 1U);
  }
#line 131
  if (tmp___0 != 0) {
#line 132
    return (-1);
  }
  {
#line 135
  tmp___1 = le_uint32_read((void const   *)(tmp + 504));
  }
#line 135
  if (tmp___1 != 3735928559U) {
    {
#line 136
    error_set("Invalid ldlinux.bss. Missing tag word.");
    }
#line 137
    return (-1);
  }
  {
#line 141
  le_uint32_write((void *)(tmp + 504), *(sec_map + 0));
#line 144
  tmp___2 = disk_write(fat->h, fat->h_pos, (void const   *)(tmp), 1U);
  }
#line 144
  if (tmp___2 != 0) {
#line 145
    return (-1);
  }
  {
#line 147
  tmp___3 = malloc((size_t )(sec_mac * 512U));
#line 147
  data = (unsigned char *)tmp___3;
  }
#line 148
  if (! data) {
    {
#line 149
    error_set("Low memory.");
    }
#line 150
    return (-1);
  }
#line 154
  i = 0U;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < sec_mac)) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp___4 = disk_read(fat->h, fat->h_pos + *(sec_map + i), (void *)(data + i * 512U),
                        1U);
    }
#line 155
    if (tmp___4 != 0) {
#line 156
      return (-1);
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  i = 0U;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 160
    if (! (i < 512U)) {
#line 160
      goto while_break___0;
    }
    {
#line 161
    tmp___5 = le_uint32_read((void const   *)(data + i));
    }
#line 161
    if (tmp___5 == 1051853566U) {
#line 162
      goto while_break___0;
    }
#line 160
    i += 4U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  if (i == 512U) {
    {
#line 164
    error_set("Invalid ldlinux.sys. Missing tag word.");
    }
#line 165
    return (-1);
  }
  {
#line 169
  p = i + 8U;
#line 171
  csum_mac = size / 4U;
#line 173
  le_uint16_write((void *)(data + p), csum_mac);
#line 174
  le_uint16_write((void *)((data + p) + 2), sec_mac - 1U);
#line 177
  memset((void *)((data + p) + 8), 0, (size_t )256);
#line 179
  i = 1U;
  }
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (! (i < sec_mac)) {
#line 179
      goto while_break___1;
    }
    {
#line 180
    le_uint32_write((void *)(((data + p) + 8) + (i - 1U) * 4U), *(sec_map + i));
#line 179
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 183
  le_uint32_write((void *)((data + p) + 4), 0U);
#line 185
  csum = 1051853566U;
#line 186
  i = 0U;
  }
  {
#line 186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 186
    if (! (i < csum_mac)) {
#line 186
      goto while_break___2;
    }
    {
#line 187
    tmp___6 = le_uint32_read((void const   *)(data + i * 4U));
#line 187
    csum -= tmp___6;
#line 186
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 189
  le_uint32_write((void *)((data + p) + 4), csum);
#line 192
  tmp___7 = disk_write(fat->h, fat->h_pos + *(sec_map + 0), (void const   *)data,
                       1U);
  }
#line 192
  if (tmp___7 != 0) {
#line 193
    return (-1);
  }
  {
#line 195
  free((void *)data);
  }
#line 197
  return (0);
}
}
#line 205 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
int fatboot_copy(struct fat_context *fat , unsigned int cluster , char const   *image ,
                 struct string_list *exclude_list , time_t force_time ) 
{ 
  DIR *d ;
  struct dirent *dd ;
  char path[512] ;
  struct stat st ;
  unsigned int file_cluster ;
  unsigned int file_size ;
  unsigned int file_attrib ;
  time_t file_time ;
  struct string_list *e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 210
  d = opendir(image);
  }
#line 211
  if (! d) {
    {
#line 212
    error_set("Error opening the directory %s.", image);
    }
#line 213
    return (-1);
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 216
    dd = readdir(d);
    }
#line 216
    if (! ((unsigned long )dd != (unsigned long )((struct dirent *)0))) {
#line 216
      goto while_break;
    }
    {
#line 225
    tmp = strcmp((char const   *)(dd->d_name), ".");
    }
#line 225
    if (tmp == 0) {
#line 226
      goto while_continue;
    } else {
      {
#line 225
      tmp___0 = strcmp((char const   *)(dd->d_name), "..");
      }
#line 225
      if (tmp___0 == 0) {
#line 226
        goto while_continue;
      }
    }
    {
#line 228
    sprintf((char */* __restrict  */)(path), (char const   */* __restrict  */)"%s/%s",
            image, dd->d_name);
#line 230
    e = exclude_list;
    }
    {
#line 231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 231
      if (! e) {
#line 231
        goto while_break___0;
      }
      {
#line 232
      tmp___1 = strcmp((char const   *)(path), (char const   *)e->path);
      }
#line 232
      if (tmp___1 == 0) {
#line 233
        goto while_break___0;
      }
#line 234
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    if (e) {
#line 237
      goto while_continue;
    }
    {
#line 239
    tmp___2 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& st));
    }
#line 239
    if (tmp___2 != 0) {
      {
#line 240
      error_set("Error reading the file %s.", path);
      }
#line 241
      return (-1);
    }
#line 244
    if ((st.st_mode & 61440U) == 16384U) {
#line 245
      file_size = 0U;
#line 246
      file_attrib = 16U;
#line 247
      if (force_time) {
#line 248
        file_time = force_time;
      } else {
#line 250
        file_time = st.st_mtime;
      }
      {
#line 252
      tmp___3 = fat_cluster_dir(fat, cluster, & file_cluster, file_time);
      }
#line 252
      if (tmp___3 != 0) {
#line 253
        return (-1);
      }
      {
#line 255
      tmp___4 = fatboot_copy(fat, file_cluster, (char const   *)(path), exclude_list,
                             force_time);
      }
#line 255
      if (tmp___4 != 0) {
#line 256
        return (-1);
      }
    } else
#line 257
    if ((st.st_mode & 61440U) == 32768U) {
#line 258
      file_attrib = 0U;
#line 259
      if (force_time) {
#line 260
        file_time = force_time;
      } else {
#line 262
        file_time = st.st_mtime;
      }
      {
#line 264
      tmp___5 = fat_cluster_file(fat, (char const   *)(path), & file_cluster, & file_size);
      }
#line 264
      if (tmp___5 != 0) {
#line 265
        return (-1);
      }
    } else {
#line 267
      return (-1);
    }
    {
#line 270
    tmp___6 = fat_entry_add(fat, cluster, (char const   *)(dd->d_name), file_cluster,
                            file_size, file_attrib, file_time);
    }
#line 270
    if (tmp___6 != 0) {
#line 271
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  closedir(d);
  }
#line 276
  return (0);
}
}
#line 279 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
int fatboot_copytoroot(struct fat_context *fat , char const   *file , unsigned int *cluster ,
                       unsigned int *size , time_t force_time ) 
{ 
  struct stat st ;
  unsigned int file_cluster ;
  unsigned int file_size ;
  unsigned int file_attrib ;
  time_t file_time ;
  char const   *name ;
  char const   *slash ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 289
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 289
  if (tmp != 0) {
    {
#line 290
    error_set("Error reading the file %s.", file);
    }
#line 291
    return (-1);
  }
#line 294
  file_attrib = 1U;
#line 295
  if (force_time) {
#line 296
    file_time = force_time;
  } else {
#line 298
    file_time = st.st_mtime;
  }
  {
#line 300
  tmp___0 = strrchr(file, '/');
#line 300
  name = (char const   *)tmp___0;
#line 301
  tmp___1 = strrchr(file, '\\');
#line 301
  slash = (char const   *)tmp___1;
  }
#line 302
  if (! name) {
#line 303
    name = slash;
  } else
#line 302
  if (slash) {
#line 302
    if ((unsigned long )slash > (unsigned long )name) {
#line 303
      name = slash;
    }
  }
#line 304
  if (! name) {
#line 305
    name = file;
  } else {
#line 307
    name ++;
  }
  {
#line 309
  tmp___2 = fat_cluster_file(fat, file, & file_cluster, & file_size);
  }
#line 309
  if (tmp___2 != 0) {
#line 310
    return (-1);
  }
  {
#line 312
  tmp___3 = fat_entry_add(fat, 0U, name, file_cluster, file_size, file_attrib, file_time);
  }
#line 312
  if (tmp___3 != 0) {
#line 313
    return (-1);
  }
#line 316
  *cluster = file_cluster;
#line 317
  *size = file_size;
#line 319
  return (0);
}
}
#line 322 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
void version(void) 
{ 


  {
  {
#line 323
  printf((char const   */* __restrict  */)"makebootfat v1.4 by Andrea Mazzoleni\n");
  }
#line 324
  return;
}
}
#line 326 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
void usage(void) 
{ 


  {
  {
#line 327
  version();
#line 329
  printf((char const   */* __restrict  */)"Usage: makebootfat [options] dir\n");
#line 330
  printf((char const   */* __restrict  */)"\n");
#line 331
  printf((char const   */* __restrict  */)"Options:\n");
#line 332
  printf((char const   */* __restrict  */)"  -o, --output DEVICE  Select the output device\n");
#line 333
  printf((char const   */* __restrict  */)"  -b, --boot FILE      Select the boot sector image\n");
#line 334
  printf((char const   */* __restrict  */)"  -m, --mbr FILE       Select the mbr sector image\n");
#line 335
  printf((char const   */* __restrict  */)"  -c, --copy FILE      Copy a file in the root directory\n");
#line 336
  printf((char const   */* __restrict  */)"  -x, --exclude FILE   Exclude files\n");
#line 337
  printf((char const   */* __restrict  */)"  -X, --syslinux2      Enforce syslinux 2.xx limitations\n");
#line 338
  printf((char const   */* __restrict  */)"  -Y, --syslinux3      Enforce syslinux 3.xx limitations\n");
#line 339
  printf((char const   */* __restrict  */)"  -Z, --zip            Enforce ZIP-Drive compatibility if possible\n");
#line 340
  printf((char const   */* __restrict  */)"  -F, --mbrfat         Change the MBR to imitate a FAT boot sector\n");
#line 341
  printf((char const   */* __restrict  */)"  -L, --label LABEL    Volume label\n");
#line 342
  printf((char const   */* __restrict  */)"  -O, --oem OEM        Volume oem\n");
#line 343
  printf((char const   */* __restrict  */)"  -S, --serial SERIAL  Volume serial\n");
#line 344
  printf((char const   */* __restrict  */)"  -E, --drive DRIVE    Drive BIOS number\n");
#line 345
  printf((char const   */* __restrict  */)"  -v, --verbose        Verbose\n");
#line 346
  printf((char const   */* __restrict  */)"  -h, --help           Help\n");
#line 347
  printf((char const   */* __restrict  */)"  -V, --version        Version\n");
  }
#line 348
  return;
}
}
#line 351 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
struct option long_options[24]  = 
#line 351
  {      {"label", 1, (int *)0, 'L'}, 
        {"oem", 1, (int *)0, 'O'}, 
        {"serial", 1, (int *)0, 'S'}, 
        {"drive", 1, (int *)0, 'E'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"boot", 1, (int *)0, 'b'}, 
        {"boot-fat12", 1, (int *)0, '1'}, 
        {"boot-fat16", 1, (int *)0, '2'}, 
        {"boot-fat32", 1, (int *)0, '3'}, 
        {"mbr", 1, (int *)0, 'm'}, 
        {"copy", 1, (int *)0, 'c'}, 
        {"exclude", 1, (int *)0, 'x'}, 
        {"time", 1, (int *)0, 't'}, 
        {"syslinux2", 0, (int *)0, 'X'}, 
        {"syslinux3", 0, (int *)0, 'Y'}, 
        {"zip", 0, (int *)0, 'Z'}, 
        {"partition", 0, (int *)0, 'P'}, 
        {"disk", 0, (int *)0, 'D'}, 
        {"mbrfat", 0, (int *)0, 'F'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"interative", 0, (int *)0, 'i'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 386 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
void string_insert(struct string_list **list , char const   *s ) 
{ 
  struct string_list *e ;
  void *tmp ;
  struct string_list *i ;

  {
  {
#line 388
  tmp = malloc(sizeof(struct string_list ));
#line 388
  e = (struct string_list *)tmp;
#line 390
  e->path = strdup(s);
#line 391
  e->next = (struct string_list *)0;
  }
#line 392
  if (! *list) {
#line 393
    *list = e;
  } else {
#line 395
    i = *list;
    {
#line 396
    while (1) {
      while_continue: /* CIL Label */ ;
#line 396
      if (! i->next) {
#line 396
        goto while_break;
      }
#line 397
      i = i->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 398
    i->next = e;
  }
#line 400
  return;
}
}
#line 402 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
void string_destroy(struct string_list *list ) 
{ 
  struct string_list *e ;
  struct string_list *n ;

  {
#line 404
  e = list;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! e) {
#line 405
      goto while_break;
    }
    {
#line 406
    n = e->next;
#line 407
    free((void *)e->path);
#line 408
    free((void *)e);
#line 409
    e = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return;
}
}
#line 413 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
int sector_read(unsigned char *sector , char const   *file ) 
{ 
  FILE *f ;
  size_t s ;

  {
  {
#line 418
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 419
  if (! f) {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading the file %s",
            file);
    }
#line 421
    return (-1);
  }
  {
#line 425
  memset((void *)sector, 0, (size_t )512);
#line 427
  s = fread((void */* __restrict  */)sector, (size_t )1, (size_t )512, (FILE */* __restrict  */)f);
  }
#line 428
  if (s == 0UL) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading the file %s",
            file);
    }
#line 430
    return (-1);
  }
  {
#line 433
  fclose(f);
  }
#line 435
  return (0);
}
}
#line 443 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
void verbose_callback(void *void_context , int operation , unsigned int pos , unsigned int size ) 
{ 
  struct verbose_context_struct *context ;

  {
#line 445
  context = (struct verbose_context_struct *)void_context;
#line 447
  if (operation) {
#line 448
    context->counter += size;
    {
#line 449
    while (1) {
      while_continue: /* CIL Label */ ;
#line 449
      if (! (context->counter >= 2048U)) {
#line 449
        goto while_break;
      }
      {
#line 450
      (context->total) ++;
#line 451
      context->counter -= 2048U;
#line 452
      printf((char const   */* __restrict  */)"\rwrite %d [sectors], %d [MB]", context->total * 2048U,
             context->total);
#line 453
      fflush(stdout);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 456
  return;
}
}
#line 458 "/home/wheatley/newnew/temp/makebootfat-1.4/makebootfat.c"
int main(int argc , char **argv ) 
{ 
  struct string_list *exclude_list ;
  struct string_list *copy_list ;
  struct string_list *s ;
  int c ;
  struct disk_handle *h ;
  int r ;
  struct fat_context *fat ;
  char const   *label ;
  char const   *oem ;
  unsigned int serial ;
  char const   *file_boot12 ;
  char const   *file_boot16 ;
  char const   *file_boot32 ;
  char const   *file_mbr ;
  unsigned char boot12[512] ;
  unsigned char boot16[512] ;
  unsigned char boot32[512] ;
  unsigned char mbr[512] ;
  char const   *output ;
  int syslinux2 ;
  int syslinux3 ;
  int mbrfat ;
  int verbose ;
  int only_partition ;
  int only_disk ;
  int zip_compatibility ;
  int drive ;
  unsigned int syslinux3_sector_max ;
  unsigned int *syslinux3_sector_map ;
  unsigned long __lengthofsyslinux3_sector_map ;
  void *tmp ;
  int syslinux3_sector_mac ;
  unsigned int syslinux3_size ;
  unsigned int part_entry ;
  unsigned int fat_start ;
  struct verbose_context_struct verbose_context ;
  time_t force_time ;
  time_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int size ;
  int tmp___8 ;
  unsigned int size___0 ;
  char const   *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char boot[512] ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int root_cluster ;
  unsigned int root_size ;
  unsigned int l ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;

  {
  {
#line 487
  syslinux3_sector_max = 65U;
#line 488
  __lengthofsyslinux3_sector_map = (unsigned long )syslinux3_sector_max;
#line 488
  tmp = __builtin_alloca(sizeof(*syslinux3_sector_map) * __lengthofsyslinux3_sector_map);
#line 488
  syslinux3_sector_map = (unsigned int *)tmp;
#line 496
  exclude_list = (struct string_list *)0;
#line 497
  copy_list = (struct string_list *)0;
#line 498
  label = (char const   *)0;
#line 499
  oem = "MAKEBOOTFAT";
#line 500
  tmp___0 = time((time_t *)0);
#line 500
  serial = (unsigned int )tmp___0;
#line 501
  file_boot12 = (char const   *)0;
#line 502
  file_boot16 = (char const   *)0;
#line 503
  file_boot32 = (char const   *)0;
#line 504
  file_mbr = (char const   *)0;
#line 505
  output = (char const   *)0;
#line 506
  syslinux2 = 0;
#line 507
  syslinux3 = 0;
#line 508
  mbrfat = 0;
#line 509
  verbose = 0;
#line 510
  only_partition = 0;
#line 511
  only_disk = 0;
#line 512
  drive = -1;
#line 513
  syslinux3_sector_mac = 0;
#line 514
  syslinux3_size = 0U;
#line 515
  zip_compatibility = 0;
#line 516
  part_entry = 0U;
#line 517
  verbose_context.total = 0U;
#line 518
  verbose_context.counter = 0U;
#line 519
  force_time = (time_t )0;
#line 521
  opterr = 0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 523
    c = getopt_long(argc, (char * const  *)argv, "L:O:S:E:o:ab:1:2:3:m:c:x:t:XYZPDFvihV",
                    (struct option  const  *)(long_options), (int *)0);
    }
#line 523
    if (! (c != -1)) {
#line 523
      goto while_break;
    }
    {
#line 531
    if (c == 79) {
#line 531
      goto case_79;
    }
#line 534
    if (c == 76) {
#line 534
      goto case_76;
    }
#line 537
    if (c == 83) {
#line 537
      goto case_83;
    }
#line 540
    if (c == 69) {
#line 540
      goto case_69;
    }
#line 543
    if (c == 98) {
#line 543
      goto case_98;
    }
#line 548
    if (c == 49) {
#line 548
      goto case_49;
    }
#line 551
    if (c == 50) {
#line 551
      goto case_50;
    }
#line 554
    if (c == 51) {
#line 554
      goto case_51;
    }
#line 557
    if (c == 109) {
#line 557
      goto case_109;
    }
#line 560
    if (c == 99) {
#line 560
      goto case_99;
    }
#line 563
    if (c == 120) {
#line 563
      goto case_120;
    }
#line 566
    if (c == 116) {
#line 566
      goto case_116;
    }
#line 569
    if (c == 88) {
#line 569
      goto case_88;
    }
#line 572
    if (c == 89) {
#line 572
      goto case_89;
    }
#line 575
    if (c == 90) {
#line 575
      goto case_90;
    }
#line 578
    if (c == 80) {
#line 578
      goto case_80;
    }
#line 581
    if (c == 68) {
#line 581
      goto case_68;
    }
#line 584
    if (c == 70) {
#line 584
      goto case_70;
    }
#line 587
    if (c == 111) {
#line 587
      goto case_111;
    }
#line 590
    if (c == 118) {
#line 590
      goto case_118;
    }
#line 593
    if (c == 105) {
#line 593
      goto case_105;
    }
#line 596
    if (c == 104) {
#line 596
      goto case_104;
    }
#line 599
    if (c == 86) {
#line 599
      goto case_86;
    }
#line 602
    goto switch_default;
    case_79: /* CIL Label */ 
#line 532
    oem = (char const   *)optarg;
#line 533
    goto switch_break;
    case_76: /* CIL Label */ 
#line 535
    label = (char const   *)optarg;
#line 536
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 538
    tmp___1 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)0,
                      0);
#line 538
    serial = (unsigned int )tmp___1;
    }
#line 539
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 541
    tmp___2 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)0,
                      0);
#line 541
    drive = (int )tmp___2;
    }
#line 542
    goto switch_break;
    case_98: /* CIL Label */ 
#line 544
    file_boot12 = (char const   *)optarg;
#line 545
    file_boot16 = (char const   *)optarg;
#line 546
    file_boot32 = (char const   *)optarg;
#line 547
    goto switch_break;
    case_49: /* CIL Label */ 
#line 549
    file_boot12 = (char const   *)optarg;
#line 550
    goto switch_break;
    case_50: /* CIL Label */ 
#line 552
    file_boot16 = (char const   *)optarg;
#line 553
    goto switch_break;
    case_51: /* CIL Label */ 
#line 555
    file_boot32 = (char const   *)optarg;
#line 556
    goto switch_break;
    case_109: /* CIL Label */ 
#line 558
    file_mbr = (char const   *)optarg;
#line 559
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 561
    string_insert(& copy_list, (char const   *)optarg);
    }
#line 562
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 564
    string_insert(& exclude_list, (char const   *)optarg);
    }
#line 565
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 567
    tmp___3 = atoi((char const   *)optarg);
#line 567
    force_time = (time_t )tmp___3;
    }
#line 568
    goto switch_break;
    case_88: /* CIL Label */ 
#line 570
    syslinux2 = 1;
#line 571
    goto switch_break;
    case_89: /* CIL Label */ 
#line 573
    syslinux3 = 1;
#line 574
    goto switch_break;
    case_90: /* CIL Label */ 
#line 576
    zip_compatibility = 1;
#line 577
    goto switch_break;
    case_80: /* CIL Label */ 
#line 579
    only_partition = 1;
#line 580
    goto switch_break;
    case_68: /* CIL Label */ 
#line 582
    only_disk = 1;
#line 583
    goto switch_break;
    case_70: /* CIL Label */ 
#line 585
    mbrfat = 1;
#line 586
    goto switch_break;
    case_111: /* CIL Label */ 
#line 588
    output = (char const   *)optarg;
#line 589
    goto switch_break;
    case_118: /* CIL Label */ 
#line 591
    verbose = 1;
#line 592
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 594
    error_interactive(1);
    }
#line 595
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 597
    usage();
#line 598
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 600
    version();
#line 601
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 603
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option `%c`\n",
            (int )((char )c));
    }
#line 604
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  if (optind + 1 != argc) {
    {
#line 609
    usage();
#line 610
    exit(1);
    }
  }
#line 613
  if (! output) {
    {
#line 614
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must specify the output device.\n");
#line 615
    exit(1);
    }
  }
#line 618
  if (! file_boot12) {
#line 618
    if (! file_boot16) {
#line 618
      if (! file_boot32) {
        {
#line 619
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must specify a boot sector image.\n");
#line 620
        exit(1);
        }
      }
    }
  }
#line 623
  if (file_boot12) {
    {
#line 624
    tmp___4 = sector_read(boot12, file_boot12);
    }
#line 624
    if (tmp___4 != 0) {
      {
#line 625
      exit(1);
      }
    }
  }
#line 629
  if (file_boot16) {
    {
#line 630
    tmp___5 = sector_read(boot16, file_boot16);
    }
#line 630
    if (tmp___5 != 0) {
      {
#line 631
      exit(1);
      }
    }
  }
#line 635
  if (file_boot32) {
    {
#line 636
    tmp___6 = sector_read(boot32, file_boot32);
    }
#line 636
    if (tmp___6 != 0) {
      {
#line 637
      exit(1);
      }
    }
  }
  {
#line 641
  tmp___7 = strcmp(output, "usb");
  }
#line 641
  if (tmp___7 == 0) {
    {
#line 642
    h = disk_find();
    }
#line 643
    if ((unsigned long )h == (unsigned long )((struct disk_handle *)0)) {
#line 644
      goto err_msg;
    }
  } else {
    {
#line 646
    h = disk_open(output);
    }
#line 647
    if ((unsigned long )h == (unsigned long )((struct disk_handle *)0)) {
#line 648
      goto err_msg;
    }
  }
#line 651
  if (zip_compatibility) {
#line 652
    if (h->geometry.size <= 2097152U) {
#line 654
      h->geometry.sectors = 32U;
#line 655
      h->geometry.heads = 64U;
#line 656
      part_entry = 3U;
#line 657
      h->geometry.cylinders = h->geometry.size / (h->geometry.sectors * h->geometry.heads);
#line 659
      h->geometry.size = (h->geometry.sectors * h->geometry.heads) * h->geometry.cylinders;
    }
  }
#line 665
  fat_start = h->geometry.sectors;
#line 667
  if (drive != -1) {
#line 668
    h->geometry.drive = (unsigned char )drive;
  }
#line 671
  if (only_partition) {
#line 672
    if (h->geometry.start == 0U) {
      {
#line 673
      error_set("The specified device isn\'t a partition but a disk.");
      }
#line 674
      goto err_invalidate;
    }
  }
#line 678
  if (only_disk) {
#line 679
    if (h->geometry.start != 0U) {
      {
#line 680
      error_set("The specified device isn\'t a disk but a partition.");
      }
#line 681
      goto err_invalidate;
    }
  }
#line 685
  if (file_mbr) {
    {
#line 688
    tmp___8 = sector_read(mbr, file_mbr);
    }
#line 688
    if (tmp___8 != 0) {
#line 689
      goto err_invalidate;
    }
#line 691
    size = h->geometry.size - fat_start;
#line 692
    if (syslinux2) {
#line 692
      if (size > 2097088U) {
#line 693
        size = 2097088U;
      }
    }
    {
#line 695
    fat = fat_open(h, fat_start, size, (struct disk_geometry  const  *)(& h->geometry));
    }
  } else {
#line 699
    size___0 = h->geometry.size;
#line 700
    if (syslinux2) {
#line 700
      if (size___0 > 2097088U) {
#line 701
        size___0 = 2097088U;
      }
    }
    {
#line 703
    fat = fat_open(h, 0U, size___0, (struct disk_geometry  const  *)(& h->geometry));
    }
  }
#line 705
  if ((unsigned long )fat == (unsigned long )((struct fat_context *)0)) {
#line 706
    goto err_invalidate;
  }
#line 708
  if (verbose) {
    {
#line 709
    printf((char const   */* __restrict  */)"device_start %d [sectors]\n", h->geometry.start);
#line 710
    printf((char const   */* __restrict  */)"device_size %d [sectors], %d [MB]\n",
           h->geometry.size, h->geometry.size / 2048U);
#line 711
    printf((char const   */* __restrict  */)"device_geometry %d/%d/%d [cylinders/heads/sectors]",
           h->geometry.cylinders, h->geometry.heads, h->geometry.sectors);
    }
#line 712
    if (h->geometry.sectors == 32U) {
#line 712
      if (h->geometry.heads == 64U) {
        {
#line 713
        printf((char const   */* __restrict  */)" (ZIP-Drive compatible)");
        }
      }
    }
    {
#line 715
    printf((char const   */* __restrict  */)"\n");
    }
#line 716
    if (((int )h->geometry.drive & 128) != 0) {
#line 716
      tmp___9 = "HDD";
    } else {
#line 716
      tmp___9 = "FDD";
    }
    {
#line 716
    printf((char const   */* __restrict  */)"bios_drive %s\n", tmp___9);
    }
  }
#line 719
  if (file_boot32) {
#line 719
    tmp___10 = boot32;
  } else {
#line 719
    tmp___10 = (unsigned char *)0;
  }
#line 719
  if (file_boot16) {
#line 719
    tmp___11 = boot16;
  } else {
#line 719
    tmp___11 = (unsigned char *)0;
  }
#line 719
  if (file_boot12) {
#line 719
    tmp___12 = boot12;
  } else {
#line 719
    tmp___12 = (unsigned char *)0;
  }
  {
#line 719
  r = fatboot_format(fat, (unsigned char const   *)tmp___12, (unsigned char const   *)tmp___11,
                     (unsigned char const   *)tmp___10, oem, label, serial, (struct disk_geometry  const  *)(& h->geometry),
                     syslinux2);
  }
#line 720
  if (r != 0) {
#line 721
    goto err_invalidate;
  }
#line 723
  if (verbose) {
    {
#line 724
    printf((char const   */* __restrict  */)"fat_start %d [sectors]\n", fat->h_pos + h->geometry.start);
#line 725
    printf((char const   */* __restrict  */)"fat_size %d [sectors]\n", fat->h_size);
#line 726
    printf((char const   */* __restrict  */)"fat_bit %d\n", fat->info.fat_bit);
#line 727
    printf((char const   */* __restrict  */)"fat_sectorpercluster %d\n", fat->info.cluster_size);
    }
  }
#line 730
  if (file_mbr) {
    {
#line 731
    part_setup(mbr, part_entry, fat->info.fat_bit, fat->h_pos, fat->h_size, (struct disk_geometry  const  *)(& h->geometry));
    }
#line 733
    if (mbrfat) {
      {
#line 737
      tmp___13 = disk_read(fat->h, fat->h_pos, (void *)(boot), 1U);
      }
#line 737
      if (tmp___13 != 0) {
#line 738
        return (-1);
      }
      {
#line 741
      r = part_fat_setup(mbr, (unsigned char const   *)(boot), fat->info.fat_bit,
                         fat->h_pos);
      }
#line 742
      if (r != 0) {
#line 743
        goto err_invalidate;
      }
    }
    {
#line 747
    tmp___14 = disk_write(h, 0U, (void const   *)(mbr), 1U);
    }
#line 747
    if (tmp___14 != 0) {
#line 748
      goto err_invalidate;
    }
  }
#line 751
  if (verbose) {
#line 752
    h->ope_callback = & verbose_callback;
#line 753
    h->ope_context = (void *)(& verbose_context);
  }
#line 756
  s = copy_list;
  {
#line 757
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 757
    if (! s) {
#line 757
      goto while_break___0;
    }
    {
#line 762
    r = fatboot_copytoroot(fat, (char const   *)s->path, & root_cluster, & root_size,
                           force_time);
    }
#line 763
    if (r != 0) {
#line 764
      goto err_invalidate;
    }
#line 767
    if (syslinux3) {
      {
#line 768
      tmp___15 = strlen((char const   *)s->path);
#line 768
      l = (unsigned int )tmp___15;
      }
#line 769
      if (l >= 11U) {
        {
#line 769
        tmp___16 = strcmp("ldlinux.sys", (char const   *)((s->path + l) - 11));
        }
#line 769
        if (tmp___16 == 0) {
#line 770
          if (syslinux3_sector_mac != 0) {
            {
#line 771
            error_set("Multiple ldlinux.sys.");
            }
#line 772
            goto err_invalidate;
          }
          {
#line 774
          syslinux3_size = root_size;
#line 775
          syslinux3_sector_mac = fat_sector_chain(fat, root_cluster, syslinux3_sector_map,
                                                  syslinux3_sector_max);
          }
        }
      }
    }
#line 779
    s = s->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 782
  r = fatboot_copy(fat, 0U, (char const   *)*(argv + optind), exclude_list, force_time);
  }
#line 783
  if (r != 0) {
#line 784
    goto err_invalidate;
  }
#line 786
  if (syslinux3) {
#line 787
    if (syslinux3_sector_mac == 0) {
      {
#line 788
      error_set("Missing ldlinux.sys.");
      }
#line 789
      goto err_invalidate;
    }
#line 791
    if (syslinux3_sector_mac < 0) {
      {
#line 792
      error_set("Invalid ldlinux.sys. Too big.");
      }
#line 793
      goto err_invalidate;
    }
    {
#line 795
    tmp___17 = fatboot_syslinux3(fat, syslinux3_sector_map, (unsigned int )syslinux3_sector_mac,
                                 syslinux3_size);
    }
#line 795
    if (tmp___17 != 0) {
#line 796
      goto err_invalidate;
    }
  }
  {
#line 800
  r = fat_close(fat);
  }
#line 801
  if (r != 0) {
#line 802
    goto err_invalidate;
  }
#line 804
  if (verbose) {
    {
#line 805
    h->ope_callback = (void (*)(void *context , int operation , unsigned int pos ,
                                unsigned int size ))0;
#line 806
    h->ope_context = (void *)0;
#line 807
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 810
  r = disk_close(h);
  }
#line 811
  if (r != 0) {
#line 812
    goto err_msg;
  }
  {
#line 814
  string_destroy(exclude_list);
#line 815
  string_destroy(copy_list);
  }
#line 817
  return (0);
  err_invalidate: 
  {
#line 820
  memset((void *)(mbr), 0, (size_t )512);
#line 821
  disk_write(h, 0U, (void const   *)(mbr), 1U);
#line 822
  disk_close(h);
  }
  err_msg: 
  {
#line 824
  tmp___18 = error_get();
#line 824
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp___18);
#line 825
  exit(1);
  }
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 972
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 58 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
unsigned int le_uint16_read(void const   *ptr ) 
{ 
  unsigned char const   *ptr8 ;

  {
#line 60
  ptr8 = (unsigned char const   *)ptr;
#line 61
  return ((unsigned int )*(ptr8 + 0) | ((unsigned int )*(ptr8 + 1) << 8));
}
}
#line 64 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
unsigned int le_uint32_read(void const   *ptr ) 
{ 
  unsigned char const   *ptr8 ;

  {
#line 66
  ptr8 = (unsigned char const   *)ptr;
#line 67
  return ((((unsigned int )*(ptr8 + 0) | ((unsigned int )*(ptr8 + 1) << 8)) | ((unsigned int )*(ptr8 + 2) << 16)) | ((unsigned int )*(ptr8 + 3) << 24));
}
}
#line 70 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
void le_uint16_write(void *ptr , unsigned int v ) 
{ 
  unsigned char *ptr8 ;

  {
#line 72
  ptr8 = (unsigned char *)ptr;
#line 73
  *(ptr8 + 0) = (unsigned char )(v & 255U);
#line 74
  *(ptr8 + 1) = (unsigned char )((v >> 8) & 255U);
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
void le_uint32_write(void *ptr , unsigned int v ) 
{ 
  unsigned char *ptr8 ;

  {
#line 79
  ptr8 = (unsigned char *)ptr;
#line 80
  *(ptr8 + 0) = (unsigned char )(v & 255U);
#line 81
  *(ptr8 + 1) = (unsigned char )((v >> 8) & 255U);
#line 82
  *(ptr8 + 2) = (unsigned char )((v >> 16) & 255U);
#line 83
  *(ptr8 + 3) = (unsigned char )((v >> 24) & 255U);
#line 84
  return;
}
}
#line 580 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int os_usbmassstorage(char const   *dev , int *host , int *channel , int *id ,
                             int *lun ) 
{ 
  int r ;
  int h ;
  char hostname[64] ;
  int idlun[2] ;
  int bus_number ;
  char buf[512] ;
  char *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 588
  h = open(dev, 2048);
  }
#line 589
  if (h < 0) {
#line 590
    goto err;
  }
  {
#line 593
  *((int *)(hostname)) = 63;
#line 594
  r = ioctl(h, 21381UL, hostname);
  }
#line 595
  if (r < 0) {
#line 596
    goto err_close;
  }
  {
#line 600
  tmp = strstr((char const   *)(hostname), "USB Mass Storage");
  }
#line 600
  if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 601
    goto err_close;
  }
  {
#line 604
  r = ioctl(h, 21378UL, & idlun);
  }
#line 605
  if (r < 0) {
#line 606
    goto err_close;
  }
#line 609
  *channel = (idlun[0] >> 16) & 255;
#line 610
  *lun = (idlun[0] >> 8) & 255;
#line 611
  *id = idlun[0] & 255;
#line 614
  if (*lun != 0) {
#line 615
    goto err_close;
  }
  {
#line 618
  r = ioctl(h, 21382UL, & bus_number);
  }
#line 619
  if (r < 0) {
#line 620
    goto err_close;
  }
  {
#line 623
  *host = bus_number;
#line 626
  tmp___0 = read(h, (void *)(buf), (size_t )512);
#line 626
  r = (int )tmp___0;
  }
#line 627
  if (r != 512) {
#line 628
    goto err_close;
  }
#line 631
  return (0);
  err_close: 
  {
#line 634
  close(h);
  }
  err: 
#line 636
  return (-1);
}
}
#line 644 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int os_checkmount(char const   *dev ) 
{ 
  FILE *f ;
  struct mntent *m ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 649
  f = setmntent("/etc/mtab", "r");
  }
#line 650
  if (! f) {
    {
#line 651
    tmp = __errno_location();
#line 651
    tmp___0 = strerror(*tmp);
#line 651
    error_set("Error accessing /etc/mtab. %s.", tmp___0);
    }
#line 652
    return (-1);
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 655
    m = getmntent(f);
    }
#line 655
    if (! ((unsigned long )m != (unsigned long )((struct mntent *)0))) {
#line 655
      goto while_break;
    }
    {
#line 656
    tmp___1 = strlen(dev);
#line 656
    tmp___2 = strncmp((char const   *)m->mnt_fsname, dev, tmp___1);
    }
#line 656
    if (tmp___2 == 0) {
      {
#line 657
      error_set("You cannot operate on device %s because is mounted as %s.", m->mnt_fsname,
                m->mnt_dir);
      }
#line 658
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 662
  endmntent(f);
  }
#line 664
  return (0);
}
}
#line 668 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static struct disk_handle *os_open(char const   *dev ) 
{ 
  off_t o ;
  struct hd_geometry hg ;
  struct floppy_struct fg ;
  struct disk_handle *h ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 675
  tmp = malloc(sizeof(struct disk_handle ));
#line 675
  h = (struct disk_handle *)tmp;
  }
#line 676
  if (! h) {
    {
#line 677
    error_set("Low memory.");
    }
#line 678
    goto err;
  }
  {
#line 681
  h->ope_callback = (void (*)(void *context , int operation , unsigned int pos , unsigned int size ))0;
#line 682
  h->ope_context = (void *)0;
#line 684
  memset((void *)(h->device), 0, sizeof(h->device));
#line 685
  strncpy((char */* __restrict  */)(h->device), (char const   */* __restrict  */)dev,
          sizeof(h->device) - 1UL);
#line 688
  tmp___0 = os_checkmount((char const   *)(h->device));
  }
#line 688
  if (tmp___0 != 0) {
#line 689
    goto err_free;
  }
  {
#line 693
  h->handle = open((char const   *)(h->device), 2);
  }
#line 694
  if (h->handle == -1) {
    {
#line 695
    tmp___1 = __errno_location();
#line 695
    tmp___2 = strerror(*tmp___1);
#line 695
    error_set("Error opening the device %s. %s.", h->device, tmp___2);
    }
#line 696
    goto err_free;
  }
  {
#line 699
  o = lseek(h->handle, (__off_t )0, 2);
  }
#line 700
  if (o == -1L) {
    {
#line 701
    tmp___3 = __errno_location();
#line 701
    tmp___4 = strerror(*tmp___3);
#line 701
    error_set("Error seeking the device %s. %s.", h->device, tmp___4);
    }
#line 702
    goto err_close;
  }
#line 705
  if (o == 0L) {
    {
#line 706
    error_set("Invalid device size.");
    }
#line 707
    goto err_close;
  } else
#line 705
  if (o % 512L != 0L) {
    {
#line 706
    error_set("Invalid device size.");
    }
#line 707
    goto err_close;
  }
  {
#line 710
  h->geometry.size = (unsigned int )(o / 512L);
#line 712
  memset((void *)(& hg), 0, sizeof(hg));
#line 713
  memset((void *)(& fg), 0, sizeof(fg));
#line 715
  tmp___6 = ioctl(h->handle, 769UL, & hg);
  }
#line 715
  if (tmp___6 >= 0) {
#line 716
    h->geometry.start = (unsigned int )hg.start;
#line 717
    h->geometry.sectors = (unsigned int )hg.sectors;
#line 718
    h->geometry.heads = (unsigned int )hg.heads;
#line 719
    h->geometry.cylinders = (unsigned int )hg.cylinders;
#line 720
    h->geometry.drive = (unsigned char)128;
  } else {
    {
#line 721
    tmp___5 = ioctl(h->handle, (unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 4U) | (sizeof(struct floppy_struct ) << 16),
                    & fg);
    }
#line 721
    if (tmp___5 >= 0) {
#line 722
      h->geometry.start = 0U;
#line 723
      h->geometry.sectors = fg.sect;
#line 724
      h->geometry.heads = fg.head;
#line 725
      h->geometry.cylinders = fg.track;
#line 726
      h->geometry.drive = (unsigned char)0;
    } else {
#line 728
      h->geometry.start = 0U;
#line 730
      if (h->geometry.size <= 2097152U) {
#line 732
        h->geometry.sectors = 32U;
#line 733
        h->geometry.heads = 64U;
      } else
#line 734
      if (h->geometry.size <= 8388608U) {
#line 736
        h->geometry.sectors = 32U;
#line 737
        h->geometry.heads = 256U;
      } else {
#line 740
        h->geometry.sectors = 63U;
#line 741
        h->geometry.heads = 256U;
      }
#line 744
      h->geometry.cylinders = h->geometry.size / (h->geometry.sectors * h->geometry.heads);
#line 745
      h->geometry.drive = (unsigned char)0;
#line 747
      h->geometry.size = (h->geometry.sectors * h->geometry.heads) * h->geometry.cylinders;
    }
  }
#line 750
  return (h);
  err_close: 
  {
#line 753
  close(h->handle);
  }
  err_free: 
  {
#line 755
  free((void *)h);
  }
  err: 
#line 757
  return ((struct disk_handle *)0);
}
}
#line 760 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static struct disk_handle *os_find(void) 
{ 
  int i ;
  char device[64] ;
  int count ;
  int eaccess ;
  int r ;
  char buf[64] ;
  int host ;
  int channel ;
  int id ;
  int lun ;
  int *tmp ;
  struct disk_handle *tmp___0 ;

  {
#line 768
  eaccess = 0;
#line 769
  count = 0;
#line 770
  i = 0;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (i < 16)) {
#line 770
      goto while_break;
    }
    {
#line 778
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/dev/sd%c",
            (int )((char )i) + 97);
#line 780
    r = os_usbmassstorage((char const   *)(buf), & host, & channel, & id, & lun);
    }
#line 781
    if (r != 0) {
      {
#line 782
      tmp = __errno_location();
      }
#line 782
      if (*tmp == 13) {
#line 783
        eaccess = 1;
      }
#line 784
      goto __Cont;
    }
    {
#line 787
    count ++;
#line 788
    strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)(buf));
    }
    __Cont: /* CIL Label */ 
#line 770
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 791
  if (count > 1) {
    {
#line 792
    error_set("Please insert ONLY ONE usb disk.");
    }
#line 793
    return ((struct disk_handle *)0);
  }
#line 796
  if (count == 0) {
#line 797
    if (eaccess) {
      {
#line 798
      error_set("Please insert one usb disk and ensure to be root.");
      }
    } else {
      {
#line 800
      error_set("Please insert one usb disk.");
      }
    }
#line 802
    return ((struct disk_handle *)0);
  }
  {
#line 805
  tmp___0 = os_open((char const   *)(device));
  }
#line 805
  return (tmp___0);
}
}
#line 812 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int os_close(struct disk_handle *h ) 
{ 
  int r ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 816
  r = close(h->handle);
  }
#line 817
  if (r == -1) {
    {
#line 818
    tmp = __errno_location();
#line 818
    tmp___0 = strerror(*tmp);
#line 818
    error_set("Error closing the device. %s.", tmp___0);
    }
#line 819
    return (-1);
  }
  {
#line 823
  sync();
#line 825
  free((void *)h);
  }
#line 827
  return (0);
}
}
#line 830 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int os_read(struct disk_handle *h , unsigned int pos , void *data , unsigned int size ) 
{ 
  off_t o ;
  ssize_t s ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 835
  o = 512L * (off_t )pos;
#line 837
  s = pread(h->handle, data, (size_t )(size * 512U), o);
  }
#line 839
  if (s != (ssize_t )(size * 512U)) {
    {
#line 840
    tmp = __errno_location();
#line 840
    tmp___0 = strerror(*tmp);
#line 840
    error_set("Error reading the device. %s.", tmp___0);
    }
#line 841
    return (-1);
  }
#line 844
  if (h->ope_callback) {
    {
#line 845
    (*(h->ope_callback))(h->ope_context, 0, pos, size);
    }
  }
#line 847
  return (0);
}
}
#line 850 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int os_write(struct disk_handle *h , unsigned int pos , void const   *data ,
                    unsigned int size ) 
{ 
  off_t o ;
  ssize_t s ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 855
  o = 512L * (off_t )pos;
#line 857
  s = pwrite(h->handle, data, (size_t )(size * 512U), o);
  }
#line 859
  if (s != (ssize_t )(size * 512U)) {
    {
#line 860
    tmp = __errno_location();
#line 860
    tmp___0 = strerror(*tmp);
#line 860
    error_set("Error writing the device. %s.", tmp___0);
    }
#line 861
    return (-1);
  }
#line 864
  if (h->ope_callback) {
    {
#line 865
    (*(h->ope_callback))(h->ope_context, 1, pos, size);
    }
  }
#line 867
  return (0);
}
}
#line 874 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static struct disk_cache *cache_alloc(unsigned int pos , void const   *data , unsigned int size ) 
{ 
  struct disk_cache *c ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 878
  tmp = malloc(sizeof(struct disk_cache ));
#line 878
  c = (struct disk_cache *)tmp;
  }
#line 879
  if (! c) {
    {
#line 880
    error_set("Low memory.");
    }
#line 881
    return ((struct disk_cache *)0);
  }
  {
#line 884
  c->pos = pos;
#line 885
  c->size = size;
#line 886
  tmp___0 = malloc((size_t )(size * 512U));
#line 886
  c->data = (unsigned char *)tmp___0;
  }
#line 887
  if (! c->data) {
    {
#line 888
    free((void *)c);
#line 889
    error_set("Low memory.");
    }
#line 890
    return ((struct disk_cache *)0);
  }
  {
#line 893
  memcpy((void */* __restrict  */)c->data, (void const   */* __restrict  */)data,
         (size_t )(size * 512U));
  }
#line 895
  return (c);
}
}
#line 898 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static void cache_free(struct disk_cache *c ) 
{ 


  {
  {
#line 900
  free((void *)c->data);
#line 901
  free((void *)c);
  }
#line 902
  return;
}
}
#line 904 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int cache_flush(struct disk_handle *h ) 
{ 
  unsigned char *buf ;
  struct disk_cache *c ;
  int r ;
  void *tmp ;
  struct disk_cache *n ;

  {
#line 910
  if (! h->cache_list) {
#line 911
    return (0);
  }
  {
#line 913
  tmp = malloc((size_t )((h->cache_end - h->cache_begin) * 512U));
#line 913
  buf = (unsigned char *)tmp;
  }
#line 914
  if (! buf) {
    {
#line 915
    error_set("Low memory.");
    }
#line 916
    return (-1);
  }
#line 919
  c = h->cache_list;
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 920
    if (! c) {
#line 920
      goto while_break;
    }
    {
#line 923
    memcpy((void */* __restrict  */)(buf + (c->pos - h->cache_begin) * 512U), (void const   */* __restrict  */)c->data,
           (size_t )(c->size * 512U));
#line 925
    n = c->next;
#line 926
    cache_free(c);
#line 927
    c = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 930
  h->cache_list = (struct disk_cache *)0;
#line 932
  r = os_write(h, h->cache_begin, (void const   *)buf, h->cache_end - h->cache_begin);
  }
#line 933
  if (r != 0) {
    {
#line 934
    free((void *)buf);
    }
#line 935
    return (-1);
  }
  {
#line 938
  free((void *)buf);
  }
#line 940
  return (0);
}
}
#line 943 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int cache_is_overlap(struct disk_handle *h , unsigned int pos , unsigned int size ) 
{ 


  {
#line 945
  if (! h->cache_list) {
#line 948
    return (0);
  } else
#line 945
  if (pos + size <= h->cache_begin) {
#line 948
    return (0);
  } else
#line 945
  if (pos >= h->cache_end) {
#line 948
    return (0);
  } else {
#line 950
    return (1);
  }
}
}
#line 953 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
static int cache_is_end(struct disk_handle *h , unsigned int pos , unsigned int size ) 
{ 
  int tmp ;

  {
#line 955
  if (h->cache_list) {
#line 955
    if (pos == h->cache_end) {
#line 955
      if (h->cache_end - h->cache_begin < 2048U) {
#line 955
        tmp = 1;
      } else {
#line 955
        tmp = 0;
      }
    } else {
#line 955
      tmp = 0;
    }
  } else {
#line 955
    tmp = 0;
  }
#line 955
  return (tmp);
}
}
#line 960 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
struct disk_handle *disk_open(char const   *dev ) 
{ 
  struct disk_handle *h ;
  struct disk_handle *tmp ;

  {
  {
#line 962
  tmp = os_open(dev);
#line 962
  h = tmp;
  }
#line 963
  if (! h) {
#line 964
    return ((struct disk_handle *)0);
  }
#line 966
  h->cache_list = (struct disk_cache *)0;
#line 968
  return (h);
}
}
#line 971 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
struct disk_handle *disk_find(void) 
{ 
  struct disk_handle *h ;
  struct disk_handle *tmp ;

  {
  {
#line 973
  tmp = os_find();
#line 973
  h = tmp;
  }
#line 974
  if (! h) {
#line 975
    return ((struct disk_handle *)0);
  }
#line 977
  h->cache_list = (struct disk_cache *)0;
#line 979
  return (h);
}
}
#line 982 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
int disk_close(struct disk_handle *h ) 
{ 
  int r ;

  {
  {
#line 986
  r = cache_flush(h);
  }
#line 987
  if (r != 0) {
#line 988
    return (-1);
  }
  {
#line 990
  r = os_close(h);
  }
#line 991
  if (r != 0) {
#line 992
    return (-1);
  }
#line 994
  return (0);
}
}
#line 997 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
int disk_read(struct disk_handle *h , unsigned int pos , void *data , unsigned int size ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 999
  tmp___0 = cache_is_overlap(h, pos, size);
  }
#line 999
  if (tmp___0) {
    {
#line 1000
    tmp = cache_flush(h);
    }
#line 1000
    if (tmp != 0) {
#line 1001
      return (-1);
    }
  }
  {
#line 1004
  tmp___1 = os_read(h, pos, data, size);
  }
#line 1004
  return (tmp___1);
}
}
#line 1007 "/home/wheatley/newnew/temp/makebootfat-1.4/disk.c"
int disk_write(struct disk_handle *h , unsigned int pos , void const   *data , unsigned int size ) 
{ 
  struct disk_cache *c ;
  struct disk_cache *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1009
  tmp = cache_alloc(pos, data, size);
#line 1009
  c = tmp;
  }
#line 1010
  if (! c) {
#line 1011
    return (-1);
  }
  {
#line 1013
  tmp___0 = cache_is_end(h, pos, size);
  }
#line 1013
  if (tmp___0) {
#line 1014
    c->next = h->cache_list;
#line 1015
    h->cache_list = c;
#line 1016
    h->cache_end = pos + size;
#line 1017
    return (0);
  }
  {
#line 1020
  tmp___1 = cache_flush(h);
  }
#line 1020
  if (tmp___1 != 0) {
    {
#line 1021
    cache_free(c);
    }
#line 1022
    return (-1);
  }
#line 1025
  c->next = (struct disk_cache *)0;
#line 1026
  h->cache_list = c;
#line 1027
  h->cache_begin = pos;
#line 1028
  h->cache_end = pos + size;
#line 1030
  return (0);
}
}
