/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 773 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
struct __anonstruct_established_timings_29 {
   int x ;
   int y ;
   int refresh ;
};
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int claims_one_point_oh  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int claims_one_point_two  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int claims_one_point_three  =    0;
#line 38 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int claims_one_point_four  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int nonconformant_digital_display  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int nonconformant_extension  =    0;
#line 41 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int did_detailed_timing  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_name_descriptor  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int name_descriptor_terminated  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_range_descriptor  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_preferred_timing  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_checksum  =    1;
#line 47 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_cvt  =    1;
#line 48 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_dummy_block  =    1;
#line 49 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_week  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_year  =    0;
#line 51 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_detailed_blocks  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_extension_count  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_descriptor_ordering  =    1;
#line 54 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_descriptor_pad  =    1;
#line 55 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_range_descriptor  =    1;
#line 56 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int has_valid_max_dotclock  =    1;
#line 57 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int manufacturer_name_well_formed  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int seen_non_detailed_descriptor  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int warning_excessive_dotclock_correction  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int warning_zero_preferred_refresh  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int conformant  =    1;
#line 67 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static char name[4]  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static char *manufacturer_name(unsigned char *x ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 69
  name[0] = (char )((((int )*(x + 0) & 124) >> 2) + 64);
#line 70
  name[1] = (char )(((((int )*(x + 0) & 3) << 3) + (((int )*(x + 1) & 224) >> 5)) + 64);
#line 71
  name[2] = (char )(((int )*(x + 1) & 31) + 64);
#line 72
  name[3] = (char)0;
#line 74
  tmp = __ctype_b_loc();
  }
#line 74
  if ((int const   )*(*tmp + (int )name[0]) & 256) {
    {
#line 74
    tmp___0 = __ctype_b_loc();
    }
#line 74
    if ((int const   )*(*tmp___0 + (int )name[1]) & 256) {
      {
#line 74
      tmp___1 = __ctype_b_loc();
      }
#line 74
      if ((int const   )*(*tmp___1 + (int )name[2]) & 256) {
#line 75
        manufacturer_name_well_formed = 1;
      }
    }
  }
#line 77
  return (name);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int detailed_cvt_descriptor(unsigned char *x , int first ) 
{ 
  unsigned char empty[3] ;
  char *names[4] ;
  int width ;
  int height ;
  int valid ;
  int fifty ;
  int sixty ;
  int seventyfive ;
  int eightyfive ;
  int reduced ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 83
  empty[0] = (unsigned char)0;
#line 83
  empty[1] = (unsigned char)0;
#line 83
  empty[2] = (unsigned char)0;
#line 84
  names[0] = (char *)"50";
#line 84
  names[1] = (char *)"60";
#line 84
  names[2] = (char *)"75";
#line 84
  names[3] = (char *)"85";
#line 86
  valid = 1;
#line 87
  fifty = 0;
#line 87
  sixty = 0;
#line 87
  seventyfive = 0;
#line 87
  eightyfive = 0;
#line 87
  reduced = 0;
#line 89
  if (! first) {
    {
#line 89
    tmp = memcmp((void const   *)x, (void const   *)(empty), (size_t )3);
    }
#line 89
    if (! tmp) {
#line 90
      return (valid);
    }
  }
#line 92
  height = (int )*(x + 0);
#line 93
  height |= ((int )*(x + 1) & 240) << 4;
#line 94
  height ++;
#line 95
  height *= 2;
  {
#line 98
  if (((int )*(x + 1) & 12) == 0) {
#line 98
    goto case_0;
  }
#line 100
  if (((int )*(x + 1) & 12) == 4) {
#line 100
    goto case_4;
  }
#line 102
  if (((int )*(x + 1) & 12) == 8) {
#line 102
    goto case_8;
  }
#line 104
  if (((int )*(x + 1) & 12) == 12) {
#line 104
    goto case_12;
  }
#line 97
  goto switch_break;
  case_0: /* CIL Label */ 
#line 99
  width = (height * 4) / 3;
#line 99
  goto switch_break;
  case_4: /* CIL Label */ 
#line 101
  width = (height * 16) / 9;
#line 101
  goto switch_break;
  case_8: /* CIL Label */ 
#line 103
  width = (height * 16) / 10;
#line 103
  goto switch_break;
  case_12: /* CIL Label */ 
#line 105
  width = (height * 15) / 9;
#line 105
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 108
  if ((int )*(x + 1) & 3) {
#line 109
    valid = 0;
  }
#line 110
  if ((int )*(x + 2) & 128) {
#line 111
    valid = 0;
  }
#line 112
  if (! ((int )*(x + 2) & 31)) {
#line 113
    valid = 0;
  }
#line 115
  fifty = (int )*(x + 2) & 16;
#line 116
  sixty = (int )*(x + 2) & 8;
#line 117
  seventyfive = (int )*(x + 2) & 4;
#line 118
  eightyfive = (int )*(x + 2) & 2;
#line 119
  reduced = (int )*(x + 2) & 1;
#line 121
  if (! valid) {
    {
#line 122
    printf((char const   */* __restrict  */)"    (broken)\n");
    }
  } else {
#line 124
    if (((int )*(x + 2) & 96) == 32) {
#line 124
      if (reduced) {
#line 124
        tmp___0 = "RB";
      } else {
#line 124
        tmp___0 = "";
      }
    } else {
#line 124
      tmp___0 = "";
    }
#line 124
    if (reduced) {
#line 124
      tmp___1 = "60RB ";
    } else {
#line 124
      tmp___1 = "";
    }
#line 124
    if (eightyfive) {
#line 124
      tmp___2 = "85 ";
    } else {
#line 124
      tmp___2 = "";
    }
#line 124
    if (seventyfive) {
#line 124
      tmp___3 = "75 ";
    } else {
#line 124
      tmp___3 = "";
    }
#line 124
    if (sixty) {
#line 124
      tmp___4 = "60 ";
    } else {
#line 124
      tmp___4 = "";
    }
#line 124
    if (fifty) {
#line 124
      tmp___5 = "50 ";
    } else {
#line 124
      tmp___5 = "";
    }
    {
#line 124
    printf((char const   */* __restrict  */)"    %dx%d @ ( %s%s%s%s%s) Hz (%s%s preferred)\n",
           width, height, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, names[((int )*(x + 2) & 96) >> 5],
           tmp___0);
    }
  }
#line 134
  return (valid);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static unsigned char name___0[53]  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int detailed_block(unsigned char *x , int in_extension ) 
{ 
  int ha ;
  int hbl ;
  int hso ;
  int hspw ;
  int hborder ;
  int va ;
  int vbl ;
  int vso ;
  int vspw ;
  int vborder ;
  int i ;
  char phsync ;
  char pvsync ;
  char *syncmethod ;
  int valid_cvt ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int h_max_offset ;
  int h_min_offset ;
  int v_max_offset ;
  int v_min_offset ;
  int is_cvt ;
  int max_h_pixels ;
  int raw_offset ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 153
  if ((int )*(x + 0) == 0) {
#line 153
    if ((int )*(x + 1) == 0) {
#line 155
      if ((int )*(x + 2) != 0) {
        {
#line 157
        printf((char const   */* __restrict  */)"Monitor descriptor block has byte 2 nonzero (0x%02x)\n",
               (int )*(x + 2));
#line 159
        has_valid_descriptor_pad = 0;
        }
      }
#line 161
      if ((int )*(x + 3) != 253) {
#line 161
        if ((int )*(x + 4) != 0) {
          {
#line 163
          printf((char const   */* __restrict  */)"Monitor descriptor block has byte 4 nonzero (0x%02x)\n",
                 (int )*(x + 4));
#line 165
          has_valid_descriptor_pad = 0;
          }
        }
      }
#line 168
      seen_non_detailed_descriptor = 1;
#line 169
      if ((int )*(x + 3) <= 15) {
        {
#line 175
        printf((char const   */* __restrict  */)"Manufacturer-specified data, tag %d\n",
               (int )*(x + 3));
        }
#line 176
        return (1);
      }
      {
#line 179
      if ((int )*(x + 3) == 16) {
#line 179
        goto case_16;
      }
#line 185
      if ((int )*(x + 3) == 247) {
#line 185
        goto case_247;
      }
#line 189
      if ((int )*(x + 3) == 248) {
#line 189
        goto case_248;
      }
#line 202
      if ((int )*(x + 3) == 249) {
#line 202
        goto case_249;
      }
#line 206
      if ((int )*(x + 3) == 250) {
#line 206
        goto case_250;
      }
#line 210
      if ((int )*(x + 3) == 251) {
#line 210
        goto case_251;
      }
#line 214
      if ((int )*(x + 3) == 252) {
#line 214
        goto case_252;
      }
#line 225
      if ((int )*(x + 3) == 253) {
#line 225
        goto case_253;
      }
#line 360
      if ((int )*(x + 3) == 254) {
#line 360
        goto case_254;
      }
#line 368
      if ((int )*(x + 3) == 255) {
#line 368
        goto case_255;
      }
#line 372
      goto switch_default___1;
      case_16: /* CIL Label */ 
      {
#line 180
      printf((char const   */* __restrict  */)"Dummy block\n");
#line 181
      i = 5;
      }
      {
#line 181
      while (1) {
        while_continue: /* CIL Label */ ;
#line 181
        if (! (i < 18)) {
#line 181
          goto while_break;
        }
#line 182
        if ((int )*(x + i) != 0) {
#line 183
          has_valid_dummy_block = 0;
        }
#line 181
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 184
      return (1);
      case_247: /* CIL Label */ 
      {
#line 187
      printf((char const   */* __restrict  */)"Established timings III\n");
      }
#line 188
      return (1);
      case_248: /* CIL Label */ 
      {
#line 191
      valid_cvt = 1;
#line 192
      printf((char const   */* __restrict  */)"CVT 3-byte code descriptor:\n");
      }
#line 193
      if ((int )*(x + 5) != 1) {
#line 194
        has_valid_cvt = 0;
#line 195
        return (0);
      }
#line 197
      i = 0;
      {
#line 197
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 197
        if (! (i < 4)) {
#line 197
          goto while_break___0;
        }
        {
#line 198
        tmp = detailed_cvt_descriptor((x + 6) + i * 3, i == 0);
#line 198
        valid_cvt &= tmp;
#line 197
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 199
      has_valid_cvt &= valid_cvt;
#line 200
      return (valid_cvt);
      case_249: /* CIL Label */ 
      {
#line 204
      printf((char const   */* __restrict  */)"Color management data\n");
      }
#line 205
      return (1);
      case_250: /* CIL Label */ 
      {
#line 208
      printf((char const   */* __restrict  */)"More standard timings\n");
      }
#line 209
      return (1);
      case_251: /* CIL Label */ 
      {
#line 212
      printf((char const   */* __restrict  */)"Color point\n");
      }
#line 213
      return (1);
      case_252: /* CIL Label */ 
      {
#line 217
      has_name_descriptor = 1;
#line 218
      tmp___0 = strchr((char const   *)((char *)(name___0)), '\n');
      }
#line 218
      if (tmp___0) {
#line 218
        return (1);
      }
      {
#line 219
      strncat((char */* __restrict  */)((char *)(name___0)), (char const   */* __restrict  */)((char *)x + 5),
              (size_t )13);
#line 220
      tmp___1 = strchr((char const   *)((char *)(name___0)), '\n');
      }
#line 220
      if (tmp___1) {
        {
#line 221
        name_descriptor_terminated = 1;
#line 222
        printf((char const   */* __restrict  */)"Monitor name: %s", name___0);
        }
      }
#line 224
      return (1);
      case_253: /* CIL Label */ 
#line 227
      h_max_offset = 0;
#line 227
      h_min_offset = 0;
#line 228
      v_max_offset = 0;
#line 228
      v_min_offset = 0;
#line 229
      is_cvt = 0;
#line 230
      has_range_descriptor = 1;
#line 235
      if (claims_one_point_four) {
#line 236
        if ((int )*(x + 4) & 2) {
#line 237
          v_max_offset = 255;
#line 238
          if ((int )*(x + 4) & 1) {
#line 239
            v_min_offset = 255;
          }
        }
#line 242
        if ((int )*(x + 4) & 4) {
#line 243
          h_max_offset = 255;
#line 244
          if ((int )*(x + 4) & 3) {
#line 245
            h_min_offset = 255;
          }
        }
      } else
#line 248
      if (*(x + 4)) {
#line 249
        has_valid_range_descriptor = 0;
      }
      {
#line 257
      if ((int )*(x + 10) == 0) {
#line 257
        goto case_0;
      }
#line 259
      if ((int )*(x + 10) == 1) {
#line 259
        goto case_1;
      }
#line 261
      if ((int )*(x + 10) == 2) {
#line 261
        goto case_2;
      }
#line 263
      if ((int )*(x + 10) == 4) {
#line 263
        goto case_4;
      }
#line 266
      goto switch_default;
      case_0: /* CIL Label */ 
#line 258
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 260
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 262
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 264
      is_cvt = 1;
#line 265
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 267
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 270
      if ((int )*(x + 5) + v_min_offset > (int )*(x + 6) + v_max_offset) {
#line 271
        has_valid_range_descriptor = 0;
      }
#line 272
      if ((int )*(x + 7) + h_min_offset > (int )*(x + 8) + h_max_offset) {
#line 273
        has_valid_range_descriptor = 0;
      }
      {
#line 274
      printf((char const   */* __restrict  */)"Monitor ranges: %d-%dHZ vertical, %d-%dkHz horizontal",
             (int )*(x + 5) + v_min_offset, (int )*(x + 6) + v_max_offset, (int )*(x + 7) + h_min_offset,
             (int )*(x + 8) + h_max_offset);
      }
#line 277
      if (*(x + 9)) {
        {
#line 278
        printf((char const   */* __restrict  */)", max dotclock %dMHz\n", (int )*(x + 9) * 10);
        }
      } else {
#line 280
        if (claims_one_point_four) {
#line 281
          has_valid_max_dotclock = 0;
        }
        {
#line 282
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 285
      if (is_cvt) {
        {
#line 286
        max_h_pixels = 0;
#line 288
        printf((char const   */* __restrict  */)"CVT version %d.%d\n", (int )*(x + 11) & (240 >> 4),
               (int )*(x + 11) & 15);
        }
#line 290
        if ((int )*(x + 12) & 252) {
          {
#line 291
          raw_offset = ((int )*(x + 12) & 252) >> 2;
#line 292
          printf((char const   */* __restrict  */)"Real max dotclock: %.2fMHz\n",
                 (double )((int )*(x + 9) * 10) - (double )raw_offset * 0.25);
          }
#line 294
          if (raw_offset >= 40) {
#line 295
            warning_excessive_dotclock_correction = 1;
          }
        }
#line 298
        max_h_pixels = (int )*(x + 12) & 3;
#line 299
        max_h_pixels <<= 8;
#line 300
        max_h_pixels |= (int )*(x + 13);
#line 301
        max_h_pixels *= 8;
#line 302
        if (max_h_pixels) {
          {
#line 303
          printf((char const   */* __restrict  */)"Max active pixels per line: %d\n",
                 max_h_pixels);
          }
        }
#line 305
        if ((int )*(x + 14) & 8) {
#line 305
          tmp___2 = "15:9";
        } else {
#line 305
          tmp___2 = "";
        }
#line 305
        if ((int )*(x + 14) & 16) {
#line 305
          tmp___3 = "5:4";
        } else {
#line 305
          tmp___3 = "";
        }
#line 305
        if ((int )*(x + 14) & 32) {
#line 305
          tmp___4 = "16:10";
        } else {
#line 305
          tmp___4 = "";
        }
#line 305
        if ((int )*(x + 14) & 64) {
#line 305
          tmp___5 = "16:9";
        } else {
#line 305
          tmp___5 = "";
        }
#line 305
        if ((int )*(x + 14) & 128) {
#line 305
          tmp___6 = "4:3";
        } else {
#line 305
          tmp___6 = "";
        }
        {
#line 305
        printf((char const   */* __restrict  */)"Supported aspect ratios: %s %s %s %s %s\n",
               tmp___6, tmp___5, tmp___4, tmp___3, tmp___2);
        }
#line 311
        if ((int )*(x + 14) & 7) {
#line 312
          has_valid_range_descriptor = 0;
        }
        {
#line 314
        printf((char const   */* __restrict  */)"Preferred aspect ratio: ");
        }
        {
#line 316
        if (((int )*(x + 15) & 224) >> 5 == 0) {
#line 316
          goto case_0___0;
        }
#line 317
        if (((int )*(x + 15) & 224) >> 5 == 1) {
#line 317
          goto case_1___0;
        }
#line 318
        if (((int )*(x + 15) & 224) >> 5 == 2) {
#line 318
          goto case_2___0;
        }
#line 319
        if (((int )*(x + 15) & 224) >> 5 == 3) {
#line 319
          goto case_3;
        }
#line 320
        if (((int )*(x + 15) & 224) >> 5 == 4) {
#line 320
          goto case_4___0;
        }
#line 321
        goto switch_default___0;
        case_0___0: /* CIL Label */ 
        {
#line 316
        printf((char const   */* __restrict  */)"4:3");
        }
#line 316
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
        {
#line 317
        printf((char const   */* __restrict  */)"16:9");
        }
#line 317
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
        {
#line 318
        printf((char const   */* __restrict  */)"16:10");
        }
#line 318
        goto switch_break___1;
        case_3: /* CIL Label */ 
        {
#line 319
        printf((char const   */* __restrict  */)"5:4");
        }
#line 319
        goto switch_break___1;
        case_4___0: /* CIL Label */ 
        {
#line 320
        printf((char const   */* __restrict  */)"15:9");
        }
#line 320
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
#line 321
        printf((char const   */* __restrict  */)"(broken)");
        }
#line 321
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
        {
#line 323
        printf((char const   */* __restrict  */)"\n");
        }
#line 325
        if ((int )*(x + 15) & 4) {
          {
#line 326
          printf((char const   */* __restrict  */)"Supports CVT standard blanking\n");
          }
        }
#line 327
        if ((int )*(x + 15) & 16) {
          {
#line 328
          printf((char const   */* __restrict  */)"Supports CVT reduced blanking\n");
          }
        }
#line 330
        if ((int )*(x + 15) & 7) {
#line 331
          has_valid_range_descriptor = 0;
        }
#line 333
        if ((int )*(x + 16) & 240) {
          {
#line 334
          printf((char const   */* __restrict  */)"Supported display scaling:\n");
          }
#line 335
          if ((int )*(x + 16) & 128) {
            {
#line 336
            printf((char const   */* __restrict  */)"    Horizontal shrink\n");
            }
          }
#line 337
          if ((int )*(x + 16) & 64) {
            {
#line 338
            printf((char const   */* __restrict  */)"    Horizontal stretch\n");
            }
          }
#line 339
          if ((int )*(x + 16) & 32) {
            {
#line 340
            printf((char const   */* __restrict  */)"    Vertical shrink\n");
            }
          }
#line 341
          if ((int )*(x + 16) & 16) {
            {
#line 342
            printf((char const   */* __restrict  */)"    Vertical stretch\n");
            }
          }
        }
#line 345
        if ((int )*(x + 16) & 15) {
#line 346
          has_valid_range_descriptor = 0;
        }
#line 348
        if (*(x + 17)) {
          {
#line 349
          printf((char const   */* __restrict  */)"Preferred vertical refresh: %d Hz\n",
                 (int )*(x + 17));
          }
        } else {
#line 351
          warning_zero_preferred_refresh = 1;
        }
      }
#line 358
      return (has_valid_range_descriptor);
      case_254: /* CIL Label */ 
      {
#line 366
      printf((char const   */* __restrict  */)"ASCII string: %s", x + 5);
      }
#line 367
      return (1);
      case_255: /* CIL Label */ 
      {
#line 370
      printf((char const   */* __restrict  */)"Serial number: %s", x + 5);
      }
#line 371
      return (1);
      switch_default___1: /* CIL Label */ 
      {
#line 373
      printf((char const   */* __restrict  */)"Unknown monitor description type %d\n",
             (int )*(x + 3));
      }
#line 374
      return (0);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 378
  if (seen_non_detailed_descriptor) {
#line 378
    if (! in_extension) {
#line 379
      has_valid_descriptor_ordering = 0;
    }
  }
#line 382
  did_detailed_timing = 1;
#line 383
  ha = (int )*(x + 2) + (((int )*(x + 4) & 240) << 4);
#line 384
  hbl = (int )*(x + 3) + (((int )*(x + 4) & 15) << 8);
#line 385
  hso = (int )*(x + 8) + (((int )*(x + 11) & 192) << 2);
#line 386
  hspw = (int )*(x + 9) + (((int )*(x + 11) & 48) << 4);
#line 387
  hborder = (int )*(x + 15);
#line 388
  va = (int )*(x + 5) + (((int )*(x + 7) & 240) << 4);
#line 389
  vbl = (int )*(x + 6) + (((int )*(x + 7) & 15) << 8);
#line 390
  vso = ((int )*(x + 10) >> 4) + (((int )*(x + 11) & 12) << 2);
#line 391
  vspw = ((int )*(x + 10) & 15) + (((int )*(x + 11) & 3) << 4);
#line 392
  vborder = (int )*(x + 16);
  {
#line 394
  if (((int )*(x + 17) & 24) >> 3 == 0) {
#line 394
    goto case_0___1;
  }
#line 397
  if (((int )*(x + 17) & 24) >> 3 == 1) {
#line 397
    goto case_1___1;
  }
#line 400
  if (((int )*(x + 17) & 24) >> 3 == 2) {
#line 400
    goto case_2___1;
  }
#line 403
  if (((int )*(x + 17) & 24) >> 3 == 3) {
#line 403
    goto case_3___0;
  }
#line 393
  goto switch_break___2;
  case_0___1: /* CIL Label */ 
#line 395
  syncmethod = (char *)" analog composite";
#line 396
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
#line 398
  syncmethod = (char *)" bipolar analog composite";
#line 399
  goto switch_break___2;
  case_2___1: /* CIL Label */ 
#line 401
  syncmethod = (char *)" digital composite";
#line 402
  goto switch_break___2;
  case_3___0: /* CIL Label */ 
#line 404
  syncmethod = (char *)"";
#line 405
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 407
  if ((int )*(x + 17) & (1 << 2)) {
#line 407
    pvsync = (char )'+';
  } else {
#line 407
    pvsync = (char )'-';
  }
#line 408
  if ((int )*(x + 17) & (1 << 1)) {
#line 408
    phsync = (char )'+';
  } else {
#line 408
    phsync = (char )'-';
  }
#line 410
  if ((int )*(x + 17) & 128) {
#line 410
    tmp___7 = " interlaced";
  } else {
#line 410
    tmp___7 = "";
  }
  {
#line 410
  printf((char const   */* __restrict  */)"Detailed mode: Clock %.3f MHz, %d mm x %d mm\n               %4d %4d %4d %4d hborder %d\n               %4d %4d %4d %4d vborder %d\n               %chsync %cvsync%s%s\n",
         (double )((int )*(x + 0) + ((int )*(x + 1) << 8)) / 100.0, (int )*(x + 12) + (((int )*(x + 14) & 240) << 4),
         (int )*(x + 13) + (((int )*(x + 14) & 15) << 8), ha, ha + hso, (ha + hso) + hspw,
         ha + hbl, hborder, va, va + vso, (va + vso) + vspw, va + vbl, vborder, (int )phsync,
         (int )pvsync, syncmethod, tmp___7);
  }
#line 423
  return (1);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void do_checksum(unsigned char *x ) 
{ 
  unsigned char sum ;
  int i ;

  {
  {
#line 429
  printf((char const   */* __restrict  */)"Checksum: 0x%hx", (int )*(x + 127));
#line 431
  sum = (unsigned char)0;
#line 433
  i = 0;
  }
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (i < 128)) {
#line 433
      goto while_break;
    }
#line 434
    sum = (unsigned char )((int )sum + (int )*(x + i));
#line 433
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if (sum) {
    {
#line 436
    printf((char const   */* __restrict  */)" (should be 0x%hx)", (int )((unsigned char )((int )*(x + 127) - (int )sum)));
#line 437
    has_valid_checksum = 0;
    }
  }
  {
#line 440
  printf((char const   */* __restrict  */)"\n");
  }
#line 441
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void cea_video_block(unsigned char *x ) 
{ 
  int i ;
  int length ;
  char const   *tmp ;

  {
#line 449
  length = (int )*(x + 0) & 31;
#line 451
  i = 1;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (i < length)) {
#line 451
      goto while_break;
    }
#line 452
    if ((int )*(x + i) & 128) {
#line 452
      tmp = "(native)";
    } else {
#line 452
      tmp = "";
    }
    {
#line 452
    printf((char const   */* __restrict  */)"    VIC %02d %s\n", (int )*(x + i) & 127,
           tmp);
#line 451
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void cea_hdmi_block(unsigned char *x ) 
{ 
  int length ;

  {
  {
#line 458
  length = (int )*(x + 0) & 31;
#line 460
  printf((char const   */* __restrict  */)" (HDMI)\n");
#line 461
  printf((char const   */* __restrict  */)"    Source physical address %d.%d.%d.%d\n",
         (int )*(x + 4) >> 4, (int )*(x + 4) & 15, (int )*(x + 5) >> 4, (int )*(x + 5) & 15);
  }
#line 464
  if (length > 5) {
#line 465
    if ((int )*(x + 6) & 128) {
      {
#line 466
      printf((char const   */* __restrict  */)"    Supports_AI\n");
      }
    }
#line 467
    if ((int )*(x + 6) & 64) {
      {
#line 468
      printf((char const   */* __restrict  */)"    DC_48bit\n");
      }
    }
#line 469
    if ((int )*(x + 6) & 32) {
      {
#line 470
      printf((char const   */* __restrict  */)"    DC_36bit\n");
      }
    }
#line 471
    if ((int )*(x + 6) & 16) {
      {
#line 472
      printf((char const   */* __restrict  */)"    DC_30bit\n");
      }
    }
#line 473
    if ((int )*(x + 6) & 8) {
      {
#line 474
      printf((char const   */* __restrict  */)"    DC_Y444\n");
      }
    }
#line 476
    if ((int )*(x + 6) & 1) {
      {
#line 477
      printf((char const   */* __restrict  */)"    DVI_Dual\n");
      }
    }
  }
#line 480
  if (length > 6) {
    {
#line 481
    printf((char const   */* __restrict  */)"    Maximum TMDS clock: %dMHz\n", (int )*(x + 7) * 5);
    }
  }
#line 484
  return;
}
}
#line 486 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void cea_block(unsigned char *x ) 
{ 
  unsigned int oui ;
  int tag ;
  int length ;

  {
  {
#line 492
  if (((int )*(x + 0) & 224) >> 5 == 1) {
#line 492
    goto case_1;
  }
#line 495
  if (((int )*(x + 0) & 224) >> 5 == 2) {
#line 495
    goto case_2;
  }
#line 499
  if (((int )*(x + 0) & 224) >> 5 == 3) {
#line 499
    goto case_3;
  }
#line 508
  if (((int )*(x + 0) & 224) >> 5 == 4) {
#line 508
    goto case_4;
  }
#line 511
  if (((int )*(x + 0) & 224) >> 5 == 5) {
#line 511
    goto case_5;
  }
#line 514
  if (((int )*(x + 0) & 224) >> 5 == 7) {
#line 514
    goto case_7;
  }
#line 554
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 493
  printf((char const   */* __restrict  */)"  Audio data block\n");
  }
#line 494
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 496
  printf((char const   */* __restrict  */)"  Video data block\n");
#line 497
  cea_video_block(x);
  }
#line 498
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 501
  oui = (unsigned int )((((int )*(x + 3) << 16) + ((int )*(x + 2) << 8)) + (int )*(x + 1));
#line 502
  printf((char const   */* __restrict  */)"  Vendor-specific data block, OUI %06x",
         oui);
  }
#line 503
  if (oui == 3075U) {
    {
#line 504
    cea_hdmi_block(x);
    }
  } else {
    {
#line 506
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 507
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 509
  printf((char const   */* __restrict  */)"  Speaker allocation data block\n");
  }
#line 510
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 512
  printf((char const   */* __restrict  */)"  VESA DTC data block\n");
  }
#line 513
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 515
  printf((char const   */* __restrict  */)"  Extended tag: ");
  }
  {
#line 517
  if ((int )*(x + 1) == 0) {
#line 517
    goto case_0;
  }
#line 520
  if ((int )*(x + 1) == 1) {
#line 520
    goto case_1___0;
  }
#line 523
  if ((int )*(x + 1) == 2) {
#line 523
    goto case_2___0;
  }
#line 526
  if ((int )*(x + 1) == 3) {
#line 526
    goto case_3___0;
  }
#line 529
  if ((int )*(x + 1) == 4) {
#line 529
    goto case_4___0;
  }
#line 532
  if ((int )*(x + 1) == 5) {
#line 532
    goto case_5___0;
  }
#line 535
  if ((int )*(x + 1) == 16) {
#line 535
    goto case_16;
  }
#line 538
  if ((int )*(x + 1) == 17) {
#line 538
    goto case_17;
  }
#line 541
  if ((int )*(x + 1) == 18) {
#line 541
    goto case_18;
  }
#line 544
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 518
  printf((char const   */* __restrict  */)"video capability data block\n");
  }
#line 519
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 521
  printf((char const   */* __restrict  */)"vendor-specific video data block\n");
  }
#line 522
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 524
  printf((char const   */* __restrict  */)"VESA video display device information data block\n");
  }
#line 525
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 527
  printf((char const   */* __restrict  */)"VESA video data block\n");
  }
#line 528
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 530
  printf((char const   */* __restrict  */)"HDMI video data block\n");
  }
#line 531
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
  {
#line 533
  printf((char const   */* __restrict  */)"Colorimetry data block\n");
  }
#line 534
  goto switch_break___0;
  case_16: /* CIL Label */ 
  {
#line 536
  printf((char const   */* __restrict  */)"CEA miscellaneous audio fields\n");
  }
#line 537
  goto switch_break___0;
  case_17: /* CIL Label */ 
  {
#line 539
  printf((char const   */* __restrict  */)"Vendor-specific audio data block\n");
  }
#line 540
  goto switch_break___0;
  case_18: /* CIL Label */ 
  {
#line 542
  printf((char const   */* __restrict  */)"HDMI audio data block\n");
  }
#line 543
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 545
  if ((int )*(x + 1) >= 6) {
#line 545
    if ((int )*(x + 1) <= 15) {
      {
#line 546
      printf((char const   */* __restrict  */)"Reserved video block (%02x)\n", (int )*(x + 1));
      }
    } else {
#line 545
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 547
  if ((int )*(x + 1) >= 19) {
#line 547
    if ((int )*(x + 1) <= 31) {
      {
#line 548
      printf((char const   */* __restrict  */)"Reserved audio block (%02x)\n", (int )*(x + 1));
      }
    } else {
      {
#line 550
      printf((char const   */* __restrict  */)"Unknown (%02x)\n", (int )*(x + 1));
      }
    }
  } else {
    {
#line 550
    printf((char const   */* __restrict  */)"Unknown (%02x)\n", (int )*(x + 1));
    }
  }
#line 551
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 553
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 556
  tag = ((int )*x & 224) >> 5;
#line 557
  length = (int )*x & 31;
#line 558
  printf((char const   */* __restrict  */)"  Unknown tag %d, length %d (raw %02x)\n",
         tag, length, (int )*x);
  }
#line 559
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 562
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int parse_cea(unsigned char *x ) 
{ 
  int ret ;
  int version ;
  int offset ;
  unsigned char *detailed ;
  int i ;

  {
#line 567
  ret = 0;
#line 568
  version = (int )*(x + 1);
#line 569
  offset = (int )*(x + 2);
#line 572
  if (version >= 1) {
    {
#line 572
    while (1) {
      while_continue: /* CIL Label */ ;
#line 573
      if (version == 1) {
#line 573
        if ((int )*(x + 3) != 0) {
#line 574
          ret = 1;
        }
      }
#line 576
      if (offset < 4) {
#line 577
        goto while_break;
      }
#line 579
      if (version < 3) {
        {
#line 580
        printf((char const   */* __restrict  */)"%d 8-byte timing descriptors\n",
               (offset - 4) / 8);
        }
      } else
#line 583
      if (version == 3) {
        {
#line 585
        printf((char const   */* __restrict  */)"%d bytes of CEA data\n", offset - 4);
#line 586
        i = 4;
        }
        {
#line 586
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 586
          if (! (i < offset)) {
#line 586
            goto while_break___0;
          }
          {
#line 587
          cea_block(x + i);
#line 586
          i += ((int )*(x + i) & 31) + 1;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 591
      if (version >= 2) {
#line 592
        if ((int )*(x + 3) & 128) {
          {
#line 593
          printf((char const   */* __restrict  */)"Underscans PC formats by default\n");
          }
        }
#line 594
        if ((int )*(x + 3) & 64) {
          {
#line 595
          printf((char const   */* __restrict  */)"Basic audio support\n");
          }
        }
#line 596
        if ((int )*(x + 3) & 32) {
          {
#line 597
          printf((char const   */* __restrict  */)"Supports YCbCr 4:4:4\n");
          }
        }
#line 598
        if ((int )*(x + 3) & 16) {
          {
#line 599
          printf((char const   */* __restrict  */)"Supports YCbCr 4:2:2\n");
          }
        }
        {
#line 600
        printf((char const   */* __restrict  */)"%d native detailed modes\n", (int )*(x + 3) & 15);
        }
      }
#line 603
      detailed = x + offset;
      {
#line 603
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 603
        if (! ((unsigned long )(detailed + 18) < (unsigned long )(x + 127))) {
#line 603
          goto while_break___1;
        }
#line 604
        if (*(detailed + 0)) {
          {
#line 605
          detailed_block(detailed, 1);
          }
        }
#line 603
        detailed += 18;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 572
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 608
  do_checksum(x);
  }
#line 610
  return (ret);
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void extension_version(unsigned char *x ) 
{ 


  {
  {
#line 618
  printf((char const   */* __restrict  */)"Extension version: %d\n", (int )*(x + 1));
  }
#line 619
  return;
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int parse_extension(unsigned char *x ) 
{ 
  int conformant_extension ;

  {
  {
#line 625
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 628
  if ((int )*(x + 0) == 2) {
#line 628
    goto case_2;
  }
#line 633
  if ((int )*(x + 0) == 16) {
#line 633
    goto case_16;
  }
#line 634
  if ((int )*(x + 0) == 64) {
#line 634
    goto case_64;
  }
#line 635
  if ((int )*(x + 0) == 80) {
#line 635
    goto case_80;
  }
#line 636
  if ((int )*(x + 0) == 96) {
#line 636
    goto case_96;
  }
#line 637
  if ((int )*(x + 0) == 240) {
#line 637
    goto case_240;
  }
#line 638
  if ((int )*(x + 0) == 255) {
#line 638
    goto case_255;
  }
#line 639
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 629
  printf((char const   */* __restrict  */)"CEA extension block\n");
#line 630
  extension_version(x);
#line 631
  conformant_extension = parse_cea(x);
  }
#line 632
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 633
  printf((char const   */* __restrict  */)"VTB extension block\n");
  }
#line 633
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 634
  printf((char const   */* __restrict  */)"DI extension block\n");
  }
#line 634
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 635
  printf((char const   */* __restrict  */)"LS extension block\n");
  }
#line 635
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 636
  printf((char const   */* __restrict  */)"DPVL extension block\n");
  }
#line 636
  goto switch_break;
  case_240: /* CIL Label */ 
  {
#line 637
  printf((char const   */* __restrict  */)"Block map\n");
  }
#line 637
  goto switch_break;
  case_255: /* CIL Label */ 
  {
#line 638
  printf((char const   */* __restrict  */)"Manufacturer-specific extension block\n");
  }
  switch_default: /* CIL Label */ 
  {
#line 640
  printf((char const   */* __restrict  */)"Unknown extension block\n");
  }
#line 641
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 644
  printf((char const   */* __restrict  */)"\n");
  }
#line 646
  return (conformant_extension);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static int edid_lines  =    0;
#line 651 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static unsigned char *extract_edid(int fd ) 
{ 
  char *ret ;
  char *start ;
  char *c ;
  unsigned char *out ;
  int state ;
  int lines ;
  int i ;
  int out_index ;
  int len ;
  int size ;
  void *tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  char indentation1[17] ;
  char indentation2[3] ;
  char const   *indentation ;
  unsigned char *out___0 ;
  char *s ;
  void *tmp___2 ;
  int j ;
  size_t tmp___3 ;
  char buf[3] ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  void *tmp___9 ;
  char buf___0[3] ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;

  {
  {
#line 654
  ret = (char *)((void *)0);
#line 656
  out = (unsigned char *)((void *)0);
#line 657
  state = 0;
#line 658
  lines = 0;
#line 660
  out_index = 0;
#line 663
  tmp = malloc((size_t )1024);
#line 663
  ret = (char *)tmp;
#line 664
  size = 1024;
#line 665
  len = 0;
  }
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 667
    tmp___0 = read(fd, (void *)(ret + len), (size_t )(size - len));
#line 667
    i = (int )tmp___0;
    }
#line 668
    if (i < 0) {
      {
#line 669
      free((void *)ret);
      }
#line 670
      return ((unsigned char *)0);
    }
#line 672
    if (i == 0) {
#line 673
      goto while_break;
    }
#line 674
    len += i;
#line 675
    if (len == size) {
      {
#line 676
      tmp___1 = realloc((void *)ret, (size_t )(size + 1024));
#line 676
      ret = (char *)tmp___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 680
  start = strstr((char const   *)ret, "EDID_DATA:");
  }
#line 680
  if ((unsigned long )start != (unsigned long )((void *)0)) {
    {
#line 681
    indentation1[0] = (char )' ';
#line 681
    indentation1[1] = (char )' ';
#line 681
    indentation1[2] = (char )' ';
#line 681
    indentation1[3] = (char )' ';
#line 681
    indentation1[4] = (char )' ';
#line 681
    indentation1[5] = (char )' ';
#line 681
    indentation1[6] = (char )' ';
#line 681
    indentation1[7] = (char )' ';
#line 681
    indentation1[8] = (char )' ';
#line 681
    indentation1[9] = (char )' ';
#line 681
    indentation1[10] = (char )' ';
#line 681
    indentation1[11] = (char )' ';
#line 681
    indentation1[12] = (char )' ';
#line 681
    indentation1[13] = (char )' ';
#line 681
    indentation1[14] = (char )' ';
#line 681
    indentation1[15] = (char )' ';
#line 681
    indentation1[16] = (char )'\000';
#line 682
    indentation2[0] = (char )'\t';
#line 682
    indentation2[1] = (char )'\t';
#line 682
    indentation2[2] = (char )'\000';
#line 687
    tmp___2 = malloc((size_t )128);
#line 687
    out___0 = (unsigned char *)tmp___2;
    }
#line 688
    if ((unsigned long )out___0 == (unsigned long )((void *)0)) {
#line 689
      return ((unsigned char *)((void *)0));
    }
#line 691
    i = 0;
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 691
      if (! (i < 8)) {
#line 691
        goto while_break___0;
      }
      {
#line 695
      indentation = (char const   *)(indentation1);
#line 695
      s = strstr((char const   *)start, indentation);
      }
#line 696
      if (! s) {
        {
#line 697
        indentation = (char const   *)(indentation2);
#line 697
        s = strstr((char const   *)start, indentation);
        }
      }
#line 698
      if ((unsigned long )s == (unsigned long )((void *)0)) {
        {
#line 699
        free((void *)ret);
#line 700
        free((void *)out___0);
        }
#line 701
        return ((unsigned char *)((void *)0));
      }
      {
#line 703
      tmp___3 = strlen(indentation);
#line 703
      start = s + tmp___3;
#line 705
      c = start;
#line 706
      j = 0;
      }
      {
#line 706
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 706
        if (! (j < 16)) {
#line 706
          goto while_break___1;
        }
        {
#line 709
        tmp___4 = __ctype_b_loc();
        }
#line 709
        if ((int const   )*(*tmp___4 + (int )*(c + 0)) & 4096) {
          {
#line 709
          tmp___5 = __ctype_b_loc();
          }
#line 709
          if (! ((int const   )*(*tmp___5 + (int )*(c + 1)) & 4096)) {
            {
#line 710
            free((void *)ret);
#line 711
            free((void *)out___0);
            }
#line 712
            return ((unsigned char *)((void *)0));
          }
        } else {
          {
#line 710
          free((void *)ret);
#line 711
          free((void *)out___0);
          }
#line 712
          return ((unsigned char *)((void *)0));
        }
        {
#line 714
        buf[0] = *(c + 0);
#line 715
        buf[1] = *(c + 1);
#line 716
        buf[2] = (char)0;
#line 717
        tmp___6 = out_index;
#line 717
        out_index ++;
#line 717
        tmp___7 = strtol((char const   */* __restrict  */)(buf), (char **/* __restrict  */)((void *)0),
                         16);
#line 717
        *(out___0 + tmp___6) = (unsigned char )tmp___7;
#line 718
        c += 2;
#line 706
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 691
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 722
    free((void *)ret);
    }
#line 723
    return (out___0);
  }
#line 727
  i = 0;
  {
#line 727
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 727
    if (! (i < 8)) {
#line 727
      goto while_break___2;
    }
#line 728
    if (! (((int )*(ret + i) & -128) == 0)) {
#line 729
      edid_lines = len / 16;
#line 730
      return ((unsigned char *)ret);
    }
#line 727
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 735
  start = strstr((char const   *)ret, "EDID (in hex):");
  }
#line 735
  if (! start) {
#line 736
    return ((unsigned char *)ret);
  }
  {
#line 737
  start = strstr((char const   *)start, "(II)");
  }
#line 737
  if (! start) {
#line 738
    return ((unsigned char *)ret);
  }
#line 740
  c = start;
  {
#line 740
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 740
    if (! *c) {
#line 740
      goto while_break___3;
    }
#line 741
    if (state == 0) {
      {
#line 743
      c = strstr((char const   *)c, ": \t");
      }
#line 743
      if (! c) {
#line 744
        goto while_break___3;
      }
      {
#line 746
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 746
        tmp___8 = __ctype_b_loc();
        }
#line 746
        if ((int const   )*(*tmp___8 + (int )*(c + 1)) & 4096) {
#line 746
          goto while_break___4;
        }
#line 747
        c ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 748
      state = 1;
#line 749
      lines ++;
#line 750
      tmp___9 = realloc((void *)out, (size_t )(lines * 16));
#line 750
      out = (unsigned char *)tmp___9;
      }
    } else
#line 751
    if (state == 1) {
      {
#line 754
      tmp___10 = __ctype_b_loc();
      }
#line 754
      if (! ((int const   )*(*tmp___10 + (int )*c) & 4096)) {
#line 755
        state = 0;
#line 756
        goto __Cont;
      }
      {
#line 758
      buf___0[0] = *(c + 0);
#line 759
      buf___0[1] = *(c + 1);
#line 760
      buf___0[2] = (char)0;
#line 761
      tmp___11 = out_index;
#line 761
      out_index ++;
#line 761
      tmp___12 = strtol((char const   */* __restrict  */)(buf___0), (char **/* __restrict  */)((void *)0),
                        16);
#line 761
      *(out + tmp___11) = (unsigned char )tmp___12;
#line 762
      c ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 740
    c ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 766
  edid_lines = lines;
#line 768
  free((void *)ret);
  }
#line 770
  return (out);
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static struct __anonstruct_established_timings_29  const  established_timings[17]  = 
#line 773
  {      {720, 400, 70}, 
        {720, 400, 88}, 
        {640, 480, 60}, 
        {640, 480, 67}, 
        {640, 480, 72}, 
        {640, 480, 75}, 
        {800, 600, 56}, 
        {800, 600, 60}, 
        {800, 600, 72}, 
        {800, 600, 75}, 
        {832, 624, 75}, 
        {1280, 768, 87}, 
        {1024, 768, 60}, 
        {1024, 768, 70}, 
        {1024, 768, 75}, 
        {1280, 1024, 75}, 
        {1152, 870, 75}};
#line 798 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void print_subsection(char *name___1 , unsigned char *edid , int start , int end ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 803
  printf((char const   */* __restrict  */)"%s:", name___1);
#line 804
  tmp = strlen((char const   *)name___1);
#line 804
  i = (int )tmp;
  }
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    if (! (i < 15)) {
#line 804
      goto while_break;
    }
    {
#line 805
    printf((char const   */* __restrict  */)" ");
#line 804
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  i = start;
  {
#line 806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 806
    if (! (i <= end)) {
#line 806
      goto while_break___0;
    }
    {
#line 807
    printf((char const   */* __restrict  */)" %02x", (int )*(edid + i));
#line 806
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 808
  printf((char const   */* __restrict  */)"\n");
  }
#line 809
  return;
}
}
#line 811 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
static void dump_breakdown(unsigned char *edid ) 
{ 


  {
  {
#line 813
  printf((char const   */* __restrict  */)"Extracted contents:\n");
#line 814
  print_subsection((char *)"header", edid, 0, 7);
#line 815
  print_subsection((char *)"serial number", edid, 8, 17);
#line 816
  print_subsection((char *)"version", edid, 18, 19);
#line 817
  print_subsection((char *)"basic params", edid, 20, 24);
#line 818
  print_subsection((char *)"chroma info", edid, 25, 34);
#line 819
  print_subsection((char *)"established", edid, 35, 37);
#line 820
  print_subsection((char *)"standard", edid, 38, 53);
#line 821
  print_subsection((char *)"descriptor 1", edid, 54, 71);
#line 822
  print_subsection((char *)"descriptor 2", edid, 72, 89);
#line 823
  print_subsection((char *)"descriptor 3", edid, 90, 107);
#line 824
  print_subsection((char *)"descriptor 4", edid, 108, 125);
#line 825
  print_subsection((char *)"extensions", edid, 126, 126);
#line 826
  print_subsection((char *)"checksum", edid, 127, 127);
#line 827
  printf((char const   */* __restrict  */)"\n");
  }
#line 828
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/edid-decode-0.1~git20100205.26c03c8e/edid-decode.c"
int main(int argc , char **argv ) 
{ 
  int fd ;
  unsigned char *edid ;
  unsigned char *x ;
  time_t the_time ;
  struct tm *ptm ;
  int analog ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  int conformance_mask ;
  int voltage ;
  int sync___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  uint8_t b1 ;
  uint8_t b2 ;
  unsigned int x___0 ;
  unsigned int y ;
  unsigned int refresh ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 839
  if (argc != 2) {
#line 840
    fd = 0;
  } else {
    {
#line 842
    fd = open((char const   *)*(argv + 1), 0);
    }
#line 842
    if (fd == -1) {
      {
#line 843
      perror((char const   *)*(argv + 1));
      }
#line 844
      return (1);
    }
  }
  {
#line 848
  edid = extract_edid(fd);
  }
#line 849
  if (! edid) {
    {
#line 850
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"edid extract failed\n");
    }
#line 851
    return (1);
  }
#line 853
  if (fd != 0) {
    {
#line 854
    close(fd);
    }
  }
  {
#line 856
  dump_breakdown(edid);
  }
#line 858
  if (! edid) {
    {
#line 859
    printf((char const   */* __restrict  */)"No header found\n");
    }
  } else {
    {
#line 858
    tmp = memcmp((void const   *)edid, (void const   *)"\000\377\377\377\377\377\377\000",
                 (size_t )8);
    }
#line 858
    if (tmp) {
      {
#line 859
      printf((char const   */* __restrict  */)"No header found\n");
      }
    }
  }
  {
#line 863
  tmp___0 = manufacturer_name(edid + 8);
#line 863
  printf((char const   */* __restrict  */)"Manufacturer: %s Model %x Serial Number %u\n",
         tmp___0, (int )((unsigned short )((int )*(edid + 10) + ((int )*(edid + 11) << 8))),
         (unsigned int )((((int )*(edid + 12) + ((int )*(edid + 13) << 8)) + ((int )*(edid + 14) << 16)) + ((int )*(edid + 15) << 24)));
#line 870
  time(& the_time);
#line 871
  ptm = localtime((time_t const   *)(& the_time));
  }
#line 872
  if ((int )*(edid + 16) < 55) {
#line 872
    goto _L;
  } else
#line 872
  if ((int )*(edid + 16) == 255) {
    _L: /* CIL Label */ 
#line 873
    has_valid_week = 1;
#line 874
    if ((int )*(edid + 17) > 15) {
#line 875
      if ((int )*(edid + 16) == 255) {
        {
#line 876
        has_valid_year = 1;
#line 877
        printf((char const   */* __restrict  */)"Made week %hd of model year %hd\n",
               (int )*(edid + 16), (int )*(edid + 17));
        }
      } else
#line 879
      if ((int )*(edid + 17) + 90 <= ptm->tm_year) {
        {
#line 880
        has_valid_year = 1;
#line 881
        printf((char const   */* __restrict  */)"Made week %hd of %hd\n", (int )*(edid + 16),
               (int )*(edid + 17) + 1990);
        }
      }
    }
  }
  {
#line 886
  printf((char const   */* __restrict  */)"EDID version: %hd.%hd\n", (int )*(edid + 18),
         (int )*(edid + 19));
  }
#line 887
  if ((int )*(edid + 18) == 1) {
#line 888
    if ((int )*(edid + 19) > 4) {
      {
#line 889
      printf((char const   */* __restrict  */)"Claims > 1.4, assuming 1.4 conformance\n");
#line 890
      *(edid + 19) = (unsigned char)4;
      }
    }
    {
#line 893
    if ((int )*(edid + 19) == 4) {
#line 893
      goto case_4;
    }
#line 895
    if ((int )*(edid + 19) == 3) {
#line 895
      goto case_3;
    }
#line 897
    if ((int )*(edid + 19) == 2) {
#line 897
      goto case_2;
    }
#line 899
    goto switch_default;
    case_4: /* CIL Label */ 
#line 894
    claims_one_point_four = 1;
    case_3: /* CIL Label */ 
#line 896
    claims_one_point_three = 1;
    case_2: /* CIL Label */ 
#line 898
    claims_one_point_two = 1;
    switch_default: /* CIL Label */ 
#line 900
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 902
    claims_one_point_oh = 1;
  }
#line 907
  if ((int )*(edid + 20) & 128) {
    {
#line 909
    analog = 0;
#line 910
    printf((char const   */* __restrict  */)"Digital display\n");
    }
#line 911
    if (claims_one_point_four) {
#line 912
      conformance_mask = 0;
#line 913
      if (((int )*(edid + 20) & 112) == 0) {
        {
#line 914
        printf((char const   */* __restrict  */)"Color depth is undefined\n");
        }
      } else
#line 915
      if (((int )*(edid + 20) & 112) == 112) {
#line 916
        nonconformant_digital_display = 1;
      } else {
        {
#line 918
        printf((char const   */* __restrict  */)"%d bits per primary color channel\n",
               (((int )*(edid + 20) & 112) >> 3) + 4);
        }
      }
      {
#line 922
      if (((int )*(edid + 20) & 15) == 0) {
#line 922
        goto case_0;
      }
#line 923
      if (((int )*(edid + 20) & 15) == 1) {
#line 923
        goto case_1;
      }
#line 924
      if (((int )*(edid + 20) & 15) == 2) {
#line 924
        goto case_2___0;
      }
#line 925
      if (((int )*(edid + 20) & 15) == 3) {
#line 925
        goto case_3___0;
      }
#line 926
      if (((int )*(edid + 20) & 15) == 4) {
#line 926
        goto case_4___0;
      }
#line 927
      if (((int )*(edid + 20) & 15) == 5) {
#line 927
        goto case_5;
      }
#line 928
      goto switch_default___0;
      case_0: /* CIL Label */ 
      {
#line 922
      printf((char const   */* __restrict  */)"Digital interface is not defined\n");
      }
#line 922
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 923
      printf((char const   */* __restrict  */)"DVI interface\n");
      }
#line 923
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 924
      printf((char const   */* __restrict  */)"HDMI-a interface\n");
      }
#line 924
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      {
#line 925
      printf((char const   */* __restrict  */)"HDMI-b interface\n");
      }
#line 925
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 926
      printf((char const   */* __restrict  */)"MDDI interface\n");
      }
#line 926
      goto switch_break___0;
      case_5: /* CIL Label */ 
      {
#line 927
      printf((char const   */* __restrict  */)"DisplayPort interface\n");
      }
#line 927
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 929
      nonconformant_digital_display = 1;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 931
    if (claims_one_point_two) {
#line 932
      conformance_mask = 126;
#line 933
      if ((int )*(edid + 20) & 1) {
        {
#line 934
        printf((char const   */* __restrict  */)"DFP 1.x compatible TMDS\n");
        }
      }
    } else {
#line 936
      conformance_mask = 127;
    }
#line 937
    if (! nonconformant_digital_display) {
#line 938
      nonconformant_digital_display = (int )*(edid + 20) & conformance_mask;
    }
  } else {
#line 940
    analog = 1;
#line 941
    voltage = ((int )*(edid + 20) & 96) >> 5;
#line 942
    sync___0 = (int )*(edid + 20) & 15;
#line 943
    if (voltage == 3) {
#line 943
      tmp___3 = "0.7/0.7";
    } else {
#line 943
      if (voltage == 2) {
#line 943
        tmp___2 = "1.0/0.4";
      } else {
#line 943
        if (voltage == 1) {
#line 943
          tmp___1 = "0.714/0.286";
        } else {
#line 943
          tmp___1 = "0.7/0.3";
        }
#line 943
        tmp___2 = tmp___1;
      }
#line 943
      tmp___3 = tmp___2;
    }
    {
#line 943
    printf((char const   */* __restrict  */)"Analog display, Input voltage level: %s V\n",
           tmp___3);
    }
#line 949
    if (claims_one_point_four) {
#line 950
      if ((int )*(edid + 20) & 16) {
        {
#line 951
        printf((char const   */* __restrict  */)"Blank-to-black setup/pedestal\n");
        }
      } else {
        {
#line 953
        printf((char const   */* __restrict  */)"Blank level equals black level\n");
        }
      }
    } else
#line 954
    if ((int )*(edid + 20) & 16) {
      {
#line 960
      printf((char const   */* __restrict  */)"Configurable signal levels\n");
      }
    }
#line 963
    if (sync___0 & 1) {
#line 963
      tmp___4 = "Serration ";
    } else {
#line 963
      tmp___4 = "";
    }
#line 963
    if (sync___0 & 2) {
#line 963
      tmp___5 = "SyncOnGreen ";
    } else {
#line 963
      tmp___5 = "";
    }
#line 963
    if (sync___0 & 4) {
#line 963
      tmp___6 = "Composite ";
    } else {
#line 963
      tmp___6 = "";
    }
#line 963
    if (sync___0 & 8) {
#line 963
      tmp___7 = "Separate ";
    } else {
#line 963
      tmp___7 = "";
    }
    {
#line 963
    printf((char const   */* __restrict  */)"Sync: %s%s%s%s\n", tmp___7, tmp___6,
           tmp___5, tmp___4);
    }
  }
#line 969
  if (*(edid + 21)) {
#line 969
    if (*(edid + 22)) {
      {
#line 970
      printf((char const   */* __restrict  */)"Maximum image size: %d cm x %d cm\n",
             (int )*(edid + 21), (int )*(edid + 22));
      }
    } else {
#line 969
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 971
  if (claims_one_point_four) {
#line 971
    if (*(edid + 21)) {
#line 971
      goto _L___0;
    } else
#line 971
    if (*(edid + 22)) {
      _L___0: /* CIL Label */ 
#line 972
      if (*(edid + 21)) {
        {
#line 973
        printf((char const   */* __restrict  */)"Aspect ratio is %f (landscape)\n",
               100.0 / (double )((int )*(edid + 22) + 99));
        }
      } else {
        {
#line 975
        printf((char const   */* __restrict  */)"Aspect ratio is %f (portrait)\n",
               100.0 / (double )((int )*(edid + 21) + 99));
        }
      }
    } else {
      {
#line 978
      printf((char const   */* __restrict  */)"Image size is variable\n");
      }
    }
  } else {
    {
#line 978
    printf((char const   */* __restrict  */)"Image size is variable\n");
    }
  }
#line 981
  if ((int )*(edid + 23) == 255) {
#line 982
    if (claims_one_point_four) {
      {
#line 983
      printf((char const   */* __restrict  */)"Gamma is defined in an extension block\n");
      }
    } else {
      {
#line 986
      printf((char const   */* __restrict  */)"Gamma: 1.0\n");
      }
    }
  } else {
    {
#line 987
    printf((char const   */* __restrict  */)"Gamma: %.2f\n", ((double )*(edid + 23) + 100.0) / 100.0);
    }
  }
#line 989
  if ((int )*(edid + 24) & 224) {
    {
#line 990
    printf((char const   */* __restrict  */)"DPMS levels:");
    }
#line 991
    if ((int )*(edid + 24) & 128) {
      {
#line 991
      printf((char const   */* __restrict  */)" Standby");
      }
    }
#line 992
    if ((int )*(edid + 24) & 64) {
      {
#line 992
      printf((char const   */* __restrict  */)" Suspend");
      }
    }
#line 993
    if ((int )*(edid + 24) & 32) {
      {
#line 993
      printf((char const   */* __restrict  */)" Off");
      }
    }
    {
#line 994
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 998
  if (analog) {
    {
#line 1000
    if (((int )*(edid + 24) & 24) == 0) {
#line 1000
      goto case_0___0;
    }
#line 1001
    if (((int )*(edid + 24) & 24) == 8) {
#line 1001
      goto case_8;
    }
#line 1002
    if (((int )*(edid + 24) & 24) == 16) {
#line 1002
      goto case_16;
    }
#line 1003
    if (((int )*(edid + 24) & 24) == 24) {
#line 1003
      goto case_24;
    }
#line 999
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
    {
#line 1000
    printf((char const   */* __restrict  */)"Monochrome or grayscale display\n");
    }
#line 1000
    goto switch_break___1;
    case_8: /* CIL Label */ 
    {
#line 1001
    printf((char const   */* __restrict  */)"RGB color display\n");
    }
#line 1001
    goto switch_break___1;
    case_16: /* CIL Label */ 
    {
#line 1002
    printf((char const   */* __restrict  */)"Non-RGB color display\n");
    }
#line 1002
    goto switch_break___1;
    case_24: /* CIL Label */ 
    {
#line 1003
    printf((char const   */* __restrict  */)"Undefined display color type\n");
    }
    switch_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1006
    printf((char const   */* __restrict  */)"Supported color formats: RGB 4:4:4");
    }
#line 1007
    if ((int )*(edid + 24) & 16) {
      {
#line 1008
      printf((char const   */* __restrict  */)", YCrCb 4:4:4");
      }
    }
#line 1009
    if ((int )*(edid + 24) & 8) {
      {
#line 1010
      printf((char const   */* __restrict  */)", YCrCb 4:2:2");
      }
    }
    {
#line 1011
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1014
  if ((int )*(edid + 24) & 4) {
    {
#line 1015
    printf((char const   */* __restrict  */)"Default (sRGB) color space is primary color space\n");
    }
  }
#line 1016
  if ((int )*(edid + 24) & 2) {
    {
#line 1017
    printf((char const   */* __restrict  */)"First detailed timing is preferred timing\n");
#line 1018
    has_preferred_timing = 1;
    }
  }
#line 1020
  if ((int )*(edid + 24) & 1) {
    {
#line 1021
    printf((char const   */* __restrict  */)"Supports GTF timings within operating range\n");
    }
  }
  {
#line 1025
  printf((char const   */* __restrict  */)"Established timings supported:\n");
#line 1026
  i = 0;
  }
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1026
    if (! (i < 17)) {
#line 1026
      goto while_break;
    }
#line 1027
    if ((int )*(edid + (35 + i / 8)) & (1 << (7 - i % 8))) {
      {
#line 1028
      printf((char const   */* __restrict  */)"  %dx%d@%dHz\n", established_timings[i].x,
             established_timings[i].y, established_timings[i].refresh);
      }
    }
#line 1026
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1033
  printf((char const   */* __restrict  */)"Standard timings supported:\n");
#line 1034
  i = 0;
  }
  {
#line 1034
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1034
    if (! (i < 8)) {
#line 1034
      goto while_break___0;
    }
#line 1035
    b1 = *(edid + (38 + i * 2));
#line 1035
    b2 = *(edid + ((38 + i * 2) + 1));
#line 1038
    if ((int )b1 == 1) {
#line 1038
      if ((int )b2 == 1) {
#line 1039
        goto __Cont;
      }
    }
#line 1041
    if ((int )b1 == 0) {
      {
#line 1042
      printf((char const   */* __restrict  */)"non-conformant standard timing (0 horiz)\n");
      }
#line 1043
      goto __Cont;
    }
#line 1045
    x___0 = (unsigned int )(((int )b1 + 31) * 8);
    {
#line 1047
    if ((((int )b2 >> 6) & 3) == 0) {
#line 1047
      goto case_0___1;
    }
#line 1050
    if ((((int )b2 >> 6) & 3) == 1) {
#line 1050
      goto case_1___0;
    }
#line 1053
    if ((((int )b2 >> 6) & 3) == 2) {
#line 1053
      goto case_2___1;
    }
#line 1056
    if ((((int )b2 >> 6) & 3) == 3) {
#line 1056
      goto case_3___1;
    }
#line 1046
    goto switch_break___2;
    case_0___1: /* CIL Label */ 
#line 1048
    y = (x___0 * 10U) / 16U;
#line 1049
    goto switch_break___2;
    case_1___0: /* CIL Label */ 
#line 1051
    y = (x___0 * 3U) / 4U;
#line 1052
    goto switch_break___2;
    case_2___1: /* CIL Label */ 
#line 1054
    y = (x___0 * 4U) / 5U;
#line 1055
    goto switch_break___2;
    case_3___1: /* CIL Label */ 
#line 1057
    y = (x___0 * 9U) / 15U;
#line 1058
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 1060
    refresh = (unsigned int )(60 + ((int )b2 & 63));
#line 1062
    printf((char const   */* __restrict  */)"  %dx%d@%dHz\n", x___0, y, refresh);
    }
    __Cont: /* CIL Label */ 
#line 1034
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1066
  has_valid_detailed_blocks = detailed_block(edid + 54, 0);
  }
#line 1067
  if (has_preferred_timing) {
#line 1067
    if (! did_detailed_timing) {
#line 1068
      has_preferred_timing = 0;
    }
  }
  {
#line 1069
  tmp___8 = detailed_block(edid + 72, 0);
#line 1069
  has_valid_detailed_blocks &= tmp___8;
#line 1070
  tmp___9 = detailed_block(edid + 90, 0);
#line 1070
  has_valid_detailed_blocks &= tmp___9;
#line 1071
  tmp___10 = detailed_block(edid + 108, 0);
#line 1071
  has_valid_detailed_blocks &= tmp___10;
  }
#line 1074
  if (*(edid + 126)) {
    {
#line 1075
    printf((char const   */* __restrict  */)"Has %d extension blocks\n", (int )*(edid + 126));
    }
#line 1077
    if ((int )*(edid + 126) != 2) {
#line 1078
      has_valid_extension_count = 1;
    }
  } else {
#line 1080
    has_valid_extension_count = 1;
  }
  {
#line 1083
  do_checksum(edid);
#line 1085
  x = edid;
#line 1086
  edid_lines /= 8;
  }
  {
#line 1086
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1086
    if (! (edid_lines > 1)) {
#line 1086
      goto while_break___1;
    }
    {
#line 1087
    x += 128;
#line 1088
    tmp___11 = parse_extension(x);
#line 1088
    nonconformant_digital_display += tmp___11;
#line 1086
    edid_lines --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1091
  if (claims_one_point_three) {
#line 1092
    if (nonconformant_digital_display) {
#line 1098
      conformant = 0;
    } else
#line 1092
    if (! has_valid_descriptor_pad) {
#line 1098
      conformant = 0;
    } else
#line 1092
    if (! has_name_descriptor) {
#line 1098
      conformant = 0;
    } else
#line 1092
    if (! name_descriptor_terminated) {
#line 1098
      conformant = 0;
    } else
#line 1092
    if (! has_preferred_timing) {
#line 1098
      conformant = 0;
    } else
#line 1092
    if (! has_range_descriptor) {
#line 1098
      conformant = 0;
    }
#line 1099
    if (! conformant) {
      {
#line 1100
      printf((char const   */* __restrict  */)"EDID block does NOT conform to EDID 1.3!\n");
      }
    }
#line 1101
    if (nonconformant_digital_display) {
      {
#line 1102
      printf((char const   */* __restrict  */)"\tDigital display field contains garbage: %x\n",
             nonconformant_digital_display);
      }
    }
#line 1104
    if (! has_name_descriptor) {
      {
#line 1105
      printf((char const   */* __restrict  */)"\tMissing name descriptor\n");
      }
    } else
#line 1106
    if (! name_descriptor_terminated) {
      {
#line 1107
      printf((char const   */* __restrict  */)"\tName descriptor not terminated with a newline\n");
      }
    }
#line 1108
    if (! has_preferred_timing) {
      {
#line 1109
      printf((char const   */* __restrict  */)"\tMissing preferred timing\n");
      }
    }
#line 1110
    if (! has_range_descriptor) {
      {
#line 1111
      printf((char const   */* __restrict  */)"\tMissing monitor ranges\n");
      }
    }
#line 1112
    if (! has_valid_descriptor_pad) {
      {
#line 1113
      printf((char const   */* __restrict  */)"\tInvalid descriptor block padding\n");
      }
    }
  } else
#line 1114
  if (claims_one_point_two) {
#line 1115
    if (nonconformant_digital_display) {
#line 1117
      conformant = 0;
    } else
#line 1115
    if (has_name_descriptor) {
#line 1115
      if (! name_descriptor_terminated) {
#line 1117
        conformant = 0;
      }
    }
#line 1118
    if (! conformant) {
      {
#line 1119
      printf((char const   */* __restrict  */)"EDID block does NOT conform to EDID 1.2!\n");
      }
    }
#line 1120
    if (nonconformant_digital_display) {
      {
#line 1121
      printf((char const   */* __restrict  */)"\tDigital display field contains garbage: %x\n",
             nonconformant_digital_display);
      }
    }
#line 1123
    if (has_name_descriptor) {
#line 1123
      if (! name_descriptor_terminated) {
        {
#line 1124
        printf((char const   */* __restrict  */)"\tName descriptor not terminated with a newline\n");
        }
      }
    }
  } else
#line 1125
  if (claims_one_point_oh) {
#line 1126
    if (seen_non_detailed_descriptor) {
#line 1127
      conformant = 0;
    }
#line 1128
    if (! conformant) {
      {
#line 1129
      printf((char const   */* __restrict  */)"EDID block does NOT conform to EDID 1.0!\n");
      }
    }
#line 1130
    if (seen_non_detailed_descriptor) {
      {
#line 1131
      printf((char const   */* __restrict  */)"\tHas descriptor blocks other than detailed timings\n");
      }
    }
  }
#line 1134
  if (nonconformant_extension) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_checksum) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_cvt) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_year) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_week) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_detailed_blocks) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_dummy_block) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_extension_count) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_descriptor_ordering) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! has_valid_range_descriptor) {
#line 1134
    goto _L___2;
  } else
#line 1134
  if (! manufacturer_name_well_formed) {
    _L___2: /* CIL Label */ 
    {
#line 1145
    conformant = 0;
#line 1146
    printf((char const   */* __restrict  */)"EDID block does not conform at all!\n");
    }
#line 1147
    if (nonconformant_extension) {
      {
#line 1148
      printf((char const   */* __restrict  */)"\tHas at least one nonconformant extension block\n");
      }
    }
#line 1149
    if (! has_valid_checksum) {
      {
#line 1150
      printf((char const   */* __restrict  */)"\tBlock has broken checksum\n");
      }
    }
#line 1151
    if (! has_valid_cvt) {
      {
#line 1152
      printf((char const   */* __restrict  */)"\tBroken 3-byte CVT blocks\n");
      }
    }
#line 1153
    if (! has_valid_year) {
      {
#line 1154
      printf((char const   */* __restrict  */)"\tBad year of manufacture\n");
      }
    }
#line 1155
    if (! has_valid_week) {
      {
#line 1156
      printf((char const   */* __restrict  */)"\tBad week of manufacture\n");
      }
    }
#line 1157
    if (! has_valid_detailed_blocks) {
      {
#line 1158
      printf((char const   */* __restrict  */)"\tDetailed blocks filled with garbage\n");
      }
    }
#line 1159
    if (! has_valid_dummy_block) {
      {
#line 1160
      printf((char const   */* __restrict  */)"\tDummy block filled with garbage\n");
      }
    }
#line 1161
    if (! has_valid_extension_count) {
      {
#line 1162
      printf((char const   */* __restrict  */)"\tImpossible extension block count\n");
      }
    }
#line 1163
    if (! manufacturer_name_well_formed) {
      {
#line 1164
      printf((char const   */* __restrict  */)"\tManufacturer name field contains garbage\n");
      }
    }
#line 1165
    if (! has_valid_descriptor_ordering) {
      {
#line 1166
      printf((char const   */* __restrict  */)"\tInvalid detailed timing descriptor ordering\n");
      }
    }
#line 1167
    if (! has_valid_range_descriptor) {
      {
#line 1168
      printf((char const   */* __restrict  */)"\tRange descriptor contains garbage\n");
      }
    }
#line 1169
    if (! has_valid_max_dotclock) {
      {
#line 1170
      printf((char const   */* __restrict  */)"\tEDID 1.4 block does not set max dotclock\n");
      }
    }
  }
#line 1173
  if (warning_excessive_dotclock_correction) {
    {
#line 1174
    printf((char const   */* __restrict  */)"Warning: CVT block corrects dotclock by more than 9.75MHz\n");
    }
  }
#line 1175
  if (warning_zero_preferred_refresh) {
    {
#line 1176
    printf((char const   */* __restrict  */)"Warning: CVT block does not set preferred refresh rate\n");
    }
  }
  {
#line 1178
  free((void *)edid);
  }
#line 1180
  return (! conformant);
}
}
